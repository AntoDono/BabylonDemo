{
  "version": 3,
  "sources": ["../../../../lts/core/generated/Behaviors/Meshes/fadeInOutBehavior.ts", "../../../../lts/core/generated/Culling/ray.ts", "../../../../lts/core/generated/Misc/pivotTools.ts", "../../../../lts/core/generated/Meshes/Builders/planeBuilder.ts", "../../../../lts/core/generated/Behaviors/Meshes/pointerDragBehavior.ts", "../../../../lts/core/generated/Behaviors/Meshes/baseSixDofDragBehavior.ts", "../../../../lts/core/generated/Behaviors/Meshes/sixDofDragBehavior.ts", "../../../../lts/core/generated/Behaviors/Meshes/surfaceMagnetismBehavior.ts", "../../../../lts/core/generated/Behaviors/Meshes/followBehavior.ts", "../../../../lts/core/generated/XR/webXRFeaturesManager.ts", "../../../../lts/core/generated/XR/features/WebXRAbstractFeature.ts", "../../../../lts/core/generated/Physics/physicsJoint.ts", "../../../../lts/core/generated/Physics/physicsImpostor.ts", "../../../../lts/core/generated/Materials/Node/Enums/nodeMaterialBlockConnectionPointTypes.ts", "../../../../lts/core/generated/Materials/Node/Enums/nodeMaterialBlockTargets.ts", "../../../../lts/core/generated/Materials/Node/nodeMaterialBlockConnectionPoint.ts", "../../../../lts/core/generated/Materials/Node/nodeMaterialBlock.ts", "../../../../lts/core/generated/Materials/Node/Blocks/transformBlock.ts", "../../../../lts/core/generated/Materials/Node/Blocks/Vertex/vertexOutputBlock.ts", "../../../../lts/core/generated/Materials/Node/nodeMaterialDecorator.ts", "../../../../lts/core/generated/Materials/Node/Blocks/Fragment/fragmentOutputBlock.ts", "../../../../lts/core/generated/Materials/Node/Enums/nodeMaterialBlockConnectionPointMode.ts", "../../../../lts/core/generated/Materials/Node/Enums/nodeMaterialSystemValues.ts", "../../../../lts/core/generated/Materials/Node/Blocks/Input/animatedInputBlockTypes.ts", "../../../../lts/core/generated/Materials/Node/Blocks/Input/inputBlock.ts", "../../../../lts/core/generated/Materials/Node/Blocks/Dual/currentScreenBlock.ts", "../../../../lts/core/generated/Materials/Node/Blocks/Particle/particleTextureBlock.ts", "../../../../lts/core/generated/Materials/Node/Blocks/Particle/particleRampGradientBlock.ts", "../../../../lts/core/generated/Materials/Node/Blocks/Particle/particleBlendMultiplyBlock.ts", "../../../../lts/core/generated/Materials/Node/Blocks/vectorMergerBlock.ts", "../../../../lts/core/generated/Materials/Node/Blocks/remapBlock.ts", "../../../../lts/core/generated/Materials/Node/Blocks/multiplyBlock.ts", "../../../../lts/core/generated/Materials/Node/Enums/nodeMaterialModes.ts", "../../../../lts/core/generated/Particles/EmitterTypes/boxParticleEmitter.ts", "../../../../lts/core/generated/Particles/EmitterTypes/coneParticleEmitter.ts", "../../../../lts/core/generated/Particles/EmitterTypes/cylinderParticleEmitter.ts", "../../../../lts/core/generated/Particles/EmitterTypes/hemisphericParticleEmitter.ts", "../../../../lts/core/generated/Particles/EmitterTypes/pointParticleEmitter.ts", "../../../../lts/core/generated/Particles/EmitterTypes/sphereParticleEmitter.ts", "../../../../lts/core/generated/Particles/EmitterTypes/customParticleEmitter.ts", "../../../../lts/core/generated/Particles/EmitterTypes/meshParticleEmitter.ts", "../../../../lts/core/generated/Particles/baseParticleSystem.ts", "../../../../lts/core/generated/Materials/Node/Blocks/colorSplitterBlock.ts", "../../../../lts/core/generated/Materials/Textures/Procedurals/proceduralTextureSceneComponent.ts", "../../../../lts/core/generated/Shaders/procedural.vertex.ts", "../../../../lts/core/generated/Materials/Textures/Procedurals/proceduralTexture.ts", "../../../../lts/core/generated/Materials/Node/Blocks/trigonometryBlock.ts", "../../../../lts/core/generated/Materials/Node/nodeMaterialBuildState.ts", "../../../../lts/core/generated/Materials/Node/nodeMaterialBuildStateSharedData.ts", "../../../../lts/core/generated/Materials/Node/nodeMaterial.ts", "../../../../lts/core/generated/Meshes/Builders/icoSphereBuilder.ts", "../../../../lts/core/generated/XR/features/WebXRHandTracking.ts", "../../../../lts/core/generated/Behaviors/Meshes/handConstraintBehavior.ts", "../../../../lts/core/generated/Engines/Extensions/engine.dynamicTexture.ts", "../../../../lts/core/generated/Materials/Textures/dynamicTexture.ts", "../../../../lts/core/generated/Rendering/utilityLayerRenderer.ts", "../../../../lts/core/generated/Gizmos/gizmo.ts", "../../../../lts/core/generated/Meshes/Builders/boxBuilder.ts", "../../../../lts/core/generated/Events/clipboardEvents.ts", "../../../../lts/core/generated/Layers/layerSceneComponent.ts", "../../../../lts/core/generated/Shaders/layer.fragment.ts", "../../../../lts/core/generated/Shaders/layer.vertex.ts", "../../../../lts/core/generated/Layers/layer.ts"],
  "sourcesContent": ["import type { Behavior } from \"../behavior\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to fade in and out\r\n */\r\nexport class FadeInOutBehavior implements Behavior<Mesh> {\r\n    /**\r\n     * Time in milliseconds to delay before fading in (Default: 0)\r\n     */\r\n    public delay = 0;\r\n    /**\r\n     * Time in milliseconds for the mesh to fade in (Default: 300)\r\n     */\r\n    public fadeInTime = 300;\r\n\r\n    private _millisecondsPerFrame = 1000 / 60;\r\n    private _hovered = false;\r\n    private _hoverValue = 0;\r\n    private _ownerNode: Nullable<Mesh> = null;\r\n\r\n    /**\r\n     * Instantiates the FadeInOutBehavior\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"FadeInOut\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Attaches the fade behavior on the passed in mesh\r\n     * @param ownerNode The mesh that will be faded in/out once attached\r\n     */\r\n    public attach(ownerNode: Mesh): void {\r\n        this._ownerNode = ownerNode;\r\n        this._setAllVisibility(this._ownerNode, 0);\r\n    }\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this._ownerNode = null;\r\n    }\r\n\r\n    /**\r\n     * Triggers the mesh to begin fading in or out\r\n     * @param value if the object should fade in or out (true to fade in)\r\n     */\r\n    public fadeIn(value: boolean) {\r\n        this._hovered = value;\r\n        this._update();\r\n    }\r\n\r\n    private _update = () => {\r\n        if (this._ownerNode) {\r\n            this._hoverValue += this._hovered ? this._millisecondsPerFrame : -this._millisecondsPerFrame;\r\n\r\n            this._setAllVisibility(this._ownerNode, (this._hoverValue - this.delay) / this.fadeInTime);\r\n\r\n            if (this._ownerNode.visibility > 1) {\r\n                this._setAllVisibility(this._ownerNode, 1);\r\n                this._hoverValue = this.fadeInTime + this.delay;\r\n                return;\r\n            } else if (this._ownerNode.visibility < 0) {\r\n                this._setAllVisibility(this._ownerNode, 0);\r\n                if (this._hoverValue < 0) {\r\n                    this._hoverValue = 0;\r\n                    return;\r\n                }\r\n            }\r\n            setTimeout(this._update, this._millisecondsPerFrame);\r\n        }\r\n    };\r\n\r\n    private _setAllVisibility(mesh: AbstractMesh, value: number) {\r\n        mesh.visibility = value;\r\n        mesh.getChildMeshes().forEach((c) => {\r\n            this._setAllVisibility(c, value);\r\n        });\r\n    }\r\n}\r\n", "import type { DeepImmutable, Nullable, float } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { BoundingBox } from \"./boundingBox\";\r\nimport type { BoundingSphere } from \"./boundingSphere\";\r\nimport { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\n\r\n/**\r\n * Class representing a ray with position and direction\r\n */\r\nexport class Ray {\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);\r\n    private static _RayDistant = Ray.Zero();\r\n    private _tmpRay: Ray;\r\n\r\n    /**\r\n     * Creates a new ray\r\n     * @param origin origin point\r\n     * @param direction direction\r\n     * @param length length of the ray\r\n     */\r\n    constructor(\r\n        /** origin point */\r\n        public origin: Vector3,\r\n        /** direction */\r\n        public direction: Vector3,\r\n        /** length of the ray */\r\n        public length: number = Number.MAX_VALUE\r\n    ) {}\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Clone the current ray\r\n     * @returns a new ray\r\n     */\r\n    public clone(): Ray {\r\n        return new Ray(this.origin.clone(), this.direction.clone(), this.length);\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray length by design to improve perfs.\r\n     * @param minimum bound of the box\r\n     * @param maximum bound of the box\r\n     * @param intersectionTreshold extra extend to be added to the box in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBoxMinMax(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, intersectionTreshold: number = 0): boolean {\r\n        const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\r\n        const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\r\n        let d = 0.0;\r\n        let maxValue = Number.MAX_VALUE;\r\n        let inv: number;\r\n        let min: number;\r\n        let max: number;\r\n        let temp: number;\r\n        if (Math.abs(this.direction.x) < 0.0000001) {\r\n            if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.x;\r\n            min = (newMinimum.x - this.origin.x) * inv;\r\n            max = (newMaximum.x - this.origin.x) * inv;\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.y) < 0.0000001) {\r\n            if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.y;\r\n            min = (newMinimum.y - this.origin.y) * inv;\r\n            max = (newMaximum.y - this.origin.y) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.z) < 0.0000001) {\r\n            if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.z;\r\n            min = (newMinimum.z - this.origin.z) * inv;\r\n            max = (newMaximum.z - this.origin.z) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray lenght by design to improve perfs.\r\n     * @param box the bounding box to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBox(box: DeepImmutable<BoundingBox>, intersectionTreshold: number = 0): boolean {\r\n        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a sphere\r\n     * @param sphere the bounding sphere to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\r\n     * @returns true if it hits the sphere\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>, intersectionTreshold: number = 0): boolean {\r\n        const x = sphere.center.x - this.origin.x;\r\n        const y = sphere.center.y - this.origin.y;\r\n        const z = sphere.center.z - this.origin.z;\r\n        const pyth = x * x + y * y + z * z;\r\n        const radius = sphere.radius + intersectionTreshold;\r\n        const rr = radius * radius;\r\n\r\n        if (pyth <= rr) {\r\n            return true;\r\n        }\r\n\r\n        const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\r\n        if (dot < 0.0) {\r\n            return false;\r\n        }\r\n\r\n        const temp = pyth - dot * dot;\r\n\r\n        return temp <= rr;\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a triange\r\n     * @param vertex0 triangle vertex\r\n     * @param vertex1 triangle vertex\r\n     * @param vertex2 triangle vertex\r\n     * @returns intersection information if hit\r\n     */\r\n    public intersectsTriangle(vertex0: DeepImmutable<Vector3>, vertex1: DeepImmutable<Vector3>, vertex2: DeepImmutable<Vector3>): Nullable<IntersectionInfo> {\r\n        const edge1 = Ray._TmpVector3[0];\r\n        const edge2 = Ray._TmpVector3[1];\r\n        const pvec = Ray._TmpVector3[2];\r\n        const tvec = Ray._TmpVector3[3];\r\n        const qvec = Ray._TmpVector3[4];\r\n\r\n        vertex1.subtractToRef(vertex0, edge1);\r\n        vertex2.subtractToRef(vertex0, edge2);\r\n        Vector3.CrossToRef(this.direction, edge2, pvec);\r\n        const det = Vector3.Dot(edge1, pvec);\r\n\r\n        if (det === 0) {\r\n            return null;\r\n        }\r\n\r\n        const invdet = 1 / det;\r\n\r\n        this.origin.subtractToRef(vertex0, tvec);\r\n\r\n        const bv = Vector3.Dot(tvec, pvec) * invdet;\r\n\r\n        if (bv < 0 || bv > 1.0) {\r\n            return null;\r\n        }\r\n\r\n        Vector3.CrossToRef(tvec, edge1, qvec);\r\n\r\n        const bw = Vector3.Dot(this.direction, qvec) * invdet;\r\n\r\n        if (bw < 0 || bv + bw > 1.0) {\r\n            return null;\r\n        }\r\n\r\n        //check if the distance is longer than the predefined length.\r\n        const distance = Vector3.Dot(edge2, qvec) * invdet;\r\n        if (distance > this.length) {\r\n            return null;\r\n        }\r\n\r\n        return new IntersectionInfo(1 - bv - bw, bv, distance);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a plane\r\n     * @param plane the plane to check\r\n     * @returns the distance away it was hit\r\n     */\r\n    public intersectsPlane(plane: DeepImmutable<Plane>): Nullable<number> {\r\n        let distance: number;\r\n        const result1 = Vector3.Dot(plane.normal, this.direction);\r\n        if (Math.abs(result1) < 9.99999997475243e-7) {\r\n            return null;\r\n        } else {\r\n            const result2 = Vector3.Dot(plane.normal, this.origin);\r\n            distance = (-plane.d - result2) / result1;\r\n            if (distance < 0.0) {\r\n                if (distance < -9.99999997475243e-7) {\r\n                    return null;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n\r\n            return distance;\r\n        }\r\n    }\r\n    /**\r\n     * Calculate the intercept of a ray on a given axis\r\n     * @param axis to check 'x' | 'y' | 'z'\r\n     * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\r\n     * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\r\n     */\r\n    public intersectsAxis(axis: string, offset: number = 0): Nullable<Vector3> {\r\n        switch (axis) {\r\n            case \"y\": {\r\n                const t = (this.origin.y - offset) / this.direction.y;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"x\": {\r\n                const t = (this.origin.x - offset) / this.direction.x;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"z\": {\r\n                const t = (this.origin.z - offset) / this.direction.z;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh\r\n     * @param mesh the mesh to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @returns picking info of the intersection\r\n     */\r\n    public intersectsMesh(mesh: DeepImmutable<AbstractMesh>, fastCheck?: boolean): PickingInfo {\r\n        const tm = TmpVectors.Matrix[0];\r\n\r\n        mesh.getWorldMatrix().invertToRef(tm);\r\n\r\n        if (this._tmpRay) {\r\n            Ray.TransformToRef(this, tm, this._tmpRay);\r\n        } else {\r\n            this._tmpRay = Ray.Transform(this, tm);\r\n        }\r\n\r\n        return mesh.intersects(this._tmpRay, fastCheck);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh\r\n     * @param meshes the meshes to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param results array to store result in\r\n     * @returns Array of picking infos\r\n     */\r\n    public intersectsMeshes(meshes: Array<DeepImmutable<AbstractMesh>>, fastCheck?: boolean, results?: Array<PickingInfo>): Array<PickingInfo> {\r\n        if (results) {\r\n            results.length = 0;\r\n        } else {\r\n            results = [];\r\n        }\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const pickInfo = this.intersectsMesh(meshes[i], fastCheck);\r\n\r\n            if (pickInfo.hit) {\r\n                results.push(pickInfo);\r\n            }\r\n        }\r\n\r\n        results.sort(this._comparePickingInfo);\r\n\r\n        return results;\r\n    }\r\n\r\n    private _comparePickingInfo(pickingInfoA: DeepImmutable<PickingInfo>, pickingInfoB: DeepImmutable<PickingInfo>): number {\r\n        if (pickingInfoA.distance < pickingInfoB.distance) {\r\n            return -1;\r\n        } else if (pickingInfoA.distance > pickingInfoB.distance) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    private static _Smallnum = 0.00000001;\r\n    private static _Rayl = 10e8;\r\n\r\n    /**\r\n     * Intersection test between the ray and a given segment within a given tolerance (threshold)\r\n     * @param sega the first point of the segment to test the intersection against\r\n     * @param segb the second point of the segment to test the intersection against\r\n     * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\r\n     * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\r\n     */\r\n    intersectionSegment(sega: DeepImmutable<Vector3>, segb: DeepImmutable<Vector3>, threshold: number): number {\r\n        const o = this.origin;\r\n        const u = TmpVectors.Vector3[0];\r\n        const rsegb = TmpVectors.Vector3[1];\r\n        const v = TmpVectors.Vector3[2];\r\n        const w = TmpVectors.Vector3[3];\r\n\r\n        segb.subtractToRef(sega, u);\r\n\r\n        this.direction.scaleToRef(Ray._Rayl, v);\r\n        o.addToRef(v, rsegb);\r\n\r\n        sega.subtractToRef(o, w);\r\n\r\n        const a = Vector3.Dot(u, u); // always >= 0\r\n        const b = Vector3.Dot(u, v);\r\n        const c = Vector3.Dot(v, v); // always >= 0\r\n        const d = Vector3.Dot(u, w);\r\n        const e = Vector3.Dot(v, w);\r\n        const D = a * c - b * b; // always >= 0\r\n        let sN: number,\r\n            sD = D; // sc = sN / sD, default sD = D >= 0\r\n        let tN: number,\r\n            tD = D; // tc = tN / tD, default tD = D >= 0\r\n\r\n        // compute the line parameters of the two closest points\r\n        if (D < Ray._Smallnum) {\r\n            // the lines are almost parallel\r\n            sN = 0.0; // force using point P0 on segment S1\r\n            sD = 1.0; // to prevent possible division by 0.0 later\r\n            tN = e;\r\n            tD = c;\r\n        } else {\r\n            // get the closest points on the infinite lines\r\n            sN = b * e - c * d;\r\n            tN = a * e - b * d;\r\n            if (sN < 0.0) {\r\n                // sc < 0 => the s=0 edge is visible\r\n                sN = 0.0;\r\n                tN = e;\r\n                tD = c;\r\n            } else if (sN > sD) {\r\n                // sc > 1 => the s=1 edge is visible\r\n                sN = sD;\r\n                tN = e + b;\r\n                tD = c;\r\n            }\r\n        }\r\n\r\n        if (tN < 0.0) {\r\n            // tc < 0 => the t=0 edge is visible\r\n            tN = 0.0;\r\n            // recompute sc for this edge\r\n            if (-d < 0.0) {\r\n                sN = 0.0;\r\n            } else if (-d > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d;\r\n                sD = a;\r\n            }\r\n        } else if (tN > tD) {\r\n            // tc > 1 => the t=1 edge is visible\r\n            tN = tD;\r\n            // recompute sc for this edge\r\n            if (-d + b < 0.0) {\r\n                sN = 0;\r\n            } else if (-d + b > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d + b;\r\n                sD = a;\r\n            }\r\n        }\r\n        // finally do the division to get sc and tc\r\n        const sc = Math.abs(sN) < Ray._Smallnum ? 0.0 : sN / sD;\r\n        const tc = Math.abs(tN) < Ray._Smallnum ? 0.0 : tN / tD;\r\n\r\n        // get the difference of the two closest points\r\n        const qtc = TmpVectors.Vector3[4];\r\n        v.scaleToRef(tc, qtc);\r\n        const qsc = TmpVectors.Vector3[5];\r\n        u.scaleToRef(sc, qsc);\r\n        qsc.addInPlace(w);\r\n        const dP = TmpVectors.Vector3[6];\r\n        qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\r\n\r\n        const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\r\n\r\n        if (isIntersected) {\r\n            return qsc.length();\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Update the ray from viewport position\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n     * @returns this ray updated\r\n     */\r\n    public update(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>,\r\n        enableDistantPicking: boolean = false\r\n    ): Ray {\r\n        if (enableDistantPicking) {\r\n            // With world matrices having great values (like 8000000000 on 1 or more scaling or position axis),\r\n            // multiplying view/projection/world and doing invert will result in loss of float precision in the matrix.\r\n            // One way to fix it is to compute the ray with world at identity then transform the ray in object space.\r\n            // This is slower (2 matrix inverts instead of 1) but precision is preserved.\r\n            // This is hidden behind `EnableDistantPicking` flag (default is false)\r\n            if (!Ray._RayDistant) {\r\n                Ray._RayDistant = Ray.Zero();\r\n            }\r\n\r\n            Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);\r\n\r\n            const tm = TmpVectors.Matrix[0];\r\n            world.invertToRef(tm);\r\n            Ray.TransformToRef(Ray._RayDistant, tm, this);\r\n        } else {\r\n            this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a ray with origin and direction of 0,0,0\r\n     * @returns the new ray\r\n     */\r\n    public static Zero(): Ray {\r\n        return new Ray(Vector3.Zero(), Vector3.Zero());\r\n    }\r\n\r\n    /**\r\n     * Creates a new ray from screen space and viewport\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @returns new ray\r\n     */\r\n    public static CreateNew(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): Ray {\r\n        const result = Ray.Zero();\r\n\r\n        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n    }\r\n\r\n    /**\r\n     * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the new ray\r\n     */\r\n    public static CreateNewFromTo(origin: Vector3, end: Vector3, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        const direction = end.subtract(origin);\r\n        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\r\n        direction.normalize();\r\n\r\n        return Ray.Transform(new Ray(origin, direction, length), world);\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @returns the resulting new ray\r\n     */\r\n    public static Transform(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>): Ray {\r\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        Ray.TransformToRef(ray, matrix, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @param result ray to store result in\r\n     */\r\n    public static TransformToRef(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>, result: Ray): void {\r\n        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\r\n        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\r\n        result.length = ray.length;\r\n\r\n        const dir = result.direction;\r\n        const len = dir.length();\r\n\r\n        if (!(len === 0 || len === 1)) {\r\n            const num = 1.0 / len;\r\n            dir.x *= num;\r\n            dir.y *= num;\r\n            dir.z *= num;\r\n            result.length *= len;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unproject a ray from screen space to object space\r\n     * @param sourceX defines the screen space x coordinate to use\r\n     * @param sourceY defines the screen space y coordinate to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     */\r\n    public unprojectRayToRef(\r\n        sourceX: float,\r\n        sourceY: float,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): void {\r\n        const matrix = TmpVectors.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        matrix.invert();\r\n\r\n        const nearScreenSource = TmpVectors.Vector3[0];\r\n        nearScreenSource.x = (sourceX / viewportWidth) * 2 - 1;\r\n        nearScreenSource.y = -((sourceY / viewportHeight) * 2 - 1);\r\n        nearScreenSource.z = EngineStore.LastCreatedEngine?.isNDCHalfZRange ? 0 : -1;\r\n\r\n        // far Z need to be close but < to 1 or camera projection matrix with maxZ = 0 will NaN\r\n        const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0 - 1e-8);\r\n        const nearVec3 = TmpVectors.Vector3[2];\r\n        const farVec3 = TmpVectors.Vector3[3];\r\n        Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);\r\n        Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);\r\n\r\n        this.origin.copyFrom(nearVec3);\r\n        farVec3.subtractToRef(nearVec3, this.direction);\r\n        this.direction.normalize();\r\n    }\r\n}\r\n\r\n// Picking\r\n/**\r\n * Type used to define predicate used to select faces when a mesh intersection is detected\r\n */\r\nexport type TrianglePickingPredicate = (p0: Vector3, p1: Vector3, p2: Vector3, ray: Ray) => boolean;\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _tempPickingRay: Nullable<Ray>;\r\n\r\n        /** @internal */\r\n        _cachedRayForTransform: Ray;\r\n\r\n        /** @internal */\r\n        _pickWithRayInverseMatrix: Matrix;\r\n\r\n        /** @internal */\r\n        _internalPick(\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            predicate?: (mesh: AbstractMesh) => boolean,\r\n            fastCheck?: boolean,\r\n            onlyBoundingInfo?: boolean,\r\n            trianglePredicate?: TrianglePickingPredicate\r\n        ): Nullable<PickingInfo>;\r\n\r\n        /** @internal */\r\n        _internalMultiPick(\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            predicate?: (mesh: AbstractMesh) => boolean,\r\n            trianglePredicate?: TrianglePickingPredicate\r\n        ): Nullable<PickingInfo[]>;\r\n\r\n        /** @internal */\r\n        _internalPickForMesh(\r\n            pickingInfo: Nullable<PickingInfo>,\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            mesh: AbstractMesh,\r\n            world: Matrix,\r\n            fastCheck?: boolean,\r\n            onlyBoundingInfo?: boolean,\r\n            trianglePredicate?: TrianglePickingPredicate,\r\n            skipBoundingInfo?: boolean\r\n        ): Nullable<PickingInfo>;\r\n    }\r\n}\r\n\r\nScene.prototype.createPickingRay = function (x: number, y: number, world: Nullable<Matrix>, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayToRef = function (\r\n    x: number,\r\n    y: number,\r\n    world: Nullable<Matrix>,\r\n    result: Ray,\r\n    camera: Nullable<Camera>,\r\n    cameraViewSpace = false,\r\n    enableDistantPicking = false\r\n): Scene {\r\n    const engine = this.getEngine();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return this;\r\n        }\r\n\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n\r\n    // Moving coordinates to local viewport world\r\n    x = x / engine.getHardwareScalingLevel() - viewport.x;\r\n    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\r\n\r\n    result.update(\r\n        x,\r\n        y,\r\n        viewport.width,\r\n        viewport.height,\r\n        world ? world : Matrix.IdentityReadOnly,\r\n        cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(),\r\n        camera.getProjectionMatrix(),\r\n        enableDistantPicking\r\n    );\r\n    return this;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpace = function (x: number, y: number, camera?: Camera): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    this.createPickingRayInCameraSpaceToRef(x, y, result, camera);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n    if (!PickingInfo) {\r\n        return this;\r\n    }\r\n\r\n    const engine = this.getEngine();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            throw new Error(\"Active camera not set\");\r\n        }\r\n\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n    const identity = Matrix.Identity();\r\n\r\n    // Moving coordinates to local viewport world\r\n    x = x / engine.getHardwareScalingLevel() - viewport.x;\r\n    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\r\n    result.update(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());\r\n    return this;\r\n};\r\n\r\nScene.prototype._internalPickForMesh = function (\r\n    pickingInfo: Nullable<PickingInfo>,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    mesh: AbstractMesh,\r\n    world: Matrix,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    skipBoundingInfo?: boolean\r\n) {\r\n    const ray = rayFunction(world, mesh.enableDistantPicking);\r\n\r\n    const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\r\n    if (!result || !result.hit) {\r\n        return null;\r\n    }\r\n\r\n    if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n        return null;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype._internalPick = function (\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n\r\n    let pickingInfo = null;\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        const mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const world = mesh.getWorldMatrix();\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            // first check if the ray intersects the whole bounding box/sphere of the mesh\r\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                if (onlyBoundingInfo) {\r\n                    // the user only asked for a bounding info check so we can return\r\n                    return result;\r\n                }\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        pickingInfo = result;\r\n                        pickingInfo.thinInstanceIndex = index;\r\n\r\n                        if (fastCheck) {\r\n                            return pickingInfo;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfo = result;\r\n\r\n                if (fastCheck) {\r\n                    return pickingInfo;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n};\r\n\r\nScene.prototype._internalMultiPick = function (\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const pickingInfos = new Array<PickingInfo>();\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        const mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const world = mesh.getWorldMatrix();\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        result.thinInstanceIndex = index;\r\n                        pickingInfos.push(result);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfos.push(result);\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfos;\r\n};\r\n\r\nScene.prototype.pickWithBoundingInfo = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>\r\n): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const result = this._internalPick(\r\n        (world) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        true\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nObject.defineProperty(Scene.prototype, \"_pickingAvailable\", {\r\n    get: () => true,\r\n    enumerable: false,\r\n    configurable: false,\r\n});\r\n\r\nScene.prototype.pick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    _enableDistantPicking = false\r\n): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const result = this._internalPick(\r\n        (world, enableDistantPicking) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null, false, enableDistantPicking);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.pickWithRay = function (\r\n    ray: Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo> {\r\n    const result = this._internalPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = ray;\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.multiPick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    camera?: Camera,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick((world) => this.createPickingRay(x, y, world, camera || null), predicate, trianglePredicate);\r\n};\r\n\r\nScene.prototype.multiPickWithRay = function (ray: Ray, predicate?: (mesh: AbstractMesh) => boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        trianglePredicate\r\n    );\r\n};\r\n\r\nCamera.prototype.getForwardRay = function (length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\r\n};\r\n\r\nCamera.prototype.getForwardRayToRef = function (refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    if (!transform) {\r\n        transform = this.getWorldMatrix();\r\n    }\r\n    refRay.length = length;\r\n\r\n    if (!origin) {\r\n        refRay.origin.copyFrom(this.position);\r\n    } else {\r\n        refRay.origin.copyFrom(origin);\r\n    }\r\n    TmpVectors.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n    Vector3.TransformNormalToRef(TmpVectors.Vector3[2], transform, TmpVectors.Vector3[3]);\r\n\r\n    Vector3.NormalizeToRef(TmpVectors.Vector3[3], refRay.direction);\r\n\r\n    return refRay;\r\n};\r\n", "import { Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\n\r\n/**\r\n * Class containing a set of static utilities functions for managing Pivots\r\n * @internal\r\n */\r\nexport class PivotTools {\r\n    // Stores the state of the pivot cache (_oldPivotPoint, _pivotTranslation)\r\n    // store/remove pivot point should only be applied during their outermost calls\r\n    private static _PivotCached = 0;\r\n    private static _OldPivotPoint = new Vector3();\r\n    private static _PivotTranslation = new Vector3();\r\n    private static _PivotTmpVector = new Vector3();\r\n    private static _PivotPostMultiplyPivotMatrix = false;\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _RemoveAndStorePivotPoint(mesh: TransformNode) {\r\n        if (mesh && PivotTools._PivotCached === 0) {\r\n            // Save old pivot and set pivot to 0,0,0\r\n            mesh.getPivotPointToRef(PivotTools._OldPivotPoint);\r\n            PivotTools._PivotPostMultiplyPivotMatrix = mesh._postMultiplyPivotMatrix;\r\n            if (!PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0)) {\r\n                mesh.setPivotMatrix(Matrix.IdentityReadOnly);\r\n                PivotTools._OldPivotPoint.subtractToRef(mesh.getPivotPoint(), PivotTools._PivotTranslation);\r\n                PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);\r\n                PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);\r\n                PivotTools._PivotTmpVector.multiplyInPlace(PivotTools._PivotTranslation);\r\n                mesh.position.addInPlace(PivotTools._PivotTmpVector);\r\n            }\r\n        }\r\n        PivotTools._PivotCached++;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _RestorePivotPoint(mesh: TransformNode) {\r\n        if (mesh && !PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0) && PivotTools._PivotCached === 1) {\r\n            mesh.setPivotPoint(PivotTools._OldPivotPoint);\r\n            mesh._postMultiplyPivotMatrix = PivotTools._PivotPostMultiplyPivotMatrix;\r\n            PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);\r\n            PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);\r\n            PivotTools._PivotTmpVector.multiplyInPlace(PivotTools._PivotTranslation);\r\n            mesh.position.subtractInPlace(PivotTools._PivotTmpVector);\r\n        }\r\n        this._PivotCached--;\r\n    }\r\n}\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Plane } from \"../../Maths/math.plane\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Plane\r\n * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n * * size sets the width and height of the plane to the value of size, optional default 1\r\n * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the box\r\n */\r\nexport function CreatePlaneVertexData(options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    const width: number = options.width || options.size || 1;\r\n    const height: number = options.height || options.size || 1;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // Vertices\r\n    const halfWidth = width / 2.0;\r\n    const halfHeight = height / 2.0;\r\n\r\n    positions.push(-halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0.0);\r\n\r\n    positions.push(halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0.0);\r\n\r\n    positions.push(halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0.0 : 1.0);\r\n\r\n    positions.push(-halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0.0 : 1.0);\r\n\r\n    // Indices\r\n    indices.push(0);\r\n    indices.push(1);\r\n    indices.push(2);\r\n\r\n    indices.push(0);\r\n    indices.push(2);\r\n    indices.push(3);\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a plane mesh\r\n * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)\r\n * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)\r\n * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param options.sourcePlane\r\n * @param scene defines the hosting scene\r\n * @returns the plane mesh\r\n * @see https://doc.babylonjs.com/how_to/set_shapes#plane\r\n */\r\nexport function CreatePlane(\r\n    name: string,\r\n    options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4; updatable?: boolean; sourcePlane?: Plane } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const plane = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    plane._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreatePlaneVertexData(options);\r\n\r\n    vertexData.applyToMesh(plane, options.updatable);\r\n\r\n    if (options.sourcePlane) {\r\n        plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);\r\n        plane.setDirection(options.sourcePlane.normal.scale(-1));\r\n    }\r\n\r\n    return plane;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const PlaneBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreatePlane,\r\n};\r\n\r\nVertexData.CreatePlane = CreatePlaneVertexData;\r\n(Mesh as any).CreatePlane = (name: string, size: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        size,\r\n        width: size,\r\n        height: size,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreatePlane(name, options, scene);\r\n};\r\n", "import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PivotTools } from \"../../Misc/pivotTools\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { CreatePlane } from \"../../Meshes/Builders/planeBuilder\";\r\n\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be dragged around the screen based on pointer events\r\n */\r\nexport class PointerDragBehavior implements Behavior<AbstractMesh> {\r\n    private static _AnyMouseId = -2;\r\n    /**\r\n     * Abstract mesh the behavior is set on\r\n     */\r\n    public attachedNode: AbstractMesh;\r\n    private _dragPlane: Mesh;\r\n    private _scene: Scene;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _beforeRenderObserver: Nullable<Observer<Scene>>;\r\n    private static _PlaneScene: Scene;\r\n    private _useAlternatePickedPointAboveMaxDragAngleDragSpeed = -1.1;\r\n    private _activeDragButton: number = -1;\r\n    /**\r\n     * The maximum tolerated angle between the drag plane and dragging pointer rays to trigger pointer events. Set to 0 to allow any angle (default: 0)\r\n     */\r\n    public maxDragAngle = 0;\r\n    /**\r\n     * Butttons that can be used to initiate a drag\r\n     */\r\n    public dragButtons = [0, 1, 2];\r\n    /**\r\n     * @internal\r\n     */\r\n    public _useAlternatePickedPointAboveMaxDragAngle = false;\r\n    /**\r\n     * Get or set the currentDraggingPointerId\r\n     * @deprecated Please use currentDraggingPointerId instead\r\n     */\r\n    public get currentDraggingPointerID(): number {\r\n        return this.currentDraggingPointerId;\r\n    }\r\n    public set currentDraggingPointerID(currentDraggingPointerID: number) {\r\n        this.currentDraggingPointerId = currentDraggingPointerID;\r\n    }\r\n    /**\r\n     * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)\r\n     */\r\n    public currentDraggingPointerId = -1;\r\n    /**\r\n     * The last position where the pointer hit the drag plane in world space\r\n     */\r\n    public lastDragPosition: Vector3;\r\n    /**\r\n     * If the behavior is currently in a dragging state\r\n     */\r\n    public dragging = false;\r\n    /**\r\n     * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)\r\n     */\r\n    public dragDeltaRatio = 0.2;\r\n    /**\r\n     * If the drag plane orientation should be updated during the dragging (Default: true)\r\n     */\r\n    public updateDragPlane = true;\r\n    // Debug mode will display drag planes to help visualize behavior\r\n    private _debugMode = false;\r\n    private _moving = false;\r\n    /**\r\n     *  Fires each time the attached mesh is dragged with the pointer\r\n     *  * delta between last drag position and current drag position in world space\r\n     *  * dragDistance along the drag axis\r\n     *  * dragPlaneNormal normal of the current drag plane used during the drag\r\n     *  * dragPlanePoint in world space where the drag intersects the drag plane\r\n     */\r\n    public onDragObservable = new Observable<{ delta: Vector3; dragPlanePoint: Vector3; dragPlaneNormal: Vector3; dragDistance: number; pointerId: number }>();\r\n    /**\r\n     *  Fires each time a drag begins (eg. mouse down on mesh)\r\n     */\r\n    public onDragStartObservable = new Observable<{ dragPlanePoint: Vector3; pointerId: number }>();\r\n    /**\r\n     *  Fires each time a drag ends (eg. mouse release after drag)\r\n     */\r\n    public onDragEndObservable = new Observable<{ dragPlanePoint: Vector3; pointerId: number }>();\r\n    /**\r\n     *  Fires each time behavior enabled state changes\r\n     */\r\n    public onEnabledObservable = new Observable<boolean>();\r\n\r\n    /**\r\n     *  If the attached mesh should be moved when dragged\r\n     */\r\n    public moveAttached = true;\r\n\r\n    /**\r\n     *  If the drag behavior will react to drag events (Default: true)\r\n     */\r\n    public set enabled(value: boolean) {\r\n        if (value != this._enabled) {\r\n            this.onEnabledObservable.notifyObservers(value);\r\n        }\r\n        this._enabled = value;\r\n    }\r\n\r\n    public get enabled() {\r\n        return this._enabled;\r\n    }\r\n    private _enabled = true;\r\n\r\n    /**\r\n     * If pointer events should start and release the drag (Default: true)\r\n     */\r\n    public startAndReleaseDragOnPointerEvents = true;\r\n    /**\r\n     * If camera controls should be detached during the drag\r\n     */\r\n    public detachCameraControls = true;\r\n\r\n    /**\r\n     * If set, the drag plane/axis will be rotated based on the attached mesh's world rotation (Default: true)\r\n     */\r\n    public useObjectOrientationForDragging = true;\r\n\r\n    private _options: { dragAxis?: Vector3; dragPlaneNormal?: Vector3 };\r\n\r\n    /**\r\n     * Gets the options used by the behavior\r\n     */\r\n    public get options(): { dragAxis?: Vector3; dragPlaneNormal?: Vector3 } {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * Sets the options used by the behavior\r\n     */\r\n    public set options(options: { dragAxis?: Vector3; dragPlaneNormal?: Vector3 }) {\r\n        this._options = options;\r\n    }\r\n\r\n    /**\r\n     * Creates a pointer drag behavior that can be attached to a mesh\r\n     * @param options The drag axis or normal of the plane that will be dragged across. If no options are specified the drag plane will always face the ray's origin (eg. camera)\r\n     * @param options.dragAxis\r\n     * @param options.dragPlaneNormal\r\n     */\r\n    constructor(options?: { dragAxis?: Vector3; dragPlaneNormal?: Vector3 }) {\r\n        this._options = options ? options : {};\r\n\r\n        let optionCount = 0;\r\n        if (this._options.dragAxis) {\r\n            optionCount++;\r\n        }\r\n        if (this._options.dragPlaneNormal) {\r\n            optionCount++;\r\n        }\r\n        if (optionCount > 1) {\r\n            throw \"Multiple drag modes specified in dragBehavior options. Only one expected\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Predicate to determine if it is valid to move the object to a new position when it is moved\r\n     * @param targetPosition\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public validateDrag = (targetPosition: Vector3) => {\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"PointerDrag\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    private _tmpVector = new Vector3(0, 0, 0);\r\n    private _alternatePickedPoint = new Vector3(0, 0, 0);\r\n    private _worldDragAxis = new Vector3(0, 0, 0);\r\n    private _targetPosition = new Vector3(0, 0, 0);\r\n    private _attachedToElement: boolean = false;\r\n    /**\r\n     * Attaches the drag behavior the passed in mesh\r\n     * @param ownerNode The mesh that will be dragged around once attached\r\n     * @param predicate Predicate to use for pick filtering\r\n     */\r\n    public attach(ownerNode: AbstractMesh, predicate?: (m: AbstractMesh) => boolean): void {\r\n        this._scene = ownerNode.getScene();\r\n        ownerNode.isNearGrabbable = true;\r\n        this.attachedNode = ownerNode;\r\n\r\n        // Initialize drag plane to not interfere with existing scene\r\n        if (!PointerDragBehavior._PlaneScene) {\r\n            if (this._debugMode) {\r\n                PointerDragBehavior._PlaneScene = this._scene;\r\n            } else {\r\n                PointerDragBehavior._PlaneScene = new Scene(this._scene.getEngine(), { virtual: true });\r\n                PointerDragBehavior._PlaneScene.detachControl();\r\n                this._scene.onDisposeObservable.addOnce(() => {\r\n                    PointerDragBehavior._PlaneScene.dispose();\r\n                    (<any>PointerDragBehavior._PlaneScene) = null;\r\n                });\r\n            }\r\n        }\r\n        this._dragPlane = CreatePlane(\r\n            \"pointerDragPlane\",\r\n            { size: this._debugMode ? 1 : 10000, updatable: false, sideOrientation: Mesh.DOUBLESIDE },\r\n            PointerDragBehavior._PlaneScene\r\n        );\r\n\r\n        // State of the drag\r\n        this.lastDragPosition = new Vector3(0, 0, 0);\r\n\r\n        const pickPredicate = predicate\r\n            ? predicate\r\n            : (m: AbstractMesh) => {\r\n                  return this.attachedNode == m || m.isDescendantOf(this.attachedNode);\r\n              };\r\n\r\n        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {\r\n            if (!this.enabled) {\r\n                // If behavior is disabled before releaseDrag is ever called, call it now.\r\n                if (this._attachedToElement) {\r\n                    this.releaseDrag();\r\n                    this._activeDragButton = -1;\r\n                }\r\n\r\n                return;\r\n            }\r\n\r\n            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\r\n                if (\r\n                    this.startAndReleaseDragOnPointerEvents &&\r\n                    !this.dragging &&\r\n                    pointerInfo.pickInfo &&\r\n                    pointerInfo.pickInfo.hit &&\r\n                    pointerInfo.pickInfo.pickedMesh &&\r\n                    pointerInfo.pickInfo.pickedPoint &&\r\n                    pointerInfo.pickInfo.ray &&\r\n                    pickPredicate(pointerInfo.pickInfo.pickedMesh)\r\n                ) {\r\n                    if (this._activeDragButton === -1 && this.dragButtons.indexOf(pointerInfo.event.button) !== -1) {\r\n                        this._activeDragButton = pointerInfo.event.button;\r\n                        this._startDrag((<IPointerEvent>pointerInfo.event).pointerId, pointerInfo.pickInfo.ray, pointerInfo.pickInfo.pickedPoint);\r\n                    }\r\n                }\r\n            } else if (pointerInfo.type == PointerEventTypes.POINTERUP) {\r\n                if (\r\n                    this.startAndReleaseDragOnPointerEvents &&\r\n                    this.currentDraggingPointerId == (<IPointerEvent>pointerInfo.event).pointerId &&\r\n                    this._activeDragButton === pointerInfo.event.button\r\n                ) {\r\n                    this.releaseDrag();\r\n                    this._activeDragButton = -1;\r\n                }\r\n            } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {\r\n                const pointerId = (<IPointerEvent>pointerInfo.event).pointerId;\r\n\r\n                // If drag was started with anyMouseID specified, set pointerID to the next mouse that moved\r\n                if (this.currentDraggingPointerId === PointerDragBehavior._AnyMouseId && pointerId !== PointerDragBehavior._AnyMouseId) {\r\n                    const evt = <IPointerEvent>pointerInfo.event;\r\n                    const isMouseEvent = evt.pointerType === \"mouse\" || (!this._scene.getEngine().hostInformation.isMobile && evt instanceof MouseEvent);\r\n                    if (isMouseEvent) {\r\n                        if (this._lastPointerRay[this.currentDraggingPointerId]) {\r\n                            this._lastPointerRay[pointerId] = this._lastPointerRay[this.currentDraggingPointerId];\r\n                            delete this._lastPointerRay[this.currentDraggingPointerId];\r\n                        }\r\n                        this.currentDraggingPointerId = pointerId;\r\n                    }\r\n                }\r\n\r\n                // Keep track of last pointer ray, this is used simulating the start of a drag in startDrag()\r\n                if (!this._lastPointerRay[pointerId]) {\r\n                    this._lastPointerRay[pointerId] = new Ray(new Vector3(), new Vector3());\r\n                }\r\n                if (pointerInfo.pickInfo && pointerInfo.pickInfo.ray) {\r\n                    this._lastPointerRay[pointerId].origin.copyFrom(pointerInfo.pickInfo.ray.origin);\r\n                    this._lastPointerRay[pointerId].direction.copyFrom(pointerInfo.pickInfo.ray.direction);\r\n\r\n                    if (this.currentDraggingPointerId == pointerId && this.dragging) {\r\n                        this._moveDrag(pointerInfo.pickInfo.ray);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        this._beforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n            if (this._moving && this.moveAttached) {\r\n                let needMatrixUpdate = false;\r\n                PivotTools._RemoveAndStorePivotPoint(this.attachedNode);\r\n                // Slowly move mesh to avoid jitter\r\n                this._targetPosition.subtractToRef(this.attachedNode.absolutePosition, this._tmpVector);\r\n                this._tmpVector.scaleInPlace(this.dragDeltaRatio);\r\n                this.attachedNode.getAbsolutePosition().addToRef(this._tmpVector, this._tmpVector);\r\n                if (this.validateDrag(this._tmpVector)) {\r\n                    this.attachedNode.setAbsolutePosition(this._tmpVector);\r\n                    needMatrixUpdate = true;\r\n                }\r\n                PivotTools._RestorePivotPoint(this.attachedNode);\r\n                if (needMatrixUpdate) {\r\n                    this.attachedNode.computeWorldMatrix();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Force release the drag action by code.\r\n     */\r\n    public releaseDrag() {\r\n        if (this.dragging) {\r\n            this.dragging = false;\r\n            this.onDragEndObservable.notifyObservers({ dragPlanePoint: this.lastDragPosition, pointerId: this.currentDraggingPointerId });\r\n        }\r\n\r\n        this.currentDraggingPointerId = -1;\r\n        this._moving = false;\r\n\r\n        // Reattach camera controls\r\n        if (this.detachCameraControls && this._attachedToElement && this._scene.activeCamera && !this._scene.activeCamera.leftCamera) {\r\n            if (this._scene.activeCamera.getClassName() === \"ArcRotateCamera\") {\r\n                const arcRotateCamera = this._scene.activeCamera as ArcRotateCamera;\r\n                arcRotateCamera.attachControl(\r\n                    arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true,\r\n                    arcRotateCamera._useCtrlForPanning,\r\n                    arcRotateCamera._panningMouseButton\r\n                );\r\n            } else {\r\n                this._scene.activeCamera.attachControl(this._scene.activeCamera.inputs ? this._scene.activeCamera.inputs.noPreventDefault : true);\r\n            }\r\n            this._attachedToElement = false;\r\n        }\r\n    }\r\n\r\n    private _startDragRay = new Ray(new Vector3(), new Vector3());\r\n    private _lastPointerRay: { [key: number]: Ray } = {};\r\n    /**\r\n     * Simulates the start of a pointer drag event on the behavior\r\n     * @param pointerId pointerID of the pointer that should be simulated (Default: Any mouse pointer ID)\r\n     * @param fromRay initial ray of the pointer to be simulated (Default: Ray from camera to attached mesh)\r\n     * @param startPickedPoint picked point of the pointer to be simulated (Default: attached mesh position)\r\n     */\r\n    public startDrag(pointerId: number = PointerDragBehavior._AnyMouseId, fromRay?: Ray, startPickedPoint?: Vector3) {\r\n        this._startDrag(pointerId, fromRay, startPickedPoint);\r\n\r\n        let lastRay = this._lastPointerRay[pointerId];\r\n        if (pointerId === PointerDragBehavior._AnyMouseId) {\r\n            lastRay = this._lastPointerRay[<any>Object.keys(this._lastPointerRay)[0]];\r\n        }\r\n\r\n        if (lastRay) {\r\n            // if there was a last pointer ray drag the object there\r\n            this._moveDrag(lastRay);\r\n        }\r\n    }\r\n\r\n    protected _startDrag(pointerId: number, fromRay?: Ray, startPickedPoint?: Vector3) {\r\n        if (!this._scene.activeCamera || this.dragging || !this.attachedNode) {\r\n            return;\r\n        }\r\n\r\n        PivotTools._RemoveAndStorePivotPoint(this.attachedNode);\r\n        // Create start ray from the camera to the object\r\n        if (fromRay) {\r\n            this._startDragRay.direction.copyFrom(fromRay.direction);\r\n            this._startDragRay.origin.copyFrom(fromRay.origin);\r\n        } else {\r\n            this._startDragRay.origin.copyFrom(this._scene.activeCamera.position);\r\n            this.attachedNode.getWorldMatrix().getTranslationToRef(this._tmpVector);\r\n            this._tmpVector.subtractToRef(this._scene.activeCamera.position, this._startDragRay.direction);\r\n        }\r\n\r\n        this._updateDragPlanePosition(this._startDragRay, startPickedPoint ? startPickedPoint : this._tmpVector);\r\n\r\n        const pickedPoint = this._pickWithRayOnDragPlane(this._startDragRay);\r\n        if (pickedPoint) {\r\n            this.dragging = true;\r\n            this.currentDraggingPointerId = pointerId;\r\n            this.lastDragPosition.copyFrom(pickedPoint);\r\n            this.onDragStartObservable.notifyObservers({ dragPlanePoint: pickedPoint, pointerId: this.currentDraggingPointerId });\r\n            this._targetPosition.copyFrom(this.attachedNode.getAbsolutePosition());\r\n\r\n            // Detatch camera controls\r\n            if (this.detachCameraControls && this._scene.activeCamera && this._scene.activeCamera.inputs && !this._scene.activeCamera.leftCamera) {\r\n                if (this._scene.activeCamera.inputs.attachedToElement) {\r\n                    this._scene.activeCamera.detachControl();\r\n                    this._attachedToElement = true;\r\n                } else {\r\n                    this._attachedToElement = false;\r\n                }\r\n            }\r\n        }\r\n        PivotTools._RestorePivotPoint(this.attachedNode);\r\n    }\r\n\r\n    private _dragDelta = new Vector3();\r\n    protected _moveDrag(ray: Ray) {\r\n        this._moving = true;\r\n        const pickedPoint = this._pickWithRayOnDragPlane(ray);\r\n\r\n        if (pickedPoint) {\r\n            PivotTools._RemoveAndStorePivotPoint(this.attachedNode);\r\n\r\n            if (this.updateDragPlane) {\r\n                this._updateDragPlanePosition(ray, pickedPoint);\r\n            }\r\n            let dragLength = 0;\r\n            // depending on the drag mode option drag accordingly\r\n            if (this._options.dragAxis) {\r\n                // Convert local drag axis to world if useObjectOrientationForDragging\r\n                this.useObjectOrientationForDragging\r\n                    ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._worldDragAxis)\r\n                    : this._worldDragAxis.copyFrom(this._options.dragAxis);\r\n\r\n                // Project delta drag from the drag plane onto the drag axis\r\n                pickedPoint.subtractToRef(this.lastDragPosition, this._tmpVector);\r\n                dragLength = Vector3.Dot(this._tmpVector, this._worldDragAxis);\r\n                this._worldDragAxis.scaleToRef(dragLength, this._dragDelta);\r\n            } else {\r\n                dragLength = this._dragDelta.length();\r\n                pickedPoint.subtractToRef(this.lastDragPosition, this._dragDelta);\r\n            }\r\n            this._targetPosition.addInPlace(this._dragDelta);\r\n            this.onDragObservable.notifyObservers({\r\n                dragDistance: dragLength,\r\n                delta: this._dragDelta,\r\n                dragPlanePoint: pickedPoint,\r\n                dragPlaneNormal: this._dragPlane.forward,\r\n                pointerId: this.currentDraggingPointerId,\r\n            });\r\n            this.lastDragPosition.copyFrom(pickedPoint);\r\n\r\n            PivotTools._RestorePivotPoint(this.attachedNode);\r\n        }\r\n    }\r\n\r\n    private _pickWithRayOnDragPlane(ray: Nullable<Ray>) {\r\n        if (!ray) {\r\n            return null;\r\n        }\r\n\r\n        // Calculate angle between plane normal and ray\r\n        let angle = Math.acos(Vector3.Dot(this._dragPlane.forward, ray.direction));\r\n        // Correct if ray is casted from oposite side\r\n        if (angle > Math.PI / 2) {\r\n            angle = Math.PI - angle;\r\n        }\r\n\r\n        // If the angle is too perpendicular to the plane pick another point on the plane where it is looking\r\n        if (this.maxDragAngle > 0 && angle > this.maxDragAngle) {\r\n            if (this._useAlternatePickedPointAboveMaxDragAngle) {\r\n                // Invert ray direction along the towards object axis\r\n                this._tmpVector.copyFrom(ray.direction);\r\n                this.attachedNode.absolutePosition.subtractToRef(ray.origin, this._alternatePickedPoint);\r\n                this._alternatePickedPoint.normalize();\r\n                this._alternatePickedPoint.scaleInPlace(this._useAlternatePickedPointAboveMaxDragAngleDragSpeed * Vector3.Dot(this._alternatePickedPoint, this._tmpVector));\r\n                this._tmpVector.addInPlace(this._alternatePickedPoint);\r\n\r\n                // Project resulting vector onto the drag plane and add it to the attached nodes absolute position to get a picked point\r\n                const dot = Vector3.Dot(this._dragPlane.forward, this._tmpVector);\r\n                this._dragPlane.forward.scaleToRef(-dot, this._alternatePickedPoint);\r\n                this._alternatePickedPoint.addInPlace(this._tmpVector);\r\n                this._alternatePickedPoint.addInPlace(this.attachedNode.absolutePosition);\r\n                return this._alternatePickedPoint;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const pickResult = PointerDragBehavior._PlaneScene.pickWithRay(ray, (m) => {\r\n            return m == this._dragPlane;\r\n        });\r\n        if (pickResult && pickResult.hit && pickResult.pickedMesh && pickResult.pickedPoint) {\r\n            return pickResult.pickedPoint;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Variables to avoid instantiation in the below method\r\n    private _pointA = new Vector3(0, 0, 0);\r\n    private _pointC = new Vector3(0, 0, 0);\r\n    private _localAxis = new Vector3(0, 0, 0);\r\n    private _lookAt = new Vector3(0, 0, 0);\r\n    // Position the drag plane based on the attached mesh position, for single axis rotate the plane along the axis to face the camera\r\n    private _updateDragPlanePosition(ray: Ray, dragPlanePosition: Vector3) {\r\n        this._pointA.copyFrom(dragPlanePosition);\r\n        if (this._options.dragAxis) {\r\n            this.useObjectOrientationForDragging\r\n                ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis)\r\n                : this._localAxis.copyFrom(this._options.dragAxis);\r\n\r\n            // Calculate plane normal that is the cross product of local axis and (eye-dragPlanePosition)\r\n            ray.origin.subtractToRef(this._pointA, this._pointC);\r\n            this._pointC.normalize();\r\n            if (Math.abs(Vector3.Dot(this._localAxis, this._pointC)) > 0.999) {\r\n                // the drag axis is colinear with the (eye to position) ray. The cross product will give jittered values.\r\n                // A new axis vector need to be computed\r\n                if (Math.abs(Vector3.Dot(Vector3.UpReadOnly, this._pointC)) > 0.999) {\r\n                    this._lookAt.copyFrom(Vector3.Right());\r\n                } else {\r\n                    this._lookAt.copyFrom(Vector3.UpReadOnly);\r\n                }\r\n            } else {\r\n                Vector3.CrossToRef(this._localAxis, this._pointC, this._lookAt);\r\n                // Get perpendicular line from previous result and drag axis to adjust lineB to be perpendicular to camera\r\n                Vector3.CrossToRef(this._localAxis, this._lookAt, this._lookAt);\r\n                this._lookAt.normalize();\r\n            }\r\n\r\n            this._dragPlane.position.copyFrom(this._pointA);\r\n            this._pointA.addToRef(this._lookAt, this._lookAt);\r\n            this._dragPlane.lookAt(this._lookAt);\r\n        } else if (this._options.dragPlaneNormal) {\r\n            this.useObjectOrientationForDragging\r\n                ? Vector3.TransformCoordinatesToRef(this._options.dragPlaneNormal, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis)\r\n                : this._localAxis.copyFrom(this._options.dragPlaneNormal);\r\n            this._dragPlane.position.copyFrom(this._pointA);\r\n            this._pointA.addToRef(this._localAxis, this._lookAt);\r\n            this._dragPlane.lookAt(this._lookAt);\r\n        } else {\r\n            this._dragPlane.position.copyFrom(this._pointA);\r\n            this._dragPlane.lookAt(ray.origin);\r\n        }\r\n        // Update the position of the drag plane so it doesn't get out of sync with the node (eg. when moving back and forth quickly)\r\n        this._dragPlane.position.copyFrom(this.attachedNode.getAbsolutePosition());\r\n\r\n        this._dragPlane.computeWorldMatrix(true);\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this._lastPointerRay = {};\r\n        if (this.attachedNode) {\r\n            this.attachedNode.isNearGrabbable = false;\r\n        }\r\n        if (this._pointerObserver) {\r\n            this._scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n        if (this._beforeRenderObserver) {\r\n            this._scene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\r\n        }\r\n        if (this._dragPlane) {\r\n            this._dragPlane.dispose();\r\n        }\r\n        this.releaseDrag();\r\n        this._activeDragButton = -1;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Data store to track virtual pointers movement\r\n */\r\ntype VirtualMeshInfo = {\r\n    dragging: boolean;\r\n    moving: boolean;\r\n    dragMesh: AbstractMesh;\r\n    originMesh: AbstractMesh;\r\n    pivotMesh: AbstractMesh;\r\n    startingPivotPosition: Vector3;\r\n    startingPivotOrientation: Quaternion;\r\n    startingPosition: Vector3;\r\n    startingOrientation: Quaternion;\r\n    lastOriginPosition: Vector3;\r\n    lastDragPosition: Vector3;\r\n};\r\n\r\n/**\r\n * Base behavior for six degrees of freedom interactions in XR experiences.\r\n * Creates virtual meshes that are dragged around\r\n * And observables for position/rotation changes\r\n */\r\nexport class BaseSixDofDragBehavior implements Behavior<Mesh> {\r\n    protected static _virtualScene: Scene;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _attachedToElement: boolean = false;\r\n    protected _virtualMeshesInfo: {\r\n        [id: number]: VirtualMeshInfo;\r\n    } = {};\r\n\r\n    private _tmpVector: Vector3 = new Vector3();\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n\r\n    protected _dragType = {\r\n        NONE: 0,\r\n        DRAG: 1,\r\n        DRAG_WITH_CONTROLLER: 2,\r\n        NEAR_DRAG: 3,\r\n    };\r\n\r\n    protected _scene: Scene;\r\n    protected _moving = false;\r\n    protected _ownerNode: TransformNode;\r\n    protected _dragging = this._dragType.NONE;\r\n\r\n    /**\r\n     * The list of child meshes that can receive drag events\r\n     * If `null`, all child meshes will receive drag event\r\n     */\r\n    public draggableMeshes: Nullable<AbstractMesh[]> = null;\r\n\r\n    /**\r\n     * How much faster the object should move when the controller is moving towards it. This is useful to bring objects that are far away from the user to them faster. Set this to 0 to avoid any speed increase. (Default: 3)\r\n     */\r\n    public zDragFactor = 3;\r\n    /**\r\n     * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)\r\n     */\r\n    public get currentDraggingPointerId() {\r\n        if (this.currentDraggingPointerIds[0] !== undefined) {\r\n            return this.currentDraggingPointerIds[0];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public set currentDraggingPointerId(value: number) {\r\n        this.currentDraggingPointerIds[0] = value;\r\n    }\r\n\r\n    /**\r\n     * In case of multipointer interaction, all pointer ids currently active are stored here\r\n     */\r\n    public currentDraggingPointerIds: number[] = [];\r\n\r\n    /**\r\n     * Get or set the currentDraggingPointerId\r\n     * @deprecated Please use currentDraggingPointerId instead\r\n     */\r\n    public get currentDraggingPointerID(): number {\r\n        return this.currentDraggingPointerId;\r\n    }\r\n    public set currentDraggingPointerID(currentDraggingPointerID: number) {\r\n        this.currentDraggingPointerId = currentDraggingPointerID;\r\n    }\r\n    /**\r\n    /**\r\n     * If camera controls should be detached during the drag\r\n     */\r\n    public detachCameraControls = true;\r\n\r\n    /**\r\n     * Fires each time a drag starts\r\n     */\r\n    public onDragStartObservable = new Observable<{ position: Vector3 }>();\r\n    /**\r\n     * Fires each time a drag happens\r\n     */\r\n    public onDragObservable = new Observable<{ delta: Vector3; position: Vector3; pickInfo: PickingInfo }>();\r\n    /**\r\n     *  Fires each time a drag ends (eg. mouse release after drag)\r\n     */\r\n    public onDragEndObservable = new Observable<{}>();\r\n\r\n    /**\r\n     * Should the behavior allow simultaneous pointers to interact with the owner node.\r\n     */\r\n    public allowMultiPointer: boolean = true;\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"BaseSixDofDrag\";\r\n    }\r\n\r\n    /**\r\n     *  Returns true if the attached mesh is currently moving with this behavior\r\n     */\r\n    public get isMoving(): boolean {\r\n        return this._moving;\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * In the case of multiple active cameras, the cameraToUseForPointers should be used if set instead of active camera\r\n     */\r\n    private get _pointerCamera() {\r\n        if (this._scene.cameraToUseForPointers) {\r\n            return this._scene.cameraToUseForPointers;\r\n        } else {\r\n            return this._scene.activeCamera;\r\n        }\r\n    }\r\n\r\n    private _createVirtualMeshInfo() {\r\n        // Setup virtual meshes to be used for dragging without dirtying the existing scene\r\n\r\n        const dragMesh = new AbstractMesh(\"\", BaseSixDofDragBehavior._virtualScene);\r\n        dragMesh.rotationQuaternion = new Quaternion();\r\n        const originMesh = new AbstractMesh(\"\", BaseSixDofDragBehavior._virtualScene);\r\n        originMesh.rotationQuaternion = new Quaternion();\r\n        const pivotMesh = new AbstractMesh(\"\", BaseSixDofDragBehavior._virtualScene);\r\n        pivotMesh.rotationQuaternion = new Quaternion();\r\n\r\n        return {\r\n            dragging: false,\r\n            moving: false,\r\n            dragMesh,\r\n            originMesh,\r\n            pivotMesh,\r\n            startingPivotPosition: new Vector3(),\r\n            startingPivotOrientation: new Quaternion(),\r\n            startingPosition: new Vector3(),\r\n            startingOrientation: new Quaternion(),\r\n            lastOriginPosition: new Vector3(),\r\n            lastDragPosition: new Vector3(),\r\n        };\r\n    }\r\n\r\n    protected _resetVirtualMeshesPosition() {\r\n        for (let i = 0; i < this.currentDraggingPointerIds.length; i++) {\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion!.copyFrom(this._ownerNode.rotationQuaternion!);\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotPosition.copyFrom(\r\n                this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position\r\n            );\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotOrientation.copyFrom(\r\n                this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion!\r\n            );\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.position);\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingOrientation.copyFrom(\r\n                this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.rotationQuaternion!\r\n            );\r\n        }\r\n    }\r\n\r\n    private _pointerUpdate2D(ray: Ray, pointerId: number, zDragFactor: number) {\r\n        if (this._pointerCamera && this._pointerCamera.cameraRigMode == Camera.RIG_MODE_NONE && !this._pointerCamera._isLeftCamera && !this._pointerCamera._isRightCamera) {\r\n            ray.origin.copyFrom(this._pointerCamera!.globalPosition);\r\n            zDragFactor = 0;\r\n        }\r\n\r\n        const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\r\n\r\n        // Calculate controller drag distance in controller space\r\n        const originDragDifference = TmpVectors.Vector3[0];\r\n        ray.origin.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDifference);\r\n        virtualMeshesInfo.lastOriginPosition.copyFrom(ray.origin);\r\n        const localOriginDragDifference = -Vector3.Dot(originDragDifference, ray.direction);\r\n\r\n        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.dragMesh);\r\n        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.pivotMesh);\r\n\r\n        this._applyZOffset(virtualMeshesInfo.dragMesh, localOriginDragDifference, zDragFactor);\r\n        this._applyZOffset(virtualMeshesInfo.pivotMesh, localOriginDragDifference, zDragFactor);\r\n\r\n        // Update the controller position\r\n        virtualMeshesInfo.originMesh.position.copyFrom(ray.origin);\r\n        const lookAt = TmpVectors.Vector3[0];\r\n        ray.origin.addToRef(ray.direction, lookAt);\r\n        virtualMeshesInfo.originMesh.lookAt(lookAt);\r\n\r\n        virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);\r\n        virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);\r\n    }\r\n\r\n    private _pointerUpdateXR(controllerAimTransform: TransformNode, controllerGripTransform: Nullable<TransformNode>, pointerId: number, zDragFactor: number) {\r\n        const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\r\n        virtualMeshesInfo.originMesh.position.copyFrom(controllerAimTransform.position);\r\n        if (this._dragging === this._dragType.NEAR_DRAG && controllerGripTransform) {\r\n            virtualMeshesInfo.originMesh.rotationQuaternion!.copyFrom(controllerGripTransform.rotationQuaternion!);\r\n        } else {\r\n            virtualMeshesInfo.originMesh.rotationQuaternion!.copyFrom(controllerAimTransform.rotationQuaternion!);\r\n        }\r\n\r\n        virtualMeshesInfo.pivotMesh.computeWorldMatrix(true);\r\n        virtualMeshesInfo.dragMesh.computeWorldMatrix(true);\r\n\r\n        // Z scaling logic\r\n        if (zDragFactor !== 0) {\r\n            // Camera.getForwardRay modifies TmpVectors.Vector[0-3], so cache it in advance\r\n            const cameraForwardVec = TmpVectors.Vector3[0];\r\n            const originDragDirection = TmpVectors.Vector3[1];\r\n            cameraForwardVec.copyFrom(this._pointerCamera!.getForwardRay().direction);\r\n            virtualMeshesInfo.originMesh.position.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDirection);\r\n            virtualMeshesInfo.lastOriginPosition.copyFrom(virtualMeshesInfo.originMesh.position);\r\n            const controllerDragDistance = originDragDirection.length();\r\n            originDragDirection.normalize();\r\n\r\n            const cameraToDrag = TmpVectors.Vector3[2];\r\n            const controllerToDrag = TmpVectors.Vector3[3];\r\n            virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(this._pointerCamera!.globalPosition, cameraToDrag);\r\n            virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(virtualMeshesInfo.originMesh.position, controllerToDrag);\r\n            const controllerToDragDistance = controllerToDrag.length();\r\n            cameraToDrag.normalize();\r\n            controllerToDrag.normalize();\r\n\r\n            const controllerDragScaling = Math.abs(Vector3.Dot(originDragDirection, controllerToDrag)) * Vector3.Dot(originDragDirection, cameraForwardVec);\r\n            let zOffsetScaling = controllerDragScaling * zDragFactor * controllerDragDistance * controllerToDragDistance;\r\n\r\n            // Prevent pulling the mesh through the controller\r\n            const minDistanceFromControllerToDragMesh = 0.01;\r\n            if (zOffsetScaling < 0 && minDistanceFromControllerToDragMesh - controllerToDragDistance > zOffsetScaling) {\r\n                zOffsetScaling = Math.min(minDistanceFromControllerToDragMesh - controllerToDragDistance, 0);\r\n            }\r\n            controllerToDrag.scaleInPlace(zOffsetScaling);\r\n\r\n            controllerToDrag.addToRef(virtualMeshesInfo.pivotMesh.absolutePosition, this._tmpVector);\r\n            virtualMeshesInfo.pivotMesh.setAbsolutePosition(this._tmpVector);\r\n            controllerToDrag.addToRef(virtualMeshesInfo.dragMesh.absolutePosition, this._tmpVector);\r\n            virtualMeshesInfo.dragMesh.setAbsolutePosition(this._tmpVector);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attaches the scale behavior the passed in mesh\r\n     * @param ownerNode The mesh that will be scaled around once attached\r\n     */\r\n    public attach(ownerNode: TransformNode): void {\r\n        this._ownerNode = ownerNode;\r\n        this._scene = this._ownerNode.getScene();\r\n        if (!BaseSixDofDragBehavior._virtualScene) {\r\n            BaseSixDofDragBehavior._virtualScene = new Scene(this._scene.getEngine(), { virtual: true });\r\n            BaseSixDofDragBehavior._virtualScene.detachControl();\r\n        }\r\n\r\n        const pickPredicate = (m: AbstractMesh) => {\r\n            return this._ownerNode === m || (m.isDescendantOf(this._ownerNode) && (!this.draggableMeshes || this.draggableMeshes.indexOf(m) !== -1));\r\n        };\r\n\r\n        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {\r\n            const pointerId = (<IPointerEvent>pointerInfo.event).pointerId;\r\n            if (!this._virtualMeshesInfo[pointerId]) {\r\n                this._virtualMeshesInfo[pointerId] = this._createVirtualMeshInfo();\r\n            }\r\n            const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\r\n            const isXRNearPointer = (<IPointerEvent>pointerInfo.event).pointerType === \"xr-near\";\r\n\r\n            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\r\n                if (\r\n                    !virtualMeshesInfo.dragging &&\r\n                    pointerInfo.pickInfo &&\r\n                    pointerInfo.pickInfo.hit &&\r\n                    pointerInfo.pickInfo.pickedMesh &&\r\n                    pointerInfo.pickInfo.pickedPoint &&\r\n                    pointerInfo.pickInfo.ray &&\r\n                    (!isXRNearPointer || pointerInfo.pickInfo.aimTransform) &&\r\n                    pickPredicate(pointerInfo.pickInfo.pickedMesh)\r\n                ) {\r\n                    if (!this.allowMultiPointer && this.currentDraggingPointerIds.length > 0) {\r\n                        return;\r\n                    }\r\n\r\n                    if (\r\n                        this._pointerCamera &&\r\n                        this._pointerCamera.cameraRigMode === Camera.RIG_MODE_NONE &&\r\n                        !this._pointerCamera._isLeftCamera &&\r\n                        !this._pointerCamera._isRightCamera\r\n                    ) {\r\n                        pointerInfo.pickInfo.ray.origin.copyFrom(this._pointerCamera!.globalPosition);\r\n                    }\r\n\r\n                    this._ownerNode.computeWorldMatrix(true);\r\n                    const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\r\n\r\n                    if (isXRNearPointer) {\r\n                        this._dragging = pointerInfo.pickInfo.originMesh ? this._dragType.NEAR_DRAG : this._dragType.DRAG_WITH_CONTROLLER;\r\n                        virtualMeshesInfo.originMesh.position.copyFrom(pointerInfo.pickInfo.aimTransform!.position);\r\n                        if (this._dragging === this._dragType.NEAR_DRAG && pointerInfo.pickInfo.gripTransform) {\r\n                            virtualMeshesInfo.originMesh.rotationQuaternion!.copyFrom(pointerInfo.pickInfo.gripTransform.rotationQuaternion!);\r\n                        } else {\r\n                            virtualMeshesInfo.originMesh.rotationQuaternion!.copyFrom(pointerInfo.pickInfo.aimTransform!.rotationQuaternion!);\r\n                        }\r\n                    } else {\r\n                        this._dragging = this._dragType.DRAG;\r\n                        virtualMeshesInfo.originMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);\r\n                    }\r\n\r\n                    virtualMeshesInfo.lastOriginPosition.copyFrom(virtualMeshesInfo.originMesh.position);\r\n\r\n                    virtualMeshesInfo.dragMesh.position.copyFrom(pointerInfo.pickInfo.pickedPoint);\r\n                    virtualMeshesInfo.lastDragPosition.copyFrom(pointerInfo.pickInfo.pickedPoint);\r\n\r\n                    virtualMeshesInfo.pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());\r\n                    virtualMeshesInfo.pivotMesh.rotationQuaternion!.copyFrom(this._ownerNode.absoluteRotationQuaternion);\r\n\r\n                    virtualMeshesInfo.startingPosition.copyFrom(virtualMeshesInfo.dragMesh.position);\r\n                    virtualMeshesInfo.startingPivotPosition.copyFrom(virtualMeshesInfo.pivotMesh.position);\r\n                    virtualMeshesInfo.startingOrientation.copyFrom(virtualMeshesInfo.dragMesh.rotationQuaternion!);\r\n                    virtualMeshesInfo.startingPivotOrientation.copyFrom(virtualMeshesInfo.pivotMesh.rotationQuaternion!);\r\n\r\n                    if (isXRNearPointer) {\r\n                        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.dragMesh);\r\n                        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.pivotMesh);\r\n                    } else {\r\n                        virtualMeshesInfo.originMesh.lookAt(virtualMeshesInfo.dragMesh.position);\r\n                    }\r\n\r\n                    // Update state\r\n                    virtualMeshesInfo.dragging = true;\r\n\r\n                    if (this.currentDraggingPointerIds.indexOf(pointerId) === -1) {\r\n                        this.currentDraggingPointerIds.push(pointerId);\r\n                    }\r\n\r\n                    // Detach camera controls\r\n                    if (this.detachCameraControls && this._pointerCamera && !this._pointerCamera.leftCamera) {\r\n                        if (this._pointerCamera.inputs && this._pointerCamera.inputs.attachedToElement) {\r\n                            this._pointerCamera.detachControl();\r\n                            this._attachedToElement = true;\r\n                        } else {\r\n                            this._attachedToElement = false;\r\n                        }\r\n                    }\r\n\r\n                    this._targetDragStart(virtualMeshesInfo.pivotMesh.position, virtualMeshesInfo.pivotMesh.rotationQuaternion!, pointerId);\r\n                    this.onDragStartObservable.notifyObservers({ position: virtualMeshesInfo.pivotMesh.position });\r\n                }\r\n            } else if (pointerInfo.type == PointerEventTypes.POINTERUP || pointerInfo.type == PointerEventTypes.POINTERDOUBLETAP) {\r\n                const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);\r\n\r\n                // Update state\r\n                virtualMeshesInfo.dragging = false;\r\n\r\n                if (registeredPointerIndex !== -1) {\r\n                    this.currentDraggingPointerIds.splice(registeredPointerIndex, 1);\r\n                    if (this.currentDraggingPointerIds.length === 0) {\r\n                        this._moving = false;\r\n                        this._dragging = this._dragType.NONE;\r\n\r\n                        // Reattach camera controls\r\n                        if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {\r\n                            this._pointerCamera.attachControl(true);\r\n                            this._attachedToElement = false;\r\n                        }\r\n                    }\r\n\r\n                    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);\r\n                    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);\r\n                    this._targetDragEnd(pointerId);\r\n                    this.onDragEndObservable.notifyObservers({});\r\n                }\r\n            } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {\r\n                const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);\r\n\r\n                if (registeredPointerIndex !== -1 && virtualMeshesInfo.dragging && pointerInfo.pickInfo && (pointerInfo.pickInfo.ray || pointerInfo.pickInfo.aimTransform)) {\r\n                    let zDragFactor = this.zDragFactor;\r\n\r\n                    // 2 pointer interaction should not have a z axis drag factor\r\n                    // as well as near interaction\r\n                    if (this.currentDraggingPointerIds.length > 1 || pointerInfo.pickInfo.originMesh) {\r\n                        zDragFactor = 0;\r\n                    }\r\n\r\n                    this._ownerNode.computeWorldMatrix(true);\r\n                    if (!isXRNearPointer) {\r\n                        this._pointerUpdate2D(pointerInfo.pickInfo.ray!, pointerId, zDragFactor);\r\n                    } else {\r\n                        this._pointerUpdateXR(pointerInfo.pickInfo.aimTransform!, pointerInfo.pickInfo.gripTransform, pointerId, zDragFactor);\r\n                    }\r\n\r\n                    // Get change in rotation\r\n                    this._tmpQuaternion.copyFrom(virtualMeshesInfo.startingPivotOrientation);\r\n                    this._tmpQuaternion.x = -this._tmpQuaternion.x;\r\n                    this._tmpQuaternion.y = -this._tmpQuaternion.y;\r\n                    this._tmpQuaternion.z = -this._tmpQuaternion.z;\r\n                    virtualMeshesInfo.pivotMesh.absoluteRotationQuaternion!.multiplyToRef(this._tmpQuaternion, this._tmpQuaternion);\r\n                    virtualMeshesInfo.pivotMesh.absolutePosition.subtractToRef(virtualMeshesInfo.startingPivotPosition, this._tmpVector);\r\n\r\n                    this.onDragObservable.notifyObservers({ delta: this._tmpVector, position: virtualMeshesInfo.pivotMesh.position, pickInfo: pointerInfo.pickInfo });\r\n\r\n                    // Notify herited methods and observables\r\n                    this._targetDrag(this._tmpVector, this._tmpQuaternion, pointerId);\r\n                    virtualMeshesInfo.lastDragPosition.copyFrom(virtualMeshesInfo.dragMesh.absolutePosition);\r\n\r\n                    this._moving = true;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _applyZOffset(node: TransformNode, localOriginDragDifference: number, zDragFactor: number) {\r\n        // Determine how much the controller moved to/away towards the dragged object and use this to move the object further when its further away\r\n        node.position.z -= node.position.z < 1 ? localOriginDragDifference * zDragFactor : localOriginDragDifference * zDragFactor * node.position.z;\r\n        if (node.position.z < 0) {\r\n            node.position.z = 0;\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _targetDragStart(worldPosition: Vector3, worldRotation: Quaternion, pointerId: number) {\r\n        // Herited classes can override that\r\n    }\r\n\r\n    protected _targetDrag(worldDeltaPosition: Vector3, worldDeltaRotation: Quaternion, pointerId: number) {\r\n        // Herited classes can override that\r\n    }\r\n\r\n    protected _targetDragEnd(pointerId: number) {\r\n        // Herited classes can override that\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        if (this._scene) {\r\n            if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {\r\n                this._pointerCamera.attachControl(true);\r\n                this._attachedToElement = false;\r\n            }\r\n            this._scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n\r\n        for (const pointerId in this._virtualMeshesInfo) {\r\n            this._virtualMeshesInfo[pointerId].originMesh.dispose();\r\n            this._virtualMeshesInfo[pointerId].dragMesh.dispose();\r\n        }\r\n\r\n        this.onDragEndObservable.clear();\r\n        this.onDragObservable.clear();\r\n        this.onDragStartObservable.clear();\r\n    }\r\n}\r\n", "import type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { BaseSixDofDragBehavior } from \"./baseSixDofDragBehavior\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Space } from \"../../Maths/math.axis\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray\r\n */\r\nexport class SixDofDragBehavior extends BaseSixDofDragBehavior {\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>> = null;\r\n    private _virtualTransformNode: TransformNode;\r\n\r\n    protected _targetPosition = new Vector3(0, 0, 0);\r\n    protected _targetOrientation = new Quaternion();\r\n    protected _targetScaling = new Vector3(1, 1, 1);\r\n    protected _startingPosition = new Vector3(0, 0, 0);\r\n    protected _startingOrientation = new Quaternion();\r\n    protected _startingScaling = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * Fires when position is updated\r\n     */\r\n    public onPositionChangedObservable = new Observable<{ position: Vector3 }>();\r\n\r\n    /**\r\n     * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)\r\n     */\r\n    public dragDeltaRatio = 0.2;\r\n\r\n    /**\r\n     * If the object should rotate to face the drag origin\r\n     */\r\n    public rotateDraggedObject = true;\r\n\r\n    /**\r\n     * If `rotateDraggedObject` is set to `true`, this parameter determines if we are only rotating around the y axis (yaw)\r\n     */\r\n    public rotateAroundYOnly = false;\r\n\r\n    /**\r\n     * Should the behavior rotate 1:1 with the motion controller, when one is used.\r\n     */\r\n    public rotateWithMotionController = true;\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"SixDofDrag\";\r\n    }\r\n\r\n    /**\r\n     * Use this flag to update the target but not move the owner node towards the target\r\n     */\r\n    public disableMovement: boolean = false;\r\n\r\n    /**\r\n     * Should the object rotate towards the camera when we start dragging it\r\n     */\r\n    public faceCameraOnDragStart = false;\r\n\r\n    /**\r\n     * Attaches the six DoF drag behavior\r\n     * @param ownerNode The mesh that will be dragged around once attached\r\n     */\r\n    public attach(ownerNode: Mesh): void {\r\n        super.attach(ownerNode);\r\n\r\n        ownerNode.isNearGrabbable = true;\r\n\r\n        // Node that will save the owner's transform\r\n        this._virtualTransformNode = new TransformNode(\"virtual_sixDof\", BaseSixDofDragBehavior._virtualScene);\r\n        this._virtualTransformNode.rotationQuaternion = Quaternion.Identity();\r\n\r\n        // On every frame move towards target scaling to avoid jitter caused by vr controllers\r\n        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\r\n            if (this.currentDraggingPointerIds.length === 1 && this._moving && !this.disableMovement) {\r\n                // 1 pointer only drags mesh\r\n                const oldParent = ownerNode.parent;\r\n                ownerNode.setParent(null);\r\n                ownerNode.position.addInPlace(this._targetPosition.subtract(ownerNode.position).scale(this.dragDeltaRatio));\r\n\r\n                this.onPositionChangedObservable.notifyObservers({ position: ownerNode.absolutePosition });\r\n\r\n                // Only rotate the mesh if it's parent has uniform scaling\r\n                if (!oldParent || ((oldParent as Mesh).scaling && !(oldParent as Mesh).scaling.isNonUniformWithinEpsilon(0.001))) {\r\n                    Quaternion.SlerpToRef(ownerNode.rotationQuaternion!, this._targetOrientation, this.dragDeltaRatio, ownerNode.rotationQuaternion!);\r\n                }\r\n\r\n                ownerNode.setParent(oldParent);\r\n            }\r\n        });\r\n    }\r\n\r\n    private _getPositionOffsetAround(transformationLocalOrigin: Vector3, scaling: number, rotation: Quaternion): Vector3 {\r\n        const translationMatrix = TmpVectors.Matrix[0]; // T\r\n        const translationMatrixInv = TmpVectors.Matrix[1]; // T'\r\n        const rotationMatrix = TmpVectors.Matrix[2]; // R\r\n        const scaleMatrix = TmpVectors.Matrix[3]; // S\r\n        const finalMatrix = TmpVectors.Matrix[4]; // T' x R x S x T\r\n\r\n        Matrix.TranslationToRef(transformationLocalOrigin.x, transformationLocalOrigin.y, transformationLocalOrigin.z, translationMatrix); // T\r\n        Matrix.TranslationToRef(-transformationLocalOrigin.x, -transformationLocalOrigin.y, -transformationLocalOrigin.z, translationMatrixInv); // T'\r\n        Matrix.FromQuaternionToRef(rotation, rotationMatrix); // R\r\n        Matrix.ScalingToRef(scaling, scaling, scaling, scaleMatrix);\r\n        translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R\r\n        finalMatrix.multiplyToRef(scaleMatrix, finalMatrix); // T' x R x S\r\n        finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x S x T\r\n\r\n        return finalMatrix.getTranslation();\r\n    }\r\n\r\n    private _onePointerPositionUpdated(worldDeltaPosition: Vector3, worldDeltaRotation: Quaternion) {\r\n        const pointerDelta = TmpVectors.Vector3[0];\r\n        pointerDelta.setAll(0);\r\n\r\n        if (this._dragging === this._dragType.DRAG) {\r\n            if (this.rotateDraggedObject) {\r\n                if (this.rotateAroundYOnly) {\r\n                    // Convert change in rotation to only y axis rotation\r\n                    Quaternion.RotationYawPitchRollToRef(worldDeltaRotation.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\r\n                } else {\r\n                    TmpVectors.Quaternion[0].copyFrom(worldDeltaRotation);\r\n                }\r\n                TmpVectors.Quaternion[0].multiplyToRef(this._startingOrientation, this._targetOrientation);\r\n            }\r\n        } else if (this._dragging === this._dragType.NEAR_DRAG || (this._dragging === this._dragType.DRAG_WITH_CONTROLLER && this.rotateWithMotionController)) {\r\n            worldDeltaRotation.multiplyToRef(this._startingOrientation, this._targetOrientation);\r\n        }\r\n\r\n        this._targetPosition.copyFrom(this._startingPosition).addInPlace(worldDeltaPosition);\r\n    }\r\n\r\n    private _twoPointersPositionUpdated() {\r\n        const startingPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].startingPosition;\r\n        const startingPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].startingPosition;\r\n        const startingCenter = TmpVectors.Vector3[0];\r\n        startingPosition0.addToRef(startingPosition1, startingCenter);\r\n        startingCenter.scaleInPlace(0.5);\r\n        const startingVector = TmpVectors.Vector3[1];\r\n        startingPosition1.subtractToRef(startingPosition0, startingVector);\r\n\r\n        const currentPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].dragMesh.absolutePosition;\r\n        const currentPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].dragMesh.absolutePosition;\r\n        const currentCenter = TmpVectors.Vector3[2];\r\n        currentPosition0.addToRef(currentPosition1, currentCenter);\r\n        currentCenter.scaleInPlace(0.5);\r\n        const currentVector = TmpVectors.Vector3[3];\r\n        currentPosition1.subtractToRef(currentPosition0, currentVector);\r\n\r\n        const scaling = currentVector.length() / startingVector.length();\r\n        const translation = currentCenter.subtract(startingCenter);\r\n        const rotationQuaternion = Quaternion.FromEulerAngles(\r\n            0,\r\n            Vector3.GetAngleBetweenVectorsOnPlane(startingVector.normalize(), currentVector.normalize(), Vector3.UpReadOnly),\r\n            0\r\n        );\r\n\r\n        const oldParent = this._ownerNode.parent;\r\n        this._ownerNode.setParent(null);\r\n\r\n        const positionOffset = this._getPositionOffsetAround(startingCenter.subtract(this._virtualTransformNode.getAbsolutePivotPoint()), scaling, rotationQuaternion);\r\n        this._virtualTransformNode.rotationQuaternion!.multiplyToRef(rotationQuaternion, this._ownerNode.rotationQuaternion!);\r\n        this._virtualTransformNode.scaling.scaleToRef(scaling, this._ownerNode.scaling);\r\n        this._virtualTransformNode.position.addToRef(translation.addInPlace(positionOffset), this._ownerNode.position);\r\n        this.onPositionChangedObservable.notifyObservers({ position: this._ownerNode.position });\r\n\r\n        this._ownerNode.setParent(oldParent);\r\n    }\r\n\r\n    protected _targetDragStart() {\r\n        const pointerCount = this.currentDraggingPointerIds.length;\r\n        const oldParent = this._ownerNode.parent;\r\n\r\n        if (!this._ownerNode.rotationQuaternion) {\r\n            this._ownerNode.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ownerNode.rotation.y, this._ownerNode.rotation.x, this._ownerNode.rotation.z);\r\n        }\r\n        const worldPivot = this._ownerNode.getAbsolutePivotPoint();\r\n        this._ownerNode.setParent(null);\r\n\r\n        if (pointerCount === 1) {\r\n            this._targetPosition.copyFrom(this._ownerNode.position);\r\n            this._targetOrientation.copyFrom(this._ownerNode.rotationQuaternion);\r\n            this._targetScaling.copyFrom(this._ownerNode.scaling);\r\n\r\n            if (this.faceCameraOnDragStart && this._scene.activeCamera) {\r\n                const toCamera = TmpVectors.Vector3[0];\r\n                this._scene.activeCamera.position.subtractToRef(worldPivot, toCamera);\r\n                toCamera.normalize();\r\n                const quat = TmpVectors.Quaternion[0];\r\n                if (this._scene.useRightHandedSystem) {\r\n                    Quaternion.FromLookDirectionRHToRef(toCamera, new Vector3(0, 1, 0), quat);\r\n                } else {\r\n                    Quaternion.FromLookDirectionLHToRef(toCamera, new Vector3(0, 1, 0), quat);\r\n                }\r\n                quat.normalize();\r\n                Quaternion.RotationYawPitchRollToRef(quat.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\r\n                this._targetOrientation.copyFrom(TmpVectors.Quaternion[0]);\r\n            }\r\n            this._startingPosition.copyFrom(this._targetPosition);\r\n            this._startingOrientation.copyFrom(this._targetOrientation);\r\n            this._startingScaling.copyFrom(this._targetScaling);\r\n        } else if (pointerCount === 2) {\r\n            this._virtualTransformNode.setPivotPoint(new Vector3(0, 0, 0), Space.LOCAL);\r\n            this._virtualTransformNode.position.copyFrom(this._ownerNode.position);\r\n            this._virtualTransformNode.scaling.copyFrom(this._ownerNode.scaling);\r\n            this._virtualTransformNode.rotationQuaternion!.copyFrom(this._ownerNode.rotationQuaternion);\r\n            this._virtualTransformNode.setPivotPoint(worldPivot, Space.WORLD);\r\n            this._resetVirtualMeshesPosition();\r\n        }\r\n\r\n        this._ownerNode.setParent(oldParent);\r\n    }\r\n\r\n    protected _targetDrag(worldDeltaPosition: Vector3, worldDeltaRotation: Quaternion) {\r\n        if (this.currentDraggingPointerIds.length === 1) {\r\n            this._onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation);\r\n        } else if (this.currentDraggingPointerIds.length === 2) {\r\n            this._twoPointersPositionUpdated();\r\n        }\r\n    }\r\n\r\n    protected _targetDragEnd() {\r\n        if (this.currentDraggingPointerIds.length === 1) {\r\n            // We still have 1 active pointer, we must simulate a dragstart with a reseted position/orientation\r\n            this._resetVirtualMeshesPosition();\r\n            const previousFaceCameraFlag = this.faceCameraOnDragStart;\r\n            this.faceCameraOnDragStart = false;\r\n            this._targetDragStart();\r\n            this.faceCameraOnDragStart = previousFaceCameraFlag;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        super.detach();\r\n\r\n        if (this._ownerNode) {\r\n            (this._ownerNode as Mesh).isNearGrabbable = false;\r\n            this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n        }\r\n\r\n        if (this._virtualTransformNode) {\r\n            this._virtualTransformNode.dispose();\r\n        }\r\n    }\r\n}\r\n", "import type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Behavior } from \"../behavior\";\r\n\r\n/**\r\n * A behavior that allows a transform node to stick to a surface position/orientation\r\n * @since 5.0.0\r\n */\r\nexport class SurfaceMagnetismBehavior implements Behavior<Mesh> {\r\n    private _scene: Scene;\r\n    private _attachedMesh: Nullable<Mesh>;\r\n    private _attachPointLocalOffset: Vector3 = new Vector3();\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _workingPosition: Vector3 = new Vector3();\r\n    private _workingQuaternion: Quaternion = new Quaternion();\r\n    private _lastTick: number = -1;\r\n    private _onBeforeRender: Nullable<Observer<Scene>>;\r\n    private _hit = false;\r\n\r\n    /**\r\n     * Distance offset from the hit point to place the target at, along the hit normal.\r\n     */\r\n    public hitNormalOffset: number = 0.05;\r\n\r\n    /**\r\n     * Name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"SurfaceMagnetism\";\r\n    }\r\n\r\n    /**\r\n     * Spatial mapping meshes to collide with\r\n     */\r\n    public meshes: AbstractMesh[] = [];\r\n\r\n    /**\r\n     * Function called when the behavior needs to be initialized (after attaching it to a target)\r\n     */\r\n    public init(): void {}\r\n\r\n    /**\r\n     * Set to false if the node should strictly follow the camera without any interpolation time\r\n     */\r\n    public interpolatePose = true;\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 250;\r\n\r\n    /**\r\n     * If true, pitch and roll are omitted.\r\n     */\r\n    public keepOrientationVertical = true;\r\n\r\n    /**\r\n     * Is this behavior reacting to pointer events\r\n     */\r\n    public enabled = true;\r\n\r\n    /**\r\n     * Maximum distance for the node to stick to the surface\r\n     */\r\n    public maxStickingDistance = 0.8;\r\n\r\n    /**\r\n     * Attaches the behavior to a transform node\r\n     * @param target defines the target where the behavior is attached to\r\n     * @param scene the scene\r\n     */\r\n    public attach(target: Mesh, scene?: Scene): void {\r\n        this._attachedMesh = target;\r\n        this._scene = scene || target.getScene();\r\n        if (!this._attachedMesh.rotationQuaternion) {\r\n            this._attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._attachedMesh.rotation.y, this._attachedMesh.rotation.x, this._attachedMesh.rotation.z);\r\n        }\r\n        this.updateAttachPoint();\r\n\r\n        this._workingPosition.copyFrom(this._attachedMesh.position);\r\n        this._workingQuaternion.copyFrom(this._attachedMesh.rotationQuaternion);\r\n        this._addObservables();\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior\r\n     */\r\n    public detach(): void {\r\n        this._attachedMesh = null;\r\n        this._removeObservables();\r\n    }\r\n\r\n    private _getTargetPose(pickingInfo: PickingInfo): Nullable<{ position: Vector3; quaternion: Quaternion }> {\r\n        if (!this._attachedMesh) {\r\n            return null;\r\n        }\r\n\r\n        if (pickingInfo && pickingInfo.hit) {\r\n            const pickedNormal = pickingInfo.getNormal(true, true);\r\n            const pickedPoint = pickingInfo.pickedPoint;\r\n\r\n            if (!pickedNormal || !pickedPoint) {\r\n                return null;\r\n            }\r\n            pickedNormal.normalize();\r\n\r\n            const worldTarget = TmpVectors.Vector3[0];\r\n            worldTarget.copyFrom(pickedNormal);\r\n            worldTarget.scaleInPlace(this.hitNormalOffset);\r\n            worldTarget.addInPlace(pickedPoint);\r\n\r\n            if (this._attachedMesh.parent) {\r\n                TmpVectors.Matrix[0].copyFrom(this._attachedMesh.parent.getWorldMatrix()).invert();\r\n                Vector3.TransformNormalToRef(worldTarget, TmpVectors.Matrix[0], worldTarget);\r\n            }\r\n\r\n            return {\r\n                position: worldTarget,\r\n                quaternion: Quaternion.RotationYawPitchRoll(\r\n                    -Math.atan2(pickedNormal.x, -pickedNormal.z),\r\n                    this.keepOrientationVertical ? 0 : Math.atan2(pickedNormal.y, Math.sqrt(pickedNormal.z * pickedNormal.z + pickedNormal.x * pickedNormal.x)),\r\n                    0\r\n                ),\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Updates the attach point with the current geometry extents of the attached mesh\r\n     */\r\n    public updateAttachPoint() {\r\n        this._getAttachPointOffsetToRef(this._attachPointLocalOffset);\r\n    }\r\n\r\n    /**\r\n     * Finds the intersection point of the given ray onto the meshes and updates the target.\r\n     * Transformation will be interpolated according to `interpolatePose` and `lerpTime` properties.\r\n     * If no mesh of `meshes` are hit, this does nothing.\r\n     * @param pickInfo The input pickingInfo that will be used to intersect the meshes\r\n     * @returns a boolean indicating if we found a hit to stick to\r\n     */\r\n    public findAndUpdateTarget(pickInfo: PickingInfo): boolean {\r\n        this._hit = false;\r\n        if (!pickInfo.ray) {\r\n            return false;\r\n        }\r\n\r\n        const subPicking = pickInfo.ray.intersectsMeshes(this.meshes)[0];\r\n\r\n        if (this._attachedMesh && subPicking && subPicking.hit && subPicking.pickedMesh) {\r\n            const pose = this._getTargetPose(subPicking);\r\n            if (pose && Vector3.Distance(this._attachedMesh.position, pose.position) < this.maxStickingDistance) {\r\n                this._workingPosition.copyFrom(pose.position);\r\n                this._workingQuaternion.copyFrom(pose.quaternion);\r\n                this._hit = true;\r\n            }\r\n        }\r\n\r\n        return this._hit;\r\n    }\r\n\r\n    private _getAttachPointOffsetToRef(ref: Vector3) {\r\n        if (!this._attachedMesh) {\r\n            ref.setAll(0);\r\n            return;\r\n        }\r\n\r\n        const storedQuat = TmpVectors.Quaternion[0];\r\n        storedQuat.copyFrom(this._attachedMesh.rotationQuaternion!);\r\n        this._attachedMesh.rotationQuaternion!.copyFromFloats(0, 0, 0, 1);\r\n        this._attachedMesh.computeWorldMatrix();\r\n        const boundingMinMax = this._attachedMesh.getHierarchyBoundingVectors();\r\n        const center = TmpVectors.Vector3[0];\r\n        boundingMinMax.max.addToRef(boundingMinMax.min, center);\r\n        center.scaleInPlace(0.5);\r\n        center.z = boundingMinMax.max.z;\r\n        // We max the z coordinate because we want the attach point to be on the back of the mesh\r\n        const invWorld = TmpVectors.Matrix[0];\r\n        this._attachedMesh.getWorldMatrix().invertToRef(invWorld);\r\n        Vector3.TransformCoordinatesToRef(center, invWorld, ref);\r\n        this._attachedMesh.rotationQuaternion!.copyFrom(storedQuat);\r\n    }\r\n\r\n    private _updateTransformToGoal(elapsed: number) {\r\n        if (!this._attachedMesh || !this._hit) {\r\n            return;\r\n        }\r\n\r\n        const oldParent = this._attachedMesh.parent;\r\n        this._attachedMesh.setParent(null);\r\n\r\n        const worldOffset = TmpVectors.Vector3[0];\r\n        Vector3.TransformNormalToRef(this._attachPointLocalOffset, this._attachedMesh.getWorldMatrix(), worldOffset);\r\n\r\n        if (!this.interpolatePose) {\r\n            this._attachedMesh.position.copyFrom(this._workingPosition).subtractInPlace(worldOffset);\r\n            this._attachedMesh.rotationQuaternion!.copyFrom(this._workingQuaternion);\r\n            return;\r\n        }\r\n\r\n        // position\r\n        const interpolatedPosition = new Vector3();\r\n        Vector3.SmoothToRef(this._attachedMesh.position, this._workingPosition, elapsed, this.lerpTime, interpolatedPosition);\r\n        this._attachedMesh.position.copyFrom(interpolatedPosition);\r\n\r\n        // rotation\r\n        const currentRotation = new Quaternion();\r\n        currentRotation.copyFrom(this._attachedMesh.rotationQuaternion!);\r\n        Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this._attachedMesh.rotationQuaternion!);\r\n\r\n        this._attachedMesh.setParent(oldParent);\r\n    }\r\n\r\n    private _addObservables() {\r\n        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {\r\n            if (this.enabled && pointerInfo.type == PointerEventTypes.POINTERMOVE && pointerInfo.pickInfo) {\r\n                this.findAndUpdateTarget(pointerInfo.pickInfo);\r\n            }\r\n        });\r\n\r\n        this._lastTick = Date.now();\r\n        this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\r\n            const tick = Date.now();\r\n            this._updateTransformToGoal(tick - this._lastTick);\r\n            this._lastTick = tick;\r\n        });\r\n    }\r\n\r\n    private _removeObservables() {\r\n        this._scene.onPointerObservable.remove(this._pointerObserver);\r\n        this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\r\n        this._pointerObserver = null;\r\n        this._onBeforeRender = null;\r\n    }\r\n}\r\n", "import type { Behavior } from \"../behavior\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will follow a camera\r\n * @since 5.0.0\r\n */\r\nexport class FollowBehavior implements Behavior<TransformNode> {\r\n    private _scene: Scene;\r\n\r\n    // Memory cache to avoid GC usage\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n    private _tmpVectors: Vector3[] = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];\r\n    private _tmpMatrix: Matrix = new Matrix();\r\n    private _tmpInvertView: Matrix = new Matrix();\r\n    private _tmpForward: Vector3 = new Vector3();\r\n    private _tmpNodeForward: Vector3 = new Vector3();\r\n    private _tmpPosition: Vector3 = new Vector3();\r\n\r\n    private _followedCamera: Nullable<Camera>;\r\n    private _onBeforeRender: Nullable<Observer<Scene>>;\r\n\r\n    private _workingPosition: Vector3 = new Vector3();\r\n    private _workingQuaternion: Quaternion = new Quaternion();\r\n    private _lastTick: number = -1;\r\n    private _recenterNextUpdate = true;\r\n\r\n    /**\r\n     * Attached node of this behavior\r\n     */\r\n    public attachedNode: Nullable<TransformNode>;\r\n\r\n    /**\r\n     * Set to false if the node should strictly follow the camera without any interpolation time\r\n     */\r\n    public interpolatePose = true;\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 500;\r\n\r\n    /**\r\n     * If the behavior should ignore the pitch and roll of the camera.\r\n     */\r\n    public ignoreCameraPitchAndRoll = false;\r\n\r\n    /**\r\n     * Pitch offset from camera (relative to Max Distance)\r\n     * Is only effective if `ignoreCameraPitchAndRoll` is set to `true`.\r\n     */\r\n    public pitchOffset = 15;\r\n\r\n    /**\r\n     * The vertical angle from the camera forward axis to the owner will not exceed this value\r\n     */\r\n    public maxViewVerticalDegrees = 30;\r\n\r\n    /**\r\n     * The horizontal angle from the camera forward axis to the owner will not exceed this value\r\n     */\r\n    public maxViewHorizontalDegrees = 30;\r\n    /**\r\n     * The attached node will not reorient until the angle between its forward vector and the vector to the camera is greater than this value\r\n     */\r\n    public orientToCameraDeadzoneDegrees = 60;\r\n    /**\r\n     * Option to ignore distance clamping\r\n     */\r\n    public ignoreDistanceClamp = false;\r\n    /**\r\n     * Option to ignore angle clamping\r\n     */\r\n    public ignoreAngleClamp = false;\r\n    /**\r\n     * Max vertical distance between the attachedNode and camera\r\n     */\r\n    public verticalMaxDistance = 0;\r\n    /**\r\n     *  Default distance from eye to attached node, i.e. the sphere radius\r\n     */\r\n    public defaultDistance = 0.8;\r\n    /**\r\n     *  Max distance from eye to attached node, i.e. the sphere radius\r\n     */\r\n    public maximumDistance = 2;\r\n    /**\r\n     *  Min distance from eye to attached node, i.e. the sphere radius\r\n     */\r\n    public minimumDistance = 0.3;\r\n\r\n    /**\r\n     * Ignore vertical movement and lock the Y position of the object.\r\n     */\r\n    public useFixedVerticalOffset = false;\r\n\r\n    /**\r\n     * Fixed vertical position offset distance.\r\n     */\r\n    public fixedVerticalOffset = 0;\r\n\r\n    /**\r\n     * Enables/disables the behavior\r\n     * @internal\r\n     */\r\n    public _enabled = true;\r\n\r\n    /**\r\n     * The camera that should be followed by this behavior\r\n     */\r\n    public get followedCamera(): Nullable<Camera> {\r\n        return this._followedCamera || this._scene.activeCamera;\r\n    }\r\n\r\n    public set followedCamera(camera: Nullable<Camera>) {\r\n        this._followedCamera = camera;\r\n    }\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"Follow\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Attaches the follow behavior\r\n     * @param ownerNode The mesh that will be following once attached\r\n     * @param followedCamera The camera that should be followed by the node\r\n     */\r\n    public attach(ownerNode: TransformNode, followedCamera?: Camera): void {\r\n        this._scene = ownerNode.getScene();\r\n        this.attachedNode = ownerNode;\r\n\r\n        if (followedCamera) {\r\n            this.followedCamera = followedCamera;\r\n        }\r\n\r\n        this._addObservables();\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this.attachedNode = null;\r\n        this._removeObservables();\r\n    }\r\n\r\n    /**\r\n     * Recenters the attached node in front of the camera on the next update\r\n     */\r\n    public recenter() {\r\n        this._recenterNextUpdate = true;\r\n    }\r\n\r\n    private _angleBetweenVectorAndPlane(vector: Vector3, normal: Vector3) {\r\n        // Work on copies\r\n        this._tmpVectors[0].copyFrom(vector);\r\n        vector = this._tmpVectors[0];\r\n        this._tmpVectors[1].copyFrom(normal);\r\n        normal = this._tmpVectors[1];\r\n\r\n        vector.normalize();\r\n        normal.normalize();\r\n\r\n        return Math.PI / 2 - Math.acos(Vector3.Dot(vector, normal));\r\n    }\r\n\r\n    private _length2D(vector: Vector3) {\r\n        return Math.sqrt(vector.x * vector.x + vector.z * vector.z);\r\n    }\r\n\r\n    private _distanceClamp(currentToTarget: Vector3, moveToDefault: boolean = false) {\r\n        let minDistance = this.minimumDistance;\r\n        let maxDistance = this.maximumDistance;\r\n        const defaultDistance = this.defaultDistance;\r\n\r\n        const direction = this._tmpVectors[0];\r\n        direction.copyFrom(currentToTarget);\r\n        let currentDistance = direction.length();\r\n        direction.normalizeFromLength(currentDistance);\r\n\r\n        if (this.ignoreCameraPitchAndRoll) {\r\n            // If we don't account for pitch offset, the casted object will float up/down as the reference\r\n            // gets closer to it because we will still be casting in the direction of the pitched offset.\r\n            // To fix this, only modify the XZ position of the object.\r\n            minDistance = this._length2D(direction) * minDistance;\r\n            maxDistance = this._length2D(direction) * maxDistance;\r\n\r\n            const currentDistance2D = this._length2D(currentToTarget);\r\n            direction.scaleInPlace(currentDistance / currentDistance2D);\r\n            currentDistance = currentDistance2D;\r\n        }\r\n\r\n        let clampedDistance = currentDistance;\r\n\r\n        if (moveToDefault) {\r\n            clampedDistance = defaultDistance;\r\n        } else {\r\n            clampedDistance = Scalar.Clamp(currentDistance, minDistance, maxDistance);\r\n        }\r\n\r\n        currentToTarget.copyFrom(direction).scaleInPlace(clampedDistance);\r\n\r\n        return currentDistance !== clampedDistance;\r\n    }\r\n\r\n    private _applyVerticalClamp(currentToTarget: Vector3) {\r\n        if (this.verticalMaxDistance !== 0) {\r\n            currentToTarget.y = Scalar.Clamp(currentToTarget.y, -this.verticalMaxDistance, this.verticalMaxDistance);\r\n        }\r\n    }\r\n\r\n    private _toOrientationQuatToRef(vector: Vector3, quaternion: Quaternion) {\r\n        Quaternion.RotationYawPitchRollToRef(Math.atan2(vector.x, vector.z), Math.atan2(vector.y, Math.sqrt(vector.z * vector.z + vector.x * vector.x)), 0, quaternion);\r\n    }\r\n\r\n    private _applyPitchOffset(invertView: Matrix) {\r\n        const forward = this._tmpVectors[0];\r\n        const right = this._tmpVectors[1];\r\n        forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n        right.copyFromFloats(1, 0, 0);\r\n        Vector3.TransformNormalToRef(forward, invertView, forward);\r\n        forward.y = 0;\r\n        forward.normalize();\r\n        Vector3.TransformNormalToRef(right, invertView, right);\r\n\r\n        Quaternion.RotationAxisToRef(right, (this.pitchOffset * Math.PI) / 180, this._tmpQuaternion);\r\n        forward.rotateByQuaternionToRef(this._tmpQuaternion, forward);\r\n        this._toOrientationQuatToRef(forward, this._tmpQuaternion);\r\n        this._tmpQuaternion.toRotationMatrix(this._tmpMatrix);\r\n\r\n        // Since we already extracted position from the invert view matrix, we can\r\n        // disregard the position part of the matrix in the copy\r\n        invertView.copyFrom(this._tmpMatrix);\r\n    }\r\n\r\n    private _angularClamp(invertView: Matrix, currentToTarget: Vector3): boolean {\r\n        const forward = this._tmpVectors[5];\r\n        forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n        const right = this._tmpVectors[6];\r\n        right.copyFromFloats(1, 0, 0);\r\n\r\n        // forward and right are related to camera frame of reference\r\n        Vector3.TransformNormalToRef(forward, invertView, forward);\r\n        Vector3.TransformNormalToRef(right, invertView, right);\r\n\r\n        // Up is global Z\r\n        const up = Vector3.UpReadOnly;\r\n\r\n        const dist = currentToTarget.length();\r\n\r\n        if (dist < Epsilon) {\r\n            return false;\r\n        }\r\n\r\n        let angularClamped = false;\r\n        const rotationQuat = this._tmpQuaternion;\r\n\r\n        // X-axis leashing\r\n        if (this.ignoreCameraPitchAndRoll) {\r\n            const angle = Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\r\n            Quaternion.RotationAxisToRef(right, angle, rotationQuat);\r\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n        } else {\r\n            const angle = -Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\r\n            const minMaxAngle = ((this.maxViewVerticalDegrees * Math.PI) / 180) * 0.5;\r\n            if (angle < -minMaxAngle) {\r\n                Quaternion.RotationAxisToRef(right, -angle - minMaxAngle, rotationQuat);\r\n                currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n                angularClamped = true;\r\n            } else if (angle > minMaxAngle) {\r\n                Quaternion.RotationAxisToRef(right, -angle + minMaxAngle, rotationQuat);\r\n                currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n                angularClamped = true;\r\n            }\r\n        }\r\n\r\n        // Y-axis leashing\r\n        const angle = this._angleBetweenVectorAndPlane(currentToTarget, right) * (this._scene.useRightHandedSystem ? -1 : 1);\r\n        const minMaxAngle = ((this.maxViewHorizontalDegrees * Math.PI) / 180) * 0.5;\r\n        if (angle < -minMaxAngle) {\r\n            Quaternion.RotationAxisToRef(up, -angle - minMaxAngle, rotationQuat);\r\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n            angularClamped = true;\r\n        } else if (angle > minMaxAngle) {\r\n            Quaternion.RotationAxisToRef(up, -angle + minMaxAngle, rotationQuat);\r\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n            angularClamped = true;\r\n        }\r\n\r\n        return angularClamped;\r\n    }\r\n\r\n    private _orientationClamp(currentToTarget: Vector3, rotationQuaternion: Quaternion) {\r\n        // Construct a rotation quat from up vector and target vector\r\n        const toFollowed = this._tmpVectors[0];\r\n        toFollowed.copyFrom(currentToTarget).scaleInPlace(-1).normalize();\r\n\r\n        const up = this._tmpVectors[1];\r\n        const right = this._tmpVectors[2];\r\n        // We use global up vector to orient the following node (global +Y)\r\n        up.copyFromFloats(0, 1, 0);\r\n\r\n        // Gram-Schmidt to create an orthonormal frame\r\n        Vector3.CrossToRef(toFollowed, up, right);\r\n        const length = right.length();\r\n\r\n        if (length < Epsilon) {\r\n            return;\r\n        }\r\n\r\n        right.normalizeFromLength(length);\r\n\r\n        Vector3.CrossToRef(right, toFollowed, up);\r\n        if (this.attachedNode?.getScene().useRightHandedSystem) {\r\n            Quaternion.FromLookDirectionRHToRef(toFollowed, up, rotationQuaternion);\r\n        } else {\r\n            Quaternion.FromLookDirectionLHToRef(toFollowed, up, rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    private _passedOrientationDeadzone(currentToTarget: Vector3, forward: Vector3) {\r\n        const leashToFollow = this._tmpVectors[5];\r\n        leashToFollow.copyFrom(currentToTarget);\r\n        leashToFollow.normalize();\r\n\r\n        const angle = Math.abs(Vector3.GetAngleBetweenVectorsOnPlane(forward, leashToFollow, Vector3.UpReadOnly));\r\n        return (angle * 180) / Math.PI > this.orientToCameraDeadzoneDegrees;\r\n    }\r\n\r\n    private _updateLeashing(camera: Camera) {\r\n        if (this.attachedNode && this._enabled) {\r\n            const oldParent = this.attachedNode.parent;\r\n            this.attachedNode.setParent(null);\r\n\r\n            const worldMatrix = this.attachedNode.getWorldMatrix();\r\n            const currentToTarget = this._workingPosition;\r\n            const rotationQuaternion = this._workingQuaternion;\r\n            const pivot = this.attachedNode.getPivotPoint();\r\n            const invertView = this._tmpInvertView;\r\n            invertView.copyFrom(camera.getViewMatrix());\r\n            invertView.invert();\r\n\r\n            Vector3.TransformCoordinatesToRef(pivot, worldMatrix, currentToTarget);\r\n            const position = this._tmpPosition;\r\n            position.copyFromFloats(0, 0, 0);\r\n            Vector3.TransformCoordinatesToRef(position, worldMatrix, position);\r\n            position.scaleInPlace(-1).subtractInPlace(pivot);\r\n            currentToTarget.subtractInPlace(camera.globalPosition);\r\n\r\n            if (this.ignoreCameraPitchAndRoll) {\r\n                this._applyPitchOffset(invertView);\r\n            }\r\n\r\n            let angularClamped = false;\r\n            const forward = this._tmpForward;\r\n            forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n            Vector3.TransformNormalToRef(forward, invertView, forward);\r\n\r\n            const nodeForward = this._tmpNodeForward;\r\n            nodeForward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n            Vector3.TransformNormalToRef(nodeForward, worldMatrix, nodeForward);\r\n\r\n            if (this._recenterNextUpdate) {\r\n                currentToTarget.copyFrom(forward).scaleInPlace(this.defaultDistance);\r\n            } else {\r\n                if (this.ignoreAngleClamp) {\r\n                    const currentDistance = currentToTarget.length();\r\n                    currentToTarget.copyFrom(forward).scaleInPlace(currentDistance);\r\n                } else {\r\n                    angularClamped = this._angularClamp(invertView, currentToTarget);\r\n                }\r\n            }\r\n\r\n            let distanceClamped = false;\r\n            if (!this.ignoreDistanceClamp) {\r\n                distanceClamped = this._distanceClamp(currentToTarget, angularClamped);\r\n                this._applyVerticalClamp(currentToTarget);\r\n            }\r\n\r\n            if (this.useFixedVerticalOffset) {\r\n                currentToTarget.y = position.y - camera.globalPosition.y + this.fixedVerticalOffset;\r\n            }\r\n\r\n            if (angularClamped || distanceClamped || this._passedOrientationDeadzone(currentToTarget, nodeForward) || this._recenterNextUpdate) {\r\n                this._orientationClamp(currentToTarget, rotationQuaternion);\r\n            }\r\n\r\n            this._workingPosition.subtractInPlace(pivot);\r\n            this._recenterNextUpdate = false;\r\n\r\n            this.attachedNode.setParent(oldParent);\r\n        }\r\n    }\r\n\r\n    private _updateTransformToGoal(elapsed: number) {\r\n        if (!this.attachedNode || !this.followedCamera || !this._enabled) {\r\n            return;\r\n        }\r\n\r\n        if (!this.attachedNode.rotationQuaternion) {\r\n            this.attachedNode.rotationQuaternion = Quaternion.Identity();\r\n        }\r\n\r\n        const oldParent = this.attachedNode.parent;\r\n        this.attachedNode.setParent(null);\r\n\r\n        if (!this.interpolatePose) {\r\n            this.attachedNode.position.copyFrom(this.followedCamera.globalPosition).addInPlace(this._workingPosition);\r\n            this.attachedNode.rotationQuaternion.copyFrom(this._workingQuaternion);\r\n            return;\r\n        }\r\n\r\n        // position\r\n        const currentDirection = new Vector3();\r\n        currentDirection.copyFrom(this.attachedNode.position).subtractInPlace(this.followedCamera.globalPosition);\r\n        Vector3.SmoothToRef(currentDirection, this._workingPosition, elapsed, this.lerpTime, currentDirection);\r\n        currentDirection.addInPlace(this.followedCamera.globalPosition);\r\n        this.attachedNode.position.copyFrom(currentDirection);\r\n\r\n        // rotation\r\n        const currentRotation = new Quaternion();\r\n        currentRotation.copyFrom(this.attachedNode.rotationQuaternion);\r\n        Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this.attachedNode.rotationQuaternion);\r\n\r\n        this.attachedNode.setParent(oldParent);\r\n    }\r\n\r\n    private _addObservables() {\r\n        this._lastTick = Date.now();\r\n        this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\r\n            if (!this.followedCamera) {\r\n                return;\r\n            }\r\n\r\n            const tick = Date.now();\r\n            this._updateLeashing(this.followedCamera);\r\n            this._updateTransformToGoal(tick - this._lastTick);\r\n            this._lastTick = tick;\r\n        });\r\n    }\r\n\r\n    private _removeObservables() {\r\n        if (this._onBeforeRender) {\r\n            this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\r\n        }\r\n    }\r\n}\r\n", "import type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\n/**\r\n * Defining the interface required for a (webxr) feature\r\n */\r\nexport interface IWebXRFeature extends IDisposable {\r\n    /**\r\n     * Is this feature attached\r\n     */\r\n    attached: boolean;\r\n    /**\r\n     * Should auto-attach be disabled?\r\n     */\r\n    disableAutoAttach: boolean;\r\n\r\n    /**\r\n     * Attach the feature to the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @param force should attachment be forced (even when already attached)\r\n     * @returns true if successful.\r\n     */\r\n    attach(force?: boolean): boolean;\r\n    /**\r\n     * Detach the feature from the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    detach(): boolean;\r\n\r\n    /**\r\n     * This function will be executed during before enabling the feature and can be used to not-allow enabling it.\r\n     * Note that at this point the session has NOT started, so this is purely checking if the browser supports it\r\n     *\r\n     * @returns whether or not the feature is compatible in this environment\r\n     */\r\n    isCompatible(): boolean;\r\n\r\n    /**\r\n     * Was this feature disposed;\r\n     */\r\n    isDisposed: boolean;\r\n\r\n    /**\r\n     * The name of the native xr feature name, if applicable (like anchor, hit-test, or hand-tracking)\r\n     */\r\n    xrNativeFeatureName?: string;\r\n\r\n    /**\r\n     * A list of (Babylon WebXR) features this feature depends on\r\n     */\r\n    dependsOn?: string[];\r\n\r\n    /**\r\n     * If this feature requires to extend the XRSessionInit object, this function will return the partial XR session init object\r\n     */\r\n    getXRSessionInitExtension?: () => Promise<Partial<XRSessionInit>>;\r\n}\r\n\r\n/**\r\n * A list of the currently available features without referencing them\r\n */\r\nexport class WebXRFeatureName {\r\n    /**\r\n     * The name of the anchor system feature\r\n     */\r\n    public static readonly ANCHOR_SYSTEM = \"xr-anchor-system\";\r\n    /**\r\n     * The name of the background remover feature\r\n     */\r\n    public static readonly BACKGROUND_REMOVER = \"xr-background-remover\";\r\n    /**\r\n     * The name of the hit test feature\r\n     */\r\n    public static readonly HIT_TEST = \"xr-hit-test\";\r\n    /**\r\n     * The name of the mesh detection feature\r\n     */\r\n    public static readonly MESH_DETECTION = \"xr-mesh-detection\";\r\n    /**\r\n     * physics impostors for xr controllers feature\r\n     */\r\n    public static readonly PHYSICS_CONTROLLERS = \"xr-physics-controller\";\r\n    /**\r\n     * The name of the plane detection feature\r\n     */\r\n    public static readonly PLANE_DETECTION = \"xr-plane-detection\";\r\n    /**\r\n     * The name of the pointer selection feature\r\n     */\r\n    public static readonly POINTER_SELECTION = \"xr-controller-pointer-selection\";\r\n    /**\r\n     * The name of the teleportation feature\r\n     */\r\n    public static readonly TELEPORTATION = \"xr-controller-teleportation\";\r\n    /**\r\n     * The name of the feature points feature.\r\n     */\r\n    public static readonly FEATURE_POINTS = \"xr-feature-points\";\r\n    /**\r\n     * The name of the hand tracking feature.\r\n     */\r\n    public static readonly HAND_TRACKING = \"xr-hand-tracking\";\r\n    /**\r\n     * The name of the image tracking feature\r\n     */\r\n    public static readonly IMAGE_TRACKING = \"xr-image-tracking\";\r\n    /**\r\n     * The name of the near interaction feature\r\n     */\r\n    public static readonly NEAR_INTERACTION = \"xr-near-interaction\";\r\n    /**\r\n     * The name of the DOM overlay feature\r\n     */\r\n    public static readonly DOM_OVERLAY = \"xr-dom-overlay\";\r\n    /**\r\n     * The name of the movement feature\r\n     */\r\n    public static readonly MOVEMENT = \"xr-controller-movement\";\r\n    /**\r\n     * The name of the light estimation feature\r\n     */\r\n    public static readonly LIGHT_ESTIMATION = \"xr-light-estimation\";\r\n    /**\r\n     * The name of the eye tracking feature\r\n     */\r\n    public static readonly EYE_TRACKING = \"xr-eye-tracking\";\r\n    /**\r\n     * The name of the walking locomotion feature\r\n     */\r\n    public static readonly WALKING_LOCOMOTION = \"xr-walking-locomotion\";\r\n    /**\r\n     * The name of the composition layers feature\r\n     */\r\n    public static readonly LAYERS = \"xr-layers\";\r\n}\r\n\r\n/**\r\n * Defining the constructor of a feature. Used to register the modules.\r\n */\r\nexport type WebXRFeatureConstructor = (xrSessionManager: WebXRSessionManager, options?: any) => () => IWebXRFeature;\r\n\r\n/**\r\n * The WebXR features manager is responsible of enabling or disabling features required for the current XR session.\r\n * It is mainly used in AR sessions.\r\n *\r\n * A feature can have a version that is defined by Babylon (and does not correspond with the webxr version).\r\n */\r\nexport class WebXRFeaturesManager implements IDisposable {\r\n    private static readonly _AvailableFeatures: {\r\n        [name: string]: {\r\n            stable: number;\r\n            latest: number;\r\n            [version: number]: WebXRFeatureConstructor;\r\n        };\r\n    } = {};\r\n\r\n    private _features: {\r\n        [name: string]: {\r\n            featureImplementation: IWebXRFeature;\r\n            version: number;\r\n            enabled: boolean;\r\n            required: boolean;\r\n        };\r\n    } = {};\r\n\r\n    /**\r\n     * The key is the feature to check and the value is the feature that conflicts.\r\n     */\r\n    private static readonly _ConflictingFeatures: { [key: string]: string } = {\r\n        [WebXRFeatureName.TELEPORTATION]: WebXRFeatureName.MOVEMENT,\r\n        [WebXRFeatureName.MOVEMENT]: WebXRFeatureName.TELEPORTATION,\r\n    };\r\n\r\n    /**\r\n     * constructs a new features manages.\r\n     *\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     */\r\n    constructor(private _xrSessionManager: WebXRSessionManager) {\r\n        // when session starts / initialized - attach\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this.getEnabledFeatures().forEach((featureName) => {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {\r\n                    this.attachFeature(featureName);\r\n                }\r\n            });\r\n        });\r\n\r\n        // when session ends - detach\r\n        this._xrSessionManager.onXRSessionEnded.add(() => {\r\n            this.getEnabledFeatures().forEach((featureName) => {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && feature.featureImplementation.attached) {\r\n                    // detach, but don't disable!\r\n                    this.detachFeature(featureName);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Used to register a module. After calling this function a developer can use this feature in the scene.\r\n     * Mainly used internally.\r\n     *\r\n     * @param featureName the name of the feature to register\r\n     * @param constructorFunction the function used to construct the module\r\n     * @param version the (babylon) version of the module\r\n     * @param stable is that a stable version of this module\r\n     */\r\n    public static AddWebXRFeature(featureName: string, constructorFunction: WebXRFeatureConstructor, version: number = 1, stable: boolean = false) {\r\n        this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || { latest: version };\r\n        if (version > this._AvailableFeatures[featureName].latest) {\r\n            this._AvailableFeatures[featureName].latest = version;\r\n        }\r\n        if (stable) {\r\n            this._AvailableFeatures[featureName].stable = version;\r\n        }\r\n        this._AvailableFeatures[featureName][version] = constructorFunction;\r\n    }\r\n\r\n    /**\r\n     * Returns a constructor of a specific feature.\r\n     *\r\n     * @param featureName the name of the feature to construct\r\n     * @param version the version of the feature to load\r\n     * @param xrSessionManager the xrSessionManager. Used to construct the module\r\n     * @param options optional options provided to the module.\r\n     * @returns a function that, when called, will return a new instance of this feature\r\n     */\r\n    public static ConstructFeature(featureName: string, version: number = 1, xrSessionManager: WebXRSessionManager, options?: any): () => IWebXRFeature {\r\n        const constructorFunction = this._AvailableFeatures[featureName][version];\r\n        if (!constructorFunction) {\r\n            // throw an error? return nothing?\r\n            throw new Error(\"feature not found\");\r\n        }\r\n\r\n        return constructorFunction(xrSessionManager, options);\r\n    }\r\n\r\n    /**\r\n     * Can be used to return the list of features currently registered\r\n     *\r\n     * @returns an Array of available features\r\n     */\r\n    public static GetAvailableFeatures() {\r\n        return Object.keys(this._AvailableFeatures);\r\n    }\r\n\r\n    /**\r\n     * Gets the versions available for a specific feature\r\n     * @param featureName the name of the feature\r\n     * @returns an array with the available versions\r\n     */\r\n    public static GetAvailableVersions(featureName: string) {\r\n        return Object.keys(this._AvailableFeatures[featureName]);\r\n    }\r\n\r\n    /**\r\n     * Return the latest unstable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetLatestVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest) || -1;\r\n    }\r\n\r\n    /**\r\n     * Return the latest stable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetStableVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable) || -1;\r\n    }\r\n\r\n    /**\r\n     * Attach a feature to the current session. Mainly used when session started to start the feature effect.\r\n     * Can be used during a session to start a feature\r\n     * @param featureName the name of feature to attach\r\n     */\r\n    public attachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.enabled && !feature.featureImplementation.attached) {\r\n            feature.featureImplementation.attach();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Can be used inside a session or when the session ends to detach a specific feature\r\n     * @param featureName the name of the feature to detach\r\n     */\r\n    public detachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.featureImplementation.attached) {\r\n            feature.featureImplementation.detach();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Used to disable an already-enabled feature\r\n     * The feature will be disposed and will be recreated once enabled.\r\n     * @param featureName the feature to disable\r\n     * @returns true if disable was successful\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public disableFeature(featureName: string | { Name: string }): boolean {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        const feature = this._features[name];\r\n        if (feature && feature.enabled) {\r\n            feature.enabled = false;\r\n            this.detachFeature(name);\r\n            feature.featureImplementation.dispose();\r\n            delete this._features[name];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * dispose this features manager\r\n     */\r\n    public dispose(): void {\r\n        this.getEnabledFeatures().forEach((feature) => {\r\n            this.disableFeature(feature);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.\r\n     * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.\r\n     *\r\n     * @param featureName the name of the feature to load or the class of the feature\r\n     * @param version optional version to load. if not provided the latest version will be enabled\r\n     * @param moduleOptions options provided to the module. Ses the module documentation / constructor\r\n     * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible\r\n     * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.\r\n     * @returns a new constructed feature or throws an error if feature not found or conflicts with another enabled feature.\r\n     */\r\n    public enableFeature(\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        featureName: string | { Name: string },\r\n        version: number | string = \"latest\",\r\n        moduleOptions: any = {},\r\n        attachIfPossible: boolean = true,\r\n        required: boolean = true\r\n    ): IWebXRFeature {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        let versionToLoad = 0;\r\n        if (typeof version === \"string\") {\r\n            if (!version) {\r\n                throw new Error(`Error in provided version - ${name} (${version})`);\r\n            }\r\n            if (version === \"stable\") {\r\n                versionToLoad = WebXRFeaturesManager.GetStableVersionOfFeature(name);\r\n            } else if (version === \"latest\") {\r\n                versionToLoad = WebXRFeaturesManager.GetLatestVersionOfFeature(name);\r\n            } else {\r\n                // try loading the number the string represents\r\n                versionToLoad = +version;\r\n            }\r\n            if (versionToLoad === -1 || isNaN(versionToLoad)) {\r\n                throw new Error(`feature not found - ${name} (${version})`);\r\n            }\r\n        } else {\r\n            versionToLoad = version;\r\n        }\r\n\r\n        // check if there is a feature conflict\r\n        const conflictingFeature = WebXRFeaturesManager._ConflictingFeatures[name];\r\n        if (conflictingFeature !== undefined && this.getEnabledFeatures().indexOf(conflictingFeature) !== -1) {\r\n            throw new Error(`Feature ${name} cannot be enabled while ${conflictingFeature} is enabled.`);\r\n        }\r\n\r\n        // check if already initialized\r\n        const feature = this._features[name];\r\n        const constructFunction = WebXRFeaturesManager.ConstructFeature(name, versionToLoad, this._xrSessionManager, moduleOptions);\r\n        if (!constructFunction) {\r\n            // report error?\r\n            throw new Error(`feature not found - ${name}`);\r\n        }\r\n\r\n        /* If the feature is already enabled, detach and dispose it, and create a new one */\r\n        if (feature) {\r\n            this.disableFeature(name);\r\n        }\r\n\r\n        const constructed = constructFunction();\r\n        if (constructed.dependsOn) {\r\n            const dependentsFound = constructed.dependsOn.every((featureName) => !!this._features[featureName]);\r\n            if (!dependentsFound) {\r\n                throw new Error(`Dependant features missing. Make sure the following features are enabled - ${constructed.dependsOn.join(\", \")}`);\r\n            }\r\n        }\r\n        if (constructed.isCompatible()) {\r\n            this._features[name] = {\r\n                featureImplementation: constructed,\r\n                enabled: true,\r\n                version: versionToLoad,\r\n                required,\r\n            };\r\n\r\n            if (attachIfPossible) {\r\n                // if session started already, request and enable\r\n                if (this._xrSessionManager.session && !this._features[name].featureImplementation.attached) {\r\n                    // enable feature\r\n                    this.attachFeature(name);\r\n                }\r\n            } else {\r\n                // disable auto-attach when session starts\r\n                this._features[name].featureImplementation.disableAutoAttach = true;\r\n            }\r\n\r\n            return this._features[name].featureImplementation;\r\n        } else {\r\n            if (required) {\r\n                throw new Error(\"required feature not compatible\");\r\n            } else {\r\n                Tools.Warn(`Feature ${name} not compatible with the current environment/browser and was not enabled.`);\r\n                return constructed;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the implementation of an enabled feature.\r\n     * @param featureName the name of the feature to load\r\n     * @returns the feature class, if found\r\n     */\r\n    public getEnabledFeature(featureName: string): IWebXRFeature {\r\n        return this._features[featureName] && this._features[featureName].featureImplementation;\r\n    }\r\n\r\n    /**\r\n     * Get the list of enabled features\r\n     * @returns an array of enabled features\r\n     */\r\n    public getEnabledFeatures() {\r\n        return Object.keys(this._features);\r\n    }\r\n\r\n    /**\r\n     * This function will extend the session creation configuration object with enabled features.\r\n     * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,\r\n     * according to the defined \"required\" variable, provided during enableFeature call\r\n     * @param xrSessionInit the xr Session init object to extend\r\n     *\r\n     * @returns an extended XRSessionInit object\r\n     */\r\n    public async _extendXRSessionInitObject(xrSessionInit: XRSessionInit): Promise<XRSessionInit> {\r\n        const enabledFeatures = this.getEnabledFeatures();\r\n        for (const featureName of enabledFeatures) {\r\n            const feature = this._features[featureName];\r\n            const nativeName = feature.featureImplementation.xrNativeFeatureName;\r\n            if (nativeName) {\r\n                if (feature.required) {\r\n                    xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];\r\n                    if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.requiredFeatures.push(nativeName);\r\n                    }\r\n                } else {\r\n                    xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];\r\n                    if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.optionalFeatures.push(nativeName);\r\n                    }\r\n                }\r\n            }\r\n            if (feature.featureImplementation.getXRSessionInitExtension) {\r\n                const extended = await feature.featureImplementation.getXRSessionInitExtension();\r\n                xrSessionInit = {\r\n                    ...xrSessionInit,\r\n                    ...extended,\r\n                };\r\n            }\r\n        }\r\n        return xrSessionInit;\r\n    }\r\n}\r\n", "import type { IWebXRFeature } from \"../webXRFeaturesManager\";\r\nimport type { Observer, Observable, EventState } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\n\r\n/**\r\n * This is the base class for all WebXR features.\r\n * Since most features require almost the same resources and callbacks, this class can be used to simplify the development\r\n * Note that since the features manager is using the `IWebXRFeature` you are in no way obligated to use this class\r\n */\r\nexport abstract class WebXRAbstractFeature implements IWebXRFeature {\r\n    private _attached: boolean = false;\r\n    private _removeOnDetach: {\r\n        observer: Nullable<Observer<any>>;\r\n        observable: Observable<any>;\r\n    }[] = [];\r\n\r\n    /**\r\n     * Is this feature disposed?\r\n     */\r\n    public isDisposed: boolean = false;\r\n\r\n    /**\r\n     * Should auto-attach be disabled?\r\n     */\r\n    public disableAutoAttach: boolean = false;\r\n\r\n    /**\r\n     * The name of the native xr feature name (like anchor, hit-test, or hand-tracking)\r\n     */\r\n    public xrNativeFeatureName: string = \"\";\r\n\r\n    /**\r\n     * Construct a new (abstract) WebXR feature\r\n     * @param _xrSessionManager the xr session manager for this feature\r\n     */\r\n    constructor(protected _xrSessionManager: WebXRSessionManager) {}\r\n\r\n    /**\r\n     * Is this feature attached\r\n     */\r\n    public get attached() {\r\n        return this._attached;\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     *\r\n     * @param force should attachment be forced (even when already attached)\r\n     * @returns true if successful, false is failed or already attached\r\n     */\r\n    public attach(force?: boolean): boolean {\r\n        // do not attach a disposed feature\r\n        if (this.isDisposed) {\r\n            return false;\r\n        }\r\n        if (!force) {\r\n            if (this.attached) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (this.attached) {\r\n                // detach first, to be sure\r\n                this.detach();\r\n            }\r\n        }\r\n\r\n        this._attached = true;\r\n        this._addNewAttachObserver(this._xrSessionManager.onXRFrameObservable, (frame) => this._onXRFrame(frame));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     *\r\n     * @returns true if successful, false if failed or already detached\r\n     */\r\n    public detach(): boolean {\r\n        if (!this._attached) {\r\n            this.disableAutoAttach = true;\r\n            return false;\r\n        }\r\n        this._attached = false;\r\n        this._removeOnDetach.forEach((toRemove) => {\r\n            toRemove.observable.remove(toRemove.observer);\r\n        });\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        this.detach();\r\n        this.isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * This function will be executed during before enabling the feature and can be used to not-allow enabling it.\r\n     * Note that at this point the session has NOT started, so this is purely checking if the browser supports it\r\n     *\r\n     * @returns whether or not the feature is compatible in this environment\r\n     */\r\n    public isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * This is used to register callbacks that will automatically be removed when detach is called.\r\n     * @param observable the observable to which the observer will be attached\r\n     * @param callback the callback to register\r\n     */\r\n    protected _addNewAttachObserver<T>(observable: Observable<T>, callback: (eventData: T, eventState: EventState) => void) {\r\n        this._removeOnDetach.push({\r\n            observable,\r\n            observer: observable.add(callback),\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Code in this function will be executed on each xrFrame received from the browser.\r\n     * This function will not execute after the feature is detached.\r\n     * @param _xrFrame the current frame\r\n     */\r\n    protected abstract _onXRFrame(_xrFrame: XRFrame): void;\r\n}\r\n", "import type { Vector3 } from \"../Maths/math.vector\";\r\nimport type { IPhysicsEnginePlugin } from \"./IPhysicsEngine\";\r\n/**\r\n * Interface for Physics-Joint data\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface PhysicsJointData {\r\n    //Important for some engines, optional!\r\n    /**\r\n     * The main pivot of the joint\r\n     */\r\n    mainPivot?: Vector3;\r\n    /**\r\n     * The connected pivot of the joint\r\n     */\r\n    connectedPivot?: Vector3;\r\n    /**\r\n     * The main axis of the joint\r\n     */\r\n    mainAxis?: Vector3;\r\n    /**\r\n     * The connected axis of the joint\r\n     */\r\n    connectedAxis?: Vector3;\r\n    /**\r\n     * The collision of the joint\r\n     */\r\n    collision?: boolean;\r\n    /**\r\n     * Native Oimo/Cannon/Energy data\r\n     */\r\n    nativeParams?: any;\r\n}\r\n\r\n/**\r\n * This is a holder class for the physics joint created by the physics plugin\r\n * It holds a set of functions to control the underlying joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class PhysicsJoint {\r\n    private _physicsJoint: any;\r\n    protected _physicsPlugin: IPhysicsEnginePlugin;\r\n\r\n    /**\r\n     * Initializes the physics joint\r\n     * @param type The type of the physics joint\r\n     * @param jointData The data for the physics joint\r\n     */\r\n    constructor(\r\n        /**\r\n         * The type of the physics joint\r\n         */\r\n        public type: number,\r\n        /**\r\n         * The data for the physics joint\r\n         */\r\n        public jointData: PhysicsJointData\r\n    ) {\r\n        jointData.nativeParams = jointData.nativeParams || {};\r\n    }\r\n\r\n    /**\r\n     * Gets the physics joint\r\n     */\r\n    public get physicsJoint(): any {\r\n        return this._physicsJoint;\r\n    }\r\n\r\n    /**\r\n     * Sets the physics joint\r\n     */\r\n    public set physicsJoint(newJoint: any) {\r\n        if (this._physicsJoint) {\r\n            //remove from the world\r\n        }\r\n\r\n        this._physicsJoint = newJoint;\r\n    }\r\n\r\n    /**\r\n     * Sets the physics plugin\r\n     */\r\n    public set physicsPlugin(physicsPlugin: IPhysicsEnginePlugin) {\r\n        this._physicsPlugin = physicsPlugin;\r\n    }\r\n\r\n    /**\r\n     * Execute a function that is physics-plugin specific.\r\n     * @param {Function} func the function that will be executed.\r\n     *                        It accepts two parameters: the physics world and the physics joint\r\n     */\r\n    public executeNativeFunction(func: (world: any, physicsJoint: any) => void) {\r\n        func(this._physicsPlugin.world, this._physicsJoint);\r\n    }\r\n\r\n    //TODO check if the native joints are the same\r\n\r\n    //Joint Types\r\n    /**\r\n     * Distance-Joint type\r\n     */\r\n    public static DistanceJoint = 0;\r\n    /**\r\n     * Hinge-Joint type\r\n     */\r\n    public static HingeJoint = 1;\r\n    /**\r\n     * Ball-and-Socket joint type\r\n     */\r\n    public static BallAndSocketJoint = 2;\r\n    /**\r\n     * Wheel-Joint type\r\n     */\r\n    public static WheelJoint = 3;\r\n    /**\r\n     * Slider-Joint type\r\n     */\r\n    public static SliderJoint = 4;\r\n    //OIMO\r\n    /**\r\n     * Prismatic-Joint type\r\n     */\r\n    public static PrismaticJoint = 5;\r\n    //\r\n    /**\r\n     * Universal-Joint type\r\n     * ENERGY FTW! (compare with this - @see http://ode-wiki.org/wiki/index.php?title=Manual:_Joint_Types_and_Functions)\r\n     */\r\n    public static UniversalJoint = 6;\r\n    /**\r\n     * Hinge-Joint 2 type\r\n     */\r\n    public static Hinge2Joint = PhysicsJoint.WheelJoint;\r\n    //Cannon\r\n    /**\r\n     * Point to Point Joint type.  Similar to a Ball-Joint.  Different in parameters\r\n     */\r\n    public static PointToPointJoint = 8;\r\n    //Cannon only at the moment\r\n    /**\r\n     * Spring-Joint type\r\n     */\r\n    public static SpringJoint = 9;\r\n    /**\r\n     * Lock-Joint type\r\n     */\r\n    public static LockJoint = 10;\r\n}\r\n\r\n/**\r\n * A class representing a physics distance joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class DistanceJoint extends PhysicsJoint {\r\n    /**\r\n     *\r\n     * @param jointData The data for the Distance-Joint\r\n     */\r\n    constructor(jointData: DistanceJointData) {\r\n        super(PhysicsJoint.DistanceJoint, jointData);\r\n    }\r\n\r\n    /**\r\n     * Update the predefined distance.\r\n     * @param maxDistance The maximum preferred distance\r\n     * @param minDistance The minimum preferred distance\r\n     */\r\n    public updateDistance(maxDistance: number, minDistance?: number) {\r\n        this._physicsPlugin.updateDistanceJoint(this, maxDistance, minDistance);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a Motor-Enabled Joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class MotorEnabledJoint extends PhysicsJoint implements IMotorEnabledJoint {\r\n    /**\r\n     * Initializes the Motor-Enabled Joint\r\n     * @param type The type of the joint\r\n     * @param jointData The physical joint data for the joint\r\n     */\r\n    constructor(type: number, jointData: PhysicsJointData) {\r\n        super(type, jointData);\r\n    }\r\n\r\n    /**\r\n     * Set the motor values.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param force the force to apply\r\n     * @param maxForce max force for this motor.\r\n     */\r\n    public setMotor(force?: number, maxForce?: number) {\r\n        this._physicsPlugin.setMotor(this, force || 0, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Set the motor's limits.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param upperLimit The upper limit of the motor\r\n     * @param lowerLimit The lower limit of the motor\r\n     */\r\n    public setLimit(upperLimit: number, lowerLimit?: number) {\r\n        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);\r\n    }\r\n}\r\n\r\n/**\r\n * This class represents a single physics Hinge-Joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class HingeJoint extends MotorEnabledJoint {\r\n    /**\r\n     * Initializes the Hinge-Joint\r\n     * @param jointData The joint data for the Hinge-Joint\r\n     */\r\n    constructor(jointData: PhysicsJointData) {\r\n        super(PhysicsJoint.HingeJoint, jointData);\r\n    }\r\n\r\n    /**\r\n     * Set the motor values.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param {number} force the force to apply\r\n     * @param {number} maxForce max force for this motor.\r\n     */\r\n    public setMotor(force?: number, maxForce?: number) {\r\n        this._physicsPlugin.setMotor(this, force || 0, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Set the motor's limits.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param upperLimit The upper limit of the motor\r\n     * @param lowerLimit The lower limit of the motor\r\n     */\r\n    public setLimit(upperLimit: number, lowerLimit?: number) {\r\n        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);\r\n    }\r\n}\r\n\r\n/**\r\n * This class represents a dual hinge physics joint (same as wheel joint)\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class Hinge2Joint extends MotorEnabledJoint {\r\n    /**\r\n     * Initializes the Hinge2-Joint\r\n     * @param jointData The joint data for the Hinge2-Joint\r\n     */\r\n    constructor(jointData: PhysicsJointData) {\r\n        super(PhysicsJoint.Hinge2Joint, jointData);\r\n    }\r\n\r\n    /**\r\n     * Set the motor values.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param targetSpeed the speed the motor is to reach\r\n     * @param maxForce max force for this motor.\r\n     * @param motorIndex motor's index, 0 or 1.\r\n     */\r\n    public setMotor(targetSpeed?: number, maxForce?: number, motorIndex: number = 0) {\r\n        this._physicsPlugin.setMotor(this, targetSpeed || 0, maxForce, motorIndex);\r\n    }\r\n\r\n    /**\r\n     * Set the motor limits.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param upperLimit the upper limit\r\n     * @param lowerLimit lower limit\r\n     * @param motorIndex the motor's index, 0 or 1.\r\n     */\r\n    public setLimit(upperLimit: number, lowerLimit?: number, motorIndex: number = 0) {\r\n        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit, motorIndex);\r\n    }\r\n}\r\n\r\n/**\r\n * Interface for a motor enabled joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface IMotorEnabledJoint {\r\n    /**\r\n     * Physics joint\r\n     */\r\n    physicsJoint: any;\r\n    /**\r\n     * Sets the motor of the motor-enabled joint\r\n     * @param force The force of the motor\r\n     * @param maxForce The maximum force of the motor\r\n     * @param motorIndex The index of the motor\r\n     */\r\n    setMotor(force?: number, maxForce?: number, motorIndex?: number): void;\r\n    /**\r\n     * Sets the limit of the motor\r\n     * @param upperLimit The upper limit of the motor\r\n     * @param lowerLimit The lower limit of the motor\r\n     * @param motorIndex The index of the motor\r\n     */\r\n    setLimit(upperLimit: number, lowerLimit?: number, motorIndex?: number): void;\r\n}\r\n\r\n/**\r\n * Joint data for a Distance-Joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface DistanceJointData extends PhysicsJointData {\r\n    /**\r\n     * Max distance the 2 joint objects can be apart\r\n     */\r\n    maxDistance: number;\r\n    //Oimo - minDistance\r\n    //Cannon - maxForce\r\n}\r\n\r\n/**\r\n * Joint data from a spring joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface SpringJointData extends PhysicsJointData {\r\n    /**\r\n     * Length of the spring\r\n     */\r\n    length: number;\r\n    /**\r\n     * Stiffness of the spring\r\n     */\r\n    stiffness: number;\r\n    /**\r\n     * Damping of the spring\r\n     */\r\n    damping: number;\r\n    /** this callback will be called when applying the force to the impostors. */\r\n    forceApplicationCallback: () => void;\r\n}\r\n", "import type { Nullable, IndicesArray } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { Vector3, Quaternion } from \"../Maths/math.vector\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Bone } from \"../Bones/bone\";\r\nimport type { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { IPhysicsEngine } from \"./IPhysicsEngine\";\r\nimport type { PhysicsJointData } from \"./physicsJoint\";\r\nimport { PhysicsJoint } from \"./physicsJoint\";\r\nimport { Space } from \"../Maths/math.axis\";\r\n\r\n/**\r\n * The interface for the physics imposter parameters\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface PhysicsImpostorParameters {\r\n    /**\r\n     * The mass of the physics imposter\r\n     */\r\n    mass: number;\r\n    /**\r\n     * The friction of the physics imposter\r\n     */\r\n    friction?: number;\r\n    /**\r\n     * The coefficient of restitution of the physics imposter\r\n     */\r\n    restitution?: number;\r\n    /**\r\n     * The native options of the physics imposter\r\n     */\r\n    nativeOptions?: any;\r\n    /**\r\n     * Specifies if the parent should be ignored\r\n     */\r\n    ignoreParent?: boolean;\r\n    /**\r\n     * Specifies if bi-directional transformations should be disabled\r\n     */\r\n    disableBidirectionalTransformation?: boolean;\r\n    /**\r\n     * The pressure inside the physics imposter, soft object only\r\n     */\r\n    pressure?: number;\r\n    /**\r\n     * The stiffness the physics imposter, soft object only\r\n     */\r\n    stiffness?: number;\r\n    /**\r\n     * The number of iterations used in maintaining consistent vertex velocities, soft object only\r\n     */\r\n    velocityIterations?: number;\r\n    /**\r\n     * The number of iterations used in maintaining consistent vertex positions, soft object only\r\n     */\r\n    positionIterations?: number;\r\n    /**\r\n     * The number used to fix points on a cloth (0, 1, 2, 4, 8) or rope (0, 1, 2) only\r\n     * 0 None, 1, back left or top, 2, back right or bottom, 4, front left, 8, front right\r\n     * Add to fix multiple points\r\n     */\r\n    fixedPoints?: number;\r\n    /**\r\n     * The collision margin around a soft object\r\n     */\r\n    margin?: number;\r\n    /**\r\n     * The collision margin around a soft object\r\n     */\r\n    damping?: number;\r\n    /**\r\n     * The path for a rope based on an extrusion\r\n     */\r\n    path?: any;\r\n    /**\r\n     * The shape of an extrusion used for a rope based on an extrusion\r\n     */\r\n    shape?: any;\r\n}\r\n\r\n/**\r\n * Interface for a physics-enabled object\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface IPhysicsEnabledObject {\r\n    /**\r\n     * The position of the physics-enabled object\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * The rotation of the physics-enabled object\r\n     */\r\n    rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * The scale of the physics-enabled object\r\n     */\r\n    scaling: Vector3;\r\n    /**\r\n     * The rotation of the physics-enabled object\r\n     */\r\n    rotation?: Vector3;\r\n    /**\r\n     * The parent of the physics-enabled object\r\n     */\r\n    parent?: any;\r\n    /**\r\n     * The bounding info of the physics-enabled object\r\n     * @returns The bounding info of the physics-enabled object\r\n     */\r\n    getBoundingInfo(): BoundingInfo;\r\n    /**\r\n     * Computes the world matrix\r\n     * @param force Specifies if the world matrix should be computed by force\r\n     * @returns A world matrix\r\n     */\r\n    computeWorldMatrix(force: boolean): Matrix;\r\n    /**\r\n     * Gets the world matrix\r\n     * @returns A world matrix\r\n     */\r\n    getWorldMatrix?(): Matrix;\r\n    /**\r\n     * Gets the child meshes\r\n     * @param directDescendantsOnly Specifies if only direct-descendants should be obtained\r\n     * @returns An array of abstract meshes\r\n     */\r\n    getChildMeshes?(directDescendantsOnly?: boolean): Array<AbstractMesh>;\r\n    /**\r\n     * Gets the vertex data\r\n     * @param kind The type of vertex data\r\n     * @returns A nullable array of numbers, or a float32 array\r\n     */\r\n    getVerticesData(kind: string): Nullable<Array<number> | Float32Array>;\r\n    /**\r\n     * Gets the indices from the mesh\r\n     * @returns A nullable array of index arrays\r\n     */\r\n    getIndices?(): Nullable<IndicesArray>;\r\n    /**\r\n     * Gets the scene from the mesh\r\n     * @returns the indices array or null\r\n     */\r\n    getScene?(): Scene;\r\n    /**\r\n     * Gets the absolute position from the mesh\r\n     * @returns the absolute position\r\n     */\r\n    getAbsolutePosition(): Vector3;\r\n    /**\r\n     * Gets the absolute pivot point from the mesh\r\n     * @returns the absolute pivot point\r\n     */\r\n    getAbsolutePivotPoint(): Vector3;\r\n    /**\r\n     * Rotates the mesh\r\n     * @param axis The axis of rotation\r\n     * @param amount The amount of rotation\r\n     * @param space The space of the rotation\r\n     * @returns The rotation transform node\r\n     */\r\n    rotate(axis: Vector3, amount: number, space?: Space): TransformNode;\r\n    /**\r\n     * Translates the mesh\r\n     * @param axis The axis of translation\r\n     * @param distance The distance of translation\r\n     * @param space The space of the translation\r\n     * @returns The transform node\r\n     */\r\n    translate(axis: Vector3, distance: number, space?: Space): TransformNode;\r\n    /**\r\n     * Sets the absolute position of the mesh\r\n     * @param absolutePosition The absolute position of the mesh\r\n     * @returns The transform node\r\n     */\r\n    setAbsolutePosition(absolutePosition: Vector3): TransformNode;\r\n    /**\r\n     * Gets the class name of the mesh\r\n     * @returns The class name\r\n     */\r\n    getClassName(): string;\r\n}\r\n\r\nMesh._PhysicsImpostorParser = function (scene: Scene, physicObject: IPhysicsEnabledObject, jsonObject: any): PhysicsImpostor {\r\n    return new PhysicsImpostor(\r\n        physicObject,\r\n        jsonObject.physicsImpostor,\r\n        {\r\n            mass: jsonObject.physicsMass,\r\n            friction: jsonObject.physicsFriction,\r\n            restitution: jsonObject.physicsRestitution,\r\n        },\r\n        scene\r\n    );\r\n};\r\n\r\n/**\r\n * Represents a physics imposter\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class PhysicsImpostor {\r\n    /**\r\n     * The default object size of the imposter\r\n     */\r\n    public static DEFAULT_OBJECT_SIZE: Vector3 = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * The identity quaternion of the imposter\r\n     */\r\n    public static IDENTITY_QUATERNION = Quaternion.Identity();\r\n\r\n    /** @internal */\r\n    public _pluginData: any = {};\r\n\r\n    private _physicsEngine: Nullable<IPhysicsEngine>;\r\n    //The native cannon/oimo/energy physics body object.\r\n    private _physicsBody: any;\r\n    private _bodyUpdateRequired: boolean = false;\r\n\r\n    private _onBeforePhysicsStepCallbacks = new Array<(impostor: PhysicsImpostor) => void>();\r\n    private _onAfterPhysicsStepCallbacks = new Array<(impostor: PhysicsImpostor) => void>();\r\n    /** @internal */\r\n    public _onPhysicsCollideCallbacks: Array<{\r\n        callback: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor, point: Nullable<Vector3>, distance: number, impulse: number, normal: Nullable<Vector3>) => void;\r\n        otherImpostors: Array<PhysicsImpostor>;\r\n    }> = [];\r\n\r\n    private _deltaPosition: Vector3 = Vector3.Zero();\r\n    private _deltaRotation: Quaternion;\r\n    private _deltaRotationConjugated: Quaternion;\r\n\r\n    /** @internal */\r\n    public _isFromLine: boolean;\r\n\r\n    //If set, this is this impostor's parent\r\n    private _parent: Nullable<PhysicsImpostor>;\r\n\r\n    private _isDisposed = false;\r\n\r\n    private static _TmpVecs: Vector3[] = ArrayTools.BuildArray(3, Vector3.Zero);\r\n    private static _TmpQuat: Quaternion = Quaternion.Identity();\r\n\r\n    /**\r\n     * Specifies if the physics imposter is disposed\r\n     */\r\n    get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets the mass of the physics imposter\r\n     */\r\n    get mass(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;\r\n    }\r\n\r\n    set mass(value: number) {\r\n        this.setMass(value);\r\n    }\r\n\r\n    /**\r\n     * Gets the coefficient of friction\r\n     */\r\n    get friction(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the coefficient of friction\r\n     */\r\n    set friction(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the coefficient of restitution\r\n     */\r\n    get restitution(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the coefficient of restitution\r\n     */\r\n    set restitution(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the pressure of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get pressure(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPressure) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyPressure!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the pressure of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set pressure(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPressure) {\r\n            return;\r\n        }\r\n        plugin.setBodyPressure!(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the stiffness of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get stiffness(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyStiffness) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyStiffness!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the stiffness of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set stiffness(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyStiffness) {\r\n            return;\r\n        }\r\n        plugin.setBodyStiffness!(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get velocityIterations(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyVelocityIterations) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyVelocityIterations!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set velocityIterations(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyVelocityIterations) {\r\n            return;\r\n        }\r\n        plugin.setBodyVelocityIterations!(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the positionIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get positionIterations(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyPositionIterations) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyPositionIterations!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the positionIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set positionIterations(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPositionIterations) {\r\n            return;\r\n        }\r\n        plugin.setBodyPositionIterations!(this, value);\r\n    }\r\n\r\n    /**\r\n     * The unique id of the physics imposter\r\n     * set by the physics engine when adding this impostor to the array\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public soft: boolean = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public segments: number = 0;\r\n\r\n    private _joints: Array<{\r\n        joint: PhysicsJoint;\r\n        otherImpostor: PhysicsImpostor;\r\n    }>;\r\n\r\n    /**\r\n     * Initializes the physics imposter\r\n     * @param object The physics-enabled object used as the physics imposter\r\n     * @param type The type of the physics imposter. Types are available as static members of this class.\r\n     * @param _options The options for the physics imposter\r\n     * @param _scene The Babylon scene\r\n     */\r\n    constructor(\r\n        /**\r\n         * The physics-enabled object used as the physics imposter\r\n         */\r\n        public object: IPhysicsEnabledObject,\r\n        /**\r\n         * The type of the physics imposter\r\n         */\r\n        public type: number,\r\n        private _options: PhysicsImpostorParameters = { mass: 0 },\r\n        private _scene?: Scene\r\n    ) {\r\n        //sanity check!\r\n        if (!this.object) {\r\n            Logger.Error(\"No object was provided. A physics object is obligatory\");\r\n            return;\r\n        }\r\n        if (this.object.parent && _options.mass !== 0) {\r\n            Logger.Warn(\"A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur.\");\r\n        }\r\n\r\n        // Legacy support for old syntax.\r\n        if (!this._scene && object.getScene) {\r\n            this._scene = object.getScene();\r\n        }\r\n\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n\r\n        if (this.type > 100) {\r\n            this.soft = true;\r\n        }\r\n\r\n        this._physicsEngine = this._scene.getPhysicsEngine();\r\n        if (!this._physicsEngine) {\r\n            Logger.Error(\"Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.\");\r\n        } else {\r\n            //set the object's quaternion, if not set\r\n            if (!this.object.rotationQuaternion) {\r\n                if (this.object.rotation) {\r\n                    this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);\r\n                } else {\r\n                    this.object.rotationQuaternion = new Quaternion();\r\n                }\r\n            }\r\n            //default options params\r\n            this._options.mass = _options.mass === void 0 ? 0 : _options.mass;\r\n            this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;\r\n            this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;\r\n            if (this.soft) {\r\n                //softbody mass must be above 0;\r\n                this._options.mass = this._options.mass > 0 ? this._options.mass : 1;\r\n                this._options.pressure = _options.pressure === void 0 ? 200 : _options.pressure;\r\n                this._options.stiffness = _options.stiffness === void 0 ? 1 : _options.stiffness;\r\n                this._options.velocityIterations = _options.velocityIterations === void 0 ? 20 : _options.velocityIterations;\r\n                this._options.positionIterations = _options.positionIterations === void 0 ? 20 : _options.positionIterations;\r\n                this._options.fixedPoints = _options.fixedPoints === void 0 ? 0 : _options.fixedPoints;\r\n                this._options.margin = _options.margin === void 0 ? 0 : _options.margin;\r\n                this._options.damping = _options.damping === void 0 ? 0 : _options.damping;\r\n                this._options.path = _options.path === void 0 ? null : _options.path;\r\n                this._options.shape = _options.shape === void 0 ? null : _options.shape;\r\n            }\r\n            this._joints = [];\r\n            //If the mesh has a parent, don't initialize the physicsBody. Instead wait for the parent to do that.\r\n            if (!this.object.parent || this._options.ignoreParent) {\r\n                this._init();\r\n            } else if (this.object.parent.physicsImpostor) {\r\n                Logger.Warn(\"You must affect impostors to children before affecting impostor to parent.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will completely initialize this impostor.\r\n     * It will create a new body - but only if this mesh has no parent.\r\n     * If it has, this impostor will not be used other than to define the impostor\r\n     * of the child mesh.\r\n     * @internal\r\n     */\r\n    public _init() {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._physicsEngine.removeImpostor(this);\r\n        this.physicsBody = null;\r\n        this._parent = this._parent || this._getPhysicsParent();\r\n        if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {\r\n            this._physicsEngine.addImpostor(this);\r\n        }\r\n    }\r\n\r\n    private _getPhysicsParent(): Nullable<PhysicsImpostor> {\r\n        if (this.object.parent instanceof AbstractMesh) {\r\n            const parentMesh: AbstractMesh = <AbstractMesh>this.object.parent;\r\n            return parentMesh.physicsImpostor;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Should a new body be generated.\r\n     * @returns boolean specifying if body initialization is required\r\n     */\r\n    public isBodyInitRequired(): boolean {\r\n        return this._bodyUpdateRequired || (!this._physicsBody && (!this._parent || !!this._options.ignoreParent));\r\n    }\r\n\r\n    /**\r\n     * Sets the updated scaling\r\n     */\r\n    public setScalingUpdated() {\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Force a regeneration of this or the parent's impostor's body.\r\n     * Use with caution - This will remove all previously-instantiated joints.\r\n     */\r\n    public forceUpdate() {\r\n        this._init();\r\n        if (this.parent && !this._options.ignoreParent) {\r\n            this.parent.forceUpdate();\r\n        }\r\n    }\r\n\r\n    /*public get mesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }*/\r\n\r\n    /**\r\n     * Gets the body that holds this impostor. Either its own, or its parent.\r\n     */\r\n    public get physicsBody(): any {\r\n        return this._parent && !this._options.ignoreParent ? this._parent.physicsBody : this._physicsBody;\r\n    }\r\n\r\n    /**\r\n     * Get the parent of the physics imposter\r\n     * @returns Physics imposter or null\r\n     */\r\n    public get parent(): Nullable<PhysicsImpostor> {\r\n        return !this._options.ignoreParent && this._parent ? this._parent : null;\r\n    }\r\n\r\n    /**\r\n     * Sets the parent of the physics imposter\r\n     */\r\n    public set parent(value: Nullable<PhysicsImpostor>) {\r\n        this._parent = value;\r\n    }\r\n\r\n    /**\r\n     * Set the physics body. Used mainly by the physics engine/plugin\r\n     */\r\n    public set physicsBody(physicsBody: any) {\r\n        if (this._physicsBody && this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);\r\n        }\r\n        this._physicsBody = physicsBody;\r\n        this.resetUpdateFlags();\r\n    }\r\n\r\n    /**\r\n     * Resets the update flags\r\n     */\r\n    public resetUpdateFlags() {\r\n        this._bodyUpdateRequired = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the object extents\r\n     * @returns the object extents\r\n     */\r\n    public getObjectExtents(): Vector3 {\r\n        if (this.object.getBoundingInfo) {\r\n            const q = this.object.rotationQuaternion;\r\n            const scaling = this.object.scaling.clone();\r\n            //reset rotation\r\n            this.object.rotationQuaternion = PhysicsImpostor.IDENTITY_QUATERNION;\r\n            //calculate the world matrix with no rotation\r\n            const worldMatrix = this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\r\n            if (worldMatrix) {\r\n                worldMatrix.decompose(scaling, undefined, undefined);\r\n            }\r\n            const boundingInfo = this.object.getBoundingInfo();\r\n            // get the global scaling of the object\r\n            const size = boundingInfo.boundingBox.extendSize.scale(2).multiplyInPlace(scaling);\r\n            size.x = Math.abs(size.x);\r\n            size.y = Math.abs(size.y);\r\n            size.z = Math.abs(size.z);\r\n            //bring back the rotation\r\n            this.object.rotationQuaternion = q;\r\n            //calculate the world matrix with the new rotation\r\n            this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\r\n            return size;\r\n        } else {\r\n            return PhysicsImpostor.DEFAULT_OBJECT_SIZE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the object center\r\n     * @returns The object center\r\n     */\r\n    public getObjectCenter(): Vector3 {\r\n        if (this.object.getBoundingInfo) {\r\n            const boundingInfo = this.object.getBoundingInfo();\r\n            return boundingInfo.boundingBox.centerWorld;\r\n        } else {\r\n            return this.object.position;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a specific parameter from the options parameters\r\n     * @param paramName The object parameter name\r\n     * @returns The object parameter\r\n     */\r\n    public getParam(paramName: string): any {\r\n        return (<any>this._options)[paramName];\r\n    }\r\n\r\n    /**\r\n     * Sets a specific parameter in the options given to the physics plugin\r\n     * @param paramName The parameter name\r\n     * @param value The value of the parameter\r\n     */\r\n    public setParam(paramName: string, value: number) {\r\n        (<any>this._options)[paramName] = value;\r\n        this._bodyUpdateRequired = true;\r\n    }\r\n\r\n    /**\r\n     * Specifically change the body's mass. Won't recreate the physics body object\r\n     * @param mass The mass of the physics imposter\r\n     */\r\n    public setMass(mass: number) {\r\n        if (this.getParam(\"mass\") !== mass) {\r\n            this.setParam(\"mass\", mass);\r\n        }\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the linear velocity\r\n     * @returns  linear velocity or null\r\n     */\r\n    public getLinearVelocity(): Nullable<Vector3> {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity\r\n     * @param velocity  linear velocity or null\r\n     */\r\n    public setLinearVelocity(velocity: Nullable<Vector3>) {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the angular velocity\r\n     * @returns angular velocity or null\r\n     */\r\n    public getAngularVelocity(): Nullable<Vector3> {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity\r\n     * @param velocity The velocity or null\r\n     */\r\n    public setAngularVelocity(velocity: Nullable<Vector3>) {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a function with the physics plugin native code\r\n     * Provide a function the will have two variables - the world object and the physics body object\r\n     * @param func The function to execute with the physics plugin native code\r\n     */\r\n    public executeNativeFunction(func: (world: any, physicsBody: any) => void) {\r\n        if (this._physicsEngine) {\r\n            func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a function that will be executed before the physics world is stepping forward\r\n     * @param func The function to execute before the physics world is stepped forward\r\n     */\r\n    public registerBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        this._onBeforePhysicsStepCallbacks.push(func);\r\n    }\r\n\r\n    /**\r\n     * Unregister a function that will be executed before the physics world is stepping forward\r\n     * @param func The function to execute before the physics world is stepped forward\r\n     */\r\n    public unregisterBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        const index = this._onBeforePhysicsStepCallbacks.indexOf(func);\r\n\r\n        if (index > -1) {\r\n            this._onBeforePhysicsStepCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a function that will be executed after the physics step\r\n     * @param func The function to execute after physics step\r\n     */\r\n    public registerAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        this._onAfterPhysicsStepCallbacks.push(func);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a function that will be executed after the physics step\r\n     * @param func The function to execute after physics step\r\n     */\r\n    public unregisterAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        const index = this._onAfterPhysicsStepCallbacks.indexOf(func);\r\n\r\n        if (index > -1) {\r\n            this._onAfterPhysicsStepCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * register a function that will be executed when this impostor collides against a different body\r\n     * @param collideAgainst Physics imposter, or array of physics imposters to collide against\r\n     * @param func Callback that is executed on collision\r\n     */\r\n    public registerOnPhysicsCollide(\r\n        collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>,\r\n        func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor, point: Nullable<Vector3>) => void\r\n    ): void {\r\n        const collidedAgainstList: Array<PhysicsImpostor> = collideAgainst instanceof Array ? <Array<PhysicsImpostor>>collideAgainst : [<PhysicsImpostor>collideAgainst];\r\n        this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });\r\n    }\r\n\r\n    /**\r\n     * Unregisters the physics imposter's collision callback\r\n     * @param collideAgainst The physics object to collide against\r\n     * @param func Callback to execute on collision\r\n     */\r\n    public unregisterOnPhysicsCollide(\r\n        collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>,\r\n        func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor | Array<PhysicsImpostor>, point: Nullable<Vector3>) => void\r\n    ): void {\r\n        const collidedAgainstList: Array<PhysicsImpostor> = collideAgainst instanceof Array ? <Array<PhysicsImpostor>>collideAgainst : [<PhysicsImpostor>collideAgainst];\r\n        let index = -1;\r\n        const found = this._onPhysicsCollideCallbacks.some((cbDef, idx) => {\r\n            if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {\r\n                // chcek the arrays match\r\n                const sameList = cbDef.otherImpostors.every((impostor) => {\r\n                    return collidedAgainstList.indexOf(impostor) > -1;\r\n                });\r\n                if (sameList) {\r\n                    index = idx;\r\n                }\r\n                return sameList;\r\n            }\r\n            return false;\r\n        });\r\n\r\n        if (found) {\r\n            this._onPhysicsCollideCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    //temp variables for parent rotation calculations\r\n    //private _mats: Array<Matrix> = [new Matrix(), new Matrix()];\r\n    private _tmpQuat: Quaternion = new Quaternion();\r\n    private _tmpQuat2: Quaternion = new Quaternion();\r\n\r\n    /**\r\n     * Get the parent rotation\r\n     * @returns The parent rotation\r\n     */\r\n    public getParentsRotation(): Quaternion {\r\n        let parent = this.object.parent;\r\n        this._tmpQuat.copyFromFloats(0, 0, 0, 1);\r\n        while (parent) {\r\n            if (parent.rotationQuaternion) {\r\n                this._tmpQuat2.copyFrom(parent.rotationQuaternion);\r\n            } else {\r\n                Quaternion.RotationYawPitchRollToRef(parent.rotation.y, parent.rotation.x, parent.rotation.z, this._tmpQuat2);\r\n            }\r\n            this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat);\r\n            parent = parent.parent;\r\n        }\r\n        return this._tmpQuat;\r\n    }\r\n\r\n    /**\r\n     * this function is executed by the physics engine.\r\n     */\r\n    public beforeStep = () => {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this.object.translate(this._deltaPosition, -1);\r\n        this._deltaRotationConjugated &&\r\n            this.object.rotationQuaternion &&\r\n            this.object.rotationQuaternion.multiplyToRef(this._deltaRotationConjugated, this.object.rotationQuaternion);\r\n        this.object.computeWorldMatrix(false);\r\n        if (this.object.parent && this.object.rotationQuaternion) {\r\n            this.getParentsRotation();\r\n            this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this._tmpQuat);\r\n        } else {\r\n            this._tmpQuat.copyFrom(this.object.rotationQuaternion || new Quaternion());\r\n        }\r\n        if (!this._options.disableBidirectionalTransformation) {\r\n            this.object.rotationQuaternion &&\r\n                this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(this, /*bInfo.boundingBox.centerWorld*/ this.object.getAbsolutePosition(), this._tmpQuat);\r\n        }\r\n\r\n        this._onBeforePhysicsStepCallbacks.forEach((func) => {\r\n            func(this);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * this function is executed by the physics engine\r\n     */\r\n    public afterStep = () => {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._onAfterPhysicsStepCallbacks.forEach((func) => {\r\n            func(this);\r\n        });\r\n\r\n        this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(this);\r\n        // object has now its world rotation. needs to be converted to local.\r\n        if (this.object.parent && this.object.rotationQuaternion) {\r\n            this.getParentsRotation();\r\n            this._tmpQuat.conjugateInPlace();\r\n            this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this.object.rotationQuaternion);\r\n        }\r\n        // take the position set and make it the absolute position of this object.\r\n        this.object.setAbsolutePosition(this.object.position);\r\n        if (this._deltaRotation) {\r\n            this.object.rotationQuaternion && this.object.rotationQuaternion.multiplyToRef(this._deltaRotation, this.object.rotationQuaternion);\r\n            this._deltaPosition.applyRotationQuaternionToRef(this._deltaRotation, PhysicsImpostor._TmpVecs[0]);\r\n            this.object.translate(PhysicsImpostor._TmpVecs[0], 1);\r\n        } else {\r\n            this.object.translate(this._deltaPosition, 1);\r\n        }\r\n        this.object.computeWorldMatrix(true);\r\n    };\r\n\r\n    /**\r\n     * Legacy collision detection event support\r\n     */\r\n    public onCollideEvent: Nullable<(collider: PhysicsImpostor, collidedWith: PhysicsImpostor) => void> = null;\r\n\r\n    /**\r\n     * event and body object due to cannon's event-based architecture.\r\n     * @param e\r\n     * @param e.body\r\n     * @param e.point\r\n     * @param e.distance\r\n     * @param e.impulse\r\n     * @param e.normal\r\n     */\r\n    public onCollide = (e: { body: any; point: Nullable<Vector3>; distance: number; impulse: number; normal: Nullable<Vector3> }) => {\r\n        if (!this._onPhysicsCollideCallbacks.length && !this.onCollideEvent) {\r\n            return;\r\n        }\r\n\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const otherImpostor = this._physicsEngine.getImpostorWithPhysicsBody(e.body);\r\n        if (otherImpostor) {\r\n            // Legacy collision detection event support\r\n            if (this.onCollideEvent) {\r\n                this.onCollideEvent(this, otherImpostor);\r\n            }\r\n            this._onPhysicsCollideCallbacks\r\n                .filter((obj) => {\r\n                    return obj.otherImpostors.indexOf(<PhysicsImpostor>otherImpostor) !== -1;\r\n                })\r\n                .forEach((obj) => {\r\n                    obj.callback(this, <PhysicsImpostor>otherImpostor, e.point, e.distance, e.impulse, e.normal);\r\n                });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Apply a force\r\n     * @param force The force to apply\r\n     * @param contactPoint The contact point for the force\r\n     * @returns The physics imposter\r\n     */\r\n    public applyForce(force: Vector3, contactPoint: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Apply an impulse\r\n     * @param force The impulse force\r\n     * @param contactPoint The contact point for the impulse force\r\n     * @returns The physics imposter\r\n     */\r\n    public applyImpulse(force: Vector3, contactPoint: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A help function to create a joint\r\n     * @param otherImpostor A physics imposter used to create a joint\r\n     * @param jointType The type of joint\r\n     * @param jointData The data for the joint\r\n     * @returns The physics imposter\r\n     */\r\n    public createJoint(otherImpostor: PhysicsImpostor, jointType: number, jointData: PhysicsJointData): PhysicsImpostor {\r\n        const joint = new PhysicsJoint(jointType, jointData);\r\n        this.addJoint(otherImpostor, joint);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a joint to this impostor with a different impostor\r\n     * @param otherImpostor A physics imposter used to add a joint\r\n     * @param joint The joint to add\r\n     * @returns The physics imposter\r\n     */\r\n    public addJoint(otherImpostor: PhysicsImpostor, joint: PhysicsJoint): PhysicsImpostor {\r\n        this._joints.push({\r\n            otherImpostor: otherImpostor,\r\n            joint: joint,\r\n        });\r\n\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.addJoint(this, otherImpostor, joint);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add an anchor to a cloth impostor\r\n     * @param otherImpostor rigid impostor to anchor to\r\n     * @param width ratio across width from 0 to 1\r\n     * @param height ratio up height from 0 to 1\r\n     * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between cloth impostor and anchor are ignored; default false\r\n     * @returns impostor the soft imposter\r\n     */\r\n    public addAnchor(otherImpostor: PhysicsImpostor, width: number, height: number, influence: number, noCollisionBetweenLinkedBodies: boolean): PhysicsImpostor {\r\n        if (!this._physicsEngine) {\r\n            return this;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.appendAnchor) {\r\n            return this;\r\n        }\r\n        if (this._physicsEngine) {\r\n            plugin.appendAnchor!(this, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a hook to a rope impostor\r\n     * @param otherImpostor rigid impostor to anchor to\r\n     * @param length ratio across rope from 0 to 1\r\n     * @param influence the elasticity between rope impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     * @returns impostor the rope imposter\r\n     */\r\n    public addHook(otherImpostor: PhysicsImpostor, length: number, influence: number, noCollisionBetweenLinkedBodies: boolean): PhysicsImpostor {\r\n        if (!this._physicsEngine) {\r\n            return this;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.appendAnchor) {\r\n            return this;\r\n        }\r\n        if (this._physicsEngine) {\r\n            plugin.appendHook!(this, otherImpostor, length, influence, noCollisionBetweenLinkedBodies);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Will keep this body still, in a sleep mode.\r\n     * @returns the physics imposter\r\n     */\r\n    public sleep(): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().sleepBody(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Wake the body up.\r\n     * @returns The physics imposter\r\n     */\r\n    public wakeUp(): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clones the physics imposter\r\n     * @param newObject The physics imposter clones to this physics-enabled object\r\n     * @returns A nullable physics imposter\r\n     */\r\n    public clone(newObject: IPhysicsEnabledObject): Nullable<PhysicsImpostor> {\r\n        if (!newObject) {\r\n            return null;\r\n        }\r\n        return new PhysicsImpostor(newObject, this.type, this._options, this._scene);\r\n    }\r\n\r\n    /**\r\n     * Disposes the physics imposter\r\n     */\r\n    public dispose(/*disposeChildren: boolean = true*/) {\r\n        //no dispose if no physics engine is available.\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._joints.forEach((j) => {\r\n            if (this._physicsEngine) {\r\n                this._physicsEngine.removeJoint(this, j.otherImpostor, j.joint);\r\n            }\r\n        });\r\n        //dispose the physics body\r\n        this._physicsEngine.removeImpostor(this);\r\n        if (this.parent) {\r\n            this.parent.forceUpdate();\r\n        } else {\r\n            /*this._object.getChildMeshes().forEach(function(mesh) {\r\n                if (mesh.physicsImpostor) {\r\n                    if (disposeChildren) {\r\n                        mesh.physicsImpostor.dispose();\r\n                        mesh.physicsImpostor = null;\r\n                    }\r\n                }\r\n            })*/\r\n        }\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the delta position\r\n     * @param position The delta position amount\r\n     */\r\n    public setDeltaPosition(position: Vector3) {\r\n        this._deltaPosition.copyFrom(position);\r\n    }\r\n\r\n    /**\r\n     * Sets the delta rotation\r\n     * @param rotation The delta rotation amount\r\n     */\r\n    public setDeltaRotation(rotation: Quaternion) {\r\n        if (!this._deltaRotation) {\r\n            this._deltaRotation = new Quaternion();\r\n        }\r\n        this._deltaRotation.copyFrom(rotation);\r\n        this._deltaRotationConjugated = this._deltaRotation.conjugate();\r\n    }\r\n\r\n    /**\r\n     * Gets the box size of the physics imposter and stores the result in the input parameter\r\n     * @param result Stores the box size\r\n     * @returns The physics imposter\r\n     */\r\n    public getBoxSizeToRef(result: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the radius of the physics imposter\r\n     * @returns Radius of the physics imposter\r\n     */\r\n    public getRadius(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sync a bone with this impostor\r\n     * @param bone The bone to sync to the impostor.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     */\r\n    public syncBoneWithImpostor(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion) {\r\n        const tempVec = PhysicsImpostor._TmpVecs[0];\r\n        const mesh = <AbstractMesh>this.object;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                const tempQuat = PhysicsImpostor._TmpQuat;\r\n                mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);\r\n                bone.setRotationQuaternion(tempQuat, Space.WORLD, boneMesh);\r\n            } else {\r\n                bone.setRotationQuaternion(mesh.rotationQuaternion, Space.WORLD, boneMesh);\r\n            }\r\n        }\r\n\r\n        tempVec.x = 0;\r\n        tempVec.y = 0;\r\n        tempVec.z = 0;\r\n\r\n        if (jointPivot) {\r\n            tempVec.x = jointPivot.x;\r\n            tempVec.y = jointPivot.y;\r\n            tempVec.z = jointPivot.z;\r\n\r\n            bone.getDirectionToRef(tempVec, boneMesh, tempVec);\r\n\r\n            if (distToJoint === undefined || distToJoint === null) {\r\n                distToJoint = jointPivot.length();\r\n            }\r\n\r\n            tempVec.x *= distToJoint;\r\n            tempVec.y *= distToJoint;\r\n            tempVec.z *= distToJoint;\r\n        }\r\n\r\n        if (bone.getParent()) {\r\n            tempVec.addInPlace(mesh.getAbsolutePosition());\r\n            bone.setAbsolutePosition(tempVec, boneMesh);\r\n        } else {\r\n            boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());\r\n            boneMesh.position.x -= tempVec.x;\r\n            boneMesh.position.y -= tempVec.y;\r\n            boneMesh.position.z -= tempVec.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sync impostor to a bone\r\n     * @param bone The bone that the impostor will be synced to.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     * @param boneAxis Optional vector3 axis the bone is aligned with\r\n     */\r\n    public syncImpostorWithBone(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion, boneAxis?: Vector3) {\r\n        const mesh = <AbstractMesh>this.object;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                const tempQuat = PhysicsImpostor._TmpQuat;\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);\r\n                tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);\r\n            } else {\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);\r\n            }\r\n        }\r\n\r\n        const pos = PhysicsImpostor._TmpVecs[0];\r\n        const boneDir = PhysicsImpostor._TmpVecs[1];\r\n\r\n        if (!boneAxis) {\r\n            boneAxis = PhysicsImpostor._TmpVecs[2];\r\n            boneAxis.x = 0;\r\n            boneAxis.y = 1;\r\n            boneAxis.z = 0;\r\n        }\r\n\r\n        bone.getDirectionToRef(boneAxis, boneMesh, boneDir);\r\n        bone.getAbsolutePositionToRef(boneMesh, pos);\r\n\r\n        if ((distToJoint === undefined || distToJoint === null) && jointPivot) {\r\n            distToJoint = jointPivot.length();\r\n        }\r\n\r\n        if (distToJoint !== undefined && distToJoint !== null) {\r\n            pos.x += boneDir.x * distToJoint;\r\n            pos.y += boneDir.y * distToJoint;\r\n            pos.z += boneDir.z * distToJoint;\r\n        }\r\n\r\n        mesh.setAbsolutePosition(pos);\r\n    }\r\n\r\n    //Impostor types\r\n    /**\r\n     * No-Imposter type\r\n     */\r\n    public static NoImpostor = 0;\r\n    /**\r\n     * Sphere-Imposter type\r\n     */\r\n    public static SphereImpostor = 1;\r\n    /**\r\n     * Box-Imposter type\r\n     */\r\n    public static BoxImpostor = 2;\r\n    /**\r\n     * Plane-Imposter type\r\n     */\r\n    public static PlaneImpostor = 3;\r\n    /**\r\n     * Mesh-imposter type (Only available to objects with vertices data)\r\n     */\r\n    public static MeshImpostor = 4;\r\n    /**\r\n     * Capsule-Impostor type (Ammo.js plugin only)\r\n     */\r\n    public static CapsuleImpostor = 6;\r\n    /**\r\n     * Cylinder-Imposter type\r\n     */\r\n    public static CylinderImpostor = 7;\r\n    /**\r\n     * Particle-Imposter type\r\n     */\r\n    public static ParticleImpostor = 8;\r\n    /**\r\n     * Heightmap-Imposter type\r\n     */\r\n    public static HeightmapImpostor = 9;\r\n    /**\r\n     * ConvexHull-Impostor type (Ammo.js plugin only)\r\n     */\r\n    public static ConvexHullImpostor = 10;\r\n    /**\r\n     * Custom-Imposter type (Ammo.js plugin only)\r\n     */\r\n    public static CustomImpostor = 100;\r\n    /**\r\n     * Rope-Imposter type\r\n     */\r\n    public static RopeImpostor = 101;\r\n    /**\r\n     * Cloth-Imposter type\r\n     */\r\n    public static ClothImpostor = 102;\r\n    /**\r\n     * Softbody-Imposter type\r\n     */\r\n    public static SoftbodyImpostor = 103;\r\n}\r\n", "/**\r\n * Defines the kind of connection point for node based material\r\n */\r\nexport enum NodeMaterialBlockConnectionPointTypes {\r\n    /** Float */\r\n    Float = 1,\r\n    /** Int */\r\n    Int = 2,\r\n    /** Vector2 */\r\n    Vector2 = 4,\r\n    /** Vector3 */\r\n    Vector3 = 8,\r\n    /** Vector4 */\r\n    Vector4 = 16,\r\n    /** Color3 */\r\n    Color3 = 32,\r\n    /** Color4 */\r\n    Color4 = 64,\r\n    /** Matrix */\r\n    Matrix = 128,\r\n    /** Custom object */\r\n    Object = 256,\r\n    /** Detect type based on connection */\r\n    AutoDetect = 1024,\r\n    /** Output type that will be defined by input type */\r\n    BasedOnInput = 2048,\r\n}\r\n", "/**\r\n * Enum used to define the target of a block\r\n */\r\nexport enum NodeMaterialBlockTargets {\r\n    /** Vertex shader */\r\n    Vertex = 1,\r\n    /** Fragment shader */\r\n    Fragment = 2,\r\n    /** Neutral */\r\n    Neutral = 4,\r\n    /** Vertex and Fragment */\r\n    VertexAndFragment = Vertex | Fragment,\r\n}\r\n", "import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\n\r\n/**\r\n * Enum used to define the compatibility state between two connection points\r\n */\r\nexport enum NodeMaterialConnectionPointCompatibilityStates {\r\n    /** Points are compatibles */\r\n    Compatible,\r\n    /** Points are incompatible because of their types */\r\n    TypeIncompatible,\r\n    /** Points are incompatible because of their targets (vertex vs fragment) */\r\n    TargetIncompatible,\r\n    /** Points are incompatible because they are in the same hierarchy **/\r\n    HierarchyIssue,\r\n}\r\n\r\n/**\r\n * Defines the direction of a connection point\r\n */\r\nexport enum NodeMaterialConnectionPointDirection {\r\n    /** Input */\r\n    Input,\r\n    /** Output */\r\n    Output,\r\n}\r\n\r\n/**\r\n * Defines a connection point for a block\r\n */\r\nexport class NodeMaterialConnectionPoint {\r\n    /**\r\n     * Checks if two types are equivalent\r\n     * @param type1 type 1 to check\r\n     * @param type2 type 2 to check\r\n     * @returns true if both types are equivalent, else false\r\n     */\r\n    public static AreEquivalentTypes(type1: number, type2: number): boolean {\r\n        switch (type1) {\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _ownerBlock: NodeMaterialBlock;\r\n    /** @internal */\r\n    public _connectedPoint: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _endpoints = new Array<NodeMaterialConnectionPoint>();\r\n    private _associatedVariableName: string;\r\n    private _direction: NodeMaterialConnectionPointDirection;\r\n\r\n    /** @internal */\r\n    public _typeConnectionSource: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    /** @internal */\r\n    public _defaultConnectionPointType: Nullable<NodeMaterialBlockConnectionPointTypes> = null;\r\n\r\n    /** @internal */\r\n    public _linkedConnectionSource: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    /** @internal */\r\n    public _acceptedConnectionPointType: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _type = NodeMaterialBlockConnectionPointTypes.Float;\r\n\r\n    /** @internal */\r\n    public _enforceAssociatedVariableName = false;\r\n\r\n    /** Gets the direction of the point */\r\n    public get direction() {\r\n        return this._direction;\r\n    }\r\n\r\n    /** Indicates that this connection point needs dual validation before being connected to another point */\r\n    public needDualDirectionValidation: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the additional types supported by this connection point\r\n     */\r\n    public acceptedConnectionPointTypes = new Array<NodeMaterialBlockConnectionPointTypes>();\r\n\r\n    /**\r\n     * Gets or sets the additional types excluded by this connection point\r\n     */\r\n    public excludedConnectionPointTypes = new Array<NodeMaterialBlockConnectionPointTypes>();\r\n\r\n    /**\r\n     * Observable triggered when this point is connected\r\n     */\r\n    public onConnectionObservable = new Observable<NodeMaterialConnectionPoint>();\r\n\r\n    /**\r\n     * Gets or sets the associated variable name in the shader\r\n     */\r\n    public get associatedVariableName(): string {\r\n        if (this._ownerBlock.isInput) {\r\n            return (this._ownerBlock as InputBlock).associatedVariableName;\r\n        }\r\n\r\n        if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {\r\n            return this._connectedPoint.associatedVariableName;\r\n        }\r\n\r\n        return this._associatedVariableName;\r\n    }\r\n\r\n    public set associatedVariableName(value: string) {\r\n        this._associatedVariableName = value;\r\n    }\r\n\r\n    /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\r\n    public get innerType() {\r\n        if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n            return this.type;\r\n        }\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeMaterialBlockConnectionPointTypes {\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            if (this._ownerBlock.isInput) {\r\n                return (this._ownerBlock as InputBlock).type;\r\n            }\r\n\r\n            if (this._connectedPoint) {\r\n                return this._connectedPoint.type;\r\n            }\r\n\r\n            if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n                return this._linkedConnectionSource.type;\r\n            }\r\n        }\r\n\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput) {\r\n            if (this._typeConnectionSource) {\r\n                if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {\r\n                    return this._defaultConnectionPointType;\r\n                }\r\n                return this._typeConnectionSource.type;\r\n            } else if (this._defaultConnectionPointType) {\r\n                return this._defaultConnectionPointType;\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    public set type(value: NodeMaterialBlockConnectionPointTypes) {\r\n        this._type = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public displayName: string;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point can be omitted\r\n     */\r\n    public isOptional: boolean;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\r\n     */\r\n    public isExposedOnFrame: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets number indicating the position that the port is exposed to on a frame\r\n     */\r\n    public exposedPortPosition: number = -1;\r\n\r\n    /**\r\n     * Gets or sets a string indicating that this uniform must be defined under a #ifdef\r\n     */\r\n    public define: string;\r\n\r\n    /** @internal */\r\n    public _prioritizeVertex = false;\r\n\r\n    private _target: NodeMaterialBlockTargets = NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n    /** Gets or sets the target of that connection point */\r\n    public get target(): NodeMaterialBlockTargets {\r\n        if (!this._prioritizeVertex || !this._ownerBlock) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            return NodeMaterialBlockTargets.Fragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Vertex;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this.connectedPoint !== null || this.hasEndpoints;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to an input block\r\n     */\r\n    public get isConnectedToInputBlock(): boolean {\r\n        return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a the connected input block (if any)\r\n     */\r\n    public get connectInputBlock(): Nullable<InputBlock> {\r\n        if (!this.isConnectedToInputBlock) {\r\n            return null;\r\n        }\r\n\r\n        return this.connectedPoint!.ownerBlock as InputBlock;\r\n    }\r\n\r\n    /** Get the other side of the connection (if any) */\r\n    public get connectedPoint(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._connectedPoint;\r\n    }\r\n\r\n    /** Get the block that owns this connection point */\r\n    public get ownerBlock(): NodeMaterialBlock {\r\n        return this._ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the other side of this connection (if any) */\r\n    public get sourceBlock(): Nullable<NodeMaterialBlock> {\r\n        if (!this._connectedPoint) {\r\n            return null;\r\n        }\r\n\r\n        return this._connectedPoint.ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the endpoints of this connection (if any) */\r\n    public get connectedBlocks(): Array<NodeMaterialBlock> {\r\n        if (this._endpoints.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        return this._endpoints.map((e) => e.ownerBlock);\r\n    }\r\n\r\n    /** Gets the list of connected endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /** Gets a boolean indicating if that output point is connected to at least one input */\r\n    public get hasEndpoints(): boolean {\r\n        return this._endpoints && this._endpoints.length > 0;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection has a path to the vertex output*/\r\n    public get isDirectlyConnectedToVertexOutput(): boolean {\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the vertex shader */\r\n    public get isConnectedInVertexShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Vertex) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInVertexShader)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the fragment shader */\r\n    public get isConnectedInFragmentShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Fragment) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInFragmentShader)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Creates a block suitable to be used as an input for this input point.\r\n     * If null is returned, a block based on the point type will be created.\r\n     * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input\r\n     */\r\n    public createCustomInputBlock(): Nullable<[NodeMaterialBlock, string]> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new connection point\r\n     * @param name defines the connection point name\r\n     * @param ownerBlock defines the block hosting this connection point\r\n     * @param direction defines the direction of the connection point\r\n     */\r\n    public constructor(name: string, ownerBlock: NodeMaterialBlock, direction: NodeMaterialConnectionPointDirection) {\r\n        this._ownerBlock = ownerBlock;\r\n        this.name = name;\r\n        this._direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialConnectionPoint\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeMaterialConnectionPoint\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a boolean\r\n     */\r\n    public canConnectTo(connectionPoint: NodeMaterialConnectionPoint) {\r\n        return this.checkCompatibilityState(connectionPoint) === NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Gets a number indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a number defining the compatibility state\r\n     */\r\n    public checkCompatibilityState(connectionPoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPointCompatibilityStates {\r\n        const ownerBlock = this._ownerBlock;\r\n        const otherBlock = connectionPoint.ownerBlock;\r\n\r\n        if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            // Let's check we are not going reverse\r\n\r\n            if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n            }\r\n\r\n            for (const output of otherBlock.outputs) {\r\n                if (output.ownerBlock.target != NodeMaterialBlockTargets.Neutral && output.isConnectedInVertexShader) {\r\n                    return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            // Equivalents\r\n            if (NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            }\r\n\r\n            // Accepted types\r\n            if (\r\n                (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) ||\r\n                (connectionPoint._acceptedConnectionPointType && NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type))\r\n            ) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            } else {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n            }\r\n        }\r\n\r\n        // Excluded\r\n        if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {\r\n            return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n        }\r\n\r\n        // Check hierarchy\r\n        let targetBlock = otherBlock;\r\n        let sourceBlock = ownerBlock;\r\n        if (this.direction === NodeMaterialConnectionPointDirection.Input) {\r\n            targetBlock = ownerBlock;\r\n            sourceBlock = otherBlock;\r\n        }\r\n\r\n        if (targetBlock.isAnAncestorOf(sourceBlock)) {\r\n            return NodeMaterialConnectionPointCompatibilityStates.HierarchyIssue;\r\n        }\r\n\r\n        return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Connect this point to another connection point\r\n     * @param connectionPoint defines the other connection point\r\n     * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\r\n     * @returns the current connection point\r\n     */\r\n    public connectTo(connectionPoint: NodeMaterialConnectionPoint, ignoreConstraints = false): NodeMaterialConnectionPoint {\r\n        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\r\n            throw \"Cannot connect these two connectors.\";\r\n        }\r\n\r\n        this._endpoints.push(connectionPoint);\r\n        connectionPoint._connectedPoint = this;\r\n\r\n        this._enforceAssociatedVariableName = false;\r\n\r\n        this.onConnectionObservable.notifyObservers(connectionPoint);\r\n        connectionPoint.onConnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disconnect this point from one of his endpoint\r\n     * @param endpoint defines the other connection point\r\n     * @returns the current connection point\r\n     */\r\n    public disconnectFrom(endpoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPoint {\r\n        const index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index === -1) {\r\n            return this;\r\n        }\r\n\r\n        this._endpoints.splice(index, 1);\r\n        endpoint._connectedPoint = null;\r\n        this._enforceAssociatedVariableName = false;\r\n        endpoint._enforceAssociatedVariableName = false;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serializes this point in a JSON representation\r\n     * @param isInput defines if the connection point is an input (default is true)\r\n     * @returns the serialized point object\r\n     */\r\n    public serialize(isInput = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.displayName = this.displayName;\r\n\r\n        if (isInput && this.connectedPoint) {\r\n            serializationObject.inputName = this.name;\r\n            serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\r\n            serializationObject.targetConnectionName = this.connectedPoint.name;\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        this.onConnectionObservable.clear();\r\n    }\r\n}\r\n", "import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"./nodeMaterialBuildState\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { Effect } from \"../effect\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"./nodeMaterial\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { GetClass } from \"../../Misc/typeStore\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\n\r\n/**\r\n * Defines a block that can be used inside a node based material\r\n */\r\nexport class NodeMaterialBlock {\r\n    private _buildId: number;\r\n    private _buildTarget: NodeMaterialBlockTargets;\r\n    protected _target: NodeMaterialBlockTargets;\r\n    private _isFinalMerger = false;\r\n    private _isInput = false;\r\n    private _name = \"\";\r\n    protected _isUnique = false;\r\n\r\n    /** Gets or sets a boolean indicating that only one input can be connected at a time */\r\n    public inputsAreExclusive = false;\r\n\r\n    /** @internal */\r\n    public _codeVariableName = \"\";\r\n\r\n    /** @internal */\r\n    public _inputs = new Array<NodeMaterialConnectionPoint>();\r\n    /** @internal */\r\n    public _outputs = new Array<NodeMaterialConnectionPoint>();\r\n\r\n    /** @internal */\r\n    public _preparationId: number;\r\n\r\n    /** @internal */\r\n    public readonly _originalTargetIsNeutral: boolean;\r\n\r\n    /**\r\n     * Gets the name of the block\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Sets the name of the block. Will check if the name is valid.\r\n     */\r\n    public set name(newName: string) {\r\n        if (!this.validateBlockName(newName)) {\r\n            return;\r\n        }\r\n\r\n        this._name = newName;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets or sets the comments associated with this block\r\n     */\r\n    public comments: string = \"\";\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block can only be used once per NodeMaterial\r\n     */\r\n    public get isUnique() {\r\n        return this._isUnique;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)\r\n     */\r\n    public get isFinalMerger(): boolean {\r\n        return this._isFinalMerger;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)\r\n     */\r\n    public get isInput(): boolean {\r\n        return this._isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the build Id\r\n     */\r\n    public get buildId(): number {\r\n        return this._buildId;\r\n    }\r\n\r\n    public set buildId(value: number) {\r\n        this._buildId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target of the block\r\n     */\r\n    public get target() {\r\n        return this._target;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        if ((this._target & value) !== 0) {\r\n            return;\r\n        }\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input points\r\n     */\r\n    public get inputs(): NodeMaterialConnectionPoint[] {\r\n        return this._inputs;\r\n    }\r\n\r\n    /** Gets the list of output points */\r\n    public get outputs(): NodeMaterialConnectionPoint[] {\r\n        return this._outputs;\r\n    }\r\n\r\n    /**\r\n     * Find an input by its name\r\n     * @param name defines the name of the input to look for\r\n     * @returns the input or null if not found\r\n     */\r\n    public getInputByName(name: string) {\r\n        const filter = this._inputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find an output by its name\r\n     * @param name defines the name of the output to look for\r\n     * @returns the output or null if not found\r\n     */\r\n    public getOutputByName(name: string) {\r\n        const filter = this._outputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */\r\n    public visibleInInspector = false;\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\r\n    public visibleOnFrame = false;\r\n\r\n    /**\r\n     * Creates a new NodeMaterialBlock\r\n     * @param name defines the block name\r\n     * @param target defines the target of that block (Vertex by default)\r\n     * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false\r\n     * @param isInput defines a boolean indicating that this block is an input (e.g. it sends data to the shader). Default is false\r\n     */\r\n    public constructor(name: string, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false, isInput = false) {\r\n        this._target = target;\r\n        this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;\r\n        this._isFinalMerger = isFinalMerger;\r\n        this._isInput = isInput;\r\n        this._name = name;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Bind data to effect. Will only be called for blocks with isBindable === true\r\n     * @param effect defines the effect to bind data to\r\n     * @param nodeMaterial defines the hosting NodeMaterial\r\n     * @param mesh defines the mesh that will be rendered\r\n     * @param subMesh defines the submesh that will be rendered\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    protected _declareOutput(output: NodeMaterialConnectionPoint, state: NodeMaterialBuildState): string {\r\n        return `${state._getGLType(output.type)} ${output.associatedVariableName}`;\r\n    }\r\n\r\n    protected _writeVariable(currentPoint: NodeMaterialConnectionPoint): string {\r\n        const connectionPoint = currentPoint.connectedPoint;\r\n\r\n        if (connectionPoint) {\r\n            return `${currentPoint.associatedVariableName}`;\r\n        }\r\n\r\n        return `0.`;\r\n    }\r\n\r\n    protected _writeFloat(value: number) {\r\n        let stringVersion = value.toString();\r\n\r\n        if (stringVersion.indexOf(\".\") === -1) {\r\n            stringVersion += \".0\";\r\n        }\r\n        return `${stringVersion}`;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialBlock\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NodeMaterialBlock\";\r\n    }\r\n\r\n    /**\r\n     * Register a new input. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param isOptional defines a boolean indicating that this input can be omitted\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerInput(\r\n        name: string,\r\n        type: NodeMaterialBlockConnectionPointTypes,\r\n        isOptional: boolean = false,\r\n        target?: NodeMaterialBlockTargets,\r\n        point?: NodeMaterialConnectionPoint\r\n    ) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Input);\r\n        point.type = type;\r\n        point.isOptional = isOptional;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._inputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register a new output. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerOutput(name: string, type: NodeMaterialBlockConnectionPointTypes, target?: NodeMaterialBlockTargets, point?: NodeMaterialConnectionPoint) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Output);\r\n        point.type = type;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._outputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available input e.g. the first one which is not an uniform or an attribute\r\n     * @param forOutput defines an optional connection point to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableInput(forOutput: Nullable<NodeMaterialConnectionPoint> = null) {\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n                    return input;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available output e.g. the first one which is not yet connected and not a varying\r\n     * @param forBlock defines an optional block to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableOutput(forBlock: Nullable<NodeMaterialBlock> = null) {\r\n        for (const output of this._outputs) {\r\n            if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {\r\n                return output;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the sibling of the given output\r\n     * @param current defines the current output\r\n     * @returns the next output in the list or null\r\n     */\r\n    public getSiblingOutput(current: NodeMaterialConnectionPoint) {\r\n        const index = this._outputs.indexOf(current);\r\n\r\n        if (index === -1 || index >= this._outputs.length) {\r\n            return null;\r\n        }\r\n\r\n        return this._outputs[index + 1];\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given block\r\n     * @param block defines the potential descendant block to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOf(block: NodeMaterialBlock): boolean {\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                if (endpoint.ownerBlock === block) {\r\n                    return true;\r\n                }\r\n                if (endpoint.ownerBlock.isAnAncestorOf(block)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Connect current block with another block\r\n     * @param other defines the block to connect with\r\n     * @param options define the various options to help pick the right connections\r\n     * @param options.input\r\n     * @param options.output\r\n     * @param options.outputSwizzle\r\n     * @returns the current block\r\n     */\r\n    public connectTo(\r\n        other: NodeMaterialBlock,\r\n        options?: {\r\n            input?: string;\r\n            output?: string;\r\n            outputSwizzle?: string;\r\n        }\r\n    ) {\r\n        if (this._outputs.length === 0) {\r\n            return;\r\n        }\r\n\r\n        let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);\r\n\r\n        let notFound = true;\r\n        while (notFound) {\r\n            const input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);\r\n\r\n            if (output && input && output.canConnectTo(input)) {\r\n                output.connectTo(input);\r\n                notFound = false;\r\n            } else if (!output) {\r\n                throw \"Unable to find a compatible match\";\r\n            } else {\r\n                output = this.getSiblingOutput(output);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        // Empty. Must be defined by child nodes\r\n    }\r\n\r\n    /**\r\n     * Add uniforms, samplers and uniform buffers at compilation time\r\n     * @param state defines the state to update\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param uniformBuffers defines the list of uniform buffer names\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Add potential fallbacks if shader compilation fails\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param fallbacks defines the current prioritized list of fallbacks\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public provideFallbacks(mesh: AbstractMesh, fallbacks: EffectFallbacks) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Initialize defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public initializeDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {}\r\n\r\n    /**\r\n     * Update defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     * @param subMesh defines which submesh to render\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Lets the block try to connect some inputs automatically\r\n     * @param material defines the hosting NodeMaterial\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public autoConfigure(material: NodeMaterial) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Function called when a block is declared as repeatable content generator\r\n     * @param vertexShaderState defines the current compilation state for the vertex shader\r\n     * @param fragmentShaderState defines the current compilation state for the fragment shader\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param defines defines the material defines to update\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, fragmentShaderState: NodeMaterialBuildState, mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        // Do nothing\r\n    }\r\n\r\n    /** Gets a boolean indicating that the code of this block will be promoted to vertex shader even if connected to fragment output */\r\n    public get willBeGeneratedIntoVertexShaderFromFragmentShader(): boolean {\r\n        if (this.isInput || this.isFinalMerger) {\r\n            return false;\r\n        }\r\n\r\n        if (this._outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.target === NodeMaterialBlockTargets.Vertex) {\r\n            return false;\r\n        }\r\n\r\n        if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {\r\n            if (this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the block is ready\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns true if the block is ready\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReady(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {\r\n        return true;\r\n    }\r\n\r\n    protected _linkConnectionTypes(inputIndex0: number, inputIndex1: number, looseCoupling = false) {\r\n        if (looseCoupling) {\r\n            this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\r\n        } else {\r\n            this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\r\n        }\r\n        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\r\n    }\r\n\r\n    private _processBuild(block: NodeMaterialBlock, state: NodeMaterialBuildState, input: NodeMaterialConnectionPoint, activeBlocks: NodeMaterialBlock[]) {\r\n        block.build(state, activeBlocks);\r\n\r\n        const localBlockIsFragment = state._vertexState != null;\r\n        const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n        if (\r\n            localBlockIsFragment &&\r\n            ((block.target & block._buildTarget) === 0 ||\r\n                (block.target & input.target) === 0 ||\r\n                (this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader))\r\n        ) {\r\n            // context switch! We need a varying\r\n            if (\r\n                (!block.isInput && state.target !== block._buildTarget) || // block was already emitted by vertex shader\r\n                (block.isInput && (block as InputBlock).isAttribute && !(block as InputBlock)._noContextSwitch) // block is an attribute\r\n            ) {\r\n                const connectedPoint = input.connectedPoint!;\r\n                if (state._vertexState._emitVaryingFromString(\"v_\" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {\r\n                    state._vertexState.compilationString += `${\"v_\" + connectedPoint.associatedVariableName} = ${connectedPoint.associatedVariableName};\\r\\n`;\r\n                }\r\n                input.associatedVariableName = \"v_\" + connectedPoint.associatedVariableName;\r\n                input._enforceAssociatedVariableName = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates the new name for the block node.\r\n     * @param newName the new name to be given to the node.\r\n     * @returns false if the name is a reserve word, else true.\r\n     */\r\n    public validateBlockName(newName: string) {\r\n        const reservedNames: Array<string> = [\r\n            \"position\",\r\n            \"normal\",\r\n            \"tangent\",\r\n            \"particle_positionw\",\r\n            \"uv\",\r\n            \"uv2\",\r\n            \"uv3\",\r\n            \"uv4\",\r\n            \"uv5\",\r\n            \"uv6\",\r\n            \"position2d\",\r\n            \"particle_uv\",\r\n            \"matricesIndices\",\r\n            \"matricesWeights\",\r\n            \"world0\",\r\n            \"world1\",\r\n            \"world2\",\r\n            \"world3\",\r\n            \"particle_color\",\r\n            \"particle_texturemask\",\r\n        ];\r\n        for (const reservedName of reservedNames) {\r\n            if (newName === reservedName) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Compile the current node and generate the shader code\r\n     * @param state defines the current compilation state (uniforms, samplers, current string)\r\n     * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)\r\n     * @returns true if already built\r\n     */\r\n    public build(state: NodeMaterialBuildState, activeBlocks: NodeMaterialBlock[]): boolean {\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.isInput) {\r\n            /** Prepare outputs */\r\n            for (const output of this._outputs) {\r\n                if (!output.associatedVariableName) {\r\n                    output.associatedVariableName = state._getFreeVariableName(output.name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check if \"parent\" blocks are compiled\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!input.isOptional) {\r\n                    // Emit a warning\r\n                    state.sharedData.checks.notConnectedNonOptionalInputs.push(input);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if (this.target !== NodeMaterialBlockTargets.Neutral) {\r\n                if ((input.target & this.target!) === 0) {\r\n                    continue;\r\n                }\r\n\r\n                if ((input.target & state.target!) === 0) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            const block = input.connectedPoint.ownerBlock;\r\n            if (block && block !== this) {\r\n                this._processBuild(block, state, input, activeBlocks);\r\n            }\r\n        }\r\n\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true; // Need to check again as inputs can be connected multiple time to this endpoint\r\n        }\r\n\r\n        // Logs\r\n        if (state.sharedData.verbose) {\r\n            console.log(`${state.target === NodeMaterialBlockTargets.Vertex ? \"Vertex shader\" : \"Fragment shader\"}: Building ${this.name} [${this.getClassName()}]`);\r\n        }\r\n\r\n        // Checks final outputs\r\n        if (this.isFinalMerger) {\r\n            switch (state.target) {\r\n                case NodeMaterialBlockTargets.Vertex:\r\n                    state.sharedData.checks.emitVertex = true;\r\n                    break;\r\n                case NodeMaterialBlockTargets.Fragment:\r\n                    state.sharedData.checks.emitFragment = true;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (!this.isInput && state.sharedData.emitComments) {\r\n            state.compilationString += `\\r\\n//${this.name}\\r\\n`;\r\n        }\r\n\r\n        this._buildBlock(state);\r\n\r\n        this._buildId = state.sharedData.buildId;\r\n        this._buildTarget = state.target;\r\n\r\n        // Compile connected blocks\r\n        for (const output of this._outputs) {\r\n            if ((output.target & state.target) === 0) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const block = endpoint.ownerBlock;\r\n\r\n                if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {\r\n                    this._processBuild(block, state, endpoint, activeBlocks);\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n        return `${variableName}.visibleInInspector = ${this.visibleInInspector};\\r\\n${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\r\\n${variableName}.target = ${this.target};\\r\\n`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeMaterialBlock[]) {\r\n        alreadyDumped.push(this);\r\n\r\n        let codeString: string;\r\n\r\n        // Get unique name\r\n        const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\r\n        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\r\n\r\n        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\r\n            let index = 0;\r\n            do {\r\n                index++;\r\n                this._codeVariableName = nameAsVariableName + index;\r\n            } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\r\n        }\r\n\r\n        uniqueNames.push(this._codeVariableName);\r\n\r\n        // Declaration\r\n        codeString = `\\r\\n// ${this.getClassName()}\\r\\n`;\r\n        if (this.comments) {\r\n            codeString += `// ${this.comments}\\r\\n`;\r\n        }\r\n        codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\r\\n`;\r\n\r\n        // Properties\r\n        codeString += this._dumpPropertiesCode();\r\n\r\n        // Inputs\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            if (alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Outputs\r\n        for (const output of this.outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const connectedBlock = endpoint.ownerBlock;\r\n                if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                    codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n                }\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCodeForOutputConnections(alreadyDumped: NodeMaterialBlock[]) {\r\n        let codeString = \"\";\r\n\r\n        if (alreadyDumped.indexOf(this) !== -1) {\r\n            return codeString;\r\n        }\r\n\r\n        alreadyDumped.push(this);\r\n\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\r\n            codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(\r\n                input.name\r\n            )});\\r\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Clone the current block to a new identical block\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a copy of the current block\r\n     */\r\n    public clone(scene: Scene, rootUrl: string = \"\") {\r\n        const serializationObject = this.serialize();\r\n\r\n        const blockType = GetClass(serializationObject.customType);\r\n        if (blockType) {\r\n            const block: NodeMaterialBlock = new blockType();\r\n            block._deserialize(serializationObject, scene, rootUrl);\r\n\r\n            return block;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.id = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n        serializationObject.comments = this.comments;\r\n        serializationObject.visibleInInspector = this.visibleInInspector;\r\n        serializationObject.visibleOnFrame = this.visibleOnFrame;\r\n        serializationObject.target = this.target;\r\n\r\n        serializationObject.inputs = [];\r\n        serializationObject.outputs = [];\r\n\r\n        for (const input of this.inputs) {\r\n            serializationObject.inputs.push(input.serialize());\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            serializationObject.outputs.push(output.serialize(false));\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        this.name = serializationObject.name;\r\n        this.comments = serializationObject.comments;\r\n        this.visibleInInspector = !!serializationObject.visibleInInspector;\r\n        this.visibleOnFrame = !!serializationObject.visibleOnFrame;\r\n        this._target = serializationObject.target ?? this.target;\r\n        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\r\n    }\r\n\r\n    private _deserializePortDisplayNamesAndExposedOnFrame(serializationObject: any) {\r\n        const serializedInputs = serializationObject.inputs;\r\n        const serializedOutputs = serializationObject.outputs;\r\n        if (serializedInputs) {\r\n            serializedInputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.inputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.inputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n        if (serializedOutputs) {\r\n            serializedOutputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.outputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.outputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        for (const input of this.inputs) {\r\n            input.dispose();\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            output.dispose();\r\n        }\r\n    }\r\n}\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { InputBlock } from \"./Input/inputBlock\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../nodeMaterial\";\r\n\r\n/**\r\n * Block used to transform a vector (2, 3 or 4) with a matrix. It will generate a Vector4\r\n */\r\nexport class TransformBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Defines the value to use to complement W value to transform it to a Vector4\r\n     */\r\n    public complementW = 1;\r\n\r\n    /**\r\n     * Defines the value to use to complement z value to transform it to a Vector4\r\n     */\r\n    public complementZ = 0;\r\n\r\n    /**\r\n     * Creates a new TransformBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.target = NodeMaterialBlockTargets.Vertex;\r\n\r\n        this.registerInput(\"vector\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"transform\", NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        this._inputs[0].onConnectionObservable.add((other) => {\r\n            if (other.ownerBlock.isInput) {\r\n                const otherAsInput = other.ownerBlock as InputBlock;\r\n\r\n                if (otherAsInput.name === \"normal\" || otherAsInput.name === \"tangent\") {\r\n                    this.complementW = 0;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TransformBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vector input\r\n     */\r\n    public get vector(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz output component\r\n     */\r\n    public get xyz(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix transform input\r\n     */\r\n    public get transform(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const vector = this.vector;\r\n        const transform = this.transform;\r\n\r\n        if (vector.connectedPoint) {\r\n            // None uniform scaling case.\r\n            if (this.complementW === 0) {\r\n                const comments = `//${this.name}`;\r\n                state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n                state.sharedData.blocksWithDefines.push(this);\r\n\r\n                const transformName = state._getFreeVariableName(`${transform.associatedVariableName}_NUS`);\r\n                state.compilationString += `mat3 ${transformName} = mat3(${transform.associatedVariableName});\\r\\n`;\r\n                state.compilationString += `#ifdef NONUNIFORMSCALING\\r\\n`;\r\n                state.compilationString += `${transformName} = transposeMat3(inverseMat3(${transformName}));\\r\\n`;\r\n                state.compilationString += `#endif\\r\\n`;\r\n                switch (vector.connectedPoint.type) {\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                        state.compilationString +=\r\n                            this._declareOutput(this.output, state) +\r\n                            ` = vec4(${transformName} * vec3(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}), ${this._writeFloat(this.complementW)});\\r\\n`;\r\n                        break;\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                    case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                        state.compilationString +=\r\n                            this._declareOutput(this.output, state) + ` = vec4(${transformName} * ${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\r\\n`;\r\n                        break;\r\n                    default:\r\n                        state.compilationString +=\r\n                            this._declareOutput(this.output, state) +\r\n                            ` = vec4(${transformName} * ${vector.associatedVariableName}.xyz, ${this._writeFloat(this.complementW)});\\r\\n`;\r\n                        break;\r\n                }\r\n            } else {\r\n                const transformName = transform.associatedVariableName;\r\n                switch (vector.connectedPoint.type) {\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                        state.compilationString +=\r\n                            this._declareOutput(this.output, state) +\r\n                            ` = ${transformName} * vec4(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}, ${this._writeFloat(this.complementW)});\\r\\n`;\r\n                        break;\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                    case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                        state.compilationString +=\r\n                            this._declareOutput(this.output, state) + ` = ${transformName} * vec4(${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\r\\n`;\r\n                        break;\r\n                    default:\r\n                        state.compilationString += this._declareOutput(this.output, state) + ` = ${transformName} * ${vector.associatedVariableName};\\r\\n`;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            if (this.xyz.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(this.xyz, state) + ` = ${this.output.associatedVariableName}.xyz;\\r\\n`;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     */\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        // Do nothing\r\n        if (mesh.nonUniformScaling) {\r\n            defines.setValue(\"NONUNIFORMSCALING\", true);\r\n        }\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.complementZ = this.complementZ;\r\n        serializationObject.complementW = this.complementW;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.complementZ = serializationObject.complementZ !== undefined ? serializationObject.complementZ : 0.0;\r\n        this.complementW = serializationObject.complementW !== undefined ? serializationObject.complementW : 1.0;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.complementZ = ${this.complementZ};\\r\\n`;\r\n\r\n        codeString += `${this._codeVariableName}.complementW = ${this.complementW};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TransformBlock\", TransformBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Immutable } from \"../../../../types\";\r\n\r\ndeclare type FragmentOutputBlock = import(\"../Fragment/fragmentOutputBlock\").FragmentOutputBlock;\r\n\r\n/**\r\n * Block used to output the vertex position\r\n */\r\nexport class VertexOutputBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new VertexOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Vertex, true);\r\n\r\n        this.registerInput(\"vector\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"VertexOutputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vector input component\r\n     */\r\n    public get vector(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    private _isLogarithmicDepthEnabled(nodeList: Immutable<NodeMaterialBlock[]>): boolean {\r\n        for (const node of nodeList) {\r\n            if ((node as FragmentOutputBlock).useLogarithmicDepth) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const input = this.vector;\r\n\r\n        state.compilationString += `gl_Position = ${input.associatedVariableName};\\r\\n`;\r\n\r\n        if (this._isLogarithmicDepthEnabled(state.sharedData.fragmentOutputNodes)) {\r\n            state._emitUniformFromString(\"logarithmicDepthConstant\", \"float\");\r\n            state._emitVaryingFromString(\"vFragmentDepth\", \"float\");\r\n\r\n            state.compilationString += `vFragmentDepth = 1.0 + gl_Position.w;\\r\\n`;\r\n            state.compilationString += `gl_Position.z = log2(max(0.000001, vFragmentDepth)) * logarithmicDepthConstant;\\r\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VertexOutputBlock\", VertexOutputBlock);\r\n", "declare type Scene = import(\"../../scene\").Scene;\r\n\r\n/**\r\n * Enum defining the type of properties that can be edited in the property pages in the NME\r\n */\r\nexport enum PropertyTypeForEdition {\r\n    /** property is a boolean */\r\n    Boolean,\r\n    /** property is a float */\r\n    Float,\r\n    /** property is a int */\r\n    Int,\r\n    /** property is a Vector2 */\r\n    Vector2,\r\n    /** property is a list of values */\r\n    List,\r\n}\r\n\r\n/**\r\n * Interface that defines an option in a variable of type list\r\n */\r\nexport interface IEditablePropertyListOption {\r\n    /** label of the option */\r\n    label: string;\r\n    /** value of the option */\r\n    value: number;\r\n}\r\n\r\n/**\r\n * Interface that defines the options available for an editable property\r\n */\r\nexport interface IEditablePropertyOption {\r\n    /** min value */\r\n    min?: number;\r\n    /** max value */\r\n    max?: number;\r\n    /** notifiers: indicates which actions to take when the property is changed */\r\n    notifiers?: {\r\n        /** the material should be rebuilt */\r\n        rebuild?: boolean;\r\n        /** the preview should be updated */\r\n        update?: boolean;\r\n        /** the onPreviewCommandActivated observer of the preview manager should be triggered */\r\n        activatePreviewCommand?: boolean;\r\n        /** a callback to trigger */\r\n        callback?: (scene: Scene) => void;\r\n    };\r\n    /** list of the options for a variable of type list */\r\n    options?: IEditablePropertyListOption[];\r\n}\r\n\r\n/**\r\n * Interface that describes an editable property\r\n */\r\nexport interface IPropertyDescriptionForEdition {\r\n    /** name of the property */\r\n    propertyName: string;\r\n    /** display name of the property */\r\n    displayName: string;\r\n    /** type of the property */\r\n    type: PropertyTypeForEdition;\r\n    /** group of the property - all properties with the same group value will be displayed in a specific section */\r\n    groupName: string;\r\n    /** options for the property */\r\n    options: IEditablePropertyOption;\r\n}\r\n\r\n/**\r\n * Decorator that flags a property in a node material block as being editable\r\n * @param displayName\r\n * @param propertyType\r\n * @param groupName\r\n * @param options\r\n */\r\nexport function editableInPropertyPage(\r\n    displayName: string,\r\n    propertyType: PropertyTypeForEdition = PropertyTypeForEdition.Boolean,\r\n    groupName: string = \"PROPERTIES\",\r\n    options?: IEditablePropertyOption\r\n) {\r\n    return (target: any, propertyKey: string) => {\r\n        let propStore: IPropertyDescriptionForEdition[] = target._propStore;\r\n        if (!propStore) {\r\n            propStore = [];\r\n            target._propStore = propStore;\r\n        }\r\n        propStore.push({\r\n            propertyName: propertyKey,\r\n            displayName: displayName,\r\n            type: propertyType,\r\n            groupName: groupName,\r\n            options: options ?? {},\r\n        });\r\n    };\r\n}\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator\";\r\nimport { MaterialHelper } from \"../../../materialHelper\";\r\n\r\ndeclare type NodeMaterial = import(\"../../nodeMaterial\").NodeMaterial;\r\ndeclare type Effect = import(\"../../../effect\").Effect;\r\ndeclare type Mesh = import(\"../../../../Meshes/mesh\").Mesh;\r\n\r\n/**\r\n * Block used to output the final color\r\n */\r\nexport class FragmentOutputBlock extends NodeMaterialBlock {\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n\r\n    /**\r\n     * Create a new FragmentOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment, true);\r\n\r\n        this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\r\n        this.registerInput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, true);\r\n        this.registerInput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n\r\n        this.rgb.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space */\r\n    @editableInPropertyPage(\"Convert to gamma space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\r\n    public convertToGammaSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space */\r\n    @editableInPropertyPage(\"Convert to linear space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\r\n    public convertToLinearSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if logarithmic depth should be used */\r\n    @editableInPropertyPage(\"Use logarithmic depth\", PropertyTypeForEdition.Boolean, \"PROPERTIES\")\r\n    public useLogarithmicDepth = false;\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"FragmentOutputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"logarithmicDepthConstant\");\r\n        state._excludeVariableName(\"vFragmentDepth\");\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba input component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb input component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the a input component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (this.useLogarithmicDepth && mesh) {\r\n            MaterialHelper.BindLogDepth(undefined, effect, mesh.getScene());\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const rgba = this.rgba;\r\n        const rgb = this.rgb;\r\n        const a = this.a;\r\n\r\n        state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        if (this.useLogarithmicDepth) {\r\n            state._emitUniformFromString(\"logarithmicDepthConstant\", \"float\");\r\n            state._emitVaryingFromString(\"vFragmentDepth\", \"float\");\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n        this._linearDefineName = state._getFreeDefineName(\"CONVERTTOLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"CONVERTTOGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        if (rgba.connectedPoint) {\r\n            if (a.isConnected) {\r\n                state.compilationString += `gl_FragColor = vec4(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});\\r\\n`;\r\n            } else {\r\n                state.compilationString += `gl_FragColor = ${rgba.associatedVariableName};\\r\\n`;\r\n            }\r\n        } else if (rgb.connectedPoint) {\r\n            let aValue = \"1.0\";\r\n\r\n            if (a.connectedPoint) {\r\n                aValue = a.associatedVariableName;\r\n            }\r\n\r\n            if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});\\r\\n`;\r\n            } else {\r\n                state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${aValue});\\r\\n`;\r\n            }\r\n        } else {\r\n            state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);\r\n        }\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\r\\n`;\r\n        state.compilationString += `gl_FragColor = toLinearSpace(gl_FragColor);\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\r\\n`;\r\n        state.compilationString += `gl_FragColor = toGammaSpace(gl_FragColor);\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        if (this.useLogarithmicDepth) {\r\n            state.compilationString += `gl_FragDepthEXT = log2(vFragmentDepth) * logarithmicDepthConstant * 0.5;\\r\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = serializationObject.convertToLinearSpace;\r\n        this.useLogarithmicDepth = serializationObject.useLogarithmicDepth ?? false;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FragmentOutputBlock\", FragmentOutputBlock);\r\n", "/**\r\n * Enum defining the mode of a NodeMaterialBlockConnectionPoint\r\n */\r\nexport enum NodeMaterialBlockConnectionPointMode {\r\n    /** Value is an uniform */\r\n    Uniform,\r\n    /** Value is a mesh attribute */\r\n    Attribute,\r\n    /** Value is a varying between vertex and fragment shaders */\r\n    Varying,\r\n    /** Mode is undefined */\r\n    Undefined,\r\n}\r\n", "/**\r\n * Enum used to define system values e.g. values automatically provided by the system\r\n */\r\nexport enum NodeMaterialSystemValues {\r\n    /** World */\r\n    World = 1,\r\n    /** View */\r\n    View = 2,\r\n    /** Projection */\r\n    Projection = 3,\r\n    /** ViewProjection */\r\n    ViewProjection = 4,\r\n    /** WorldView */\r\n    WorldView = 5,\r\n    /** WorldViewProjection */\r\n    WorldViewProjection = 6,\r\n    /** CameraPosition */\r\n    CameraPosition = 7,\r\n    /** Fog Color */\r\n    FogColor = 8,\r\n    /** Delta time */\r\n    DeltaTime = 9,\r\n    /** Camera parameters */\r\n    CameraParameters = 10,\r\n    /** Material alpha */\r\n    MaterialAlpha = 11,\r\n}\r\n", "/**\r\n * Enum defining the type of animations supported by InputBlock\r\n */\r\nexport enum AnimatedInputBlockTypes {\r\n    /** No animation */\r\n    None,\r\n    /** Time based animation. Will only work for floats */\r\n    Time,\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockConnectionPointMode } from \"../../Enums/nodeMaterialBlockConnectionPointMode\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { Effect } from \"../../../../Materials/effect\";\r\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../../../Maths/math.vector\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { GetClass, RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Color3, Color4, TmpColors } from \"../../../../Maths/math\";\r\nimport { AnimatedInputBlockTypes } from \"./animatedInputBlockTypes\";\r\nimport { Observable } from \"../../../../Misc/observable\";\r\nimport type { NodeMaterial } from \"../../nodeMaterial\";\r\n\r\nconst remapAttributeName: { [name: string]: string } = {\r\n    position2d: \"position\",\r\n    particle_uv: \"vUV\",\r\n    particle_color: \"vColor\",\r\n    particle_texturemask: \"textureMask\",\r\n    particle_positionw: \"vPositionW\",\r\n};\r\n\r\nconst attributeInFragmentOnly: { [name: string]: boolean } = {\r\n    particle_uv: true,\r\n    particle_color: true,\r\n    particle_texturemask: true,\r\n    particle_positionw: true,\r\n};\r\n\r\nconst attributeAsUniform: { [name: string]: boolean } = {\r\n    particle_texturemask: true,\r\n};\r\n\r\n/**\r\n * Block used to expose an input value\r\n */\r\nexport class InputBlock extends NodeMaterialBlock {\r\n    private _mode = NodeMaterialBlockConnectionPointMode.Undefined;\r\n    private _associatedVariableName: string;\r\n    private _storedValue: any;\r\n    private _valueCallback: () => any;\r\n    private _type: NodeMaterialBlockConnectionPointTypes;\r\n    private _animationType = AnimatedInputBlockTypes.None;\r\n\r\n    /** Gets or set a value used to limit the range of float values */\r\n    public min: number = 0;\r\n\r\n    /** Gets or set a value used to limit the range of float values */\r\n    public max: number = 0;\r\n\r\n    /** Gets or set a value indicating that this input can only get 0 and 1 values */\r\n    public isBoolean: boolean = false;\r\n\r\n    /** Gets or sets a value used by the Node Material editor to determine how to configure the current value if it is a matrix */\r\n    public matrixMode: number = 0;\r\n\r\n    /** @internal */\r\n    public _systemValue: Nullable<NodeMaterialSystemValues> = null;\r\n\r\n    /** Gets or sets a boolean indicating that the value of this input will not change after a build */\r\n    public isConstant = false;\r\n\r\n    /** Gets or sets the group to use to display this block in the Inspector */\r\n    public groupInInspector = \"\";\r\n\r\n    /** Gets an observable raised when the value is changed */\r\n    public onValueChangedObservable = new Observable<InputBlock>();\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space (for color3/4 only) */\r\n    public convertToGammaSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space (for color3/4 only) */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeMaterialBlockConnectionPointTypes {\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            if (this.isUniform && this.value != null) {\r\n                if (!isNaN(this.value)) {\r\n                    this._type = NodeMaterialBlockConnectionPointTypes.Float;\r\n                    return this._type;\r\n                }\r\n\r\n                switch (this.value.getClassName()) {\r\n                    case \"Vector2\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector2;\r\n                        return this._type;\r\n                    case \"Vector3\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\r\n                        return this._type;\r\n                    case \"Vector4\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n                        return this._type;\r\n                    case \"Color3\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color3;\r\n                        return this._type;\r\n                    case \"Color4\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color4;\r\n                        return this._type;\r\n                    case \"Matrix\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Matrix;\r\n                        return this._type;\r\n                }\r\n            }\r\n\r\n            if (this.isAttribute) {\r\n                switch (this.name) {\r\n                    case \"position\":\r\n                    case \"normal\":\r\n                    case \"particle_positionw\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\r\n                        return this._type;\r\n                    case \"uv\":\r\n                    case \"uv2\":\r\n                    case \"uv3\":\r\n                    case \"uv4\":\r\n                    case \"uv5\":\r\n                    case \"uv6\":\r\n                    case \"position2d\":\r\n                    case \"particle_uv\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector2;\r\n                        return this._type;\r\n                    case \"matricesIndices\":\r\n                    case \"matricesWeights\":\r\n                    case \"world0\":\r\n                    case \"world1\":\r\n                    case \"world2\":\r\n                    case \"world3\":\r\n                    case \"tangent\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n                        return this._type;\r\n                    case \"color\":\r\n                    case \"instanceColor\":\r\n                    case \"particle_color\":\r\n                    case \"particle_texturemask\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color4;\r\n                        return this._type;\r\n                }\r\n            }\r\n\r\n            if (this.isSystemValue) {\r\n                switch (this._systemValue) {\r\n                    case NodeMaterialSystemValues.World:\r\n                    case NodeMaterialSystemValues.WorldView:\r\n                    case NodeMaterialSystemValues.WorldViewProjection:\r\n                    case NodeMaterialSystemValues.View:\r\n                    case NodeMaterialSystemValues.ViewProjection:\r\n                    case NodeMaterialSystemValues.Projection:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Matrix;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.CameraPosition:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.FogColor:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color3;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.DeltaTime:\r\n                    case NodeMaterialSystemValues.MaterialAlpha:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Float;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.CameraParameters:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n                        return this._type;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InputBlock\r\n     * @param name defines the block name\r\n     * @param target defines the target of that block (Vertex by default)\r\n     * @param type defines the type of the input (can be set to NodeMaterialBlockConnectionPointTypes.AutoDetect)\r\n     */\r\n    public constructor(name: string, target = NodeMaterialBlockTargets.Vertex, type: NodeMaterialBlockConnectionPointTypes = NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n        super(name, target, false, true);\r\n\r\n        this._type = type;\r\n\r\n        this.setDefaultValue();\r\n\r\n        this.registerOutput(\"output\", type);\r\n    }\r\n\r\n    /**\r\n     * Validates if a name is a reserve word.\r\n     * @param newName the new name to be given to the node.\r\n     * @returns false if the name is a reserve word, else true.\r\n     */\r\n    public validateBlockName(newName: string) {\r\n        if (!this.isAttribute) {\r\n            return super.validateBlockName(newName);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Set the source of this connection point to a vertex attribute\r\n     * @param attributeName defines the attribute name (position, uv, normal, etc...). If not specified it will take the connection point name\r\n     * @returns the current connection point\r\n     */\r\n    public setAsAttribute(attributeName?: string): InputBlock {\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Attribute;\r\n        if (attributeName) {\r\n            this.name = attributeName;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the source of this connection point to a system value\r\n     * @param value define the system value to use (world, view, etc...) or null to switch to manual value\r\n     * @returns the current connection point\r\n     */\r\n    public setAsSystemValue(value: Nullable<NodeMaterialSystemValues>): InputBlock {\r\n        this.systemValue = value;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the value of that point.\r\n     * Please note that this value will be ignored if valueCallback is defined\r\n     */\r\n    public get value(): any {\r\n        return this._storedValue;\r\n    }\r\n\r\n    public set value(value: any) {\r\n        if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n            if (this.isBoolean) {\r\n                value = value ? 1 : 0;\r\n            } else if (this.min !== this.max) {\r\n                value = Math.max(this.min, value);\r\n                value = Math.min(this.max, value);\r\n            }\r\n        }\r\n\r\n        this._storedValue = value;\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\r\n\r\n        this.onValueChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a callback used to get the value of that point.\r\n     * Please note that setting this value will force the connection point to ignore the value property\r\n     */\r\n    public get valueCallback(): () => any {\r\n        return this._valueCallback;\r\n    }\r\n\r\n    public set valueCallback(value: () => any) {\r\n        this._valueCallback = value;\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the associated variable name in the shader\r\n     */\r\n    public get associatedVariableName(): string {\r\n        return this._associatedVariableName;\r\n    }\r\n\r\n    public set associatedVariableName(value: string) {\r\n        this._associatedVariableName = value;\r\n    }\r\n\r\n    /** Gets or sets the type of animation applied to the input */\r\n    public get animationType() {\r\n        return this._animationType;\r\n    }\r\n\r\n    public set animationType(value: AnimatedInputBlockTypes) {\r\n        this._animationType = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this connection point not defined yet\r\n     */\r\n    public get isUndefined(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is coming from an uniform.\r\n     * In this case the connection point name must be the name of the uniform to use.\r\n     * Can only be set on inputs\r\n     */\r\n    public get isUniform(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Uniform;\r\n    }\r\n\r\n    public set isUniform(value: boolean) {\r\n        this._mode = value ? NodeMaterialBlockConnectionPointMode.Uniform : NodeMaterialBlockConnectionPointMode.Undefined;\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is coming from an attribute.\r\n     * In this case the connection point name must be the name of the attribute to use\r\n     * Can only be set on inputs\r\n     */\r\n    public get isAttribute(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Attribute;\r\n    }\r\n\r\n    public set isAttribute(value: boolean) {\r\n        this._mode = value ? NodeMaterialBlockConnectionPointMode.Attribute : NodeMaterialBlockConnectionPointMode.Undefined;\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is generating a varying variable.\r\n     * Can only be set on exit points\r\n     */\r\n    public get isVarying(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Varying;\r\n    }\r\n\r\n    public set isVarying(value: boolean) {\r\n        this._mode = value ? NodeMaterialBlockConnectionPointMode.Varying : NodeMaterialBlockConnectionPointMode.Undefined;\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current connection point is a system value\r\n     */\r\n    public get isSystemValue(): boolean {\r\n        return this._systemValue != null;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current well known value or null if not defined as a system value\r\n     */\r\n    public get systemValue(): Nullable<NodeMaterialSystemValues> {\r\n        return this._systemValue;\r\n    }\r\n\r\n    public set systemValue(value: Nullable<NodeMaterialSystemValues>) {\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\r\n        this.associatedVariableName = \"\";\r\n        this._systemValue = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"InputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Animate the input if animationType !== None\r\n     * @param scene defines the rendering scene\r\n     */\r\n    public animate(scene: Scene) {\r\n        switch (this._animationType) {\r\n            case AnimatedInputBlockTypes.Time: {\r\n                if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                    this.value += scene.getAnimationRatio() * 0.01;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _emitDefine(define: string): string {\r\n        if (define[0] === \"!\") {\r\n            return `#ifndef ${define.substring(1)}\\r\\n`;\r\n        }\r\n\r\n        return `#ifdef ${define}\\r\\n`;\r\n    }\r\n\r\n    public initialize() {\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Set the input block to its default value (based on its type)\r\n     */\r\n    public setDefaultValue() {\r\n        switch (this.type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                this.value = 0;\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                this.value = Vector2.Zero();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                this.value = Vector3.Zero();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                this.value = Vector4.Zero();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                this.value = Color3.White();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                this.value = new Color4(1, 1, 1, 1);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                this.value = Matrix.Identity();\r\n                break;\r\n        }\r\n    }\r\n\r\n    private _emitConstant(state: NodeMaterialBuildState) {\r\n        switch (this.type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                return `${state._emitFloat(this.value)}`;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                return `vec2(${this.value.x}, ${this.value.y})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                return `vec3(${this.value.x}, ${this.value.y}, ${this.value.z})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                return `vec4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0]);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0]);\r\n                }\r\n                return `vec3(${TmpColors.Color3[0].r}, ${TmpColors.Color3[0].g}, ${TmpColors.Color3[0].b})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0]);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0]);\r\n                }\r\n                return `vec4(${TmpColors.Color4[0].r}, ${TmpColors.Color4[0].g}, ${TmpColors.Color4[0].b}, ${TmpColors.Color4[0].a})`;\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /** @internal */\r\n    public get _noContextSwitch(): boolean {\r\n        return attributeInFragmentOnly[this.name];\r\n    }\r\n\r\n    private _emit(state: NodeMaterialBuildState, define?: string) {\r\n        // Uniforms\r\n        if (this.isUniform) {\r\n            if (!this.associatedVariableName) {\r\n                this.associatedVariableName = state._getFreeVariableName(\"u_\" + this.name);\r\n            }\r\n\r\n            if (this.isConstant) {\r\n                if (state.constants.indexOf(this.associatedVariableName) !== -1) {\r\n                    return;\r\n                }\r\n                state.constants.push(this.associatedVariableName);\r\n                state._constantDeclaration += this._declareOutput(this.output, state) + ` = ${this._emitConstant(state)};\\r\\n`;\r\n                return;\r\n            }\r\n\r\n            if (state.uniforms.indexOf(this.associatedVariableName) !== -1) {\r\n                return;\r\n            }\r\n\r\n            state.uniforms.push(this.associatedVariableName);\r\n            if (define) {\r\n                state._uniformDeclaration += this._emitDefine(define);\r\n            }\r\n            state._uniformDeclaration += `uniform ${state._getGLType(this.type)} ${this.associatedVariableName};\\r\\n`;\r\n            if (define) {\r\n                state._uniformDeclaration += `#endif\\r\\n`;\r\n            }\r\n\r\n            // well known\r\n            const hints = state.sharedData.hints;\r\n            if (this._systemValue !== null && this._systemValue !== undefined) {\r\n                switch (this._systemValue) {\r\n                    case NodeMaterialSystemValues.WorldView:\r\n                        hints.needWorldViewMatrix = true;\r\n                        break;\r\n                    case NodeMaterialSystemValues.WorldViewProjection:\r\n                        hints.needWorldViewProjectionMatrix = true;\r\n                        break;\r\n                }\r\n            } else {\r\n                if (this._animationType !== AnimatedInputBlockTypes.None) {\r\n                    state.sharedData.animatedInputs.push(this);\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Attribute\r\n        if (this.isAttribute) {\r\n            this.associatedVariableName = remapAttributeName[this.name] ?? this.name;\r\n\r\n            if (this.target === NodeMaterialBlockTargets.Vertex && state._vertexState) {\r\n                // Attribute for fragment need to be carried over by varyings\r\n                if (attributeInFragmentOnly[this.name]) {\r\n                    if (attributeAsUniform[this.name]) {\r\n                        state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);\r\n                    } else {\r\n                        state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);\r\n                    }\r\n                } else {\r\n                    this._emit(state._vertexState, define);\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (state.attributes.indexOf(this.associatedVariableName) !== -1) {\r\n                return;\r\n            }\r\n\r\n            state.attributes.push(this.associatedVariableName);\r\n\r\n            if (attributeInFragmentOnly[this.name]) {\r\n                if (attributeAsUniform[this.name]) {\r\n                    state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);\r\n                } else {\r\n                    state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);\r\n                }\r\n            } else {\r\n                if (define) {\r\n                    state._attributeDeclaration += this._emitDefine(define);\r\n                }\r\n                state._attributeDeclaration += `attribute ${state._getGLType(this.type)} ${this.associatedVariableName};\\r\\n`;\r\n                if (define) {\r\n                    state._attributeDeclaration += `#endif\\r\\n`;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _transmitWorld(effect: Effect, world: Matrix, worldView: Matrix, worldViewProjection: Matrix) {\r\n        if (!this._systemValue) {\r\n            return;\r\n        }\r\n\r\n        const variableName = this.associatedVariableName;\r\n        switch (this._systemValue) {\r\n            case NodeMaterialSystemValues.World:\r\n                effect.setMatrix(variableName, world);\r\n                break;\r\n            case NodeMaterialSystemValues.WorldView:\r\n                effect.setMatrix(variableName, worldView);\r\n                break;\r\n            case NodeMaterialSystemValues.WorldViewProjection:\r\n                effect.setMatrix(variableName, worldViewProjection);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _transmit(effect: Effect, scene: Scene, material: NodeMaterial) {\r\n        if (this.isAttribute) {\r\n            return;\r\n        }\r\n\r\n        const variableName = this.associatedVariableName;\r\n        if (this._systemValue) {\r\n            switch (this._systemValue) {\r\n                case NodeMaterialSystemValues.World:\r\n                case NodeMaterialSystemValues.WorldView:\r\n                case NodeMaterialSystemValues.WorldViewProjection:\r\n                    return;\r\n                case NodeMaterialSystemValues.View:\r\n                    effect.setMatrix(variableName, scene.getViewMatrix());\r\n                    break;\r\n                case NodeMaterialSystemValues.Projection:\r\n                    effect.setMatrix(variableName, scene.getProjectionMatrix());\r\n                    break;\r\n                case NodeMaterialSystemValues.ViewProjection:\r\n                    effect.setMatrix(variableName, scene.getTransformMatrix());\r\n                    break;\r\n                case NodeMaterialSystemValues.CameraPosition:\r\n                    scene.bindEyePosition(effect, variableName, true);\r\n                    break;\r\n                case NodeMaterialSystemValues.FogColor:\r\n                    effect.setColor3(variableName, scene.fogColor);\r\n                    break;\r\n                case NodeMaterialSystemValues.DeltaTime:\r\n                    effect.setFloat(variableName, scene.deltaTime / 1000.0);\r\n                    break;\r\n                case NodeMaterialSystemValues.CameraParameters:\r\n                    if (scene.activeCamera) {\r\n                        effect.setFloat4(\r\n                            variableName,\r\n                            scene.getEngine().hasOriginBottomLeft ? -1 : 1,\r\n                            scene.activeCamera.minZ,\r\n                            scene.activeCamera.maxZ,\r\n                            1 / scene.activeCamera.maxZ\r\n                        );\r\n                    }\r\n                    break;\r\n                case NodeMaterialSystemValues.MaterialAlpha:\r\n                    effect.setFloat(variableName, material.alpha);\r\n                    break;\r\n            }\r\n            return;\r\n        }\r\n\r\n        const value = this._valueCallback ? this._valueCallback() : this._storedValue;\r\n\r\n        if (value === null) {\r\n            return;\r\n        }\r\n\r\n        switch (this.type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                effect.setFloat(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Int:\r\n                effect.setInt(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0]);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0]);\r\n                }\r\n                effect.setColor3(variableName, TmpColors.Color3[0]);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0]);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0]);\r\n                }\r\n                effect.setDirectColor4(variableName, TmpColors.Color4[0]);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                effect.setVector2(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                effect.setVector3(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                effect.setVector4(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                effect.setMatrix(variableName, value);\r\n                break;\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (this.isUniform || this.isSystemValue) {\r\n            state.sharedData.inputBlocks.push(this);\r\n        }\r\n\r\n        this._emit(state);\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n\r\n        if (this.isAttribute) {\r\n            return super._dumpPropertiesCode() + `${variableName}.setAsAttribute(\"${this.name}\");\\r\\n`;\r\n        }\r\n        if (this.isSystemValue) {\r\n            return super._dumpPropertiesCode() + `${variableName}.setAsSystemValue(BABYLON.NodeMaterialSystemValues.${NodeMaterialSystemValues[this._systemValue!]});\\r\\n`;\r\n        }\r\n        if (this.isUniform) {\r\n            const codes: string[] = [];\r\n\r\n            let valueString = \"\";\r\n\r\n            switch (this.type) {\r\n                case NodeMaterialBlockConnectionPointTypes.Float:\r\n                    valueString = `${this.value}`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                    valueString = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                    valueString = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                    valueString = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                    valueString = `new BABYLON.Color3(${this.value.r}, ${this.value.g}, ${this.value.b})`;\r\n                    if (this.convertToGammaSpace) {\r\n                        valueString += \".toGammaSpace()\";\r\n                    }\r\n                    if (this.convertToLinearSpace) {\r\n                        valueString += \".toLinearSpace()\";\r\n                    }\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                    valueString = `new BABYLON.Color4(${this.value.r}, ${this.value.g}, ${this.value.b}, ${this.value.a})`;\r\n                    if (this.convertToGammaSpace) {\r\n                        valueString += \".toGammaSpace()\";\r\n                    }\r\n                    if (this.convertToLinearSpace) {\r\n                        valueString += \".toLinearSpace()\";\r\n                    }\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                    valueString = `BABYLON.Matrix.FromArray([${(this.value as Matrix).m}])`;\r\n                    break;\r\n            }\r\n\r\n            // Common Property \"Value\"\r\n            codes.push(`${variableName}.value = ${valueString}`);\r\n\r\n            // Float-Value-Specific Properties\r\n            if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                codes.push(\r\n                    `${variableName}.min = ${this.min}`,\r\n                    `${variableName}.max = ${this.max}`,\r\n                    `${variableName}.isBoolean = ${this.isBoolean}`,\r\n                    `${variableName}.matrixMode = ${this.matrixMode}`,\r\n                    `${variableName}.animationType = BABYLON.AnimatedInputBlockTypes.${AnimatedInputBlockTypes[this.animationType]}`\r\n                );\r\n            }\r\n\r\n            // Common Property \"Type\"\r\n            codes.push(`${variableName}.isConstant = ${this.isConstant}`);\r\n\r\n            codes.push(\"\");\r\n\r\n            return super._dumpPropertiesCode() + codes.join(\";\\r\\n\");\r\n        }\r\n        return super._dumpPropertiesCode();\r\n    }\r\n\r\n    public dispose() {\r\n        this.onValueChangedObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.type = this.type;\r\n        serializationObject.mode = this._mode;\r\n        serializationObject.systemValue = this._systemValue;\r\n        serializationObject.animationType = this._animationType;\r\n        serializationObject.min = this.min;\r\n        serializationObject.max = this.max;\r\n        serializationObject.isBoolean = this.isBoolean;\r\n        serializationObject.matrixMode = this.matrixMode;\r\n        serializationObject.isConstant = this.isConstant;\r\n        serializationObject.groupInInspector = this.groupInInspector;\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n\r\n        if (this._storedValue != null && this._mode === NodeMaterialBlockConnectionPointMode.Uniform) {\r\n            if (this._storedValue.asArray) {\r\n                serializationObject.valueType = \"BABYLON.\" + this._storedValue.getClassName();\r\n                serializationObject.value = this._storedValue.asArray();\r\n            } else {\r\n                serializationObject.valueType = \"number\";\r\n                serializationObject.value = this._storedValue;\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        this._mode = serializationObject.mode;\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this._type = serializationObject.type;\r\n\r\n        this._systemValue = serializationObject.systemValue || serializationObject.wellKnownValue;\r\n        this._animationType = serializationObject.animationType;\r\n        this.min = serializationObject.min || 0;\r\n        this.max = serializationObject.max || 0;\r\n        this.isBoolean = !!serializationObject.isBoolean;\r\n        this.matrixMode = serializationObject.matrixMode || 0;\r\n        this.isConstant = !!serializationObject.isConstant;\r\n        this.groupInInspector = serializationObject.groupInInspector || \"\";\r\n        this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n\r\n        // Tangents back compat\r\n        if (\r\n            serializationObject.name === \"tangent\" &&\r\n            serializationObject.mode === NodeMaterialBlockConnectionPointMode.Attribute &&\r\n            serializationObject.type === NodeMaterialBlockConnectionPointTypes.Vector3\r\n        ) {\r\n            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n        }\r\n\r\n        if (!serializationObject.valueType) {\r\n            return;\r\n        }\r\n\r\n        if (serializationObject.valueType === \"number\") {\r\n            this._storedValue = serializationObject.value;\r\n        } else {\r\n            const valueType = GetClass(serializationObject.valueType);\r\n\r\n            if (valueType) {\r\n                this._storedValue = valueType.FromArray(serializationObject.value);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InputBlock\", InputBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { InputBlock } from \"../Input/inputBlock\";\r\n\r\ndeclare type NodeMaterial = import(\"../../nodeMaterial\").NodeMaterial;\r\n\r\n/**\r\n * Base block used as input for post process\r\n */\r\nexport class CurrentScreenBlock extends NodeMaterialBlock {\r\n    private _samplerName = \"textureSampler\";\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    private _mainUVName: string;\r\n    private _tempTextureRead: string;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public convertToGammaSpace = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Create a new CurrentScreenBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._isUnique = false;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n\r\n        this._inputs[0]._prioritizeVertex = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"CurrentScreenBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"textureSampler\");\r\n    }\r\n\r\n    public get target() {\r\n        if (!this.uv.isConnected) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        if (this.uv.sourceBlock!.isInput) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Fragment;\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\r\n    }\r\n\r\n    public isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _injectVertexCode(state: NodeMaterialBuildState) {\r\n        const uvInput = this.uv;\r\n\r\n        if (uvInput.connectedPoint!.ownerBlock.isInput) {\r\n            const uvInputOwnerBlock = uvInput.connectedPoint!.ownerBlock as InputBlock;\r\n\r\n            if (!uvInputOwnerBlock.isAttribute) {\r\n                state._emitUniformFromString(uvInput.associatedVariableName, \"vec2\");\r\n            }\r\n        }\r\n\r\n        this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\r\n\r\n        state._emitVaryingFromString(this._mainUVName, \"vec2\");\r\n\r\n        state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\r\\n`;\r\n\r\n        if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n            return;\r\n        }\r\n\r\n        this._writeTextureRead(state, true);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _writeTextureRead(state: NodeMaterialBuildState, vertexMode = false) {\r\n        const uvInput = this.uv;\r\n\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\\r\\n`;\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\\r\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._mainUVName});\\r\\n`;\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string, vertexMode = false) {\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\r\n\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\r\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\r\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n\r\n        if (state.sharedData.blockingBlocks.indexOf(this) < 0) {\r\n            state.sharedData.blockingBlocks.push(this);\r\n        }\r\n        if (state.sharedData.textureBlocks.indexOf(this) < 0) {\r\n            state.sharedData.textureBlocks.push(this);\r\n        }\r\n        if (state.sharedData.blocksWithDefines.indexOf(this) < 0) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n        }\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            state._emit2DSampler(this._samplerName);\r\n            this._injectVertexCode(state);\r\n            return;\r\n        }\r\n\r\n        // Fragment\r\n        if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {\r\n            return;\r\n        }\r\n\r\n        state._emit2DSampler(this._samplerName);\r\n\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        this._writeTextureRead(state);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CurrentScreenBlock\", CurrentScreenBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { Scene } from \"../../../../scene\";\r\n\r\ndeclare type NodeMaterial = import(\"../../nodeMaterial\").NodeMaterial;\r\n\r\n/**\r\n * Base block used for the particle texture\r\n */\r\nexport class ParticleTextureBlock extends NodeMaterialBlock {\r\n    private _samplerName = \"diffuseSampler\";\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    private _tempTextureRead: string;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public convertToGammaSpace = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Create a new ParticleTextureBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = false;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ParticleTextureBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"diffuseSampler\");\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.uv.isConnected) {\r\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"particle_uv\");\r\n\r\n            if (!uvInput) {\r\n                uvInput = new InputBlock(\"uv\");\r\n                uvInput.setAsAttribute(\"particle_uv\");\r\n            }\r\n            uvInput.output.connectTo(this.uv);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\r\n    }\r\n\r\n    public isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string) {\r\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\r\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\r\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n\r\n        state._emit2DSampler(this._samplerName);\r\n\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this.uv.associatedVariableName});\\r\\n`;\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ParticleTextureBlock\", ParticleTextureBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n\r\n/**\r\n * Block used for the particle ramp gradient section\r\n */\r\nexport class ParticleRampGradientBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ParticleRampGradientBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"rampColor\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ParticleRampGradientBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rampColor output component\r\n     */\r\n    public get rampColor(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"remapRanges\");\r\n        state._excludeVariableName(\"rampSampler\");\r\n        state._excludeVariableName(\"baseColor\");\r\n        state._excludeVariableName(\"alpha\");\r\n        state._excludeVariableName(\"remappedColorIndex\");\r\n        state._excludeVariableName(\"rampColor\");\r\n        state._excludeVariableName(\"finalAlpha\");\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        state._emit2DSampler(\"rampSampler\");\r\n        state._emitVaryingFromString(\"remapRanges\", \"vec4\", \"RAMPGRADIENT\");\r\n\r\n        state.compilationString += `\r\n            #ifdef RAMPGRADIENT\r\n                vec4 baseColor = ${this.color.associatedVariableName};\r\n                float alpha = ${this.color.associatedVariableName}.a;\r\n\r\n                float remappedColorIndex = clamp((alpha - remapRanges.x) / remapRanges.y, 0.0, 1.0);\r\n\r\n                vec4 rampColor = texture2D(rampSampler, vec2(1.0 - remappedColorIndex, 0.));\r\n                baseColor.rgb *= rampColor.rgb;\r\n\r\n                // Remapped alpha\r\n                float finalAlpha = baseColor.a;\r\n                baseColor.a = clamp((alpha * rampColor.a - remapRanges.z) / remapRanges.w, 0.0, 1.0);\r\n\r\n                ${this._declareOutput(this.rampColor, state)} = baseColor;\r\n            #else\r\n                ${this._declareOutput(this.rampColor, state)} = ${this.color.associatedVariableName};\r\n            #endif\r\n        `;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ParticleRampGradientBlock\", ParticleRampGradientBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n\r\n/**\r\n * Block used for the particle blend multiply section\r\n */\r\nexport class ParticleBlendMultiplyBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ParticleBlendMultiplyBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"alphaTexture\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"alphaColor\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"blendColor\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ParticleBlendMultiplyBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the alphaTexture input component\r\n     */\r\n    public get alphaTexture(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the alphaColor input component\r\n     */\r\n    public get alphaColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the blendColor output component\r\n     */\r\n    public get blendColor(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"sourceAlpha\");\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `\r\n            #ifdef BLENDMULTIPLYMODE\r\n                ${this._declareOutput(this.blendColor, state)};\r\n                float sourceAlpha = ${this.alphaColor.associatedVariableName} * ${this.alphaTexture.associatedVariableName};\r\n                ${this.blendColor.associatedVariableName}.rgb = ${this.color.associatedVariableName}.rgb * sourceAlpha + vec3(1.0) * (1.0 - sourceAlpha);\r\n                ${this.blendColor.associatedVariableName}.a = ${this.color.associatedVariableName}.a;\r\n            #else\r\n                ${this._declareOutput(this.blendColor, state)} = ${this.color.associatedVariableName};\r\n            #endif\r\n        `;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ParticleBlendMultiplyBlock\", ParticleBlendMultiplyBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\n\r\n/**\r\n * Block used to create a Vector2/3/4 out of individual inputs (one for each component)\r\n */\r\nexport class VectorMergerBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the swizzle for x (meaning which component to affect to the output.x)\r\n     */\r\n    public xSwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"x\";\r\n    /**\r\n     * Gets or sets the swizzle for y (meaning which component to affect to the output.y)\r\n     */\r\n    public ySwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"y\";\r\n    /**\r\n     * Gets or sets the swizzle for z (meaning which component to affect to the output.z)\r\n     */\r\n    public zSwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"z\";\r\n    /**\r\n     * Gets or sets the swizzle for w (meaning which component to affect to the output.w)\r\n     */\r\n    public wSwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"w\";\r\n\r\n    /**\r\n     * Create a new VectorMergerBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"xyzw \", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\"xyz \", NodeMaterialBlockConnectionPointTypes.Vector3, true);\r\n        this.registerInput(\"xy \", NodeMaterialBlockConnectionPointTypes.Vector2, true);\r\n        this.registerInput(\"zw \", NodeMaterialBlockConnectionPointTypes.Vector2, true);\r\n        this.registerInput(\"x\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"y\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"z\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"w\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n\r\n        this.registerOutput(\"xyzw\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"xy\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"zw\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"VectorMergerBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the xyzw component (input)\r\n     */\r\n    public get xyzwIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (input)\r\n     */\r\n    public get xyzIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (input)\r\n     */\r\n    public get xyIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the zw component (input)\r\n     */\r\n    public get zwIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the x component (input)\r\n     */\r\n    public get x(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the y component (input)\r\n     */\r\n    public get y(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the z component (input)\r\n     */\r\n    public get z(): NodeMaterialConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the w component (input)\r\n     */\r\n    public get w(): NodeMaterialConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyzw component (output)\r\n     */\r\n    public get xyzw(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (output)\r\n     */\r\n    public get xyzOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (output)\r\n     */\r\n    public get xyOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the zw component (output)\r\n     */\r\n    public get zwOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (output)\r\n     * @deprecated Please use xyOut instead.\r\n     */\r\n    public get xy(): NodeMaterialConnectionPoint {\r\n        return this.xyOut;\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (output)\r\n     * @deprecated Please use xyzOut instead.\r\n     */\r\n    public get xyz(): NodeMaterialConnectionPoint {\r\n        return this.xyzOut;\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        if (name === \"xyzw \") {\r\n            return \"xyzwIn\";\r\n        }\r\n        if (name === \"xyz \") {\r\n            return \"xyzIn\";\r\n        }\r\n        if (name === \"xy \") {\r\n            return \"xyIn\";\r\n        }\r\n        if (name === \"zw \") {\r\n            return \"zwIn\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    private _buildSwizzle(len: number) {\r\n        const swizzle = this.xSwizzle + this.ySwizzle + this.zSwizzle + this.wSwizzle;\r\n\r\n        return \".\" + swizzle.substr(0, len);\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const xInput = this.x;\r\n        const yInput = this.y;\r\n        const zInput = this.z;\r\n        const wInput = this.w;\r\n        const xyInput = this.xyIn;\r\n        const zwInput = this.zwIn;\r\n        const xyzInput = this.xyzIn;\r\n        const xyzwInput = this.xyzwIn;\r\n\r\n        const v4Output = this._outputs[0];\r\n        const v3Output = this._outputs[1];\r\n        const v2Output = this._outputs[2];\r\n        const v2CompOutput = this._outputs[3];\r\n\r\n        if (xyzwInput.isConnected) {\r\n            if (v4Output.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(v4Output, state) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(4)};\\r\\n`;\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(v3Output, state) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(3)};\\r\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(v2Output, state) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(2)};\\r\\n`;\r\n            }\r\n        } else if (xyzInput.isConnected) {\r\n            if (v4Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    this._declareOutput(v4Output, state) +\r\n                    ` = vec4(${xyzInput.associatedVariableName}, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(4)};\\r\\n`;\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(v3Output, state) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(3)};\\r\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(v2Output, state) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(2)};\\r\\n`;\r\n            }\r\n        } else if (xyInput.isConnected) {\r\n            if (v4Output.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString +=\r\n                        this._declareOutput(v4Output, state) + ` = vec4(${xyInput.associatedVariableName}, ${zwInput.associatedVariableName})${this._buildSwizzle(4)};\\r\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        this._declareOutput(v4Output, state) +\r\n                        ` = vec4(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"}, ${\r\n                            wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"\r\n                        })${this._buildSwizzle(4)};\\r\\n`;\r\n                }\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    this._declareOutput(v3Output, state) +\r\n                    ` = vec3(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"})${this._buildSwizzle(3)};\\r\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(v2Output, state) + ` = ${xyInput.associatedVariableName}${this._buildSwizzle(2)};\\r\\n`;\r\n            }\r\n\r\n            if (v2CompOutput.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString += this._declareOutput(v2CompOutput, state) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};\\r\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        this._declareOutput(v2CompOutput, state) +\r\n                        ` = vec2(${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"}, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(\r\n                            2\r\n                        )};\\r\\n`;\r\n                }\r\n            }\r\n        } else {\r\n            if (v4Output.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString +=\r\n                        this._declareOutput(v4Output, state) +\r\n                        ` = vec4(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"}, ${\r\n                            zwInput.associatedVariableName\r\n                        })${this._buildSwizzle(4)};\\r\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        this._declareOutput(v4Output, state) +\r\n                        ` = vec4(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"}, ${\r\n                            zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"\r\n                        }, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(4)};\\r\\n`;\r\n                }\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    this._declareOutput(v3Output, state) +\r\n                    ` = vec3(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"}, ${\r\n                        zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"\r\n                    })${this._buildSwizzle(3)};\\r\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    this._declareOutput(v2Output, state) +\r\n                    ` = vec2(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"})${this._buildSwizzle(\r\n                        2\r\n                    )};\\r\\n`;\r\n            }\r\n\r\n            if (v2CompOutput.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString += this._declareOutput(v2CompOutput, state) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};\\r\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        this._declareOutput(v2CompOutput, state) +\r\n                        ` = vec2(${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"}, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(\r\n                            2\r\n                        )};\\r\\n`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.xSwizzle = this.xSwizzle;\r\n        serializationObject.ySwizzle = this.ySwizzle;\r\n        serializationObject.zSwizzle = this.zSwizzle;\r\n        serializationObject.wSwizzle = this.wSwizzle;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.xSwizzle = serializationObject.xSwizzle ?? \"x\";\r\n        this.ySwizzle = serializationObject.ySwizzle ?? \"y\";\r\n        this.zSwizzle = serializationObject.zSwizzle ?? \"z\";\r\n        this.wSwizzle = serializationObject.wSwizzle ?? \"w\";\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n        codeString += `${this._codeVariableName}.xSwizzle = \"${this.xSwizzle}\";\\r\\n`;\r\n        codeString += `${this._codeVariableName}.ySwizzle = \"${this.ySwizzle}\";\\r\\n`;\r\n        codeString += `${this._codeVariableName}.zSwizzle = \"${this.zSwizzle}\";\\r\\n`;\r\n        codeString += `${this._codeVariableName}.wSwizzle = \"${this.wSwizzle}\";\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VectorMergerBlock\", VectorMergerBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { Vector2 } from \"../../../Maths/math.vector\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../nodeMaterialDecorator\";\r\n/**\r\n * Block used to remap a float from a range to a new one\r\n */\r\nexport class RemapBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the source range\r\n     */\r\n    @editableInPropertyPage(\"From\", PropertyTypeForEdition.Vector2)\r\n    public sourceRange = new Vector2(-1, 1);\r\n\r\n    /**\r\n     * Gets or sets the target range\r\n     */\r\n    @editableInPropertyPage(\"To\", PropertyTypeForEdition.Vector2)\r\n    public targetRange = new Vector2(0, 1);\r\n\r\n    /**\r\n     * Creates a new RemapBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"sourceMin\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"sourceMax\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"targetMin\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"targetMax\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"RemapBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the source min input component\r\n     */\r\n    public get sourceMin(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the source max input component\r\n     */\r\n    public get sourceMax(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the target min input component\r\n     */\r\n    public get targetMin(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the target max input component\r\n     */\r\n    public get targetMax(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        const sourceMin = this.sourceMin.isConnected ? this.sourceMin.associatedVariableName : this._writeFloat(this.sourceRange.x);\r\n        const sourceMax = this.sourceMax.isConnected ? this.sourceMax.associatedVariableName : this._writeFloat(this.sourceRange.y);\r\n\r\n        const targetMin = this.targetMin.isConnected ? this.targetMin.associatedVariableName : this._writeFloat(this.targetRange.x);\r\n        const targetMax = this.targetMax.isConnected ? this.targetMax.associatedVariableName : this._writeFloat(this.targetRange.y);\r\n\r\n        state.compilationString +=\r\n            this._declareOutput(output, state) +\r\n            ` = ${targetMin} + (${this._inputs[0].associatedVariableName} - ${sourceMin}) * (${targetMax} - ${targetMin}) / (${sourceMax} - ${sourceMin});\\r\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.sourceRange = new BABYLON.Vector2(${this.sourceRange.x}, ${this.sourceRange.y});\\r\\n`;\r\n\r\n        codeString += `${this._codeVariableName}.targetRange = new BABYLON.Vector2(${this.targetRange.x}, ${this.targetRange.y});\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.sourceRange = this.sourceRange.asArray();\r\n        serializationObject.targetRange = this.targetRange.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.sourceRange = Vector2.FromArray(serializationObject.sourceRange);\r\n        this.targetRange = Vector2.FromArray(serializationObject.targetRange);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RemapBlock\", RemapBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to multiply 2 values\r\n */\r\nexport class MultiplyBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new MultiplyBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"left\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"right\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._linkConnectionTypes(0, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"MultiplyBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the left operand input component\r\n     */\r\n    public get left(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right operand input component\r\n     */\r\n    public get right(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += this._declareOutput(output, state) + ` = ${this.left.associatedVariableName} * ${this.right.associatedVariableName};\\r\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MultiplyBlock\", MultiplyBlock);\r\n", "/**\r\n * Enum used to define the material modes\r\n */\r\nexport enum NodeMaterialModes {\r\n    /** Regular material */\r\n    Material = 0,\r\n    /** For post process */\r\n    PostProcess = 1,\r\n    /** For particle system */\r\n    Particle = 2,\r\n    /** For procedural texture */\r\n    ProceduralTexture = 3,\r\n}\r\n", "import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a box.\r\n * It emits the particles randomly between 2 given directions.\r\n */\r\nexport class BoxParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction1 = new Vector3(0, 1.0, 0);\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction2 = new Vector3(0, 1.0, 0);\r\n\r\n    /**\r\n     * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\r\n     */\r\n    public minEmitBox = new Vector3(-0.5, -0.5, -0.5);\r\n    /**\r\n     * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\r\n     */\r\n    public maxEmitBox = new Vector3(0.5, 0.5, 0.5);\r\n\r\n    /**\r\n     * Creates a new instance BoxParticleEmitter\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.x = randX;\r\n            directionToUpdate.y = randY;\r\n            directionToUpdate.z = randZ;\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const randX = Scalar.RandomRange(this.minEmitBox.x, this.maxEmitBox.x);\r\n        const randY = Scalar.RandomRange(this.minEmitBox.y, this.maxEmitBox.y);\r\n        const randZ = Scalar.RandomRange(this.minEmitBox.z, this.maxEmitBox.z);\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.x = randX;\r\n            positionToUpdate.y = randY;\r\n            positionToUpdate.z = randZ;\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): BoxParticleEmitter {\r\n        const newOne = new BoxParticleEmitter();\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n        uboOrEffect.setVector3(\"minEmitBox\", this.minEmitBox);\r\n        uboOrEffect.setVector3(\"maxEmitBox\", this.maxEmitBox);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n        ubo.addUniform(\"minEmitBox\", 3);\r\n        ubo.addUniform(\"maxEmitBox\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define BOXEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"BoxParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BoxParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n        serializationObject.minEmitBox = this.minEmitBox.asArray();\r\n        serializationObject.maxEmitBox = this.maxEmitBox.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\r\n        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\r\n        Vector3.FromArrayToRef(serializationObject.minEmitBox, 0, this.minEmitBox);\r\n        Vector3.FromArrayToRef(serializationObject.maxEmitBox, 0, this.maxEmitBox);\r\n    }\r\n}\r\n", "import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a cone.\r\n * It emits the particles alongside the cone volume from the base to the particle.\r\n * The emission direction might be randomized.\r\n */\r\nexport class ConeParticleEmitter implements IParticleEmitterType {\r\n    private _radius: number;\r\n    private _angle: number;\r\n    private _height: number;\r\n\r\n    /**\r\n     * Gets or sets a value indicating where on the radius the start position should be picked (1 = everywhere, 0 = only surface)\r\n     */\r\n    public radiusRange = 1;\r\n\r\n    /**\r\n     * Gets or sets a value indicating where on the height the start position should be picked (1 = everywhere, 0 = only surface)\r\n     */\r\n    public heightRange = 1;\r\n\r\n    /**\r\n     * Gets or sets a value indicating if all the particles should be emitted from the spawn point only (the base of the cone)\r\n     */\r\n    public emitFromSpawnPointOnly = false;\r\n\r\n    /**\r\n     * Gets or sets the radius of the emission cone\r\n     */\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._buildHeight();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the angle of the emission cone\r\n     */\r\n    public get angle(): number {\r\n        return this._angle;\r\n    }\r\n\r\n    public set angle(value: number) {\r\n        this._angle = value;\r\n        this._buildHeight();\r\n    }\r\n\r\n    private _buildHeight() {\r\n        if (this._angle !== 0) {\r\n            this._height = this._radius / Math.tan(this._angle / 2);\r\n        } else {\r\n            this._height = 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance ConeParticleEmitter\r\n     * @param radius the radius of the emission cone (1 by default)\r\n     * @param angle the cone base angle (PI by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)\r\n     */\r\n    constructor(\r\n        radius = 1,\r\n        angle = Math.PI,\r\n        /** defines how much to randomize the particle direction [0-1] (default is 0) */\r\n        public directionRandomizer = 0\r\n    ) {\r\n        this.angle = angle;\r\n        this.radius = radius;\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (isLocal) {\r\n            TmpVectors.Vector3[0].copyFrom(particle._localPosition!).normalize();\r\n        } else {\r\n            particle.position.subtractToRef(worldMatrix.getTranslation(), TmpVectors.Vector3[0]).normalize();\r\n        }\r\n\r\n        const randX = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randY = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randZ = Scalar.RandomRange(0, this.directionRandomizer);\r\n        directionToUpdate.x = TmpVectors.Vector3[0].x + randX;\r\n        directionToUpdate.y = TmpVectors.Vector3[0].y + randY;\r\n        directionToUpdate.z = TmpVectors.Vector3[0].z + randZ;\r\n        directionToUpdate.normalize();\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const s = Scalar.RandomRange(0, Math.PI * 2);\r\n        let h: number;\r\n\r\n        if (!this.emitFromSpawnPointOnly) {\r\n            h = Scalar.RandomRange(0, this.heightRange);\r\n            // Better distribution in a cone at normal angles.\r\n            h = 1 - h * h;\r\n        } else {\r\n            h = 0.0001;\r\n        }\r\n        let radius = this._radius - Scalar.RandomRange(0, this._radius * this.radiusRange);\r\n        radius = radius * h;\r\n\r\n        const randX = radius * Math.sin(s);\r\n        const randZ = radius * Math.cos(s);\r\n        const randY = h * this._height;\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.x = randX;\r\n            positionToUpdate.y = randY;\r\n            positionToUpdate.z = randZ;\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): ConeParticleEmitter {\r\n        const newOne = new ConeParticleEmitter(this._radius, this._angle, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat2(\"radius\", this._radius, this.radiusRange);\r\n        uboOrEffect.setFloat(\"coneAngle\", this._angle);\r\n        uboOrEffect.setFloat2(\"height\", this._height, this.heightRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 2);\r\n        ubo.addUniform(\"coneAngle\", 1);\r\n        ubo.addUniform(\"height\", 2);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        let defines = \"#define CONEEMITTER\";\r\n\r\n        if (this.emitFromSpawnPointOnly) {\r\n            defines += \"\\n#define CONEEMITTERSPAWNPOINT\";\r\n        }\r\n\r\n        return defines;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"ConeParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ConeParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this._radius;\r\n        serializationObject.angle = this._angle;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.heightRange = this.heightRange;\r\n        serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.angle = serializationObject.angle;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n\r\n        this.radiusRange = serializationObject.radiusRange !== undefined ? serializationObject.radiusRange : 1;\r\n        this.heightRange = serializationObject.radiusRange !== undefined ? serializationObject.heightRange : 1;\r\n        this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== undefined ? serializationObject.emitFromSpawnPointOnly : false;\r\n    }\r\n}\r\n", "import type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a cylinder.\r\n * It emits the particles alongside the cylinder radius. The emission direction might be randomized.\r\n */\r\nexport class CylinderParticleEmitter implements IParticleEmitterType {\r\n    private _tempVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Creates a new instance CylinderParticleEmitter\r\n     * @param radius the radius of the emission cylinder (1 by default)\r\n     * @param height the height of the emission cylinder (1 by default)\r\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1]\r\n     */\r\n    constructor(\r\n        /**\r\n         * The radius of the emission cylinder.\r\n         */\r\n        public radius = 1,\r\n        /**\r\n         * The height of the emission cylinder.\r\n         */\r\n        public height = 1,\r\n        /**\r\n         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\r\n         */\r\n        public radiusRange = 1,\r\n        /**\r\n         * How much to randomize the particle direction [0-1].\r\n         */\r\n        public directionRandomizer = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     * @param inverseWorldMatrix defines the inverted world matrix to use if isLocal is false\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean, inverseWorldMatrix: Matrix): void {\r\n        particle.position.subtractToRef(worldMatrix.getTranslation(), this._tempVector);\r\n\r\n        this._tempVector.normalize();\r\n\r\n        Vector3.TransformNormalToRef(this._tempVector, inverseWorldMatrix, this._tempVector);\r\n\r\n        const randY = Scalar.RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2);\r\n\r\n        let angle = Math.atan2(this._tempVector.x, this._tempVector.z);\r\n        angle += Scalar.RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer;\r\n\r\n        this._tempVector.y = randY; // set direction y to rand y to mirror normal of cylinder surface\r\n        this._tempVector.x = Math.sin(angle);\r\n        this._tempVector.z = Math.cos(angle);\r\n        this._tempVector.normalize();\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(this._tempVector);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(this._tempVector.x, this._tempVector.y, this._tempVector.z, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const yPos = Scalar.RandomRange(-this.height / 2, this.height / 2);\r\n        const angle = Scalar.RandomRange(0, 2 * Math.PI);\r\n\r\n        // Pick a properly distributed point within the circle https://programming.guide/random-point-within-circle.html\r\n        const radiusDistribution = Scalar.RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1);\r\n        const positionRadius = Math.sqrt(radiusDistribution) * this.radius;\r\n        const xPos = positionRadius * Math.cos(angle);\r\n        const zPos = positionRadius * Math.sin(angle);\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(xPos, yPos, zPos);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): CylinderParticleEmitter {\r\n        const newOne = new CylinderParticleEmitter(this.radius, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"height\", this.height);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"height\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define CYLINDEREMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"CylinderParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"CylinderParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this.radius;\r\n        serializationObject.height = this.height;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.height = serializationObject.height;\r\n        this.radiusRange = serializationObject.radiusRange;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n    }\r\n}\r\n\r\n/**\r\n * Particle emitter emitting particles from the inside of a cylinder.\r\n * It emits the particles randomly between two vectors.\r\n */\r\nexport class CylinderDirectedParticleEmitter extends CylinderParticleEmitter {\r\n    /**\r\n     * Creates a new instance CylinderDirectedParticleEmitter\r\n     * @param radius the radius of the emission cylinder (1 by default)\r\n     * @param height the height of the emission cylinder (1 by default)\r\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param direction1 the min limit of the emission direction (up vector by default)\r\n     * @param direction2 the max limit of the emission direction (up vector by default)\r\n     */\r\n    constructor(\r\n        radius = 1,\r\n        height = 1,\r\n        radiusRange = 1,\r\n        /**\r\n         * The min limit of the emission direction.\r\n         */\r\n        public direction1 = new Vector3(0, 1, 0),\r\n        /**\r\n         * The max limit of the emission direction.\r\n         */\r\n        public direction2 = new Vector3(0, 1, 0)\r\n    ) {\r\n        super(radius, height, radiusRange);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3): void {\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): CylinderDirectedParticleEmitter {\r\n        const newOne = new CylinderDirectedParticleEmitter(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"height\", this.height);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"height\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define CYLINDEREMITTER\\n#define DIRECTEDCYLINDEREMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"CylinderDirectedParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"CylinderDirectedParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        super.parse(serializationObject);\r\n        this.direction1.copyFrom(serializationObject.direction1);\r\n        this.direction2.copyFrom(serializationObject.direction2);\r\n    }\r\n}\r\n", "import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a hemisphere.\r\n * It emits the particles alongside the hemisphere radius. The emission direction might be randomized.\r\n */\r\nexport class HemisphericParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Creates a new instance HemisphericParticleEmitter\r\n     * @param radius the radius of the emission hemisphere (1 by default)\r\n     * @param radiusRange the range of the emission hemisphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1]\r\n     */\r\n    constructor(\r\n        /**\r\n         * The radius of the emission hemisphere.\r\n         */\r\n        public radius = 1,\r\n        /**\r\n         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\r\n         */\r\n        public radiusRange = 1,\r\n        /**\r\n         * How much to randomize the particle direction [0-1].\r\n         */\r\n        public directionRandomizer = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\r\n        const randX = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randY = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randZ = Scalar.RandomRange(0, this.directionRandomizer);\r\n        direction.x += randX;\r\n        direction.y += randY;\r\n        direction.z += randZ;\r\n        direction.normalize();\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(direction);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\r\n        const v = Scalar.RandomRange(0, 1.0);\r\n        const phi = Scalar.RandomRange(0, 2 * Math.PI);\r\n        const theta = Math.acos(2 * v - 1);\r\n        const randX = randRadius * Math.cos(phi) * Math.sin(theta);\r\n        const randY = randRadius * Math.cos(theta);\r\n        const randZ = randRadius * Math.sin(phi) * Math.sin(theta);\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(randX, Math.abs(randY), randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, Math.abs(randY), randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): HemisphericParticleEmitter {\r\n        const newOne = new HemisphericParticleEmitter(this.radius, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define HEMISPHERICEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"HemisphericParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"HemisphericParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this.radius;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.radiusRange = serializationObject.radiusRange;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n    }\r\n}\r\n", "import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from a point.\r\n * It emits the particles randomly between 2 given directions.\r\n */\r\nexport class PointParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction1 = new Vector3(0, 1.0, 0);\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction2 = new Vector3(0, 1.0, 0);\r\n\r\n    /**\r\n     * Creates a new instance PointParticleEmitter\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFromFloats(randX, randY, randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(0, 0, 0);\r\n            return;\r\n        }\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): PointParticleEmitter {\r\n        const newOne = new PointParticleEmitter();\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define POINTEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PointParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"PointParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\r\n        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\r\n    }\r\n}\r\n", "import type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a sphere.\r\n * It emits the particles alongside the sphere radius. The emission direction might be randomized.\r\n */\r\nexport class SphereParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Creates a new instance SphereParticleEmitter\r\n     * @param radius the radius of the emission sphere (1 by default)\r\n     * @param radiusRange the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1]\r\n     */\r\n    constructor(\r\n        /**\r\n         * The radius of the emission sphere.\r\n         */\r\n        public radius = 1,\r\n        /**\r\n         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\r\n         */\r\n        public radiusRange = 1,\r\n        /**\r\n         * How much to randomize the particle direction [0-1].\r\n         */\r\n        public directionRandomizer = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\r\n        const randX = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randY = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randZ = Scalar.RandomRange(0, this.directionRandomizer);\r\n        direction.x += randX;\r\n        direction.y += randY;\r\n        direction.z += randZ;\r\n        direction.normalize();\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(direction);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\r\n        const v = Scalar.RandomRange(0, 1.0);\r\n        const phi = Scalar.RandomRange(0, 2 * Math.PI);\r\n        const theta = Math.acos(2 * v - 1);\r\n        const randX = randRadius * Math.cos(phi) * Math.sin(theta);\r\n        const randY = randRadius * Math.cos(theta);\r\n        const randZ = randRadius * Math.sin(phi) * Math.sin(theta);\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(randX, randY, randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): SphereParticleEmitter {\r\n        const newOne = new SphereParticleEmitter(this.radius, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define SPHEREEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SphereParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"SphereParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this.radius;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.radiusRange = serializationObject.radiusRange;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n    }\r\n}\r\n\r\n/**\r\n * Particle emitter emitting particles from the inside of a sphere.\r\n * It emits the particles randomly between two vectors.\r\n */\r\nexport class SphereDirectedParticleEmitter extends SphereParticleEmitter {\r\n    /**\r\n     * Creates a new instance SphereDirectedParticleEmitter\r\n     * @param radius the radius of the emission sphere (1 by default)\r\n     * @param direction1 the min limit of the emission direction (up vector by default)\r\n     * @param direction2 the max limit of the emission direction (up vector by default)\r\n     */\r\n    constructor(\r\n        radius = 1,\r\n        /**\r\n         * The min limit of the emission direction.\r\n         */\r\n        public direction1 = new Vector3(0, 1, 0),\r\n        /**\r\n         * The max limit of the emission direction.\r\n         */\r\n        public direction2 = new Vector3(0, 1, 0)\r\n    ) {\r\n        super(radius);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3): void {\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): SphereDirectedParticleEmitter {\r\n        const newOne = new SphereDirectedParticleEmitter(this.radius, this.direction1, this.direction2);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define SPHEREEMITTER\\n#define DIRECTEDSPHEREEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SphereDirectedParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"SphereDirectedParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        super.parse(serializationObject);\r\n        this.direction1.copyFrom(serializationObject.direction1);\r\n        this.direction2.copyFrom(serializationObject.direction2);\r\n    }\r\n}\r\n", "import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Particle } from \"../particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from a custom list of positions.\r\n */\r\nexport class CustomParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Gets or sets the position generator that will create the initial position of each particle.\r\n     * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\r\n     */\r\n    public particlePositionGenerator: (index: number, particle: Nullable<Particle>, outPosition: Vector3) => void = () => {};\r\n\r\n    /**\r\n     * Gets or sets the destination generator that will create the final destination of each particle.\r\n     *  * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\r\n     */\r\n    public particleDestinationGenerator: (index: number, particle: Nullable<Particle>, outDestination: Vector3) => void = () => {};\r\n\r\n    /**\r\n     * Creates a new instance CustomParticleEmitter\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n\r\n        if (this.particleDestinationGenerator) {\r\n            this.particleDestinationGenerator(-1, particle, tmpVector);\r\n\r\n            // Get direction\r\n            const diffVector = TmpVectors.Vector3[1];\r\n            tmpVector.subtractToRef(particle.position, diffVector);\r\n\r\n            diffVector.scaleToRef(1 / particle.lifeTime, tmpVector);\r\n        } else {\r\n            tmpVector.set(0, 0, 0);\r\n        }\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(tmpVector);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalToRef(tmpVector, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n\r\n        if (this.particlePositionGenerator) {\r\n            this.particlePositionGenerator(-1, particle, tmpVector);\r\n        } else {\r\n            tmpVector.set(0, 0, 0);\r\n        }\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFrom(tmpVector);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(tmpVector, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): CustomParticleEmitter {\r\n        const newOne = new CustomParticleEmitter();\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {}\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public buildUniformLayout(ubo: UniformBuffer): void {}\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define CUSTOMEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PointParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"CustomParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public parse(serializationObject: any): void {}\r\n}\r\n", "import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { IndicesArray, Nullable, FloatArray } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a box.\r\n * It emits the particles randomly between 2 given directions.\r\n */\r\nexport class MeshParticleEmitter implements IParticleEmitterType {\r\n    private _indices: Nullable<IndicesArray> = null;\r\n    private _positions: Nullable<FloatArray> = null;\r\n    private _normals: Nullable<FloatArray> = null;\r\n    private _storedNormal = Vector3.Zero();\r\n    private _mesh: Nullable<AbstractMesh> = null;\r\n\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction1 = new Vector3(0, 1.0, 0);\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction2 = new Vector3(0, 1.0, 0);\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that particle directions must be built from mesh face normals\r\n     */\r\n    public useMeshNormalsForDirection = true;\r\n\r\n    /** Defines the mesh to use as source */\r\n    public get mesh(): Nullable<AbstractMesh> {\r\n        return this._mesh;\r\n    }\r\n\r\n    public set mesh(value: Nullable<AbstractMesh>) {\r\n        if (this._mesh === value) {\r\n            return;\r\n        }\r\n\r\n        this._mesh = value;\r\n\r\n        if (value) {\r\n            this._indices = value.getIndices();\r\n            this._positions = value.getVerticesData(VertexBuffer.PositionKind);\r\n            this._normals = value.getVerticesData(VertexBuffer.NormalKind);\r\n        } else {\r\n            this._indices = null;\r\n            this._positions = null;\r\n            this._normals = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance MeshParticleEmitter\r\n     * @param mesh defines the mesh to use as source\r\n     */\r\n    constructor(mesh: Nullable<AbstractMesh> = null) {\r\n        this.mesh = mesh;\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (this.useMeshNormalsForDirection && this._normals) {\r\n            Vector3.TransformNormalToRef(this._storedNormal, worldMatrix, directionToUpdate);\r\n            return;\r\n        }\r\n\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFromFloats(randX, randY, randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (!this._indices || !this._positions) {\r\n            return;\r\n        }\r\n\r\n        const randomFaceIndex = (3 * Math.random() * (this._indices.length / 3)) | 0;\r\n        const bu = Math.random();\r\n        const bv = Math.random() * (1.0 - bu);\r\n        const bw = 1.0 - bu - bv;\r\n\r\n        const faceIndexA = this._indices[randomFaceIndex];\r\n        const faceIndexB = this._indices[randomFaceIndex + 1];\r\n        const faceIndexC = this._indices[randomFaceIndex + 2];\r\n        const vertexA = TmpVectors.Vector3[0];\r\n        const vertexB = TmpVectors.Vector3[1];\r\n        const vertexC = TmpVectors.Vector3[2];\r\n        const randomVertex = TmpVectors.Vector3[3];\r\n\r\n        Vector3.FromArrayToRef(this._positions, faceIndexA * 3, vertexA);\r\n        Vector3.FromArrayToRef(this._positions, faceIndexB * 3, vertexB);\r\n        Vector3.FromArrayToRef(this._positions, faceIndexC * 3, vertexC);\r\n\r\n        randomVertex.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\r\n        randomVertex.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\r\n        randomVertex.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(randomVertex.x, randomVertex.y, randomVertex.z);\r\n        } else {\r\n            Vector3.TransformCoordinatesFromFloatsToRef(randomVertex.x, randomVertex.y, randomVertex.z, worldMatrix, positionToUpdate);\r\n        }\r\n\r\n        if (this.useMeshNormalsForDirection && this._normals) {\r\n            Vector3.FromArrayToRef(this._normals, faceIndexA * 3, vertexA);\r\n            Vector3.FromArrayToRef(this._normals, faceIndexB * 3, vertexB);\r\n            Vector3.FromArrayToRef(this._normals, faceIndexC * 3, vertexC);\r\n\r\n            this._storedNormal.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\r\n            this._storedNormal.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\r\n            this._storedNormal.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): MeshParticleEmitter {\r\n        const newOne = new MeshParticleEmitter(this.mesh);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"BoxParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"MeshParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n        serializationObject.meshId = this.mesh?.id;\r\n        serializationObject.useMeshNormalsForDirection = this.useMeshNormalsForDirection;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     * @param scene defines the hosting scene\r\n     */\r\n    public parse(serializationObject: any, scene: Nullable<Scene>): void {\r\n        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\r\n        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\r\n\r\n        if (serializationObject.meshId && scene) {\r\n            this.mesh = scene.getLastMeshById(serializationObject.meshId);\r\n        }\r\n\r\n        this.useMeshNormalsForDirection = serializationObject.useMeshNormalsForDirection;\r\n    }\r\n}\r\n", "/* eslint-disable import/no-internal-modules */\r\nimport type { Nullable } from \"../types\";\r\nimport { Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { ImageProcessingConfigurationDefines } from \"../Materials/imageProcessingConfiguration\";\r\nimport type { ColorGradient, FactorGradient, Color3Gradient, IValueGradient } from \"../Misc/gradients\";\r\nimport type { IParticleEmitterType } from \"../Particles/EmitterTypes/index\";\r\nimport {\r\n    BoxParticleEmitter,\r\n    PointParticleEmitter,\r\n    HemisphericParticleEmitter,\r\n    SphereParticleEmitter,\r\n    SphereDirectedParticleEmitter,\r\n    CylinderParticleEmitter,\r\n    CylinderDirectedParticleEmitter,\r\n    ConeParticleEmitter,\r\n} from \"../Particles/EmitterTypes/index\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\n\r\nimport \"../Engines/Extensions/engine.dynamicBuffer\";\r\n\r\ndeclare type Animation = import(\"../Animations/animation\").Animation;\r\ndeclare type Scene = import(\"../scene\").Scene;\r\ndeclare type ProceduralTexture = import(\"../Materials/Textures/Procedurals/proceduralTexture\").ProceduralTexture;\r\ndeclare type RawTexture = import(\"../Materials/Textures/rawTexture\").RawTexture;\r\n\r\n/**\r\n * This represents the base class for particle system in Babylon.\r\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\r\n * @example https://doc.babylonjs.com/babylon101/particles\r\n */\r\nexport class BaseParticleSystem {\r\n    /**\r\n     * Source color is added to the destination color without alpha affecting the result\r\n     */\r\n    public static BLENDMODE_ONEONE = 0;\r\n    /**\r\n     * Blend current color and particle color using particle\u2019s alpha\r\n     */\r\n    public static BLENDMODE_STANDARD = 1;\r\n    /**\r\n     * Add current color and particle color multiplied by particle\u2019s alpha\r\n     */\r\n    public static BLENDMODE_ADD = 2;\r\n    /**\r\n     * Multiply current color with particle color\r\n     */\r\n    public static BLENDMODE_MULTIPLY = 3;\r\n\r\n    /**\r\n     * Multiply current color with particle color then add current color and particle color multiplied by particle\u2019s alpha\r\n     */\r\n    public static BLENDMODE_MULTIPLYADD = 4;\r\n\r\n    /**\r\n     * List of animations used by the particle system.\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * Gets or sets the unique id of the particle system\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * The id of the Particle system.\r\n     */\r\n    public id: string;\r\n\r\n    /**\r\n     * The friendly name of the Particle system.\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Snippet ID if the particle system was created from the snippet server\r\n     */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * The rendering group used by the Particle system to chose when to render.\r\n     */\r\n    public renderingGroupId = 0;\r\n\r\n    /**\r\n     * The emitter represents the Mesh or position we are attaching the particle system to.\r\n     */\r\n    public emitter: Nullable<AbstractMesh | Vector3> = Vector3.Zero();\r\n\r\n    /**\r\n     * The maximum number of particles to emit per frame\r\n     */\r\n    public emitRate = 10;\r\n\r\n    /**\r\n     * If you want to launch only a few particles at once, that can be done, as well.\r\n     */\r\n    public manualEmitCount = -1;\r\n\r\n    /**\r\n     * The overall motion speed (0.01 is default update speed, faster updates = faster animation)\r\n     */\r\n    public updateSpeed = 0.01;\r\n\r\n    /**\r\n     * The amount of time the particle system is running (depends of the overall update speed).\r\n     */\r\n    public targetStopDuration = 0;\r\n\r\n    /**\r\n     * Specifies whether the particle system will be disposed once it reaches the end of the animation.\r\n     */\r\n    public disposeOnStop = false;\r\n\r\n    /**\r\n     * Minimum power of emitting particles.\r\n     */\r\n    public minEmitPower = 1;\r\n    /**\r\n     * Maximum power of emitting particles.\r\n     */\r\n    public maxEmitPower = 1;\r\n\r\n    /**\r\n     * Minimum life time of emitting particles.\r\n     */\r\n    public minLifeTime = 1;\r\n    /**\r\n     * Maximum life time of emitting particles.\r\n     */\r\n    public maxLifeTime = 1;\r\n\r\n    /**\r\n     * Minimum Size of emitting particles.\r\n     */\r\n    public minSize = 1;\r\n    /**\r\n     * Maximum Size of emitting particles.\r\n     */\r\n    public maxSize = 1;\r\n\r\n    /**\r\n     * Minimum scale of emitting particles on X axis.\r\n     */\r\n    public minScaleX = 1;\r\n    /**\r\n     * Maximum scale of emitting particles on X axis.\r\n     */\r\n    public maxScaleX = 1;\r\n\r\n    /**\r\n     * Minimum scale of emitting particles on Y axis.\r\n     */\r\n    public minScaleY = 1;\r\n    /**\r\n     * Maximum scale of emitting particles on Y axis.\r\n     */\r\n    public maxScaleY = 1;\r\n\r\n    /**\r\n     * Gets or sets the minimal initial rotation in radians.\r\n     */\r\n    public minInitialRotation = 0;\r\n    /**\r\n     * Gets or sets the maximal initial rotation in radians.\r\n     */\r\n    public maxInitialRotation = 0;\r\n\r\n    /**\r\n     * Minimum angular speed of emitting particles (Z-axis rotation for each particle).\r\n     */\r\n    public minAngularSpeed = 0;\r\n    /**\r\n     * Maximum angular speed of emitting particles (Z-axis rotation for each particle).\r\n     */\r\n    public maxAngularSpeed = 0;\r\n\r\n    /**\r\n     * The texture used to render each particle. (this can be a spritesheet)\r\n     */\r\n    public particleTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * The layer mask we are rendering the particles through.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /**\r\n     * This can help using your own shader to render the particle system.\r\n     * The according effect will be created\r\n     */\r\n    public customShader: any = null;\r\n\r\n    /**\r\n     * By default particle system starts as soon as they are created. This prevents the\r\n     * automatic start to happen and let you decide when to start emitting particles.\r\n     */\r\n    public preventAutoStart: boolean = false;\r\n\r\n    /** @internal */\r\n    _wasDispatched = false;\r\n\r\n    protected _rootUrl = \"\";\r\n    private _noiseTexture: Nullable<ProceduralTexture>;\r\n\r\n    /**\r\n     * Gets or sets a texture used to add random noise to particle positions\r\n     */\r\n    public get noiseTexture(): Nullable<ProceduralTexture> {\r\n        return this._noiseTexture;\r\n    }\r\n\r\n    public set noiseTexture(value: Nullable<ProceduralTexture>) {\r\n        if (this._noiseTexture === value) {\r\n            return;\r\n        }\r\n\r\n        this._noiseTexture = value;\r\n        this._reset();\r\n    }\r\n\r\n    /** Gets or sets the strength to apply to the noise value (default is (10, 10, 10)) */\r\n    public noiseStrength = new Vector3(10, 10, 10);\r\n\r\n    /**\r\n     * Callback triggered when the particle animation is ending.\r\n     */\r\n    public onAnimationEnd: Nullable<() => void> = null;\r\n\r\n    /**\r\n     * Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.\r\n     */\r\n    public blendMode = BaseParticleSystem.BLENDMODE_ONEONE;\r\n\r\n    /**\r\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\r\n     * to override the particles.\r\n     */\r\n    public forceDepthWrite = false;\r\n\r\n    /** Gets or sets a value indicating how many cycles (or frames) must be executed before first rendering (this value has to be set before starting the system). Default is 0 */\r\n    public preWarmCycles = 0;\r\n\r\n    /** Gets or sets a value indicating the time step multiplier to use in pre-warm mode (default is 1) */\r\n    public preWarmStepOffset = 1;\r\n\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the speed of the sprite loop (default is 1 meaning the animation will play once during the entire particle lifetime)\r\n     */\r\n    public spriteCellChangeSpeed = 1;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the first sprite cell to display\r\n     */\r\n    public startSpriteCellID = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the last sprite cell to display\r\n     */\r\n    public endSpriteCellID = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use\r\n     */\r\n    public spriteCellWidth = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use\r\n     */\r\n    public spriteCellHeight = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines wether the sprite animation is looping\r\n     */\r\n    public spriteCellLoop = true;\r\n    /**\r\n     * This allows the system to random pick the start cell ID between startSpriteCellID and endSpriteCellID\r\n     */\r\n    public spriteRandomStartCell = false;\r\n\r\n    /** Gets or sets a Vector2 used to move the pivot (by default (0,0)) */\r\n    public translationPivot = new Vector2(0, 0);\r\n\r\n    /** @internal */\r\n    public _isAnimationSheetEnabled: boolean;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that hosted animations (in the system.animations array) must be started when system.start() is called\r\n     */\r\n    public beginAnimationOnStart = false;\r\n\r\n    /**\r\n     * Gets or sets the frame to start the animation from when beginAnimationOnStart is true\r\n     */\r\n    public beginAnimationFrom = 0;\r\n\r\n    /**\r\n     * Gets or sets the frame to end the animation on when beginAnimationOnStart is true\r\n     */\r\n    public beginAnimationTo = 60;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if animations must loop when beginAnimationOnStart is true\r\n     */\r\n    public beginAnimationLoop = false;\r\n\r\n    /**\r\n     * Gets or sets a world offset applied to all particles\r\n     */\r\n    public worldOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Gets or sets whether an animation sprite sheet is enabled or not on the particle system\r\n     */\r\n    public get isAnimationSheetEnabled(): boolean {\r\n        return this._isAnimationSheetEnabled;\r\n    }\r\n\r\n    public set isAnimationSheetEnabled(value: boolean) {\r\n        if (this._isAnimationSheetEnabled == value) {\r\n            return;\r\n        }\r\n\r\n        this._isAnimationSheetEnabled = value;\r\n\r\n        this._reset();\r\n    }\r\n\r\n    private _useLogarithmicDepth: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean enabling the use of logarithmic depth buffers, which is good for wide depth buffers.\r\n     */\r\n    public get useLogarithmicDepth(): boolean {\r\n        return this._useLogarithmicDepth;\r\n    }\r\n\r\n    public set useLogarithmicDepth(value: boolean) {\r\n        this._useLogarithmicDepth = value && this.getScene()!.getEngine().getCaps().fragmentDepthSupported;\r\n    }\r\n\r\n    /**\r\n     * Get hosting scene\r\n     * @returns the scene\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * You can use gravity if you want to give an orientation to your particles.\r\n     */\r\n    public gravity = Vector3.Zero();\r\n\r\n    protected _colorGradients: Nullable<Array<ColorGradient>> = null;\r\n    protected _sizeGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _lifeTimeGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _angularSpeedGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _velocityGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _limitVelocityGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _dragGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _emitRateGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _startSizeGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _rampGradients: Nullable<Array<Color3Gradient>> = null;\r\n    protected _colorRemapGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _alphaRemapGradients: Nullable<Array<FactorGradient>> = null;\r\n\r\n    protected _hasTargetStopDurationDependantGradient() {\r\n        return (\r\n            (this._startSizeGradients && this._startSizeGradients.length > 0) ||\r\n            (this._emitRateGradients && this._emitRateGradients.length > 0) ||\r\n            (this._lifeTimeGradients && this._lifeTimeGradients.length > 0)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Defines the delay in milliseconds before starting the system (0 by default)\r\n     */\r\n    public startDelay = 0;\r\n\r\n    /**\r\n     * Gets the current list of drag gradients.\r\n     * You must use addDragGradient and removeDragGradient to update this list\r\n     * @returns the list of drag gradients\r\n     */\r\n    public getDragGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._dragGradients;\r\n    }\r\n\r\n    /** Gets or sets a value indicating the damping to apply if the limit velocity factor is reached */\r\n    public limitVelocityDamping = 0.4;\r\n\r\n    /**\r\n     * Gets the current list of limit velocity gradients.\r\n     * You must use addLimitVelocityGradient and removeLimitVelocityGradient to update this list\r\n     * @returns the list of limit velocity gradients\r\n     */\r\n    public getLimitVelocityGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._limitVelocityGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of color gradients.\r\n     * You must use addColorGradient and removeColorGradient to update this list\r\n     * @returns the list of color gradients\r\n     */\r\n    public getColorGradients(): Nullable<Array<ColorGradient>> {\r\n        return this._colorGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of size gradients.\r\n     * You must use addSizeGradient and removeSizeGradient to update this list\r\n     * @returns the list of size gradients\r\n     */\r\n    public getSizeGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._sizeGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of color remap gradients.\r\n     * You must use addColorRemapGradient and removeColorRemapGradient to update this list\r\n     * @returns the list of color remap gradients\r\n     */\r\n    public getColorRemapGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._colorRemapGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of alpha remap gradients.\r\n     * You must use addAlphaRemapGradient and removeAlphaRemapGradient to update this list\r\n     * @returns the list of alpha remap gradients\r\n     */\r\n    public getAlphaRemapGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._alphaRemapGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of life time gradients.\r\n     * You must use addLifeTimeGradient and removeLifeTimeGradient to update this list\r\n     * @returns the list of life time gradients\r\n     */\r\n    public getLifeTimeGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._lifeTimeGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of angular speed gradients.\r\n     * You must use addAngularSpeedGradient and removeAngularSpeedGradient to update this list\r\n     * @returns the list of angular speed gradients\r\n     */\r\n    public getAngularSpeedGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._angularSpeedGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of velocity gradients.\r\n     * You must use addVelocityGradient and removeVelocityGradient to update this list\r\n     * @returns the list of velocity gradients\r\n     */\r\n    public getVelocityGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._velocityGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of start size gradients.\r\n     * You must use addStartSizeGradient and removeStartSizeGradient to update this list\r\n     * @returns the list of start size gradients\r\n     */\r\n    public getStartSizeGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._startSizeGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of emit rate gradients.\r\n     * You must use addEmitRateGradient and removeEmitRateGradient to update this list\r\n     * @returns the list of emit rate gradients\r\n     */\r\n    public getEmitRateGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._emitRateGradients;\r\n    }\r\n\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get direction1(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction1) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).direction1;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set direction1(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction1) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).direction1 = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get direction2(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction2) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).direction2;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set direction2(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction2) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).direction2 = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get minEmitBox(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).minEmitBox) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).minEmitBox;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set minEmitBox(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).minEmitBox) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).minEmitBox = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get maxEmitBox(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).maxEmitBox) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).maxEmitBox;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set maxEmitBox(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).maxEmitBox) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).maxEmitBox = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Random color of each particle after it has been emitted, between color1 and color2 vectors\r\n     */\r\n    public color1 = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * Random color of each particle after it has been emitted, between color1 and color2 vectors\r\n     */\r\n    public color2 = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * Color the particle will have at the end of its lifetime\r\n     */\r\n    public colorDead = new Color4(0, 0, 0, 1.0);\r\n\r\n    /**\r\n     * An optional mask to filter some colors out of the texture, or filter a part of the alpha channel\r\n     */\r\n    public textureMask = new Color4(1.0, 1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * The particle emitter type defines the emitter used by the particle system.\r\n     * It can be for example box, sphere, or cone...\r\n     */\r\n    public particleEmitterType: IParticleEmitterType;\r\n\r\n    /** @internal */\r\n    public _isSubEmitter = false;\r\n\r\n    /** @internal */\r\n    public _billboardMode = Constants.PARTICLES_BILLBOARDMODE_ALL;\r\n    /**\r\n     * Gets or sets the billboard mode to use when isBillboardBased = true.\r\n     * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED\r\n     */\r\n    public get billboardMode(): number {\r\n        return this._billboardMode;\r\n    }\r\n\r\n    public set billboardMode(value: number) {\r\n        if (this._billboardMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._billboardMode = value;\r\n        this._reset();\r\n    }\r\n\r\n    /** @internal */\r\n    public _isBillboardBased = true;\r\n    /**\r\n     * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction\r\n     */\r\n    public get isBillboardBased(): boolean {\r\n        return this._isBillboardBased;\r\n    }\r\n\r\n    public set isBillboardBased(value: boolean) {\r\n        if (this._isBillboardBased === value) {\r\n            return;\r\n        }\r\n\r\n        this._isBillboardBased = value;\r\n        this._reset();\r\n    }\r\n\r\n    /**\r\n     * The scene the particle system belongs to.\r\n     */\r\n    protected _scene: Nullable<Scene>;\r\n\r\n    /**\r\n     * The engine the particle system belongs to.\r\n     */\r\n    protected _engine: ThinEngine;\r\n\r\n    /**\r\n     * Local cache of defines for image processing.\r\n     */\r\n    protected _imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the standard Material.\r\n     */\r\n    protected _imageProcessingConfiguration: Nullable<ImageProcessingConfiguration>;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): Nullable<ImageProcessingConfiguration> {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: Nullable<ImageProcessingConfiguration>) {\r\n        this._attachImageProcessingConfiguration(value);\r\n    }\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration && this._scene) {\r\n            this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    protected _reset() {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _removeGradientAndTexture(gradient: number, gradients: Nullable<IValueGradient[]>, texture: Nullable<RawTexture>): BaseParticleSystem {\r\n        if (!gradients) {\r\n            return this;\r\n        }\r\n\r\n        let index = 0;\r\n        for (const valueGradient of gradients) {\r\n            if (valueGradient.gradient === gradient) {\r\n                gradients.splice(index, 1);\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        if (texture) {\r\n            texture.dispose();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a particle system.\r\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n     * @param name The name of the particle system\r\n     */\r\n    public constructor(name: string) {\r\n        this.id = name;\r\n        this.name = name;\r\n    }\r\n\r\n    /**\r\n     * Creates a Point Emitter for the particle system (emits directly from the emitter position)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @returns the emitter\r\n     */\r\n    public createPointEmitter(direction1: Vector3, direction2: Vector3): PointParticleEmitter {\r\n        const particleEmitter = new PointParticleEmitter();\r\n        particleEmitter.direction1 = direction1;\r\n        particleEmitter.direction2 = direction2;\r\n\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)\r\n     * @param radius The radius of the hemisphere to emit from\r\n     * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\r\n     * @returns the emitter\r\n     */\r\n    public createHemisphericEmitter(radius = 1, radiusRange = 1): HemisphericParticleEmitter {\r\n        const particleEmitter = new HemisphericParticleEmitter(radius, radiusRange);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Sphere Emitter for the particle system (emits along the sphere radius)\r\n     * @param radius The radius of the sphere to emit from\r\n     * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\r\n     * @returns the emitter\r\n     */\r\n    public createSphereEmitter(radius = 1, radiusRange = 1): SphereParticleEmitter {\r\n        const particleEmitter = new SphereParticleEmitter(radius, radiusRange);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)\r\n     * @param radius The radius of the sphere to emit from\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere\r\n     * @returns the emitter\r\n     */\r\n    public createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)): SphereDirectedParticleEmitter {\r\n        const particleEmitter = new SphereDirectedParticleEmitter(radius, direction1, direction2);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)\r\n     * @param radius The radius of the emission cylinder\r\n     * @param height The height of the emission cylinder\r\n     * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius\r\n     * @param directionRandomizer How much to randomize the particle direction [0-1]\r\n     * @returns the emitter\r\n     */\r\n    public createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0): CylinderParticleEmitter {\r\n        const particleEmitter = new CylinderParticleEmitter(radius, height, radiusRange, directionRandomizer);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)\r\n     * @param radius The radius of the cylinder to emit from\r\n     * @param height The height of the emission cylinder\r\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder\r\n     * @returns the emitter\r\n     */\r\n    public createDirectedCylinderEmitter(\r\n        radius = 1,\r\n        height = 1,\r\n        radiusRange = 1,\r\n        direction1 = new Vector3(0, 1.0, 0),\r\n        direction2 = new Vector3(0, 1.0, 0)\r\n    ): CylinderDirectedParticleEmitter {\r\n        const particleEmitter = new CylinderDirectedParticleEmitter(radius, height, radiusRange, direction1, direction2);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)\r\n     * @param radius The radius of the cone to emit from\r\n     * @param angle The base angle of the cone\r\n     * @returns the emitter\r\n     */\r\n    public createConeEmitter(radius = 1, angle = Math.PI / 4): ConeParticleEmitter {\r\n        const particleEmitter = new ConeParticleEmitter(radius, angle);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox\r\n     * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox\r\n     * @returns the emitter\r\n     */\r\n    public createBoxEmitter(direction1: Vector3, direction2: Vector3, minEmitBox: Vector3, maxEmitBox: Vector3): BoxParticleEmitter {\r\n        const particleEmitter = new BoxParticleEmitter();\r\n        this.particleEmitterType = particleEmitter;\r\n        this.direction1 = direction1;\r\n        this.direction2 = direction2;\r\n        this.minEmitBox = minEmitBox;\r\n        this.maxEmitBox = maxEmitBox;\r\n        return particleEmitter;\r\n    }\r\n}\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n\r\n/**\r\n * Block used to expand a Color3/4 into 4 outputs (one for each component)\r\n */\r\nexport class ColorSplitterBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ColorSplitterBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\r\n        this.registerInput(\"rgb \", NodeMaterialBlockConnectionPointTypes.Color3, true);\r\n\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this.inputsAreExclusive = true;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ColorSplitterBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba component (input)\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb component (input)\r\n     */\r\n    public get rgbIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb component (output)\r\n     */\r\n    public get rgbOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the r component (output)\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the g component (output)\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n    /**\r\n     * Gets the b component (output)\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n    /**\r\n     * Gets the a component (output)\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        if (name === \"rgb \") {\r\n            return \"rgbIn\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        if (name === \"rgb\") {\r\n            return \"rgbOut\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const input = this.rgba.isConnected ? this.rgba : this.rgbIn;\r\n\r\n        if (!input.isConnected) {\r\n            return;\r\n        }\r\n\r\n        const rgbOutput = this._outputs[0];\r\n        const rOutput = this._outputs[1];\r\n        const gOutput = this._outputs[2];\r\n        const bOutput = this._outputs[3];\r\n        const aOutput = this._outputs[4];\r\n\r\n        if (rgbOutput.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(rgbOutput, state) + ` = ${input.associatedVariableName}.rgb;\\r\\n`;\r\n        }\r\n        if (rOutput.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(rOutput, state) + ` = ${input.associatedVariableName}.r;\\r\\n`;\r\n        }\r\n        if (gOutput.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(gOutput, state) + ` = ${input.associatedVariableName}.g;\\r\\n`;\r\n        }\r\n        if (bOutput.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(bOutput, state) + ` = ${input.associatedVariableName}.b;\\r\\n`;\r\n        }\r\n        if (aOutput.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(aOutput, state) + ` = ${input.associatedVariableName}.a;\\r\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ColorSplitterBlock\", ColorSplitterBlock);\r\n", "import { Tools } from \"../../../Misc/tools\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { ISceneComponent } from \"../../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\nimport type { ProceduralTexture } from \"./proceduralTexture\";\r\n\r\ndeclare module \"../../../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of procedural textures added to the scene\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures\r\n         */\r\n        proceduralTextures: Array<ProceduralTexture>;\r\n    }\r\n}\r\n/**\r\n * Defines the Procedural Texture scene component responsible to manage any Procedural Texture\r\n * in a given scene.\r\n */\r\nexport class ProceduralTextureSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.proceduralTextures = new Array<ProceduralTexture>();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    private _beforeClear(): void {\r\n        if (this.scene.proceduralTexturesEnabled) {\r\n            Tools.StartPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n            for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {\r\n                const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];\r\n                if (proceduralTexture._shouldRender()) {\r\n                    proceduralTexture.render();\r\n                }\r\n            }\r\n            Tools.EndPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n        }\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"proceduralVertexShader\";\nconst shader = `attribute vec2 position;\rvarying vec2 vPosition;\rvarying vec2 vUV;\rconst vec2 madd=vec2(0.5,0.5);\r#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\nvPosition=position;\rvUV=position*madd+madd;\rgl_Position=vec4(position,0.0,1.0);\r#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const proceduralVertexShader = { name, shader };\n", "import { serialize } from \"../../../Misc/decorators\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { Matrix, Vector3, Vector2 } from \"../../../Maths/math.vector\";\r\nimport type { Color4, Color3 } from \"../../../Maths/math.color\";\r\nimport type { Engine } from \"../../../Engines/engine\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\nimport { Material } from \"../../../Materials/material\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent\";\r\n\r\nimport \"../../../Engines/Extensions/engine.renderTarget\";\r\nimport \"../../../Engines/Extensions/engine.renderTargetCube\";\r\nimport \"../../../Shaders/procedural.vertex\";\r\nimport type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { NodeMaterial } from \"../../Node/nodeMaterial\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { DrawWrapper } from \"../../drawWrapper\";\r\nimport type { RenderTargetWrapper } from \"../../../Engines/renderTargetWrapper\";\r\n\r\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\r\n * This is the base class of any Procedural texture and contains most of the shareable code.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures\r\n */\r\nexport class ProceduralTexture extends Texture {\r\n    /**\r\n     * Define if the texture is enabled or not (disabled texture will not render)\r\n     */\r\n    @serialize()\r\n    public isEnabled = true;\r\n\r\n    /**\r\n     * Define if the texture must be cleared before rendering (default is true)\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n\r\n    /**\r\n     * Callback called when the texture is generated\r\n     */\r\n    public onGenerated: () => void;\r\n\r\n    /**\r\n     * Event raised when the texture is generated\r\n     */\r\n    public onGeneratedObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Event raised before the texture is generated\r\n     */\r\n    public onBeforeGenerationObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /** @internal */\r\n    @serialize()\r\n    public _generateMipMaps: boolean;\r\n\r\n    private _drawWrapper: DrawWrapper;\r\n\r\n    /** @internal */\r\n    public _textures: { [key: string]: Texture } = {};\r\n\r\n    /** @internal */\r\n    protected _fallbackTexture: Nullable<Texture>;\r\n\r\n    @serialize()\r\n    private _size: TextureSize;\r\n    private _textureType: number;\r\n    private _currentRefreshId = -1;\r\n    private _frameId = -1;\r\n    private _refreshRate = 1;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _uniforms = new Array<string>();\r\n    private _samplers = new Array<string>();\r\n    private _fragment: any;\r\n\r\n    private _floats: { [key: string]: number } = {};\r\n    private _ints: { [key: string]: number } = {};\r\n    private _floatsArrays: { [key: string]: number[] } = {};\r\n    private _colors3: { [key: string]: Color3 } = {};\r\n    private _colors4: { [key: string]: Color4 } = {};\r\n    private _vectors2: { [key: string]: Vector2 } = {};\r\n    private _vectors3: { [key: string]: Vector3 } = {};\r\n    private _matrices: { [key: string]: Matrix } = {};\r\n\r\n    private _fallbackTextureUsed = false;\r\n    private _fullEngine: Engine;\r\n\r\n    private _cachedDefines: Nullable<string> = null;\r\n\r\n    private _contentUpdateId = -1;\r\n    private _contentData: Nullable<Promise<ArrayBufferView>>;\r\n\r\n    private _rtWrapper: Nullable<RenderTargetWrapper> = null;\r\n\r\n    /**\r\n     * Instantiates a new procedural texture.\r\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n     * This is the base class of any Procedural texture and contains most of the shareable code.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures\r\n     * @param name  Define the name of the texture\r\n     * @param size Define the size of the texture to create\r\n     * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n     * @param generateMipMaps Define if the texture should creates mip maps or not\r\n     * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\r\n     * @param textureType The FBO internal texture type\r\n     */\r\n    constructor(\r\n        name: string,\r\n        size: TextureSize,\r\n        fragment: any,\r\n        scene: Nullable<Scene>,\r\n        fallbackTexture: Nullable<Texture> = null,\r\n        generateMipMaps = true,\r\n        isCube = false,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ) {\r\n        super(null, scene, !generateMipMaps);\r\n\r\n        scene = this.getScene() || EngineStore.LastCreatedScene!;\r\n        let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\r\n        if (!component) {\r\n            component = new ProceduralTextureSceneComponent(scene);\r\n            scene._addComponent(component);\r\n        }\r\n        scene.proceduralTextures.push(this);\r\n\r\n        this._fullEngine = scene.getEngine();\r\n\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._size = size;\r\n        this._textureType = textureType;\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._drawWrapper = new DrawWrapper(this._fullEngine);\r\n\r\n        this.setFragment(fragment);\r\n\r\n        this._fallbackTexture = fallbackTexture;\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createRtWrapper(isCube: boolean, size: TextureSize, generateMipMaps: boolean, textureType: number) {\r\n        if (isCube) {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size as number, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n            });\r\n            this.setFloat(\"face\", 0);\r\n        } else {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n            });\r\n        }\r\n        return this._rtWrapper;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding the the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._drawWrapper.effect!;\r\n    }\r\n\r\n    /**\r\n     * @internal*\r\n     */\r\n    public _setEffect(effect: Effect) {\r\n        this._drawWrapper.effect = effect;\r\n    }\r\n\r\n    /**\r\n     * Gets texture content (Use this function wisely as reading from a texture can be slow)\r\n     * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\r\n     */\r\n    public getContent(): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._contentData && this._frameId === this._contentUpdateId) {\r\n            return this._contentData;\r\n        }\r\n\r\n        if (this._contentData) {\r\n            this._contentData.then((buffer) => {\r\n                this._contentData = this.readPixels(0, 0, buffer);\r\n                this._contentUpdateId = this._frameId;\r\n            });\r\n        } else {\r\n            this._contentData = this.readPixels(0, 0);\r\n            this._contentUpdateId = this._frameId;\r\n        }\r\n\r\n        return this._contentData;\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this._fullEngine;\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the texture in order to recreate its associated resources.\r\n     * This can be called in case of context loss\r\n     */\r\n    public reset(): void {\r\n        this._drawWrapper.effect?.dispose();\r\n    }\r\n\r\n    protected _getDefines(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Is the texture ready to be used ? (rendered at least once)\r\n     * @returns true if ready, otherwise, false.\r\n     */\r\n    public isReady(): boolean {\r\n        const engine = this._fullEngine;\r\n        let shaders;\r\n\r\n        if (this.nodeMaterialSource) {\r\n            return this._drawWrapper.effect!.isReady();\r\n        }\r\n\r\n        if (!this._fragment) {\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        const defines = this._getDefines();\r\n        if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\r\n            return true;\r\n        }\r\n\r\n        if (this._fragment.fragmentElement !== undefined) {\r\n            shaders = { vertex: \"procedural\", fragmentElement: this._fragment.fragmentElement };\r\n        } else {\r\n            shaders = { vertex: \"procedural\", fragment: this._fragment };\r\n        }\r\n\r\n        if (this._cachedDefines !== defines) {\r\n            this._cachedDefines = defines;\r\n\r\n            this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, undefined, undefined, () => {\r\n                this._rtWrapper?.dispose();\r\n                this._rtWrapper = this._texture = null;\r\n\r\n                if (this._fallbackTexture) {\r\n                    this._texture = this._fallbackTexture._texture;\r\n\r\n                    if (this._texture) {\r\n                        this._texture.incrementReferences();\r\n                    }\r\n                }\r\n\r\n                this._fallbackTextureUsed = true;\r\n            });\r\n        }\r\n\r\n        return this._drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Set the fragment shader to use in order to render the texture.\r\n     * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\r\n     */\r\n    public setFragment(fragment: any) {\r\n        this._fragment = fragment;\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    @serialize()\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /** @internal */\r\n    public _shouldRender(): boolean {\r\n        if (!this.isEnabled || !this.isReady() || !this._texture) {\r\n            if (this._texture) {\r\n                this._texture.isReady = false;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return false;\r\n        }\r\n\r\n        if (this._currentRefreshId === -1) {\r\n            // At least render once\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the size the texture is rendering at.\r\n     * @returns the size (on cube texture it is always squared)\r\n     */\r\n    public getRenderSize(): TextureSize {\r\n        return this._size;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to new value.\r\n     * @param size Define the new size the texture should have\r\n     * @param generateMipMaps Define whether the new texture should create mip maps\r\n     */\r\n    public resize(size: TextureSize, generateMipMaps: boolean): void {\r\n        if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\r\n            return;\r\n        }\r\n\r\n        const isCube = this._texture.isCube;\r\n        this._rtWrapper.dispose();\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // Update properties\r\n        this._size = size;\r\n        this._generateMipMaps = generateMipMaps;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._uniforms.indexOf(uniformName) === -1) {\r\n            this._uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader program used to render.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: Texture): ProceduralTexture {\r\n        if (this._samplers.indexOf(name) === -1) {\r\n            this._samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a MAtrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Render the texture to its associated render target.\r\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public render(useCameraPostProcess?: boolean): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._fullEngine;\r\n\r\n        // Render\r\n        engine.enableEffect(this._drawWrapper);\r\n        this.onBeforeGenerationObservable.notifyObservers(this);\r\n        engine.setState(false);\r\n\r\n        if (!this.nodeMaterialSource) {\r\n            // Texture\r\n            for (const name in this._textures) {\r\n                this._drawWrapper.effect!.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._ints) {\r\n                this._drawWrapper.effect!.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._floats) {\r\n                this._drawWrapper.effect!.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (const name in this._floatsArrays) {\r\n                this._drawWrapper.effect!.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (const name in this._colors3) {\r\n                this._drawWrapper.effect!.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (const name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                this._drawWrapper.effect!.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Vector2\r\n            for (const name in this._vectors2) {\r\n                this._drawWrapper.effect!.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (const name in this._vectors3) {\r\n                this._drawWrapper.effect!.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (const name in this._matrices) {\r\n                this._drawWrapper.effect!.setMatrix(name, this._matrices[name]);\r\n            }\r\n        }\r\n\r\n        if (!this._texture || !this._rtWrapper) {\r\n            return;\r\n        }\r\n\r\n        engine._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);\r\n\r\n        const viewPort = engine.currentViewport;\r\n        if (this.isCube) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n                this._drawWrapper.effect!.setFloat(\"face\", face);\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n            }\r\n        } else {\r\n            engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true);\r\n\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n            // Clear\r\n            if (this.autoClear) {\r\n                engine.clear(scene.clearColor, true, false, false);\r\n            }\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        // Unbind and restore viewport\r\n        engine.unBindFramebuffer(this._rtWrapper, this.isCube);\r\n        if (viewPort) {\r\n            engine.setViewport(viewPort);\r\n        }\r\n\r\n        // Mipmaps\r\n        if (this.isCube) {\r\n            engine.generateMipMapsForCubemap(this._texture);\r\n        }\r\n\r\n        engine._debugPopGroup?.(1);\r\n\r\n        if (this.onGenerated) {\r\n            this.onGenerated();\r\n        }\r\n\r\n        this.onGeneratedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Clone the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): ProceduralTexture {\r\n        const textureSize = this.getSize();\r\n        const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, <Scene>this.getScene(), this._fallbackTexture, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const index = scene.proceduralTextures.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.proceduralTextures.splice(index, 1);\r\n        }\r\n\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        this.onGeneratedObservable.clear();\r\n        this.onBeforeGenerationObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\n\r\n/**\r\n * Operations supported by the Trigonometry block\r\n */\r\nexport enum TrigonometryBlockOperations {\r\n    /** Cos */\r\n    Cos,\r\n    /** Sin */\r\n    Sin,\r\n    /** Abs */\r\n    Abs,\r\n    /** Exp */\r\n    Exp,\r\n    /** Exp2 */\r\n    Exp2,\r\n    /** Round */\r\n    Round,\r\n    /** Floor */\r\n    Floor,\r\n    /** Ceiling */\r\n    Ceiling,\r\n    /** Square root */\r\n    Sqrt,\r\n    /** Log */\r\n    Log,\r\n    /** Tangent */\r\n    Tan,\r\n    /** Arc tangent */\r\n    ArcTan,\r\n    /** Arc cosinus */\r\n    ArcCos,\r\n    /** Arc sinus */\r\n    ArcSin,\r\n    /** Fraction */\r\n    Fract,\r\n    /** Sign */\r\n    Sign,\r\n    /** To radians (from degrees) */\r\n    Radians,\r\n    /** To degrees (from radians) */\r\n    Degrees,\r\n}\r\n\r\n/**\r\n * Block used to apply trigonometry operation to floats\r\n */\r\nexport class TrigonometryBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the operation applied by the block\r\n     */\r\n    public operation = TrigonometryBlockOperations.Cos;\r\n\r\n    /**\r\n     * Creates a new TrigonometryBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TrigonometryBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        let operation = \"\";\r\n\r\n        switch (this.operation) {\r\n            case TrigonometryBlockOperations.Cos: {\r\n                operation = \"cos\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Sin: {\r\n                operation = \"sin\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Abs: {\r\n                operation = \"abs\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Exp: {\r\n                operation = \"exp\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Exp2: {\r\n                operation = \"exp2\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Round: {\r\n                operation = \"round\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Floor: {\r\n                operation = \"floor\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Ceiling: {\r\n                operation = \"ceil\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Sqrt: {\r\n                operation = \"sqrt\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Log: {\r\n                operation = \"log\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Tan: {\r\n                operation = \"tan\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.ArcTan: {\r\n                operation = \"atan\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.ArcCos: {\r\n                operation = \"acos\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.ArcSin: {\r\n                operation = \"asin\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Fract: {\r\n                operation = \"fract\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Sign: {\r\n                operation = \"sign\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Radians: {\r\n                operation = \"radians\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Degrees: {\r\n                operation = \"degrees\";\r\n                break;\r\n            }\r\n        }\r\n\r\n        state.compilationString += this._declareOutput(output, state) + ` = ${operation}(${this.input.associatedVariableName});\\r\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.operation = this.operation;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.operation = serializationObject.operation;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString =\r\n            super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.TrigonometryBlockOperations.${TrigonometryBlockOperations[this.operation]};\\r\\n`;\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TrigonometryBlock\", TrigonometryBlock);\r\n", "import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialBuildStateSharedData } from \"./nodeMaterialBuildStateSharedData\";\r\nimport { Effect } from \"../effect\";\r\n\r\n/**\r\n * Class used to store node based material build state\r\n */\r\nexport class NodeMaterialBuildState {\r\n    /** Gets or sets a boolean indicating if the current state can emit uniform buffers */\r\n    public supportUniformBuffers = false;\r\n    /**\r\n     * Gets the list of emitted attributes\r\n     */\r\n    public attributes = new Array<string>();\r\n    /**\r\n     * Gets the list of emitted uniforms\r\n     */\r\n    public uniforms = new Array<string>();\r\n    /**\r\n     * Gets the list of emitted constants\r\n     */\r\n    public constants = new Array<string>();\r\n    /**\r\n     * Gets the list of emitted samplers\r\n     */\r\n    public samplers = new Array<string>();\r\n    /**\r\n     * Gets the list of emitted functions\r\n     */\r\n    public functions: { [key: string]: string } = {};\r\n    /**\r\n     * Gets the list of emitted extensions\r\n     */\r\n    public extensions: { [key: string]: string } = {};\r\n\r\n    /**\r\n     * Gets the target of the compilation state\r\n     */\r\n    public target: NodeMaterialBlockTargets;\r\n    /**\r\n     * Gets the list of emitted counters\r\n     */\r\n    public counters: { [key: string]: number } = {};\r\n\r\n    /**\r\n     * Shared data between multiple NodeMaterialBuildState instances\r\n     */\r\n    public sharedData: NodeMaterialBuildStateSharedData;\r\n\r\n    /** @internal */\r\n    public _vertexState: NodeMaterialBuildState;\r\n\r\n    /** @internal */\r\n    public _attributeDeclaration = \"\";\r\n    /** @internal */\r\n    public _uniformDeclaration = \"\";\r\n    /** @internal */\r\n    public _constantDeclaration = \"\";\r\n    /** @internal */\r\n    public _samplerDeclaration = \"\";\r\n    /** @internal */\r\n    public _varyingTransfer = \"\";\r\n    /** @internal */\r\n    public _injectAtEnd = \"\";\r\n\r\n    private _repeatableContentAnchorIndex = 0;\r\n    /** @internal */\r\n    public _builtCompilationString = \"\";\r\n\r\n    /**\r\n     * Gets the emitted compilation strings\r\n     */\r\n    public compilationString = \"\";\r\n\r\n    /**\r\n     * Finalize the compilation strings\r\n     * @param state defines the current compilation state\r\n     */\r\n    public finalize(state: NodeMaterialBuildState) {\r\n        const emitComments = state.sharedData.emitComments;\r\n        const isFragmentMode = this.target === NodeMaterialBlockTargets.Fragment;\r\n\r\n        this.compilationString = `\\r\\n${emitComments ? \"//Entry point\\r\\n\" : \"\"}void main(void) {\\r\\n${this.compilationString}`;\r\n\r\n        if (this._constantDeclaration) {\r\n            this.compilationString = `\\r\\n${emitComments ? \"//Constants\\r\\n\" : \"\"}${this._constantDeclaration}\\r\\n${this.compilationString}`;\r\n        }\r\n\r\n        let functionCode = \"\";\r\n        for (const functionName in this.functions) {\r\n            functionCode += this.functions[functionName] + `\\r\\n`;\r\n        }\r\n        this.compilationString = `\\r\\n${functionCode}\\r\\n${this.compilationString}`;\r\n\r\n        if (!isFragmentMode && this._varyingTransfer) {\r\n            this.compilationString = `${this.compilationString}\\r\\n${this._varyingTransfer}`;\r\n        }\r\n\r\n        if (this._injectAtEnd) {\r\n            this.compilationString = `${this.compilationString}\\r\\n${this._injectAtEnd}`;\r\n        }\r\n\r\n        this.compilationString = `${this.compilationString}\\r\\n}`;\r\n\r\n        if (this.sharedData.varyingDeclaration) {\r\n            this.compilationString = `\\r\\n${emitComments ? \"//Varyings\\r\\n\" : \"\"}${this.sharedData.varyingDeclaration}\\r\\n${this.compilationString}`;\r\n        }\r\n\r\n        if (this._samplerDeclaration) {\r\n            this.compilationString = `\\r\\n${emitComments ? \"//Samplers\\r\\n\" : \"\"}${this._samplerDeclaration}\\r\\n${this.compilationString}`;\r\n        }\r\n\r\n        if (this._uniformDeclaration) {\r\n            this.compilationString = `\\r\\n${emitComments ? \"//Uniforms\\r\\n\" : \"\"}${this._uniformDeclaration}\\r\\n${this.compilationString}`;\r\n        }\r\n\r\n        if (this._attributeDeclaration && !isFragmentMode) {\r\n            this.compilationString = `\\r\\n${emitComments ? \"//Attributes\\r\\n\" : \"\"}${this._attributeDeclaration}\\r\\n${this.compilationString}`;\r\n        }\r\n\r\n        this.compilationString = \"precision highp float;\\r\\n\" + this.compilationString;\r\n\r\n        for (const extensionName in this.extensions) {\r\n            const extension = this.extensions[extensionName];\r\n            this.compilationString = `\\r\\n${extension}\\r\\n${this.compilationString}`;\r\n        }\r\n\r\n        this._builtCompilationString = this.compilationString;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _repeatableContentAnchor(): string {\r\n        return `###___ANCHOR${this._repeatableContentAnchorIndex++}___###`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFreeVariableName(prefix: string): string {\r\n        prefix = prefix.replace(/[^a-zA-Z_]+/g, \"\");\r\n\r\n        if (this.sharedData.variableNames[prefix] === undefined) {\r\n            this.sharedData.variableNames[prefix] = 0;\r\n\r\n            // Check reserved words\r\n            if (prefix === \"output\" || prefix === \"texture\") {\r\n                return prefix + this.sharedData.variableNames[prefix];\r\n            }\r\n\r\n            return prefix;\r\n        } else {\r\n            this.sharedData.variableNames[prefix]++;\r\n        }\r\n\r\n        return prefix + this.sharedData.variableNames[prefix];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFreeDefineName(prefix: string): string {\r\n        if (this.sharedData.defineNames[prefix] === undefined) {\r\n            this.sharedData.defineNames[prefix] = 0;\r\n        } else {\r\n            this.sharedData.defineNames[prefix]++;\r\n        }\r\n\r\n        return prefix + this.sharedData.defineNames[prefix];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _excludeVariableName(name: string) {\r\n        this.sharedData.variableNames[name] = 0;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emit2DSampler(name: string) {\r\n        if (this.samplers.indexOf(name) < 0) {\r\n            this._samplerDeclaration += `uniform sampler2D ${name};\\r\\n`;\r\n            this.samplers.push(name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getGLType(type: NodeMaterialBlockConnectionPointTypes): string {\r\n        switch (type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                return \"float\";\r\n            case NodeMaterialBlockConnectionPointTypes.Int:\r\n                return \"int\";\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                return \"vec2\";\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                return \"vec3\";\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                return \"vec4\";\r\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                return \"mat4\";\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitExtension(name: string, extension: string, define: string = \"\") {\r\n        if (this.extensions[name]) {\r\n            return;\r\n        }\r\n\r\n        if (define) {\r\n            extension = `#if ${define}\\r\\n${extension}\\r\\n#endif`;\r\n        }\r\n        this.extensions[name] = extension;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitFunction(name: string, code: string, comments: string) {\r\n        if (this.functions[name]) {\r\n            return;\r\n        }\r\n\r\n        if (this.sharedData.emitComments) {\r\n            code = comments + `\\r\\n` + code;\r\n        }\r\n\r\n        this.functions[name] = code;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitCodeFromInclude(\r\n        includeName: string,\r\n        comments: string,\r\n        options?: {\r\n            replaceStrings?: { search: RegExp; replace: string }[];\r\n            repeatKey?: string;\r\n        }\r\n    ) {\r\n        if (options && options.repeatKey) {\r\n            return `#include<${includeName}>[0..${options.repeatKey}]\\r\\n`;\r\n        }\r\n\r\n        let code = Effect.IncludesShadersStore[includeName] + \"\\r\\n\";\r\n\r\n        if (this.sharedData.emitComments) {\r\n            code = comments + `\\r\\n` + code;\r\n        }\r\n\r\n        if (!options) {\r\n            return code;\r\n        }\r\n\r\n        if (options.replaceStrings) {\r\n            for (let index = 0; index < options.replaceStrings.length; index++) {\r\n                const replaceString = options.replaceStrings[index];\r\n                code = code.replace(replaceString.search, replaceString.replace);\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitFunctionFromInclude(\r\n        includeName: string,\r\n        comments: string,\r\n        options?: {\r\n            repeatKey?: string;\r\n            removeAttributes?: boolean;\r\n            removeUniforms?: boolean;\r\n            removeVaryings?: boolean;\r\n            removeIfDef?: boolean;\r\n            replaceStrings?: { search: RegExp; replace: string }[];\r\n        },\r\n        storeKey: string = \"\"\r\n    ) {\r\n        const key = includeName + storeKey;\r\n        if (this.functions[key]) {\r\n            return;\r\n        }\r\n\r\n        if (!options || (!options.removeAttributes && !options.removeUniforms && !options.removeVaryings && !options.removeIfDef && !options.replaceStrings)) {\r\n            if (options && options.repeatKey) {\r\n                this.functions[key] = `#include<${includeName}>[0..${options.repeatKey}]\\r\\n`;\r\n            } else {\r\n                this.functions[key] = `#include<${includeName}>\\r\\n`;\r\n            }\r\n\r\n            if (this.sharedData.emitComments) {\r\n                this.functions[key] = comments + `\\r\\n` + this.functions[key];\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        this.functions[key] = Effect.IncludesShadersStore[includeName];\r\n\r\n        if (this.sharedData.emitComments) {\r\n            this.functions[key] = comments + `\\r\\n` + this.functions[key];\r\n        }\r\n\r\n        if (options.removeIfDef) {\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#ifdef.+$/gm, \"\");\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#endif.*$/gm, \"\");\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#else.*$/gm, \"\");\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#elif.*$/gm, \"\");\r\n        }\r\n\r\n        if (options.removeAttributes) {\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?attribute.+$/gm, \"\");\r\n        }\r\n\r\n        if (options.removeUniforms) {\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?uniform.+$/gm, \"\");\r\n        }\r\n\r\n        if (options.removeVaryings) {\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?varying.+$/gm, \"\");\r\n        }\r\n\r\n        if (options.replaceStrings) {\r\n            for (let index = 0; index < options.replaceStrings.length; index++) {\r\n                const replaceString = options.replaceStrings[index];\r\n                this.functions[key] = this.functions[key].replace(replaceString.search, replaceString.replace);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _registerTempVariable(name: string) {\r\n        if (this.sharedData.temps.indexOf(name) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        this.sharedData.temps.push(name);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitVaryingFromString(name: string, type: string, define: string = \"\", notDefine = false) {\r\n        if (this.sharedData.varyings.indexOf(name) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        this.sharedData.varyings.push(name);\r\n\r\n        if (define) {\r\n            if (define.startsWith(\"defined(\")) {\r\n                this.sharedData.varyingDeclaration += `#if ${define}\\r\\n`;\r\n            } else {\r\n                this.sharedData.varyingDeclaration += `${notDefine ? \"#ifndef\" : \"#ifdef\"} ${define}\\r\\n`;\r\n            }\r\n        }\r\n        this.sharedData.varyingDeclaration += `varying ${type} ${name};\\r\\n`;\r\n        if (define) {\r\n            this.sharedData.varyingDeclaration += `#endif\\r\\n`;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitUniformFromString(name: string, type: string, define: string = \"\", notDefine = false) {\r\n        if (this.uniforms.indexOf(name) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this.uniforms.push(name);\r\n\r\n        if (define) {\r\n            if (define.startsWith(\"defined(\")) {\r\n                this._uniformDeclaration += `#if ${define}\\r\\n`;\r\n            } else {\r\n                this._uniformDeclaration += `${notDefine ? \"#ifndef\" : \"#ifdef\"} ${define}\\r\\n`;\r\n            }\r\n        }\r\n        this._uniformDeclaration += `uniform ${type} ${name};\\r\\n`;\r\n        if (define) {\r\n            this._uniformDeclaration += `#endif\\r\\n`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitFloat(value: number) {\r\n        if (value.toString() === value.toFixed(0)) {\r\n            return `${value}.0`;\r\n        }\r\n\r\n        return value.toString();\r\n    }\r\n}\r\n", "import type { NodeMaterialConnectionPoint } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport type { TextureBlock } from \"./Blocks/Dual/textureBlock\";\r\nimport type { ReflectionTextureBaseBlock } from \"./Blocks/Dual/reflectionTextureBaseBlock\";\r\nimport type { RefractionBlock } from \"./Blocks/PBR/refractionBlock\";\r\nimport type { CurrentScreenBlock } from \"./Blocks/Dual/currentScreenBlock\";\r\nimport type { ParticleTextureBlock } from \"./Blocks/Particle/particleTextureBlock\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ImageSourceBlock } from \"./Blocks/Dual/imageSourceBlock\";\r\nimport type { Immutable } from \"../../types\";\r\n\r\n/**\r\n * Class used to store shared data between 2 NodeMaterialBuildState\r\n */\r\nexport class NodeMaterialBuildStateSharedData {\r\n    /**\r\n     * Gets the list of emitted varyings\r\n     */\r\n    public temps = new Array<string>();\r\n\r\n    /**\r\n     * Gets the list of emitted varyings\r\n     */\r\n    public varyings = new Array<string>();\r\n\r\n    /**\r\n     * Gets the varying declaration string\r\n     */\r\n    public varyingDeclaration = \"\";\r\n\r\n    /**\r\n     * List of the fragment output nodes\r\n     */\r\n    public fragmentOutputNodes: Immutable<Array<NodeMaterialBlock>>;\r\n\r\n    /**\r\n     * Input blocks\r\n     */\r\n    public inputBlocks = new Array<InputBlock>();\r\n\r\n    /**\r\n     * Input blocks\r\n     */\r\n    public textureBlocks = new Array<TextureBlock | ReflectionTextureBaseBlock | RefractionBlock | CurrentScreenBlock | ParticleTextureBlock | ImageSourceBlock>();\r\n\r\n    /**\r\n     * Bindable blocks (Blocks that need to set data to the effect)\r\n     */\r\n    public bindableBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Bindable blocks (Blocks that need to set data to the effect) that will always be called (by bindForSubMesh), contrary to bindableBlocks that won't be called if _mustRebind() returns false\r\n     */\r\n    public forcedBindableBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can provide a compilation fallback\r\n     */\r\n    public blocksWithFallbacks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can provide a define update\r\n     */\r\n    public blocksWithDefines = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can provide a repeatable content\r\n     */\r\n    public repeatableContentBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can provide a dynamic list of uniforms\r\n     */\r\n    public dynamicUniformBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can block the isReady function for the material\r\n     */\r\n    public blockingBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Gets the list of animated inputs\r\n     */\r\n    public animatedInputs = new Array<InputBlock>();\r\n\r\n    /**\r\n     * Build Id used to avoid multiple recompilations\r\n     */\r\n    public buildId: number;\r\n\r\n    /** List of emitted variables */\r\n    public variableNames: { [key: string]: number } = {};\r\n\r\n    /** List of emitted defines */\r\n    public defineNames: { [key: string]: number } = {};\r\n\r\n    /** Should emit comments? */\r\n    public emitComments: boolean;\r\n\r\n    /** Emit build activity */\r\n    public verbose: boolean;\r\n\r\n    /** Gets or sets the hosting scene */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Gets the compilation hints emitted at compilation time\r\n     */\r\n    public hints = {\r\n        needWorldViewMatrix: false,\r\n        needWorldViewProjectionMatrix: false,\r\n        needAlphaBlending: false,\r\n        needAlphaTesting: false,\r\n    };\r\n\r\n    /**\r\n     * List of compilation checks\r\n     */\r\n    public checks = {\r\n        emitVertex: false,\r\n        emitFragment: false,\r\n        notConnectedNonOptionalInputs: new Array<NodeMaterialConnectionPoint>(),\r\n    };\r\n\r\n    /**\r\n     * Is vertex program allowed to be empty?\r\n     */\r\n    public allowEmptyVertexProgram: boolean = false;\r\n\r\n    /** Creates a new shared data */\r\n    public constructor() {\r\n        // Exclude usual attributes from free variable names\r\n        this.variableNames[\"position\"] = 0;\r\n        this.variableNames[\"normal\"] = 0;\r\n        this.variableNames[\"tangent\"] = 0;\r\n        this.variableNames[\"uv\"] = 0;\r\n        this.variableNames[\"uv2\"] = 0;\r\n        this.variableNames[\"uv3\"] = 0;\r\n        this.variableNames[\"uv4\"] = 0;\r\n        this.variableNames[\"uv5\"] = 0;\r\n        this.variableNames[\"uv6\"] = 0;\r\n        this.variableNames[\"color\"] = 0;\r\n        this.variableNames[\"matricesIndices\"] = 0;\r\n        this.variableNames[\"matricesWeights\"] = 0;\r\n        this.variableNames[\"matricesIndicesExtra\"] = 0;\r\n        this.variableNames[\"matricesWeightsExtra\"] = 0;\r\n        this.variableNames[\"diffuseBase\"] = 0;\r\n        this.variableNames[\"specularBase\"] = 0;\r\n        this.variableNames[\"worldPos\"] = 0;\r\n        this.variableNames[\"shadow\"] = 0;\r\n        this.variableNames[\"view\"] = 0;\r\n\r\n        // Exclude known varyings\r\n        this.variableNames[\"vTBN\"] = 0;\r\n\r\n        // Exclude defines\r\n        this.defineNames[\"MAINUV0\"] = 0;\r\n        this.defineNames[\"MAINUV1\"] = 0;\r\n        this.defineNames[\"MAINUV2\"] = 0;\r\n        this.defineNames[\"MAINUV3\"] = 0;\r\n        this.defineNames[\"MAINUV4\"] = 0;\r\n        this.defineNames[\"MAINUV5\"] = 0;\r\n        this.defineNames[\"MAINUV6\"] = 0;\r\n        this.defineNames[\"MAINUV7\"] = 0;\r\n    }\r\n\r\n    /**\r\n     * Emits console errors and exceptions if there is a failing check\r\n     */\r\n    public emitErrors() {\r\n        let errorMessage = \"\";\r\n\r\n        if (!this.checks.emitVertex && !this.allowEmptyVertexProgram) {\r\n            errorMessage += \"NodeMaterial does not have a vertex output. You need to at least add a block that generates a glPosition value.\\r\\n\";\r\n        }\r\n        if (!this.checks.emitFragment) {\r\n            errorMessage += \"NodeMaterial does not have a fragment output. You need to at least add a block that generates a glFragColor value.\\r\\n\";\r\n        }\r\n        for (const notConnectedInput of this.checks.notConnectedNonOptionalInputs) {\r\n            errorMessage += `input ${notConnectedInput.name} from block ${\r\n                notConnectedInput.ownerBlock.name\r\n            }[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.\\r\\n`;\r\n        }\r\n\r\n        if (errorMessage) {\r\n            throw \"Build of NodeMaterial failed:\\r\\n\" + errorMessage;\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\nimport { PushMaterial } from \"../pushMaterial\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { ScenePerformancePriority } from \"../../scene\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Matrix, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { NodeMaterialBuildState } from \"./nodeMaterialBuildState\";\r\nimport type { IEffectCreationOptions } from \"../effect\";\r\nimport { Effect } from \"../effect\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialBuildStateSharedData } from \"./nodeMaterialBuildStateSharedData\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport type { NodeMaterialOptimizer } from \"./Optimizers/nodeMaterialOptimizer\";\r\nimport type { ImageProcessingConfiguration, IImageProcessingConfigurationDefines } from \"../imageProcessingConfiguration\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { TransformBlock } from \"./Blocks/transformBlock\";\r\nimport { VertexOutputBlock } from \"./Blocks/Vertex/vertexOutputBlock\";\r\nimport { FragmentOutputBlock } from \"./Blocks/Fragment/fragmentOutputBlock\";\r\nimport { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport { serialize, SerializationHelper } from \"../../Misc/decorators\";\r\nimport type { TextureBlock } from \"./Blocks/Dual/textureBlock\";\r\nimport type { ReflectionTextureBaseBlock } from \"./Blocks/Dual/reflectionTextureBaseBlock\";\r\nimport type { RefractionBlock } from \"./Blocks/PBR/refractionBlock\";\r\nimport { CurrentScreenBlock } from \"./Blocks/Dual/currentScreenBlock\";\r\nimport { ParticleTextureBlock } from \"./Blocks/Particle/particleTextureBlock\";\r\nimport { ParticleRampGradientBlock } from \"./Blocks/Particle/particleRampGradientBlock\";\r\nimport { ParticleBlendMultiplyBlock } from \"./Blocks/Particle/particleBlendMultiplyBlock\";\r\nimport { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { WebRequest } from \"../../Misc/webRequest\";\r\n\r\nimport type { PostProcessOptions } from \"../../PostProcesses/postProcess\";\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { VectorMergerBlock } from \"./Blocks/vectorMergerBlock\";\r\nimport { RemapBlock } from \"./Blocks/remapBlock\";\r\nimport { MultiplyBlock } from \"./Blocks/multiplyBlock\";\r\nimport { NodeMaterialModes } from \"./Enums/nodeMaterialModes\";\r\nimport { Texture } from \"../Textures/texture\";\r\nimport type { IParticleSystem } from \"../../Particles/IParticleSystem\";\r\nimport { BaseParticleSystem } from \"../../Particles/baseParticleSystem\";\r\nimport { ColorSplitterBlock } from \"./Blocks/colorSplitterBlock\";\r\nimport { TimingTools } from \"../../Misc/timingTools\";\r\nimport { ProceduralTexture } from \"../Textures/Procedurals/proceduralTexture\";\r\nimport { AnimatedInputBlockTypes } from \"./Blocks/Input/animatedInputBlockTypes\";\r\nimport { TrigonometryBlock, TrigonometryBlockOperations } from \"./Blocks/trigonometryBlock\";\r\nimport { NodeMaterialSystemValues } from \"./Enums/nodeMaterialSystemValues\";\r\nimport type { ImageSourceBlock } from \"./Blocks/Dual/imageSourceBlock\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { Material } from \"../material\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n// declare NODEEDITOR namespace for compilation issue\r\ndeclare let NODEEDITOR: any;\r\ndeclare let BABYLON: any;\r\n\r\n/**\r\n * Interface used to configure the node material editor\r\n */\r\nexport interface INodeMaterialEditorOptions {\r\n    /** Define the URl to load node editor script */\r\n    editorURL?: string;\r\n}\r\n\r\n/** @internal */\r\nexport class NodeMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    public NORMAL = false;\r\n    public TANGENT = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public UV3 = false;\r\n    public UV4 = false;\r\n    public UV5 = false;\r\n    public UV6 = false;\r\n\r\n    /** BONES */\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public BONETEXTURE = false;\r\n\r\n    /** MORPH TARGETS */\r\n    public MORPHTARGETS = false;\r\n    public MORPHTARGETS_NORMAL = false;\r\n    public MORPHTARGETS_TANGENT = false;\r\n    public MORPHTARGETS_UV = false;\r\n    public NUM_MORPH_INFLUENCERS = 0;\r\n    public MORPHTARGETS_TEXTURE = false;\r\n\r\n    /** IMAGE PROCESSING */\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = false;\r\n    public TONEMAPPING_ACES = false;\r\n    public CONTRAST = false;\r\n    public EXPOSURE = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public DITHER = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    /** MISC. */\r\n    public BUMPDIRECTUV = 0;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n\r\n    public setValue(name: string, value: any, markAsUnprocessedIfDirty = false) {\r\n        if (this[name] === undefined) {\r\n            this._keys.push(name);\r\n        }\r\n\r\n        if (markAsUnprocessedIfDirty && this[name] !== value) {\r\n            this.markAsUnprocessed();\r\n        }\r\n\r\n        this[name] = value;\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to configure NodeMaterial\r\n */\r\nexport interface INodeMaterialOptions {\r\n    /**\r\n     * Defines if blocks should emit comments\r\n     */\r\n    emitComments: boolean;\r\n}\r\n\r\n/**\r\n * Class used to create a node based material built by assembling shader blocks\r\n */\r\nexport class NodeMaterial extends PushMaterial {\r\n    private static _BuildIdGenerator: number = 0;\r\n    private _options: INodeMaterialOptions;\r\n    private _vertexCompilationState: NodeMaterialBuildState;\r\n    private _fragmentCompilationState: NodeMaterialBuildState;\r\n    private _sharedData: NodeMaterialBuildStateSharedData;\r\n    private _buildId: number = NodeMaterial._BuildIdGenerator++;\r\n    private _buildWasSuccessful = false;\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _optimizers = new Array<NodeMaterialOptimizer>();\r\n    private _animationFrame = -1;\r\n\r\n    /** Define the Url to load node editor script */\r\n    public static EditorURL = `https://unpkg.com/babylonjs-node-editor@${Engine.Version}/babylon.nodeEditor.js`;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Gets or sets a boolean indicating that node materials should not deserialize textures from json / snippet content */\r\n    public static IgnoreTexturesAtLoadTime = false;\r\n\r\n    private BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor();\r\n\r\n    /** Get the inspector from bundle or global */\r\n    private _getGlobalNodeMaterialEditor(): any {\r\n        // UMD Global name detection from Webpack Bundle UMD Name.\r\n        if (typeof NODEEDITOR !== \"undefined\") {\r\n            return NODEEDITOR;\r\n        }\r\n\r\n        // In case of module let's check the global emitted from the editor entry point.\r\n        if (typeof BABYLON !== \"undefined\" && typeof BABYLON.NodeEditor !== \"undefined\") {\r\n            return BABYLON;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Snippet ID if the material was created from the snippet server\r\n     */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Gets or sets data used by visual editor\r\n     * @see https://nme.babylonjs.com\r\n     */\r\n    public editorData: any = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)\r\n     */\r\n    @serialize()\r\n    public ignoreAlpha = false;\r\n\r\n    /**\r\n     * Defines the maximum number of lights that can be used in the material\r\n     */\r\n    @serialize()\r\n    public maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * Observable raised when the material is built\r\n     */\r\n    public onBuildObservable = new Observable<NodeMaterial>();\r\n\r\n    /**\r\n     * Gets or sets the root nodes of the material vertex shader\r\n     */\r\n    public _vertexOutputNodes = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Gets or sets the root nodes of the material fragment (pixel) shader\r\n     */\r\n    public _fragmentOutputNodes = new Array<NodeMaterialBlock>();\r\n\r\n    /** Gets or sets options to control the node material overall behavior */\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    public set options(options: INodeMaterialOptions) {\r\n        this._options = options;\r\n    }\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the standard Material.\r\n     */\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: ImageProcessingConfiguration) {\r\n        this._attachImageProcessingConfiguration(value);\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\r\n     */\r\n    public attachedBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Specifies the mode of the node material\r\n     * @internal\r\n     */\r\n    @serialize(\"mode\")\r\n    public _mode: NodeMaterialModes = NodeMaterialModes.Material;\r\n\r\n    /**\r\n     * Gets or sets the mode property\r\n     */\r\n    public get mode(): NodeMaterialModes {\r\n        return this._mode;\r\n    }\r\n\r\n    public set mode(value: NodeMaterialModes) {\r\n        this._mode = value;\r\n    }\r\n\r\n    /** Gets or sets the unique identifier used to identified the effect associated with the material */\r\n    public get buildId() {\r\n        return this._buildId;\r\n    }\r\n\r\n    public set buildId(value: number) {\r\n        this._buildId = value;\r\n    }\r\n\r\n    /**\r\n     * A free comment about the material\r\n     */\r\n    @serialize(\"comment\")\r\n    public comment: string;\r\n\r\n    /**\r\n     * Create a new node based material\r\n     * @param name defines the material name\r\n     * @param scene defines the hosting scene\r\n     * @param options defines creation option\r\n     */\r\n    constructor(name: string, scene?: Scene, options: Partial<INodeMaterialOptions> = {}) {\r\n        super(name, scene || EngineStore.LastCreatedScene!);\r\n\r\n        this._options = {\r\n            emitComments: false,\r\n            ...options,\r\n        };\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"NodeMaterial\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Detaches observer.\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration) {\r\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n\r\n        // Attaches observer.\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a block by its name\r\n     * @param name defines the name of the block to retrieve\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByName(name: string) {\r\n        let result = null;\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.name === name) {\r\n                if (!result) {\r\n                    result = block;\r\n                } else {\r\n                    Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get a block by its name\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByPredicate(predicate: (block: NodeMaterialBlock) => boolean) {\r\n        for (const block of this.attachedBlocks) {\r\n            if (predicate(block)) {\r\n                return block;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get an input block by its name\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required input block or null if not found\r\n     */\r\n    public getInputBlockByPredicate(predicate: (block: InputBlock) => boolean): Nullable<InputBlock> {\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isInput && predicate(block as InputBlock)) {\r\n                return block as InputBlock;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input blocks attached to this material\r\n     * @returns an array of InputBlocks\r\n     */\r\n    public getInputBlocks() {\r\n        const blocks: InputBlock[] = [];\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isInput) {\r\n                blocks.push(block as InputBlock);\r\n            }\r\n        }\r\n\r\n        return blocks;\r\n    }\r\n\r\n    /**\r\n     * Adds a new optimizer to the list of optimizers\r\n     * @param optimizer defines the optimizers to add\r\n     * @returns the current material\r\n     */\r\n    public registerOptimizer(optimizer: NodeMaterialOptimizer) {\r\n        const index = this._optimizers.indexOf(optimizer);\r\n\r\n        if (index > -1) {\r\n            return;\r\n        }\r\n\r\n        this._optimizers.push(optimizer);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove an optimizer from the list of optimizers\r\n     * @param optimizer defines the optimizers to remove\r\n     * @returns the current material\r\n     */\r\n    public unregisterOptimizer(optimizer: NodeMaterialOptimizer) {\r\n        const index = this._optimizers.indexOf(optimizer);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._optimizers.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a new block to the list of output nodes\r\n     * @param node defines the node to add\r\n     * @returns the current material\r\n     */\r\n    public addOutputNode(node: NodeMaterialBlock) {\r\n        if (node.target === null) {\r\n            throw \"This node is not meant to be an output node. You may want to explicitly set its target value.\";\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\r\n            this._addVertexOutputNode(node);\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\r\n            this._addFragmentOutputNode(node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the list of root nodes\r\n     * @param node defines the node to remove\r\n     * @returns the current material\r\n     */\r\n    public removeOutputNode(node: NodeMaterialBlock) {\r\n        if (node.target === null) {\r\n            return this;\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\r\n            this._removeVertexOutputNode(node);\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\r\n            this._removeFragmentOutputNode(node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _addVertexOutputNode(node: NodeMaterialBlock) {\r\n        if (this._vertexOutputNodes.indexOf(node) !== -1) {\r\n            return;\r\n        }\r\n\r\n        node.target = NodeMaterialBlockTargets.Vertex;\r\n        this._vertexOutputNodes.push(node);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _removeVertexOutputNode(node: NodeMaterialBlock) {\r\n        const index = this._vertexOutputNodes.indexOf(node);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._vertexOutputNodes.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _addFragmentOutputNode(node: NodeMaterialBlock) {\r\n        if (this._fragmentOutputNodes.indexOf(node) !== -1) {\r\n            return;\r\n        }\r\n\r\n        node.target = NodeMaterialBlockTargets.Fragment;\r\n        this._fragmentOutputNodes.push(node);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _removeFragmentOutputNode(node: NodeMaterialBlock) {\r\n        const index = this._fragmentOutputNodes.indexOf(node);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._fragmentOutputNodes.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that alpha blending must be enabled no matter what alpha value or alpha channel of the FragmentBlock are\r\n     */\r\n    @serialize()\r\n    public forceAlphaBlending = false;\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this.ignoreAlpha) {\r\n            return false;\r\n        }\r\n        return this.forceAlphaBlending || this.alpha < 1.0 || (this._sharedData && this._sharedData.hints.needAlphaBlending);\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return this._sharedData && this._sharedData.hints.needAlphaTesting;\r\n    }\r\n\r\n    private _initializeBlock(node: NodeMaterialBlock, state: NodeMaterialBuildState, nodesToProcessForOtherBuildState: NodeMaterialBlock[], autoConfigure = true) {\r\n        node.initialize(state);\r\n        if (autoConfigure) {\r\n            node.autoConfigure(this);\r\n        }\r\n        node._preparationId = this._buildId;\r\n\r\n        if (this.attachedBlocks.indexOf(node) === -1) {\r\n            if (node.isUnique) {\r\n                const className = node.getClassName();\r\n\r\n                for (const other of this.attachedBlocks) {\r\n                    if (other.getClassName() === className) {\r\n                        throw `Cannot have multiple blocks of type ${className} in the same NodeMaterial`;\r\n                    }\r\n                }\r\n            }\r\n            this.attachedBlocks.push(node);\r\n        }\r\n\r\n        for (const input of node.inputs) {\r\n            input.associatedVariableName = \"\";\r\n\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                        nodesToProcessForOtherBuildState.push(block);\r\n                    } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {\r\n                        nodesToProcessForOtherBuildState.push(block);\r\n                    }\r\n                    this._initializeBlock(block, state, nodesToProcessForOtherBuildState, autoConfigure);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const output of node.outputs) {\r\n            output.associatedVariableName = \"\";\r\n        }\r\n    }\r\n\r\n    private _resetDualBlocks(node: NodeMaterialBlock, id: number) {\r\n        if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n            node.buildId = id;\r\n        }\r\n\r\n        for (const inputs of node.inputs) {\r\n            const connectedPoint = inputs.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    this._resetDualBlocks(block, id);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the current node material\r\n     * @param block defines the block to remove\r\n     */\r\n    public removeBlock(block: NodeMaterialBlock) {\r\n        const attachedBlockIndex = this.attachedBlocks.indexOf(block);\r\n        if (attachedBlockIndex > -1) {\r\n            this.attachedBlocks.splice(attachedBlockIndex, 1);\r\n        }\r\n\r\n        if (block.isFinalMerger) {\r\n            this.removeOutputNode(block);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Build the material and generates the inner effect\r\n     * @param verbose defines if the build should log activity\r\n     * @param updateBuildId defines if the internal build Id should be updated (default is true)\r\n     * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is true)\r\n     */\r\n    public build(verbose: boolean = false, updateBuildId = true, autoConfigure = true) {\r\n        this._buildWasSuccessful = false;\r\n        const engine = this.getScene().getEngine();\r\n\r\n        const allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle;\r\n\r\n        if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {\r\n            throw \"You must define at least one vertexOutputNode\";\r\n        }\r\n\r\n        if (this._fragmentOutputNodes.length === 0) {\r\n            throw \"You must define at least one fragmentOutputNode\";\r\n        }\r\n\r\n        // Compilation state\r\n        this._vertexCompilationState = new NodeMaterialBuildState();\r\n        this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\r\n        this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;\r\n        this._fragmentCompilationState = new NodeMaterialBuildState();\r\n        this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\r\n        this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;\r\n\r\n        // Shared data\r\n        this._sharedData = new NodeMaterialBuildStateSharedData();\r\n        this._sharedData.fragmentOutputNodes = this._fragmentOutputNodes;\r\n        this._vertexCompilationState.sharedData = this._sharedData;\r\n        this._fragmentCompilationState.sharedData = this._sharedData;\r\n        this._sharedData.buildId = this._buildId;\r\n        this._sharedData.emitComments = this._options.emitComments;\r\n        this._sharedData.verbose = verbose;\r\n        this._sharedData.scene = this.getScene();\r\n        this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;\r\n\r\n        // Initialize blocks\r\n        const vertexNodes: NodeMaterialBlock[] = [];\r\n        const fragmentNodes: NodeMaterialBlock[] = [];\r\n\r\n        for (const vertexOutputNode of this._vertexOutputNodes) {\r\n            vertexNodes.push(vertexOutputNode);\r\n            this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes, autoConfigure);\r\n        }\r\n\r\n        for (const fragmentOutputNode of this._fragmentOutputNodes) {\r\n            fragmentNodes.push(fragmentOutputNode);\r\n            this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes, autoConfigure);\r\n        }\r\n\r\n        // Optimize\r\n        this.optimize();\r\n\r\n        // Vertex\r\n        for (const vertexOutputNode of vertexNodes) {\r\n            vertexOutputNode.build(this._vertexCompilationState, vertexNodes);\r\n        }\r\n\r\n        // Fragment\r\n        this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);\r\n        this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;\r\n        this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;\r\n        this._fragmentCompilationState._vertexState = this._vertexCompilationState;\r\n\r\n        for (const fragmentOutputNode of fragmentNodes) {\r\n            this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);\r\n        }\r\n\r\n        for (const fragmentOutputNode of fragmentNodes) {\r\n            fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);\r\n        }\r\n\r\n        // Finalize\r\n        this._vertexCompilationState.finalize(this._vertexCompilationState);\r\n        this._fragmentCompilationState.finalize(this._fragmentCompilationState);\r\n\r\n        if (updateBuildId) {\r\n            this._buildId = NodeMaterial._BuildIdGenerator++;\r\n        }\r\n\r\n        // Errors\r\n        this._sharedData.emitErrors();\r\n\r\n        if (verbose) {\r\n            console.log(\"Vertex shader:\");\r\n            console.log(this._vertexCompilationState.compilationString);\r\n            console.log(\"Fragment shader:\");\r\n            console.log(this._fragmentCompilationState.compilationString);\r\n        }\r\n\r\n        this._buildWasSuccessful = true;\r\n        this.onBuildObservable.notifyObservers(this);\r\n\r\n        // Wipe defines\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                if (!subMesh.materialDefines) {\r\n                    continue;\r\n                }\r\n\r\n                const defines = subMesh.materialDefines;\r\n                defines.markAllAsDirty();\r\n                defines.reset();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs an otpimization phase to try to improve the shader code\r\n     */\r\n    public optimize() {\r\n        for (const optimizer of this._optimizers) {\r\n            optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);\r\n        }\r\n    }\r\n\r\n    private _prepareDefinesForAttributes(mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        const oldNormal = defines[\"NORMAL\"];\r\n        const oldTangent = defines[\"TANGENT\"];\r\n\r\n        defines[\"NORMAL\"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\r\n\r\n        defines[\"TANGENT\"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);\r\n\r\n        let uvChanged = false;\r\n        for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n            const oldUV = defines[\"UV\" + i];\r\n            defines[\"UV\" + i] = mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`);\r\n            uvChanged = uvChanged || defines[\"UV\" + i] !== oldUV;\r\n        }\r\n\r\n        if (oldNormal !== defines[\"NORMAL\"] || oldTangent !== defines[\"TANGENT\"] || uvChanged) {\r\n            defines.markAsAttributesDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a post process from the material\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     * @returns the post process created\r\n     */\r\n    public createPostProcess(\r\n        camera: Nullable<Camera>,\r\n        options: number | PostProcessOptions = 1,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ): Nullable<PostProcess> {\r\n        if (this.mode !== NodeMaterialModes.PostProcess) {\r\n            console.log(\"Incompatible material mode\");\r\n            return null;\r\n        }\r\n        return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);\r\n    }\r\n\r\n    /**\r\n     * Create the post process effect from the material\r\n     * @param postProcess The post process to create the effect for\r\n     */\r\n    public createEffectForPostProcess(postProcess: PostProcess) {\r\n        this._createEffectForPostProcess(postProcess);\r\n    }\r\n\r\n    private _createEffectForPostProcess(\r\n        postProcess: Nullable<PostProcess>,\r\n        camera?: Nullable<Camera>,\r\n        options: number | PostProcessOptions = 1,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ): PostProcess {\r\n        let tempName = this.name + this._buildId;\r\n\r\n        const defines = new NodeMaterialDefines();\r\n\r\n        const dummyMesh = new AbstractMesh(tempName + \"PostProcess\", this.getScene());\r\n\r\n        let buildId = this._buildId;\r\n\r\n        this._processDefines(dummyMesh, defines);\r\n\r\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n        if (!postProcess) {\r\n            postProcess = new PostProcess(\r\n                this.name + \"PostProcess\",\r\n                tempName,\r\n                this._fragmentCompilationState.uniforms,\r\n                this._fragmentCompilationState.samplers,\r\n                options,\r\n                camera!,\r\n                samplingMode,\r\n                engine,\r\n                reusable,\r\n                defines.toString(),\r\n                textureType,\r\n                tempName,\r\n                { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                false,\r\n                textureFormat\r\n            );\r\n        } else {\r\n            postProcess.updateEffect(\r\n                defines.toString(),\r\n                this._fragmentCompilationState.uniforms,\r\n                this._fragmentCompilationState.samplers,\r\n                { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                undefined,\r\n                undefined,\r\n                tempName,\r\n                tempName\r\n            );\r\n        }\r\n\r\n        postProcess.nodeMaterialSource = this;\r\n\r\n        postProcess.onApplyObservable.add((effect) => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"VertexShader\"];\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId;\r\n\r\n                defines.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            const result = this._processDefines(dummyMesh, defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n                TimingTools.SetImmediate(() =>\r\n                    postProcess!.updateEffect(\r\n                        defines.toString(),\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                        undefined,\r\n                        undefined,\r\n                        tempName,\r\n                        tempName\r\n                    )\r\n                );\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n\r\n        return postProcess;\r\n    }\r\n\r\n    /**\r\n     * Create a new procedural texture based on this node material\r\n     * @param size defines the size of the texture\r\n     * @param scene defines the hosting scene\r\n     * @returns the new procedural texture attached to this node material\r\n     */\r\n    public createProceduralTexture(size: number | { width: number; height: number; layers?: number }, scene: Scene): Nullable<ProceduralTexture> {\r\n        if (this.mode !== NodeMaterialModes.ProceduralTexture) {\r\n            console.log(\"Incompatible material mode\");\r\n            return null;\r\n        }\r\n\r\n        let tempName = this.name + this._buildId;\r\n\r\n        const proceduralTexture = new ProceduralTexture(tempName, size, null, scene);\r\n\r\n        const dummyMesh = new AbstractMesh(tempName + \"Procedural\", this.getScene());\r\n        dummyMesh.reservedDataStore = {\r\n            hidden: true,\r\n        };\r\n\r\n        const defines = new NodeMaterialDefines();\r\n        const result = this._processDefines(dummyMesh, defines);\r\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n        let effect = this.getScene().getEngine().createEffect(\r\n            {\r\n                vertexElement: tempName,\r\n                fragmentElement: tempName,\r\n            },\r\n            [VertexBuffer.PositionKind],\r\n            this._fragmentCompilationState.uniforms,\r\n            this._fragmentCompilationState.samplers,\r\n            defines.toString(),\r\n            result?.fallbacks,\r\n            undefined\r\n        );\r\n\r\n        proceduralTexture.nodeMaterialSource = this;\r\n        proceduralTexture._setEffect(effect);\r\n\r\n        let buildId = this._buildId;\r\n        proceduralTexture.onBeforeGenerationObservable.add(() => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"VertexShader\"];\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId;\r\n\r\n                defines.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            const result = this._processDefines(dummyMesh, defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n                TimingTools.SetImmediate(() => {\r\n                    effect = this.getScene().getEngine().createEffect(\r\n                        {\r\n                            vertexElement: tempName,\r\n                            fragmentElement: tempName,\r\n                        },\r\n                        [VertexBuffer.PositionKind],\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        defines.toString(),\r\n                        result?.fallbacks,\r\n                        undefined\r\n                    );\r\n\r\n                    proceduralTexture._setEffect(effect);\r\n                });\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n\r\n        return proceduralTexture;\r\n    }\r\n\r\n    private _createEffectForParticles(\r\n        particleSystem: IParticleSystem,\r\n        blendMode: number,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void,\r\n        effect?: Effect,\r\n        defines?: NodeMaterialDefines,\r\n        dummyMesh?: Nullable<AbstractMesh>,\r\n        particleSystemDefinesJoined = \"\"\r\n    ) {\r\n        let tempName = this.name + this._buildId + \"_\" + blendMode;\r\n\r\n        if (!defines) {\r\n            defines = new NodeMaterialDefines();\r\n        }\r\n\r\n        if (!dummyMesh) {\r\n            dummyMesh = this.getScene().getMeshByName(this.name + \"Particle\");\r\n            if (!dummyMesh) {\r\n                dummyMesh = new AbstractMesh(this.name + \"Particle\", this.getScene());\r\n                dummyMesh.reservedDataStore = {\r\n                    hidden: true,\r\n                };\r\n            }\r\n        }\r\n\r\n        let buildId = this._buildId;\r\n\r\n        const particleSystemDefines: Array<string> = [];\r\n        let join = particleSystemDefinesJoined;\r\n\r\n        if (!effect) {\r\n            const result = this._processDefines(dummyMesh, defines);\r\n\r\n            Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\r\n\r\n            particleSystem.fillDefines(particleSystemDefines, blendMode);\r\n\r\n            join = particleSystemDefines.join(\"\\n\");\r\n\r\n            effect = this.getScene()\r\n                .getEngine()\r\n                .createEffectForParticles(\r\n                    tempName,\r\n                    this._fragmentCompilationState.uniforms,\r\n                    this._fragmentCompilationState.samplers,\r\n                    defines.toString() + \"\\n\" + join,\r\n                    result?.fallbacks,\r\n                    onCompiled,\r\n                    onError,\r\n                    particleSystem\r\n                );\r\n\r\n            particleSystem.setCustomEffect(effect, blendMode);\r\n        }\r\n\r\n        effect.onBindObservable.add((effect) => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId + \"_\" + blendMode;\r\n\r\n                defines!.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            particleSystemDefines.length = 0;\r\n\r\n            particleSystem.fillDefines(particleSystemDefines, blendMode);\r\n\r\n            const particleSystemDefinesJoinedCurrent = particleSystemDefines.join(\"\\n\");\r\n\r\n            if (particleSystemDefinesJoinedCurrent !== join) {\r\n                defines!.markAllAsDirty();\r\n                join = particleSystemDefinesJoinedCurrent;\r\n            }\r\n\r\n            const result = this._processDefines(dummyMesh!, defines!);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\r\n\r\n                effect = this.getScene()\r\n                    .getEngine()\r\n                    .createEffectForParticles(\r\n                        tempName,\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        defines!.toString() + \"\\n\" + join,\r\n                        result?.fallbacks,\r\n                        onCompiled,\r\n                        onError,\r\n                        particleSystem\r\n                    );\r\n                particleSystem.setCustomEffect(effect, blendMode);\r\n                this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined); // add the effect.onBindObservable observer\r\n                return;\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n    }\r\n\r\n    private _checkInternals(effect: Effect) {\r\n        // Animated blocks\r\n        if (this._sharedData.animatedInputs) {\r\n            const scene = this.getScene();\r\n\r\n            const frameId = scene.getFrameId();\r\n\r\n            if (this._animationFrame !== frameId) {\r\n                for (const input of this._sharedData.animatedInputs) {\r\n                    input.animate(scene);\r\n                }\r\n\r\n                this._animationFrame = frameId;\r\n            }\r\n        }\r\n\r\n        // Bindable blocks\r\n        for (const block of this._sharedData.bindableBlocks) {\r\n            block.bind(effect, this);\r\n        }\r\n\r\n        // Connection points\r\n        for (const inputBlock of this._sharedData.inputBlocks) {\r\n            inputBlock._transmit(effect, this.getScene(), this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the effect to be used as the custom effect for a particle system\r\n     * @param particleSystem Particle system to create the effect for\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     */\r\n    public createEffectForParticles(particleSystem: IParticleSystem, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void) {\r\n        if (this.mode !== NodeMaterialModes.Particle) {\r\n            console.log(\"Incompatible material mode\");\r\n            return;\r\n        }\r\n\r\n        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);\r\n        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);\r\n    }\r\n\r\n    /**\r\n     * Use this material as the shadow depth wrapper of a target material\r\n     * @param targetMaterial defines the target material\r\n     */\r\n    public createAsShadowDepthWrapper(targetMaterial: Material) {\r\n        if (this.mode !== NodeMaterialModes.Material) {\r\n            console.log(\"Incompatible material mode\");\r\n            return;\r\n        }\r\n\r\n        targetMaterial.shadowDepthWrapper = new BABYLON.ShadowDepthWrapper(this, this.getScene());\r\n    }\r\n\r\n    private _processDefines(\r\n        mesh: AbstractMesh,\r\n        defines: NodeMaterialDefines,\r\n        useInstances = false,\r\n        subMesh?: SubMesh\r\n    ): Nullable<{\r\n        lightDisposed: boolean;\r\n        uniformBuffers: string[];\r\n        mergedUniforms: string[];\r\n        mergedSamplers: string[];\r\n        fallbacks: EffectFallbacks;\r\n    }> {\r\n        let result = null;\r\n\r\n        // Shared defines\r\n        this._sharedData.blocksWithDefines.forEach((b) => {\r\n            b.initializeDefines(mesh, this, defines, useInstances);\r\n        });\r\n\r\n        this._sharedData.blocksWithDefines.forEach((b) => {\r\n            b.prepareDefines(mesh, this, defines, useInstances, subMesh);\r\n        });\r\n\r\n        // Need to recompile?\r\n        if (defines.isDirty) {\r\n            const lightDisposed = defines._areLightsDisposed;\r\n            defines.markAsProcessed();\r\n\r\n            // Repeatable content generators\r\n            this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;\r\n            this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;\r\n\r\n            this._sharedData.repeatableContentBlocks.forEach((b) => {\r\n                b.replaceRepeatableContent(this._vertexCompilationState, this._fragmentCompilationState, mesh, defines);\r\n            });\r\n\r\n            // Uniforms\r\n            const uniformBuffers: string[] = [];\r\n            this._sharedData.dynamicUniformBlocks.forEach((b) => {\r\n                b.updateUniformsAndSamples(this._vertexCompilationState, this, defines, uniformBuffers);\r\n            });\r\n\r\n            const mergedUniforms = this._vertexCompilationState.uniforms;\r\n\r\n            this._fragmentCompilationState.uniforms.forEach((u) => {\r\n                const index = mergedUniforms.indexOf(u);\r\n\r\n                if (index === -1) {\r\n                    mergedUniforms.push(u);\r\n                }\r\n            });\r\n\r\n            // Samplers\r\n            const mergedSamplers = this._vertexCompilationState.samplers;\r\n\r\n            this._fragmentCompilationState.samplers.forEach((s) => {\r\n                const index = mergedSamplers.indexOf(s);\r\n\r\n                if (index === -1) {\r\n                    mergedSamplers.push(s);\r\n                }\r\n            });\r\n\r\n            const fallbacks = new EffectFallbacks();\r\n\r\n            this._sharedData.blocksWithFallbacks.forEach((b) => {\r\n                b.provideFallbacks(mesh, fallbacks);\r\n            });\r\n\r\n            result = {\r\n                lightDisposed,\r\n                uniformBuffers,\r\n                mergedUniforms,\r\n                mergedSamplers,\r\n                fallbacks,\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get if the submesh is ready to be used and all its information available.\r\n     * Child classes can use it to update shaders\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances: boolean = false): boolean {\r\n        if (!this._buildWasSuccessful) {\r\n            return false;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        if (this._sharedData.animatedInputs) {\r\n            const frameId = scene.getFrameId();\r\n\r\n            if (this._animationFrame !== frameId) {\r\n                for (const input of this._sharedData.animatedInputs) {\r\n                    input.animate(scene);\r\n                }\r\n\r\n                this._animationFrame = frameId;\r\n            }\r\n        }\r\n\r\n        if (subMesh.effect && this.isFrozen) {\r\n            if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new NodeMaterialDefines();\r\n        }\r\n\r\n        const defines = <NodeMaterialDefines>subMesh.materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        this._prepareDefinesForAttributes(mesh, defines);\r\n\r\n        // Check if blocks are ready\r\n        if (this._sharedData.blockingBlocks.some((b) => !b.isReady(mesh, this, defines, useInstances))) {\r\n            return false;\r\n        }\r\n\r\n        const result = this._processDefines(mesh, defines, useInstances, subMesh);\r\n\r\n        if (result) {\r\n            const previousEffect = subMesh.effect;\r\n            // Compilation\r\n            const join = defines.toString();\r\n            let effect = engine.createEffect(\r\n                {\r\n                    vertex: \"nodeMaterial\" + this._buildId,\r\n                    fragment: \"nodeMaterial\" + this._buildId,\r\n                    vertexSource: this._vertexCompilationState.compilationString,\r\n                    fragmentSource: this._fragmentCompilationState.compilationString,\r\n                },\r\n                <IEffectCreationOptions>{\r\n                    attributes: this._vertexCompilationState.attributes,\r\n                    uniformsNames: result.mergedUniforms,\r\n                    uniformBuffersNames: result.uniformBuffers,\r\n                    samplers: result.mergedSamplers,\r\n                    defines: join,\r\n                    fallbacks: result.fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },\r\n                },\r\n                engine\r\n            );\r\n\r\n            if (effect) {\r\n                if (this._onEffectCreatedObservable) {\r\n                    onCreatedEffectParameters.effect = effect;\r\n                    onCreatedEffectParameters.subMesh = subMesh;\r\n                    this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n                }\r\n\r\n                // Use previous effect while new one is compiling\r\n                if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                    effect = previousEffect;\r\n                    defines.markAsUnprocessed();\r\n\r\n                    if (result.lightDisposed) {\r\n                        // re register in case it takes more than one frame.\r\n                        defines._areLightsDisposed = true;\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    scene.resetCachedMaterial();\r\n                    subMesh.setEffect(effect, defines, this._materialContext);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = useInstances;\r\n\r\n        if (scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {\r\n            this.checkReadyOnlyOnce = true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get a string representing the shaders built by the current node graph\r\n     */\r\n    public get compiledShaders() {\r\n        return `// Vertex shader\\r\\n${this._vertexCompilationState.compilationString}\\r\\n\\r\\n// Fragment shader\\r\\n${this._fragmentCompilationState.compilationString}`;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!this._activeEffect) {\r\n            return;\r\n        }\r\n\r\n        const hints = this._sharedData.hints;\r\n\r\n        if (hints.needWorldViewMatrix) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (hints.needWorldViewProjectionMatrix) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n        }\r\n\r\n        // Connection points\r\n        for (const inputBlock of this._sharedData.inputBlocks) {\r\n            inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n\r\n        const mustRebind = this._mustRebind(scene, effect, mesh.visibility);\r\n        const sharedData = this._sharedData;\r\n\r\n        if (mustRebind) {\r\n            // Bindable blocks\r\n            for (const block of sharedData.bindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n\r\n            for (const block of sharedData.forcedBindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n\r\n            // Connection points\r\n            for (const inputBlock of sharedData.inputBlocks) {\r\n                inputBlock._transmit(effect, scene, this);\r\n            }\r\n        } else if (!this.isFrozen) {\r\n            for (const block of sharedData.forcedBindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._sharedData) {\r\n            activeTextures.push(...this._sharedData.textureBlocks.filter((tb) => tb.texture).map((tb) => tb.texture!));\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of texture blocks\r\n     * @returns an array of texture blocks\r\n     */\r\n    public getTextureBlocks(): (TextureBlock | ReflectionTextureBaseBlock | RefractionBlock | CurrentScreenBlock | ParticleTextureBlock | ImageSourceBlock)[] {\r\n        if (!this._sharedData) {\r\n            return [];\r\n        }\r\n\r\n        return this._sharedData.textureBlocks;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._sharedData) {\r\n            return false;\r\n        }\r\n\r\n        for (const t of this._sharedData.textureBlocks) {\r\n            if (t.texture === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            for (const texture of this.getTextureBlocks()\r\n                .filter((tb) => tb.texture)\r\n                .map((tb) => tb.texture!)) {\r\n                texture.dispose();\r\n            }\r\n        }\r\n\r\n        for (const block of this.attachedBlocks) {\r\n            block.dispose();\r\n        }\r\n\r\n        this.attachedBlocks.length = 0;\r\n        (this._sharedData as any) = null;\r\n        (this._vertexCompilationState as any) = null;\r\n        (this._fragmentCompilationState as any) = null;\r\n\r\n        this.onBuildObservable.clear();\r\n\r\n        if (this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n            this._imageProcessingObserver = null;\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /** Creates the node editor window. */\r\n    private _createNodeEditor() {\r\n        this.BJSNODEMATERIALEDITOR.NodeEditor.Show({\r\n            nodeMaterial: this,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Launch the node material editor\r\n     * @param config Define the configuration of the editor\r\n     * @returns a promise fulfilled when the node editor is visible\r\n     */\r\n    public edit(config?: INodeMaterialEditorOptions): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\r\n            if (typeof this.BJSNODEMATERIALEDITOR == \"undefined\") {\r\n                const editorUrl = config && config.editorURL ? config.editorURL : NodeMaterial.EditorURL;\r\n\r\n                // Load editor and add it to the DOM\r\n                Tools.LoadScript(editorUrl, () => {\r\n                    this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\r\n                    this._createNodeEditor();\r\n                    resolve();\r\n                });\r\n            } else {\r\n                // Otherwise creates the editor\r\n                this._createNodeEditor();\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clear the current material\r\n     */\r\n    public clear() {\r\n        this._vertexOutputNodes.length = 0;\r\n        this._fragmentOutputNodes.length = 0;\r\n        this.attachedBlocks.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state\r\n     */\r\n    public setToDefault() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const positionInput = new InputBlock(\"Position\");\r\n        positionInput.setAsAttribute(\"position\");\r\n\r\n        const worldInput = new InputBlock(\"World\");\r\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n\r\n        const worldPos = new TransformBlock(\"WorldPos\");\r\n        positionInput.connectTo(worldPos);\r\n        worldInput.connectTo(worldPos);\r\n\r\n        const viewProjectionInput = new InputBlock(\"ViewProjection\");\r\n        viewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.ViewProjection);\r\n\r\n        const worldPosdMultipliedByViewProjection = new TransformBlock(\"WorldPos * ViewProjectionTransform\");\r\n        worldPos.connectTo(worldPosdMultipliedByViewProjection);\r\n        viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        worldPosdMultipliedByViewProjection.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const pixelColor = new InputBlock(\"color\");\r\n        pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        pixelColor.connectTo(fragmentOutput);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.Material;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for post process\r\n     */\r\n    public setToDefaultPostProcess() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const position = new InputBlock(\"Position\");\r\n        position.setAsAttribute(\"position2d\");\r\n\r\n        const const1 = new InputBlock(\"Constant1\");\r\n        const1.isConstant = true;\r\n        const1.value = 1;\r\n\r\n        const vmerger = new VectorMergerBlock(\"Position3D\");\r\n\r\n        position.connectTo(vmerger);\r\n        const1.connectTo(vmerger, { input: \"w\" });\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        vmerger.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const scale = new InputBlock(\"Scale\");\r\n        scale.visibleInInspector = true;\r\n        scale.value = new Vector2(1, 1);\r\n\r\n        const uv0 = new RemapBlock(\"uv0\");\r\n        position.connectTo(uv0);\r\n\r\n        const uv = new MultiplyBlock(\"UV scale\");\r\n        uv0.connectTo(uv);\r\n        scale.connectTo(uv);\r\n\r\n        const currentScreen = new CurrentScreenBlock(\"CurrentScreen\");\r\n        uv.connectTo(currentScreen);\r\n\r\n        currentScreen.texture = new Texture(\"https://assets.babylonjs.com/nme/currentScreenPostProcess.png\", this.getScene());\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        currentScreen.connectTo(fragmentOutput, { output: \"rgba\" });\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.PostProcess;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for procedural texture\r\n     */\r\n    public setToDefaultProceduralTexture() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const position = new InputBlock(\"Position\");\r\n        position.setAsAttribute(\"position2d\");\r\n\r\n        const const1 = new InputBlock(\"Constant1\");\r\n        const1.isConstant = true;\r\n        const1.value = 1;\r\n\r\n        const vmerger = new VectorMergerBlock(\"Position3D\");\r\n\r\n        position.connectTo(vmerger);\r\n        const1.connectTo(vmerger, { input: \"w\" });\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        vmerger.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const time = new InputBlock(\"Time\");\r\n        time.value = 0;\r\n        time.min = 0;\r\n        time.max = 0;\r\n        time.isBoolean = false;\r\n        time.matrixMode = 0;\r\n        time.animationType = AnimatedInputBlockTypes.Time;\r\n        time.isConstant = false;\r\n\r\n        const color = new InputBlock(\"Color3\");\r\n        color.value = new Color3(1, 1, 1);\r\n        color.isConstant = false;\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n\r\n        const vectorMerger = new VectorMergerBlock(\"VectorMerger\");\r\n        vectorMerger.visibleInInspector = false;\r\n\r\n        const cos = new TrigonometryBlock(\"Cos\");\r\n        cos.operation = TrigonometryBlockOperations.Cos;\r\n\r\n        position.connectTo(vectorMerger);\r\n        time.output.connectTo(cos.input);\r\n        cos.output.connectTo(vectorMerger.z);\r\n        vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.ProceduralTexture;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for particle\r\n     */\r\n    public setToDefaultParticle() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        // Pixel\r\n        const uv = new InputBlock(\"uv\");\r\n        uv.setAsAttribute(\"particle_uv\");\r\n\r\n        const texture = new ParticleTextureBlock(\"ParticleTexture\");\r\n        uv.connectTo(texture);\r\n\r\n        const color = new InputBlock(\"Color\");\r\n        color.setAsAttribute(\"particle_color\");\r\n\r\n        const multiply = new MultiplyBlock(\"Texture * Color\");\r\n        texture.connectTo(multiply);\r\n        color.connectTo(multiply);\r\n\r\n        const rampGradient = new ParticleRampGradientBlock(\"ParticleRampGradient\");\r\n        multiply.connectTo(rampGradient);\r\n\r\n        const cSplitter = new ColorSplitterBlock(\"ColorSplitter\");\r\n        color.connectTo(cSplitter);\r\n\r\n        const blendMultiply = new ParticleBlendMultiplyBlock(\"ParticleBlendMultiply\");\r\n        rampGradient.connectTo(blendMultiply);\r\n        texture.connectTo(blendMultiply, { output: \"a\" });\r\n        cSplitter.connectTo(blendMultiply, { output: \"a\" });\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        blendMultiply.connectTo(fragmentOutput);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.Particle;\r\n    }\r\n\r\n    /**\r\n     * Loads the current Node Material from a url pointing to a file save by the Node Material Editor\r\n     * @deprecated Please use NodeMaterial.ParseFromFileAsync instead\r\n     * @param url defines the url to load from\r\n     * @param rootUrl defines the root URL for nested url in the node material\r\n     * @returns a promise that will fulfil when the material is fully loaded\r\n     */\r\n    public async loadAsync(url: string, rootUrl: string = \"\") {\r\n        return NodeMaterial.ParseFromFileAsync(\"\", url, this.getScene(), rootUrl, true, this);\r\n    }\r\n\r\n    private _gatherBlocks(rootNode: NodeMaterialBlock, list: NodeMaterialBlock[]) {\r\n        if (list.indexOf(rootNode) !== -1) {\r\n            return;\r\n        }\r\n        list.push(rootNode);\r\n\r\n        for (const input of rootNode.inputs) {\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== rootNode) {\r\n                    this._gatherBlocks(block, list);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate a string containing the code declaration required to create an equivalent of this material\r\n     * @returns a string\r\n     */\r\n    public generateCode() {\r\n        let alreadyDumped: NodeMaterialBlock[] = [];\r\n        const vertexBlocks: NodeMaterialBlock[] = [];\r\n        const uniqueNames: string[] = [\"const\", \"var\", \"let\"];\r\n        // Gets active blocks\r\n        for (const outputNode of this._vertexOutputNodes) {\r\n            this._gatherBlocks(outputNode, vertexBlocks);\r\n        }\r\n\r\n        const fragmentBlocks: NodeMaterialBlock[] = [];\r\n        for (const outputNode of this._fragmentOutputNodes) {\r\n            this._gatherBlocks(outputNode, fragmentBlocks);\r\n        }\r\n\r\n        // Generate vertex shader\r\n        let codeString = `var nodeMaterial = new BABYLON.NodeMaterial(\"${this.name || \"node material\"}\");\\r\\n`;\r\n        for (const node of vertexBlocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Generate fragment shader\r\n        for (const node of fragmentBlocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Connections\r\n        alreadyDumped = [];\r\n        codeString += \"\\r\\n// Connections\\r\\n\";\r\n        for (const node of this._vertexOutputNodes) {\r\n            codeString += node._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n        for (const node of this._fragmentOutputNodes) {\r\n            codeString += node._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n\r\n        // Output nodes\r\n        codeString += \"\\r\\n// Output nodes\\r\\n\";\r\n        for (const node of this._vertexOutputNodes) {\r\n            codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\r\\n`;\r\n        }\r\n\r\n        for (const node of this._fragmentOutputNodes) {\r\n            codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\r\\n`;\r\n        }\r\n\r\n        codeString += `nodeMaterial.build();\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @param selectedBlocks\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(selectedBlocks?: NodeMaterialBlock[]): any {\r\n        const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\r\n        serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\r\n\r\n        let blocks: NodeMaterialBlock[] = [];\r\n\r\n        if (selectedBlocks) {\r\n            blocks = selectedBlocks;\r\n        } else {\r\n            serializationObject.customType = \"BABYLON.NodeMaterial\";\r\n            serializationObject.outputNodes = [];\r\n\r\n            // Outputs\r\n            for (const outputNode of this._vertexOutputNodes) {\r\n                this._gatherBlocks(outputNode, blocks);\r\n                serializationObject.outputNodes.push(outputNode.uniqueId);\r\n            }\r\n\r\n            for (const outputNode of this._fragmentOutputNodes) {\r\n                this._gatherBlocks(outputNode, blocks);\r\n\r\n                if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {\r\n                    serializationObject.outputNodes.push(outputNode.uniqueId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Blocks\r\n        serializationObject.blocks = [];\r\n\r\n        for (const block of blocks) {\r\n            serializationObject.blocks.push(block.serialize());\r\n        }\r\n\r\n        if (!selectedBlocks) {\r\n            for (const block of this.attachedBlocks) {\r\n                if (blocks.indexOf(block) !== -1) {\r\n                    continue;\r\n                }\r\n                serializationObject.blocks.push(block.serialize());\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _restoreConnections(block: NodeMaterialBlock, source: any, map: { [key: number]: NodeMaterialBlock }) {\r\n        for (const outputPoint of block.outputs) {\r\n            for (const candidate of source.blocks) {\r\n                const target = map[candidate.id];\r\n\r\n                if (!target) {\r\n                    continue;\r\n                }\r\n\r\n                for (const input of candidate.inputs) {\r\n                    if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\r\n                        const inputPoint = target.getInputByName(input.inputName);\r\n                        if (!inputPoint || inputPoint.isConnected) {\r\n                            continue;\r\n                        }\r\n\r\n                        outputPoint.connectTo(inputPoint, true);\r\n                        this._restoreConnections(target, source, map);\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current graph and load a new one from a serialization object\r\n     * @param source defines the JSON representation of the material\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param merge defines whether or not the source must be merged or replace the current content\r\n     */\r\n    public parseSerializedObject(source: any, rootUrl: string = \"\", merge = false) {\r\n        if (!merge) {\r\n            this.clear();\r\n        }\r\n\r\n        const map: { [key: number]: NodeMaterialBlock } = {};\r\n\r\n        // Create blocks\r\n        for (const parsedBlock of source.blocks) {\r\n            const blockType = GetClass(parsedBlock.customType);\r\n            if (blockType) {\r\n                const block: NodeMaterialBlock = new blockType();\r\n                block._deserialize(parsedBlock, this.getScene(), rootUrl);\r\n                map[parsedBlock.id] = block;\r\n\r\n                this.attachedBlocks.push(block);\r\n            }\r\n        }\r\n\r\n        // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\r\n        for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\r\n            const parsedBlock = source.blocks[blockIndex];\r\n            const block = map[parsedBlock.id];\r\n\r\n            if (!block) {\r\n                continue;\r\n            }\r\n\r\n            if (block.inputs.length && !merge) {\r\n                continue;\r\n            }\r\n            this._restoreConnections(block, source, map);\r\n        }\r\n\r\n        // Outputs\r\n        if (source.outputNodes) {\r\n            for (const outputNodeId of source.outputNodes) {\r\n                this.addOutputNode(map[outputNodeId]);\r\n            }\r\n        }\r\n\r\n        // UI related info\r\n        if (source.locations || (source.editorData && source.editorData.locations)) {\r\n            const locations: {\r\n                blockId: number;\r\n                x: number;\r\n                y: number;\r\n            }[] = source.locations || source.editorData.locations;\r\n\r\n            for (const location of locations) {\r\n                if (map[location.blockId]) {\r\n                    location.blockId = map[location.blockId].uniqueId;\r\n                }\r\n            }\r\n\r\n            if (merge && this.editorData && this.editorData.locations) {\r\n                locations.concat(this.editorData.locations);\r\n            }\r\n\r\n            if (source.locations) {\r\n                this.editorData = {\r\n                    locations: locations,\r\n                };\r\n            } else {\r\n                this.editorData = source.editorData;\r\n                this.editorData.locations = locations;\r\n            }\r\n\r\n            const blockMap: number[] = [];\r\n\r\n            for (const key in map) {\r\n                blockMap[key] = map[key].uniqueId;\r\n            }\r\n\r\n            this.editorData.map = blockMap;\r\n        }\r\n\r\n        this.comment = source.comment;\r\n\r\n        if (source.forceAlphaBlending !== undefined) {\r\n            this.forceAlphaBlending = source.forceAlphaBlending;\r\n        }\r\n\r\n        if (!merge) {\r\n            this._mode = source.mode ?? NodeMaterialModes.Material;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current graph and load a new one from a serialization object\r\n     * @param source defines the JSON representation of the material\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param merge defines whether or not the source must be merged or replace the current content\r\n     * @deprecated Please use the parseSerializedObject method instead\r\n     */\r\n    public loadFromSerialization(source: any, rootUrl: string = \"\", merge = false) {\r\n        this.parseSerializedObject(source, rootUrl, merge);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current material.\r\n     * @param name defines the name to use for the new material\r\n     * @param shareEffect defines if the clone material should share the same effect (default is false)\r\n     */\r\n    public clone(name: string, shareEffect: boolean = false): NodeMaterial {\r\n        const serializationObject = this.serialize();\r\n\r\n        const clone = SerializationHelper.Clone(() => new NodeMaterial(name, this.getScene(), this.options), this);\r\n        clone.id = name;\r\n        clone.name = name;\r\n\r\n        clone.parseSerializedObject(serializationObject);\r\n        clone._buildId = this._buildId;\r\n        clone.build(false, !shareEffect);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new node material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string = \"\"): NodeMaterial {\r\n        const nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(source.name, scene), source, scene, rootUrl);\r\n\r\n        nodeMaterial.parseSerializedObject(source, rootUrl);\r\n        nodeMaterial.build();\r\n\r\n        return nodeMaterial;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from a snippet saved in a remote file\r\n     * @param name defines the name of the material to create\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL for nested url in the node material\r\n     * @param skipBuild defines whether to build the node material\r\n     * @param targetMaterial defines a material to use instead of creating a new one\r\n     * @returns a promise that will resolve to the new node material\r\n     */\r\n    public static async ParseFromFileAsync(\r\n        name: string,\r\n        url: string,\r\n        scene: Scene,\r\n        rootUrl: string = \"\",\r\n        skipBuild: boolean = false,\r\n        targetMaterial?: NodeMaterial\r\n    ): Promise<NodeMaterial> {\r\n        const material = targetMaterial ?? new NodeMaterial(name, scene);\r\n\r\n        const data = await scene._loadFileAsync(url);\r\n        const serializationObject = JSON.parse(data as string);\r\n        material.parseSerializedObject(serializationObject, rootUrl);\r\n        if (!skipBuild) {\r\n            material.build();\r\n        }\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from a snippet saved by the node material editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param nodeMaterial defines a node material to update (instead of creating a new one)\r\n     * @param skipBuild defines whether to build the node material\r\n     * @returns a promise that will resolve to the new node material\r\n     */\r\n    public static ParseFromSnippetAsync(\r\n        snippetId: string,\r\n        scene: Scene = EngineStore.LastCreatedScene!,\r\n        rootUrl: string = \"\",\r\n        nodeMaterial?: NodeMaterial,\r\n        skipBuild: boolean = false\r\n    ): Promise<NodeMaterial> {\r\n        if (snippetId === \"_BLANK\") {\r\n            return Promise.resolve(NodeMaterial.CreateDefault(\"blank\", scene));\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.nodeMaterial);\r\n\r\n                        if (!nodeMaterial) {\r\n                            nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(snippetId, scene), serializationObject, scene, rootUrl);\r\n                            nodeMaterial.uniqueId = scene.getUniqueId();\r\n                        }\r\n\r\n                        nodeMaterial.parseSerializedObject(serializationObject);\r\n                        nodeMaterial.snippetId = snippetId;\r\n\r\n                        try {\r\n                            if (!skipBuild) {\r\n                                nodeMaterial.build();\r\n                            }\r\n                            resolve(nodeMaterial);\r\n                        } catch (err) {\r\n                            reject(err);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a new node material set to default basic configuration\r\n     * @param name defines the name of the material\r\n     * @param scene defines the hosting scene\r\n     * @returns a new NodeMaterial\r\n     */\r\n    public static CreateDefault(name: string, scene?: Scene) {\r\n        const newMaterial = new NodeMaterial(name, scene);\r\n\r\n        newMaterial.setToDefault();\r\n        newMaterial.build();\r\n\r\n        return newMaterial;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NodeMaterial\", NodeMaterial);\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData of the IcoSphere\r\n * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n * * radius the radius of the IcoSphere, optional default 1\r\n * * radiusX allows stretching in the x direction, optional, default radius\r\n * * radiusY allows stretching in the y direction, optional, default radius\r\n * * radiusZ allows stretching in the z direction, optional, default radius\r\n * * flat when true creates a flat shaded mesh, optional, default true\r\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.radius\r\n * @param options.radiusX\r\n * @param options.radiusY\r\n * @param options.radiusZ\r\n * @param options.flat\r\n * @param options.subdivisions\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the IcoSphere\r\n */\r\nexport function CreateIcoSphereVertexData(options: {\r\n    radius?: number;\r\n    radiusX?: number;\r\n    radiusY?: number;\r\n    radiusZ?: number;\r\n    flat?: boolean;\r\n    subdivisions?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const sideOrientation = options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const radius = options.radius || 1;\r\n    const flat = options.flat === undefined ? true : options.flat;\r\n    const subdivisions = options.subdivisions || 4;\r\n    const radiusX = options.radiusX || radius;\r\n    const radiusY = options.radiusY || radius;\r\n    const radiusZ = options.radiusZ || radius;\r\n\r\n    const t = (1 + Math.sqrt(5)) / 2;\r\n\r\n    // 12 vertex x,y,z\r\n    const icoVertices = [\r\n        -1,\r\n        t,\r\n        -0,\r\n        1,\r\n        t,\r\n        0,\r\n        -1,\r\n        -t,\r\n        0,\r\n        1,\r\n        -t,\r\n        0, // v0-3\r\n        0,\r\n        -1,\r\n        -t,\r\n        0,\r\n        1,\r\n        -t,\r\n        0,\r\n        -1,\r\n        t,\r\n        0,\r\n        1,\r\n        t, // v4-7\r\n        t,\r\n        0,\r\n        1,\r\n        t,\r\n        0,\r\n        -1,\r\n        -t,\r\n        0,\r\n        1,\r\n        -t,\r\n        0,\r\n        -1, // v8-11\r\n    ];\r\n\r\n    // index of 3 vertex makes a face of icopshere\r\n    const ico_indices = [\r\n        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 12, 22, 23, 1, 5, 20, 5, 11, 4, 23, 22, 13, 22, 18, 6, 7, 1, 8, 14, 21, 4, 14, 4, 2, 16, 13, 6, 15, 6, 19, 3, 8, 9, 4, 21, 5, 13, 17,\r\n        23, 6, 13, 22, 19, 6, 18, 9, 8, 1,\r\n    ];\r\n    // vertex for uv have aliased position, not for UV\r\n    const vertices_unalias_id = [\r\n        0,\r\n        1,\r\n        2,\r\n        3,\r\n        4,\r\n        5,\r\n        6,\r\n        7,\r\n        8,\r\n        9,\r\n        10,\r\n        11,\r\n        // vertex alias\r\n        0, // 12: 0 + 12\r\n        2, // 13: 2 + 11\r\n        3, // 14: 3 + 11\r\n        3, // 15: 3 + 12\r\n        3, // 16: 3 + 13\r\n        4, // 17: 4 + 13\r\n        7, // 18: 7 + 11\r\n        8, // 19: 8 + 11\r\n        9, // 20: 9 + 11\r\n        9, // 21: 9 + 12\r\n        10, // 22: A + 12\r\n        11, // 23: B + 12\r\n    ];\r\n\r\n    // uv as integer step (not pixels !)\r\n    const ico_vertexuv = [\r\n        5,\r\n        1,\r\n        3,\r\n        1,\r\n        6,\r\n        4,\r\n        0,\r\n        0, // v0-3\r\n        5,\r\n        3,\r\n        4,\r\n        2,\r\n        2,\r\n        2,\r\n        4,\r\n        0, // v4-7\r\n        2,\r\n        0,\r\n        1,\r\n        1,\r\n        6,\r\n        0,\r\n        6,\r\n        2, // v8-11\r\n        // vertex alias (for same vertex on different faces)\r\n        0,\r\n        4, // 12: 0 + 12\r\n        3,\r\n        3, // 13: 2 + 11\r\n        4,\r\n        4, // 14: 3 + 11\r\n        3,\r\n        1, // 15: 3 + 12\r\n        4,\r\n        2, // 16: 3 + 13\r\n        4,\r\n        4, // 17: 4 + 13\r\n        0,\r\n        2, // 18: 7 + 11\r\n        1,\r\n        1, // 19: 8 + 11\r\n        2,\r\n        2, // 20: 9 + 11\r\n        3,\r\n        3, // 21: 9 + 12\r\n        1,\r\n        3, // 22: A + 12\r\n        2,\r\n        4, // 23: B + 12\r\n    ];\r\n\r\n    // Vertices[0, 1, ...9, A, B] : position on UV plane\r\n    // '+' indicate duplicate position to be fixed (3,9:0,2,3,4,7,8,A,B)\r\n    // First island of uv mapping\r\n    // v = 4h          3+  2\r\n    // v = 3h        9+  4\r\n    // v = 2h      9+  5   B\r\n    // v = 1h    9   1   0\r\n    // v = 0h  3   8   7   A\r\n    //     u = 0 1 2 3 4 5 6  *a\r\n\r\n    // Second island of uv mapping\r\n    // v = 4h  0+  B+  4+\r\n    // v = 3h    A+  2+\r\n    // v = 2h  7+  6   3+\r\n    // v = 1h    8+  3+\r\n    // v = 0h\r\n    //     u = 0 1 2 3 4 5 6  *a\r\n\r\n    // Face layout on texture UV mapping\r\n    // ============\r\n    // \\ 4  /\\ 16 /   ======\r\n    //  \\  /  \\  /   /\\ 11 /\r\n    //   \\/ 7  \\/   /  \\  /\r\n    //    =======  / 10 \\/\r\n    //   /\\ 17 /\\  =======\r\n    //  /  \\  /  \\ \\ 15 /\\\r\n    // / 8  \\/ 12 \\ \\  /  \\\r\n    // ============  \\/ 6  \\\r\n    // \\ 18 /\\  ============\r\n    //  \\  /  \\ \\ 5  /\\ 0  /\r\n    //   \\/ 13 \\ \\  /  \\  /\r\n    //   =======  \\/ 1  \\/\r\n    //       =============\r\n    //      /\\ 19 /\\  2 /\\\r\n    //     /  \\  /  \\  /  \\\r\n    //    / 14 \\/ 9  \\/  3 \\\r\n    //   ===================\r\n\r\n    // uv step is u:1 or 0.5, v:cos(30)=sqrt(3)/2, ratio approx is 84/97\r\n    const ustep = 138 / 1024;\r\n    const vstep = 239 / 1024;\r\n    const uoffset = 60 / 1024;\r\n    const voffset = 26 / 1024;\r\n    // Second island should have margin, not to touch the first island\r\n    // avoid any borderline artefact in pixel rounding\r\n    const island_u_offset = -40 / 1024;\r\n    const island_v_offset = +20 / 1024;\r\n    // face is either island 0 or 1 :\r\n    // second island is for faces : [4, 7, 8, 12, 13, 16, 17, 18]\r\n    const island = [\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        1, //  0 - 4\r\n        0,\r\n        0,\r\n        1,\r\n        1,\r\n        0, //  5 - 9\r\n        0,\r\n        0,\r\n        1,\r\n        1,\r\n        0, //  10 - 14\r\n        0,\r\n        1,\r\n        1,\r\n        1,\r\n        0, //  15 - 19\r\n    ];\r\n\r\n    const indices = new Array<number>();\r\n    const positions = new Array<number>();\r\n    const normals = new Array<number>();\r\n    const uvs = new Array<number>();\r\n\r\n    let current_indice = 0;\r\n    // prepare array of 3 vector (empty) (to be worked in place, shared for each face)\r\n    const face_vertex_pos = new Array(3);\r\n    const face_vertex_uv = new Array(3);\r\n    let v012;\r\n    for (v012 = 0; v012 < 3; v012++) {\r\n        face_vertex_pos[v012] = Vector3.Zero();\r\n        face_vertex_uv[v012] = Vector2.Zero();\r\n    }\r\n    // create all with normals\r\n    for (let face = 0; face < 20; face++) {\r\n        // 3 vertex per face\r\n        for (v012 = 0; v012 < 3; v012++) {\r\n            // look up vertex 0,1,2 to its index in 0 to 11 (or 23 including alias)\r\n            const v_id = ico_indices[3 * face + v012];\r\n            // vertex have 3D position (x,y,z)\r\n            face_vertex_pos[v012].copyFromFloats(\r\n                icoVertices[3 * vertices_unalias_id[v_id]],\r\n                icoVertices[3 * vertices_unalias_id[v_id] + 1],\r\n                icoVertices[3 * vertices_unalias_id[v_id] + 2]\r\n            );\r\n            // Normalize to get normal\r\n            face_vertex_pos[v012].normalize();\r\n\r\n            // uv Coordinates from vertex ID\r\n            face_vertex_uv[v012].copyFromFloats(\r\n                ico_vertexuv[2 * v_id] * ustep + uoffset + island[face] * island_u_offset,\r\n                ico_vertexuv[2 * v_id + 1] * vstep + voffset + island[face] * island_v_offset\r\n            );\r\n        }\r\n\r\n        // Subdivide the face (interpolate pos, norm, uv)\r\n        // - pos is linear interpolation, then projected to sphere (converge polyhedron to sphere)\r\n        // - norm is linear interpolation of vertex corner normal\r\n        //   (to be checked if better to re-calc from face vertex, or if approximation is OK ??? )\r\n        // - uv is linear interpolation\r\n        //\r\n        // Topology is as below for sub-divide by 2\r\n        // vertex shown as v0,v1,v2\r\n        // interp index is i1 to progress in range [v0,v1[\r\n        // interp index is i2 to progress in range [v0,v2[\r\n        // face index as  (i1,i2)  for /\\  : (i1,i2),(i1+1,i2),(i1,i2+1)\r\n        //            and (i1,i2)' for \\/  : (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\r\n        //\r\n        //\r\n        //                    i2    v2\r\n        //                    ^    ^\r\n        //                   /    / \\\r\n        //                  /    /   \\\r\n        //                 /    /     \\\r\n        //                /    / (0,1) \\\r\n        //               /    #---------\\\r\n        //              /    / \\ (0,0)'/ \\\r\n        //             /    /   \\     /   \\\r\n        //            /    /     \\   /     \\\r\n        //           /    / (0,0) \\ / (1,0) \\\r\n        //          /    #---------#---------\\\r\n        //              v0                    v1\r\n        //\r\n        //              --------------------> i1\r\n        //\r\n        // interp of (i1,i2):\r\n        //  along i2 :  x0=lerp(v0,v2, i2/S) <---> x1=lerp(v1,v2, i2/S)\r\n        //  along i1 :  lerp(x0,x1, i1/(S-i2))\r\n        //\r\n        // centroid of triangle is needed to get help normal computation\r\n        //  (c1,c2) are used for centroid location\r\n\r\n        const interp_vertex = (i1: number, i2: number, c1: number, c2: number) => {\r\n            // vertex is interpolated from\r\n            //   - face_vertex_pos[0..2]\r\n            //   - face_vertex_uv[0..2]\r\n            const pos_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], i2 / subdivisions);\r\n            const pos_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], i2 / subdivisions);\r\n            const pos_interp = subdivisions === i2 ? face_vertex_pos[2] : Vector3.Lerp(pos_x0, pos_x1, i1 / (subdivisions - i2));\r\n            pos_interp.normalize();\r\n\r\n            let vertex_normal;\r\n            if (flat) {\r\n                // in flat mode, recalculate normal as face centroid normal\r\n                const centroid_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], c2 / subdivisions);\r\n                const centroid_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], c2 / subdivisions);\r\n                vertex_normal = Vector3.Lerp(centroid_x0, centroid_x1, c1 / (subdivisions - c2));\r\n            } else {\r\n                // in smooth mode, recalculate normal from each single vertex position\r\n                vertex_normal = new Vector3(pos_interp.x, pos_interp.y, pos_interp.z);\r\n            }\r\n            // Vertex normal need correction due to X,Y,Z radius scaling\r\n            vertex_normal.x /= radiusX;\r\n            vertex_normal.y /= radiusY;\r\n            vertex_normal.z /= radiusZ;\r\n            vertex_normal.normalize();\r\n\r\n            const uv_x0 = Vector2.Lerp(face_vertex_uv[0], face_vertex_uv[2], i2 / subdivisions);\r\n            const uv_x1 = Vector2.Lerp(face_vertex_uv[1], face_vertex_uv[2], i2 / subdivisions);\r\n            const uv_interp = subdivisions === i2 ? face_vertex_uv[2] : Vector2.Lerp(uv_x0, uv_x1, i1 / (subdivisions - i2));\r\n            positions.push(pos_interp.x * radiusX, pos_interp.y * radiusY, pos_interp.z * radiusZ);\r\n            normals.push(vertex_normal.x, vertex_normal.y, vertex_normal.z);\r\n            uvs.push(uv_interp.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - uv_interp.y : uv_interp.y);\r\n            // push each vertex has member of a face\r\n            // Same vertex can belong to multiple face, it is pushed multiple time (duplicate vertex are present)\r\n            indices.push(current_indice);\r\n            current_indice++;\r\n        };\r\n\r\n        for (let i2 = 0; i2 < subdivisions; i2++) {\r\n            for (let i1 = 0; i1 + i2 < subdivisions; i1++) {\r\n                // face : (i1,i2)  for /\\  :\r\n                // interp for : (i1,i2),(i1+1,i2),(i1,i2+1)\r\n                interp_vertex(i1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                interp_vertex(i1 + 1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                interp_vertex(i1, i2 + 1, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                if (i1 + i2 + 1 < subdivisions) {\r\n                    // face : (i1,i2)' for \\/  :\r\n                    // interp for (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\r\n                    interp_vertex(i1 + 1, i2, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                    interp_vertex(i1 + 1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                    interp_vertex(i1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided\r\n * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)\r\n * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)\r\n * * The parameter `subdivisions` sets the number of subdivisions (positive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size\r\n * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.radius\r\n * @param options.radiusX\r\n * @param options.radiusY\r\n * @param options.radiusZ\r\n * @param options.flat\r\n * @param options.subdivisions\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the icosahedron mesh\r\n * @see https://doc.babylonjs.com/how_to/polyhedra_shapes#icosphere\r\n */\r\nexport function CreateIcoSphere(\r\n    name: string,\r\n    options: {\r\n        radius?: number;\r\n        radiusX?: number;\r\n        radiusY?: number;\r\n        radiusZ?: number;\r\n        flat?: boolean;\r\n        subdivisions?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateIcoSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const IcoSphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateIcoSphere,\r\n};\r\n\r\nVertexData.CreateIcoSphere = CreateIcoSphereVertexData;\r\n\r\n(Mesh as any).CreateIcoSphere = (\r\n    name: string,\r\n    options: { radius?: number; flat?: boolean; subdivisions?: number; sideOrientation?: number; updatable?: boolean },\r\n    scene: Scene\r\n): Mesh => {\r\n    return CreateIcoSphere(name, options, scene);\r\n};\r\n", "import { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport { Matrix, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\r\n\r\nimport type { IDisposable, Scene } from \"../../scene\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { InstancedMesh } from \"../../Meshes/instancedMesh\";\r\nimport type { ISceneLoaderAsyncResult } from \"../../Loading/sceneLoader\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial\";\r\nimport type { InputBlock } from \"../../Materials/Node/Blocks/Input/inputBlock\";\r\nimport { Material } from \"../../Materials/material\";\r\nimport { CreateIcoSphere } from \"../../Meshes/Builders/icoSphereBuilder\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\ndeclare const XRHand: XRHand;\r\n\r\n/**\r\n * Configuration interface for the hand tracking feature\r\n */\r\nexport interface IWebXRHandTrackingOptions {\r\n    /**\r\n     * The xrInput that will be used as source for new hands\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Configuration object for the joint meshes.\r\n     */\r\n    jointMeshes?: {\r\n        /**\r\n         * Should the meshes created be invisible (defaults to false).\r\n         */\r\n        invisible?: boolean;\r\n        /**\r\n         * A source mesh to be used to create instances. Defaults to an icosphere with two subdivisions and smooth lighting.\r\n         * This mesh will be the source for all other (25) meshes.\r\n         * It should have the general size of a single unit, as the instances will be scaled according to the provided radius.\r\n         */\r\n        sourceMesh?: Mesh;\r\n        /**\r\n         * This function will be called after a mesh was created for a specific joint.\r\n         * Using this function you can either manipulate the instance or return a new mesh.\r\n         * When returning a new mesh the instance created before will be disposed.\r\n         * @param meshInstance An instance of the original joint mesh being used for the joint.\r\n         * @param jointId The joint's index, see https://immersive-web.github.io/webxr-hand-input/#skeleton-joints-section for more info.\r\n         * @param hand Which hand (\"left\", \"right\") the joint will be on.\r\n         */\r\n        onHandJointMeshGenerated?: (meshInstance: InstancedMesh, jointId: number, hand: XRHandedness) => AbstractMesh | undefined;\r\n        /**\r\n         * Should the source mesh stay visible (defaults to false).\r\n         */\r\n        keepOriginalVisible?: boolean;\r\n        /**\r\n         * Should each instance have its own physics impostor\r\n         */\r\n        enablePhysics?: boolean;\r\n        /**\r\n         * If enabled, override default physics properties\r\n         */\r\n        physicsProps?: { friction?: number; restitution?: number; impostorType?: number };\r\n        /**\r\n         * Scale factor for all joint meshes (defaults to 1)\r\n         */\r\n        scaleFactor?: number;\r\n    };\r\n\r\n    /**\r\n     * Configuration object for the hand meshes.\r\n     */\r\n    handMeshes?: {\r\n        /**\r\n         * Should the default hand mesh be disabled. In this case, the spheres will be visible (unless set invisible).\r\n         */\r\n        disableDefaultMeshes?: boolean;\r\n        /**\r\n         * Rigged hand meshes that will be tracked to the user's hands. This will override the default hand mesh.\r\n         */\r\n        customMeshes?: {\r\n            right: AbstractMesh;\r\n            left: AbstractMesh;\r\n        };\r\n        /**\r\n         * Are the meshes prepared for a left-handed system. Default hand meshes are right-handed.\r\n         */\r\n        meshesUseLeftHandedCoordinates?: boolean;\r\n        /**\r\n         * If a hand mesh was provided, this array will define what axis will update which node. This will override the default hand mesh\r\n         */\r\n        customRigMappings?: {\r\n            right: XRHandMeshRigMapping;\r\n            left: XRHandMeshRigMapping;\r\n        };\r\n\r\n        /**\r\n         * Override the colors of the hand meshes.\r\n         */\r\n        customColors?: {\r\n            base?: Color3;\r\n            fresnel?: Color3;\r\n            fingerColor?: Color3;\r\n            tipFresnel?: Color3;\r\n        };\r\n    };\r\n}\r\n\r\n/**\r\n * Parts of the hands divided to writs and finger names\r\n */\r\nexport enum HandPart {\r\n    /**\r\n     * HandPart - Wrist\r\n     */\r\n    WRIST = \"wrist\",\r\n    /**\r\n     * HandPart - The thumb\r\n     */\r\n    THUMB = \"thumb\",\r\n    /**\r\n     * HandPart - Index finger\r\n     */\r\n    INDEX = \"index\",\r\n    /**\r\n     * HandPart - Middle finger\r\n     */\r\n    MIDDLE = \"middle\",\r\n    /**\r\n     * HandPart - Ring finger\r\n     */\r\n    RING = \"ring\",\r\n    /**\r\n     * HandPart - Little finger\r\n     */\r\n    LITTLE = \"little\",\r\n}\r\n\r\n/**\r\n * Joints of the hand as defined by the WebXR specification.\r\n * https://immersive-web.github.io/webxr-hand-input/#skeleton-joints-section\r\n */\r\nexport enum WebXRHandJoint {\r\n    /** Wrist */\r\n    WRIST = \"wrist\",\r\n\r\n    /** Thumb near wrist */\r\n    THUMB_METACARPAL = \"thumb-metacarpal\",\r\n    /** Thumb first knuckle */\r\n    THUMB_PHALANX_PROXIMAL = \"thumb-phalanx-proximal\",\r\n    /** Thumb second knuckle */\r\n    THUMB_PHALANX_DISTAL = \"thumb-phalanx-distal\",\r\n    /** Thumb tip */\r\n    THUMB_TIP = \"thumb-tip\",\r\n\r\n    /** Index finger near wrist */\r\n    INDEX_FINGER_METACARPAL = \"index-finger-metacarpal\",\r\n    /** Index finger first knuckle */\r\n    INDEX_FINGER_PHALANX_PROXIMAL = \"index-finger-phalanx-proximal\",\r\n    /** Index finger second knuckle */\r\n    INDEX_FINGER_PHALANX_INTERMEDIATE = \"index-finger-phalanx-intermediate\",\r\n    /** Index finger third knuckle */\r\n    INDEX_FINGER_PHALANX_DISTAL = \"index-finger-phalanx-distal\",\r\n    /** Index finger tip */\r\n    INDEX_FINGER_TIP = \"index-finger-tip\",\r\n\r\n    /** Middle finger near wrist */\r\n    MIDDLE_FINGER_METACARPAL = \"middle-finger-metacarpal\",\r\n    /** Middle finger first knuckle */\r\n    MIDDLE_FINGER_PHALANX_PROXIMAL = \"middle-finger-phalanx-proximal\",\r\n    /** Middle finger second knuckle */\r\n    MIDDLE_FINGER_PHALANX_INTERMEDIATE = \"middle-finger-phalanx-intermediate\",\r\n    /** Middle finger third knuckle */\r\n    MIDDLE_FINGER_PHALANX_DISTAL = \"middle-finger-phalanx-distal\",\r\n    /** Middle finger tip */\r\n    MIDDLE_FINGER_TIP = \"middle-finger-tip\",\r\n\r\n    /** Ring finger near wrist */\r\n    RING_FINGER_METACARPAL = \"ring-finger-metacarpal\",\r\n    /** Ring finger first knuckle */\r\n    RING_FINGER_PHALANX_PROXIMAL = \"ring-finger-phalanx-proximal\",\r\n    /** Ring finger second knuckle */\r\n    RING_FINGER_PHALANX_INTERMEDIATE = \"ring-finger-phalanx-intermediate\",\r\n    /** Ring finger third knuckle */\r\n    RING_FINGER_PHALANX_DISTAL = \"ring-finger-phalanx-distal\",\r\n    /** Ring finger tip */\r\n    RING_FINGER_TIP = \"ring-finger-tip\",\r\n\r\n    /** Pinky finger near wrist */\r\n    PINKY_FINGER_METACARPAL = \"pinky-finger-metacarpal\",\r\n    /** Pinky finger first knuckle */\r\n    PINKY_FINGER_PHALANX_PROXIMAL = \"pinky-finger-phalanx-proximal\",\r\n    /** Pinky finger second knuckle */\r\n    PINKY_FINGER_PHALANX_INTERMEDIATE = \"pinky-finger-phalanx-intermediate\",\r\n    /** Pinky finger third knuckle */\r\n    PINKY_FINGER_PHALANX_DISTAL = \"pinky-finger-phalanx-distal\",\r\n    /** Pinky finger tip */\r\n    PINKY_FINGER_TIP = \"pinky-finger-tip\",\r\n}\r\n\r\n/** A type encapsulating a dictionary mapping WebXR joints to bone names in a rigged hand mesh.  */\r\nexport type XRHandMeshRigMapping = { [webXRJointName in WebXRHandJoint]: string };\r\n\r\nconst handJointReferenceArray: WebXRHandJoint[] = [\r\n    WebXRHandJoint.WRIST,\r\n    WebXRHandJoint.THUMB_METACARPAL,\r\n    WebXRHandJoint.THUMB_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.THUMB_PHALANX_DISTAL,\r\n    WebXRHandJoint.THUMB_TIP,\r\n    WebXRHandJoint.INDEX_FINGER_METACARPAL,\r\n    WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.INDEX_FINGER_TIP,\r\n    WebXRHandJoint.MIDDLE_FINGER_METACARPAL,\r\n    WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.MIDDLE_FINGER_TIP,\r\n    WebXRHandJoint.RING_FINGER_METACARPAL,\r\n    WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.RING_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.RING_FINGER_TIP,\r\n    WebXRHandJoint.PINKY_FINGER_METACARPAL,\r\n    WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.PINKY_FINGER_TIP,\r\n];\r\n\r\nconst handPartsDefinition: { [key in HandPart]: WebXRHandJoint[] } = {\r\n    [HandPart.WRIST]: [WebXRHandJoint.WRIST],\r\n    [HandPart.THUMB]: [WebXRHandJoint.THUMB_METACARPAL, WebXRHandJoint.THUMB_PHALANX_PROXIMAL, WebXRHandJoint.THUMB_PHALANX_DISTAL, WebXRHandJoint.THUMB_TIP],\r\n    [HandPart.INDEX]: [\r\n        WebXRHandJoint.INDEX_FINGER_METACARPAL,\r\n        WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.INDEX_FINGER_TIP,\r\n    ],\r\n    [HandPart.MIDDLE]: [\r\n        WebXRHandJoint.MIDDLE_FINGER_METACARPAL,\r\n        WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.MIDDLE_FINGER_TIP,\r\n    ],\r\n    [HandPart.RING]: [\r\n        WebXRHandJoint.RING_FINGER_METACARPAL,\r\n        WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.RING_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.RING_FINGER_TIP,\r\n    ],\r\n    [HandPart.LITTLE]: [\r\n        WebXRHandJoint.PINKY_FINGER_METACARPAL,\r\n        WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.PINKY_FINGER_TIP,\r\n    ],\r\n};\r\n\r\n/**\r\n * Representing a single hand (with its corresponding native XRHand object)\r\n */\r\nexport class WebXRHand implements IDisposable {\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Transform nodes that will directly receive the transforms from the WebXR matrix data.\r\n     */\r\n    private _jointTransforms = new Array<TransformNode>(handJointReferenceArray.length);\r\n\r\n    /**\r\n     * The float array that will directly receive the transform matrix data from WebXR.\r\n     */\r\n    private _jointTransformMatrices = new Float32Array(handJointReferenceArray.length * 16);\r\n\r\n    private _tempJointMatrix = new Matrix();\r\n\r\n    /**\r\n     * The float array that will directly receive the joint radii from WebXR.\r\n     */\r\n    private _jointRadii = new Float32Array(handJointReferenceArray.length);\r\n\r\n    /**\r\n     * Get the hand mesh.\r\n     */\r\n    public get handMesh(): Nullable<AbstractMesh> {\r\n        return this._handMesh;\r\n    }\r\n\r\n    /**\r\n     * Get meshes of part of the hand.\r\n     * @param part The part of hand to get.\r\n     * @returns An array of meshes that correlate to the hand part requested.\r\n     */\r\n    public getHandPartMeshes(part: HandPart): AbstractMesh[] {\r\n        return handPartsDefinition[part].map((name) => this._jointMeshes[handJointReferenceArray.indexOf(name)]!);\r\n    }\r\n\r\n    /**\r\n     * Retrieves a mesh linked to a named joint in the hand.\r\n     * @param jointName The name of the joint.\r\n     * @returns An AbstractMesh whose position corresponds with the joint position.\r\n     */\r\n    public getJointMesh(jointName: WebXRHandJoint): AbstractMesh {\r\n        return this._jointMeshes[handJointReferenceArray.indexOf(jointName)!];\r\n    }\r\n\r\n    /**\r\n     * Construct a new hand object\r\n     * @param xrController The controller to which the hand correlates.\r\n     * @param _jointMeshes The meshes to be used to track the hand joints.\r\n     * @param _handMesh An optional hand mesh.\r\n     * @param rigMapping An optional rig mapping for the hand mesh.\r\n     *                   If not provided (but a hand mesh is provided),\r\n     *                   it will be assumed that the hand mesh's bones are named\r\n     *                   directly after the WebXR bone names.\r\n     * @param _leftHandedMeshes Are the hand meshes left-handed-system meshes\r\n     * @param _jointsInvisible Are the tracked joint meshes visible\r\n     * @param _jointScaleFactor Scale factor for all joint meshes\r\n     */\r\n    constructor(\r\n        /** The controller to which the hand correlates. */\r\n        public readonly xrController: WebXRInputSource,\r\n        private readonly _jointMeshes: AbstractMesh[],\r\n        private _handMesh: Nullable<AbstractMesh>,\r\n        /** An optional rig mapping for the hand mesh. If not provided (but a hand mesh is provided),\r\n         * it will be assumed that the hand mesh's bones are named directly after the WebXR bone names. */\r\n        readonly rigMapping: Nullable<XRHandMeshRigMapping>,\r\n        private readonly _leftHandedMeshes: boolean = false,\r\n        private readonly _jointsInvisible: boolean = false,\r\n        private readonly _jointScaleFactor: number = 1\r\n    ) {\r\n        this._scene = _jointMeshes[0].getScene();\r\n\r\n        // Initialize the joint transform quaternions and link the transforms to the bones.\r\n        for (let jointIdx = 0; jointIdx < this._jointTransforms.length; jointIdx++) {\r\n            const jointTransform = (this._jointTransforms[jointIdx] = new TransformNode(handJointReferenceArray[jointIdx], this._scene));\r\n            jointTransform.rotationQuaternion = new Quaternion();\r\n\r\n            // Set the rotation quaternion so we can use it later for tracking.\r\n            _jointMeshes[jointIdx].rotationQuaternion = new Quaternion();\r\n        }\r\n\r\n        if (_handMesh) {\r\n            // Note that this logic needs to happen after we initialize the joint tracking transform nodes.\r\n            this.setHandMesh(_handMesh, rigMapping);\r\n        }\r\n\r\n        // hide the motion controller, if available/loaded\r\n        if (this.xrController.motionController) {\r\n            if (this.xrController.motionController.rootMesh) {\r\n                this.xrController.motionController.rootMesh.setEnabled(false);\r\n            } else {\r\n                this.xrController.motionController.onModelLoadedObservable.add((controller) => {\r\n                    if (controller.rootMesh) {\r\n                        controller.rootMesh.setEnabled(false);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        this.xrController.onMotionControllerInitObservable.add((motionController) => {\r\n            motionController.onModelLoadedObservable.add((controller) => {\r\n                if (controller.rootMesh) {\r\n                    controller.rootMesh.setEnabled(false);\r\n                }\r\n            });\r\n            if (motionController.rootMesh) {\r\n                motionController.rootMesh.setEnabled(false);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the current hand mesh to render for the WebXRHand.\r\n     * @param handMesh The rigged hand mesh that will be tracked to the user's hand.\r\n     * @param rigMapping The mapping from XRHandJoint to bone names to use with the mesh.\r\n     */\r\n    public setHandMesh(handMesh: AbstractMesh, rigMapping: Nullable<XRHandMeshRigMapping>) {\r\n        this._handMesh = handMesh;\r\n\r\n        // Avoid any strange frustum culling. We will manually control visibility via attach and detach.\r\n        handMesh.alwaysSelectAsActiveMesh = true;\r\n        handMesh.getChildMeshes().forEach((mesh) => (mesh.alwaysSelectAsActiveMesh = true));\r\n\r\n        // Link the bones in the hand mesh to the transform nodes that will be bound to the WebXR tracked joints.\r\n        if (this._handMesh.skeleton) {\r\n            const handMeshSkeleton = this._handMesh.skeleton;\r\n            handJointReferenceArray.forEach((jointName, jointIdx) => {\r\n                const jointBoneIdx = handMeshSkeleton.getBoneIndexByName(rigMapping ? rigMapping[jointName] : jointName);\r\n                if (jointBoneIdx !== -1) {\r\n                    handMeshSkeleton.bones[jointBoneIdx].linkTransformNode(this._jointTransforms[jointIdx]);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update this hand from the latest xr frame.\r\n     * @param xrFrame The latest frame received from WebXR.\r\n     * @param referenceSpace The current viewer reference space.\r\n     */\r\n    public updateFromXRFrame(xrFrame: XRFrame, referenceSpace: XRReferenceSpace) {\r\n        const hand = this.xrController.inputSource.hand;\r\n        if (!hand) {\r\n            return;\r\n        }\r\n\r\n        // TODO: Modify webxr.d.ts to better match WebXR IDL so we don't need this any cast.\r\n        const anyHand: any = hand;\r\n        const jointSpaces: XRJointSpace[] = handJointReferenceArray.map((jointName) => anyHand[jointName] || hand.get(jointName));\r\n        let trackingSuccessful = false;\r\n\r\n        if (xrFrame.fillPoses && xrFrame.fillJointRadii) {\r\n            trackingSuccessful = xrFrame.fillPoses(jointSpaces, referenceSpace, this._jointTransformMatrices) && xrFrame.fillJointRadii(jointSpaces, this._jointRadii);\r\n        } else if (xrFrame.getJointPose) {\r\n            trackingSuccessful = true;\r\n            // Warning: This codepath is slow by comparison, only here for compat.\r\n            for (let jointIdx = 0; jointIdx < jointSpaces.length; jointIdx++) {\r\n                const jointPose = xrFrame.getJointPose(jointSpaces[jointIdx], referenceSpace);\r\n                if (jointPose) {\r\n                    this._jointTransformMatrices.set(jointPose.transform.matrix, jointIdx * 16);\r\n                    this._jointRadii[jointIdx] = jointPose.radius || 0.008;\r\n                } else {\r\n                    trackingSuccessful = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!trackingSuccessful) {\r\n            return;\r\n        }\r\n\r\n        handJointReferenceArray.forEach((_jointName, jointIdx) => {\r\n            const jointTransform = this._jointTransforms[jointIdx];\r\n            Matrix.FromArrayToRef(this._jointTransformMatrices, jointIdx * 16, this._tempJointMatrix);\r\n            this._tempJointMatrix.decompose(undefined, jointTransform.rotationQuaternion!, jointTransform.position);\r\n\r\n            // The radius we need to make the joint in order for it to roughly cover the joints of the user's real hand.\r\n            const scaledJointRadius = this._jointRadii[jointIdx] * this._jointScaleFactor;\r\n\r\n            const jointMesh = this._jointMeshes[jointIdx];\r\n            jointMesh.isVisible = !this._handMesh && !this._jointsInvisible;\r\n            jointMesh.position.copyFrom(jointTransform.position);\r\n            jointMesh.rotationQuaternion!.copyFrom(jointTransform.rotationQuaternion!);\r\n            jointMesh.scaling.setAll(scaledJointRadius);\r\n\r\n            // The WebXR data comes as right-handed, so we might need to do some conversions.\r\n            if (!this._scene.useRightHandedSystem) {\r\n                jointMesh.position.z *= -1;\r\n                jointMesh.rotationQuaternion!.z *= -1;\r\n                jointMesh.rotationQuaternion!.w *= -1;\r\n\r\n                if (this._leftHandedMeshes && this._handMesh) {\r\n                    jointTransform.position.z *= -1;\r\n                    jointTransform.rotationQuaternion!.z *= -1;\r\n                    jointTransform.rotationQuaternion!.w *= -1;\r\n                }\r\n            }\r\n        });\r\n\r\n        if (this._handMesh) {\r\n            this._handMesh.isVisible = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose this Hand object\r\n     */\r\n    public dispose() {\r\n        if (this._handMesh) {\r\n            this._handMesh.isVisible = false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * WebXR Hand Joint tracking feature, available for selected browsers and devices\r\n */\r\nexport class WebXRHandTracking extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.HAND_TRACKING;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /** The base URL for the default hand model. */\r\n    public static DEFAULT_HAND_MODEL_BASE_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/\";\r\n    /** The filename to use for the default right hand model. */\r\n    public static DEFAULT_HAND_MODEL_RIGHT_FILENAME = \"r_hand_rhs.glb\";\r\n    /** The filename to use for the default left hand model. */\r\n    public static DEFAULT_HAND_MODEL_LEFT_FILENAME = \"l_hand_rhs.glb\";\r\n    /** The URL pointing to the default hand model NodeMaterial shader. */\r\n    public static DEFAULT_HAND_MODEL_SHADER_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/handsShader.json\";\r\n\r\n    // We want to use lightweight models, diameter will initially be 1 but scaled to the values returned from WebXR.\r\n    private static readonly _ICOSPHERE_PARAMS = { radius: 0.5, flat: false, subdivisions: 2 };\r\n\r\n    private static _RightHandGLB: Nullable<ISceneLoaderAsyncResult> = null;\r\n    private static _LeftHandGLB: Nullable<ISceneLoaderAsyncResult> = null;\r\n\r\n    private static _GenerateTrackedJointMeshes(featureOptions: IWebXRHandTrackingOptions): { left: AbstractMesh[]; right: AbstractMesh[] } {\r\n        const meshes: { [handedness: string]: AbstractMesh[] } = {};\r\n        [\"left\" as XRHandedness, \"right\" as XRHandedness].map((handedness) => {\r\n            const trackedMeshes = [];\r\n            const originalMesh = featureOptions.jointMeshes?.sourceMesh || CreateIcoSphere(\"jointParent\", WebXRHandTracking._ICOSPHERE_PARAMS);\r\n            originalMesh.isVisible = !!featureOptions.jointMeshes?.keepOriginalVisible;\r\n            for (let i = 0; i < handJointReferenceArray.length; ++i) {\r\n                let newInstance: AbstractMesh = originalMesh.createInstance(`${handedness}-handJoint-${i}`);\r\n                if (featureOptions.jointMeshes?.onHandJointMeshGenerated) {\r\n                    const returnedMesh = featureOptions.jointMeshes.onHandJointMeshGenerated(newInstance as InstancedMesh, i, handedness);\r\n                    if (returnedMesh) {\r\n                        if (returnedMesh !== newInstance) {\r\n                            newInstance.dispose();\r\n                            newInstance = returnedMesh;\r\n                        }\r\n                    }\r\n                }\r\n                newInstance.isPickable = false;\r\n                if (featureOptions.jointMeshes?.enablePhysics) {\r\n                    const props = featureOptions.jointMeshes?.physicsProps || {};\r\n                    // downscale the instances so that physics will be initialized correctly\r\n                    newInstance.scaling.setAll(0.02);\r\n                    const type = props.impostorType !== undefined ? props.impostorType : PhysicsImpostor.SphereImpostor;\r\n                    newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, { mass: 0, ...props });\r\n                }\r\n                newInstance.rotationQuaternion = new Quaternion();\r\n                newInstance.isVisible = false;\r\n                trackedMeshes.push(newInstance);\r\n            }\r\n\r\n            meshes[handedness] = trackedMeshes;\r\n        });\r\n        return { left: meshes.left, right: meshes.right };\r\n    }\r\n\r\n    private static _GenerateDefaultHandMeshesAsync(scene: Scene, options?: IWebXRHandTrackingOptions): Promise<{ left: AbstractMesh; right: AbstractMesh }> {\r\n        // eslint-disable-next-line no-async-promise-executor\r\n        return new Promise(async (resolve) => {\r\n            const riggedMeshes: { [handedness: string]: AbstractMesh } = {};\r\n            // check the cache, defensive\r\n            if (WebXRHandTracking._RightHandGLB?.meshes[1]?.isDisposed()) {\r\n                WebXRHandTracking._RightHandGLB = null;\r\n            }\r\n            if (WebXRHandTracking._LeftHandGLB?.meshes[1]?.isDisposed()) {\r\n                WebXRHandTracking._LeftHandGLB = null;\r\n            }\r\n\r\n            const handsDefined = !!(WebXRHandTracking._RightHandGLB && WebXRHandTracking._LeftHandGLB);\r\n            // load them in parallel\r\n            const handGLBs = await Promise.all([\r\n                WebXRHandTracking._RightHandGLB ||\r\n                    SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME, scene),\r\n                WebXRHandTracking._LeftHandGLB ||\r\n                    SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME, scene),\r\n            ]);\r\n            WebXRHandTracking._RightHandGLB = handGLBs[0];\r\n            WebXRHandTracking._LeftHandGLB = handGLBs[1];\r\n\r\n            const handShader = new NodeMaterial(\"handShader\", scene, { emitComments: false });\r\n            await handShader.loadAsync(WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL);\r\n\r\n            // depth prepass and alpha mode\r\n            handShader.needDepthPrePass = true;\r\n            handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;\r\n            handShader.alphaMode = Constants.ALPHA_COMBINE;\r\n\r\n            // build node materials\r\n            handShader.build(false);\r\n\r\n            // shader\r\n            const handColors = {\r\n                base: Color3.FromInts(116, 63, 203),\r\n                fresnel: Color3.FromInts(149, 102, 229),\r\n                fingerColor: Color3.FromInts(177, 130, 255),\r\n                tipFresnel: Color3.FromInts(220, 200, 255),\r\n                ...options?.handMeshes?.customColors,\r\n            };\r\n\r\n            const handNodes = {\r\n                base: handShader.getBlockByName(\"baseColor\") as InputBlock,\r\n                fresnel: handShader.getBlockByName(\"fresnelColor\") as InputBlock,\r\n                fingerColor: handShader.getBlockByName(\"fingerColor\") as InputBlock,\r\n                tipFresnel: handShader.getBlockByName(\"tipFresnelColor\") as InputBlock,\r\n            };\r\n\r\n            handNodes.base.value = handColors.base;\r\n            handNodes.fresnel.value = handColors.fresnel;\r\n            handNodes.fingerColor.value = handColors.fingerColor;\r\n            handNodes.tipFresnel.value = handColors.tipFresnel;\r\n\r\n            [\"left\", \"right\"].forEach((handedness) => {\r\n                const handGLB = handedness == \"left\" ? WebXRHandTracking._LeftHandGLB : WebXRHandTracking._RightHandGLB;\r\n                if (!handGLB) {\r\n                    // this should never happen!\r\n                    throw new Error(\"Could not load hand model\");\r\n                }\r\n                const handMesh = handGLB.meshes[1];\r\n                handMesh._internalAbstractMeshDataInfo._computeBonesUsingShaders = true;\r\n                handMesh.material = handShader.clone(`${handedness}HandShaderClone`, true);\r\n                handMesh.isVisible = false;\r\n\r\n                riggedMeshes[handedness] = handMesh;\r\n\r\n                // single change for left handed systems\r\n                if (!handsDefined && !scene.useRightHandedSystem) {\r\n                    handGLB.meshes[1].rotate(Axis.Y, Math.PI);\r\n                }\r\n            });\r\n\r\n            handShader.dispose();\r\n            resolve({ left: riggedMeshes.left, right: riggedMeshes.right });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates a mapping from XRHandJoint to bone name for the default hand mesh.\r\n     * @param handedness The handedness being mapped for.\r\n     */\r\n    private static _GenerateDefaultHandMeshRigMapping(handedness: XRHandedness): XRHandMeshRigMapping {\r\n        const H = handedness == \"right\" ? \"R\" : \"L\";\r\n        return {\r\n            [WebXRHandJoint.WRIST]: `wrist_${H}`,\r\n            [WebXRHandJoint.THUMB_METACARPAL]: `thumb_metacarpal_${H}`,\r\n            [WebXRHandJoint.THUMB_PHALANX_PROXIMAL]: `thumb_proxPhalanx_${H}`,\r\n            [WebXRHandJoint.THUMB_PHALANX_DISTAL]: `thumb_distPhalanx_${H}`,\r\n            [WebXRHandJoint.THUMB_TIP]: `thumb_tip_${H}`,\r\n            [WebXRHandJoint.INDEX_FINGER_METACARPAL]: `index_metacarpal_${H}`,\r\n            [WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL]: `index_proxPhalanx_${H}`,\r\n            [WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE]: `index_intPhalanx_${H}`,\r\n            [WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL]: `index_distPhalanx_${H}`,\r\n            [WebXRHandJoint.INDEX_FINGER_TIP]: `index_tip_${H}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_METACARPAL]: `middle_metacarpal_${H}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL]: `middle_proxPhalanx_${H}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE]: `middle_intPhalanx_${H}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL]: `middle_distPhalanx_${H}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_TIP]: `middle_tip_${H}`,\r\n            [WebXRHandJoint.RING_FINGER_METACARPAL]: `ring_metacarpal_${H}`,\r\n            [WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL]: `ring_proxPhalanx_${H}`,\r\n            [WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE]: `ring_intPhalanx_${H}`,\r\n            [WebXRHandJoint.RING_FINGER_PHALANX_DISTAL]: `ring_distPhalanx_${H}`,\r\n            [WebXRHandJoint.RING_FINGER_TIP]: `ring_tip_${H}`,\r\n            [WebXRHandJoint.PINKY_FINGER_METACARPAL]: `little_metacarpal_${H}`,\r\n            [WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL]: `little_proxPhalanx_${H}`,\r\n            [WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE]: `little_intPhalanx_${H}`,\r\n            [WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL]: `little_distPhalanx_${H}`,\r\n            [WebXRHandJoint.PINKY_FINGER_TIP]: `little_tip_${H}`,\r\n        };\r\n    }\r\n\r\n    private _attachedHands: {\r\n        [uniqueId: string]: WebXRHand;\r\n    } = {};\r\n\r\n    private _trackingHands: {\r\n        left: Nullable<WebXRHand>;\r\n        right: Nullable<WebXRHand>;\r\n    } = { left: null, right: null };\r\n\r\n    private _handResources: {\r\n        jointMeshes: Nullable<{ left: AbstractMesh[]; right: AbstractMesh[] }>;\r\n        handMeshes: Nullable<{ left: AbstractMesh; right: AbstractMesh }>;\r\n        rigMappings: Nullable<{ left: XRHandMeshRigMapping; right: XRHandMeshRigMapping }>;\r\n    } = { jointMeshes: null, handMeshes: null, rigMappings: null };\r\n\r\n    /**\r\n     * This observable will notify registered observers when a new hand object was added and initialized\r\n     */\r\n    public onHandAddedObservable: Observable<WebXRHand> = new Observable();\r\n    /**\r\n     * This observable will notify its observers right before the hand object is disposed\r\n     */\r\n    public onHandRemovedObservable: Observable<WebXRHand> = new Observable();\r\n\r\n    /**\r\n     * Check if the needed objects are defined.\r\n     * This does not mean that the feature is enabled, but that the objects needed are well defined.\r\n     */\r\n    public isCompatible(): boolean {\r\n        return typeof XRHand !== \"undefined\";\r\n    }\r\n\r\n    /**\r\n     * Get the hand object according to the controller id\r\n     * @param controllerId the controller id to which we want to get the hand\r\n     * @returns null if not found or the WebXRHand object if found\r\n     */\r\n    public getHandByControllerId(controllerId: string): Nullable<WebXRHand> {\r\n        return this._attachedHands[controllerId];\r\n    }\r\n\r\n    /**\r\n     * Get a hand object according to the requested handedness\r\n     * @param handedness the handedness to request\r\n     * @returns null if not found or the WebXRHand object if found\r\n     */\r\n    public getHandByHandedness(handedness: XRHandedness): Nullable<WebXRHand> {\r\n        if (handedness == \"none\") {\r\n            return null;\r\n        }\r\n        return this._trackingHands[handedness];\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of the XR hand tracking feature.\r\n     * @param _xrSessionManager An instance of WebXRSessionManager.\r\n     * @param options Options to use when constructing this feature.\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /** Options to use when constructing this feature. */\r\n        public readonly options: IWebXRHandTrackingOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"hand-tracking\";\r\n\r\n        // Support legacy versions of the options object by copying over joint mesh properties\r\n        const anyOptions = options as any;\r\n        const anyJointMeshOptions = anyOptions.jointMeshes;\r\n        if (anyJointMeshOptions) {\r\n            if (typeof anyJointMeshOptions.disableDefaultHandMesh !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                options.handMeshes.disableDefaultMeshes = anyJointMeshOptions.disableDefaultHandMesh;\r\n            }\r\n            if (typeof anyJointMeshOptions.handMeshes !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                options.handMeshes.customMeshes = anyJointMeshOptions.handMeshes;\r\n            }\r\n            if (typeof anyJointMeshOptions.leftHandedSystemMeshes !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                options.handMeshes.meshesUseLeftHandedCoordinates = anyJointMeshOptions.leftHandedSystemMeshes;\r\n            }\r\n            if (typeof anyJointMeshOptions.rigMapping !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                const leftRigMapping = {};\r\n                const rightRigMapping = {};\r\n                [\r\n                    [anyJointMeshOptions.rigMapping.left, leftRigMapping],\r\n                    [anyJointMeshOptions.rigMapping.right, rightRigMapping],\r\n                ].forEach((rigMappingTuple) => {\r\n                    const legacyRigMapping = rigMappingTuple[0] as string[];\r\n                    const rigMapping = rigMappingTuple[1] as XRHandMeshRigMapping;\r\n                    legacyRigMapping.forEach((modelJointName, index) => {\r\n                        rigMapping[handJointReferenceArray[index]] = modelJointName;\r\n                    });\r\n                });\r\n                options.handMeshes.customRigMappings = {\r\n                    left: leftRigMapping as XRHandMeshRigMapping,\r\n                    right: rightRigMapping as XRHandMeshRigMapping,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach this feature.\r\n     * Will usually be called by the features manager.\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._handResources = {\r\n            jointMeshes: WebXRHandTracking._GenerateTrackedJointMeshes(this.options),\r\n            handMeshes: this.options.handMeshes?.customMeshes || null,\r\n            rigMappings: this.options.handMeshes?.customRigMappings || null,\r\n        };\r\n\r\n        // If they didn't supply custom meshes and are not disabling the default meshes...\r\n        if (!this.options.handMeshes?.customMeshes && !this.options.handMeshes?.disableDefaultMeshes) {\r\n            WebXRHandTracking._GenerateDefaultHandMeshesAsync(EngineStore.LastCreatedScene!, this.options).then((defaultHandMeshes) => {\r\n                this._handResources.handMeshes = defaultHandMeshes;\r\n                this._handResources.rigMappings = {\r\n                    left: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"left\"),\r\n                    right: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"right\"),\r\n                };\r\n\r\n                // Apply meshes to existing hands if already tracking.\r\n                this._trackingHands.left?.setHandMesh(this._handResources.handMeshes.left, this._handResources.rigMappings.left);\r\n                this._trackingHands.right?.setHandMesh(this._handResources.handMeshes.right, this._handResources.rigMappings.right);\r\n            });\r\n        }\r\n\r\n        this.options.xrInput.controllers.forEach(this._attachHand);\r\n        this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);\r\n        this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, this._detachHand);\r\n\r\n        return true;\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        this._trackingHands.left?.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\r\n        this._trackingHands.right?.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\r\n    }\r\n\r\n    private _attachHand = (xrController: WebXRInputSource) => {\r\n        if (!xrController.inputSource.hand || xrController.inputSource.handedness == \"none\" || !this._handResources.jointMeshes) {\r\n            return;\r\n        }\r\n\r\n        const handedness = xrController.inputSource.handedness;\r\n        const webxrHand = new WebXRHand(\r\n            xrController,\r\n            this._handResources.jointMeshes[handedness],\r\n            this._handResources.handMeshes && this._handResources.handMeshes[handedness],\r\n            this._handResources.rigMappings && this._handResources.rigMappings[handedness],\r\n            this.options.handMeshes?.meshesUseLeftHandedCoordinates,\r\n            this.options.jointMeshes?.invisible,\r\n            this.options.jointMeshes?.scaleFactor\r\n        );\r\n\r\n        this._attachedHands[xrController.uniqueId] = webxrHand;\r\n        this._trackingHands[handedness] = webxrHand;\r\n\r\n        this.onHandAddedObservable.notifyObservers(webxrHand);\r\n    };\r\n\r\n    private _detachHandById(controllerId: string) {\r\n        const hand = this.getHandByControllerId(controllerId);\r\n        if (hand) {\r\n            const handedness = hand.xrController.inputSource.handedness == \"left\" ? \"left\" : \"right\";\r\n            if (this._trackingHands[handedness]?.xrController.uniqueId === controllerId) {\r\n                this._trackingHands[handedness] = null;\r\n            }\r\n            this.onHandRemovedObservable.notifyObservers(hand);\r\n            hand.dispose();\r\n            delete this._attachedHands[controllerId];\r\n        }\r\n    }\r\n\r\n    private _detachHand = (xrController: WebXRInputSource) => {\r\n        this._detachHandById(xrController.uniqueId);\r\n    };\r\n\r\n    /**\r\n     * Detach this feature.\r\n     * Will usually be called by the features manager.\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._attachedHands).forEach((uniqueId) => this._detachHandById(uniqueId));\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onHandAddedObservable.clear();\r\n        this.onHandRemovedObservable.clear();\r\n\r\n        if (this._handResources.handMeshes && !this.options.handMeshes?.customMeshes) {\r\n            // this will dispose the cached meshes\r\n            this._handResources.handMeshes.left.dispose();\r\n            this._handResources.handMeshes.right.dispose();\r\n            // remove the cached meshes\r\n            WebXRHandTracking._RightHandGLB = null;\r\n            WebXRHandTracking._LeftHandGLB = null;\r\n        }\r\n\r\n        if (this._handResources.jointMeshes) {\r\n            this._handResources.jointMeshes.left.forEach((trackedMesh) => trackedMesh.dispose());\r\n            this._handResources.jointMeshes.right.forEach((trackedMesh) => trackedMesh.dispose());\r\n        }\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRHandTracking.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRHandTracking(xrSessionManager, options);\r\n    },\r\n    WebXRHandTracking.Version,\r\n    false\r\n);\r\n", "import type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebXRFeatureName } from \"../../XR/webXRFeaturesManager\";\r\nimport type { WebXREyeTracking } from \"../../XR/features/WebXREyeTracking\";\r\nimport type { WebXRHandTracking } from \"../../XR/features/WebXRHandTracking\";\r\nimport { WebXRHandJoint } from \"../../XR/features/WebXRHandTracking\";\r\nimport type { WebXRExperienceHelper } from \"../../XR/webXRExperienceHelper\";\r\nimport type { Behavior } from \"../behavior\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\n\r\n/**\r\n * Zones around the hand\r\n */\r\nexport enum HandConstraintZone {\r\n    /**\r\n     * Above finger tips\r\n     */\r\n    ABOVE_FINGER_TIPS,\r\n    /**\r\n     * Next to the thumb\r\n     */\r\n    RADIAL_SIDE,\r\n    /**\r\n     * Next to the pinky finger\r\n     */\r\n    ULNAR_SIDE,\r\n    /**\r\n     * Below the wrist\r\n     */\r\n    BELOW_WRIST,\r\n}\r\n\r\n/**\r\n * Orientations for the hand zones and for the attached node\r\n */\r\nexport enum HandConstraintOrientation {\r\n    /**\r\n     * Orientation is towards the camera\r\n     */\r\n    LOOK_AT_CAMERA,\r\n    /**\r\n     * Orientation is determined by the rotation of the palm\r\n     */\r\n    HAND_ROTATION,\r\n}\r\n\r\n/**\r\n * Orientations for the hand zones and for the attached node\r\n */\r\nexport enum HandConstraintVisibility {\r\n    /**\r\n     * Constraint is always visible\r\n     */\r\n    ALWAYS_VISIBLE,\r\n    /**\r\n     * Constraint is only visible when the palm is up\r\n     */\r\n    PALM_UP,\r\n    /**\r\n     * Constraint is only visible when the user is looking at the constraint.\r\n     * Uses XR Eye Tracking if enabled/available, otherwise uses camera direction\r\n     */\r\n    GAZE_FOCUS,\r\n    /**\r\n     * Constraint is only visible when the palm is up and the user is looking at it\r\n     */\r\n    PALM_AND_GAZE,\r\n}\r\n\r\ntype HandPoseInfo = {\r\n    position: Vector3;\r\n    quaternion: Quaternion;\r\n    id: string;\r\n};\r\n\r\n/**\r\n * Hand constraint behavior that makes the attached `TransformNode` follow hands in XR experiences.\r\n * @since 5.0.0\r\n */\r\nexport class HandConstraintBehavior implements Behavior<TransformNode> {\r\n    private _scene: Scene;\r\n    private _node: TransformNode;\r\n    private _eyeTracking: Nullable<WebXREyeTracking>;\r\n    private _handTracking: Nullable<WebXRHandTracking>;\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>> = null;\r\n    private _zoneAxis: { [id: number]: Vector3 } = {};\r\n\r\n    /**\r\n     * Sets the HandConstraintVisibility level for the hand constraint\r\n     */\r\n    public handConstraintVisibility: HandConstraintVisibility = HandConstraintVisibility.PALM_AND_GAZE;\r\n\r\n    /**\r\n     * A number from 0.0 to 1.0, marking how restricted the direction the palm faces is for the attached node to be enabled.\r\n     * A 1 means the palm must be directly facing the user before the node is enabled, a 0 means it is always enabled.\r\n     * Used with HandConstraintVisibility.PALM_UP\r\n     */\r\n    public palmUpStrictness: number = 0.95;\r\n\r\n    /**\r\n     * The radius in meters around the center of the hand that the user must gaze inside for the attached node to be enabled and appear.\r\n     * Used with HandConstraintVisibility.GAZE_FOCUS\r\n     */\r\n    public gazeProximityRadius: number = 0.15;\r\n\r\n    /**\r\n     * Offset distance from the hand in meters\r\n     */\r\n    public targetOffset: number = 0.1;\r\n\r\n    /**\r\n     * Where to place the node regarding the center of the hand.\r\n     */\r\n    public targetZone: HandConstraintZone = HandConstraintZone.ULNAR_SIDE;\r\n\r\n    /**\r\n     * Orientation mode of the 4 zones around the hand\r\n     */\r\n    public zoneOrientationMode: HandConstraintOrientation = HandConstraintOrientation.HAND_ROTATION;\r\n    /**\r\n     * Orientation mode of the node attached to this behavior\r\n     */\r\n    public nodeOrientationMode: HandConstraintOrientation = HandConstraintOrientation.HAND_ROTATION;\r\n\r\n    /**\r\n     * Set the hand this behavior should follow. If set to \"none\", it will follow any visible hand (prioritising the left one).\r\n     */\r\n    public handedness: XRHandedness = \"none\";\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 100;\r\n\r\n    /**\r\n     * Builds a hand constraint behavior\r\n     */\r\n    constructor() {\r\n        // For a right hand\r\n        this._zoneAxis[HandConstraintZone.ABOVE_FINGER_TIPS] = new Vector3(0, 1, 0);\r\n        this._zoneAxis[HandConstraintZone.RADIAL_SIDE] = new Vector3(-1, 0, 0);\r\n        this._zoneAxis[HandConstraintZone.ULNAR_SIDE] = new Vector3(1, 0, 0);\r\n        this._zoneAxis[HandConstraintZone.BELOW_WRIST] = new Vector3(0, -1, 0);\r\n    }\r\n\r\n    /** gets or sets behavior's name */\r\n    public get name() {\r\n        return \"HandConstraint\";\r\n    }\r\n\r\n    /** Enable the behavior */\r\n    public enable() {\r\n        this._node.setEnabled(true);\r\n    }\r\n\r\n    /** Disable the behavior */\r\n    public disable() {\r\n        this._node.setEnabled(false);\r\n    }\r\n\r\n    private _getHandPose(): Nullable<HandPoseInfo> {\r\n        if (!this._handTracking) {\r\n            return null;\r\n        }\r\n\r\n        // Retrieve any available hand, starting by the left\r\n        let hand;\r\n        if (this.handedness === \"none\") {\r\n            hand = this._handTracking.getHandByHandedness(\"left\") || this._handTracking.getHandByHandedness(\"right\");\r\n        } else {\r\n            hand = this._handTracking.getHandByHandedness(this.handedness);\r\n        }\r\n\r\n        if (hand) {\r\n            const pinkyMetacarpal = hand.getJointMesh(WebXRHandJoint.PINKY_FINGER_METACARPAL);\r\n            const middleMetacarpal = hand.getJointMesh(WebXRHandJoint.MIDDLE_FINGER_METACARPAL);\r\n            const wrist = hand.getJointMesh(WebXRHandJoint.WRIST);\r\n\r\n            if (wrist && middleMetacarpal && pinkyMetacarpal) {\r\n                const handPose: HandPoseInfo = { position: middleMetacarpal.absolutePosition, quaternion: new Quaternion(), id: hand.xrController.uniqueId };\r\n\r\n                // palm forward\r\n                const up = TmpVectors.Vector3[0];\r\n                const forward = TmpVectors.Vector3[1];\r\n                const left = TmpVectors.Vector3[2];\r\n                up.copyFrom(middleMetacarpal.absolutePosition).subtractInPlace(wrist.absolutePosition).normalize();\r\n                forward.copyFrom(pinkyMetacarpal.absolutePosition).subtractInPlace(middleMetacarpal.absolutePosition).normalize();\r\n\r\n                // Create vectors for a rotation quaternion, where forward points out from the palm\r\n                Vector3.CrossToRef(up, forward, forward);\r\n                Vector3.CrossToRef(forward, up, left);\r\n\r\n                Quaternion.FromLookDirectionLHToRef(forward, up, handPose.quaternion);\r\n\r\n                return handPose;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Initializes the hand constraint behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Attaches the hand constraint to a `TransformNode`\r\n     * @param node defines the node to attach the behavior to\r\n     */\r\n    public attach(node: TransformNode): void {\r\n        this._node = node;\r\n        this._scene = node.getScene();\r\n\r\n        if (!this._node.rotationQuaternion) {\r\n            this._node.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._node.rotation.y, this._node.rotation.x, this._node.rotation.z);\r\n        }\r\n\r\n        let lastTick = Date.now();\r\n        this._sceneRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n            const pose = this._getHandPose();\r\n\r\n            this._node.reservedDataStore = this._node.reservedDataStore || {};\r\n            this._node.reservedDataStore.nearInteraction = this._node.reservedDataStore.nearInteraction || {};\r\n            this._node.reservedDataStore.nearInteraction.excludedControllerId = null;\r\n\r\n            if (pose) {\r\n                const zoneOffset = TmpVectors.Vector3[0];\r\n                const camera = this._scene.activeCamera;\r\n\r\n                zoneOffset.copyFrom(this._zoneAxis[this.targetZone]);\r\n\r\n                const cameraLookAtQuaternion = TmpVectors.Quaternion[0];\r\n                if (camera && (this.zoneOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA || this.nodeOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA)) {\r\n                    const toCamera = TmpVectors.Vector3[1];\r\n                    toCamera.copyFrom(camera.position).subtractInPlace(pose.position).normalize();\r\n                    if (this._scene.useRightHandedSystem) {\r\n                        Quaternion.FromLookDirectionRHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\r\n                    } else {\r\n                        Quaternion.FromLookDirectionLHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\r\n                    }\r\n                }\r\n\r\n                if (this.zoneOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\r\n                    pose.quaternion.toRotationMatrix(TmpVectors.Matrix[0]);\r\n                } else {\r\n                    cameraLookAtQuaternion.toRotationMatrix(TmpVectors.Matrix[0]);\r\n                }\r\n\r\n                Vector3.TransformNormalToRef(zoneOffset, TmpVectors.Matrix[0], zoneOffset);\r\n                zoneOffset.scaleInPlace(this.targetOffset);\r\n\r\n                const targetPosition = TmpVectors.Vector3[2];\r\n                const targetRotation = TmpVectors.Quaternion[1];\r\n                targetPosition.copyFrom(pose.position).addInPlace(zoneOffset);\r\n\r\n                if (this.nodeOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\r\n                    targetRotation.copyFrom(pose.quaternion);\r\n                } else {\r\n                    targetRotation.copyFrom(cameraLookAtQuaternion);\r\n                }\r\n\r\n                const elapsed = Date.now() - lastTick;\r\n\r\n                Vector3.SmoothToRef(this._node.position, targetPosition, elapsed, this.lerpTime, this._node.position);\r\n                Quaternion.SmoothToRef(this._node.rotationQuaternion!, targetRotation, elapsed, this.lerpTime, this._node.rotationQuaternion!);\r\n\r\n                this._node.reservedDataStore.nearInteraction.excludedControllerId = pose.id;\r\n            }\r\n\r\n            this._setVisibility(pose);\r\n\r\n            lastTick = Date.now();\r\n        });\r\n    }\r\n\r\n    private _setVisibility(pose: Nullable<HandPoseInfo>) {\r\n        let palmVisible = true;\r\n        let gazeVisible = true;\r\n        const camera = this._scene.activeCamera;\r\n\r\n        if (camera) {\r\n            const cameraForward = camera.getForwardRay();\r\n\r\n            if (this.handConstraintVisibility === HandConstraintVisibility.GAZE_FOCUS || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\r\n                gazeVisible = false;\r\n                let gaze: Ray | undefined;\r\n                if (this._eyeTracking) {\r\n                    gaze = this._eyeTracking.getEyeGaze()!;\r\n                }\r\n\r\n                gaze = gaze || cameraForward;\r\n\r\n                const gazeToBehavior = TmpVectors.Vector3[0];\r\n                if (pose) {\r\n                    pose.position.subtractToRef(gaze.origin, gazeToBehavior);\r\n                } else {\r\n                    this._node.getAbsolutePosition().subtractToRef(gaze.origin, gazeToBehavior);\r\n                }\r\n\r\n                const projectedDistance = Vector3.Dot(gazeToBehavior, gaze.direction);\r\n                const projectedSquared = projectedDistance * projectedDistance;\r\n\r\n                if (projectedDistance > 0) {\r\n                    const radiusSquared = gazeToBehavior.lengthSquared() - projectedSquared;\r\n                    if (radiusSquared < this.gazeProximityRadius * this.gazeProximityRadius) {\r\n                        gazeVisible = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.handConstraintVisibility === HandConstraintVisibility.PALM_UP || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\r\n                palmVisible = false;\r\n\r\n                if (pose) {\r\n                    const palmDirection = TmpVectors.Vector3[0];\r\n                    Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(pose.quaternion, palmDirection);\r\n\r\n                    if (Vector3.Dot(palmDirection, cameraForward.direction) > this.palmUpStrictness * 2 - 1) {\r\n                        palmVisible = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._node.setEnabled(palmVisible && gazeVisible);\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from the `TransformNode`\r\n     */\r\n    public detach(): void {\r\n        this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n    }\r\n\r\n    /**\r\n     * Links the behavior to the XR experience in which to retrieve hand transform information.\r\n     * @param xr xr experience\r\n     */\r\n    public linkToXRExperience(xr: WebXRExperienceHelper) {\r\n        try {\r\n            this._eyeTracking = xr.featuresManager.getEnabledFeature(WebXRFeatureName.EYE_TRACKING) as WebXREyeTracking;\r\n        } catch {}\r\n\r\n        try {\r\n            this._handTracking = xr.featuresManager.getEnabledFeature(WebXRFeatureName.HAND_TRACKING) as WebXRHandTracking;\r\n        } catch {\r\n            alert(\"Hand tracking must be enabled for the Hand Menu to work\");\r\n        }\r\n    }\r\n}\r\n", "import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICanvas } from \"../ICanvas\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a dynamic texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @returns the dynamic texture inside an InternalTexture\r\n         */\r\n        createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture;\r\n\r\n        /**\r\n         * Update the content of a dynamic texture\r\n         * @param texture defines the texture to update\r\n         * @param source defines the source containing the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param premulAlpha defines if alpha is stored as premultiplied\r\n         * @param format defines the format of the data\r\n         * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n         * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n         */\r\n        updateDynamicTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            source: ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | OffscreenCanvas | ICanvas,\r\n            invertY?: boolean,\r\n            premulAlpha?: boolean,\r\n            format?: number,\r\n            forceBindTexture?: boolean,\r\n            allowGPUOptimization?: boolean\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createDynamicTexture = function (width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Dynamic);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n\r\n    if (generateMipMaps) {\r\n        width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(width, this._caps.maxTextureSize) : width;\r\n        height = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(height, this._caps.maxTextureSize) : height;\r\n    }\r\n\r\n    //  this.resetTextureCache();\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.isReady = false;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n\r\n    this.updateTextureSamplingMode(samplingMode, texture);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateDynamicTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    source: ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | OffscreenCanvas,\r\n    invertY?: boolean,\r\n    premulAlpha: boolean = false,\r\n    format?: number,\r\n    forceBindTexture: boolean = false,\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    allowGPUOptimization: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    const target = gl.TEXTURE_2D;\r\n\r\n    const wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);\r\n\r\n    this._unpackFlipY(invertY === undefined ? texture.invertY : invertY);\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(texture.type);\r\n    const glformat = this._getInternalFormat(format ? format : texture.format);\r\n    const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);\r\n\r\n    gl.texImage2D(target, 0, internalFormat, glformat, textureType, source as TexImageSource);\r\n\r\n    if (texture.generateMipMaps) {\r\n        gl.generateMipmap(target);\r\n    }\r\n\r\n    if (!wasPreviouslyBound) {\r\n        this._bindTextureDirectly(target, null);\r\n    }\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n", "import { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"../../Engines/ICanvas\";\r\n\r\n/**\r\n * A class extending Texture allowing drawing on a texture\r\n * @see https://doc.babylonjs.com/divingDeeper/materials/using/dynamicTexture\r\n */\r\nexport class DynamicTexture extends Texture {\r\n    private _generateMipMaps: boolean;\r\n    private _canvas: ICanvas;\r\n    private _context: ICanvasRenderingContext;\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param scene defines the scene where you want the texture\r\n     * @param generateMipMaps defines the use of MinMaps or not (default is false)\r\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     */\r\n\r\n    constructor(\r\n        name: string,\r\n        options: any,\r\n        scene: Nullable<Scene> = null,\r\n        generateMipMaps: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        invertY?: boolean\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\r\n\r\n        this.name = name;\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        if (options.getContext) {\r\n            this._canvas = options;\r\n            this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n        } else {\r\n            this._canvas = engine.createCanvas(1, 1);\r\n\r\n            if (options.width || options.width === 0) {\r\n                this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n            } else {\r\n                this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\r\n            }\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n\r\n        if (this._canvas.width !== textureSize.width) {\r\n            this._canvas.width = textureSize.width;\r\n        }\r\n        if (this._canvas.height !== textureSize.height) {\r\n            this._canvas.height = textureSize.height;\r\n        }\r\n        this._context = this._canvas.getContext(\"2d\");\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"DynamicTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"DynamicTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the current state of canRescale\r\n     */\r\n    public get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    private _recreate(textureSize: ISize): void {\r\n        this._canvas.width = textureSize.width;\r\n        this._canvas.height = textureSize.height;\r\n\r\n        this.releaseInternalTexture();\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public scale(ratio: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width *= ratio;\r\n        textureSize.height *= ratio;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width = width;\r\n        textureSize.height = height;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Gets the context of the canvas used by the texture\r\n     * @returns the canvas context of the dynamic texture\r\n     */\r\n    public getContext(): ICanvasRenderingContext {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Clears the texture\r\n     */\r\n    public clear(): void {\r\n        const size = this.getSize();\r\n        this._context.fillRect(0, 0, size.width, size.height);\r\n    }\r\n\r\n    /**\r\n     * Updates the texture\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\r\n     * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n     */\r\n    public update(invertY?: boolean, premulAlpha = false, allowGPUOptimization = false): void {\r\n        this._getEngine()!.updateDynamicTexture(\r\n            this._texture,\r\n            this._canvas,\r\n            invertY === undefined ? true : invertY,\r\n            premulAlpha,\r\n            this._format || undefined,\r\n            undefined,\r\n            allowGPUOptimization\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draws text onto the texture\r\n     * @param text defines the text to be drawn\r\n     * @param x defines the placement of the text from the left\r\n     * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\r\n     * @param font defines the font to be used with font-style, font-size, font-name\r\n     * @param color defines the color used for the text\r\n     * @param clearColor defines the color for the canvas, use null to not overwrite canvas\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param update defines whether texture is immediately update (default is true)\r\n     */\r\n    public drawText(\r\n        text: string,\r\n        x: number | null | undefined,\r\n        y: number | null | undefined,\r\n        font: string,\r\n        color: string | null,\r\n        clearColor: string | null,\r\n        invertY?: boolean,\r\n        update = true\r\n    ) {\r\n        const size = this.getSize();\r\n        if (clearColor) {\r\n            this._context.fillStyle = clearColor;\r\n            this._context.fillRect(0, 0, size.width, size.height);\r\n        }\r\n\r\n        this._context.font = font;\r\n        if (x === null || x === undefined) {\r\n            const textSize = this._context.measureText(text);\r\n            x = (size.width - textSize.width) / 2;\r\n        }\r\n        if (y === null || y === undefined) {\r\n            const fontSize = parseInt(font.replace(/\\D/g, \"\"));\r\n            y = size.height / 2 + fontSize / 3.65;\r\n        }\r\n\r\n        this._context.fillStyle = color || \"\";\r\n        this._context.fillText(text, x, y);\r\n\r\n        if (update) {\r\n            this.update(invertY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the texture\r\n     * @returns the clone of the texture.\r\n     */\r\n    public clone(): DynamicTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n        const newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // Dynamic Texture\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\r\n     * @returns a serialized dynamic texture object\r\n     */\r\n    public serialize(): any {\r\n        const scene = this.getScene();\r\n        if (scene && !scene.isReady()) {\r\n            Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n        if (DynamicTexture._IsCanvasElement(this._canvas)) {\r\n            serializationObject.base64String = this._canvas.toDataURL();\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private static _IsCanvasElement(canvas: HTMLCanvasElement | OffscreenCanvas | ICanvas): canvas is HTMLCanvasElement {\r\n        return (canvas as HTMLCanvasElement).toDataURL !== undefined;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n}\r\n", "import type { IDisposable } from \"../scene\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { PointerInfoPre } from \"../Events/pointerEvents\";\r\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { HemisphericLight } from \"../Lights/hemisphericLight\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { IPointerEvent } from \"../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Renders a layer on top of an existing scene\r\n */\r\nexport class UtilityLayerRenderer implements IDisposable {\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n    private _lastPointerEvents: { [pointerId: number]: boolean } = {};\r\n    /** @internal */\r\n    public static _DefaultUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    /** @internal */\r\n    public static _DefaultKeepDepthUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    private _sharedGizmoLight: Nullable<HemisphericLight> = null;\r\n\r\n    private _renderCamera: Nullable<Camera> = null;\r\n\r\n    /**\r\n     * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\r\n     * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\r\n     * @returns the camera that is used when rendering the utility layer\r\n     */\r\n    public getRenderCamera(getRigParentIfPossible?: boolean) {\r\n        if (this._renderCamera) {\r\n            return this._renderCamera;\r\n        } else {\r\n            let activeCam: Camera;\r\n            if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\r\n                activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\r\n            } else {\r\n                activeCam = <Camera>this.originalScene.activeCamera!;\r\n            }\r\n\r\n            if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\r\n                return activeCam.rigParent!;\r\n            }\r\n            return activeCam;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\r\n     * @param cam the camera that should be used when rendering the utility layer\r\n     */\r\n    public setRenderCamera(cam: Nullable<Camera>) {\r\n        this._renderCamera = cam;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Light which used by gizmos to get light shading\r\n     */\r\n    public _getSharedGizmoLight(): HemisphericLight {\r\n        if (!this._sharedGizmoLight) {\r\n            this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\r\n            this._sharedGizmoLight.intensity = 2;\r\n            this._sharedGizmoLight.groundColor = Color3.Gray();\r\n        }\r\n        return this._sharedGizmoLight;\r\n    }\r\n\r\n    /**\r\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\r\n     */\r\n    public pickUtilitySceneFirst = true;\r\n    /**\r\n     * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\r\n            return UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene!);\r\n        }\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * Creates an utility layer, and set it as a default utility layer\r\n     * @param scene associated scene\r\n     * @internal\r\n     */\r\n    public static _CreateDefaultUtilityLayerFromScene(scene: Scene): UtilityLayerRenderer {\r\n        UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(scene);\r\n        UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n            UtilityLayerRenderer._DefaultUtilityLayer = null;\r\n        });\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n    /**\r\n     * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultKeepDepthUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene!);\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n                UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\r\n            });\r\n        }\r\n        return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * The scene that is rendered on top of the original scene\r\n     */\r\n    public utilityLayerScene: Scene;\r\n\r\n    /**\r\n     *  If the utility layer should automatically be rendered on top of existing scene\r\n     */\r\n    public shouldRender: boolean = true;\r\n    /**\r\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\r\n     */\r\n    public onlyCheckPointerDownEvents = true;\r\n\r\n    /**\r\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\r\n     */\r\n    public processAllEvents = false;\r\n\r\n    /**\r\n     * Set to false to disable picking\r\n     */\r\n    public pickingEnabled = true;\r\n\r\n    /**\r\n     * Observable raised when the pointer moves from the utility layer scene to the main scene\r\n     */\r\n    public onPointerOutObservable = new Observable<number>();\r\n\r\n    /** Gets or sets a predicate that will be used to indicate utility meshes present in the main scene */\r\n    public mainSceneTrackerPredicate: (mesh: Nullable<AbstractMesh>) => boolean;\r\n\r\n    private _afterRenderObserver: Nullable<Observer<Camera>>;\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    private _originalPointerObserver: Nullable<Observer<PointerInfoPre>>;\r\n    /**\r\n     * Instantiates a UtilityLayerRenderer\r\n     * @param originalScene the original scene that will be rendered on top of\r\n     * @param handleEvents boolean indicating if the utility layer should handle events\r\n     */\r\n    constructor(\r\n        /** the original scene that will be rendered on top of */\r\n        public originalScene: Scene,\r\n        handleEvents: boolean = true\r\n    ) {\r\n        // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\r\n        this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });\r\n        this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\r\n        this.utilityLayerScene._allowPostProcessClearColor = false;\r\n\r\n        // Deactivate post processes\r\n        this.utilityLayerScene.postProcessesEnabled = false;\r\n\r\n        // Detach controls on utility scene, events will be fired by logic below to handle picking priority\r\n        this.utilityLayerScene.detachControl();\r\n\r\n        if (handleEvents) {\r\n            this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo) => {\r\n                if (!this.utilityLayerScene.activeCamera) {\r\n                    return;\r\n                }\r\n                if (!this.pickingEnabled) {\r\n                    return;\r\n                }\r\n\r\n                if (!this.processAllEvents) {\r\n                    if (\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERMOVE &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERUP &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOWN &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP\r\n                    ) {\r\n                        return;\r\n                    }\r\n                }\r\n                this.utilityLayerScene.pointerX = originalScene.pointerX;\r\n                this.utilityLayerScene.pointerY = originalScene.pointerY;\r\n                const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n                if (originalScene!.isPointerCaptured(pointerEvent.pointerId)) {\r\n                    this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    return;\r\n                }\r\n\r\n                const getNearPickDataForScene = (scene: Scene) => {\r\n                    let scenePick = null;\r\n\r\n                    if (prePointerInfo.nearInteractionPickingInfo) {\r\n                        if (prePointerInfo.nearInteractionPickingInfo.pickedMesh!.getScene() == scene) {\r\n                            scenePick = prePointerInfo.nearInteractionPickingInfo;\r\n                        } else {\r\n                            scenePick = new PickingInfo();\r\n                        }\r\n                    } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {\r\n                        scenePick = prePointerInfo.originalPickingInfo;\r\n                    } else {\r\n                        let previousActiveCamera: Nullable<Camera> = null;\r\n                        // If a camera is set for rendering with this layer\r\n                        // it will also be used for the ray computation\r\n                        // To preserve back compat and because scene.pick always use activeCamera\r\n                        // it's substituted temporarily and a new scenePick is forced.\r\n                        // otherwise, the ray with previously active camera is always used.\r\n                        // It's set back to previous activeCamera after operation.\r\n                        if (this._renderCamera) {\r\n                            previousActiveCamera = scene._activeCamera;\r\n                            scene._activeCamera = this._renderCamera;\r\n                            prePointerInfo.ray = null;\r\n                        }\r\n                        scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);\r\n                        if (previousActiveCamera) {\r\n                            scene._activeCamera = previousActiveCamera;\r\n                        }\r\n                    }\r\n\r\n                    return scenePick;\r\n                };\r\n\r\n                const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);\r\n\r\n                if (!prePointerInfo.ray && utilityScenePick) {\r\n                    prePointerInfo.ray = utilityScenePick.ray;\r\n                }\r\n\r\n                // always fire the prepointer observable\r\n                this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\r\n\r\n                // allow every non pointer down event to flow to the utility layer\r\n                if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\r\n                    if (!prePointerInfo.skipOnPointerObservable) {\r\n                        this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                            new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                            prePointerInfo.type\r\n                        );\r\n                    }\r\n                    if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                        this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {\r\n                    // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\r\n                    if (utilityScenePick && utilityScenePick.hit) {\r\n                        if (!prePointerInfo.skipOnPointerObservable) {\r\n                            this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                                new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                                prePointerInfo.type\r\n                            );\r\n                        }\r\n                        prePointerInfo.skipOnPointerObservable = true;\r\n                    }\r\n                } else {\r\n                    const originalScenePick = getNearPickDataForScene(originalScene);\r\n                    const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n\r\n                    // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\r\n                    if (originalScenePick && utilityScenePick) {\r\n                        // No pick in utility scene\r\n                        if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                // We touched an utility mesh present in the main scene\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                                this._pointerCaptures[pointerEvent.pointerId] = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                    // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                    this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                    delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\r\n                            // We pick something in utility scene or the pick in utility is closer than the one in main scene\r\n                            this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            // If a previous utility layer set this, do not unset this\r\n                            if (!prePointerInfo.skipOnPointerObservable) {\r\n                                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {\r\n                            // We have a pick in both scenes but main is closer than utility\r\n\r\n                            // We touched an utility mesh present in the main scene\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else {\r\n                                if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                    if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                        // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                        this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                        delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                    }\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            }\r\n                        }\r\n\r\n                        if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                            this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\r\n            if (this._originalPointerObserver) {\r\n                originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\r\n            }\r\n        }\r\n\r\n        // Render directly on top of existing scene without clearing\r\n        this.utilityLayerScene.autoClear = false;\r\n\r\n        this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add((camera) => {\r\n            // Only render when the render camera finishes rendering\r\n            if (this.shouldRender && camera == this.getRenderCamera()) {\r\n                this.render();\r\n            }\r\n        });\r\n\r\n        this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._updateCamera();\r\n    }\r\n\r\n    private _notifyObservers(prePointerInfo: PointerInfoPre, pickInfo: PickingInfo, pointerEvent: IPointerEvent) {\r\n        if (!prePointerInfo.skipOnPointerObservable) {\r\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\r\n            this._lastPointerEvents[pointerEvent.pointerId] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the utility layers scene on top of the original scene\r\n     */\r\n    public render() {\r\n        this._updateCamera();\r\n        if (this.utilityLayerScene.activeCamera) {\r\n            // Set the camera's scene to utility layers scene\r\n            const oldScene = this.utilityLayerScene.activeCamera.getScene();\r\n            const camera = this.utilityLayerScene.activeCamera;\r\n            camera._scene = this.utilityLayerScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = this.utilityLayerScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = this.utilityLayerScene;\r\n            }\r\n\r\n            this.utilityLayerScene.render(false);\r\n\r\n            // Reset camera's scene back to original\r\n            camera._scene = oldScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = oldScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = oldScene;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the renderer\r\n     */\r\n    public dispose() {\r\n        this.onPointerOutObservable.clear();\r\n\r\n        if (this._afterRenderObserver) {\r\n            this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\r\n        }\r\n        if (this._sceneDisposeObserver) {\r\n            this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        }\r\n        if (this._originalPointerObserver) {\r\n            this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\r\n        }\r\n        this.utilityLayerScene.dispose();\r\n    }\r\n\r\n    private _updateCamera() {\r\n        this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\r\n        this.utilityLayerScene.activeCamera = this.getRenderCamera();\r\n    }\r\n}\r\n", "import type { Observer } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { WebVRFreeCamera } from \"../Cameras/VR/webVRCamera\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { Quaternion, Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport type { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport type { Node } from \"../node\";\r\nimport type { Bone } from \"../Bones/bone\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\nimport type { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\r\nimport type { ShadowLight } from \"../Lights/shadowLight\";\r\nimport { Light } from \"../Lights/light\";\r\n\r\n/**\r\n * Cache built by each axis. Used for managing state between all elements of gizmo for enhanced UI\r\n */\r\nexport interface GizmoAxisCache {\r\n    /** Mesh used to render the Gizmo */\r\n    gizmoMeshes: Mesh[];\r\n    /** Mesh used to detect user interaction with Gizmo */\r\n    colliderMeshes: Mesh[];\r\n    /** Material used to indicate color of gizmo mesh */\r\n    material: StandardMaterial;\r\n    /** Material used to indicate hover state of the Gizmo */\r\n    hoverMaterial: StandardMaterial;\r\n    /** Material used to indicate disabled state of the Gizmo */\r\n    disableMaterial: StandardMaterial;\r\n    /** Used to indicate Active state of the Gizmo */\r\n    active: boolean;\r\n    /** DragBehavior */\r\n    dragBehavior: PointerDragBehavior;\r\n}\r\n\r\n/**\r\n * Interface for basic gizmo\r\n */\r\nexport interface IGizmo extends IDisposable {\r\n    /** True when the mouse pointer is hovered a gizmo mesh */\r\n    readonly isHovered: boolean;\r\n    /** The root mesh of the gizmo */\r\n    _rootMesh: Mesh;\r\n    /** Ratio for the scale of the gizmo */\r\n    scaleRatio: number;\r\n    /**\r\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    attachedMesh: Nullable<AbstractMesh>;\r\n    /**\r\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    attachedNode: Nullable<Node>;\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    updateGizmoRotationToMatchAttachedMesh: boolean;\r\n    /** The utility layer the gizmo will be added to */\r\n    gizmoLayer: UtilityLayerRenderer;\r\n    /**\r\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    updateGizmoPositionToMatchAttachedMesh: boolean;\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n    updateScale: boolean;\r\n    /**\r\n     * posture that the gizmo will be display\r\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\r\n     */\r\n    customRotationQuaternion: Nullable<Quaternion>;\r\n    /** Disposes and replaces the current meshes in the gizmo with the specified mesh */\r\n    setCustomMesh(mesh: Mesh): void;\r\n}\r\n/**\r\n * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.\r\n */\r\nexport class Gizmo implements IGizmo {\r\n    /**\r\n     * The root mesh of the gizmo\r\n     */\r\n    public _rootMesh: Mesh;\r\n    protected _attachedMesh: Nullable<AbstractMesh> = null;\r\n    protected _attachedNode: Nullable<Node> = null;\r\n    protected _customRotationQuaternion: Nullable<Quaternion> = null;\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    protected _scaleRatio = 1;\r\n\r\n    /**\r\n     * boolean updated by pointermove when a gizmo mesh is hovered\r\n     */\r\n    protected _isHovered = false;\r\n\r\n    /**\r\n     * When enabled, any gizmo operation will perserve scaling sign. Default is off.\r\n     * Only valid for TransformNode derived classes (Mesh, AbstractMesh, ...)\r\n     */\r\n    public static PreserveScaling = false;\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        this._scaleRatio = value;\r\n    }\r\n\r\n    public get scaleRatio() {\r\n        return this._scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovered a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        return this._isHovered;\r\n    }\r\n\r\n    /**\r\n     * If a custom mesh has been set (Default: false)\r\n     */\r\n    protected _customMeshSet = false;\r\n    /**\r\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedMesh() {\r\n        return this._attachedMesh;\r\n    }\r\n    public set attachedMesh(value) {\r\n        this._attachedMesh = value;\r\n        if (value) {\r\n            this._attachedNode = value;\r\n        }\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n    /**\r\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedNode() {\r\n        return this._attachedNode;\r\n    }\r\n    public set attachedNode(value) {\r\n        this._attachedNode = value;\r\n        this._attachedMesh = null;\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n\r\n    /**\r\n     * Disposes and replaces the current meshes in the gizmo with the specified mesh\r\n     * @param mesh The mesh to replace the default mesh of the gizmo\r\n     */\r\n    public setCustomMesh(mesh: Mesh) {\r\n        if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {\r\n            throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\r\n        }\r\n        this._rootMesh.getChildMeshes().forEach((c) => {\r\n            c.dispose();\r\n        });\r\n        mesh.parent = this._rootMesh;\r\n        this._customMeshSet = true;\r\n    }\r\n\r\n    protected _updateGizmoRotationToMatchAttachedMesh = true;\r\n\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    public set updateGizmoRotationToMatchAttachedMesh(value: boolean) {\r\n        this._updateGizmoRotationToMatchAttachedMesh = value;\r\n    }\r\n    public get updateGizmoRotationToMatchAttachedMesh() {\r\n        return this._updateGizmoRotationToMatchAttachedMesh;\r\n    }\r\n    /**\r\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    public updateGizmoPositionToMatchAttachedMesh = true;\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n    public updateScale = true;\r\n    protected _interactionsEnabled = true;\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _attachedNodeChanged(value: Nullable<Node>) {}\r\n\r\n    protected _beforeRenderObserver: Nullable<Observer<Scene>>;\r\n    private _tempQuaternion = new Quaternion(0, 0, 0, 1);\r\n    private _tempVector = new Vector3();\r\n    private _tempVector2 = new Vector3();\r\n    private _tempMatrix1 = new Matrix();\r\n    private _tempMatrix2 = new Matrix();\r\n    private _rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);\r\n\r\n    /**\r\n     * Creates a gizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(\r\n        /** The utility layer the gizmo will be added to */\r\n        public gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer\r\n    ) {\r\n        this._rootMesh = new Mesh(\"gizmoRootNode\", gizmoLayer.utilityLayerScene);\r\n        this._rootMesh.rotationQuaternion = Quaternion.Identity();\r\n\r\n        this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {\r\n            this._update();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * posture that the gizmo will be display\r\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\r\n     */\r\n    public get customRotationQuaternion(): Nullable<Quaternion> {\r\n        return this._customRotationQuaternion;\r\n    }\r\n\r\n    public set customRotationQuaternion(customRotationQuaternion: Nullable<Quaternion>) {\r\n        this._customRotationQuaternion = customRotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Updates the gizmo to match the attached mesh's position/rotation\r\n     */\r\n    protected _update() {\r\n        if (this.attachedNode) {\r\n            let effectiveNode = this.attachedNode;\r\n            if (this.attachedMesh) {\r\n                effectiveNode = this.attachedMesh || this.attachedNode;\r\n            }\r\n\r\n            // Position\r\n            if (this.updateGizmoPositionToMatchAttachedMesh) {\r\n                const row = effectiveNode.getWorldMatrix().getRow(3);\r\n                const position = row ? row.toVector3() : new Vector3(0, 0, 0);\r\n                this._rootMesh.position.copyFrom(position);\r\n            }\r\n\r\n            // Rotation\r\n            if (this.updateGizmoRotationToMatchAttachedMesh) {\r\n                const supportedNode =\r\n                    (<Mesh>effectiveNode)._isMesh ||\r\n                    effectiveNode.getClassName() === \"AbstractMesh\" ||\r\n                    effectiveNode.getClassName() === \"TransformNode\" ||\r\n                    effectiveNode.getClassName() === \"InstancedMesh\";\r\n                const transformNode = supportedNode ? (effectiveNode as TransformNode) : undefined;\r\n                effectiveNode.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion!, undefined, Gizmo.PreserveScaling ? transformNode : undefined);\r\n            } else {\r\n                if (this._customRotationQuaternion) {\r\n                    this._rootMesh.rotationQuaternion!.copyFrom(this._customRotationQuaternion);\r\n                } else {\r\n                    this._rootMesh.rotationQuaternion!.set(0, 0, 0, 1);\r\n                }\r\n            }\r\n\r\n            // Scale\r\n            if (this.updateScale) {\r\n                const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera!;\r\n                let cameraPosition = activeCamera.globalPosition;\r\n                if ((<WebVRFreeCamera>activeCamera).devicePosition) {\r\n                    cameraPosition = (<WebVRFreeCamera>activeCamera).devicePosition;\r\n                }\r\n                this._rootMesh.position.subtractToRef(cameraPosition, this._tempVector);\r\n                let scale = this.scaleRatio;\r\n                if (activeCamera.mode == Camera.ORTHOGRAPHIC_CAMERA) {\r\n                    if (activeCamera.orthoTop && activeCamera.orthoBottom) {\r\n                        const orthoHeight = activeCamera.orthoTop - activeCamera.orthoBottom;\r\n                        scale *= orthoHeight;\r\n                    }\r\n                } else {\r\n                    const camForward = activeCamera.getScene().useRightHandedSystem ? Vector3.RightHandedForwardReadOnly : Vector3.LeftHandedForwardReadOnly;\r\n                    const direction = activeCamera.getDirection(camForward);\r\n                    scale *= Vector3.Dot(this._tempVector, direction);\r\n                }\r\n                this._rootMesh.scaling.setAll(scale);\r\n\r\n                // Account for handedness, similar to Matrix.decompose\r\n                if (effectiveNode._getWorldMatrixDeterminant() < 0 && !Gizmo.PreserveScaling) {\r\n                    this._rootMesh.scaling.y *= -1;\r\n                }\r\n            } else {\r\n                this._rootMesh.scaling.setAll(this.scaleRatio);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle position/translation when using an attached node using pivot\r\n     */\r\n    protected _handlePivot() {\r\n        const attachedNodeTransform = this._attachedNode as any;\r\n        // check there is an active pivot for the TransformNode attached\r\n        if (attachedNodeTransform.isUsingPivotMatrix && attachedNodeTransform.isUsingPivotMatrix() && attachedNodeTransform.position) {\r\n            // When a TransformNode has an active pivot, even without parenting,\r\n            // translation from the world matrix is different from TransformNode.position.\r\n            // Pivot works like a virtual parent that's using the node orientation.\r\n            // As the world matrix is transformed by the gizmo and then decomposed to TRS\r\n            // its translation part must be set to the Node's position.\r\n            attachedNodeTransform.getWorldMatrix().setTranslation(attachedNodeTransform.position);\r\n        }\r\n    }\r\n    /**\r\n     * computes the rotation/scaling/position of the transform once the Node world matrix has changed.\r\n     */\r\n    protected _matrixChanged() {\r\n        if (!this._attachedNode) {\r\n            return;\r\n        }\r\n\r\n        if ((<Camera>this._attachedNode)._isCamera) {\r\n            const camera = this._attachedNode as Camera;\r\n            let worldMatrix;\r\n            let worldMatrixUC;\r\n            if (camera.parent) {\r\n                const parentInv = this._tempMatrix2;\r\n                camera.parent._worldMatrix.invertToRef(parentInv);\r\n                this._attachedNode._worldMatrix.multiplyToRef(parentInv, this._tempMatrix1);\r\n                worldMatrix = this._tempMatrix1;\r\n            } else {\r\n                worldMatrix = this._attachedNode._worldMatrix;\r\n            }\r\n\r\n            if (camera.getScene().useRightHandedSystem) {\r\n                // avoid desync with RH matrix computation. Otherwise, rotation of PI around Y axis happens each frame resulting in axis flipped because worldMatrix is computed as inverse of viewMatrix.\r\n                this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, this._tempMatrix2);\r\n                worldMatrixUC = this._tempMatrix2;\r\n            } else {\r\n                worldMatrixUC = worldMatrix;\r\n            }\r\n\r\n            worldMatrixUC.decompose(this._tempVector2, this._tempQuaternion, this._tempVector);\r\n\r\n            const inheritsTargetCamera =\r\n                this._attachedNode.getClassName() === \"FreeCamera\" ||\r\n                this._attachedNode.getClassName() === \"FlyCamera\" ||\r\n                this._attachedNode.getClassName() === \"ArcFollowCamera\" ||\r\n                this._attachedNode.getClassName() === \"TargetCamera\" ||\r\n                this._attachedNode.getClassName() === \"TouchCamera\" ||\r\n                this._attachedNode.getClassName() === \"UniversalCamera\";\r\n\r\n            if (inheritsTargetCamera) {\r\n                const targetCamera = this._attachedNode as TargetCamera;\r\n                targetCamera.rotation = this._tempQuaternion.toEulerAngles();\r\n\r\n                if (targetCamera.rotationQuaternion) {\r\n                    targetCamera.rotationQuaternion.copyFrom(this._tempQuaternion);\r\n                    targetCamera.rotationQuaternion.normalize();\r\n                }\r\n            }\r\n\r\n            camera.position.copyFrom(this._tempVector);\r\n        } else if (\r\n            (<Mesh>this._attachedNode)._isMesh ||\r\n            this._attachedNode.getClassName() === \"AbstractMesh\" ||\r\n            this._attachedNode.getClassName() === \"TransformNode\" ||\r\n            this._attachedNode.getClassName() === \"InstancedMesh\"\r\n        ) {\r\n            const transform = this._attachedNode as TransformNode;\r\n            if (transform.parent) {\r\n                const parentInv = this._tempMatrix1;\r\n                const localMat = this._tempMatrix2;\r\n                transform.parent.getWorldMatrix().invertToRef(parentInv);\r\n                this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);\r\n                localMat.decompose(this._tempVector, this._tempQuaternion, transform.position, Gizmo.PreserveScaling ? transform : undefined);\r\n            } else {\r\n                this._attachedNode._worldMatrix.decompose(this._tempVector, this._tempQuaternion, transform.position, Gizmo.PreserveScaling ? transform : undefined);\r\n            }\r\n            transform.scaling.copyFrom(this._tempVector);\r\n            if (!transform.billboardMode) {\r\n                if (transform.rotationQuaternion) {\r\n                    transform.rotationQuaternion.copyFrom(this._tempQuaternion);\r\n                    transform.rotationQuaternion.normalize();\r\n                } else {\r\n                    transform.rotation = this._tempQuaternion.toEulerAngles();\r\n                }\r\n            }\r\n        } else if (this._attachedNode.getClassName() === \"Bone\") {\r\n            const bone = this._attachedNode as Bone;\r\n            const parent = bone.getParent();\r\n\r\n            if (parent) {\r\n                const invParent = this._tempMatrix1;\r\n                const boneLocalMatrix = this._tempMatrix2;\r\n                parent.getWorldMatrix().invertToRef(invParent);\r\n                bone.getWorldMatrix().multiplyToRef(invParent, boneLocalMatrix);\r\n                const lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(boneLocalMatrix);\r\n            } else {\r\n                const lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(bone.getWorldMatrix());\r\n            }\r\n            bone.markAsDirty();\r\n        } else {\r\n            const light = this._attachedNode as ShadowLight;\r\n            if (light.getTypeID) {\r\n                const type = light.getTypeID();\r\n                if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {\r\n                    const parent = light.parent;\r\n\r\n                    if (parent) {\r\n                        const invParent = this._tempMatrix1;\r\n                        const nodeLocalMatrix = this._tempMatrix2;\r\n                        parent.getWorldMatrix().invertToRef(invParent);\r\n                        light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);\r\n                        nodeLocalMatrix.decompose(undefined, this._tempQuaternion, this._tempVector);\r\n                    } else {\r\n                        this._attachedNode._worldMatrix.decompose(undefined, this._tempQuaternion, this._tempVector);\r\n                    }\r\n                    // setter doesn't copy values. Need a new Vector3\r\n                    light.position = new Vector3(this._tempVector.x, this._tempVector.y, this._tempVector.z);\r\n                    if (light.direction) {\r\n                        light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * refresh gizmo mesh material\r\n     * @param gizmoMeshes\r\n     * @param material material to apply\r\n     */\r\n    protected _setGizmoMeshMaterial(gizmoMeshes: Mesh[], material: StandardMaterial) {\r\n        if (gizmoMeshes) {\r\n            gizmoMeshes.forEach((m: Mesh) => {\r\n                m.material = material;\r\n                if ((<LinesMesh>m).color) {\r\n                    (<LinesMesh>m).color = material.diffuseColor;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n     * @returns {Observer<PointerInfo>} pointerObserver\r\n     */\r\n    public static GizmoAxisPointerObserver(gizmoLayer: UtilityLayerRenderer, gizmoAxisCache: Map<Mesh, GizmoAxisCache>): Observer<PointerInfo> {\r\n        let dragging = false;\r\n\r\n        const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (pointerInfo.pickInfo) {\r\n                // On Hover Logic\r\n                if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (dragging) {\r\n                        return;\r\n                    }\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        if (cache.colliderMeshes && cache.gizmoMeshes) {\r\n                            const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh as Mesh) != -1;\r\n                            const material = cache.dragBehavior.enabled ? (isHovered || cache.active ? cache.hoverMaterial : cache.material) : cache.disableMaterial;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n\r\n                // On Mouse Down\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If user Clicked Gizmo\r\n                    if (gizmoAxisCache.has(pointerInfo.pickInfo.pickedMesh?.parent as Mesh)) {\r\n                        dragging = true;\r\n                        const statusMap = gizmoAxisCache.get(pointerInfo.pickInfo.pickedMesh?.parent as Mesh);\r\n                        statusMap!.active = true;\r\n                        gizmoAxisCache.forEach((cache) => {\r\n                            const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh as Mesh) != -1;\r\n                            const material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // On Mouse Up\r\n                if (pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        cache.active = false;\r\n                        dragging = false;\r\n                        cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                            m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;\r\n                            if ((m as LinesMesh).color) {\r\n                                (m as LinesMesh).color = cache.material.diffuseColor;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n        });\r\n\r\n        return pointerObserver!;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this._rootMesh.dispose();\r\n        if (this._beforeRenderObserver) {\r\n            this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a box\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param options.topBaseAt\r\n * @param options.bottomBaseAt\r\n * @returns the VertexData of the box\r\n */\r\nexport function CreateBoxVertexData(options: {\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    depth?: number;\r\n    faceUV?: Vector4[];\r\n    faceColors?: Color4[];\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    wrap?: boolean;\r\n    topBaseAt?: number;\r\n    bottomBaseAt?: number;\r\n}): VertexData {\r\n    const nbFaces = 6;\r\n    let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\r\n    const normals = [\r\n        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0,\r\n        1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,\r\n    ];\r\n    const uvs = [];\r\n    let positions = [];\r\n    const width = options.width || options.size || 1;\r\n    const height = options.height || options.size || 1;\r\n    const depth = options.depth || options.size || 1;\r\n    const wrap = options.wrap || false;\r\n    let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;\r\n    let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;\r\n    topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\r\n    bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\r\n    const topOrder = [2, 0, 3, 1];\r\n    const bottomOrder = [2, 0, 1, 3];\r\n    let topIndex = topOrder[topBaseAt];\r\n    let bottomIndex = bottomOrder[bottomBaseAt];\r\n    let basePositions = [\r\n        1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1,\r\n        1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1,\r\n    ];\r\n    if (wrap) {\r\n        indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\r\n        basePositions = [\r\n            -1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1,\r\n        ];\r\n        let topFaceBase: any = [\r\n            [1, 1, 1],\r\n            [-1, 1, 1],\r\n            [-1, 1, -1],\r\n            [1, 1, -1],\r\n        ];\r\n        let bottomFaceBase: any = [\r\n            [-1, -1, 1],\r\n            [1, -1, 1],\r\n            [1, -1, -1],\r\n            [-1, -1, -1],\r\n        ];\r\n        const topFaceOrder: any = [17, 18, 19, 16];\r\n        const bottomFaceOrder: any = [22, 23, 20, 21];\r\n        while (topIndex > 0) {\r\n            topFaceBase.unshift(topFaceBase.pop());\r\n            topFaceOrder.unshift(topFaceOrder.pop());\r\n            topIndex--;\r\n        }\r\n        while (bottomIndex > 0) {\r\n            bottomFaceBase.unshift(bottomFaceBase.pop());\r\n            bottomFaceOrder.unshift(bottomFaceOrder.pop());\r\n            bottomIndex--;\r\n        }\r\n        topFaceBase = topFaceBase.flat();\r\n        bottomFaceBase = bottomFaceBase.flat();\r\n        basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\r\n        indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\r\n        indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\r\n    }\r\n    const scaleArray = [width / 2, height / 2, depth / 2];\r\n    positions = basePositions.reduce((accumulator: Array<number>, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(6);\r\n    const faceColors = options.faceColors;\r\n    const colors = [];\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < 6; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    // Create each face in turn.\r\n    for (let index = 0; index < nbFaces; index++) {\r\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\r\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\r\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\r\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\r\n        if (faceColors) {\r\n            for (let c = 0; c < 4; c++) {\r\n                colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\r\n            }\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a box mesh\r\n * * The parameter `size` sets the size (float) of each box side (default 1)\r\n * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\r\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/how_to/set_shapes#box\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param options.topBaseAt\r\n * @param options.bottomBaseAt\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateBox(\r\n    name: string,\r\n    options: {\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n        topBaseAt?: number;\r\n        bottomBaseAt?: number;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const box = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    box._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateBoxVertexData(options);\r\n\r\n    vertexData.applyToMesh(box, options.updatable);\r\n\r\n    return box;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateBox directly\r\n */\r\nexport const BoxBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateBox,\r\n};\r\n\r\n// Side effects\r\nVertexData.CreateBox = CreateBoxVertexData;\r\n\r\n(Mesh as any).CreateBox = (name: string, size: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        size,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateBox(name, options, scene);\r\n};\r\n", "/**\r\n * Gather the list of clipboard event types as constants.\r\n */\r\nexport class ClipboardEventTypes {\r\n    /**\r\n     * The clipboard event is fired when a copy command is active (pressed).\r\n     */\r\n    public static readonly COPY = 0x01; //\r\n    /**\r\n     *  The clipboard event is fired when a cut command is active (pressed).\r\n     */\r\n    public static readonly CUT = 0x02;\r\n\r\n    /**\r\n     * The clipboard event is fired when a paste command is active (pressed).\r\n     */\r\n    public static readonly PASTE = 0x03;\r\n}\r\n/**\r\n * This class is used to store clipboard related info for the onClipboardObservable event.\r\n */\r\nexport class ClipboardInfo {\r\n    /**\r\n     *Creates an instance of ClipboardInfo.\r\n     * @param type Defines the type of event (BABYLON.ClipboardEventTypes)\r\n     * @param event Defines the related dom event\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the type of event (BABYLON.ClipboardEventTypes)\r\n         */\r\n        public type: number,\r\n        /**\r\n         * Defines the related dom event\r\n         */\r\n        public event: ClipboardEvent\r\n    ) {}\r\n\r\n    /**\r\n     *  Get the clipboard event's type from the keycode.\r\n     * @param keyCode Defines the keyCode for the current keyboard event.\r\n     * @returns {number}\r\n     */\r\n    public static GetTypeFromCharacter(keyCode: number): number {\r\n        const charCode = keyCode;\r\n        //TODO: add codes for extended ASCII\r\n        switch (charCode) {\r\n            case 67:\r\n                return ClipboardEventTypes.COPY;\r\n            case 86:\r\n                return ClipboardEventTypes.PASTE;\r\n            case 88:\r\n                return ClipboardEventTypes.CUT;\r\n            default:\r\n                return -1;\r\n        }\r\n    }\r\n}\r\n", "import type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { Layer } from \"./layer\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of layers (background and foreground) of the scene\r\n         */\r\n        layers: Array<Layer>;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines the layer scene component responsible to manage any layers\r\n * in a given scene.\r\n */\r\nexport class LayerSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_LAYER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _engine: Engine;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this.scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this.scene) {\r\n            return;\r\n        }\r\n        this._engine = this.scene.getEngine();\r\n        this.scene.layers = new Array<Layer>();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForegroundWithPostProcessing);\r\n        this.scene._afterCameraPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER, this, this._drawCameraForegroundWithoutPostProcessing);\r\n\r\n        this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);\r\n        this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForegroundWithPostProcessing);\r\n        this.scene._afterRenderTargetPostProcessStage.registerStep(\r\n            SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER,\r\n            this,\r\n            this._drawRenderTargetForegroundWithoutPostProcessing\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const layers = this.scene.layers;\r\n\r\n        for (const layer of layers) {\r\n            layer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const layers = this.scene.layers;\r\n\r\n        while (layers.length) {\r\n            layers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _draw(predicate: (layer: Layer) => boolean): void {\r\n        const layers = this.scene.layers;\r\n\r\n        if (layers.length) {\r\n            this._engine.setDepthBuffer(false);\r\n            for (const layer of layers) {\r\n                if (predicate(layer)) {\r\n                    layer.render();\r\n                }\r\n            }\r\n            this._engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _drawCameraPredicate(layer: Layer, isBackground: boolean, applyPostProcess: boolean, cameraLayerMask: number): boolean {\r\n        return (\r\n            !layer.renderOnlyInRenderTargetTextures &&\r\n            layer.isBackground === isBackground &&\r\n            layer.applyPostProcess === applyPostProcess &&\r\n            (layer.layerMask & cameraLayerMask) !== 0\r\n        );\r\n    }\r\n\r\n    private _drawCameraBackground(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, true, true, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawCameraForegroundWithPostProcessing(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, false, true, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawCameraForegroundWithoutPostProcessing(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, false, false, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetPredicate(layer: Layer, isBackground: boolean, applyPostProcess: boolean, cameraLayerMask: number, renderTargetTexture: RenderTargetTexture): boolean {\r\n        return (\r\n            layer.renderTargetTextures.length > 0 &&\r\n            layer.isBackground === isBackground &&\r\n            layer.applyPostProcess === applyPostProcess &&\r\n            layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 &&\r\n            (layer.layerMask & cameraLayerMask) !== 0\r\n        );\r\n    }\r\n\r\n    private _drawRenderTargetBackground(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, true, true, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetForegroundWithPostProcessing(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, false, true, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetForegroundWithoutPostProcessing(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, false, false, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: AbstractScene): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            this.scene.layers.push(layer);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: AbstractScene, dispose = false): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            const index = this.scene.layers.indexOf(layer);\r\n            if (index !== -1) {\r\n                this.scene.layers.splice(index, 1);\r\n            }\r\n            if (dispose) {\r\n                layer.dispose();\r\n            }\r\n        });\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"layerPixelShader\";\nconst shader = `varying vec2 vUV;\runiform sampler2D textureSampler;\runiform vec4 color;\r#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvec4 baseColor=texture2D(textureSampler,vUV);\r#ifdef LINEAR\nbaseColor.rgb=toGammaSpace(baseColor.rgb);\r#endif\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\rdiscard;\r#endif\ngl_FragColor=baseColor*color;\r#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const layerPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"layerVertexShader\";\nconst shader = `attribute vec2 position;\runiform vec2 scale;\runiform vec2 offset;\runiform mat4 textureMatrix;\rvarying vec2 vUV;\rconst vec2 madd=vec2(0.5,0.5);\r#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\nvec2 shiftedPosition=position*scale+offset;\rvUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));\rgl_Position=vec4(shiftedPosition,0.0,1.0);\r#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const layerVertexShader = { name, shader };\n", "import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { LayerSceneComponent } from \"./layerSceneComponent\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\nimport \"../Shaders/layer.fragment\";\r\nimport \"../Shaders/layer.vertex\";\r\n\r\n/**\r\n * This represents a full screen 2d layer.\r\n * This can be useful to display a picture in the  background of your scene for instance.\r\n * @see https://www.babylonjs-playground.com/#08A2BS#1\r\n */\r\nexport class Layer {\r\n    /**\r\n     * Define the texture the layer should display.\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Is the layer in background or foreground.\r\n     */\r\n    public isBackground: boolean;\r\n\r\n    private _applyPostProcess: boolean = true;\r\n    /**\r\n     * Determines if the layer is drawn before (true) or after (false) post-processing.\r\n     * If the layer is background, it is always before.\r\n     */\r\n    public set applyPostProcess(value: boolean) {\r\n        this._applyPostProcess = value;\r\n    }\r\n    public get applyPostProcess(): boolean {\r\n        return this.isBackground || this._applyPostProcess;\r\n    }\r\n\r\n    /**\r\n     * Define the color of the layer (instead of texture).\r\n     */\r\n    public color: Color4;\r\n\r\n    /**\r\n     * Define the scale of the layer in order to zoom in out of the texture.\r\n     */\r\n    public scale = new Vector2(1, 1);\r\n\r\n    /**\r\n     * Define an offset for the layer in order to shift the texture.\r\n     */\r\n    public offset = new Vector2(0, 0);\r\n\r\n    /**\r\n     * Define the alpha blending mode used in the layer in case the texture or color has an alpha.\r\n     */\r\n    public alphaBlendingMode = Constants.ALPHA_COMBINE;\r\n\r\n    /**\r\n     * Define if the layer should alpha test or alpha blend with the rest of the scene.\r\n     * Alpha test will not mix with the background color in case of transparency.\r\n     * It will either use the texture color or the background depending on the alpha value of the current pixel.\r\n     */\r\n    public alphaTest: boolean;\r\n\r\n    /**\r\n     * Define a mask to restrict the layer to only some of the scene cameras.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /**\r\n     * Define the list of render target the layer is visible into.\r\n     */\r\n    public renderTargetTextures: RenderTargetTexture[] = [];\r\n\r\n    /**\r\n     * Define if the layer is only used in renderTarget or if it also\r\n     * renders in the main frame buffer of the canvas.\r\n     */\r\n    public renderOnlyInRenderTargetTextures = false;\r\n\r\n    /**\r\n     * Define if the layer is enabled (ie. should be displayed). Default: true\r\n     */\r\n    public isEnabled = true;\r\n\r\n    private _scene: Scene;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _drawWrapper: DrawWrapper;\r\n    private _previousDefines: string;\r\n\r\n    /**\r\n     * An event triggered when the layer is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<Layer>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onDisposeObservable existed.\r\n     * The set callback will be triggered when the layer has been disposed.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered before rendering the scene\r\n     */\r\n    public onBeforeRenderObservable = new Observable<Layer>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onBeforeRenderObservable existed.\r\n     * The set callback will be triggered just before rendering the layer.\r\n     */\r\n    public set onBeforeRender(callback: () => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered after rendering the scene\r\n     */\r\n    public onAfterRenderObservable = new Observable<Layer>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onAfterRenderObservable existed.\r\n     * The set callback will be triggered just after rendering the layer.\r\n     */\r\n    public set onAfterRender(callback: () => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new layer.\r\n     * This represents a full screen 2d layer.\r\n     * This can be useful to display a picture in the  background of your scene for instance.\r\n     * @see https://www.babylonjs-playground.com/#08A2BS#1\r\n     * @param name Define the name of the layer in the scene\r\n     * @param imgUrl Define the url of the texture to display in the layer\r\n     * @param scene Define the scene the layer belongs to\r\n     * @param isBackground Defines whether the layer is displayed in front or behind the scene\r\n     * @param color Defines a color for the layer\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define the name of the layer.\r\n         */\r\n        public name: string,\r\n        imgUrl: Nullable<string>,\r\n        scene: Nullable<Scene>,\r\n        isBackground?: boolean,\r\n        color?: Color4\r\n    ) {\r\n        this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;\r\n        this.isBackground = isBackground === undefined ? true : isBackground;\r\n        this.color = color === undefined ? new Color4(1, 1, 1, 1) : color;\r\n\r\n        this._scene = <Scene>(scene || EngineStore.LastCreatedScene);\r\n        let layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER) as LayerSceneComponent;\r\n        if (!layerComponent) {\r\n            layerComponent = new LayerSceneComponent(this._scene);\r\n            this._scene._addComponent(layerComponent);\r\n        }\r\n        this._scene.layers.push(this);\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._drawWrapper = new DrawWrapper(engine);\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        const vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Renders the layer in the scene.\r\n     */\r\n    public render(): void {\r\n        if (!this.isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        let defines = \"\";\r\n\r\n        if (this.alphaTest) {\r\n            defines = \"#define ALPHATEST\";\r\n        }\r\n\r\n        if (this.texture && !this.texture.gammaSpace) {\r\n            defines += \"\\r\\n#define LINEAR\";\r\n        }\r\n\r\n        if (this._previousDefines !== defines) {\r\n            this._previousDefines = defines;\r\n            this._drawWrapper.effect = engine.createEffect(\"layer\", [VertexBuffer.PositionKind], [\"textureMatrix\", \"color\", \"scale\", \"offset\"], [\"textureSampler\"], defines);\r\n        }\r\n        const currentEffect = this._drawWrapper.effect;\r\n\r\n        // Check\r\n        if (!currentEffect || !currentEffect.isReady() || !this.texture || !this.texture.isReady()) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeRenderObservable.notifyObservers(this);\r\n\r\n        // Render\r\n        engine.enableEffect(this._drawWrapper);\r\n        engine.setState(false);\r\n\r\n        // Texture\r\n        currentEffect.setTexture(\"textureSampler\", this.texture);\r\n        currentEffect.setMatrix(\"textureMatrix\", this.texture.getTextureMatrix());\r\n\r\n        // Color\r\n        currentEffect.setFloat4(\"color\", this.color.r, this.color.g, this.color.b, this.color.a);\r\n\r\n        // Scale / offset\r\n        currentEffect.setVector2(\"offset\", this.offset);\r\n        currentEffect.setVector2(\"scale\", this.scale);\r\n\r\n        // VBOs\r\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);\r\n\r\n        // Draw order\r\n        if (!this.alphaTest) {\r\n            engine.setAlphaMode(this.alphaBlendingMode);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        } else {\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        this.onAfterRenderObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Disposes and releases the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        if (this.texture) {\r\n            this.texture.dispose();\r\n            this.texture = null;\r\n        }\r\n\r\n        // Clean RTT list\r\n        this.renderTargetTextures = [];\r\n\r\n        // Remove from scene\r\n        const index = this._scene.layers.indexOf(this);\r\n        this._scene.layers.splice(index, 1);\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["result", "name", "virtualMeshesInfo", "angle", "minMaxAngle", "name", "featureName", "NodeMaterialBlockConnectionPointTypes", "NodeMaterialBlockTargets", "NodeMaterialConnectionPointCompatibilityStates", "NodeMaterialConnectionPointDirection", "name", "name", "name", "name", "PropertyTypeForEdition", "name", "NodeMaterialBlockConnectionPointMode", "NodeMaterialSystemValues", "AnimatedInputBlockTypes", "name", "name", "name", "name", "name", "name", "name", "name", "NodeMaterialModes", "name", "name", "name", "TrigonometryBlockOperations", "name", "name", "name", "result", "effect", "name", "HandPart", "WebXRHandJoint", "name", "_a", "_b", "HandConstraintZone", "HandConstraintOrientation", "HandConstraintVisibility", "name", "pointerEvent", "_a", "_b", "name", "name", "shader", "name", "shader", "name"]
}
