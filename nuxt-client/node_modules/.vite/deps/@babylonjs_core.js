import {
  AnimationEvent,
  ApplyPostProcess,
  AssetContainer,
  AutoReleaseWorkerPool,
  BRDFTextureTools,
  BaseCameraMouseWheelInput,
  Bone,
  CameraInputTypes,
  CameraInputsManager,
  CreateEnvTextureAsync,
  CreateImageDataArrayBufferViews,
  CreateResizedCopy,
  CubeMapToSphericalPolynomialTools,
  CubeTexture,
  DataReader,
  Deferred,
  DirectionalLight,
  DracoCompression,
  EnvironmentTextureTools,
  FreeCamera,
  FreeCameraInputsManager,
  FreeCameraKeyboardMoveInput,
  FreeCameraMouseInput,
  FreeCameraMouseWheelInput,
  FreeCameraTouchInput,
  FromHalfFloat,
  GetEnvInfo,
  GetEnvironmentBRDFTexture,
  InstantiatedEntries,
  KeepAssets,
  MaterialAnisotropicDefines,
  MaterialClearCoatDefines,
  MaterialIridescenceDefines,
  MaterialSheenDefines,
  MaterialSubSurfaceDefines,
  MeshoptCompression,
  MorphTarget,
  MorphTargetManager,
  PBRAnisotropicConfiguration,
  PBRBRDFConfiguration,
  PBRBaseMaterial,
  PBRClearCoatConfiguration,
  PBRIridescenceConfiguration,
  PBRMaterial,
  PBRMaterialDefines,
  PBRSheenConfiguration,
  PBRSubSurfaceConfiguration,
  PassCubePostProcess,
  PassPostProcess,
  PointLight,
  RGBDTextureTools,
  RawCubeTexture,
  RawTexture,
  RawTexture2DArray,
  ShadowLight,
  Skeleton,
  Sound,
  SphericalHarmonics,
  SphericalPolynomial,
  SpotLight,
  TargetCamera,
  TextureTools,
  ToHalfFloat,
  UploadEnvLevelsAsync,
  UploadEnvSpherical,
  UploadLevelsAsync,
  WeightedSound,
  WorkerPool,
  _UpdateRGBDAsync,
  normalizeEnvInfo
} from "./chunk-W7TSTCRI.js";
import {
  AnimatedInputBlockTypes,
  BaseParticleSystem,
  BaseSixDofDragBehavior,
  BoxBuilder,
  BoxParticleEmitter,
  ClipboardEventTypes,
  ClipboardInfo,
  ColorSplitterBlock,
  ConeParticleEmitter,
  CreateBox,
  CreateBoxVertexData,
  CreateIcoSphere,
  CreateIcoSphereVertexData,
  CreatePlane,
  CreatePlaneVertexData,
  CurrentScreenBlock,
  CustomParticleEmitter,
  CylinderDirectedParticleEmitter,
  CylinderParticleEmitter,
  DistanceJoint,
  DynamicTexture,
  FadeInOutBehavior,
  FollowBehavior,
  FragmentOutputBlock,
  Gizmo,
  HandConstraintBehavior,
  HandConstraintOrientation,
  HandConstraintVisibility,
  HandConstraintZone,
  HandPart,
  HemisphericParticleEmitter,
  Hinge2Joint,
  HingeJoint,
  IcoSphereBuilder,
  InputBlock,
  Layer,
  LayerSceneComponent,
  MeshParticleEmitter,
  MotorEnabledJoint,
  MultiplyBlock,
  NodeMaterial,
  NodeMaterialBlock,
  NodeMaterialBlockConnectionPointMode,
  NodeMaterialBlockConnectionPointTypes,
  NodeMaterialBlockTargets,
  NodeMaterialConnectionPoint,
  NodeMaterialConnectionPointCompatibilityStates,
  NodeMaterialConnectionPointDirection,
  NodeMaterialDefines,
  NodeMaterialModes,
  NodeMaterialSystemValues,
  ParticleBlendMultiplyBlock,
  ParticleRampGradientBlock,
  ParticleTextureBlock,
  PhysicsImpostor,
  PhysicsJoint,
  PivotTools,
  PlaneBuilder,
  PointParticleEmitter,
  PointerDragBehavior,
  ProceduralTexture,
  ProceduralTextureSceneComponent,
  PropertyTypeForEdition,
  Ray,
  RemapBlock,
  SixDofDragBehavior,
  SphereDirectedParticleEmitter,
  SphereParticleEmitter,
  SurfaceMagnetismBehavior,
  TransformBlock,
  TrigonometryBlock,
  TrigonometryBlockOperations,
  UtilityLayerRenderer,
  VectorMergerBlock,
  VertexOutputBlock,
  WebXRAbstractFeature,
  WebXRFeatureName,
  WebXRFeaturesManager,
  WebXRHand,
  WebXRHandJoint,
  WebXRHandTracking,
  editableInPropertyPage
} from "./chunk-3CAGSAXU.js";
import {
  AbstractActionManager,
  AbstractMesh,
  AbstractScene,
  ActionEvent,
  AlphaState,
  AndOrNotEvaluator,
  Angle,
  Animation,
  AnimationGroup,
  AnimationKeyInterpolation,
  AnimationRange,
  Arc2,
  ArrayTools,
  AsyncLoop,
  Axis,
  BaseError,
  BaseTexture,
  BezierCurve,
  BoundingBox,
  BoundingInfo,
  BoundingSphere,
  Buffer,
  Camera,
  Color3,
  Color4,
  ColorCurves,
  CompatibilityOptions,
  Constants,
  Coordinate,
  CopyTools,
  Curve3,
  DataBuffer,
  Decode,
  DecodeBase64ToBinary,
  DecodeBase64ToString,
  DecodeBase64UrlToBinary,
  DecodeBase64UrlToString,
  DeepCopier,
  DepthCullingState,
  DetailMapConfiguration,
  DeviceInputEventType,
  DeviceSource,
  DeviceSourceManager,
  DeviceType,
  DomManagement,
  DrawWrapper,
  DualSenseInput,
  DualShockInput,
  DumpTools,
  Effect,
  EffectFallbacks,
  EffectRenderer,
  EffectWrapper,
  EncodeArrayBufferToBase64,
  EndsWith,
  Engine,
  EngineStore,
  Epsilon,
  ErrorCodes,
  EventConstants,
  EventState,
  FileTools,
  FileToolsOptions,
  FilesInputStore,
  Frustum,
  GUID,
  GenerateBase64StringFromPixelData,
  GenerateBase64StringFromTexture,
  GenerateBase64StringFromTextureAsync,
  Geometry,
  GetClass,
  GetDOMTextContent,
  HemisphericLight,
  ImageProcessingConfiguration,
  ImageProcessingConfigurationDefines,
  InternalTexture,
  InternalTextureSource,
  IntersectionInfo,
  IsBase64DataUrl,
  IsDocumentAvailable,
  IsFileURL,
  IsNavigatorAvailable,
  IsWindowObjectExist,
  KeyboardEventTypes,
  KeyboardInfo,
  KeyboardInfoPre,
  Light,
  LightConstants,
  LoadFile,
  LoadFileError,
  LoadImage,
  Logger,
  Material,
  MaterialDefines,
  MaterialDetailMapDefines,
  MaterialFlags,
  MaterialHelper,
  MaterialPluginBase,
  MaterialPluginEvent,
  MaterialPluginManager,
  Matrix,
  Mesh,
  MeshLODLevel,
  MultiMaterial,
  NativePointerInput,
  Node as Node2,
  Observable,
  Observer,
  Orientation,
  PHI,
  PadNumber,
  Path2,
  Path3D,
  PerfCounter,
  PerformanceConfigurator,
  PerformanceMonitor,
  PickingInfo,
  Plane,
  PointerEventTypes,
  PointerInfo,
  PointerInfoBase,
  PointerInfoPre,
  PointerInput,
  PositionNormalTextureVertex,
  PositionNormalVertex,
  PostProcess,
  PostProcessManager,
  PrecisionDate,
  PushMaterial,
  Quaternion,
  RandomGUID,
  ReadFile,
  ReadFileError,
  RegisterClass,
  RegisterMaterialPlugin,
  RenderTargetTexture,
  RenderTargetWrapper,
  RenderingGroup,
  RenderingGroupInfo,
  RenderingManager,
  RequestFile,
  RequestFileError,
  RetryStrategy,
  RollingAverage,
  RuntimeError,
  Scalar,
  Scene,
  SceneComponentConstants,
  SceneLoader,
  SceneLoaderAnimationGroupLoadingMode,
  SceneLoaderFlags,
  ScenePerformancePriority,
  SerializationHelper,
  SetCorsBehavior,
  ShaderLanguage,
  ShaderMaterial,
  ShaderProcessor,
  ShaderStore,
  Size,
  SmartArray,
  SmartArrayNoDuplicate,
  Space,
  Stage,
  StandardMaterial,
  StandardMaterialDefines,
  StartsWith,
  StencilState,
  StencilStateComposer,
  StringDictionary,
  StringTools,
  SubMesh,
  SwitchInput,
  Tags,
  TargetedAnimation,
  TestBase64DataUrl,
  Texture,
  TextureSampler,
  ThinEngine,
  ThinTexture,
  TmpColors,
  TmpVectors,
  ToGammaSpace,
  ToLinearSpace,
  Tools,
  TransformNode,
  UniformBuffer,
  UniqueIdGenerator,
  UnregisterAllMaterialPlugins,
  UnregisterMaterialPlugin,
  Vector2,
  Vector3,
  Vector4,
  VertexBuffer,
  VertexData,
  Viewport,
  WebGL2ShaderProcessor,
  WebGLDataBuffer,
  WebGLHardwareTexture,
  WebGLPipelineContext,
  WebRequest,
  XboxInput,
  _CreationDataStorage,
  _IAnimationState,
  _InstancesBatch,
  _MeshCollisionData,
  _WarnImport,
  __decorate,
  _injectLTSFileTools,
  addClipPlaneUniforms,
  allocateAndCopyTypedBuffer,
  bindClipPlane,
  className,
  createYieldingScheduler,
  expandToProperty,
  extractMinAndMax,
  extractMinAndMaxIndexed,
  inlineScheduler,
  makeAsyncFunction,
  makeSyncFunction,
  nativeOverride,
  prepareDefinesForClipPlanes,
  runCoroutine,
  runCoroutineAsync,
  runCoroutineSync,
  serialize,
  serializeAsCameraReference,
  serializeAsColor3,
  serializeAsColor4,
  serializeAsColorCurves,
  serializeAsFresnelParameters,
  serializeAsImageProcessingConfiguration,
  serializeAsMatrix,
  serializeAsMeshReference,
  serializeAsQuaternion,
  serializeAsTexture,
  serializeAsVector2,
  serializeAsVector3
} from "./chunk-PPM2REY6.js";
import "./chunk-JC4IRQUL.js";

// node_modules/@babylonjs/core/Actions/action.js
var Action = class {
  constructor(triggerOptions, condition) {
    this.triggerOptions = triggerOptions;
    this.onBeforeExecuteObservable = new Observable();
    if (triggerOptions.parameter) {
      this.trigger = triggerOptions.trigger;
      this._triggerParameter = triggerOptions.parameter;
    } else if (triggerOptions.trigger) {
      this.trigger = triggerOptions.trigger;
    } else {
      this.trigger = triggerOptions;
    }
    this._nextActiveAction = this;
    this._condition = condition;
  }
  _prepare() {
  }
  getTriggerParameter() {
    return this._triggerParameter;
  }
  setTriggerParameter(value) {
    this._triggerParameter = value;
  }
  _evaluateConditionForCurrentFrame() {
    const condition = this._condition;
    if (!condition) {
      return true;
    }
    const currentRenderId = this._actionManager.getScene().getRenderId();
    if (condition._evaluationId !== currentRenderId) {
      condition._evaluationId = currentRenderId;
      condition._currentResult = condition.isValid();
    }
    return condition._currentResult;
  }
  _executeCurrent(evt) {
    const isConditionValid = this._evaluateConditionForCurrentFrame();
    if (!isConditionValid) {
      return;
    }
    this.onBeforeExecuteObservable.notifyObservers(this);
    this._nextActiveAction.execute(evt);
    this.skipToNextActiveAction();
  }
  execute(evt) {
  }
  skipToNextActiveAction() {
    if (this._nextActiveAction._child) {
      if (!this._nextActiveAction._child._actionManager) {
        this._nextActiveAction._child._actionManager = this._actionManager;
      }
      this._nextActiveAction = this._nextActiveAction._child;
    } else {
      this._nextActiveAction = this;
    }
  }
  then(action) {
    this._child = action;
    action._actionManager = this._actionManager;
    action._prepare();
    return action;
  }
  _getProperty(propertyPath) {
    return this._actionManager._getProperty(propertyPath);
  }
  _getEffectiveTarget(target, propertyPath) {
    return this._actionManager._getEffectiveTarget(target, propertyPath);
  }
  serialize(parent) {
  }
  _serialize(serializedAction, parent) {
    const serializationObject = {
      type: 1,
      children: [],
      name: serializedAction.name,
      properties: serializedAction.properties || []
    };
    if (this._child) {
      this._child.serialize(serializationObject);
    }
    if (this._condition) {
      const serializedCondition = this._condition.serialize();
      serializedCondition.children.push(serializationObject);
      if (parent) {
        parent.children.push(serializedCondition);
      }
      return serializedCondition;
    }
    if (parent) {
      parent.children.push(serializationObject);
    }
    return serializationObject;
  }
};
Action._SerializeValueAsString = (value) => {
  if (typeof value === "number") {
    return value.toString();
  }
  if (typeof value === "boolean") {
    return value ? "true" : "false";
  }
  if (value instanceof Vector2) {
    return value.x + ", " + value.y;
  }
  if (value instanceof Vector3) {
    return value.x + ", " + value.y + ", " + value.z;
  }
  if (value instanceof Color3) {
    return value.r + ", " + value.g + ", " + value.b;
  }
  if (value instanceof Color4) {
    return value.r + ", " + value.g + ", " + value.b + ", " + value.a;
  }
  return value;
};
Action._GetTargetProperty = (target) => {
  return {
    name: "target",
    targetType: target._isMesh ? "MeshProperties" : target._isLight ? "LightProperties" : target._isCamera ? "CameraProperties" : target._isMaterial ? "MaterialProperties" : "SceneProperties",
    value: target._isScene ? "Scene" : target.name
  };
};
RegisterClass("BABYLON.Action", Action);

// node_modules/@babylonjs/core/Actions/condition.js
var Condition = class {
  constructor(actionManager) {
    this._actionManager = actionManager;
  }
  isValid() {
    return true;
  }
  _getProperty(propertyPath) {
    return this._actionManager._getProperty(propertyPath);
  }
  _getEffectiveTarget(target, propertyPath) {
    return this._actionManager._getEffectiveTarget(target, propertyPath);
  }
  serialize() {
  }
  _serialize(serializedCondition) {
    return {
      type: 2,
      children: [],
      name: serializedCondition.name,
      properties: serializedCondition.properties
    };
  }
};
var ValueCondition = class extends Condition {
  constructor(actionManager, target, propertyPath, value, operator = ValueCondition.IsEqual) {
    super(actionManager);
    this.propertyPath = propertyPath;
    this.value = value;
    this.operator = operator;
    this._target = target;
    this._effectiveTarget = this._getEffectiveTarget(target, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
  }
  static get IsEqual() {
    return ValueCondition._IsEqual;
  }
  static get IsDifferent() {
    return ValueCondition._IsDifferent;
  }
  static get IsGreater() {
    return ValueCondition._IsGreater;
  }
  static get IsLesser() {
    return ValueCondition._IsLesser;
  }
  isValid() {
    switch (this.operator) {
      case ValueCondition.IsGreater:
        return this._effectiveTarget[this._property] > this.value;
      case ValueCondition.IsLesser:
        return this._effectiveTarget[this._property] < this.value;
      case ValueCondition.IsEqual:
      case ValueCondition.IsDifferent: {
        let check;
        if (this.value.equals) {
          check = this.value.equals(this._effectiveTarget[this._property]);
        } else {
          check = this.value === this._effectiveTarget[this._property];
        }
        return this.operator === ValueCondition.IsEqual ? check : !check;
      }
    }
    return false;
  }
  serialize() {
    return this._serialize({
      name: "ValueCondition",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath },
        { name: "value", value: Action._SerializeValueAsString(this.value) },
        { name: "operator", value: ValueCondition.GetOperatorName(this.operator) }
      ]
    });
  }
  static GetOperatorName(operator) {
    switch (operator) {
      case ValueCondition._IsEqual:
        return "IsEqual";
      case ValueCondition._IsDifferent:
        return "IsDifferent";
      case ValueCondition._IsGreater:
        return "IsGreater";
      case ValueCondition._IsLesser:
        return "IsLesser";
      default:
        return "";
    }
  }
};
ValueCondition._IsEqual = 0;
ValueCondition._IsDifferent = 1;
ValueCondition._IsGreater = 2;
ValueCondition._IsLesser = 3;
var PredicateCondition = class extends Condition {
  constructor(actionManager, predicate) {
    super(actionManager);
    this.predicate = predicate;
  }
  isValid() {
    return this.predicate();
  }
};
var StateCondition = class extends Condition {
  constructor(actionManager, target, value) {
    super(actionManager);
    this.value = value;
    this._target = target;
  }
  isValid() {
    return this._target.state === this.value;
  }
  serialize() {
    return this._serialize({
      name: "StateCondition",
      properties: [Action._GetTargetProperty(this._target), { name: "value", value: this.value }]
    });
  }
};
RegisterClass("BABYLON.ValueCondition", ValueCondition);
RegisterClass("BABYLON.PredicateCondition", PredicateCondition);
RegisterClass("BABYLON.StateCondition", StateCondition);

// node_modules/@babylonjs/core/Actions/directActions.js
var SwitchBooleanAction = class extends Action {
  constructor(triggerOptions, target, propertyPath, condition) {
    super(triggerOptions, condition);
    this.propertyPath = propertyPath;
    this._target = this._effectiveTarget = target;
  }
  _prepare() {
    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
  }
  execute() {
    this._effectiveTarget[this._property] = !this._effectiveTarget[this._property];
  }
  serialize(parent) {
    return super._serialize({
      name: "SwitchBooleanAction",
      properties: [Action._GetTargetProperty(this._target), { name: "propertyPath", value: this.propertyPath }]
    }, parent);
  }
};
var SetStateAction = class extends Action {
  constructor(triggerOptions, target, value, condition) {
    super(triggerOptions, condition);
    this.value = value;
    this._target = target;
  }
  execute() {
    this._target.state = this.value;
  }
  serialize(parent) {
    return super._serialize({
      name: "SetStateAction",
      properties: [Action._GetTargetProperty(this._target), { name: "value", value: this.value }]
    }, parent);
  }
};
var SetValueAction = class extends Action {
  constructor(triggerOptions, target, propertyPath, value, condition) {
    super(triggerOptions, condition);
    this.propertyPath = propertyPath;
    this.value = value;
    this._target = this._effectiveTarget = target;
  }
  _prepare() {
    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
  }
  execute() {
    this._effectiveTarget[this._property] = this.value;
    if (this._target.markAsDirty) {
      this._target.markAsDirty(this._property);
    }
  }
  serialize(parent) {
    return super._serialize({
      name: "SetValueAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath },
        { name: "value", value: Action._SerializeValueAsString(this.value) }
      ]
    }, parent);
  }
};
var IncrementValueAction = class extends Action {
  constructor(triggerOptions, target, propertyPath, value, condition) {
    super(triggerOptions, condition);
    this.propertyPath = propertyPath;
    this.value = value;
    this._target = this._effectiveTarget = target;
  }
  _prepare() {
    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
    if (typeof this._effectiveTarget[this._property] !== "number") {
      Logger.Warn("Warning: IncrementValueAction can only be used with number values");
    }
  }
  execute() {
    this._effectiveTarget[this._property] += this.value;
    if (this._target.markAsDirty) {
      this._target.markAsDirty(this._property);
    }
  }
  serialize(parent) {
    return super._serialize({
      name: "IncrementValueAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath },
        { name: "value", value: Action._SerializeValueAsString(this.value) }
      ]
    }, parent);
  }
};
var PlayAnimationAction = class extends Action {
  constructor(triggerOptions, target, from, to, loop, condition) {
    super(triggerOptions, condition);
    this.from = from;
    this.to = to;
    this.loop = loop;
    this._target = target;
  }
  _prepare() {
  }
  execute() {
    const scene = this._actionManager.getScene();
    scene.beginAnimation(this._target, this.from, this.to, this.loop);
  }
  serialize(parent) {
    return super._serialize({
      name: "PlayAnimationAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "from", value: String(this.from) },
        { name: "to", value: String(this.to) },
        { name: "loop", value: Action._SerializeValueAsString(this.loop) || false }
      ]
    }, parent);
  }
};
var StopAnimationAction = class extends Action {
  constructor(triggerOptions, target, condition) {
    super(triggerOptions, condition);
    this._target = target;
  }
  _prepare() {
  }
  execute() {
    const scene = this._actionManager.getScene();
    scene.stopAnimation(this._target);
  }
  serialize(parent) {
    return super._serialize({
      name: "StopAnimationAction",
      properties: [Action._GetTargetProperty(this._target)]
    }, parent);
  }
};
var DoNothingAction = class extends Action {
  constructor(triggerOptions = 0, condition) {
    super(triggerOptions, condition);
  }
  execute() {
  }
  serialize(parent) {
    return super._serialize({
      name: "DoNothingAction",
      properties: []
    }, parent);
  }
};
var CombineAction = class extends Action {
  constructor(triggerOptions, children, condition, enableChildrenConditions = true) {
    super(triggerOptions, condition);
    this.children = children;
    this.enableChildrenConditions = enableChildrenConditions;
  }
  _prepare() {
    for (let index = 0; index < this.children.length; index++) {
      this.children[index]._actionManager = this._actionManager;
      this.children[index]._prepare();
    }
  }
  execute(evt) {
    for (const action of this.children) {
      if (!this.enableChildrenConditions || action._evaluateConditionForCurrentFrame()) {
        action.execute(evt);
      }
    }
  }
  serialize(parent) {
    const serializationObject = super._serialize({
      name: "CombineAction",
      properties: [],
      combine: []
    }, parent);
    for (let i = 0; i < this.children.length; i++) {
      serializationObject.combine.push(this.children[i].serialize(null));
    }
    return serializationObject;
  }
};
var ExecuteCodeAction = class extends Action {
  constructor(triggerOptions, func, condition) {
    super(triggerOptions, condition);
    this.func = func;
  }
  execute(evt) {
    this.func(evt);
  }
};
var SetParentAction = class extends Action {
  constructor(triggerOptions, target, parent, condition) {
    super(triggerOptions, condition);
    this._target = target;
    this._parent = parent;
  }
  _prepare() {
  }
  execute() {
    if (this._target.parent === this._parent) {
      return;
    }
    const invertParentWorldMatrix = this._parent.getWorldMatrix().clone();
    invertParentWorldMatrix.invert();
    this._target.position = Vector3.TransformCoordinates(this._target.position, invertParentWorldMatrix);
    this._target.parent = this._parent;
  }
  serialize(parent) {
    return super._serialize({
      name: "SetParentAction",
      properties: [Action._GetTargetProperty(this._target), Action._GetTargetProperty(this._parent)]
    }, parent);
  }
};
RegisterClass("BABYLON.SetParentAction", SetParentAction);
RegisterClass("BABYLON.ExecuteCodeAction", ExecuteCodeAction);
RegisterClass("BABYLON.DoNothingAction", DoNothingAction);
RegisterClass("BABYLON.StopAnimationAction", StopAnimationAction);
RegisterClass("BABYLON.PlayAnimationAction", PlayAnimationAction);
RegisterClass("BABYLON.IncrementValueAction", IncrementValueAction);
RegisterClass("BABYLON.SetValueAction", SetValueAction);
RegisterClass("BABYLON.SetStateAction", SetStateAction);
RegisterClass("BABYLON.SetParentAction", SetParentAction);
RegisterClass("BABYLON.SwitchBooleanAction", SwitchBooleanAction);
RegisterClass("BABYLON.CombineAction", CombineAction);

// node_modules/@babylonjs/core/Actions/actionManager.js
var ActionManager = class extends AbstractActionManager {
  constructor(scene) {
    super();
    scene = scene || EngineStore.LastCreatedScene;
    if (!scene) {
      return;
    }
    this._scene = scene;
    scene.actionManagers.push(this);
  }
  dispose() {
    const index = this._scene.actionManagers.indexOf(this);
    for (let i = 0; i < this.actions.length; i++) {
      const action = this.actions[i];
      ActionManager.Triggers[action.trigger]--;
      if (ActionManager.Triggers[action.trigger] === 0) {
        delete ActionManager.Triggers[action.trigger];
      }
    }
    if (index > -1) {
      this._scene.actionManagers.splice(index, 1);
    }
  }
  getScene() {
    return this._scene;
  }
  hasSpecificTriggers(triggers) {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (triggers.indexOf(action.trigger) > -1) {
        return true;
      }
    }
    return false;
  }
  hasSpecificTriggers2(triggerA, triggerB) {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (triggerA == action.trigger || triggerB == action.trigger) {
        return true;
      }
    }
    return false;
  }
  hasSpecificTrigger(trigger, parameterPredicate) {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (action.trigger === trigger) {
        if (parameterPredicate) {
          if (parameterPredicate(action.getTriggerParameter())) {
            return true;
          }
        } else {
          return true;
        }
      }
    }
    return false;
  }
  get hasPointerTriggers() {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPointerOutTrigger) {
        return true;
      }
    }
    return false;
  }
  get hasPickTriggers() {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPickUpTrigger) {
        return true;
      }
    }
    return false;
  }
  registerAction(action) {
    if (action.trigger === ActionManager.OnEveryFrameTrigger) {
      if (this.getScene().actionManager !== this) {
        Logger.Warn("OnEveryFrameTrigger can only be used with scene.actionManager");
        return null;
      }
    }
    this.actions.push(action);
    this.getScene()._registeredActions++;
    if (ActionManager.Triggers[action.trigger]) {
      ActionManager.Triggers[action.trigger]++;
    } else {
      ActionManager.Triggers[action.trigger] = 1;
    }
    action._actionManager = this;
    action._prepare();
    return action;
  }
  unregisterAction(action) {
    const index = this.actions.indexOf(action);
    if (index !== -1) {
      this.actions.splice(index, 1);
      ActionManager.Triggers[action.trigger] -= 1;
      if (ActionManager.Triggers[action.trigger] === 0) {
        delete ActionManager.Triggers[action.trigger];
      }
      action._actionManager = null;
      this.getScene()._registeredActions--;
      return true;
    }
    return false;
  }
  processTrigger(trigger, evt) {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (action.trigger === trigger) {
        if (evt) {
          if (trigger === ActionManager.OnKeyUpTrigger || trigger === ActionManager.OnKeyDownTrigger) {
            const parameter = action.getTriggerParameter();
            if (parameter && parameter !== evt.sourceEvent.keyCode) {
              if (!parameter.toLowerCase) {
                continue;
              }
              const lowerCase = parameter.toLowerCase();
              if (lowerCase !== evt.sourceEvent.key) {
                const unicode = evt.sourceEvent.charCode ? evt.sourceEvent.charCode : evt.sourceEvent.keyCode;
                const actualkey = String.fromCharCode(unicode).toLowerCase();
                if (actualkey !== lowerCase) {
                  continue;
                }
              }
            }
          }
        }
        action._executeCurrent(evt);
      }
    }
  }
  _getEffectiveTarget(target, propertyPath) {
    const properties = propertyPath.split(".");
    for (let index = 0; index < properties.length - 1; index++) {
      target = target[properties[index]];
    }
    return target;
  }
  _getProperty(propertyPath) {
    const properties = propertyPath.split(".");
    return properties[properties.length - 1];
  }
  serialize(name137) {
    const root = {
      children: new Array(),
      name: name137,
      type: 3,
      properties: new Array()
    };
    for (let i = 0; i < this.actions.length; i++) {
      const triggerObject = {
        type: 0,
        children: new Array(),
        name: ActionManager.GetTriggerName(this.actions[i].trigger),
        properties: new Array()
      };
      const triggerOptions = this.actions[i].triggerOptions;
      if (triggerOptions && typeof triggerOptions !== "number") {
        if (triggerOptions.parameter instanceof Node) {
          triggerObject.properties.push(Action._GetTargetProperty(triggerOptions.parameter));
        } else {
          const parameter = {};
          DeepCopier.DeepCopy(triggerOptions.parameter, parameter, ["mesh"]);
          if (triggerOptions.parameter && triggerOptions.parameter.mesh) {
            parameter._meshId = triggerOptions.parameter.mesh.id;
          }
          triggerObject.properties.push({ name: "parameter", targetType: null, value: parameter });
        }
      }
      this.actions[i].serialize(triggerObject);
      root.children.push(triggerObject);
    }
    return root;
  }
  static Parse(parsedActions, object, scene) {
    const actionManager = new ActionManager(scene);
    if (object === null) {
      scene.actionManager = actionManager;
    } else {
      object.actionManager = actionManager;
    }
    const instanciate = (name137, params) => {
      const internalClassType = GetClass("BABYLON." + name137);
      return internalClassType && new internalClassType(...params);
    };
    const parseParameter = (name137, value, target, propertyPath) => {
      if (propertyPath === null) {
        const floatValue = parseFloat(value);
        if (value === "true" || value === "false") {
          return value === "true";
        } else {
          return isNaN(floatValue) ? value : floatValue;
        }
      }
      const effectiveTarget = propertyPath.split(".");
      const values = value.split(",");
      for (let i = 0; i < effectiveTarget.length; i++) {
        target = target[effectiveTarget[i]];
      }
      if (typeof target === "boolean") {
        return values[0] === "true";
      }
      if (typeof target === "string") {
        return values[0];
      }
      const split = new Array();
      for (let i = 0; i < values.length; i++) {
        split.push(parseFloat(values[i]));
      }
      if (target instanceof Vector3) {
        return Vector3.FromArray(split);
      }
      if (target instanceof Vector4) {
        return Vector4.FromArray(split);
      }
      if (target instanceof Color3) {
        return Color3.FromArray(split);
      }
      if (target instanceof Color4) {
        return Color4.FromArray(split);
      }
      return parseFloat(values[0]);
    };
    const traverse = (parsedAction, trigger, condition, action, combineArray = null) => {
      if (parsedAction.detached) {
        return;
      }
      const parameters = new Array();
      let target = null;
      let propertyPath = null;
      const combine = parsedAction.combine && parsedAction.combine.length > 0;
      if (parsedAction.type === 2) {
        parameters.push(actionManager);
      } else {
        parameters.push(trigger);
      }
      if (combine) {
        const actions = new Array();
        for (let j = 0; j < parsedAction.combine.length; j++) {
          traverse(parsedAction.combine[j], ActionManager.NothingTrigger, condition, action, actions);
        }
        parameters.push(actions);
      } else {
        for (let i = 0; i < parsedAction.properties.length; i++) {
          let value = parsedAction.properties[i].value;
          const name137 = parsedAction.properties[i].name;
          const targetType = parsedAction.properties[i].targetType;
          if (name137 === "target") {
            if (targetType === "SceneProperties") {
              value = target = scene;
            } else if (targetType === "MaterialProperties") {
              value = target = scene.getMaterialByName(value);
            } else {
              value = target = scene.getNodeByName(value);
            }
          } else if (name137 === "parent") {
            value = scene.getNodeByName(value);
          } else if (name137 === "sound") {
            if (scene.getSoundByName) {
              value = scene.getSoundByName(value);
            }
          } else if (name137 !== "propertyPath") {
            if (parsedAction.type === 2 && name137 === "operator") {
              value = ValueCondition[value];
            } else {
              value = parseParameter(name137, value, target, name137 === "value" ? propertyPath : null);
            }
          } else {
            propertyPath = value;
          }
          parameters.push(value);
        }
      }
      if (combineArray === null) {
        parameters.push(condition);
      } else {
        parameters.push(null);
      }
      if (parsedAction.name === "InterpolateValueAction") {
        const param = parameters[parameters.length - 2];
        parameters[parameters.length - 1] = param;
        parameters[parameters.length - 2] = condition;
      }
      let newAction = instanciate(parsedAction.name, parameters);
      if (newAction instanceof Condition && condition !== null) {
        const nothing = new DoNothingAction(trigger, condition);
        if (action) {
          action.then(nothing);
        } else {
          actionManager.registerAction(nothing);
        }
        action = nothing;
      }
      if (combineArray === null) {
        if (newAction instanceof Condition) {
          condition = newAction;
          newAction = action;
        } else {
          condition = null;
          if (action) {
            action.then(newAction);
          } else {
            actionManager.registerAction(newAction);
          }
        }
      } else {
        combineArray.push(newAction);
      }
      for (let i = 0; i < parsedAction.children.length; i++) {
        traverse(parsedAction.children[i], trigger, condition, newAction, null);
      }
    };
    for (let i = 0; i < parsedActions.children.length; i++) {
      let triggerParams;
      const trigger = parsedActions.children[i];
      if (trigger.properties.length > 0) {
        const param = trigger.properties[0].value;
        const value = trigger.properties[0].targetType === null ? param : scene.getMeshByName(param);
        if (value._meshId) {
          value.mesh = scene.getMeshById(value._meshId);
        }
        triggerParams = { trigger: ActionManager[trigger.name], parameter: value };
      } else {
        triggerParams = ActionManager[trigger.name];
      }
      for (let j = 0; j < trigger.children.length; j++) {
        if (!trigger.detached) {
          traverse(trigger.children[j], triggerParams, null, null);
        }
      }
    }
  }
  static GetTriggerName(trigger) {
    switch (trigger) {
      case 0:
        return "NothingTrigger";
      case 1:
        return "OnPickTrigger";
      case 2:
        return "OnLeftPickTrigger";
      case 3:
        return "OnRightPickTrigger";
      case 4:
        return "OnCenterPickTrigger";
      case 5:
        return "OnPickDownTrigger";
      case 6:
        return "OnPickUpTrigger";
      case 7:
        return "OnLongPressTrigger";
      case 8:
        return "OnPointerOverTrigger";
      case 9:
        return "OnPointerOutTrigger";
      case 10:
        return "OnEveryFrameTrigger";
      case 11:
        return "OnIntersectionEnterTrigger";
      case 12:
        return "OnIntersectionExitTrigger";
      case 13:
        return "OnKeyDownTrigger";
      case 14:
        return "OnKeyUpTrigger";
      case 15:
        return "OnPickOutTrigger";
      default:
        return "";
    }
  }
};
ActionManager.NothingTrigger = 0;
ActionManager.OnPickTrigger = 1;
ActionManager.OnLeftPickTrigger = 2;
ActionManager.OnRightPickTrigger = 3;
ActionManager.OnCenterPickTrigger = 4;
ActionManager.OnPickDownTrigger = 5;
ActionManager.OnDoublePickTrigger = 6;
ActionManager.OnPickUpTrigger = 7;
ActionManager.OnPickOutTrigger = 16;
ActionManager.OnLongPressTrigger = 8;
ActionManager.OnPointerOverTrigger = 9;
ActionManager.OnPointerOutTrigger = 10;
ActionManager.OnEveryFrameTrigger = 11;
ActionManager.OnIntersectionEnterTrigger = 12;
ActionManager.OnIntersectionExitTrigger = 13;
ActionManager.OnKeyDownTrigger = 14;
ActionManager.OnKeyUpTrigger = 15;

// node_modules/@babylonjs/core/Actions/directAudioActions.js
var PlaySoundAction = class extends Action {
  constructor(triggerOptions, sound, condition) {
    super(triggerOptions, condition);
    this._sound = sound;
  }
  _prepare() {
  }
  execute() {
    if (this._sound !== void 0) {
      this._sound.play();
    }
  }
  serialize(parent) {
    return super._serialize({
      name: "PlaySoundAction",
      properties: [{ name: "sound", value: this._sound.name }]
    }, parent);
  }
};
var StopSoundAction = class extends Action {
  constructor(triggerOptions, sound, condition) {
    super(triggerOptions, condition);
    this._sound = sound;
  }
  _prepare() {
  }
  execute() {
    if (this._sound !== void 0) {
      this._sound.stop();
    }
  }
  serialize(parent) {
    return super._serialize({
      name: "StopSoundAction",
      properties: [{ name: "sound", value: this._sound.name }]
    }, parent);
  }
};
RegisterClass("BABYLON.PlaySoundAction", PlaySoundAction);
RegisterClass("BABYLON.StopSoundAction", StopSoundAction);

// node_modules/@babylonjs/core/Actions/interpolateValueAction.js
var InterpolateValueAction = class extends Action {
  constructor(triggerOptions, target, propertyPath, value, duration = 1e3, condition, stopOtherAnimations, onInterpolationDone) {
    super(triggerOptions, condition);
    this.duration = 1e3;
    this.onInterpolationDoneObservable = new Observable();
    this.propertyPath = propertyPath;
    this.value = value;
    this.duration = duration;
    this.stopOtherAnimations = stopOtherAnimations;
    this.onInterpolationDone = onInterpolationDone;
    this._target = this._effectiveTarget = target;
  }
  _prepare() {
    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
  }
  execute() {
    const scene = this._actionManager.getScene();
    const keys = [
      {
        frame: 0,
        value: this._effectiveTarget[this._property]
      },
      {
        frame: 100,
        value: this.value
      }
    ];
    let dataType;
    if (typeof this.value === "number") {
      dataType = Animation.ANIMATIONTYPE_FLOAT;
    } else if (this.value instanceof Color3) {
      dataType = Animation.ANIMATIONTYPE_COLOR3;
    } else if (this.value instanceof Vector3) {
      dataType = Animation.ANIMATIONTYPE_VECTOR3;
    } else if (this.value instanceof Matrix) {
      dataType = Animation.ANIMATIONTYPE_MATRIX;
    } else if (this.value instanceof Quaternion) {
      dataType = Animation.ANIMATIONTYPE_QUATERNION;
    } else {
      Logger.Warn("InterpolateValueAction: Unsupported type (" + typeof this.value + ")");
      return;
    }
    const animation = new Animation("InterpolateValueAction", this._property, 100 * (1e3 / this.duration), dataType, Animation.ANIMATIONLOOPMODE_CONSTANT);
    animation.setKeys(keys);
    if (this.stopOtherAnimations) {
      scene.stopAnimation(this._effectiveTarget);
    }
    const wrapper = () => {
      this.onInterpolationDoneObservable.notifyObservers(this);
      if (this.onInterpolationDone) {
        this.onInterpolationDone();
      }
    };
    scene.beginDirectAnimation(this._effectiveTarget, [animation], 0, 100, false, 1, wrapper);
  }
  serialize(parent) {
    return super._serialize({
      name: "InterpolateValueAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath },
        { name: "value", value: Action._SerializeValueAsString(this.value) },
        { name: "duration", value: Action._SerializeValueAsString(this.duration) },
        { name: "stopOtherAnimations", value: Action._SerializeValueAsString(this.stopOtherAnimations) || false }
      ]
    }, parent);
  }
};
RegisterClass("BABYLON.InterpolateValueAction", InterpolateValueAction);

// node_modules/@babylonjs/core/Animations/runtimeAnimation.js
var _staticOffsetValueQuaternion = Object.freeze(new Quaternion(0, 0, 0, 0));
var _staticOffsetValueVector3 = Object.freeze(Vector3.Zero());
var _staticOffsetValueVector2 = Object.freeze(Vector2.Zero());
var _staticOffsetValueSize = Object.freeze(Size.Zero());
var _staticOffsetValueColor3 = Object.freeze(Color3.Black());
var RuntimeAnimation = class {
  constructor(target, animation, scene, host) {
    this._events = new Array();
    this._currentFrame = 0;
    this._originalValue = new Array();
    this._originalBlendValue = null;
    this._offsetsCache = {};
    this._highLimitsCache = {};
    this._stopped = false;
    this._blendingFactor = 0;
    this._currentValue = null;
    this._currentActiveTarget = null;
    this._directTarget = null;
    this._targetPath = "";
    this._weight = 1;
    this._ratioOffset = 0;
    this._previousDelay = 0;
    this._previousRatio = 0;
    this._targetIsArray = false;
    this._animation = animation;
    this._target = target;
    this._scene = scene;
    this._host = host;
    this._activeTargets = [];
    animation._runtimeAnimations.push(this);
    this._animationState = {
      key: 0,
      repeatCount: 0,
      loopMode: this._getCorrectLoopMode()
    };
    if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {
      this._animationState.workValue = Matrix.Zero();
    }
    this._keys = this._animation.getKeys();
    this._minFrame = this._keys[0].frame;
    this._maxFrame = this._keys[this._keys.length - 1].frame;
    this._minValue = this._keys[0].value;
    this._maxValue = this._keys[this._keys.length - 1].value;
    if (this._minFrame !== 0) {
      const newKey = { frame: 0, value: this._minValue };
      this._keys.splice(0, 0, newKey);
    }
    if (this._target instanceof Array) {
      let index = 0;
      for (const target2 of this._target) {
        this._preparePath(target2, index);
        this._getOriginalValues(index);
        index++;
      }
      this._targetIsArray = true;
    } else {
      this._preparePath(this._target);
      this._getOriginalValues();
      this._targetIsArray = false;
      this._directTarget = this._activeTargets[0];
    }
    const events = animation.getEvents();
    if (events && events.length > 0) {
      events.forEach((e) => {
        this._events.push(e._clone());
      });
    }
    this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;
  }
  get currentFrame() {
    return this._currentFrame;
  }
  get weight() {
    return this._weight;
  }
  get currentValue() {
    return this._currentValue;
  }
  get targetPath() {
    return this._targetPath;
  }
  get target() {
    return this._currentActiveTarget;
  }
  get isAdditive() {
    return this._host && this._host.isAdditive;
  }
  _preparePath(target, targetIndex = 0) {
    const targetPropertyPath = this._animation.targetPropertyPath;
    if (targetPropertyPath.length > 1) {
      let property = target[targetPropertyPath[0]];
      for (let index = 1; index < targetPropertyPath.length - 1; index++) {
        property = property[targetPropertyPath[index]];
      }
      this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];
      this._activeTargets[targetIndex] = property;
    } else {
      this._targetPath = targetPropertyPath[0];
      this._activeTargets[targetIndex] = target;
    }
  }
  get animation() {
    return this._animation;
  }
  reset(restoreOriginal = false) {
    if (restoreOriginal) {
      if (this._target instanceof Array) {
        let index = 0;
        for (const target of this._target) {
          if (this._originalValue[index] !== void 0) {
            this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);
          }
          index++;
        }
      } else {
        if (this._originalValue[0] !== void 0) {
          this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);
        }
      }
    }
    this._offsetsCache = {};
    this._highLimitsCache = {};
    this._currentFrame = 0;
    this._blendingFactor = 0;
    for (let index = 0; index < this._events.length; index++) {
      this._events[index].isDone = false;
    }
  }
  isStopped() {
    return this._stopped;
  }
  dispose() {
    const index = this._animation.runtimeAnimations.indexOf(this);
    if (index > -1) {
      this._animation.runtimeAnimations.splice(index, 1);
    }
  }
  setValue(currentValue, weight) {
    if (this._targetIsArray) {
      for (let index = 0; index < this._target.length; index++) {
        const target = this._target[index];
        this._setValue(target, this._activeTargets[index], currentValue, weight, index);
      }
      return;
    }
    this._setValue(this._target, this._directTarget, currentValue, weight, 0);
  }
  _getOriginalValues(targetIndex = 0) {
    let originalValue;
    const target = this._activeTargets[targetIndex];
    if (target.getRestPose && this._targetPath === "_matrix") {
      originalValue = target.getRestPose();
    } else {
      originalValue = target[this._targetPath];
    }
    if (originalValue && originalValue.clone) {
      this._originalValue[targetIndex] = originalValue.clone();
    } else {
      this._originalValue[targetIndex] = originalValue;
    }
  }
  _setValue(target, destination, currentValue, weight, targetIndex) {
    this._currentActiveTarget = destination;
    this._weight = weight;
    if (this._enableBlending && this._blendingFactor <= 1) {
      if (!this._originalBlendValue) {
        const originalValue = destination[this._targetPath];
        if (originalValue.clone) {
          this._originalBlendValue = originalValue.clone();
        } else {
          this._originalBlendValue = originalValue;
        }
      }
      if (this._originalBlendValue.m) {
        if (Animation.AllowMatrixDecomposeForInterpolation) {
          if (this._currentValue) {
            Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);
          } else {
            this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);
          }
        } else {
          if (this._currentValue) {
            Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);
          } else {
            this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);
          }
        }
      } else {
        this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);
      }
      const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;
      this._blendingFactor += blendingSpeed;
    } else {
      if (!this._currentValue) {
        if (currentValue === null || currentValue === void 0 ? void 0 : currentValue.clone) {
          this._currentValue = currentValue.clone();
        } else {
          this._currentValue = currentValue;
        }
      } else if (this._currentValue.copyFrom) {
        this._currentValue.copyFrom(currentValue);
      } else {
        this._currentValue = currentValue;
      }
    }
    if (weight !== -1) {
      this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);
    } else {
      destination[this._targetPath] = this._currentValue;
    }
    if (target.markAsDirty) {
      target.markAsDirty(this._animation.targetProperty);
    }
  }
  _getCorrectLoopMode() {
    if (this._target && this._target.animationPropertiesOverride) {
      return this._target.animationPropertiesOverride.loopMode;
    }
    return this._animation.loopMode;
  }
  goToFrame(frame) {
    const keys = this._animation.getKeys();
    if (frame < keys[0].frame) {
      frame = keys[0].frame;
    } else if (frame > keys[keys.length - 1].frame) {
      frame = keys[keys.length - 1].frame;
    }
    const events = this._events;
    if (events.length) {
      for (let index = 0; index < events.length; index++) {
        if (!events[index].onlyOnce) {
          events[index].isDone = events[index].frame < frame;
        }
      }
    }
    this._currentFrame = frame;
    const currentValue = this._animation._interpolate(frame, this._animationState);
    this.setValue(currentValue, -1);
  }
  _prepareForSpeedRatioChange(newSpeedRatio) {
    const newRatio = this._previousDelay * (this._animation.framePerSecond * newSpeedRatio) / 1e3;
    this._ratioOffset = this._previousRatio - newRatio;
  }
  animate(delay, from, to, loop, speedRatio, weight = -1) {
    const animation = this._animation;
    const targetPropertyPath = animation.targetPropertyPath;
    if (!targetPropertyPath || targetPropertyPath.length < 1) {
      this._stopped = true;
      return false;
    }
    let returnValue = true;
    if (from < this._minFrame || from > this._maxFrame) {
      from = this._minFrame;
    }
    if (to < this._minFrame || to > this._maxFrame) {
      to = this._maxFrame;
    }
    const range = to - from;
    let offsetValue;
    const ratio = delay * (animation.framePerSecond * speedRatio) / 1e3 + this._ratioOffset;
    let highLimitValue = 0;
    this._previousDelay = delay;
    this._previousRatio = ratio;
    if (!loop && to >= from && ratio >= range) {
      returnValue = false;
      highLimitValue = animation._getKeyValue(this._maxValue);
    } else if (!loop && from >= to && ratio <= range) {
      returnValue = false;
      highLimitValue = animation._getKeyValue(this._minValue);
    } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {
      const keyOffset = to.toString() + from.toString();
      if (!this._offsetsCache[keyOffset]) {
        this._animationState.repeatCount = 0;
        this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;
        const fromValue = animation._interpolate(from, this._animationState);
        const toValue = animation._interpolate(to, this._animationState);
        this._animationState.loopMode = this._getCorrectLoopMode();
        switch (animation.dataType) {
          case Animation.ANIMATIONTYPE_FLOAT:
            this._offsetsCache[keyOffset] = toValue - fromValue;
            break;
          case Animation.ANIMATIONTYPE_QUATERNION:
            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);
            break;
          case Animation.ANIMATIONTYPE_VECTOR3:
            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);
            break;
          case Animation.ANIMATIONTYPE_VECTOR2:
            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);
            break;
          case Animation.ANIMATIONTYPE_SIZE:
            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);
            break;
          case Animation.ANIMATIONTYPE_COLOR3:
            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);
            break;
          default:
            break;
        }
        this._highLimitsCache[keyOffset] = toValue;
      }
      highLimitValue = this._highLimitsCache[keyOffset];
      offsetValue = this._offsetsCache[keyOffset];
    }
    if (offsetValue === void 0) {
      switch (animation.dataType) {
        case Animation.ANIMATIONTYPE_FLOAT:
          offsetValue = 0;
          break;
        case Animation.ANIMATIONTYPE_QUATERNION:
          offsetValue = _staticOffsetValueQuaternion;
          break;
        case Animation.ANIMATIONTYPE_VECTOR3:
          offsetValue = _staticOffsetValueVector3;
          break;
        case Animation.ANIMATIONTYPE_VECTOR2:
          offsetValue = _staticOffsetValueVector2;
          break;
        case Animation.ANIMATIONTYPE_SIZE:
          offsetValue = _staticOffsetValueSize;
          break;
        case Animation.ANIMATIONTYPE_COLOR3:
          offsetValue = _staticOffsetValueColor3;
      }
    }
    let currentFrame;
    if (this._host && this._host.syncRoot) {
      const syncRoot = this._host.syncRoot;
      const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);
      currentFrame = from + (to - from) * hostNormalizedFrame;
    } else {
      if (ratio > 0 && from > to || ratio < 0 && from < to) {
        currentFrame = returnValue && range !== 0 ? to + ratio % range : from;
      } else {
        currentFrame = returnValue && range !== 0 ? from + ratio % range : to;
      }
    }
    const events = this._events;
    if (speedRatio > 0 && this.currentFrame > currentFrame || speedRatio < 0 && this.currentFrame < currentFrame) {
      this._onLoop();
      for (let index = 0; index < events.length; index++) {
        if (!events[index].onlyOnce) {
          events[index].isDone = false;
        }
      }
      this._animationState.key = speedRatio > 0 ? 0 : animation.getKeys().length - 1;
    }
    this._currentFrame = currentFrame;
    this._animationState.repeatCount = range === 0 ? 0 : ratio / range >> 0;
    this._animationState.highLimitValue = highLimitValue;
    this._animationState.offsetValue = offsetValue;
    const currentValue = animation._interpolate(currentFrame, this._animationState);
    this.setValue(currentValue, weight);
    if (events.length) {
      for (let index = 0; index < events.length; index++) {
        if (range > 0 && currentFrame >= events[index].frame && events[index].frame >= from || range < 0 && currentFrame <= events[index].frame && events[index].frame <= from) {
          const event = events[index];
          if (!event.isDone) {
            if (event.onlyOnce) {
              events.splice(index, 1);
              index--;
            }
            event.isDone = true;
            event.action(currentFrame);
          }
        }
      }
    }
    if (!returnValue) {
      this._stopped = true;
    }
    return returnValue;
  }
};

// node_modules/@babylonjs/core/Animations/animatable.js
var Animatable = class {
  constructor(scene, target, fromFrame = 0, toFrame = 100, loopAnimation = false, speedRatio = 1, onAnimationEnd, animations, onAnimationLoop, isAdditive = false) {
    this.target = target;
    this.fromFrame = fromFrame;
    this.toFrame = toFrame;
    this.loopAnimation = loopAnimation;
    this.onAnimationEnd = onAnimationEnd;
    this.onAnimationLoop = onAnimationLoop;
    this.isAdditive = isAdditive;
    this._localDelayOffset = null;
    this._pausedDelay = null;
    this._manualJumpDelay = null;
    this._runtimeAnimations = new Array();
    this._paused = false;
    this._speedRatio = 1;
    this._weight = -1;
    this._syncRoot = null;
    this._frameToSyncFromJump = null;
    this._goToFrame = null;
    this.disposeOnEnd = true;
    this.animationStarted = false;
    this.onAnimationEndObservable = new Observable();
    this.onAnimationLoopObservable = new Observable();
    this._scene = scene;
    if (animations) {
      this.appendAnimations(target, animations);
    }
    this._speedRatio = speedRatio;
    scene._activeAnimatables.push(this);
  }
  get syncRoot() {
    return this._syncRoot;
  }
  get masterFrame() {
    if (this._runtimeAnimations.length === 0) {
      return 0;
    }
    return this._runtimeAnimations[0].currentFrame;
  }
  get weight() {
    return this._weight;
  }
  set weight(value) {
    if (value === -1) {
      this._weight = -1;
      return;
    }
    this._weight = Math.min(Math.max(value, 0), 1);
  }
  get speedRatio() {
    return this._speedRatio;
  }
  set speedRatio(value) {
    for (let index = 0; index < this._runtimeAnimations.length; index++) {
      const animation = this._runtimeAnimations[index];
      animation._prepareForSpeedRatioChange(value);
    }
    this._speedRatio = value;
    if (this._goToFrame !== null) {
      this.goToFrame(this._goToFrame);
    }
  }
  syncWith(root) {
    this._syncRoot = root;
    if (root) {
      const index = this._scene._activeAnimatables.indexOf(this);
      if (index > -1) {
        this._scene._activeAnimatables.splice(index, 1);
        this._scene._activeAnimatables.push(this);
      }
    }
    return this;
  }
  getAnimations() {
    return this._runtimeAnimations;
  }
  appendAnimations(target, animations) {
    for (let index = 0; index < animations.length; index++) {
      const animation = animations[index];
      const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);
      newRuntimeAnimation._onLoop = () => {
        this.onAnimationLoopObservable.notifyObservers(this);
        if (this.onAnimationLoop) {
          this.onAnimationLoop();
        }
      };
      this._runtimeAnimations.push(newRuntimeAnimation);
    }
  }
  getAnimationByTargetProperty(property) {
    const runtimeAnimations = this._runtimeAnimations;
    for (let index = 0; index < runtimeAnimations.length; index++) {
      if (runtimeAnimations[index].animation.targetProperty === property) {
        return runtimeAnimations[index].animation;
      }
    }
    return null;
  }
  getRuntimeAnimationByTargetProperty(property) {
    const runtimeAnimations = this._runtimeAnimations;
    for (let index = 0; index < runtimeAnimations.length; index++) {
      if (runtimeAnimations[index].animation.targetProperty === property) {
        return runtimeAnimations[index];
      }
    }
    return null;
  }
  reset() {
    const runtimeAnimations = this._runtimeAnimations;
    for (let index = 0; index < runtimeAnimations.length; index++) {
      runtimeAnimations[index].reset(true);
    }
    this._localDelayOffset = null;
    this._pausedDelay = null;
  }
  enableBlending(blendingSpeed) {
    const runtimeAnimations = this._runtimeAnimations;
    for (let index = 0; index < runtimeAnimations.length; index++) {
      runtimeAnimations[index].animation.enableBlending = true;
      runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;
    }
  }
  disableBlending() {
    const runtimeAnimations = this._runtimeAnimations;
    for (let index = 0; index < runtimeAnimations.length; index++) {
      runtimeAnimations[index].animation.enableBlending = false;
    }
  }
  goToFrame(frame) {
    var _a;
    const runtimeAnimations = this._runtimeAnimations;
    if (runtimeAnimations[0]) {
      const fps = runtimeAnimations[0].animation.framePerSecond;
      this._frameToSyncFromJump = (_a = this._frameToSyncFromJump) !== null && _a !== void 0 ? _a : runtimeAnimations[0].currentFrame;
      const delay = this.speedRatio === 0 ? 0 : (frame - this._frameToSyncFromJump) / fps * 1e3 / this.speedRatio;
      this._manualJumpDelay = -delay;
    }
    for (let index = 0; index < runtimeAnimations.length; index++) {
      runtimeAnimations[index].goToFrame(frame);
    }
    this._goToFrame = frame;
  }
  pause() {
    if (this._paused) {
      return;
    }
    this._paused = true;
  }
  restart() {
    this._paused = false;
  }
  _raiseOnAnimationEnd() {
    if (this.onAnimationEnd) {
      this.onAnimationEnd();
    }
    this.onAnimationEndObservable.notifyObservers(this);
  }
  stop(animationName, targetMask) {
    if (animationName || targetMask) {
      const idx = this._scene._activeAnimatables.indexOf(this);
      if (idx > -1) {
        const runtimeAnimations = this._runtimeAnimations;
        for (let index = runtimeAnimations.length - 1; index >= 0; index--) {
          const runtimeAnimation = runtimeAnimations[index];
          if (animationName && runtimeAnimation.animation.name != animationName) {
            continue;
          }
          if (targetMask && !targetMask(runtimeAnimation.target)) {
            continue;
          }
          runtimeAnimation.dispose();
          runtimeAnimations.splice(index, 1);
        }
        if (runtimeAnimations.length == 0) {
          this._scene._activeAnimatables.splice(idx, 1);
          this._raiseOnAnimationEnd();
        }
      }
    } else {
      const index = this._scene._activeAnimatables.indexOf(this);
      if (index > -1) {
        this._scene._activeAnimatables.splice(index, 1);
        const runtimeAnimations = this._runtimeAnimations;
        for (let index2 = 0; index2 < runtimeAnimations.length; index2++) {
          runtimeAnimations[index2].dispose();
        }
        this._raiseOnAnimationEnd();
      }
    }
  }
  waitAsync() {
    return new Promise((resolve) => {
      this.onAnimationEndObservable.add(() => {
        resolve(this);
      }, void 0, void 0, this, true);
    });
  }
  _animate(delay) {
    if (this._paused) {
      this.animationStarted = false;
      if (this._pausedDelay === null) {
        this._pausedDelay = delay;
      }
      return true;
    }
    if (this._localDelayOffset === null) {
      this._localDelayOffset = delay;
      this._pausedDelay = null;
    } else if (this._pausedDelay !== null) {
      this._localDelayOffset += delay - this._pausedDelay;
      this._pausedDelay = null;
    }
    if (this._manualJumpDelay !== null) {
      this._localDelayOffset += this._manualJumpDelay;
      this._manualJumpDelay = null;
      this._frameToSyncFromJump = null;
    }
    this._goToFrame = null;
    if (this._weight === 0) {
      return true;
    }
    let running = false;
    const runtimeAnimations = this._runtimeAnimations;
    let index;
    for (index = 0; index < runtimeAnimations.length; index++) {
      const animation = runtimeAnimations[index];
      const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);
      running = running || isRunning;
    }
    this.animationStarted = running;
    if (!running) {
      if (this.disposeOnEnd) {
        index = this._scene._activeAnimatables.indexOf(this);
        this._scene._activeAnimatables.splice(index, 1);
        for (index = 0; index < runtimeAnimations.length; index++) {
          runtimeAnimations[index].dispose();
        }
      }
      this._raiseOnAnimationEnd();
      if (this.disposeOnEnd) {
        this.onAnimationEnd = null;
        this.onAnimationLoop = null;
        this.onAnimationLoopObservable.clear();
        this.onAnimationEndObservable.clear();
      }
    }
    return running;
  }
};
Scene.prototype._animate = function() {
  if (!this.animationsEnabled) {
    return;
  }
  const now = PrecisionDate.Now;
  if (!this._animationTimeLast) {
    if (this._pendingData.length > 0) {
      return;
    }
    this._animationTimeLast = now;
  }
  this.deltaTime = this.useConstantAnimationDeltaTime ? 16 : (now - this._animationTimeLast) * this.animationTimeScale;
  this._animationTimeLast = now;
  const animatables = this._activeAnimatables;
  if (animatables.length === 0) {
    return;
  }
  this._animationTime += this.deltaTime;
  const animationTime = this._animationTime;
  for (let index = 0; index < animatables.length; index++) {
    const animatable = animatables[index];
    if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {
      index--;
    }
  }
  this._processLateAnimationBindings();
};
Scene.prototype.beginWeightedAnimation = function(target, from, to, weight = 1, loop, speedRatio = 1, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive = false) {
  const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);
  returnedAnimatable.weight = weight;
  return returnedAnimatable;
};
Scene.prototype.beginAnimation = function(target, from, to, loop, speedRatio = 1, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {
  if (from > to && speedRatio > 0) {
    speedRatio *= -1;
  }
  if (stopCurrent) {
    this.stopAnimation(target, void 0, targetMask);
  }
  if (!animatable) {
    animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, void 0, onAnimationLoop, isAdditive);
  }
  const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;
  if (target.animations && shouldRunTargetAnimations) {
    animatable.appendAnimations(target, target.animations);
  }
  if (target.getAnimatables) {
    const animatables = target.getAnimatables();
    for (let index = 0; index < animatables.length; index++) {
      this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);
    }
  }
  animatable.reset();
  return animatable;
};
Scene.prototype.beginHierarchyAnimation = function(target, directDescendantsOnly, from, to, loop, speedRatio = 1, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {
  const children = target.getDescendants(directDescendantsOnly);
  const result = [];
  result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, void 0, isAdditive));
  for (const child of children) {
    result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, void 0, isAdditive));
  }
  return result;
};
Scene.prototype.beginDirectAnimation = function(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive = false) {
  if (speedRatio === void 0) {
    speedRatio = 1;
  }
  if (from > to && speedRatio > 0) {
    speedRatio *= -1;
  } else if (to > from && speedRatio < 0) {
    const temp = to;
    to = from;
    from = temp;
  }
  const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);
  return animatable;
};
Scene.prototype.beginDirectHierarchyAnimation = function(target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive = false) {
  const children = target.getDescendants(directDescendantsOnly);
  const result = [];
  result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));
  for (const child of children) {
    result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));
  }
  return result;
};
Scene.prototype.getAnimatableByTarget = function(target) {
  for (let index = 0; index < this._activeAnimatables.length; index++) {
    if (this._activeAnimatables[index].target === target) {
      return this._activeAnimatables[index];
    }
  }
  return null;
};
Scene.prototype.getAllAnimatablesByTarget = function(target) {
  const result = [];
  for (let index = 0; index < this._activeAnimatables.length; index++) {
    if (this._activeAnimatables[index].target === target) {
      result.push(this._activeAnimatables[index]);
    }
  }
  return result;
};
Scene.prototype.stopAnimation = function(target, animationName, targetMask) {
  const animatables = this.getAllAnimatablesByTarget(target);
  for (const animatable of animatables) {
    animatable.stop(animationName, targetMask);
  }
};
Scene.prototype.stopAllAnimations = function() {
  if (this._activeAnimatables) {
    for (let i = 0; i < this._activeAnimatables.length; i++) {
      this._activeAnimatables[i].stop();
    }
    this._activeAnimatables.length = 0;
  }
  for (const group of this.animationGroups) {
    group.stop();
  }
};
Scene.prototype._registerTargetForLateAnimationBinding = function(runtimeAnimation, originalValue) {
  const target = runtimeAnimation.target;
  this._registeredForLateAnimationBindings.pushNoDuplicate(target);
  if (!target._lateAnimationHolders) {
    target._lateAnimationHolders = {};
  }
  if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {
    target._lateAnimationHolders[runtimeAnimation.targetPath] = {
      totalWeight: 0,
      totalAdditiveWeight: 0,
      animations: [],
      additiveAnimations: [],
      originalValue
    };
  }
  if (runtimeAnimation.isAdditive) {
    target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);
    target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;
  } else {
    target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);
    target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;
  }
};
Scene.prototype._processLateAnimationBindingsForMatrices = function(holder) {
  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {
    return holder.originalValue;
  }
  let normalizer = 1;
  const finalPosition = TmpVectors.Vector3[0];
  const finalScaling = TmpVectors.Vector3[1];
  const finalQuaternion = TmpVectors.Quaternion[0];
  let startIndex = 0;
  const originalAnimation = holder.animations[0];
  const originalValue = holder.originalValue;
  let scale = 1;
  let skipOverride = false;
  if (holder.totalWeight < 1) {
    scale = 1 - holder.totalWeight;
    originalValue.decompose(finalScaling, finalQuaternion, finalPosition);
  } else {
    startIndex = 1;
    normalizer = holder.totalWeight;
    scale = originalAnimation.weight / normalizer;
    if (scale == 1) {
      if (holder.totalAdditiveWeight) {
        skipOverride = true;
      } else {
        return originalAnimation.currentValue;
      }
    }
    originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);
  }
  if (!skipOverride) {
    finalScaling.scaleInPlace(scale);
    finalPosition.scaleInPlace(scale);
    finalQuaternion.scaleInPlace(scale);
    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {
      const runtimeAnimation = holder.animations[animIndex];
      if (runtimeAnimation.weight === 0) {
        continue;
      }
      scale = runtimeAnimation.weight / normalizer;
      const currentPosition = TmpVectors.Vector3[2];
      const currentScaling = TmpVectors.Vector3[3];
      const currentQuaternion = TmpVectors.Quaternion[1];
      runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);
      currentScaling.scaleAndAddToRef(scale, finalScaling);
      currentQuaternion.scaleAndAddToRef(Quaternion.Dot(finalQuaternion, currentQuaternion) > 0 ? scale : -scale, finalQuaternion);
      currentPosition.scaleAndAddToRef(scale, finalPosition);
    }
    finalQuaternion.normalize();
  }
  for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {
    const runtimeAnimation = holder.additiveAnimations[animIndex];
    if (runtimeAnimation.weight === 0) {
      continue;
    }
    const currentPosition = TmpVectors.Vector3[2];
    const currentScaling = TmpVectors.Vector3[3];
    const currentQuaternion = TmpVectors.Quaternion[1];
    runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);
    currentScaling.multiplyToRef(finalScaling, currentScaling);
    Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);
    finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);
    Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);
    currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);
  }
  const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();
  Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);
  return workValue;
};
Scene.prototype._processLateAnimationBindingsForQuaternions = function(holder, refQuaternion) {
  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {
    return refQuaternion;
  }
  const originalAnimation = holder.animations[0];
  const originalValue = holder.originalValue;
  let cumulativeQuaternion = refQuaternion;
  if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {
    cumulativeQuaternion.copyFrom(originalValue);
  } else if (holder.animations.length === 1) {
    Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1, holder.totalWeight), cumulativeQuaternion);
    if (holder.totalAdditiveWeight === 0) {
      return cumulativeQuaternion;
    }
  } else if (holder.animations.length > 1) {
    let normalizer = 1;
    let quaternions;
    let weights;
    if (holder.totalWeight < 1) {
      const scale = 1 - holder.totalWeight;
      quaternions = [];
      weights = [];
      quaternions.push(originalValue);
      weights.push(scale);
    } else {
      if (holder.animations.length === 2) {
        Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);
        if (holder.totalAdditiveWeight === 0) {
          return refQuaternion;
        }
      }
      quaternions = [];
      weights = [];
      normalizer = holder.totalWeight;
    }
    for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {
      const runtimeAnimation = holder.animations[animIndex];
      quaternions.push(runtimeAnimation.currentValue);
      weights.push(runtimeAnimation.weight / normalizer);
    }
    let cumulativeAmount = 0;
    for (let index = 0; index < quaternions.length; ) {
      if (!index) {
        Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);
        cumulativeQuaternion = refQuaternion;
        cumulativeAmount = weights[index] + weights[index + 1];
        index += 2;
        continue;
      }
      cumulativeAmount += weights[index];
      Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);
      index++;
    }
  }
  for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {
    const runtimeAnimation = holder.additiveAnimations[animIndex];
    if (runtimeAnimation.weight === 0) {
      continue;
    }
    cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);
    Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);
  }
  return cumulativeQuaternion;
};
Scene.prototype._processLateAnimationBindings = function() {
  if (!this._registeredForLateAnimationBindings.length) {
    return;
  }
  for (let index = 0; index < this._registeredForLateAnimationBindings.length; index++) {
    const target = this._registeredForLateAnimationBindings.data[index];
    for (const path in target._lateAnimationHolders) {
      const holder = target._lateAnimationHolders[path];
      const originalAnimation = holder.animations[0];
      const originalValue = holder.originalValue;
      if (originalValue === void 0 || originalValue === null) {
        continue;
      }
      const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m;
      let finalValue = target[path];
      if (matrixDecomposeMode) {
        finalValue = this._processLateAnimationBindingsForMatrices(holder);
      } else {
        const quaternionMode = originalValue.w !== void 0;
        if (quaternionMode) {
          finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());
        } else {
          let startIndex = 0;
          let normalizer = 1;
          if (holder.totalWeight < 1) {
            if (originalAnimation && originalValue.scale) {
              finalValue = originalValue.scale(1 - holder.totalWeight);
            } else if (originalAnimation) {
              finalValue = originalValue * (1 - holder.totalWeight);
            } else if (originalValue.clone) {
              finalValue = originalValue.clone();
            } else {
              finalValue = originalValue;
            }
          } else if (originalAnimation) {
            normalizer = holder.totalWeight;
            const scale = originalAnimation.weight / normalizer;
            if (scale !== 1) {
              if (originalAnimation.currentValue.scale) {
                finalValue = originalAnimation.currentValue.scale(scale);
              } else {
                finalValue = originalAnimation.currentValue * scale;
              }
            } else {
              finalValue = originalAnimation.currentValue;
            }
            startIndex = 1;
          }
          for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {
            const runtimeAnimation = holder.animations[animIndex];
            const scale = runtimeAnimation.weight / normalizer;
            if (!scale) {
              continue;
            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {
              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);
            } else {
              finalValue += runtimeAnimation.currentValue * scale;
            }
          }
          for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {
            const runtimeAnimation = holder.additiveAnimations[animIndex];
            const scale = runtimeAnimation.weight;
            if (!scale) {
              continue;
            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {
              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);
            } else {
              finalValue += runtimeAnimation.currentValue * scale;
            }
          }
        }
      }
      target[path] = finalValue;
    }
    target._lateAnimationHolders = {};
  }
  this._registeredForLateAnimationBindings.reset();
};
Bone.prototype.copyAnimationRange = function(source, rangeName, frameOffset, rescaleAsRequired = false, skelDimensionsRatio = null) {
  if (this.animations.length === 0) {
    this.animations.push(new Animation(this.name, "_matrix", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));
    this.animations[0].setKeys([]);
  }
  const sourceRange = source.animations[0].getRange(rangeName);
  if (!sourceRange) {
    return false;
  }
  const from = sourceRange.from;
  const to = sourceRange.to;
  const sourceKeys = source.animations[0].getKeys();
  const sourceBoneLength = source.length;
  const sourceParent = source.getParent();
  const parent = this.getParent();
  const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;
  const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;
  const dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);
  const destKeys = this.animations[0].getKeys();
  let orig;
  let origTranslation;
  let mat;
  for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {
    orig = sourceKeys[key];
    if (orig.frame >= from && orig.frame <= to) {
      if (rescaleAsRequired) {
        mat = orig.value.clone();
        if (parentScalingReqd) {
          origTranslation = mat.getTranslation();
          mat.setTranslation(origTranslation.scaleInPlace(parentRatio));
        } else if (dimensionsScalingReqd && skelDimensionsRatio) {
          origTranslation = mat.getTranslation();
          mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));
        } else {
          mat = orig.value;
        }
      } else {
        mat = orig.value;
      }
      destKeys.push({ frame: orig.frame + frameOffset, value: mat });
    }
  }
  this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);
  return true;
};

// node_modules/@babylonjs/core/Animations/animationPropertiesOverride.js
var AnimationPropertiesOverride = class {
  constructor() {
    this.enableBlending = false;
    this.blendingSpeed = 0.01;
    this.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;
  }
};

// node_modules/@babylonjs/core/Animations/easing.js
var EasingFunction = class {
  constructor() {
    this._easingMode = EasingFunction.EASINGMODE_EASEIN;
  }
  setEasingMode(easingMode) {
    const n = Math.min(Math.max(easingMode, 0), 2);
    this._easingMode = n;
  }
  getEasingMode() {
    return this._easingMode;
  }
  easeInCore(gradient) {
    throw new Error("You must implement this method");
  }
  ease(gradient) {
    switch (this._easingMode) {
      case EasingFunction.EASINGMODE_EASEIN:
        return this.easeInCore(gradient);
      case EasingFunction.EASINGMODE_EASEOUT:
        return 1 - this.easeInCore(1 - gradient);
    }
    if (gradient >= 0.5) {
      return (1 - this.easeInCore((1 - gradient) * 2)) * 0.5 + 0.5;
    }
    return this.easeInCore(gradient * 2) * 0.5;
  }
};
EasingFunction.EASINGMODE_EASEIN = 0;
EasingFunction.EASINGMODE_EASEOUT = 1;
EasingFunction.EASINGMODE_EASEINOUT = 2;
var CircleEase = class extends EasingFunction {
  easeInCore(gradient) {
    gradient = Math.max(0, Math.min(1, gradient));
    return 1 - Math.sqrt(1 - gradient * gradient);
  }
};
var BackEase = class extends EasingFunction {
  constructor(amplitude = 1) {
    super();
    this.amplitude = amplitude;
  }
  easeInCore(gradient) {
    const num = Math.max(0, this.amplitude);
    return Math.pow(gradient, 3) - gradient * num * Math.sin(3.141592653589793 * gradient);
  }
};
var BounceEase = class extends EasingFunction {
  constructor(bounces = 3, bounciness = 2) {
    super();
    this.bounces = bounces;
    this.bounciness = bounciness;
  }
  easeInCore(gradient) {
    const y = Math.max(0, this.bounces);
    let bounciness = this.bounciness;
    if (bounciness <= 1) {
      bounciness = 1.001;
    }
    const num9 = Math.pow(bounciness, y);
    const num5 = 1 - bounciness;
    const num4 = (1 - num9) / num5 + num9 * 0.5;
    const num15 = gradient * num4;
    const num65 = Math.log(-num15 * (1 - bounciness) + 1) / Math.log(bounciness);
    const num3 = Math.floor(num65);
    const num13 = num3 + 1;
    const num8 = (1 - Math.pow(bounciness, num3)) / (num5 * num4);
    const num12 = (1 - Math.pow(bounciness, num13)) / (num5 * num4);
    const num7 = (num8 + num12) * 0.5;
    const num6 = gradient - num7;
    const num2 = num7 - num8;
    return -Math.pow(1 / bounciness, y - num3) / (num2 * num2) * (num6 - num2) * (num6 + num2);
  }
};
var CubicEase = class extends EasingFunction {
  easeInCore(gradient) {
    return gradient * gradient * gradient;
  }
};
var ElasticEase = class extends EasingFunction {
  constructor(oscillations = 3, springiness = 3) {
    super();
    this.oscillations = oscillations;
    this.springiness = springiness;
  }
  easeInCore(gradient) {
    let num2;
    const num3 = Math.max(0, this.oscillations);
    const num = Math.max(0, this.springiness);
    if (num == 0) {
      num2 = gradient;
    } else {
      num2 = (Math.exp(num * gradient) - 1) / (Math.exp(num) - 1);
    }
    return num2 * Math.sin((6.283185307179586 * num3 + 1.5707963267948966) * gradient);
  }
};
var ExponentialEase = class extends EasingFunction {
  constructor(exponent = 2) {
    super();
    this.exponent = exponent;
  }
  easeInCore(gradient) {
    if (this.exponent <= 0) {
      return gradient;
    }
    return (Math.exp(this.exponent * gradient) - 1) / (Math.exp(this.exponent) - 1);
  }
};
var PowerEase = class extends EasingFunction {
  constructor(power = 2) {
    super();
    this.power = power;
  }
  easeInCore(gradient) {
    const y = Math.max(0, this.power);
    return Math.pow(gradient, y);
  }
};
var QuadraticEase = class extends EasingFunction {
  easeInCore(gradient) {
    return gradient * gradient;
  }
};
var QuarticEase = class extends EasingFunction {
  easeInCore(gradient) {
    return gradient * gradient * gradient * gradient;
  }
};
var QuinticEase = class extends EasingFunction {
  easeInCore(gradient) {
    return gradient * gradient * gradient * gradient * gradient;
  }
};
var SineEase = class extends EasingFunction {
  easeInCore(gradient) {
    return 1 - Math.sin(1.5707963267948966 * (1 - gradient));
  }
};
var BezierCurveEase = class extends EasingFunction {
  constructor(x1 = 0, y1 = 0, x2 = 1, y2 = 1) {
    super();
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }
  easeInCore(gradient) {
    return BezierCurve.Interpolate(gradient, this.x1, this.y1, this.x2, this.y2);
  }
};

// node_modules/@babylonjs/core/Animations/pathCursor.js
var PathCursor = class {
  constructor(_path) {
    this._path = _path;
    this._onchange = new Array();
    this.value = 0;
    this.animations = new Array();
  }
  getPoint() {
    const point = this._path.getPointAtLengthPosition(this.value);
    return new Vector3(point.x, 0, point.y);
  }
  moveAhead(step = 2e-3) {
    this.move(step);
    return this;
  }
  moveBack(step = 2e-3) {
    this.move(-step);
    return this;
  }
  move(step) {
    if (Math.abs(step) > 1) {
      throw "step size should be less than 1.";
    }
    this.value += step;
    this._ensureLimits();
    this._raiseOnChange();
    return this;
  }
  _ensureLimits() {
    while (this.value > 1) {
      this.value -= 1;
    }
    while (this.value < 0) {
      this.value += 1;
    }
    return this;
  }
  _raiseOnChange() {
    this._onchange.forEach((f) => f(this));
    return this;
  }
  onchange(f) {
    this._onchange.push(f);
    return this;
  }
};

// node_modules/@babylonjs/core/Audio/analyser.js
var Analyser = class {
  constructor(scene) {
    this.SMOOTHING = 0.75;
    this.FFT_SIZE = 512;
    this.BARGRAPHAMPLITUDE = 256;
    this.DEBUGCANVASPOS = { x: 20, y: 20 };
    this.DEBUGCANVASSIZE = { width: 320, height: 200 };
    scene = scene || EngineStore.LastCreatedScene;
    if (!scene) {
      return;
    }
    this._scene = scene;
    if (!Engine.audioEngine) {
      Tools.Warn("No audio engine initialized, failed to create an audio analyser");
      return;
    }
    this._audioEngine = Engine.audioEngine;
    if (this._audioEngine.canUseWebAudio && this._audioEngine.audioContext) {
      this._webAudioAnalyser = this._audioEngine.audioContext.createAnalyser();
      this._webAudioAnalyser.minDecibels = -140;
      this._webAudioAnalyser.maxDecibels = 0;
      this._byteFreqs = new Uint8Array(this._webAudioAnalyser.frequencyBinCount);
      this._byteTime = new Uint8Array(this._webAudioAnalyser.frequencyBinCount);
      this._floatFreqs = new Float32Array(this._webAudioAnalyser.frequencyBinCount);
    }
  }
  getFrequencyBinCount() {
    if (this._audioEngine.canUseWebAudio) {
      return this._webAudioAnalyser.frequencyBinCount;
    } else {
      return 0;
    }
  }
  getByteFrequencyData() {
    if (this._audioEngine.canUseWebAudio) {
      this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING;
      this._webAudioAnalyser.fftSize = this.FFT_SIZE;
      this._webAudioAnalyser.getByteFrequencyData(this._byteFreqs);
    }
    return this._byteFreqs;
  }
  getByteTimeDomainData() {
    if (this._audioEngine.canUseWebAudio) {
      this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING;
      this._webAudioAnalyser.fftSize = this.FFT_SIZE;
      this._webAudioAnalyser.getByteTimeDomainData(this._byteTime);
    }
    return this._byteTime;
  }
  getFloatFrequencyData() {
    if (this._audioEngine.canUseWebAudio) {
      this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING;
      this._webAudioAnalyser.fftSize = this.FFT_SIZE;
      this._webAudioAnalyser.getFloatFrequencyData(this._floatFreqs);
    }
    return this._floatFreqs;
  }
  drawDebugCanvas() {
    if (this._audioEngine.canUseWebAudio) {
      if (!this._debugCanvas) {
        this._debugCanvas = document.createElement("canvas");
        this._debugCanvas.width = this.DEBUGCANVASSIZE.width;
        this._debugCanvas.height = this.DEBUGCANVASSIZE.height;
        this._debugCanvas.style.position = "absolute";
        this._debugCanvas.style.top = this.DEBUGCANVASPOS.y + "px";
        this._debugCanvas.style.left = this.DEBUGCANVASPOS.x + "px";
        this._debugCanvasContext = this._debugCanvas.getContext("2d");
        document.body.appendChild(this._debugCanvas);
        this._registerFunc = () => {
          this.drawDebugCanvas();
        };
        this._scene.registerBeforeRender(this._registerFunc);
      }
      if (this._registerFunc && this._debugCanvasContext) {
        const workingArray = this.getByteFrequencyData();
        this._debugCanvasContext.fillStyle = "rgb(0, 0, 0)";
        this._debugCanvasContext.fillRect(0, 0, this.DEBUGCANVASSIZE.width, this.DEBUGCANVASSIZE.height);
        for (let i = 0; i < this.getFrequencyBinCount(); i++) {
          const value = workingArray[i];
          const percent = value / this.BARGRAPHAMPLITUDE;
          const height = this.DEBUGCANVASSIZE.height * percent;
          const offset = this.DEBUGCANVASSIZE.height - height - 1;
          const barWidth = this.DEBUGCANVASSIZE.width / this.getFrequencyBinCount();
          const hue = i / this.getFrequencyBinCount() * 360;
          this._debugCanvasContext.fillStyle = "hsl(" + hue + ", 100%, 50%)";
          this._debugCanvasContext.fillRect(i * barWidth, offset, barWidth, height);
        }
      }
    }
  }
  stopDebugCanvas() {
    if (this._debugCanvas) {
      if (this._registerFunc) {
        this._scene.unregisterBeforeRender(this._registerFunc);
        this._registerFunc = null;
      }
      document.body.removeChild(this._debugCanvas);
      this._debugCanvas = null;
      this._debugCanvasContext = null;
    }
  }
  connectAudioNodes(inputAudioNode, outputAudioNode) {
    if (this._audioEngine.canUseWebAudio) {
      inputAudioNode.connect(this._webAudioAnalyser);
      this._webAudioAnalyser.connect(outputAudioNode);
    }
  }
  dispose() {
    if (this._audioEngine.canUseWebAudio) {
      this._webAudioAnalyser.disconnect();
    }
  }
};

// node_modules/@babylonjs/core/Audio/audioEngine.js
Engine.AudioEngineFactory = (hostElement, audioContext, audioDestination) => {
  return new AudioEngine(hostElement, audioContext, audioDestination);
};
var AudioEngine = class {
  constructor(hostElement = null, audioContext = null, audioDestination = null) {
    this._audioContext = null;
    this._audioContextInitialized = false;
    this._muteButton = null;
    this._audioDestination = null;
    this.canUseWebAudio = false;
    this.WarnedWebAudioUnsupported = false;
    this.isMP3supported = false;
    this.isOGGsupported = false;
    this.unlocked = true;
    this.useCustomUnlockedButton = false;
    this.onAudioUnlockedObservable = new Observable();
    this.onAudioLockedObservable = new Observable();
    this._tryToRun = false;
    this._onResize = () => {
      this._moveButtonToTopLeft();
    };
    if (!IsWindowObjectExist()) {
      return;
    }
    if (typeof window.AudioContext !== "undefined") {
      this.canUseWebAudio = true;
    }
    const audioElem = document.createElement("audio");
    this._hostElement = hostElement;
    this._audioContext = audioContext;
    this._audioDestination = audioDestination;
    try {
      if (audioElem && !!audioElem.canPlayType && (audioElem.canPlayType('audio/mpeg; codecs="mp3"').replace(/^no$/, "") || audioElem.canPlayType("audio/mp3").replace(/^no$/, ""))) {
        this.isMP3supported = true;
      }
    } catch (e) {
    }
    try {
      if (audioElem && !!audioElem.canPlayType && audioElem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "")) {
        this.isOGGsupported = true;
      }
    } catch (e) {
    }
  }
  get audioContext() {
    if (!this._audioContextInitialized) {
      this._initializeAudioContext();
    } else {
      if (!this.unlocked && !this._muteButton) {
        this._displayMuteButton();
      }
    }
    return this._audioContext;
  }
  lock() {
    this._triggerSuspendedState();
  }
  unlock() {
    this._triggerRunningState();
  }
  _resumeAudioContext() {
    let result;
    if (this._audioContext.resume !== void 0) {
      result = this._audioContext.resume();
    }
    return result || Promise.resolve();
  }
  _initializeAudioContext() {
    try {
      if (this.canUseWebAudio) {
        if (!this._audioContext) {
          this._audioContext = new AudioContext();
        }
        this.masterGain = this._audioContext.createGain();
        this.masterGain.gain.value = 1;
        if (!this._audioDestination) {
          this._audioDestination = this._audioContext.destination;
        }
        this.masterGain.connect(this._audioDestination);
        this._audioContextInitialized = true;
        if (this._audioContext.state === "running") {
          this._triggerRunningState();
        }
      }
    } catch (e) {
      this.canUseWebAudio = false;
      Logger.Error("Web Audio: " + e.message);
    }
  }
  _triggerRunningState() {
    if (this._tryToRun) {
      return;
    }
    this._tryToRun = true;
    this._resumeAudioContext().then(() => {
      this._tryToRun = false;
      if (this._muteButton) {
        this._hideMuteButton();
      }
      this.unlocked = true;
      this.onAudioUnlockedObservable.notifyObservers(this);
    }).catch(() => {
      this._tryToRun = false;
      this.unlocked = false;
    });
  }
  _triggerSuspendedState() {
    this.unlocked = false;
    this.onAudioLockedObservable.notifyObservers(this);
    this._displayMuteButton();
  }
  _displayMuteButton() {
    if (this.useCustomUnlockedButton || this._muteButton) {
      return;
    }
    this._muteButton = document.createElement("BUTTON");
    this._muteButton.className = "babylonUnmuteIcon";
    this._muteButton.id = "babylonUnmuteIconBtn";
    this._muteButton.title = "Unmute";
    const imageUrl = !window.SVGSVGElement ? "https://cdn.babylonjs.com/Assets/audio.png" : "data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E";
    const css = ".babylonUnmuteIcon { position: absolute; left: 20px; top: 20px; height: 40px; width: 60px; background-color: rgba(51,51,51,0.7); background-image: url(" + imageUrl + ");  background-size: 80%; background-repeat:no-repeat; background-position: center; background-position-y: 4px; border: none; outline: none; transition: transform 0.125s ease-out; cursor: pointer; z-index: 9999; } .babylonUnmuteIcon:hover { transform: scale(1.05) } .babylonUnmuteIcon:active { background-color: rgba(51,51,51,1) }";
    const style = document.createElement("style");
    style.appendChild(document.createTextNode(css));
    document.getElementsByTagName("head")[0].appendChild(style);
    document.body.appendChild(this._muteButton);
    this._moveButtonToTopLeft();
    this._muteButton.addEventListener("touchend", () => {
      this._triggerRunningState();
    }, true);
    this._muteButton.addEventListener("click", () => {
      this._triggerRunningState();
    }, true);
    window.addEventListener("resize", this._onResize);
  }
  _moveButtonToTopLeft() {
    if (this._hostElement && this._muteButton) {
      this._muteButton.style.top = this._hostElement.offsetTop + 20 + "px";
      this._muteButton.style.left = this._hostElement.offsetLeft + 20 + "px";
    }
  }
  _hideMuteButton() {
    if (this._muteButton) {
      document.body.removeChild(this._muteButton);
      this._muteButton = null;
    }
  }
  dispose() {
    if (this.canUseWebAudio && this._audioContextInitialized) {
      if (this._connectedAnalyser && this._audioContext) {
        this._connectedAnalyser.stopDebugCanvas();
        this._connectedAnalyser.dispose();
        this.masterGain.disconnect();
        this.masterGain.connect(this._audioContext.destination);
        this._connectedAnalyser = null;
      }
      this.masterGain.gain.value = 1;
    }
    this.WarnedWebAudioUnsupported = false;
    this._hideMuteButton();
    window.removeEventListener("resize", this._onResize);
    this.onAudioUnlockedObservable.clear();
    this.onAudioLockedObservable.clear();
  }
  getGlobalVolume() {
    if (this.canUseWebAudio && this._audioContextInitialized) {
      return this.masterGain.gain.value;
    } else {
      return -1;
    }
  }
  setGlobalVolume(newVolume) {
    if (this.canUseWebAudio && this._audioContextInitialized) {
      this.masterGain.gain.value = newVolume;
    }
  }
  connectToAnalyser(analyser) {
    if (this._connectedAnalyser) {
      this._connectedAnalyser.stopDebugCanvas();
    }
    if (this.canUseWebAudio && this._audioContextInitialized && this._audioContext) {
      this._connectedAnalyser = analyser;
      this.masterGain.disconnect();
      this._connectedAnalyser.connectAudioNodes(this.masterGain, this._audioContext.destination);
    }
  }
};

// node_modules/@babylonjs/core/Audio/soundTrack.js
var SoundTrack = class {
  constructor(scene, options = {}) {
    this.id = -1;
    this._isInitialized = false;
    scene = scene || EngineStore.LastCreatedScene;
    if (!scene) {
      return;
    }
    this._scene = scene;
    this.soundCollection = new Array();
    this._options = options;
    if (!this._options.mainTrack && this._scene.soundTracks) {
      this._scene.soundTracks.push(this);
      this.id = this._scene.soundTracks.length - 1;
    }
  }
  _initializeSoundTrackAudioGraph() {
    var _a;
    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && Engine.audioEngine.audioContext) {
      this._outputAudioNode = Engine.audioEngine.audioContext.createGain();
      this._outputAudioNode.connect(Engine.audioEngine.masterGain);
      if (this._options) {
        if (this._options.volume) {
          this._outputAudioNode.gain.value = this._options.volume;
        }
      }
      this._isInitialized = true;
    }
  }
  dispose() {
    if (Engine.audioEngine && Engine.audioEngine.canUseWebAudio) {
      if (this._connectedAnalyser) {
        this._connectedAnalyser.stopDebugCanvas();
      }
      while (this.soundCollection.length) {
        this.soundCollection[0].dispose();
      }
      if (this._outputAudioNode) {
        this._outputAudioNode.disconnect();
      }
      this._outputAudioNode = null;
    }
  }
  addSound(sound) {
    var _a;
    if (!this._isInitialized) {
      this._initializeSoundTrackAudioGraph();
    }
    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._outputAudioNode) {
      sound.connectToSoundTrackAudioNode(this._outputAudioNode);
    }
    if (sound.soundTrackId) {
      if (sound.soundTrackId === -1) {
        this._scene.mainSoundTrack.removeSound(sound);
      } else if (this._scene.soundTracks) {
        this._scene.soundTracks[sound.soundTrackId].removeSound(sound);
      }
    }
    this.soundCollection.push(sound);
    sound.soundTrackId = this.id;
  }
  removeSound(sound) {
    const index = this.soundCollection.indexOf(sound);
    if (index !== -1) {
      this.soundCollection.splice(index, 1);
    }
  }
  setVolume(newVolume) {
    var _a;
    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._outputAudioNode) {
      this._outputAudioNode.gain.value = newVolume;
    }
  }
  switchPanningModelToHRTF() {
    var _a;
    if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) {
      for (let i = 0; i < this.soundCollection.length; i++) {
        this.soundCollection[i].switchPanningModelToHRTF();
      }
    }
  }
  switchPanningModelToEqualPower() {
    var _a;
    if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) {
      for (let i = 0; i < this.soundCollection.length; i++) {
        this.soundCollection[i].switchPanningModelToEqualPower();
      }
    }
  }
  connectToAnalyser(analyser) {
    var _a;
    if (this._connectedAnalyser) {
      this._connectedAnalyser.stopDebugCanvas();
    }
    this._connectedAnalyser = analyser;
    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._outputAudioNode) {
      this._outputAudioNode.disconnect();
      this._connectedAnalyser.connectAudioNodes(this._outputAudioNode, Engine.audioEngine.masterGain);
    }
  }
};

// node_modules/@babylonjs/core/Audio/audioSceneComponent.js
AbstractScene.AddParser(SceneComponentConstants.NAME_AUDIO, (parsedData, scene, container, rootUrl) => {
  var _a;
  let loadedSounds = [];
  let loadedSound;
  container.sounds = container.sounds || [];
  if (parsedData.sounds !== void 0 && parsedData.sounds !== null) {
    for (let index = 0, cache = parsedData.sounds.length; index < cache; index++) {
      const parsedSound = parsedData.sounds[index];
      if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) {
        if (!parsedSound.url) {
          parsedSound.url = parsedSound.name;
        }
        if (!loadedSounds[parsedSound.url]) {
          loadedSound = Sound.Parse(parsedSound, scene, rootUrl);
          loadedSounds[parsedSound.url] = loadedSound;
          container.sounds.push(loadedSound);
        } else {
          container.sounds.push(Sound.Parse(parsedSound, scene, rootUrl, loadedSounds[parsedSound.url]));
        }
      } else {
        container.sounds.push(new Sound(parsedSound.name, null, scene));
      }
    }
  }
  loadedSounds = [];
});
Object.defineProperty(Scene.prototype, "mainSoundTrack", {
  get: function() {
    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    if (!this._mainSoundTrack) {
      this._mainSoundTrack = new SoundTrack(this, { mainTrack: true });
    }
    return this._mainSoundTrack;
  },
  enumerable: true,
  configurable: true
});
Scene.prototype.getSoundByName = function(name137) {
  let index;
  for (index = 0; index < this.mainSoundTrack.soundCollection.length; index++) {
    if (this.mainSoundTrack.soundCollection[index].name === name137) {
      return this.mainSoundTrack.soundCollection[index];
    }
  }
  if (this.soundTracks) {
    for (let sdIndex = 0; sdIndex < this.soundTracks.length; sdIndex++) {
      for (index = 0; index < this.soundTracks[sdIndex].soundCollection.length; index++) {
        if (this.soundTracks[sdIndex].soundCollection[index].name === name137) {
          return this.soundTracks[sdIndex].soundCollection[index];
        }
      }
    }
  }
  return null;
};
Object.defineProperty(Scene.prototype, "audioEnabled", {
  get: function() {
    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    return compo.audioEnabled;
  },
  set: function(value) {
    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    if (value) {
      compo.enableAudio();
    } else {
      compo.disableAudio();
    }
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(Scene.prototype, "headphone", {
  get: function() {
    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    return compo.headphone;
  },
  set: function(value) {
    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    if (value) {
      compo.switchAudioModeForHeadphones();
    } else {
      compo.switchAudioModeForNormalSpeakers();
    }
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(Scene.prototype, "audioListenerPositionProvider", {
  get: function() {
    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    return compo.audioListenerPositionProvider;
  },
  set: function(value) {
    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    if (typeof value !== "function") {
      throw new Error("The value passed to [Scene.audioListenerPositionProvider] must be a function that returns a Vector3");
    } else {
      compo.audioListenerPositionProvider = value;
    }
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(Scene.prototype, "audioListenerRotationProvider", {
  get: function() {
    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    return compo.audioListenerRotationProvider;
  },
  set: function(value) {
    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    if (typeof value !== "function") {
      throw new Error("The value passed to [Scene.audioListenerRotationProvider] must be a function that returns a Vector3");
    } else {
      compo.audioListenerRotationProvider = value;
    }
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(Scene.prototype, "audioPositioningRefreshRate", {
  get: function() {
    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    return compo.audioPositioningRefreshRate;
  },
  set: function(value) {
    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    compo.audioPositioningRefreshRate = value;
  },
  enumerable: true,
  configurable: true
});
var AudioSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_AUDIO;
    this._audioEnabled = true;
    this._headphone = false;
    this.audioPositioningRefreshRate = 500;
    this.audioListenerPositionProvider = null;
    this.audioListenerRotationProvider = null;
    this._cachedCameraDirection = new Vector3();
    this._cachedCameraPosition = new Vector3();
    this._lastCheck = 0;
    this._invertMatrixTemp = new Matrix();
    this._cameraDirectionTemp = new Vector3();
    scene = scene || EngineStore.LastCreatedScene;
    if (!scene) {
      return;
    }
    this.scene = scene;
    scene.soundTracks = new Array();
    scene.sounds = new Array();
  }
  get audioEnabled() {
    return this._audioEnabled;
  }
  get headphone() {
    return this._headphone;
  }
  register() {
    this.scene._afterRenderStage.registerStep(SceneComponentConstants.STEP_AFTERRENDER_AUDIO, this, this._afterRender);
  }
  rebuild() {
  }
  serialize(serializationObject) {
    serializationObject.sounds = [];
    if (this.scene.soundTracks) {
      for (let index = 0; index < this.scene.soundTracks.length; index++) {
        const soundtrack = this.scene.soundTracks[index];
        for (let soundId = 0; soundId < soundtrack.soundCollection.length; soundId++) {
          serializationObject.sounds.push(soundtrack.soundCollection[soundId].serialize());
        }
      }
    }
  }
  addFromContainer(container) {
    if (!container.sounds) {
      return;
    }
    container.sounds.forEach((sound) => {
      sound.play();
      sound.autoplay = true;
      this.scene.mainSoundTrack.addSound(sound);
    });
  }
  removeFromContainer(container, dispose = false) {
    if (!container.sounds) {
      return;
    }
    container.sounds.forEach((sound) => {
      sound.stop();
      sound.autoplay = false;
      this.scene.mainSoundTrack.removeSound(sound);
      if (dispose) {
        sound.dispose();
      }
    });
  }
  dispose() {
    const scene = this.scene;
    if (scene._mainSoundTrack) {
      scene.mainSoundTrack.dispose();
    }
    if (scene.soundTracks) {
      for (let scIndex = 0; scIndex < scene.soundTracks.length; scIndex++) {
        scene.soundTracks[scIndex].dispose();
      }
    }
  }
  disableAudio() {
    const scene = this.scene;
    this._audioEnabled = false;
    if (Engine.audioEngine && Engine.audioEngine.audioContext) {
      Engine.audioEngine.audioContext.suspend();
    }
    let i;
    for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {
      scene.mainSoundTrack.soundCollection[i].pause();
    }
    if (scene.soundTracks) {
      for (i = 0; i < scene.soundTracks.length; i++) {
        for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {
          scene.soundTracks[i].soundCollection[j].pause();
        }
      }
    }
  }
  enableAudio() {
    const scene = this.scene;
    this._audioEnabled = true;
    if (Engine.audioEngine && Engine.audioEngine.audioContext) {
      Engine.audioEngine.audioContext.resume();
    }
    let i;
    for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {
      if (scene.mainSoundTrack.soundCollection[i].isPaused) {
        scene.mainSoundTrack.soundCollection[i].play();
      }
    }
    if (scene.soundTracks) {
      for (i = 0; i < scene.soundTracks.length; i++) {
        for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {
          if (scene.soundTracks[i].soundCollection[j].isPaused) {
            scene.soundTracks[i].soundCollection[j].play();
          }
        }
      }
    }
  }
  switchAudioModeForHeadphones() {
    const scene = this.scene;
    this._headphone = true;
    scene.mainSoundTrack.switchPanningModelToHRTF();
    if (scene.soundTracks) {
      for (let i = 0; i < scene.soundTracks.length; i++) {
        scene.soundTracks[i].switchPanningModelToHRTF();
      }
    }
  }
  switchAudioModeForNormalSpeakers() {
    const scene = this.scene;
    this._headphone = false;
    scene.mainSoundTrack.switchPanningModelToEqualPower();
    if (scene.soundTracks) {
      for (let i = 0; i < scene.soundTracks.length; i++) {
        scene.soundTracks[i].switchPanningModelToEqualPower();
      }
    }
  }
  _afterRender() {
    const now = PrecisionDate.Now;
    if (this._lastCheck && now - this._lastCheck < this.audioPositioningRefreshRate) {
      return;
    }
    this._lastCheck = now;
    const scene = this.scene;
    if (!this._audioEnabled || !scene._mainSoundTrack || !scene.soundTracks || scene._mainSoundTrack.soundCollection.length === 0 && scene.soundTracks.length === 1) {
      return;
    }
    const audioEngine = Engine.audioEngine;
    if (!audioEngine) {
      return;
    }
    if (audioEngine.audioContext) {
      let listeningCamera = scene.activeCamera;
      if (scene.activeCameras && scene.activeCameras.length > 0) {
        listeningCamera = scene.activeCameras[0];
      }
      if (this.audioListenerPositionProvider) {
        const position = this.audioListenerPositionProvider();
        audioEngine.audioContext.listener.setPosition(position.x || 0, position.y || 0, position.z || 0);
      } else if (listeningCamera) {
        if (!this._cachedCameraPosition.equals(listeningCamera.globalPosition)) {
          this._cachedCameraPosition.copyFrom(listeningCamera.globalPosition);
          audioEngine.audioContext.listener.setPosition(listeningCamera.globalPosition.x, listeningCamera.globalPosition.y, listeningCamera.globalPosition.z);
        }
      } else {
        audioEngine.audioContext.listener.setPosition(0, 0, 0);
      }
      if (this.audioListenerRotationProvider) {
        const rotation = this.audioListenerRotationProvider();
        audioEngine.audioContext.listener.setOrientation(rotation.x || 0, rotation.y || 0, rotation.z || 0, 0, 1, 0);
      } else if (listeningCamera) {
        if (listeningCamera.rigCameras && listeningCamera.rigCameras.length > 0) {
          listeningCamera = listeningCamera.rigCameras[0];
        }
        listeningCamera.getViewMatrix().invertToRef(this._invertMatrixTemp);
        Vector3.TransformNormalToRef(AudioSceneComponent._CameraDirection, this._invertMatrixTemp, this._cameraDirectionTemp);
        this._cameraDirectionTemp.normalize();
        if (!isNaN(this._cameraDirectionTemp.x) && !isNaN(this._cameraDirectionTemp.y) && !isNaN(this._cameraDirectionTemp.z)) {
          if (!this._cachedCameraDirection.equals(this._cameraDirectionTemp)) {
            this._cachedCameraDirection.copyFrom(this._cameraDirectionTemp);
            audioEngine.audioContext.listener.setOrientation(this._cameraDirectionTemp.x, this._cameraDirectionTemp.y, this._cameraDirectionTemp.z, 0, 1, 0);
          }
        }
      } else {
        audioEngine.audioContext.listener.setOrientation(0, 0, 0, 0, 1, 0);
      }
      let i;
      for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {
        const sound = scene.mainSoundTrack.soundCollection[i];
        if (sound.useCustomAttenuation) {
          sound.updateDistanceFromListener();
        }
      }
      if (scene.soundTracks) {
        for (i = 0; i < scene.soundTracks.length; i++) {
          for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {
            const sound = scene.soundTracks[i].soundCollection[j];
            if (sound.useCustomAttenuation) {
              sound.updateDistanceFromListener();
            }
          }
        }
      }
    }
  }
};
AudioSceneComponent._CameraDirection = new Vector3(0, 0, -1);
Sound._SceneComponentInitialization = (scene) => {
  let compo = scene._getComponent(SceneComponentConstants.NAME_AUDIO);
  if (!compo) {
    compo = new AudioSceneComponent(scene);
    scene._addComponent(compo);
  }
};

// node_modules/@babylonjs/core/BakedVertexAnimation/bakedVertexAnimationManager.js
var BakedVertexAnimationManager = class {
  constructor(scene) {
    this._texture = null;
    this._isEnabled = true;
    this.isEnabled = true;
    this.time = 0;
    scene = scene || EngineStore.LastCreatedScene;
    if (!scene) {
      return;
    }
    this._scene = scene;
    this.animationParameters = new Vector4(0, 0, 0, 30);
  }
  _markSubMeshesAsAttributesDirty() {
    for (const mesh of this._scene.meshes) {
      if (mesh.bakedVertexAnimationManager === this) {
        mesh._markSubMeshesAsAttributesDirty();
      }
    }
  }
  bind(effect, useInstances = false) {
    if (!this._texture || !this._isEnabled) {
      return;
    }
    const size = this._texture.getSize();
    effect.setFloat2("bakedVertexAnimationTextureSizeInverted", 1 / size.width, 1 / size.height);
    effect.setFloat("bakedVertexAnimationTime", this.time);
    if (!useInstances) {
      effect.setVector4("bakedVertexAnimationSettings", this.animationParameters);
    }
    effect.setTexture("bakedVertexAnimationTexture", this._texture);
  }
  clone() {
    const copy = new BakedVertexAnimationManager(this._scene);
    this.copyTo(copy);
    return copy;
  }
  setAnimationParameters(startFrame, endFrame, offset = 0, speedFramesPerSecond = 30) {
    this.animationParameters = new Vector4(startFrame, endFrame, offset, speedFramesPerSecond);
  }
  dispose(forceDisposeTextures) {
    var _a;
    if (forceDisposeTextures) {
      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
    }
  }
  getClassName() {
    return "BakedVertexAnimationManager";
  }
  copyTo(vatMap) {
    SerializationHelper.Clone(() => vatMap, this);
  }
  serialize() {
    return SerializationHelper.Serialize(this);
  }
  parse(source, scene, rootUrl) {
    SerializationHelper.Parse(() => this, source, scene, rootUrl);
  }
};
__decorate([
  serializeAsTexture(),
  expandToProperty("_markSubMeshesAsAttributesDirty")
], BakedVertexAnimationManager.prototype, "texture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markSubMeshesAsAttributesDirty")
], BakedVertexAnimationManager.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], BakedVertexAnimationManager.prototype, "animationParameters", void 0);
__decorate([
  serialize()
], BakedVertexAnimationManager.prototype, "time", void 0);

// node_modules/@babylonjs/core/BakedVertexAnimation/vertexAnimationBaker.js
var VertexAnimationBaker = class {
  constructor(scene, mesh) {
    this._scene = scene;
    this._mesh = mesh;
  }
  async bakeVertexData(ranges) {
    if (!this._mesh.skeleton) {
      throw new Error("No skeleton in this mesh.");
    }
    const boneCount = this._mesh.skeleton.bones.length;
    const frameCount = ranges.reduce((previous, current) => previous + current.to - current.from + 1, 0);
    if (isNaN(frameCount)) {
      throw new Error("Invalid animation ranges.");
    }
    let textureIndex = 0;
    const textureSize = (boneCount + 1) * 4 * 4 * frameCount;
    const vertexData = new Float32Array(textureSize);
    this._scene.stopAnimation(this._mesh);
    this._mesh.skeleton.returnToRest();
    for (const range of ranges) {
      for (let frameIndex = range.from; frameIndex <= range.to; frameIndex++) {
        await this._executeAnimationFrame(vertexData, frameIndex, textureIndex++);
      }
    }
    return vertexData;
  }
  async _executeAnimationFrame(vertexData, frameIndex, textureIndex) {
    return new Promise((resolve, _reject) => {
      this._scene.beginAnimation(this._mesh.skeleton, frameIndex, frameIndex, false, 1, () => {
        const skeletonMatrices = this._mesh.skeleton.getTransformMatrices(this._mesh);
        vertexData.set(skeletonMatrices, textureIndex * skeletonMatrices.length);
        resolve();
      });
    });
  }
  textureFromBakedVertexData(vertexData) {
    if (!this._mesh.skeleton) {
      throw new Error("No skeleton in this mesh.");
    }
    const boneCount = this._mesh.skeleton.bones.length;
    const texture = RawTexture.CreateRGBATexture(vertexData, (boneCount + 1) * 4, vertexData.length / ((boneCount + 1) * 4 * 4), this._scene, false, false, Texture.NEAREST_NEAREST, 1);
    texture.name = "VAT" + this._mesh.skeleton.name;
    return texture;
  }
  serializeBakedVertexDataToObject(vertexData) {
    if (!this._mesh.skeleton) {
      throw new Error("No skeleton in this mesh.");
    }
    const boneCount = this._mesh.skeleton.bones.length;
    const width = (boneCount + 1) * 4;
    const height = vertexData.length / ((boneCount + 1) * 4 * 4);
    const data = {
      vertexData: EncodeArrayBufferToBase64(vertexData),
      width,
      height
    };
    return data;
  }
  loadBakedVertexDataFromObject(data) {
    return new Float32Array(DecodeBase64ToBinary(data.vertexData));
  }
  serializeBakedVertexDataToJSON(vertexData) {
    return JSON.stringify(this.serializeBakedVertexDataToObject(vertexData));
  }
  loadBakedVertexDataFromJSON(json) {
    return this.loadBakedVertexDataFromObject(JSON.parse(json));
  }
};

// node_modules/@babylonjs/core/Behaviors/Cameras/autoRotationBehavior.js
var AutoRotationBehavior = class {
  constructor() {
    this._zoomStopsAnimation = false;
    this._idleRotationSpeed = 0.05;
    this._idleRotationWaitTime = 2e3;
    this._idleRotationSpinupTime = 2e3;
    this.targetAlpha = null;
    this._isPointerDown = false;
    this._lastFrameTime = null;
    this._lastInteractionTime = -Infinity;
    this._cameraRotationSpeed = 0;
    this._lastFrameRadius = 0;
  }
  get name() {
    return "AutoRotation";
  }
  set zoomStopsAnimation(flag) {
    this._zoomStopsAnimation = flag;
  }
  get zoomStopsAnimation() {
    return this._zoomStopsAnimation;
  }
  set idleRotationSpeed(speed) {
    this._idleRotationSpeed = speed;
  }
  get idleRotationSpeed() {
    return this._idleRotationSpeed;
  }
  set idleRotationWaitTime(time) {
    this._idleRotationWaitTime = time;
  }
  get idleRotationWaitTime() {
    return this._idleRotationWaitTime;
  }
  set idleRotationSpinupTime(time) {
    this._idleRotationSpinupTime = time;
  }
  get idleRotationSpinupTime() {
    return this._idleRotationSpinupTime;
  }
  get rotationInProgress() {
    return Math.abs(this._cameraRotationSpeed) > 0;
  }
  init() {
  }
  attach(camera) {
    this._attachedCamera = camera;
    const scene = this._attachedCamera.getScene();
    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {
      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {
        this._isPointerDown = true;
        return;
      }
      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {
        this._isPointerDown = false;
      }
    });
    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {
      if (this._reachTargetAlpha()) {
        return;
      }
      const now = PrecisionDate.Now;
      let dt = 0;
      if (this._lastFrameTime != null) {
        dt = now - this._lastFrameTime;
      }
      this._lastFrameTime = now;
      this._applyUserInteraction();
      const timeToRotation = now - this._lastInteractionTime - this._idleRotationWaitTime;
      const scale = Math.max(Math.min(timeToRotation / this._idleRotationSpinupTime, 1), 0);
      this._cameraRotationSpeed = this._idleRotationSpeed * scale;
      if (this._attachedCamera) {
        this._attachedCamera.alpha -= this._cameraRotationSpeed * (dt / 1e3);
      }
    });
  }
  detach() {
    if (!this._attachedCamera) {
      return;
    }
    const scene = this._attachedCamera.getScene();
    if (this._onPrePointerObservableObserver) {
      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);
    }
    this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
    this._attachedCamera = null;
  }
  resetLastInteractionTime(customTime) {
    this._lastInteractionTime = customTime !== null && customTime !== void 0 ? customTime : PrecisionDate.Now;
  }
  _reachTargetAlpha() {
    if (this._attachedCamera && this.targetAlpha) {
      return Math.abs(this._attachedCamera.alpha - this.targetAlpha) < Epsilon;
    }
    return false;
  }
  _userIsZooming() {
    if (!this._attachedCamera) {
      return false;
    }
    return this._attachedCamera.inertialRadiusOffset !== 0;
  }
  _shouldAnimationStopForInteraction() {
    if (!this._attachedCamera) {
      return false;
    }
    let zoomHasHitLimit = false;
    if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {
      zoomHasHitLimit = true;
    }
    this._lastFrameRadius = this._attachedCamera.radius;
    return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();
  }
  _applyUserInteraction() {
    if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {
      this._lastInteractionTime = PrecisionDate.Now;
    }
  }
  _userIsMoving() {
    if (!this._attachedCamera) {
      return false;
    }
    return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;
  }
};

// node_modules/@babylonjs/core/Behaviors/Cameras/bouncingBehavior.js
var BouncingBehavior = class {
  constructor() {
    this.transitionDuration = 450;
    this.lowerRadiusTransitionRange = 2;
    this.upperRadiusTransitionRange = -2;
    this._autoTransitionRange = false;
    this._radiusIsAnimating = false;
    this._radiusBounceTransition = null;
    this._animatables = new Array();
  }
  get name() {
    return "Bouncing";
  }
  get autoTransitionRange() {
    return this._autoTransitionRange;
  }
  set autoTransitionRange(value) {
    if (this._autoTransitionRange === value) {
      return;
    }
    this._autoTransitionRange = value;
    const camera = this._attachedCamera;
    if (!camera) {
      return;
    }
    if (value) {
      this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((mesh) => {
        if (!mesh) {
          return;
        }
        mesh.computeWorldMatrix(true);
        const diagonal = mesh.getBoundingInfo().diagonalLength;
        this.lowerRadiusTransitionRange = diagonal * 0.05;
        this.upperRadiusTransitionRange = diagonal * 0.05;
      });
    } else if (this._onMeshTargetChangedObserver) {
      camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
    }
  }
  init() {
  }
  attach(camera) {
    this._attachedCamera = camera;
    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {
      if (!this._attachedCamera) {
        return;
      }
      if (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)) {
        this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange);
      }
      if (this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)) {
        this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange);
      }
    });
  }
  detach() {
    if (!this._attachedCamera) {
      return;
    }
    if (this._onAfterCheckInputsObserver) {
      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
    }
    if (this._onMeshTargetChangedObserver) {
      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
    }
    this._attachedCamera = null;
  }
  _isRadiusAtLimit(radiusLimit) {
    if (!this._attachedCamera) {
      return false;
    }
    if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {
      return true;
    }
    return false;
  }
  _applyBoundRadiusAnimation(radiusDelta) {
    if (!this._attachedCamera) {
      return;
    }
    if (!this._radiusBounceTransition) {
      BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);
      this._radiusBounceTransition = Animation.CreateAnimation("radius", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);
    }
    this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;
    this._attachedCamera.wheelPrecision = Infinity;
    this._attachedCamera.inertialRadiusOffset = 0;
    this.stopAllAnimations();
    this._radiusIsAnimating = true;
    const animatable = Animation.TransitionTo("radius", this._attachedCamera.radius + radiusDelta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusBounceTransition, this.transitionDuration, () => this._clearAnimationLocks());
    if (animatable) {
      this._animatables.push(animatable);
    }
  }
  _clearAnimationLocks() {
    this._radiusIsAnimating = false;
    if (this._attachedCamera) {
      this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;
    }
  }
  stopAllAnimations() {
    if (this._attachedCamera) {
      this._attachedCamera.animations = [];
    }
    while (this._animatables.length) {
      this._animatables[0].onAnimationEnd = null;
      this._animatables[0].stop();
      this._animatables.shift();
    }
  }
};
BouncingBehavior.EasingFunction = new BackEase(0.3);
BouncingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEOUT;

// node_modules/@babylonjs/core/Behaviors/Cameras/framingBehavior.js
var FramingBehavior = class {
  constructor() {
    this.onTargetFramingAnimationEndObservable = new Observable();
    this._mode = FramingBehavior.FitFrustumSidesMode;
    this._radiusScale = 1;
    this._positionScale = 0.5;
    this._defaultElevation = 0.3;
    this._elevationReturnTime = 1500;
    this._elevationReturnWaitTime = 1e3;
    this._zoomStopsAnimation = false;
    this._framingTime = 1500;
    this.autoCorrectCameraLimitsAndSensibility = true;
    this._isPointerDown = false;
    this._lastInteractionTime = -Infinity;
    this._animatables = new Array();
    this._betaIsAnimating = false;
  }
  get name() {
    return "Framing";
  }
  set mode(mode) {
    this._mode = mode;
  }
  get mode() {
    return this._mode;
  }
  set radiusScale(radius) {
    this._radiusScale = radius;
  }
  get radiusScale() {
    return this._radiusScale;
  }
  set positionScale(scale) {
    this._positionScale = scale;
  }
  get positionScale() {
    return this._positionScale;
  }
  set defaultElevation(elevation) {
    this._defaultElevation = elevation;
  }
  get defaultElevation() {
    return this._defaultElevation;
  }
  set elevationReturnTime(speed) {
    this._elevationReturnTime = speed;
  }
  get elevationReturnTime() {
    return this._elevationReturnTime;
  }
  set elevationReturnWaitTime(time) {
    this._elevationReturnWaitTime = time;
  }
  get elevationReturnWaitTime() {
    return this._elevationReturnWaitTime;
  }
  set zoomStopsAnimation(flag) {
    this._zoomStopsAnimation = flag;
  }
  get zoomStopsAnimation() {
    return this._zoomStopsAnimation;
  }
  set framingTime(time) {
    this._framingTime = time;
  }
  get framingTime() {
    return this._framingTime;
  }
  init() {
  }
  attach(camera) {
    this._attachedCamera = camera;
    const scene = this._attachedCamera.getScene();
    FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);
    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {
      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {
        this._isPointerDown = true;
        return;
      }
      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {
        this._isPointerDown = false;
      }
    });
    this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((mesh) => {
      if (mesh) {
        this.zoomOnMesh(mesh, void 0, () => {
          this.onTargetFramingAnimationEndObservable.notifyObservers();
        });
      }
    });
    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {
      this._applyUserInteraction();
      this._maintainCameraAboveGround();
    });
  }
  detach() {
    if (!this._attachedCamera) {
      return;
    }
    const scene = this._attachedCamera.getScene();
    if (this._onPrePointerObservableObserver) {
      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);
    }
    if (this._onAfterCheckInputsObserver) {
      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
    }
    if (this._onMeshTargetChangedObserver) {
      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
    }
    this._attachedCamera = null;
  }
  zoomOnMesh(mesh, focusOnOriginXZ = false, onAnimationEnd = null) {
    mesh.computeWorldMatrix(true);
    const boundingBox = mesh.getBoundingInfo().boundingBox;
    this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);
  }
  zoomOnMeshHierarchy(mesh, focusOnOriginXZ = false, onAnimationEnd = null) {
    mesh.computeWorldMatrix(true);
    const boundingBox = mesh.getHierarchyBoundingVectors(true);
    this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);
  }
  zoomOnMeshesHierarchy(meshes, focusOnOriginXZ = false, onAnimationEnd = null) {
    const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    for (let i = 0; i < meshes.length; i++) {
      const boundingInfo = meshes[i].getHierarchyBoundingVectors(true);
      Vector3.CheckExtends(boundingInfo.min, min, max);
      Vector3.CheckExtends(boundingInfo.max, min, max);
    }
    this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);
  }
  zoomOnBoundingInfo(minimumWorld, maximumWorld, focusOnOriginXZ = false, onAnimationEnd = null) {
    let zoomTarget;
    if (!this._attachedCamera) {
      return;
    }
    const bottom = minimumWorld.y;
    const top = maximumWorld.y;
    const zoomTargetY = bottom + (top - bottom) * this._positionScale;
    const radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);
    if (focusOnOriginXZ) {
      zoomTarget = new Vector3(0, zoomTargetY, 0);
    } else {
      const centerWorld = minimumWorld.add(radiusWorld);
      zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);
    }
    if (!this._vectorTransition) {
      this._vectorTransition = Animation.CreateAnimation("target", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);
    }
    this._betaIsAnimating = true;
    let animatable = Animation.TransitionTo("target", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);
    if (animatable) {
      this._animatables.push(animatable);
    }
    let radius = 0;
    if (this._mode === FramingBehavior.FitFrustumSidesMode) {
      const position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);
      if (this.autoCorrectCameraLimitsAndSensibility) {
        this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;
      }
      radius = position;
    } else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {
      radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);
      if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {
        this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;
      }
    }
    if (this.autoCorrectCameraLimitsAndSensibility) {
      const extend = maximumWorld.subtract(minimumWorld).length();
      this._attachedCamera.panningSensibility = 5e3 / extend;
      this._attachedCamera.wheelPrecision = 100 / radius;
    }
    if (!this._radiusTransition) {
      this._radiusTransition = Animation.CreateAnimation("radius", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);
    }
    animatable = Animation.TransitionTo("radius", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, () => {
      this.stopAllAnimations();
      if (onAnimationEnd) {
        onAnimationEnd();
      }
      if (this._attachedCamera && this._attachedCamera.useInputToRestoreState) {
        this._attachedCamera.storeState();
      }
    });
    if (animatable) {
      this._animatables.push(animatable);
    }
  }
  _calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld) {
    const size = maximumWorld.subtract(minimumWorld);
    const boxVectorGlobalDiagonal = size.length();
    const frustumSlope = this._getFrustumSlope();
    const radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5;
    const radius = radiusWithoutFraming * this._radiusScale;
    const distanceForHorizontalFrustum = radius * Math.sqrt(1 + 1 / (frustumSlope.x * frustumSlope.x));
    const distanceForVerticalFrustum = radius * Math.sqrt(1 + 1 / (frustumSlope.y * frustumSlope.y));
    let distance = Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);
    const camera = this._attachedCamera;
    if (!camera) {
      return 0;
    }
    if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {
      distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;
    }
    if (camera.upperRadiusLimit) {
      distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;
    }
    return distance;
  }
  _maintainCameraAboveGround() {
    if (this._elevationReturnTime < 0) {
      return;
    }
    const timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;
    const defaultBeta = Math.PI * 0.5 - this._defaultElevation;
    const limitBeta = Math.PI * 0.5;
    if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {
      this._betaIsAnimating = true;
      this.stopAllAnimations();
      if (!this._betaTransition) {
        this._betaTransition = Animation.CreateAnimation("beta", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);
      }
      const animatabe = Animation.TransitionTo("beta", defaultBeta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._betaTransition, this._elevationReturnTime, () => {
        this._clearAnimationLocks();
        this.stopAllAnimations();
      });
      if (animatabe) {
        this._animatables.push(animatabe);
      }
    }
  }
  _getFrustumSlope() {
    const camera = this._attachedCamera;
    if (!camera) {
      return Vector2.Zero();
    }
    const engine = camera.getScene().getEngine();
    const aspectRatio = engine.getAspectRatio(camera);
    const frustumSlopeY = Math.tan(camera.fov / 2);
    const frustumSlopeX = frustumSlopeY * aspectRatio;
    return new Vector2(frustumSlopeX, frustumSlopeY);
  }
  _clearAnimationLocks() {
    this._betaIsAnimating = false;
  }
  _applyUserInteraction() {
    if (this.isUserIsMoving) {
      this._lastInteractionTime = PrecisionDate.Now;
      this.stopAllAnimations();
      this._clearAnimationLocks();
    }
  }
  stopAllAnimations() {
    if (this._attachedCamera) {
      this._attachedCamera.animations = [];
    }
    while (this._animatables.length) {
      if (this._animatables[0]) {
        this._animatables[0].onAnimationEnd = null;
        this._animatables[0].stop();
      }
      this._animatables.shift();
    }
  }
  get isUserIsMoving() {
    if (!this._attachedCamera) {
      return false;
    }
    return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;
  }
};
FramingBehavior.EasingFunction = new ExponentialEase();
FramingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEINOUT;
FramingBehavior.IgnoreBoundsSizeMode = 0;
FramingBehavior.FitFrustumSidesMode = 1;

// node_modules/@babylonjs/core/Behaviors/Meshes/attachToBoxBehavior.js
var FaceDirectionInfo = class {
  constructor(direction, rotatedDirection = new Vector3(), diff = 0, ignore = false) {
    this.direction = direction;
    this.rotatedDirection = rotatedDirection;
    this.diff = diff;
    this.ignore = ignore;
  }
};
var AttachToBoxBehavior = class {
  constructor(_ui) {
    this._ui = _ui;
    this.name = "AttachToBoxBehavior";
    this.distanceAwayFromFace = 0.15;
    this.distanceAwayFromBottomOfFace = 0.15;
    this._faceVectors = [
      new FaceDirectionInfo(Vector3.Up()),
      new FaceDirectionInfo(Vector3.Down()),
      new FaceDirectionInfo(Vector3.Left()),
      new FaceDirectionInfo(Vector3.Right()),
      new FaceDirectionInfo(Vector3.Forward()),
      new FaceDirectionInfo(Vector3.Forward().scaleInPlace(-1))
    ];
    this._tmpMatrix = new Matrix();
    this._tmpVector = new Vector3();
    this._zeroVector = Vector3.Zero();
    this._lookAtTmpMatrix = new Matrix();
  }
  init() {
  }
  _closestFace(targetDirection) {
    this._faceVectors.forEach((v) => {
      if (!this._target.rotationQuaternion) {
        this._target.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._target.rotation.y, this._target.rotation.x, this._target.rotation.z);
      }
      this._target.rotationQuaternion.toRotationMatrix(this._tmpMatrix);
      Vector3.TransformCoordinatesToRef(v.direction, this._tmpMatrix, v.rotatedDirection);
      v.diff = Vector3.GetAngleBetweenVectors(v.rotatedDirection, targetDirection, Vector3.Cross(v.rotatedDirection, targetDirection));
    });
    return this._faceVectors.reduce((min, p) => {
      if (min.ignore) {
        return p;
      } else if (p.ignore) {
        return min;
      } else {
        return min.diff < p.diff ? min : p;
      }
    }, this._faceVectors[0]);
  }
  _lookAtToRef(pos, up = new Vector3(0, 1, 0), ref) {
    Matrix.LookAtLHToRef(this._zeroVector, pos, up, this._lookAtTmpMatrix);
    this._lookAtTmpMatrix.invert();
    Quaternion.FromRotationMatrixToRef(this._lookAtTmpMatrix, ref);
  }
  attach(target) {
    this._target = target;
    this._scene = this._target.getScene();
    this._onRenderObserver = this._scene.onBeforeRenderObservable.add(() => {
      if (!this._scene.activeCamera) {
        return;
      }
      let cameraPos = this._scene.activeCamera.position;
      if (this._scene.activeCamera.devicePosition) {
        cameraPos = this._scene.activeCamera.devicePosition;
      }
      const facing = this._closestFace(cameraPos.subtract(target.position));
      if (this._scene.activeCamera.leftCamera) {
        this._scene.activeCamera.leftCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);
      } else {
        this._scene.activeCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);
      }
      Vector3.TransformCoordinatesToRef(Vector3.Up(), this._tmpMatrix, this._tmpVector);
      this._faceVectors.forEach((v) => {
        if (facing.direction.x && v.direction.x) {
          v.ignore = true;
        }
        if (facing.direction.y && v.direction.y) {
          v.ignore = true;
        }
        if (facing.direction.z && v.direction.z) {
          v.ignore = true;
        }
      });
      const facingUp = this._closestFace(this._tmpVector);
      this._faceVectors.forEach((v) => {
        v.ignore = false;
      });
      this._ui.position.copyFrom(target.position);
      if (facing.direction.x) {
        facing.rotatedDirection.scaleToRef(target.scaling.x / 2 + this.distanceAwayFromFace, this._tmpVector);
        this._ui.position.addInPlace(this._tmpVector);
      }
      if (facing.direction.y) {
        facing.rotatedDirection.scaleToRef(target.scaling.y / 2 + this.distanceAwayFromFace, this._tmpVector);
        this._ui.position.addInPlace(this._tmpVector);
      }
      if (facing.direction.z) {
        facing.rotatedDirection.scaleToRef(target.scaling.z / 2 + this.distanceAwayFromFace, this._tmpVector);
        this._ui.position.addInPlace(this._tmpVector);
      }
      if (!this._ui.rotationQuaternion) {
        this._ui.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ui.rotation.y, this._ui.rotation.x, this._ui.rotation.z);
      }
      facing.rotatedDirection.scaleToRef(-1, this._tmpVector);
      this._lookAtToRef(this._tmpVector, facingUp.rotatedDirection, this._ui.rotationQuaternion);
      if (facingUp.direction.x) {
        this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.x / 2, this._tmpVector);
      }
      if (facingUp.direction.y) {
        this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.y / 2, this._tmpVector);
      }
      if (facingUp.direction.z) {
        this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.z / 2, this._tmpVector);
      }
      this._ui.position.addInPlace(this._tmpVector);
    });
  }
  detach() {
    this._scene.onBeforeRenderObservable.remove(this._onRenderObserver);
  }
};

// node_modules/@babylonjs/core/Behaviors/Meshes/multiPointerScaleBehavior.js
var MultiPointerScaleBehavior = class {
  constructor() {
    this._startDistance = 0;
    this._initialScale = new Vector3(0, 0, 0);
    this._targetScale = new Vector3(0, 0, 0);
    this._sceneRenderObserver = null;
    this._dragBehaviorA = new PointerDragBehavior({});
    this._dragBehaviorA.moveAttached = false;
    this._dragBehaviorB = new PointerDragBehavior({});
    this._dragBehaviorB.moveAttached = false;
  }
  get name() {
    return "MultiPointerScale";
  }
  init() {
  }
  _getCurrentDistance() {
    return this._dragBehaviorA.lastDragPosition.subtract(this._dragBehaviorB.lastDragPosition).length();
  }
  attach(ownerNode) {
    this._ownerNode = ownerNode;
    this._dragBehaviorA.onDragStartObservable.add(() => {
      if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {
        if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {
          this._dragBehaviorA.releaseDrag();
        } else {
          this._initialScale.copyFrom(ownerNode.scaling);
          this._startDistance = this._getCurrentDistance();
        }
      }
    });
    this._dragBehaviorB.onDragStartObservable.add(() => {
      if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {
        if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {
          this._dragBehaviorB.releaseDrag();
        } else {
          this._initialScale.copyFrom(ownerNode.scaling);
          this._startDistance = this._getCurrentDistance();
        }
      }
    });
    [this._dragBehaviorA, this._dragBehaviorB].forEach((behavior) => {
      behavior.onDragObservable.add(() => {
        if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {
          const ratio = this._getCurrentDistance() / this._startDistance;
          this._initialScale.scaleToRef(ratio, this._targetScale);
        }
      });
    });
    ownerNode.addBehavior(this._dragBehaviorA);
    ownerNode.addBehavior(this._dragBehaviorB);
    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {
      if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {
        const change = this._targetScale.subtract(ownerNode.scaling).scaleInPlace(0.1);
        if (change.length() > 0.01) {
          ownerNode.scaling.addInPlace(change);
        }
      }
    });
  }
  detach() {
    this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);
    [this._dragBehaviorA, this._dragBehaviorB].forEach((behavior) => {
      behavior.onDragStartObservable.clear();
      behavior.onDragObservable.clear();
      this._ownerNode.removeBehavior(behavior);
    });
  }
};

// node_modules/@babylonjs/core/Bones/boneIKController.js
var BoneIKController = class {
  constructor(mesh, bone, options) {
    this.targetPosition = Vector3.Zero();
    this.poleTargetPosition = Vector3.Zero();
    this.poleTargetLocalOffset = Vector3.Zero();
    this.poleAngle = 0;
    this.slerpAmount = 1;
    this._bone1Quat = Quaternion.Identity();
    this._bone1Mat = Matrix.Identity();
    this._bone2Ang = Math.PI;
    this._maxAngle = Math.PI;
    this._rightHandedSystem = false;
    this._bendAxis = Vector3.Right();
    this._slerping = false;
    this._adjustRoll = 0;
    this._notEnoughInformation = false;
    this._bone2 = bone;
    const bone1 = bone.getParent();
    if (!bone1) {
      this._notEnoughInformation = true;
      Logger.Error("BoneIKController: bone must have a parent for IK to work.");
      return;
    }
    this._bone1 = bone1;
    if (this._bone2.children.length === 0 && !this._bone2.length) {
      this._notEnoughInformation = true;
      Logger.Error("BoneIKController: bone must not be a leaf or it should have a length for IK to work.");
      return;
    }
    this.mesh = mesh;
    const bonePos = bone.getPosition();
    if (bone.getAbsoluteTransform().determinant() > 0) {
      this._rightHandedSystem = true;
      this._bendAxis.x = 0;
      this._bendAxis.y = 0;
      this._bendAxis.z = -1;
      if (bonePos.x > bonePos.y && bonePos.x > bonePos.z) {
        this._adjustRoll = Math.PI * 0.5;
        this._bendAxis.z = 1;
      }
    }
    if (this._bone1.length && this._bone2.length) {
      const boneScale1 = this._bone1.getScale();
      const boneScale2 = this._bone2.getScale();
      this._bone1Length = this._bone1.length * boneScale1.y * this.mesh.scaling.y;
      this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;
    } else if (this._bone2.children[0]) {
      mesh.computeWorldMatrix(true);
      const pos1 = this._bone2.children[0].getAbsolutePosition(mesh);
      const pos2 = this._bone2.getAbsolutePosition(mesh);
      const pos3 = this._bone1.getAbsolutePosition(mesh);
      this._bone2Length = Vector3.Distance(pos1, pos2);
      this._bone1Length = Vector3.Distance(pos2, pos3);
    } else {
      mesh.computeWorldMatrix(true);
      const boneScale2 = this._bone2.getScale();
      this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;
      const pos2 = this._bone2.getAbsolutePosition(mesh);
      const pos3 = this._bone1.getAbsolutePosition(mesh);
      this._bone1Length = Vector3.Distance(pos2, pos3);
    }
    this._bone1.getRotationMatrixToRef(Space.WORLD, mesh, this._bone1Mat);
    this.maxAngle = Math.PI;
    if (options) {
      if (options.targetMesh) {
        this.targetMesh = options.targetMesh;
        this.targetMesh.computeWorldMatrix(true);
      }
      if (options.poleTargetMesh) {
        this.poleTargetMesh = options.poleTargetMesh;
        this.poleTargetMesh.computeWorldMatrix(true);
      } else if (options.poleTargetBone) {
        this.poleTargetBone = options.poleTargetBone;
      } else if (this._bone1.getParent()) {
        this.poleTargetBone = this._bone1.getParent();
      }
      if (options.poleTargetLocalOffset) {
        this.poleTargetLocalOffset.copyFrom(options.poleTargetLocalOffset);
      }
      if (options.poleAngle) {
        this.poleAngle = options.poleAngle;
      }
      if (options.bendAxis) {
        this._bendAxis.copyFrom(options.bendAxis);
      }
      if (options.maxAngle) {
        this.maxAngle = options.maxAngle;
      }
      if (options.slerpAmount) {
        this.slerpAmount = options.slerpAmount;
      }
    }
  }
  get maxAngle() {
    return this._maxAngle;
  }
  set maxAngle(value) {
    this._setMaxAngle(value);
  }
  _setMaxAngle(ang) {
    if (ang < 0) {
      ang = 0;
    }
    if (ang > Math.PI || ang == void 0) {
      ang = Math.PI;
    }
    this._maxAngle = ang;
    const a = this._bone1Length;
    const b = this._bone2Length;
    this._maxReach = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(ang));
  }
  update() {
    if (this._notEnoughInformation) {
      return;
    }
    const target = this.targetPosition;
    const poleTarget = this.poleTargetPosition;
    const mat1 = BoneIKController._TmpMats[0];
    const mat2 = BoneIKController._TmpMats[1];
    if (this.targetMesh) {
      target.copyFrom(this.targetMesh.getAbsolutePosition());
    }
    if (this.poleTargetBone) {
      this.poleTargetBone.getAbsolutePositionFromLocalToRef(this.poleTargetLocalOffset, this.mesh, poleTarget);
    } else if (this.poleTargetMesh) {
      Vector3.TransformCoordinatesToRef(this.poleTargetLocalOffset, this.poleTargetMesh.getWorldMatrix(), poleTarget);
    }
    const bonePos = BoneIKController._TmpVecs[0];
    const zaxis = BoneIKController._TmpVecs[1];
    const xaxis = BoneIKController._TmpVecs[2];
    const yaxis = BoneIKController._TmpVecs[3];
    const upAxis = BoneIKController._TmpVecs[4];
    const tmpQuat = BoneIKController._TmpQuat;
    this._bone1.getAbsolutePositionToRef(this.mesh, bonePos);
    poleTarget.subtractToRef(bonePos, upAxis);
    if (upAxis.x == 0 && upAxis.y == 0 && upAxis.z == 0) {
      upAxis.y = 1;
    } else {
      upAxis.normalize();
    }
    target.subtractToRef(bonePos, yaxis);
    yaxis.normalize();
    Vector3.CrossToRef(yaxis, upAxis, zaxis);
    zaxis.normalize();
    Vector3.CrossToRef(yaxis, zaxis, xaxis);
    xaxis.normalize();
    Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, mat1);
    const a = this._bone1Length;
    const b = this._bone2Length;
    let c = Vector3.Distance(bonePos, target);
    if (this._maxReach > 0) {
      c = Math.min(this._maxReach, c);
    }
    let acosa = (b * b + c * c - a * a) / (2 * b * c);
    let acosb = (c * c + a * a - b * b) / (2 * c * a);
    if (acosa > 1) {
      acosa = 1;
    }
    if (acosb > 1) {
      acosb = 1;
    }
    if (acosa < -1) {
      acosa = -1;
    }
    if (acosb < -1) {
      acosb = -1;
    }
    const angA = Math.acos(acosa);
    const angB = Math.acos(acosb);
    let angC = -angA - angB;
    if (this._rightHandedSystem) {
      Matrix.RotationYawPitchRollToRef(0, 0, this._adjustRoll, mat2);
      mat2.multiplyToRef(mat1, mat1);
      Matrix.RotationAxisToRef(this._bendAxis, angB, mat2);
      mat2.multiplyToRef(mat1, mat1);
    } else {
      const _tmpVec = BoneIKController._TmpVecs[5];
      _tmpVec.copyFrom(this._bendAxis);
      _tmpVec.x *= -1;
      Matrix.RotationAxisToRef(_tmpVec, -angB, mat2);
      mat2.multiplyToRef(mat1, mat1);
    }
    if (this.poleAngle) {
      Matrix.RotationAxisToRef(yaxis, this.poleAngle, mat2);
      mat1.multiplyToRef(mat2, mat1);
    }
    if (this._bone1) {
      if (this.slerpAmount < 1) {
        if (!this._slerping) {
          Quaternion.FromRotationMatrixToRef(this._bone1Mat, this._bone1Quat);
        }
        Quaternion.FromRotationMatrixToRef(mat1, tmpQuat);
        Quaternion.SlerpToRef(this._bone1Quat, tmpQuat, this.slerpAmount, this._bone1Quat);
        angC = this._bone2Ang * (1 - this.slerpAmount) + angC * this.slerpAmount;
        this._bone1.setRotationQuaternion(this._bone1Quat, Space.WORLD, this.mesh);
        this._slerping = true;
      } else {
        this._bone1.setRotationMatrix(mat1, Space.WORLD, this.mesh);
        this._bone1Mat.copyFrom(mat1);
        this._slerping = false;
      }
      this._updateLinkedTransformRotation(this._bone1);
    }
    this._bone2.setAxisAngle(this._bendAxis, angC, Space.LOCAL);
    this._updateLinkedTransformRotation(this._bone2);
    this._bone2Ang = angC;
  }
  _updateLinkedTransformRotation(bone) {
    if (bone._linkedTransformNode) {
      if (!bone._linkedTransformNode.rotationQuaternion) {
        bone._linkedTransformNode.rotationQuaternion = new Quaternion();
      }
      bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);
    }
  }
};
BoneIKController._TmpVecs = [Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero()];
BoneIKController._TmpQuat = Quaternion.Identity();
BoneIKController._TmpMats = [Matrix.Identity(), Matrix.Identity()];

// node_modules/@babylonjs/core/Bones/boneLookController.js
var BoneLookController = class {
  constructor(mesh, bone, target, options) {
    this.upAxis = Vector3.Up();
    this.upAxisSpace = Space.LOCAL;
    this.adjustYaw = 0;
    this.adjustPitch = 0;
    this.adjustRoll = 0;
    this.slerpAmount = 1;
    this._boneQuat = Quaternion.Identity();
    this._slerping = false;
    this._firstFrameSkipped = false;
    this._fowardAxis = Vector3.Forward();
    this.mesh = mesh;
    this.bone = bone;
    this.target = target;
    if (options) {
      if (options.adjustYaw) {
        this.adjustYaw = options.adjustYaw;
      }
      if (options.adjustPitch) {
        this.adjustPitch = options.adjustPitch;
      }
      if (options.adjustRoll) {
        this.adjustRoll = options.adjustRoll;
      }
      if (options.maxYaw != null) {
        this.maxYaw = options.maxYaw;
      } else {
        this.maxYaw = Math.PI;
      }
      if (options.minYaw != null) {
        this.minYaw = options.minYaw;
      } else {
        this.minYaw = -Math.PI;
      }
      if (options.maxPitch != null) {
        this.maxPitch = options.maxPitch;
      } else {
        this.maxPitch = Math.PI;
      }
      if (options.minPitch != null) {
        this.minPitch = options.minPitch;
      } else {
        this.minPitch = -Math.PI;
      }
      if (options.slerpAmount != null) {
        this.slerpAmount = options.slerpAmount;
      }
      if (options.upAxis != null) {
        this.upAxis = options.upAxis;
      }
      if (options.upAxisSpace != null) {
        this.upAxisSpace = options.upAxisSpace;
      }
      if (options.yawAxis != null || options.pitchAxis != null) {
        let newYawAxis = Axis.Y;
        let newPitchAxis = Axis.X;
        if (options.yawAxis != null) {
          newYawAxis = options.yawAxis.clone();
          newYawAxis.normalize();
        }
        if (options.pitchAxis != null) {
          newPitchAxis = options.pitchAxis.clone();
          newPitchAxis.normalize();
        }
        const newRollAxis = Vector3.Cross(newPitchAxis, newYawAxis);
        this._transformYawPitch = Matrix.Identity();
        Matrix.FromXYZAxesToRef(newPitchAxis, newYawAxis, newRollAxis, this._transformYawPitch);
        this._transformYawPitchInv = this._transformYawPitch.clone();
        this._transformYawPitch.invert();
      }
    }
    if (!bone.getParent() && this.upAxisSpace == Space.BONE) {
      this.upAxisSpace = Space.LOCAL;
    }
  }
  get minYaw() {
    return this._minYaw;
  }
  set minYaw(value) {
    this._minYaw = value;
    this._minYawSin = Math.sin(value);
    this._minYawCos = Math.cos(value);
    if (this._maxYaw != null) {
      this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;
      this._yawRange = this._maxYaw - this._minYaw;
    }
  }
  get maxYaw() {
    return this._maxYaw;
  }
  set maxYaw(value) {
    this._maxYaw = value;
    this._maxYawSin = Math.sin(value);
    this._maxYawCos = Math.cos(value);
    if (this._minYaw != null) {
      this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;
      this._yawRange = this._maxYaw - this._minYaw;
    }
  }
  get minPitch() {
    return this._minPitch;
  }
  set minPitch(value) {
    this._minPitch = value;
    this._minPitchTan = Math.tan(value);
  }
  get maxPitch() {
    return this._maxPitch;
  }
  set maxPitch(value) {
    this._maxPitch = value;
    this._maxPitchTan = Math.tan(value);
  }
  update() {
    if (this.slerpAmount < 1 && !this._firstFrameSkipped) {
      this._firstFrameSkipped = true;
      return;
    }
    const bone = this.bone;
    const bonePos = BoneLookController._TmpVecs[0];
    bone.getAbsolutePositionToRef(this.mesh, bonePos);
    let target = this.target;
    const _tmpMat1 = BoneLookController._TmpMats[0];
    const _tmpMat2 = BoneLookController._TmpMats[1];
    const mesh = this.mesh;
    const parentBone = bone.getParent();
    const upAxis = BoneLookController._TmpVecs[1];
    upAxis.copyFrom(this.upAxis);
    if (this.upAxisSpace == Space.BONE && parentBone) {
      if (this._transformYawPitch) {
        Vector3.TransformCoordinatesToRef(upAxis, this._transformYawPitchInv, upAxis);
      }
      parentBone.getDirectionToRef(upAxis, this.mesh, upAxis);
    } else if (this.upAxisSpace == Space.LOCAL) {
      mesh.getDirectionToRef(upAxis, upAxis);
      if (mesh.scaling.x != 1 || mesh.scaling.y != 1 || mesh.scaling.z != 1) {
        upAxis.normalize();
      }
    }
    let checkYaw = false;
    let checkPitch = false;
    if (this._maxYaw != Math.PI || this._minYaw != -Math.PI) {
      checkYaw = true;
    }
    if (this._maxPitch != Math.PI || this._minPitch != -Math.PI) {
      checkPitch = true;
    }
    if (checkYaw || checkPitch) {
      const spaceMat = BoneLookController._TmpMats[2];
      const spaceMatInv = BoneLookController._TmpMats[3];
      if (this.upAxisSpace == Space.BONE && upAxis.y == 1 && parentBone) {
        parentBone.getRotationMatrixToRef(Space.WORLD, this.mesh, spaceMat);
      } else if (this.upAxisSpace == Space.LOCAL && upAxis.y == 1 && !parentBone) {
        spaceMat.copyFrom(mesh.getWorldMatrix());
      } else {
        let forwardAxis = BoneLookController._TmpVecs[2];
        forwardAxis.copyFrom(this._fowardAxis);
        if (this._transformYawPitch) {
          Vector3.TransformCoordinatesToRef(forwardAxis, this._transformYawPitchInv, forwardAxis);
        }
        if (parentBone) {
          parentBone.getDirectionToRef(forwardAxis, this.mesh, forwardAxis);
        } else {
          mesh.getDirectionToRef(forwardAxis, forwardAxis);
        }
        const rightAxis = Vector3.Cross(upAxis, forwardAxis);
        rightAxis.normalize();
        forwardAxis = Vector3.Cross(rightAxis, upAxis);
        Matrix.FromXYZAxesToRef(rightAxis, upAxis, forwardAxis, spaceMat);
      }
      spaceMat.invertToRef(spaceMatInv);
      let xzlen = null;
      if (checkPitch) {
        const localTarget = BoneLookController._TmpVecs[3];
        target.subtractToRef(bonePos, localTarget);
        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);
        xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);
        const pitch = Math.atan2(localTarget.y, xzlen);
        let newPitch = pitch;
        if (pitch > this._maxPitch) {
          localTarget.y = this._maxPitchTan * xzlen;
          newPitch = this._maxPitch;
        } else if (pitch < this._minPitch) {
          localTarget.y = this._minPitchTan * xzlen;
          newPitch = this._minPitch;
        }
        if (pitch != newPitch) {
          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);
          localTarget.addInPlace(bonePos);
          target = localTarget;
        }
      }
      if (checkYaw) {
        const localTarget = BoneLookController._TmpVecs[4];
        target.subtractToRef(bonePos, localTarget);
        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);
        const yaw = Math.atan2(localTarget.x, localTarget.z);
        let newYaw = yaw;
        if (yaw > this._maxYaw || yaw < this._minYaw) {
          if (xzlen == null) {
            xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);
          }
          if (this._yawRange > Math.PI) {
            if (this._isAngleBetween(yaw, this._maxYaw, this._midYawConstraint)) {
              localTarget.z = this._maxYawCos * xzlen;
              localTarget.x = this._maxYawSin * xzlen;
              newYaw = this._maxYaw;
            } else if (this._isAngleBetween(yaw, this._midYawConstraint, this._minYaw)) {
              localTarget.z = this._minYawCos * xzlen;
              localTarget.x = this._minYawSin * xzlen;
              newYaw = this._minYaw;
            }
          } else {
            if (yaw > this._maxYaw) {
              localTarget.z = this._maxYawCos * xzlen;
              localTarget.x = this._maxYawSin * xzlen;
              newYaw = this._maxYaw;
            } else if (yaw < this._minYaw) {
              localTarget.z = this._minYawCos * xzlen;
              localTarget.x = this._minYawSin * xzlen;
              newYaw = this._minYaw;
            }
          }
        }
        if (this._slerping && this._yawRange > Math.PI) {
          const boneFwd = BoneLookController._TmpVecs[8];
          boneFwd.copyFrom(Axis.Z);
          if (this._transformYawPitch) {
            Vector3.TransformCoordinatesToRef(boneFwd, this._transformYawPitchInv, boneFwd);
          }
          const boneRotMat = BoneLookController._TmpMats[4];
          this._boneQuat.toRotationMatrix(boneRotMat);
          this.mesh.getWorldMatrix().multiplyToRef(boneRotMat, boneRotMat);
          Vector3.TransformCoordinatesToRef(boneFwd, boneRotMat, boneFwd);
          Vector3.TransformCoordinatesToRef(boneFwd, spaceMatInv, boneFwd);
          const boneYaw = Math.atan2(boneFwd.x, boneFwd.z);
          const angBtwTar = this._getAngleBetween(boneYaw, yaw);
          const angBtwMidYaw = this._getAngleBetween(boneYaw, this._midYawConstraint);
          if (angBtwTar > angBtwMidYaw) {
            if (xzlen == null) {
              xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);
            }
            const angBtwMax = this._getAngleBetween(boneYaw, this._maxYaw);
            const angBtwMin = this._getAngleBetween(boneYaw, this._minYaw);
            if (angBtwMin < angBtwMax) {
              newYaw = boneYaw + Math.PI * 0.75;
              localTarget.z = Math.cos(newYaw) * xzlen;
              localTarget.x = Math.sin(newYaw) * xzlen;
            } else {
              newYaw = boneYaw - Math.PI * 0.75;
              localTarget.z = Math.cos(newYaw) * xzlen;
              localTarget.x = Math.sin(newYaw) * xzlen;
            }
          }
        }
        if (yaw != newYaw) {
          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);
          localTarget.addInPlace(bonePos);
          target = localTarget;
        }
      }
    }
    const zaxis = BoneLookController._TmpVecs[5];
    const xaxis = BoneLookController._TmpVecs[6];
    const yaxis = BoneLookController._TmpVecs[7];
    const tmpQuat = BoneLookController._TmpQuat;
    target.subtractToRef(bonePos, zaxis);
    zaxis.normalize();
    Vector3.CrossToRef(upAxis, zaxis, xaxis);
    xaxis.normalize();
    Vector3.CrossToRef(zaxis, xaxis, yaxis);
    yaxis.normalize();
    Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, _tmpMat1);
    if (xaxis.x === 0 && xaxis.y === 0 && xaxis.z === 0) {
      return;
    }
    if (yaxis.x === 0 && yaxis.y === 0 && yaxis.z === 0) {
      return;
    }
    if (zaxis.x === 0 && zaxis.y === 0 && zaxis.z === 0) {
      return;
    }
    if (this.adjustYaw || this.adjustPitch || this.adjustRoll) {
      Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, _tmpMat2);
      _tmpMat2.multiplyToRef(_tmpMat1, _tmpMat1);
    }
    if (this.slerpAmount < 1) {
      if (!this._slerping) {
        this.bone.getRotationQuaternionToRef(Space.WORLD, this.mesh, this._boneQuat);
      }
      if (this._transformYawPitch) {
        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);
      }
      Quaternion.FromRotationMatrixToRef(_tmpMat1, tmpQuat);
      Quaternion.SlerpToRef(this._boneQuat, tmpQuat, this.slerpAmount, this._boneQuat);
      this.bone.setRotationQuaternion(this._boneQuat, Space.WORLD, this.mesh);
      this._slerping = true;
    } else {
      if (this._transformYawPitch) {
        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);
      }
      this.bone.setRotationMatrix(_tmpMat1, Space.WORLD, this.mesh);
      this._slerping = false;
    }
    this._updateLinkedTransformRotation();
  }
  _getAngleDiff(ang1, ang2) {
    let angDiff = ang2 - ang1;
    angDiff %= Math.PI * 2;
    if (angDiff > Math.PI) {
      angDiff -= Math.PI * 2;
    } else if (angDiff < -Math.PI) {
      angDiff += Math.PI * 2;
    }
    return angDiff;
  }
  _getAngleBetween(ang1, ang2) {
    ang1 %= 2 * Math.PI;
    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;
    ang2 %= 2 * Math.PI;
    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;
    let ab = 0;
    if (ang1 < ang2) {
      ab = ang2 - ang1;
    } else {
      ab = ang1 - ang2;
    }
    if (ab > Math.PI) {
      ab = Math.PI * 2 - ab;
    }
    return ab;
  }
  _isAngleBetween(ang, ang1, ang2) {
    ang %= 2 * Math.PI;
    ang = ang < 0 ? ang + 2 * Math.PI : ang;
    ang1 %= 2 * Math.PI;
    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;
    ang2 %= 2 * Math.PI;
    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;
    if (ang1 < ang2) {
      if (ang > ang1 && ang < ang2) {
        return true;
      }
    } else {
      if (ang > ang2 && ang < ang1) {
        return true;
      }
    }
    return false;
  }
  _updateLinkedTransformRotation() {
    const bone = this.bone;
    if (bone._linkedTransformNode) {
      if (!bone._linkedTransformNode.rotationQuaternion) {
        bone._linkedTransformNode.rotationQuaternion = new Quaternion();
      }
      bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);
    }
  }
};
BoneLookController._TmpVecs = ArrayTools.BuildArray(10, Vector3.Zero);
BoneLookController._TmpQuat = Quaternion.Identity();
BoneLookController._TmpMats = ArrayTools.BuildArray(5, Matrix.Identity);

// node_modules/@babylonjs/core/Buffers/storageBuffer.js
var StorageBuffer = class {
  constructor(engine, size, creationFlags = 3) {
    this._engine = engine;
    this._engine._storageBuffers.push(this);
    this._create(size, creationFlags);
  }
  _create(size, creationFlags) {
    this._bufferSize = size;
    this._creationFlags = creationFlags;
    this._buffer = this._engine.createStorageBuffer(size, creationFlags);
  }
  _rebuild() {
    this._create(this._bufferSize, this._creationFlags);
  }
  getBuffer() {
    return this._buffer;
  }
  update(data, byteOffset, byteLength) {
    if (!this._buffer) {
      return;
    }
    this._engine.updateStorageBuffer(this._buffer, data, byteOffset, byteLength);
  }
  read(offset, size, buffer) {
    return this._engine.readFromStorageBuffer(this._buffer, offset, size, buffer);
  }
  dispose() {
    const storageBuffers = this._engine._storageBuffers;
    const index = storageBuffers.indexOf(this);
    if (index !== -1) {
      storageBuffers[index] = storageBuffers[storageBuffers.length - 1];
      storageBuffers.pop();
    }
    this._engine._releaseBuffer(this._buffer);
    this._buffer = null;
  }
};

// node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraPointersInput.js
var BaseCameraPointersInput = class {
  constructor() {
    this._currentActiveButton = -1;
    this.buttons = [0, 1, 2];
  }
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    const engine = this.camera.getEngine();
    const element = engine.getInputElement();
    let previousPinchSquaredDistance = 0;
    let previousMultiTouchPanPosition = null;
    this._pointA = null;
    this._pointB = null;
    this._altKey = false;
    this._ctrlKey = false;
    this._metaKey = false;
    this._shiftKey = false;
    this._buttonsPressed = 0;
    this._pointerInput = (p) => {
      const evt = p.event;
      const isTouch = evt.pointerType === "touch";
      if (engine.isInVRExclusivePointerMode) {
        return;
      }
      if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {
        return;
      }
      const srcElement = evt.target;
      this._altKey = evt.altKey;
      this._ctrlKey = evt.ctrlKey;
      this._metaKey = evt.metaKey;
      this._shiftKey = evt.shiftKey;
      this._buttonsPressed = evt.buttons;
      if (engine.isPointerLock) {
        const offsetX = evt.movementX;
        const offsetY = evt.movementY;
        this.onTouch(null, offsetX, offsetY);
        this._pointA = null;
        this._pointB = null;
      } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentActiveButton === -1 || isTouch)) {
        try {
          srcElement === null || srcElement === void 0 ? void 0 : srcElement.setPointerCapture(evt.pointerId);
        } catch (e) {
        }
        if (this._pointA === null) {
          this._pointA = {
            x: evt.clientX,
            y: evt.clientY,
            pointerId: evt.pointerId,
            type: evt.pointerType
          };
        } else if (this._pointB === null) {
          this._pointB = {
            x: evt.clientX,
            y: evt.clientY,
            pointerId: evt.pointerId,
            type: evt.pointerType
          };
        }
        if (this._currentActiveButton === -1 && !isTouch) {
          this._currentActiveButton = evt.button;
        }
        this.onButtonDown(evt);
        if (!noPreventDefault) {
          evt.preventDefault();
          element && element.focus();
        }
      } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {
        this.onDoubleTap(evt.pointerType);
      } else if (p.type === PointerEventTypes.POINTERUP && (this._currentActiveButton === evt.button || isTouch)) {
        try {
          srcElement === null || srcElement === void 0 ? void 0 : srcElement.releasePointerCapture(evt.pointerId);
        } catch (e) {
        }
        if (!isTouch) {
          this._pointB = null;
        }
        if (engine._badOS) {
          this._pointA = this._pointB = null;
        } else {
          if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {
            this._pointA = this._pointB;
            this._pointB = null;
          } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {
            this._pointB = null;
          } else {
            this._pointA = this._pointB = null;
          }
        }
        if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {
          this.onMultiTouch(
            this._pointA,
            this._pointB,
            previousPinchSquaredDistance,
            0,
            previousMultiTouchPanPosition,
            null
          );
          previousPinchSquaredDistance = 0;
          previousMultiTouchPanPosition = null;
        }
        this._currentActiveButton = -1;
        this.onButtonUp(evt);
        if (!noPreventDefault) {
          evt.preventDefault();
        }
      } else if (p.type === PointerEventTypes.POINTERMOVE) {
        if (!noPreventDefault) {
          evt.preventDefault();
        }
        if (this._pointA && this._pointB === null) {
          const offsetX = evt.clientX - this._pointA.x;
          const offsetY = evt.clientY - this._pointA.y;
          this.onTouch(this._pointA, offsetX, offsetY);
          this._pointA.x = evt.clientX;
          this._pointA.y = evt.clientY;
        } else if (this._pointA && this._pointB) {
          const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;
          ed.x = evt.clientX;
          ed.y = evt.clientY;
          const distX = this._pointA.x - this._pointB.x;
          const distY = this._pointA.y - this._pointB.y;
          const pinchSquaredDistance = distX * distX + distY * distY;
          const multiTouchPanPosition = {
            x: (this._pointA.x + this._pointB.x) / 2,
            y: (this._pointA.y + this._pointB.y) / 2,
            pointerId: evt.pointerId,
            type: p.type
          };
          this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);
          previousMultiTouchPanPosition = multiTouchPanPosition;
          previousPinchSquaredDistance = pinchSquaredDistance;
        }
      }
    };
    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP);
    this._onLostFocus = () => {
      this._pointA = this._pointB = null;
      previousPinchSquaredDistance = 0;
      previousMultiTouchPanPosition = null;
      this.onLostFocus();
    };
    this._contextMenuBind = this.onContextMenu.bind(this);
    element && element.addEventListener("contextmenu", this._contextMenuBind, false);
    const hostWindow = this.camera.getScene().getEngine().getHostWindow();
    if (hostWindow) {
      Tools.RegisterTopRootEvents(hostWindow, [{ name: "blur", handler: this._onLostFocus }]);
    }
  }
  detachControl() {
    if (this._onLostFocus) {
      const hostWindow = this.camera.getScene().getEngine().getHostWindow();
      if (hostWindow) {
        Tools.UnregisterTopRootEvents(hostWindow, [{ name: "blur", handler: this._onLostFocus }]);
      }
    }
    if (this._observer) {
      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
      this._observer = null;
      if (this._contextMenuBind) {
        const inputElement = this.camera.getScene().getEngine().getInputElement();
        inputElement && inputElement.removeEventListener("contextmenu", this._contextMenuBind);
      }
      this._onLostFocus = null;
    }
    this._altKey = false;
    this._ctrlKey = false;
    this._metaKey = false;
    this._shiftKey = false;
    this._buttonsPressed = 0;
    this._currentActiveButton = -1;
  }
  getClassName() {
    return "BaseCameraPointersInput";
  }
  getSimpleName() {
    return "pointers";
  }
  onDoubleTap(type) {
  }
  onTouch(point, offsetX, offsetY) {
  }
  onMultiTouch(_pointA, _pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
  }
  onContextMenu(evt) {
    evt.preventDefault();
  }
  onButtonDown(evt) {
  }
  onButtonUp(evt) {
  }
  onLostFocus() {
  }
};
__decorate([
  serialize()
], BaseCameraPointersInput.prototype, "buttons", void 0);

// node_modules/@babylonjs/core/Gamepads/gamepad.js
var StickValues = class {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
};
var Gamepad = class {
  constructor(id, index, browserGamepad, leftStickX = 0, leftStickY = 1, rightStickX = 2, rightStickY = 3) {
    this.id = id;
    this.index = index;
    this.browserGamepad = browserGamepad;
    this._leftStick = { x: 0, y: 0 };
    this._rightStick = { x: 0, y: 0 };
    this._isConnected = true;
    this._invertLeftStickY = false;
    this.type = Gamepad.GAMEPAD;
    this._leftStickAxisX = leftStickX;
    this._leftStickAxisY = leftStickY;
    this._rightStickAxisX = rightStickX;
    this._rightStickAxisY = rightStickY;
    if (this.browserGamepad.axes.length >= 2) {
      this._leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };
    }
    if (this.browserGamepad.axes.length >= 4) {
      this._rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };
    }
  }
  get isConnected() {
    return this._isConnected;
  }
  onleftstickchanged(callback) {
    this._onleftstickchanged = callback;
  }
  onrightstickchanged(callback) {
    this._onrightstickchanged = callback;
  }
  get leftStick() {
    return this._leftStick;
  }
  set leftStick(newValues) {
    if (this._onleftstickchanged && (this._leftStick.x !== newValues.x || this._leftStick.y !== newValues.y)) {
      this._onleftstickchanged(newValues);
    }
    this._leftStick = newValues;
  }
  get rightStick() {
    return this._rightStick;
  }
  set rightStick(newValues) {
    if (this._onrightstickchanged && (this._rightStick.x !== newValues.x || this._rightStick.y !== newValues.y)) {
      this._onrightstickchanged(newValues);
    }
    this._rightStick = newValues;
  }
  update() {
    if (this._leftStick) {
      this.leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };
      if (this._invertLeftStickY) {
        this.leftStick.y *= -1;
      }
    }
    if (this._rightStick) {
      this.rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };
    }
  }
  dispose() {
  }
};
Gamepad.GAMEPAD = 0;
Gamepad.GENERIC = 1;
Gamepad.XBOX = 2;
Gamepad.POSE_ENABLED = 3;
Gamepad.DUALSHOCK = 4;
var GenericPad = class extends Gamepad {
  constructor(id, index, browserGamepad) {
    super(id, index, browserGamepad);
    this.onButtonDownObservable = new Observable();
    this.onButtonUpObservable = new Observable();
    this.type = Gamepad.GENERIC;
    this._buttons = new Array(browserGamepad.buttons.length);
  }
  onbuttondown(callback) {
    this._onbuttondown = callback;
  }
  onbuttonup(callback) {
    this._onbuttonup = callback;
  }
  _setButtonValue(newValue, currentValue, buttonIndex) {
    if (newValue !== currentValue) {
      if (newValue === 1) {
        if (this._onbuttondown) {
          this._onbuttondown(buttonIndex);
        }
        this.onButtonDownObservable.notifyObservers(buttonIndex);
      }
      if (newValue === 0) {
        if (this._onbuttonup) {
          this._onbuttonup(buttonIndex);
        }
        this.onButtonUpObservable.notifyObservers(buttonIndex);
      }
    }
    return newValue;
  }
  update() {
    super.update();
    for (let index = 0; index < this._buttons.length; index++) {
      this._buttons[index] = this._setButtonValue(this.browserGamepad.buttons[index].value, this._buttons[index], index);
    }
  }
  dispose() {
    super.dispose();
    this.onButtonDownObservable.clear();
    this.onButtonUpObservable.clear();
  }
};

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraGamepadInput.js
var ArcRotateCameraGamepadInput = class {
  constructor() {
    this.gamepadRotationSensibility = 80;
    this.gamepadMoveSensibility = 40;
    this._yAxisScale = 1;
  }
  get invertYAxis() {
    return this._yAxisScale !== 1;
  }
  set invertYAxis(value) {
    this._yAxisScale = value ? -1 : 1;
  }
  attachControl() {
    const manager = this.camera.getScene().gamepadManager;
    this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {
      if (gamepad.type !== Gamepad.POSE_ENABLED) {
        if (!this.gamepad || gamepad.type === Gamepad.XBOX) {
          this.gamepad = gamepad;
        }
      }
    });
    this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {
      if (this.gamepad === gamepad) {
        this.gamepad = null;
      }
    });
    this.gamepad = manager.getGamepadByType(Gamepad.XBOX);
  }
  detachControl() {
    this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);
    this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);
    this.gamepad = null;
  }
  checkInputs() {
    if (this.gamepad) {
      const camera = this.camera;
      const rsValues = this.gamepad.rightStick;
      if (rsValues) {
        if (rsValues.x != 0) {
          const normalizedRX = rsValues.x / this.gamepadRotationSensibility;
          if (normalizedRX != 0 && Math.abs(normalizedRX) > 5e-3) {
            camera.inertialAlphaOffset += normalizedRX;
          }
        }
        if (rsValues.y != 0) {
          const normalizedRY = rsValues.y / this.gamepadRotationSensibility * this._yAxisScale;
          if (normalizedRY != 0 && Math.abs(normalizedRY) > 5e-3) {
            camera.inertialBetaOffset += normalizedRY;
          }
        }
      }
      const lsValues = this.gamepad.leftStick;
      if (lsValues && lsValues.y != 0) {
        const normalizedLY = lsValues.y / this.gamepadMoveSensibility;
        if (normalizedLY != 0 && Math.abs(normalizedLY) > 5e-3) {
          this.camera.inertialRadiusOffset -= normalizedLY;
        }
      }
    }
  }
  getClassName() {
    return "ArcRotateCameraGamepadInput";
  }
  getSimpleName() {
    return "gamepad";
  }
};
__decorate([
  serialize()
], ArcRotateCameraGamepadInput.prototype, "gamepadRotationSensibility", void 0);
__decorate([
  serialize()
], ArcRotateCameraGamepadInput.prototype, "gamepadMoveSensibility", void 0);
CameraInputTypes["ArcRotateCameraGamepadInput"] = ArcRotateCameraGamepadInput;

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.js
var ArcRotateCameraKeyboardMoveInput = class {
  constructor() {
    this.keysUp = [38];
    this.keysDown = [40];
    this.keysLeft = [37];
    this.keysRight = [39];
    this.keysReset = [220];
    this.panningSensibility = 50;
    this.zoomingSensibility = 25;
    this.useAltToZoom = true;
    this.angularSpeed = 0.01;
    this._keys = new Array();
  }
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    if (this._onCanvasBlurObserver) {
      return;
    }
    this._scene = this.camera.getScene();
    this._engine = this._scene.getEngine();
    this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {
      this._keys.length = 0;
    });
    this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {
      const evt = info.event;
      if (!evt.metaKey) {
        if (info.type === KeyboardEventTypes.KEYDOWN) {
          this._ctrlPressed = evt.ctrlKey;
          this._altPressed = evt.altKey;
          if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysReset.indexOf(evt.keyCode) !== -1) {
            const index = this._keys.indexOf(evt.keyCode);
            if (index === -1) {
              this._keys.push(evt.keyCode);
            }
            if (evt.preventDefault) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
            }
          }
        } else {
          if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysReset.indexOf(evt.keyCode) !== -1) {
            const index = this._keys.indexOf(evt.keyCode);
            if (index >= 0) {
              this._keys.splice(index, 1);
            }
            if (evt.preventDefault) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
            }
          }
        }
      }
    });
  }
  detachControl() {
    if (this._scene) {
      if (this._onKeyboardObserver) {
        this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
      }
      if (this._onCanvasBlurObserver) {
        this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
      }
      this._onKeyboardObserver = null;
      this._onCanvasBlurObserver = null;
    }
    this._keys.length = 0;
  }
  checkInputs() {
    if (this._onKeyboardObserver) {
      const camera = this.camera;
      for (let index = 0; index < this._keys.length; index++) {
        const keyCode = this._keys[index];
        if (this.keysLeft.indexOf(keyCode) !== -1) {
          if (this._ctrlPressed && this.camera._useCtrlForPanning) {
            camera.inertialPanningX -= 1 / this.panningSensibility;
          } else {
            camera.inertialAlphaOffset -= this.angularSpeed;
          }
        } else if (this.keysUp.indexOf(keyCode) !== -1) {
          if (this._ctrlPressed && this.camera._useCtrlForPanning) {
            camera.inertialPanningY += 1 / this.panningSensibility;
          } else if (this._altPressed && this.useAltToZoom) {
            camera.inertialRadiusOffset += 1 / this.zoomingSensibility;
          } else {
            camera.inertialBetaOffset -= this.angularSpeed;
          }
        } else if (this.keysRight.indexOf(keyCode) !== -1) {
          if (this._ctrlPressed && this.camera._useCtrlForPanning) {
            camera.inertialPanningX += 1 / this.panningSensibility;
          } else {
            camera.inertialAlphaOffset += this.angularSpeed;
          }
        } else if (this.keysDown.indexOf(keyCode) !== -1) {
          if (this._ctrlPressed && this.camera._useCtrlForPanning) {
            camera.inertialPanningY -= 1 / this.panningSensibility;
          } else if (this._altPressed && this.useAltToZoom) {
            camera.inertialRadiusOffset -= 1 / this.zoomingSensibility;
          } else {
            camera.inertialBetaOffset += this.angularSpeed;
          }
        } else if (this.keysReset.indexOf(keyCode) !== -1) {
          if (camera.useInputToRestoreState) {
            camera.restoreState();
          }
        }
      }
    }
  }
  getClassName() {
    return "ArcRotateCameraKeyboardMoveInput";
  }
  getSimpleName() {
    return "keyboard";
  }
};
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "keysUp", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "keysDown", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "keysLeft", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "keysRight", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "keysReset", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "panningSensibility", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "zoomingSensibility", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "useAltToZoom", void 0);
__decorate([
  serialize()
], ArcRotateCameraKeyboardMoveInput.prototype, "angularSpeed", void 0);
CameraInputTypes["ArcRotateCameraKeyboardMoveInput"] = ArcRotateCameraKeyboardMoveInput;

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraMouseWheelInput.js
var ffMultiplier = 40;
var ArcRotateCameraMouseWheelInput = class {
  constructor() {
    this.wheelPrecision = 3;
    this.zoomToMouseLocation = false;
    this.wheelDeltaPercentage = 0;
    this.customComputeDeltaFromMouseWheel = null;
    this._inertialPanning = Vector3.Zero();
  }
  _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta, radius) {
    let delta = 0;
    const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;
    if (mouseWheelDelta > 0) {
      delta = wheelDelta / (1 + this.wheelDeltaPercentage);
    } else {
      delta = wheelDelta * (1 + this.wheelDeltaPercentage);
    }
    return delta;
  }
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this._wheel = (p) => {
      if (p.type !== PointerEventTypes.POINTERWHEEL) {
        return;
      }
      const event = p.event;
      let delta = 0;
      const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1;
      const wheelDelta = -(event.deltaY * platformScale);
      if (this.customComputeDeltaFromMouseWheel) {
        delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);
      } else {
        if (this.wheelDeltaPercentage) {
          delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);
          if (delta > 0) {
            let estimatedTargetRadius = this.camera.radius;
            let targetInertia = this.camera.inertialRadiusOffset + delta;
            for (let i = 0; i < 20 && Math.abs(targetInertia) > 1e-3; i++) {
              estimatedTargetRadius -= targetInertia;
              targetInertia *= this.camera.inertia;
            }
            estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);
            delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);
          }
        } else {
          delta = wheelDelta / (this.wheelPrecision * 40);
        }
      }
      if (delta) {
        if (this.zoomToMouseLocation && this._hitPlane) {
          this._zoomToMouse(delta);
        } else {
          this.camera.inertialRadiusOffset += delta;
        }
      }
      if (event.preventDefault) {
        if (!noPreventDefault) {
          event.preventDefault();
        }
      }
    };
    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);
    if (this.zoomToMouseLocation) {
      this._inertialPanning.setAll(0);
    }
  }
  detachControl() {
    if (this._observer) {
      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
      this._observer = null;
      this._wheel = null;
    }
  }
  checkInputs() {
    if (!this.zoomToMouseLocation) {
      return;
    }
    const camera = this.camera;
    const motion = 0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;
    if (motion) {
      this._updateHitPlane();
      camera.target.addInPlace(this._inertialPanning);
      this._inertialPanning.scaleInPlace(camera.inertia);
      this._zeroIfClose(this._inertialPanning);
    }
  }
  getClassName() {
    return "ArcRotateCameraMouseWheelInput";
  }
  getSimpleName() {
    return "mousewheel";
  }
  _updateHitPlane() {
    const camera = this.camera;
    const direction = camera.target.subtract(camera.position);
    this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);
  }
  _getPosition() {
    var _a;
    const camera = this.camera;
    const scene = camera.getScene();
    const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);
    let distance = 0;
    if (this._hitPlane) {
      distance = (_a = ray.intersectsPlane(this._hitPlane)) !== null && _a !== void 0 ? _a : 0;
    }
    return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));
  }
  _zoomToMouse(delta) {
    var _a, _b;
    const camera = this.camera;
    const inertiaComp = 1 - camera.inertia;
    if (camera.lowerRadiusLimit) {
      const lowerLimit = (_a = camera.lowerRadiusLimit) !== null && _a !== void 0 ? _a : 0;
      if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {
        delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;
      }
    }
    if (camera.upperRadiusLimit) {
      const upperLimit = (_b = camera.upperRadiusLimit) !== null && _b !== void 0 ? _b : 0;
      if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {
        delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;
      }
    }
    const zoomDistance = delta / inertiaComp;
    const ratio = zoomDistance / camera.radius;
    const vec = this._getPosition();
    const directionToZoomLocation = TmpVectors.Vector3[6];
    vec.subtractToRef(camera.target, directionToZoomLocation);
    directionToZoomLocation.scaleInPlace(ratio);
    directionToZoomLocation.scaleInPlace(inertiaComp);
    this._inertialPanning.addInPlace(directionToZoomLocation);
    camera.inertialRadiusOffset += delta;
  }
  _zeroIfClose(vec) {
    if (Math.abs(vec.x) < Epsilon) {
      vec.x = 0;
    }
    if (Math.abs(vec.y) < Epsilon) {
      vec.y = 0;
    }
    if (Math.abs(vec.z) < Epsilon) {
      vec.z = 0;
    }
  }
};
__decorate([
  serialize()
], ArcRotateCameraMouseWheelInput.prototype, "wheelPrecision", void 0);
__decorate([
  serialize()
], ArcRotateCameraMouseWheelInput.prototype, "zoomToMouseLocation", void 0);
__decorate([
  serialize()
], ArcRotateCameraMouseWheelInput.prototype, "wheelDeltaPercentage", void 0);
CameraInputTypes["ArcRotateCameraMouseWheelInput"] = ArcRotateCameraMouseWheelInput;

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraPointersInput.js
var ArcRotateCameraPointersInput = class extends BaseCameraPointersInput {
  constructor() {
    super(...arguments);
    this.buttons = [0, 1, 2];
    this.angularSensibilityX = 1e3;
    this.angularSensibilityY = 1e3;
    this.pinchPrecision = 12;
    this.pinchDeltaPercentage = 0;
    this.useNaturalPinchZoom = false;
    this.pinchZoom = true;
    this.panningSensibility = 1e3;
    this.multiTouchPanning = true;
    this.multiTouchPanAndZoom = true;
    this.pinchInwards = true;
    this._isPanClick = false;
    this._twoFingerActivityCount = 0;
    this._isPinching = false;
  }
  getClassName() {
    return "ArcRotateCameraPointersInput";
  }
  _computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition) {
    if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {
      const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;
      const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;
      this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;
      this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;
    }
  }
  _computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance) {
    const radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;
    if (this.useNaturalPinchZoom) {
      this.camera.radius = radius * Math.sqrt(previousPinchSquaredDistance) / Math.sqrt(pinchSquaredDistance);
    } else if (this.pinchDeltaPercentage) {
      this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 1e-3 * radius * this.pinchDeltaPercentage;
    } else {
      this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY) / 2);
    }
  }
  onTouch(point, offsetX, offsetY) {
    if (this.panningSensibility !== 0 && (this._ctrlKey && this.camera._useCtrlForPanning || this._isPanClick)) {
      this.camera.inertialPanningX += -offsetX / this.panningSensibility;
      this.camera.inertialPanningY += offsetY / this.panningSensibility;
    } else {
      this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;
      this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;
    }
  }
  onDoubleTap() {
    if (this.camera.useInputToRestoreState) {
      this.camera.restoreState();
    }
  }
  onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
    if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {
      return;
    }
    if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {
      return;
    }
    if (this.multiTouchPanAndZoom) {
      this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);
      this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);
    } else if (this.multiTouchPanning && this.pinchZoom) {
      this._twoFingerActivityCount++;
      if (this._isPinching || this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance) {
        this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);
        this._isPinching = true;
      } else {
        this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);
      }
    } else if (this.multiTouchPanning) {
      this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);
    } else if (this.pinchZoom) {
      this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);
    }
  }
  onButtonDown(evt) {
    this._isPanClick = evt.button === this.camera._panningMouseButton;
  }
  onButtonUp() {
    this._twoFingerActivityCount = 0;
    this._isPinching = false;
  }
  onLostFocus() {
    this._isPanClick = false;
    this._twoFingerActivityCount = 0;
    this._isPinching = false;
  }
};
ArcRotateCameraPointersInput.MinimumRadiusForPinch = 1e-3;
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "buttons", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "angularSensibilityX", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "angularSensibilityY", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "pinchPrecision", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "pinchDeltaPercentage", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "useNaturalPinchZoom", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "pinchZoom", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "panningSensibility", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "multiTouchPanning", void 0);
__decorate([
  serialize()
], ArcRotateCameraPointersInput.prototype, "multiTouchPanAndZoom", void 0);
CameraInputTypes["ArcRotateCameraPointersInput"] = ArcRotateCameraPointersInput;

// node_modules/@babylonjs/core/Cameras/arcRotateCameraInputsManager.js
var ArcRotateCameraInputsManager = class extends CameraInputsManager {
  constructor(camera) {
    super(camera);
  }
  addMouseWheel() {
    this.add(new ArcRotateCameraMouseWheelInput());
    return this;
  }
  addPointers() {
    this.add(new ArcRotateCameraPointersInput());
    return this;
  }
  addKeyboard() {
    this.add(new ArcRotateCameraKeyboardMoveInput());
    return this;
  }
};

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraVRDeviceOrientationInput.js
ArcRotateCameraInputsManager.prototype.addVRDeviceOrientation = function() {
  this.add(new ArcRotateCameraVRDeviceOrientationInput());
  return this;
};
var ArcRotateCameraVRDeviceOrientationInput = class {
  constructor() {
    this.alphaCorrection = 1;
    this.gammaCorrection = 1;
    this._alpha = 0;
    this._gamma = 0;
    this._dirty = false;
    this._deviceOrientationHandler = this._onOrientationEvent.bind(this);
  }
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this.camera.attachControl(noPreventDefault);
    const hostWindow = this.camera.getScene().getEngine().getHostWindow();
    if (hostWindow) {
      if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
        DeviceOrientationEvent.requestPermission().then((response) => {
          if (response === "granted") {
            hostWindow.addEventListener("deviceorientation", this._deviceOrientationHandler);
          } else {
            Tools.Warn("Permission not granted.");
          }
        }).catch((error) => {
          Tools.Error(error);
        });
      } else {
        hostWindow.addEventListener("deviceorientation", this._deviceOrientationHandler);
      }
    }
  }
  _onOrientationEvent(evt) {
    if (evt.alpha !== null) {
      this._alpha = (+evt.alpha | 0) * this.alphaCorrection;
    }
    if (evt.gamma !== null) {
      this._gamma = (+evt.gamma | 0) * this.gammaCorrection;
    }
    this._dirty = true;
  }
  checkInputs() {
    if (this._dirty) {
      this._dirty = false;
      if (this._gamma < 0) {
        this._gamma = 180 + this._gamma;
      }
      this.camera.alpha = -this._alpha / 180 * Math.PI % Math.PI * 2;
      this.camera.beta = this._gamma / 180 * Math.PI;
    }
  }
  detachControl() {
    window.removeEventListener("deviceorientation", this._deviceOrientationHandler);
  }
  getClassName() {
    return "ArcRotateCameraVRDeviceOrientationInput";
  }
  getSimpleName() {
    return "VRDeviceOrientation";
  }
};
CameraInputTypes["ArcRotateCameraVRDeviceOrientationInput"] = ArcRotateCameraVRDeviceOrientationInput;

// node_modules/@babylonjs/core/Cameras/Inputs/flyCameraKeyboardInput.js
var FlyCameraKeyboardInput = class {
  constructor() {
    this.keysForward = [87];
    this.keysBackward = [83];
    this.keysUp = [69];
    this.keysDown = [81];
    this.keysRight = [68];
    this.keysLeft = [65];
    this._keys = new Array();
  }
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    if (this._onCanvasBlurObserver) {
      return;
    }
    this._scene = this.camera.getScene();
    this._engine = this._scene.getEngine();
    this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {
      this._keys.length = 0;
    });
    this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {
      const evt = info.event;
      if (info.type === KeyboardEventTypes.KEYDOWN) {
        if (this.keysForward.indexOf(evt.keyCode) !== -1 || this.keysBackward.indexOf(evt.keyCode) !== -1 || this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1) {
          const index = this._keys.indexOf(evt.keyCode);
          if (index === -1) {
            this._keys.push(evt.keyCode);
          }
          if (!noPreventDefault) {
            evt.preventDefault();
          }
        }
      } else {
        if (this.keysForward.indexOf(evt.keyCode) !== -1 || this.keysBackward.indexOf(evt.keyCode) !== -1 || this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1) {
          const index = this._keys.indexOf(evt.keyCode);
          if (index >= 0) {
            this._keys.splice(index, 1);
          }
          if (!noPreventDefault) {
            evt.preventDefault();
          }
        }
      }
    });
  }
  detachControl() {
    if (this._scene) {
      if (this._onKeyboardObserver) {
        this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
      }
      if (this._onCanvasBlurObserver) {
        this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
      }
      this._onKeyboardObserver = null;
      this._onCanvasBlurObserver = null;
    }
    this._keys.length = 0;
  }
  getClassName() {
    return "FlyCameraKeyboardInput";
  }
  _onLostFocus() {
    this._keys.length = 0;
  }
  getSimpleName() {
    return "keyboard";
  }
  checkInputs() {
    if (this._onKeyboardObserver) {
      const camera = this.camera;
      for (let index = 0; index < this._keys.length; index++) {
        const keyCode = this._keys[index];
        const speed = camera._computeLocalCameraSpeed();
        if (this.keysForward.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, speed);
        } else if (this.keysBackward.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, -speed);
        } else if (this.keysUp.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, speed, 0);
        } else if (this.keysDown.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, -speed, 0);
        } else if (this.keysRight.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(speed, 0, 0);
        } else if (this.keysLeft.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(-speed, 0, 0);
        }
        if (camera.getScene().useRightHandedSystem) {
          camera._localDirection.z *= -1;
        }
        camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);
        Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);
        camera.cameraDirection.addInPlace(camera._transformedDirection);
      }
    }
  }
};
__decorate([
  serialize()
], FlyCameraKeyboardInput.prototype, "keysForward", void 0);
__decorate([
  serialize()
], FlyCameraKeyboardInput.prototype, "keysBackward", void 0);
__decorate([
  serialize()
], FlyCameraKeyboardInput.prototype, "keysUp", void 0);
__decorate([
  serialize()
], FlyCameraKeyboardInput.prototype, "keysDown", void 0);
__decorate([
  serialize()
], FlyCameraKeyboardInput.prototype, "keysRight", void 0);
__decorate([
  serialize()
], FlyCameraKeyboardInput.prototype, "keysLeft", void 0);
CameraInputTypes["FlyCameraKeyboardInput"] = FlyCameraKeyboardInput;

// node_modules/@babylonjs/core/Cameras/Inputs/flyCameraMouseInput.js
var FlyCameraMouseInput = class {
  constructor() {
    this.buttons = [0, 1, 2];
    this.buttonsYaw = [-1, 0, 1];
    this.buttonsPitch = [-1, 0, 1];
    this.buttonsRoll = [2];
    this.activeButton = -1;
    this.angularSensibility = 1e3;
    this._previousPosition = null;
  }
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this._noPreventDefault = noPreventDefault;
    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver((p) => {
      this._pointerInput(p);
    }, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
    this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(() => {
      if (this.camera.rollCorrect) {
        this.camera.restoreRoll(this.camera.rollCorrect);
      }
    });
  }
  detachControl() {
    if (this._observer) {
      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
      this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);
      this._observer = null;
      this._rollObserver = null;
      this._previousPosition = null;
      this._noPreventDefault = void 0;
    }
  }
  getClassName() {
    return "FlyCameraMouseInput";
  }
  getSimpleName() {
    return "mouse";
  }
  _pointerInput(p) {
    const e = p.event;
    const camera = this.camera;
    const engine = camera.getEngine();
    if (engine.isInVRExclusivePointerMode) {
      return;
    }
    if (!this.touchEnabled && e.pointerType === "touch") {
      return;
    }
    if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {
      return;
    }
    const srcElement = e.target;
    if (p.type === PointerEventTypes.POINTERDOWN) {
      try {
        srcElement === null || srcElement === void 0 ? void 0 : srcElement.setPointerCapture(e.pointerId);
      } catch (e2) {
      }
      this._previousPosition = {
        x: e.clientX,
        y: e.clientY
      };
      this.activeButton = e.button;
      if (!this._noPreventDefault) {
        e.preventDefault();
        this._element.focus();
      }
      if (engine.isPointerLock) {
        this._onMouseMove(p.event);
      }
    } else if (p.type === PointerEventTypes.POINTERUP) {
      try {
        srcElement === null || srcElement === void 0 ? void 0 : srcElement.releasePointerCapture(e.pointerId);
      } catch (e2) {
      }
      this.activeButton = -1;
      this._previousPosition = null;
      if (!this._noPreventDefault) {
        e.preventDefault();
      }
    } else if (p.type === PointerEventTypes.POINTERMOVE) {
      if (!this._previousPosition) {
        if (engine.isPointerLock) {
          this._onMouseMove(p.event);
        }
        return;
      }
      const offsetX = e.clientX - this._previousPosition.x;
      const offsetY = e.clientY - this._previousPosition.y;
      this._rotateCamera(offsetX, offsetY);
      this._previousPosition = {
        x: e.clientX,
        y: e.clientY
      };
      if (!this._noPreventDefault) {
        e.preventDefault();
      }
    }
  }
  _onMouseMove(e) {
    const camera = this.camera;
    const engine = camera.getEngine();
    if (!engine.isPointerLock || engine.isInVRExclusivePointerMode) {
      return;
    }
    const offsetX = e.movementX;
    const offsetY = e.movementY;
    this._rotateCamera(offsetX, offsetY);
    this._previousPosition = null;
    if (!this._noPreventDefault) {
      e.preventDefault();
    }
  }
  _rotateCamera(offsetX, offsetY) {
    const camera = this.camera;
    const scene = this.camera.getScene();
    if (scene.useRightHandedSystem) {
      offsetX *= -1;
    }
    if (camera.parent && camera.parent._getWorldMatrixDeterminant() < 0) {
      offsetX *= -1;
    }
    const x = offsetX / this.angularSensibility;
    const y = offsetY / this.angularSensibility;
    const currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);
    let rotationChange;
    if (this.buttonsPitch.some((v) => {
      return v === this.activeButton;
    })) {
      rotationChange = Quaternion.RotationAxis(Axis.X, y);
      currentRotation.multiplyInPlace(rotationChange);
    }
    if (this.buttonsYaw.some((v) => {
      return v === this.activeButton;
    })) {
      rotationChange = Quaternion.RotationAxis(Axis.Y, x);
      currentRotation.multiplyInPlace(rotationChange);
      const limit = camera.bankedTurnLimit + camera._trackRoll;
      if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {
        const bankingDelta = camera.bankedTurnMultiplier * -x;
        rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta);
        currentRotation.multiplyInPlace(rotationChange);
      }
    }
    if (this.buttonsRoll.some((v) => {
      return v === this.activeButton;
    })) {
      rotationChange = Quaternion.RotationAxis(Axis.Z, -x);
      camera._trackRoll -= x;
      currentRotation.multiplyInPlace(rotationChange);
    }
    currentRotation.toEulerAnglesToRef(camera.rotation);
  }
};
__decorate([
  serialize()
], FlyCameraMouseInput.prototype, "buttons", void 0);
__decorate([
  serialize()
], FlyCameraMouseInput.prototype, "angularSensibility", void 0);
CameraInputTypes["FlyCameraMouseInput"] = FlyCameraMouseInput;

// node_modules/@babylonjs/core/Cameras/Inputs/followCameraKeyboardMoveInput.js
var FollowCameraKeyboardMoveInput = class {
  constructor() {
    this.keysHeightOffsetIncr = [38];
    this.keysHeightOffsetDecr = [40];
    this.keysHeightOffsetModifierAlt = false;
    this.keysHeightOffsetModifierCtrl = false;
    this.keysHeightOffsetModifierShift = false;
    this.keysRotationOffsetIncr = [37];
    this.keysRotationOffsetDecr = [39];
    this.keysRotationOffsetModifierAlt = false;
    this.keysRotationOffsetModifierCtrl = false;
    this.keysRotationOffsetModifierShift = false;
    this.keysRadiusIncr = [40];
    this.keysRadiusDecr = [38];
    this.keysRadiusModifierAlt = true;
    this.keysRadiusModifierCtrl = false;
    this.keysRadiusModifierShift = false;
    this.heightSensibility = 1;
    this.rotationSensibility = 1;
    this.radiusSensibility = 1;
    this._keys = new Array();
  }
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    if (this._onCanvasBlurObserver) {
      return;
    }
    this._scene = this.camera.getScene();
    this._engine = this._scene.getEngine();
    this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {
      this._keys.length = 0;
    });
    this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {
      const evt = info.event;
      if (!evt.metaKey) {
        if (info.type === KeyboardEventTypes.KEYDOWN) {
          this._ctrlPressed = evt.ctrlKey;
          this._altPressed = evt.altKey;
          this._shiftPressed = evt.shiftKey;
          if (this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 || this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 || this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 || this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 || this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 || this.keysRadiusDecr.indexOf(evt.keyCode) !== -1) {
            const index = this._keys.indexOf(evt.keyCode);
            if (index === -1) {
              this._keys.push(evt.keyCode);
            }
            if (evt.preventDefault) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
            }
          }
        } else {
          if (this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 || this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 || this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 || this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 || this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 || this.keysRadiusDecr.indexOf(evt.keyCode) !== -1) {
            const index = this._keys.indexOf(evt.keyCode);
            if (index >= 0) {
              this._keys.splice(index, 1);
            }
            if (evt.preventDefault) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
            }
          }
        }
      }
    });
  }
  detachControl() {
    if (this._scene) {
      if (this._onKeyboardObserver) {
        this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
      }
      if (this._onCanvasBlurObserver) {
        this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
      }
      this._onKeyboardObserver = null;
      this._onCanvasBlurObserver = null;
    }
    this._keys.length = 0;
  }
  checkInputs() {
    if (this._onKeyboardObserver) {
      this._keys.forEach((keyCode) => {
        if (this.keysHeightOffsetIncr.indexOf(keyCode) !== -1 && this._modifierHeightOffset()) {
          this.camera.heightOffset += this.heightSensibility;
        } else if (this.keysHeightOffsetDecr.indexOf(keyCode) !== -1 && this._modifierHeightOffset()) {
          this.camera.heightOffset -= this.heightSensibility;
        } else if (this.keysRotationOffsetIncr.indexOf(keyCode) !== -1 && this._modifierRotationOffset()) {
          this.camera.rotationOffset += this.rotationSensibility;
          this.camera.rotationOffset %= 360;
        } else if (this.keysRotationOffsetDecr.indexOf(keyCode) !== -1 && this._modifierRotationOffset()) {
          this.camera.rotationOffset -= this.rotationSensibility;
          this.camera.rotationOffset %= 360;
        } else if (this.keysRadiusIncr.indexOf(keyCode) !== -1 && this._modifierRadius()) {
          this.camera.radius += this.radiusSensibility;
        } else if (this.keysRadiusDecr.indexOf(keyCode) !== -1 && this._modifierRadius()) {
          this.camera.radius -= this.radiusSensibility;
        }
      });
    }
  }
  getClassName() {
    return "FollowCameraKeyboardMoveInput";
  }
  getSimpleName() {
    return "keyboard";
  }
  _modifierHeightOffset() {
    return this.keysHeightOffsetModifierAlt === this._altPressed && this.keysHeightOffsetModifierCtrl === this._ctrlPressed && this.keysHeightOffsetModifierShift === this._shiftPressed;
  }
  _modifierRotationOffset() {
    return this.keysRotationOffsetModifierAlt === this._altPressed && this.keysRotationOffsetModifierCtrl === this._ctrlPressed && this.keysRotationOffsetModifierShift === this._shiftPressed;
  }
  _modifierRadius() {
    return this.keysRadiusModifierAlt === this._altPressed && this.keysRadiusModifierCtrl === this._ctrlPressed && this.keysRadiusModifierShift === this._shiftPressed;
  }
};
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "keysHeightOffsetIncr", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "keysHeightOffsetDecr", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "keysHeightOffsetModifierAlt", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "keysHeightOffsetModifierCtrl", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "keysHeightOffsetModifierShift", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "keysRotationOffsetIncr", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "keysRotationOffsetDecr", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "keysRotationOffsetModifierAlt", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "keysRotationOffsetModifierCtrl", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "keysRotationOffsetModifierShift", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "keysRadiusIncr", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "keysRadiusDecr", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "keysRadiusModifierAlt", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "keysRadiusModifierCtrl", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "keysRadiusModifierShift", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "heightSensibility", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "rotationSensibility", void 0);
__decorate([
  serialize()
], FollowCameraKeyboardMoveInput.prototype, "radiusSensibility", void 0);
CameraInputTypes["FollowCameraKeyboardMoveInput"] = FollowCameraKeyboardMoveInput;

// node_modules/@babylonjs/core/Cameras/Inputs/followCameraMouseWheelInput.js
var FollowCameraMouseWheelInput = class {
  constructor() {
    this.axisControlRadius = true;
    this.axisControlHeight = false;
    this.axisControlRotation = false;
    this.wheelPrecision = 3;
    this.wheelDeltaPercentage = 0;
  }
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this._wheel = (p) => {
      if (p.type !== PointerEventTypes.POINTERWHEEL) {
        return;
      }
      const event = p.event;
      let delta = 0;
      const wheelDelta = Math.max(-1, Math.min(1, event.deltaY));
      if (this.wheelDeltaPercentage) {
        console.assert(this.axisControlRadius + this.axisControlHeight + this.axisControlRotation <= 1, "wheelDeltaPercentage only usable when mouse wheel controls ONE axis. Currently enabled: axisControlRadius: " + this.axisControlRadius + ", axisControlHeightOffset: " + this.axisControlHeight + ", axisControlRotationOffset: " + this.axisControlRotation);
        if (this.axisControlRadius) {
          delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.radius;
        } else if (this.axisControlHeight) {
          delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.heightOffset;
        } else if (this.axisControlRotation) {
          delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.rotationOffset;
        }
      } else {
        delta = wheelDelta * this.wheelPrecision;
      }
      if (delta) {
        if (this.axisControlRadius) {
          this.camera.radius += delta;
        } else if (this.axisControlHeight) {
          this.camera.heightOffset -= delta;
        } else if (this.axisControlRotation) {
          this.camera.rotationOffset -= delta;
        }
      }
      if (event.preventDefault) {
        if (!noPreventDefault) {
          event.preventDefault();
        }
      }
    };
    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);
  }
  detachControl() {
    if (this._observer) {
      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
      this._observer = null;
      this._wheel = null;
    }
  }
  getClassName() {
    return "ArcRotateCameraMouseWheelInput";
  }
  getSimpleName() {
    return "mousewheel";
  }
};
__decorate([
  serialize()
], FollowCameraMouseWheelInput.prototype, "axisControlRadius", void 0);
__decorate([
  serialize()
], FollowCameraMouseWheelInput.prototype, "axisControlHeight", void 0);
__decorate([
  serialize()
], FollowCameraMouseWheelInput.prototype, "axisControlRotation", void 0);
__decorate([
  serialize()
], FollowCameraMouseWheelInput.prototype, "wheelPrecision", void 0);
__decorate([
  serialize()
], FollowCameraMouseWheelInput.prototype, "wheelDeltaPercentage", void 0);
CameraInputTypes["FollowCameraMouseWheelInput"] = FollowCameraMouseWheelInput;

// node_modules/@babylonjs/core/Cameras/Inputs/followCameraPointersInput.js
var FollowCameraPointersInput = class extends BaseCameraPointersInput {
  constructor() {
    super(...arguments);
    this.angularSensibilityX = 1;
    this.angularSensibilityY = 1;
    this.pinchPrecision = 1e4;
    this.pinchDeltaPercentage = 0;
    this.axisXControlRadius = false;
    this.axisXControlHeight = false;
    this.axisXControlRotation = true;
    this.axisYControlRadius = false;
    this.axisYControlHeight = true;
    this.axisYControlRotation = false;
    this.axisPinchControlRadius = true;
    this.axisPinchControlHeight = false;
    this.axisPinchControlRotation = false;
    this.warningEnable = true;
    this._warningCounter = 0;
  }
  getClassName() {
    return "FollowCameraPointersInput";
  }
  onTouch(pointA, offsetX, offsetY) {
    this._warning();
    if (this.axisXControlRotation) {
      this.camera.rotationOffset += offsetX / this.angularSensibilityX;
    } else if (this.axisYControlRotation) {
      this.camera.rotationOffset += offsetY / this.angularSensibilityX;
    }
    if (this.axisXControlHeight) {
      this.camera.heightOffset += offsetX / this.angularSensibilityY;
    } else if (this.axisYControlHeight) {
      this.camera.heightOffset += offsetY / this.angularSensibilityY;
    }
    if (this.axisXControlRadius) {
      this.camera.radius -= offsetX / this.angularSensibilityY;
    } else if (this.axisYControlRadius) {
      this.camera.radius -= offsetY / this.angularSensibilityY;
    }
  }
  onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
    if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {
      return;
    }
    if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {
      return;
    }
    let pinchDelta = (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * (this.angularSensibilityX + this.angularSensibilityY) / 2);
    if (this.pinchDeltaPercentage) {
      pinchDelta *= 0.01 * this.pinchDeltaPercentage;
      if (this.axisPinchControlRotation) {
        this.camera.rotationOffset += pinchDelta * this.camera.rotationOffset;
      }
      if (this.axisPinchControlHeight) {
        this.camera.heightOffset += pinchDelta * this.camera.heightOffset;
      }
      if (this.axisPinchControlRadius) {
        this.camera.radius -= pinchDelta * this.camera.radius;
      }
    } else {
      if (this.axisPinchControlRotation) {
        this.camera.rotationOffset += pinchDelta;
      }
      if (this.axisPinchControlHeight) {
        this.camera.heightOffset += pinchDelta;
      }
      if (this.axisPinchControlRadius) {
        this.camera.radius -= pinchDelta;
      }
    }
  }
  _warning() {
    if (!this.warningEnable || this._warningCounter++ % 100 !== 0) {
      return;
    }
    const warn = "It probably only makes sense to control ONE camera property with each pointer axis. Set 'warningEnable = false' if you are sure. Currently enabled: ";
    console.assert(this.axisXControlRotation + this.axisXControlHeight + this.axisXControlRadius <= 1, warn + "axisXControlRotation: " + this.axisXControlRotation + ", axisXControlHeight: " + this.axisXControlHeight + ", axisXControlRadius: " + this.axisXControlRadius);
    console.assert(this.axisYControlRotation + this.axisYControlHeight + this.axisYControlRadius <= 1, warn + "axisYControlRotation: " + this.axisYControlRotation + ", axisYControlHeight: " + this.axisYControlHeight + ", axisYControlRadius: " + this.axisYControlRadius);
    console.assert(this.axisPinchControlRotation + this.axisPinchControlHeight + this.axisPinchControlRadius <= 1, warn + "axisPinchControlRotation: " + this.axisPinchControlRotation + ", axisPinchControlHeight: " + this.axisPinchControlHeight + ", axisPinchControlRadius: " + this.axisPinchControlRadius);
  }
};
__decorate([
  serialize()
], FollowCameraPointersInput.prototype, "angularSensibilityX", void 0);
__decorate([
  serialize()
], FollowCameraPointersInput.prototype, "angularSensibilityY", void 0);
__decorate([
  serialize()
], FollowCameraPointersInput.prototype, "pinchPrecision", void 0);
__decorate([
  serialize()
], FollowCameraPointersInput.prototype, "pinchDeltaPercentage", void 0);
__decorate([
  serialize()
], FollowCameraPointersInput.prototype, "axisXControlRadius", void 0);
__decorate([
  serialize()
], FollowCameraPointersInput.prototype, "axisXControlHeight", void 0);
__decorate([
  serialize()
], FollowCameraPointersInput.prototype, "axisXControlRotation", void 0);
__decorate([
  serialize()
], FollowCameraPointersInput.prototype, "axisYControlRadius", void 0);
__decorate([
  serialize()
], FollowCameraPointersInput.prototype, "axisYControlHeight", void 0);
__decorate([
  serialize()
], FollowCameraPointersInput.prototype, "axisYControlRotation", void 0);
__decorate([
  serialize()
], FollowCameraPointersInput.prototype, "axisPinchControlRadius", void 0);
__decorate([
  serialize()
], FollowCameraPointersInput.prototype, "axisPinchControlHeight", void 0);
__decorate([
  serialize()
], FollowCameraPointersInput.prototype, "axisPinchControlRotation", void 0);
CameraInputTypes["FollowCameraPointersInput"] = FollowCameraPointersInput;

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraDeviceOrientationInput.js
FreeCameraInputsManager.prototype.addDeviceOrientation = function(smoothFactor) {
  if (!this._deviceOrientationInput) {
    this._deviceOrientationInput = new FreeCameraDeviceOrientationInput();
    if (smoothFactor) {
      this._deviceOrientationInput.smoothFactor = smoothFactor;
    }
    this.add(this._deviceOrientationInput);
  }
  return this;
};
var FreeCameraDeviceOrientationInput = class {
  constructor() {
    this._screenOrientationAngle = 0;
    this._screenQuaternion = new Quaternion();
    this._alpha = 0;
    this._beta = 0;
    this._gamma = 0;
    this.smoothFactor = 0;
    this._onDeviceOrientationChangedObservable = new Observable();
    this._orientationChanged = () => {
      this._screenOrientationAngle = window.orientation !== void 0 ? +window.orientation : window.screen.orientation && window.screen.orientation["angle"] ? window.screen.orientation.angle : 0;
      this._screenOrientationAngle = -Tools.ToRadians(this._screenOrientationAngle / 2);
      this._screenQuaternion.copyFromFloats(0, Math.sin(this._screenOrientationAngle), 0, Math.cos(this._screenOrientationAngle));
    };
    this._deviceOrientation = (evt) => {
      if (this.smoothFactor) {
        this._alpha = evt.alpha !== null ? Tools.SmoothAngleChange(this._alpha, evt.alpha, this.smoothFactor) : 0;
        this._beta = evt.beta !== null ? Tools.SmoothAngleChange(this._beta, evt.beta, this.smoothFactor) : 0;
        this._gamma = evt.gamma !== null ? Tools.SmoothAngleChange(this._gamma, evt.gamma, this.smoothFactor) : 0;
      } else {
        this._alpha = evt.alpha !== null ? evt.alpha : 0;
        this._beta = evt.beta !== null ? evt.beta : 0;
        this._gamma = evt.gamma !== null ? evt.gamma : 0;
      }
      if (evt.alpha !== null) {
        this._onDeviceOrientationChangedObservable.notifyObservers();
      }
    };
    this._constantTranform = new Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
    this._orientationChanged();
  }
  static WaitForOrientationChangeAsync(timeout) {
    return new Promise((res, rej) => {
      let gotValue = false;
      const eventHandler = () => {
        window.removeEventListener("deviceorientation", eventHandler);
        gotValue = true;
        res();
      };
      if (timeout) {
        setTimeout(() => {
          if (!gotValue) {
            window.removeEventListener("deviceorientation", eventHandler);
            rej("WaitForOrientationChangeAsync timed out");
          }
        }, timeout);
      }
      if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
        DeviceOrientationEvent.requestPermission().then((response) => {
          if (response == "granted") {
            window.addEventListener("deviceorientation", eventHandler);
          } else {
            Tools.Warn("Permission not granted.");
          }
        }).catch((error) => {
          Tools.Error(error);
        });
      } else {
        window.addEventListener("deviceorientation", eventHandler);
      }
    });
  }
  get camera() {
    return this._camera;
  }
  set camera(camera) {
    this._camera = camera;
    if (this._camera != null && !this._camera.rotationQuaternion) {
      this._camera.rotationQuaternion = new Quaternion();
    }
    if (this._camera) {
      this._camera.onDisposeObservable.add(() => {
        this._onDeviceOrientationChangedObservable.clear();
      });
    }
  }
  attachControl() {
    const hostWindow = this.camera.getScene().getEngine().getHostWindow();
    if (hostWindow) {
      const eventHandler = () => {
        hostWindow.addEventListener("orientationchange", this._orientationChanged);
        hostWindow.addEventListener("deviceorientation", this._deviceOrientation);
        this._orientationChanged();
      };
      if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
        DeviceOrientationEvent.requestPermission().then((response) => {
          if (response === "granted") {
            eventHandler();
          } else {
            Tools.Warn("Permission not granted.");
          }
        }).catch((error) => {
          Tools.Error(error);
        });
      } else {
        eventHandler();
      }
    }
  }
  detachControl() {
    window.removeEventListener("orientationchange", this._orientationChanged);
    window.removeEventListener("deviceorientation", this._deviceOrientation);
    this._alpha = 0;
  }
  checkInputs() {
    if (!this._alpha) {
      return;
    }
    Quaternion.RotationYawPitchRollToRef(Tools.ToRadians(this._alpha), Tools.ToRadians(this._beta), -Tools.ToRadians(this._gamma), this.camera.rotationQuaternion);
    this._camera.rotationQuaternion.multiplyInPlace(this._screenQuaternion);
    this._camera.rotationQuaternion.multiplyInPlace(this._constantTranform);
    this._camera.rotationQuaternion.z *= -1;
    this._camera.rotationQuaternion.w *= -1;
  }
  getClassName() {
    return "FreeCameraDeviceOrientationInput";
  }
  getSimpleName() {
    return "deviceOrientation";
  }
};
CameraInputTypes["FreeCameraDeviceOrientationInput"] = FreeCameraDeviceOrientationInput;

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraGamepadInput.js
var FreeCameraGamepadInput = class {
  constructor() {
    this.gamepadAngularSensibility = 200;
    this.gamepadMoveSensibility = 40;
    this.deadzoneDelta = 0.1;
    this._yAxisScale = 1;
    this._cameraTransform = Matrix.Identity();
    this._deltaTransform = Vector3.Zero();
    this._vector3 = Vector3.Zero();
    this._vector2 = Vector2.Zero();
  }
  get invertYAxis() {
    return this._yAxisScale !== 1;
  }
  set invertYAxis(value) {
    this._yAxisScale = value ? -1 : 1;
  }
  attachControl() {
    const manager = this.camera.getScene().gamepadManager;
    this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {
      if (gamepad.type !== Gamepad.POSE_ENABLED) {
        if (!this.gamepad || gamepad.type === Gamepad.XBOX) {
          this.gamepad = gamepad;
        }
      }
    });
    this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {
      if (this.gamepad === gamepad) {
        this.gamepad = null;
      }
    });
    this.gamepad = manager.getGamepadByType(Gamepad.XBOX);
    if (!this.gamepad && manager.gamepads.length) {
      this.gamepad = manager.gamepads[0];
    }
  }
  detachControl() {
    this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);
    this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);
    this.gamepad = null;
  }
  checkInputs() {
    if (this.gamepad && this.gamepad.leftStick) {
      const camera = this.camera;
      const lsValues = this.gamepad.leftStick;
      if (this.gamepadMoveSensibility !== 0) {
        lsValues.x = Math.abs(lsValues.x) > this.deadzoneDelta ? lsValues.x / this.gamepadMoveSensibility : 0;
        lsValues.y = Math.abs(lsValues.y) > this.deadzoneDelta ? lsValues.y / this.gamepadMoveSensibility : 0;
      }
      let rsValues = this.gamepad.rightStick;
      if (rsValues && this.gamepadAngularSensibility !== 0) {
        rsValues.x = Math.abs(rsValues.x) > this.deadzoneDelta ? rsValues.x / this.gamepadAngularSensibility : 0;
        rsValues.y = (Math.abs(rsValues.y) > this.deadzoneDelta ? rsValues.y / this.gamepadAngularSensibility : 0) * this._yAxisScale;
      } else {
        rsValues = { x: 0, y: 0 };
      }
      if (!camera.rotationQuaternion) {
        Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, this._cameraTransform);
      } else {
        camera.rotationQuaternion.toRotationMatrix(this._cameraTransform);
      }
      const speed = camera._computeLocalCameraSpeed() * 50;
      this._vector3.copyFromFloats(lsValues.x * speed, 0, -lsValues.y * speed);
      Vector3.TransformCoordinatesToRef(this._vector3, this._cameraTransform, this._deltaTransform);
      camera.cameraDirection.addInPlace(this._deltaTransform);
      this._vector2.copyFromFloats(rsValues.y, rsValues.x);
      camera.cameraRotation.addInPlace(this._vector2);
    }
  }
  getClassName() {
    return "FreeCameraGamepadInput";
  }
  getSimpleName() {
    return "gamepad";
  }
};
__decorate([
  serialize()
], FreeCameraGamepadInput.prototype, "gamepadAngularSensibility", void 0);
__decorate([
  serialize()
], FreeCameraGamepadInput.prototype, "gamepadMoveSensibility", void 0);
CameraInputTypes["FreeCameraGamepadInput"] = FreeCameraGamepadInput;

// node_modules/@babylonjs/core/Misc/virtualJoystick.js
var JoystickAxis;
(function(JoystickAxis2) {
  JoystickAxis2[JoystickAxis2["X"] = 0] = "X";
  JoystickAxis2[JoystickAxis2["Y"] = 1] = "Y";
  JoystickAxis2[JoystickAxis2["Z"] = 2] = "Z";
})(JoystickAxis || (JoystickAxis = {}));
var VirtualJoystick = class {
  constructor(leftJoystick, customizations) {
    this._released = false;
    const options = {
      ...VirtualJoystick._GetDefaultOptions(),
      ...customizations
    };
    if (leftJoystick) {
      this._leftJoystick = true;
    } else {
      this._leftJoystick = false;
    }
    VirtualJoystick._GlobalJoystickIndex++;
    this._axisTargetedByLeftAndRight = JoystickAxis.X;
    this._axisTargetedByUpAndDown = JoystickAxis.Y;
    this.reverseLeftRight = false;
    this.reverseUpDown = false;
    this._touches = new StringDictionary();
    this.deltaPosition = Vector3.Zero();
    this._joystickSensibility = 25;
    this._inversedSensibility = 1 / (this._joystickSensibility / 1e3);
    this._onResize = () => {
      VirtualJoystick._VJCanvasWidth = window.innerWidth;
      VirtualJoystick._VJCanvasHeight = window.innerHeight;
      if (VirtualJoystick.Canvas) {
        VirtualJoystick.Canvas.width = VirtualJoystick._VJCanvasWidth;
        VirtualJoystick.Canvas.height = VirtualJoystick._VJCanvasHeight;
      }
      VirtualJoystick._HalfWidth = VirtualJoystick._VJCanvasWidth / 2;
    };
    if (!VirtualJoystick.Canvas) {
      window.addEventListener("resize", this._onResize, false);
      VirtualJoystick.Canvas = document.createElement("canvas");
      VirtualJoystick._VJCanvasWidth = window.innerWidth;
      VirtualJoystick._VJCanvasHeight = window.innerHeight;
      VirtualJoystick.Canvas.width = window.innerWidth;
      VirtualJoystick.Canvas.height = window.innerHeight;
      VirtualJoystick.Canvas.style.width = "100%";
      VirtualJoystick.Canvas.style.height = "100%";
      VirtualJoystick.Canvas.style.position = "absolute";
      VirtualJoystick.Canvas.style.backgroundColor = "transparent";
      VirtualJoystick.Canvas.style.top = "0px";
      VirtualJoystick.Canvas.style.left = "0px";
      VirtualJoystick.Canvas.style.zIndex = "5";
      VirtualJoystick.Canvas.style.touchAction = "none";
      VirtualJoystick.Canvas.setAttribute("touch-action", "none");
      const context = VirtualJoystick.Canvas.getContext("2d");
      if (!context) {
        throw new Error("Unable to create canvas for virtual joystick");
      }
      VirtualJoystick._VJCanvasContext = context;
      VirtualJoystick._VJCanvasContext.strokeStyle = "#ffffff";
      VirtualJoystick._VJCanvasContext.lineWidth = 2;
      document.body.appendChild(VirtualJoystick.Canvas);
    }
    VirtualJoystick._HalfWidth = VirtualJoystick.Canvas.width / 2;
    this.pressed = false;
    this.limitToContainer = options.limitToContainer;
    this._joystickColor = options.color;
    this.containerSize = options.containerSize;
    this.puckSize = options.puckSize;
    if (options.position) {
      this.setPosition(options.position.x, options.position.y);
    }
    if (options.puckImage) {
      this.setPuckImage(options.puckImage);
    }
    if (options.containerImage) {
      this.setContainerImage(options.containerImage);
    }
    if (options.alwaysVisible) {
      VirtualJoystick._AlwaysVisibleSticks++;
    }
    this.alwaysVisible = options.alwaysVisible;
    this._joystickPointerId = -1;
    this._joystickPointerPos = new Vector2(0, 0);
    this._joystickPreviousPointerPos = new Vector2(0, 0);
    this._joystickPointerStartPos = new Vector2(0, 0);
    this._deltaJoystickVector = new Vector2(0, 0);
    this._onPointerDownHandlerRef = (evt) => {
      this._onPointerDown(evt);
    };
    this._onPointerMoveHandlerRef = (evt) => {
      this._onPointerMove(evt);
    };
    this._onPointerUpHandlerRef = (evt) => {
      this._onPointerUp(evt);
    };
    VirtualJoystick.Canvas.addEventListener("pointerdown", this._onPointerDownHandlerRef, false);
    VirtualJoystick.Canvas.addEventListener("pointermove", this._onPointerMoveHandlerRef, false);
    VirtualJoystick.Canvas.addEventListener("pointerup", this._onPointerUpHandlerRef, false);
    VirtualJoystick.Canvas.addEventListener("pointerout", this._onPointerUpHandlerRef, false);
    VirtualJoystick.Canvas.addEventListener("contextmenu", (evt) => {
      evt.preventDefault();
    }, false);
    requestAnimationFrame(() => {
      this._drawVirtualJoystick();
    });
  }
  static _GetDefaultOptions() {
    return {
      puckSize: 40,
      containerSize: 60,
      color: "cyan",
      puckImage: void 0,
      containerImage: void 0,
      position: void 0,
      alwaysVisible: false,
      limitToContainer: false
    };
  }
  setJoystickSensibility(newJoystickSensibility) {
    this._joystickSensibility = newJoystickSensibility;
    this._inversedSensibility = 1 / (this._joystickSensibility / 1e3);
  }
  _onPointerDown(e) {
    let positionOnScreenCondition;
    e.preventDefault();
    if (this._leftJoystick === true) {
      positionOnScreenCondition = e.clientX < VirtualJoystick._HalfWidth;
    } else {
      positionOnScreenCondition = e.clientX > VirtualJoystick._HalfWidth;
    }
    if (positionOnScreenCondition && this._joystickPointerId < 0) {
      this._joystickPointerId = e.pointerId;
      if (this._joystickPosition) {
        this._joystickPointerStartPos = this._joystickPosition.clone();
        this._joystickPointerPos = this._joystickPosition.clone();
        this._joystickPreviousPointerPos = this._joystickPosition.clone();
        this._onPointerMove(e);
      } else {
        this._joystickPointerStartPos.x = e.clientX;
        this._joystickPointerStartPos.y = e.clientY;
        this._joystickPointerPos = this._joystickPointerStartPos.clone();
        this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone();
      }
      this._deltaJoystickVector.x = 0;
      this._deltaJoystickVector.y = 0;
      this.pressed = true;
      this._touches.add(e.pointerId.toString(), e);
    } else {
      if (VirtualJoystick._GlobalJoystickIndex < 2 && this._action) {
        this._action();
        this._touches.add(e.pointerId.toString(), { x: e.clientX, y: e.clientY, prevX: e.clientX, prevY: e.clientY });
      }
    }
  }
  _onPointerMove(e) {
    if (this._joystickPointerId == e.pointerId) {
      if (this.limitToContainer) {
        const vector = new Vector2(e.clientX - this._joystickPointerStartPos.x, e.clientY - this._joystickPointerStartPos.y);
        const distance = vector.length();
        if (distance > this.containerSize) {
          vector.scaleInPlace(this.containerSize / distance);
        }
        this._joystickPointerPos.x = this._joystickPointerStartPos.x + vector.x;
        this._joystickPointerPos.y = this._joystickPointerStartPos.y + vector.y;
      } else {
        this._joystickPointerPos.x = e.clientX;
        this._joystickPointerPos.y = e.clientY;
      }
      this._deltaJoystickVector = this._joystickPointerPos.clone();
      this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos);
      if (0 < VirtualJoystick._AlwaysVisibleSticks) {
        if (this._leftJoystick) {
          this._joystickPointerPos.x = Math.min(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);
        } else {
          this._joystickPointerPos.x = Math.max(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);
        }
      }
      const directionLeftRight = this.reverseLeftRight ? -1 : 1;
      const deltaJoystickX = directionLeftRight * this._deltaJoystickVector.x / this._inversedSensibility;
      switch (this._axisTargetedByLeftAndRight) {
        case JoystickAxis.X:
          this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickX));
          break;
        case JoystickAxis.Y:
          this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickX));
          break;
        case JoystickAxis.Z:
          this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickX));
          break;
      }
      const directionUpDown = this.reverseUpDown ? 1 : -1;
      const deltaJoystickY = directionUpDown * this._deltaJoystickVector.y / this._inversedSensibility;
      switch (this._axisTargetedByUpAndDown) {
        case JoystickAxis.X:
          this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickY));
          break;
        case JoystickAxis.Y:
          this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickY));
          break;
        case JoystickAxis.Z:
          this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickY));
          break;
      }
    } else {
      const data = this._touches.get(e.pointerId.toString());
      if (data) {
        data.x = e.clientX;
        data.y = e.clientY;
      }
    }
  }
  _onPointerUp(e) {
    if (this._joystickPointerId == e.pointerId) {
      this._clearPreviousDraw();
      this._joystickPointerId = -1;
      this.pressed = false;
    } else {
      const touch = this._touches.get(e.pointerId.toString());
      if (touch) {
        VirtualJoystick._VJCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);
      }
    }
    this._deltaJoystickVector.x = 0;
    this._deltaJoystickVector.y = 0;
    this._touches.remove(e.pointerId.toString());
  }
  setJoystickColor(newColor) {
    this._joystickColor = newColor;
  }
  set containerSize(newSize) {
    this._joystickContainerSize = newSize;
    this._clearContainerSize = ~~(this._joystickContainerSize * 2.1);
    this._clearContainerSizeOffset = ~~(this._clearContainerSize / 2);
  }
  get containerSize() {
    return this._joystickContainerSize;
  }
  set puckSize(newSize) {
    this._joystickPuckSize = newSize;
    this._clearPuckSize = ~~(this._joystickPuckSize * 2.1);
    this._clearPuckSizeOffset = ~~(this._clearPuckSize / 2);
  }
  get puckSize() {
    return this._joystickPuckSize;
  }
  clearPosition() {
    this.alwaysVisible = false;
    this._joystickPosition = null;
  }
  set alwaysVisible(value) {
    if (this._alwaysVisible === value) {
      return;
    }
    if (value && this._joystickPosition) {
      VirtualJoystick._AlwaysVisibleSticks++;
      this._alwaysVisible = true;
    } else {
      VirtualJoystick._AlwaysVisibleSticks--;
      this._alwaysVisible = false;
    }
  }
  get alwaysVisible() {
    return this._alwaysVisible;
  }
  setPosition(x, y) {
    if (this._joystickPointerStartPos) {
      this._clearPreviousDraw();
    }
    this._joystickPosition = new Vector2(x, y);
  }
  setActionOnTouch(action) {
    this._action = action;
  }
  setAxisForLeftRight(axis) {
    switch (axis) {
      case JoystickAxis.X:
      case JoystickAxis.Y:
      case JoystickAxis.Z:
        this._axisTargetedByLeftAndRight = axis;
        break;
      default:
        this._axisTargetedByLeftAndRight = JoystickAxis.X;
        break;
    }
  }
  setAxisForUpDown(axis) {
    switch (axis) {
      case JoystickAxis.X:
      case JoystickAxis.Y:
      case JoystickAxis.Z:
        this._axisTargetedByUpAndDown = axis;
        break;
      default:
        this._axisTargetedByUpAndDown = JoystickAxis.Y;
        break;
    }
  }
  _clearPreviousDraw() {
    const jp = this._joystickPosition || this._joystickPointerStartPos;
    VirtualJoystick._VJCanvasContext.clearRect(jp.x - this._clearContainerSizeOffset, jp.y - this._clearContainerSizeOffset, this._clearContainerSize, this._clearContainerSize);
    VirtualJoystick._VJCanvasContext.clearRect(this._joystickPreviousPointerPos.x - this._clearPuckSizeOffset, this._joystickPreviousPointerPos.y - this._clearPuckSizeOffset, this._clearPuckSize, this._clearPuckSize);
  }
  setContainerImage(urlPath) {
    const image = new Image();
    image.src = urlPath;
    image.onload = () => this._containerImage = image;
  }
  setPuckImage(urlPath) {
    const image = new Image();
    image.src = urlPath;
    image.onload = () => this._puckImage = image;
  }
  _drawContainer() {
    const jp = this._joystickPosition || this._joystickPointerStartPos;
    this._clearPreviousDraw();
    if (this._containerImage) {
      VirtualJoystick._VJCanvasContext.drawImage(this._containerImage, jp.x - this.containerSize, jp.y - this.containerSize, this.containerSize * 2, this.containerSize * 2);
    } else {
      VirtualJoystick._VJCanvasContext.beginPath();
      VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;
      VirtualJoystick._VJCanvasContext.lineWidth = 2;
      VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.containerSize, 0, Math.PI * 2, true);
      VirtualJoystick._VJCanvasContext.stroke();
      VirtualJoystick._VJCanvasContext.closePath();
      VirtualJoystick._VJCanvasContext.beginPath();
      VirtualJoystick._VJCanvasContext.lineWidth = 6;
      VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;
      VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.puckSize, 0, Math.PI * 2, true);
      VirtualJoystick._VJCanvasContext.stroke();
      VirtualJoystick._VJCanvasContext.closePath();
    }
  }
  _drawPuck() {
    if (this._puckImage) {
      VirtualJoystick._VJCanvasContext.drawImage(this._puckImage, this._joystickPointerPos.x - this.puckSize, this._joystickPointerPos.y - this.puckSize, this.puckSize * 2, this.puckSize * 2);
    } else {
      VirtualJoystick._VJCanvasContext.beginPath();
      VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;
      VirtualJoystick._VJCanvasContext.lineWidth = 2;
      VirtualJoystick._VJCanvasContext.arc(this._joystickPointerPos.x, this._joystickPointerPos.y, this.puckSize, 0, Math.PI * 2, true);
      VirtualJoystick._VJCanvasContext.stroke();
      VirtualJoystick._VJCanvasContext.closePath();
    }
  }
  _drawVirtualJoystick() {
    if (this._released) {
      return;
    }
    if (this.alwaysVisible) {
      this._drawContainer();
    }
    if (this.pressed) {
      this._touches.forEach((key, touch) => {
        if (touch.pointerId === this._joystickPointerId) {
          if (!this.alwaysVisible) {
            this._drawContainer();
          }
          this._drawPuck();
          this._joystickPreviousPointerPos = this._joystickPointerPos.clone();
        } else {
          VirtualJoystick._VJCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);
          VirtualJoystick._VJCanvasContext.beginPath();
          VirtualJoystick._VJCanvasContext.fillStyle = "white";
          VirtualJoystick._VJCanvasContext.beginPath();
          VirtualJoystick._VJCanvasContext.strokeStyle = "red";
          VirtualJoystick._VJCanvasContext.lineWidth = 6;
          VirtualJoystick._VJCanvasContext.arc(touch.x, touch.y, 40, 0, Math.PI * 2, true);
          VirtualJoystick._VJCanvasContext.stroke();
          VirtualJoystick._VJCanvasContext.closePath();
          touch.prevX = touch.x;
          touch.prevY = touch.y;
        }
      });
    }
    requestAnimationFrame(() => {
      this._drawVirtualJoystick();
    });
  }
  releaseCanvas() {
    if (VirtualJoystick.Canvas) {
      VirtualJoystick.Canvas.removeEventListener("pointerdown", this._onPointerDownHandlerRef);
      VirtualJoystick.Canvas.removeEventListener("pointermove", this._onPointerMoveHandlerRef);
      VirtualJoystick.Canvas.removeEventListener("pointerup", this._onPointerUpHandlerRef);
      VirtualJoystick.Canvas.removeEventListener("pointerout", this._onPointerUpHandlerRef);
      window.removeEventListener("resize", this._onResize);
      document.body.removeChild(VirtualJoystick.Canvas);
      VirtualJoystick.Canvas = null;
    }
    this._released = true;
  }
};
VirtualJoystick._GlobalJoystickIndex = 0;
VirtualJoystick._AlwaysVisibleSticks = 0;

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraVirtualJoystickInput.js
FreeCameraInputsManager.prototype.addVirtualJoystick = function() {
  this.add(new FreeCameraVirtualJoystickInput());
  return this;
};
var FreeCameraVirtualJoystickInput = class {
  getLeftJoystick() {
    return this._leftjoystick;
  }
  getRightJoystick() {
    return this._rightjoystick;
  }
  checkInputs() {
    if (this._leftjoystick) {
      const camera = this.camera;
      const speed = camera._computeLocalCameraSpeed() * 50;
      const cameraTransform = Matrix.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, 0);
      const deltaTransform = Vector3.TransformCoordinates(new Vector3(this._leftjoystick.deltaPosition.x * speed, this._leftjoystick.deltaPosition.y * speed, this._leftjoystick.deltaPosition.z * speed), cameraTransform);
      camera.cameraDirection = camera.cameraDirection.add(deltaTransform);
      camera.cameraRotation = camera.cameraRotation.addVector3(this._rightjoystick.deltaPosition);
      if (!this._leftjoystick.pressed) {
        this._leftjoystick.deltaPosition = this._leftjoystick.deltaPosition.scale(0.9);
      }
      if (!this._rightjoystick.pressed) {
        this._rightjoystick.deltaPosition = this._rightjoystick.deltaPosition.scale(0.9);
      }
    }
  }
  attachControl() {
    this._leftjoystick = new VirtualJoystick(true);
    this._leftjoystick.setAxisForUpDown(JoystickAxis.Z);
    this._leftjoystick.setAxisForLeftRight(JoystickAxis.X);
    this._leftjoystick.setJoystickSensibility(0.15);
    this._rightjoystick = new VirtualJoystick(false);
    this._rightjoystick.setAxisForUpDown(JoystickAxis.X);
    this._rightjoystick.setAxisForLeftRight(JoystickAxis.Y);
    this._rightjoystick.reverseUpDown = true;
    this._rightjoystick.setJoystickSensibility(0.05);
    this._rightjoystick.setJoystickColor("yellow");
  }
  detachControl() {
    this._leftjoystick.releaseCanvas();
    this._rightjoystick.releaseCanvas();
  }
  getClassName() {
    return "FreeCameraVirtualJoystickInput";
  }
  getSimpleName() {
    return "virtualJoystick";
  }
};
CameraInputTypes["FreeCameraVirtualJoystickInput"] = FreeCameraVirtualJoystickInput;

// node_modules/@babylonjs/core/Cameras/touchCamera.js
Node2.AddNodeConstructor("TouchCamera", (name137, scene) => {
  return () => new TouchCamera(name137, Vector3.Zero(), scene);
});
var TouchCamera = class extends FreeCamera {
  get touchAngularSensibility() {
    const touch = this.inputs.attached["touch"];
    if (touch) {
      return touch.touchAngularSensibility;
    }
    return 0;
  }
  set touchAngularSensibility(value) {
    const touch = this.inputs.attached["touch"];
    if (touch) {
      touch.touchAngularSensibility = value;
    }
  }
  get touchMoveSensibility() {
    const touch = this.inputs.attached["touch"];
    if (touch) {
      return touch.touchMoveSensibility;
    }
    return 0;
  }
  set touchMoveSensibility(value) {
    const touch = this.inputs.attached["touch"];
    if (touch) {
      touch.touchMoveSensibility = value;
    }
  }
  constructor(name137, position, scene) {
    super(name137, position, scene);
    this.inputs.addTouch();
    this._setupInputs();
  }
  getClassName() {
    return "TouchCamera";
  }
  _setupInputs() {
    const touch = this.inputs.attached["touch"];
    const mouse = this.inputs.attached["mouse"];
    if (mouse) {
      mouse.touchEnabled = false;
    } else {
      touch.allowMouse = true;
    }
  }
};

// node_modules/@babylonjs/core/Cameras/arcRotateCamera.js
Node2.AddNodeConstructor("ArcRotateCamera", (name137, scene) => {
  return () => new ArcRotateCamera(name137, 0, 0, 1, Vector3.Zero(), scene);
});
var ArcRotateCamera = class extends TargetCamera {
  constructor(name137, alpha, beta, radius, target, scene, setActiveOnSceneIfNoneActive = true) {
    super(name137, Vector3.Zero(), scene, setActiveOnSceneIfNoneActive);
    this.inertialAlphaOffset = 0;
    this.inertialBetaOffset = 0;
    this.inertialRadiusOffset = 0;
    this.lowerAlphaLimit = null;
    this.upperAlphaLimit = null;
    this.lowerBetaLimit = 0.01;
    this.upperBetaLimit = Math.PI - 0.01;
    this.lowerRadiusLimit = null;
    this.upperRadiusLimit = null;
    this.inertialPanningX = 0;
    this.inertialPanningY = 0;
    this.pinchToPanMaxDistance = 20;
    this.panningDistanceLimit = null;
    this.panningOriginTarget = Vector3.Zero();
    this.panningInertia = 0.9;
    this.zoomOnFactor = 1;
    this.targetScreenOffset = Vector2.Zero();
    this.allowUpsideDown = true;
    this.useInputToRestoreState = true;
    this._viewMatrix = new Matrix();
    this.panningAxis = new Vector3(1, 1, 0);
    this._transformedDirection = new Vector3();
    this.mapPanning = false;
    this.onMeshTargetChangedObservable = new Observable();
    this.checkCollisions = false;
    this.collisionRadius = new Vector3(0.5, 0.5, 0.5);
    this._previousPosition = Vector3.Zero();
    this._collisionVelocity = Vector3.Zero();
    this._newPosition = Vector3.Zero();
    this._computationVector = Vector3.Zero();
    this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {
      if (!collidedMesh) {
        this._previousPosition.copyFrom(this._position);
      } else {
        this.setPosition(newPosition);
        if (this.onCollide) {
          this.onCollide(collidedMesh);
        }
      }
      const cosa = Math.cos(this.alpha);
      const sina = Math.sin(this.alpha);
      const cosb = Math.cos(this.beta);
      let sinb = Math.sin(this.beta);
      if (sinb === 0) {
        sinb = 1e-4;
      }
      const target2 = this._getTargetPosition();
      this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);
      target2.addToRef(this._computationVector, this._newPosition);
      this._position.copyFrom(this._newPosition);
      let up = this.upVector;
      if (this.allowUpsideDown && this.beta < 0) {
        up = up.clone();
        up = up.negate();
      }
      this._computeViewMatrix(this._position, target2, up);
      this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);
      this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);
      this._collisionTriggered = false;
    };
    this._target = Vector3.Zero();
    if (target) {
      this.setTarget(target);
    }
    this.alpha = alpha;
    this.beta = beta;
    this.radius = radius;
    this.getViewMatrix();
    this.inputs = new ArcRotateCameraInputsManager(this);
    this.inputs.addKeyboard().addMouseWheel().addPointers();
  }
  get target() {
    return this._target;
  }
  set target(value) {
    this.setTarget(value);
  }
  get targetHost() {
    return this._targetHost;
  }
  set targetHost(value) {
    if (value) {
      this.setTarget(value);
    }
  }
  getTarget() {
    return this.target;
  }
  get position() {
    return this._position;
  }
  set position(newPosition) {
    this.setPosition(newPosition);
  }
  set upVector(vec) {
    if (!this._upToYMatrix) {
      this._yToUpMatrix = new Matrix();
      this._upToYMatrix = new Matrix();
      this._upVector = Vector3.Zero();
    }
    vec.normalize();
    this._upVector.copyFrom(vec);
    this.setMatUp();
  }
  get upVector() {
    return this._upVector;
  }
  setMatUp() {
    Matrix.RotationAlignToRef(Vector3.UpReadOnly, this._upVector, this._yToUpMatrix);
    Matrix.RotationAlignToRef(this._upVector, Vector3.UpReadOnly, this._upToYMatrix);
  }
  get angularSensibilityX() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.angularSensibilityX;
    }
    return 0;
  }
  set angularSensibilityX(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.angularSensibilityX = value;
    }
  }
  get angularSensibilityY() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.angularSensibilityY;
    }
    return 0;
  }
  set angularSensibilityY(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.angularSensibilityY = value;
    }
  }
  get pinchPrecision() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.pinchPrecision;
    }
    return 0;
  }
  set pinchPrecision(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.pinchPrecision = value;
    }
  }
  get pinchDeltaPercentage() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.pinchDeltaPercentage;
    }
    return 0;
  }
  set pinchDeltaPercentage(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.pinchDeltaPercentage = value;
    }
  }
  get useNaturalPinchZoom() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.useNaturalPinchZoom;
    }
    return false;
  }
  set useNaturalPinchZoom(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.useNaturalPinchZoom = value;
    }
  }
  get panningSensibility() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.panningSensibility;
    }
    return 0;
  }
  set panningSensibility(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.panningSensibility = value;
    }
  }
  get keysUp() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysUp;
    }
    return [];
  }
  set keysUp(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysUp = value;
    }
  }
  get keysDown() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysDown;
    }
    return [];
  }
  set keysDown(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysDown = value;
    }
  }
  get keysLeft() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysLeft;
    }
    return [];
  }
  set keysLeft(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysLeft = value;
    }
  }
  get keysRight() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysRight;
    }
    return [];
  }
  set keysRight(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysRight = value;
    }
  }
  get wheelPrecision() {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      return mousewheel.wheelPrecision;
    }
    return 0;
  }
  set wheelPrecision(value) {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      mousewheel.wheelPrecision = value;
    }
  }
  get zoomToMouseLocation() {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      return mousewheel.zoomToMouseLocation;
    }
    return false;
  }
  set zoomToMouseLocation(value) {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      mousewheel.zoomToMouseLocation = value;
    }
  }
  get wheelDeltaPercentage() {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      return mousewheel.wheelDeltaPercentage;
    }
    return 0;
  }
  set wheelDeltaPercentage(value) {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      mousewheel.wheelDeltaPercentage = value;
    }
  }
  get bouncingBehavior() {
    return this._bouncingBehavior;
  }
  get useBouncingBehavior() {
    return this._bouncingBehavior != null;
  }
  set useBouncingBehavior(value) {
    if (value === this.useBouncingBehavior) {
      return;
    }
    if (value) {
      this._bouncingBehavior = new BouncingBehavior();
      this.addBehavior(this._bouncingBehavior);
    } else if (this._bouncingBehavior) {
      this.removeBehavior(this._bouncingBehavior);
      this._bouncingBehavior = null;
    }
  }
  get framingBehavior() {
    return this._framingBehavior;
  }
  get useFramingBehavior() {
    return this._framingBehavior != null;
  }
  set useFramingBehavior(value) {
    if (value === this.useFramingBehavior) {
      return;
    }
    if (value) {
      this._framingBehavior = new FramingBehavior();
      this.addBehavior(this._framingBehavior);
    } else if (this._framingBehavior) {
      this.removeBehavior(this._framingBehavior);
      this._framingBehavior = null;
    }
  }
  get autoRotationBehavior() {
    return this._autoRotationBehavior;
  }
  get useAutoRotationBehavior() {
    return this._autoRotationBehavior != null;
  }
  set useAutoRotationBehavior(value) {
    if (value === this.useAutoRotationBehavior) {
      return;
    }
    if (value) {
      this._autoRotationBehavior = new AutoRotationBehavior();
      this.addBehavior(this._autoRotationBehavior);
    } else if (this._autoRotationBehavior) {
      this.removeBehavior(this._autoRotationBehavior);
      this._autoRotationBehavior = null;
    }
  }
  _initCache() {
    super._initCache();
    this._cache._target = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.alpha = void 0;
    this._cache.beta = void 0;
    this._cache.radius = void 0;
    this._cache.targetScreenOffset = Vector2.Zero();
  }
  _updateCache(ignoreParentClass) {
    if (!ignoreParentClass) {
      super._updateCache();
    }
    this._cache._target.copyFrom(this._getTargetPosition());
    this._cache.alpha = this.alpha;
    this._cache.beta = this.beta;
    this._cache.radius = this.radius;
    this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);
  }
  _getTargetPosition() {
    if (this._targetHost && this._targetHost.getAbsolutePosition) {
      const pos = this._targetHost.getAbsolutePosition();
      if (this._targetBoundingCenter) {
        pos.addToRef(this._targetBoundingCenter, this._target);
      } else {
        this._target.copyFrom(pos);
      }
    }
    const lockedTargetPosition = this._getLockedTargetPosition();
    if (lockedTargetPosition) {
      return lockedTargetPosition;
    }
    return this._target;
  }
  storeState() {
    this._storedAlpha = this.alpha;
    this._storedBeta = this.beta;
    this._storedRadius = this.radius;
    this._storedTarget = this._getTargetPosition().clone();
    this._storedTargetScreenOffset = this.targetScreenOffset.clone();
    return super.storeState();
  }
  _restoreStateValues() {
    if (!super._restoreStateValues()) {
      return false;
    }
    this.setTarget(this._storedTarget.clone());
    this.alpha = this._storedAlpha;
    this.beta = this._storedBeta;
    this.radius = this._storedRadius;
    this.targetScreenOffset = this._storedTargetScreenOffset.clone();
    this.inertialAlphaOffset = 0;
    this.inertialBetaOffset = 0;
    this.inertialRadiusOffset = 0;
    this.inertialPanningX = 0;
    this.inertialPanningY = 0;
    return true;
  }
  _isSynchronizedViewMatrix() {
    if (!super._isSynchronizedViewMatrix()) {
      return false;
    }
    return this._cache._target.equals(this._getTargetPosition()) && this._cache.alpha === this.alpha && this._cache.beta === this.beta && this._cache.radius === this.radius && this._cache.targetScreenOffset.equals(this.targetScreenOffset);
  }
  attachControl(ignored, noPreventDefault, useCtrlForPanning = true, panningMouseButton = 2) {
    const args = arguments;
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(args);
    this._useCtrlForPanning = useCtrlForPanning;
    this._panningMouseButton = panningMouseButton;
    if (typeof args[0] === "boolean") {
      if (args.length > 1) {
        this._useCtrlForPanning = args[1];
      }
      if (args.length > 2) {
        this._panningMouseButton = args[2];
      }
    }
    this.inputs.attachElement(noPreventDefault);
    this._reset = () => {
      this.inertialAlphaOffset = 0;
      this.inertialBetaOffset = 0;
      this.inertialRadiusOffset = 0;
      this.inertialPanningX = 0;
      this.inertialPanningY = 0;
    };
  }
  detachControl() {
    this.inputs.detachElement();
    if (this._reset) {
      this._reset();
    }
  }
  _checkInputs() {
    if (this._collisionTriggered) {
      return;
    }
    this.inputs.checkInputs();
    if (this.inertialAlphaOffset !== 0 || this.inertialBetaOffset !== 0 || this.inertialRadiusOffset !== 0) {
      const directionModifier = this.invertRotation ? -1 : 1;
      let inertialAlphaOffset = this.inertialAlphaOffset;
      if (this.beta <= 0) {
        inertialAlphaOffset *= -1;
      }
      if (this.getScene().useRightHandedSystem) {
        inertialAlphaOffset *= -1;
      }
      if (this.parent && this.parent._getWorldMatrixDeterminant() < 0) {
        inertialAlphaOffset *= -1;
      }
      this.alpha += inertialAlphaOffset * directionModifier;
      this.beta += this.inertialBetaOffset * directionModifier;
      this.radius -= this.inertialRadiusOffset;
      this.inertialAlphaOffset *= this.inertia;
      this.inertialBetaOffset *= this.inertia;
      this.inertialRadiusOffset *= this.inertia;
      if (Math.abs(this.inertialAlphaOffset) < Epsilon) {
        this.inertialAlphaOffset = 0;
      }
      if (Math.abs(this.inertialBetaOffset) < Epsilon) {
        this.inertialBetaOffset = 0;
      }
      if (Math.abs(this.inertialRadiusOffset) < this.speed * Epsilon) {
        this.inertialRadiusOffset = 0;
      }
    }
    if (this.inertialPanningX !== 0 || this.inertialPanningY !== 0) {
      const localDirection = new Vector3(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);
      this._viewMatrix.invertToRef(this._cameraTransformMatrix);
      localDirection.multiplyInPlace(this.panningAxis);
      Vector3.TransformNormalToRef(localDirection, this._cameraTransformMatrix, this._transformedDirection);
      if (this.mapPanning || !this.panningAxis.y) {
        this._transformedDirection.y = 0;
      }
      if (!this._targetHost) {
        if (this.panningDistanceLimit) {
          this._transformedDirection.addInPlace(this._target);
          const distanceSquared = Vector3.DistanceSquared(this._transformedDirection, this.panningOriginTarget);
          if (distanceSquared <= this.panningDistanceLimit * this.panningDistanceLimit) {
            this._target.copyFrom(this._transformedDirection);
          }
        } else {
          this._target.addInPlace(this._transformedDirection);
        }
      }
      this.inertialPanningX *= this.panningInertia;
      this.inertialPanningY *= this.panningInertia;
      if (Math.abs(this.inertialPanningX) < this.speed * Epsilon) {
        this.inertialPanningX = 0;
      }
      if (Math.abs(this.inertialPanningY) < this.speed * Epsilon) {
        this.inertialPanningY = 0;
      }
    }
    this._checkLimits();
    super._checkInputs();
  }
  _checkLimits() {
    if (this.lowerBetaLimit === null || this.lowerBetaLimit === void 0) {
      if (this.allowUpsideDown && this.beta > Math.PI) {
        this.beta = this.beta - 2 * Math.PI;
      }
    } else {
      if (this.beta < this.lowerBetaLimit) {
        this.beta = this.lowerBetaLimit;
      }
    }
    if (this.upperBetaLimit === null || this.upperBetaLimit === void 0) {
      if (this.allowUpsideDown && this.beta < -Math.PI) {
        this.beta = this.beta + 2 * Math.PI;
      }
    } else {
      if (this.beta > this.upperBetaLimit) {
        this.beta = this.upperBetaLimit;
      }
    }
    if (this.lowerAlphaLimit !== null && this.alpha < this.lowerAlphaLimit) {
      this.alpha = this.lowerAlphaLimit;
    }
    if (this.upperAlphaLimit !== null && this.alpha > this.upperAlphaLimit) {
      this.alpha = this.upperAlphaLimit;
    }
    if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {
      this.radius = this.lowerRadiusLimit;
      this.inertialRadiusOffset = 0;
    }
    if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {
      this.radius = this.upperRadiusLimit;
      this.inertialRadiusOffset = 0;
    }
  }
  rebuildAnglesAndRadius() {
    this._position.subtractToRef(this._getTargetPosition(), this._computationVector);
    if (this._upVector.x !== 0 || this._upVector.y !== 1 || this._upVector.z !== 0) {
      Vector3.TransformCoordinatesToRef(this._computationVector, this._upToYMatrix, this._computationVector);
    }
    this.radius = this._computationVector.length();
    if (this.radius === 0) {
      this.radius = 1e-4;
    }
    const previousAlpha = this.alpha;
    if (this._computationVector.x === 0 && this._computationVector.z === 0) {
      this.alpha = Math.PI / 2;
    } else {
      this.alpha = Math.acos(this._computationVector.x / Math.sqrt(Math.pow(this._computationVector.x, 2) + Math.pow(this._computationVector.z, 2)));
    }
    if (this._computationVector.z < 0) {
      this.alpha = 2 * Math.PI - this.alpha;
    }
    const alphaCorrectionTurns = Math.round((previousAlpha - this.alpha) / (2 * Math.PI));
    this.alpha += alphaCorrectionTurns * 2 * Math.PI;
    this.beta = Math.acos(this._computationVector.y / this.radius);
    this._checkLimits();
  }
  setPosition(position) {
    if (this._position.equals(position)) {
      return;
    }
    this._position.copyFrom(position);
    this.rebuildAnglesAndRadius();
  }
  setTarget(target, toBoundingCenter = false, allowSamePosition = false, cloneAlphaBetaRadius = false) {
    var _a;
    cloneAlphaBetaRadius = (_a = this.overrideCloneAlphaBetaRadius) !== null && _a !== void 0 ? _a : cloneAlphaBetaRadius;
    if (target.getBoundingInfo) {
      if (toBoundingCenter) {
        this._targetBoundingCenter = target.getBoundingInfo().boundingBox.centerWorld.clone();
      } else {
        this._targetBoundingCenter = null;
      }
      target.computeWorldMatrix();
      this._targetHost = target;
      this._target = this._getTargetPosition();
      this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);
    } else {
      const newTarget = target;
      const currentTarget = this._getTargetPosition();
      if (currentTarget && !allowSamePosition && currentTarget.equals(newTarget)) {
        return;
      }
      this._targetHost = null;
      this._target = newTarget;
      this._targetBoundingCenter = null;
      this.onMeshTargetChangedObservable.notifyObservers(null);
    }
    if (!cloneAlphaBetaRadius) {
      this.rebuildAnglesAndRadius();
    }
  }
  _getViewMatrix() {
    const cosa = Math.cos(this.alpha);
    const sina = Math.sin(this.alpha);
    const cosb = Math.cos(this.beta);
    let sinb = Math.sin(this.beta);
    if (sinb === 0) {
      sinb = 1e-4;
    }
    if (this.radius === 0) {
      this.radius = 1e-4;
    }
    const target = this._getTargetPosition();
    this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);
    if (this._upVector.x !== 0 || this._upVector.y !== 1 || this._upVector.z !== 0) {
      Vector3.TransformCoordinatesToRef(this._computationVector, this._yToUpMatrix, this._computationVector);
    }
    target.addToRef(this._computationVector, this._newPosition);
    if (this.getScene().collisionsEnabled && this.checkCollisions) {
      const coordinator = this.getScene().collisionCoordinator;
      if (!this._collider) {
        this._collider = coordinator.createCollider();
      }
      this._collider._radius = this.collisionRadius;
      this._newPosition.subtractToRef(this._position, this._collisionVelocity);
      this._collisionTriggered = true;
      coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
    } else {
      this._position.copyFrom(this._newPosition);
      let up = this.upVector;
      if (this.allowUpsideDown && sinb < 0) {
        up = up.negate();
      }
      this._computeViewMatrix(this._position, target, up);
      this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);
      this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);
    }
    this._currentTarget = target;
    return this._viewMatrix;
  }
  zoomOn(meshes, doNotUpdateMaxZ = false) {
    meshes = meshes || this.getScene().meshes;
    const minMaxVector = Mesh.MinMax(meshes);
    const distance = Vector3.Distance(minMaxVector.min, minMaxVector.max);
    this.radius = distance * this.zoomOnFactor;
    this.focusOn({ min: minMaxVector.min, max: minMaxVector.max, distance }, doNotUpdateMaxZ);
  }
  focusOn(meshesOrMinMaxVectorAndDistance, doNotUpdateMaxZ = false) {
    let meshesOrMinMaxVector;
    let distance;
    if (meshesOrMinMaxVectorAndDistance.min === void 0) {
      const meshes = meshesOrMinMaxVectorAndDistance || this.getScene().meshes;
      meshesOrMinMaxVector = Mesh.MinMax(meshes);
      distance = Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);
    } else {
      const minMaxVectorAndDistance = meshesOrMinMaxVectorAndDistance;
      meshesOrMinMaxVector = minMaxVectorAndDistance;
      distance = minMaxVectorAndDistance.distance;
    }
    this._target = Mesh.Center(meshesOrMinMaxVector);
    if (!doNotUpdateMaxZ) {
      this.maxZ = distance * 2;
    }
  }
  createRigCamera(name137, cameraIndex) {
    let alphaShift = 0;
    switch (this.cameraRigMode) {
      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:
      case Camera.RIG_MODE_VR:
        alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? 1 : -1);
        break;
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
        alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? -1 : 1);
        break;
    }
    const rigCam = new ArcRotateCamera(name137, this.alpha + alphaShift, this.beta, this.radius, this._target, this.getScene());
    rigCam._cameraRigParams = {};
    rigCam.isRigCamera = true;
    rigCam.rigParent = this;
    rigCam.upVector = this.upVector;
    rigCam.mode = this.mode;
    rigCam.orthoLeft = this.orthoLeft;
    rigCam.orthoRight = this.orthoRight;
    rigCam.orthoBottom = this.orthoBottom;
    rigCam.orthoTop = this.orthoTop;
    return rigCam;
  }
  _updateRigCameras() {
    const camLeft = this._rigCameras[0];
    const camRight = this._rigCameras[1];
    camLeft.beta = camRight.beta = this.beta;
    switch (this.cameraRigMode) {
      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:
      case Camera.RIG_MODE_VR:
        camLeft.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;
        camRight.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;
        break;
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
        camLeft.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;
        camRight.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;
        break;
    }
    super._updateRigCameras();
  }
  dispose() {
    this.inputs.clear();
    super.dispose();
  }
  getClassName() {
    return "ArcRotateCamera";
  }
};
__decorate([
  serialize()
], ArcRotateCamera.prototype, "alpha", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "beta", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "radius", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "overrideCloneAlphaBetaRadius", void 0);
__decorate([
  serializeAsVector3("target")
], ArcRotateCamera.prototype, "_target", void 0);
__decorate([
  serializeAsMeshReference("targetHost")
], ArcRotateCamera.prototype, "_targetHost", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "inertialAlphaOffset", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "inertialBetaOffset", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "inertialRadiusOffset", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "lowerAlphaLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "upperAlphaLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "lowerBetaLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "upperBetaLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "lowerRadiusLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "upperRadiusLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "inertialPanningX", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "inertialPanningY", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "pinchToPanMaxDistance", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "panningDistanceLimit", void 0);
__decorate([
  serializeAsVector3()
], ArcRotateCamera.prototype, "panningOriginTarget", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "panningInertia", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "zoomToMouseLocation", null);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "zoomOnFactor", void 0);
__decorate([
  serializeAsVector2()
], ArcRotateCamera.prototype, "targetScreenOffset", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "allowUpsideDown", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "useInputToRestoreState", void 0);

// node_modules/@babylonjs/core/Cameras/deviceOrientationCamera.js
Node2.AddNodeConstructor("DeviceOrientationCamera", (name137, scene) => {
  return () => new DeviceOrientationCamera(name137, Vector3.Zero(), scene);
});
var DeviceOrientationCamera = class extends FreeCamera {
  constructor(name137, position, scene) {
    super(name137, position, scene);
    this._tmpDragQuaternion = new Quaternion();
    this._disablePointerInputWhenUsingDeviceOrientation = true;
    this._dragFactor = 0;
    this._quaternionCache = new Quaternion();
    this.inputs.addDeviceOrientation();
    if (this.inputs._deviceOrientationInput) {
      this.inputs._deviceOrientationInput._onDeviceOrientationChangedObservable.addOnce(() => {
        if (this._disablePointerInputWhenUsingDeviceOrientation) {
          if (this.inputs._mouseInput) {
            this.inputs._mouseInput._allowCameraRotation = false;
            this.inputs._mouseInput.onPointerMovedObservable.add((e) => {
              if (this._dragFactor != 0) {
                if (!this._initialQuaternion) {
                  this._initialQuaternion = new Quaternion();
                }
                Quaternion.FromEulerAnglesToRef(0, e.offsetX * this._dragFactor, 0, this._tmpDragQuaternion);
                this._initialQuaternion.multiplyToRef(this._tmpDragQuaternion, this._initialQuaternion);
              }
            });
          }
        }
      });
    }
  }
  get disablePointerInputWhenUsingDeviceOrientation() {
    return this._disablePointerInputWhenUsingDeviceOrientation;
  }
  set disablePointerInputWhenUsingDeviceOrientation(value) {
    this._disablePointerInputWhenUsingDeviceOrientation = value;
  }
  enableHorizontalDragging(dragFactor = 1 / 300) {
    this._dragFactor = dragFactor;
  }
  getClassName() {
    return "DeviceOrientationCamera";
  }
  _checkInputs() {
    super._checkInputs();
    this._quaternionCache.copyFrom(this.rotationQuaternion);
    if (this._initialQuaternion) {
      this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    }
  }
  resetToCurrentRotation(axis = Axis.Y) {
    if (!this.rotationQuaternion) {
      return;
    }
    if (!this._initialQuaternion) {
      this._initialQuaternion = new Quaternion();
    }
    this._initialQuaternion.copyFrom(this._quaternionCache || this.rotationQuaternion);
    ["x", "y", "z"].forEach((axisName) => {
      if (!axis[axisName]) {
        this._initialQuaternion[axisName] = 0;
      } else {
        this._initialQuaternion[axisName] *= -1;
      }
    });
    this._initialQuaternion.normalize();
    this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
  }
};

// node_modules/@babylonjs/core/Cameras/flyCameraInputsManager.js
var FlyCameraInputsManager = class extends CameraInputsManager {
  constructor(camera) {
    super(camera);
  }
  addKeyboard() {
    this.add(new FlyCameraKeyboardInput());
    return this;
  }
  addMouse() {
    this.add(new FlyCameraMouseInput());
    return this;
  }
};

// node_modules/@babylonjs/core/Cameras/flyCamera.js
var FlyCamera = class extends TargetCamera {
  constructor(name137, position, scene, setActiveOnSceneIfNoneActive = true) {
    super(name137, position, scene, setActiveOnSceneIfNoneActive);
    this.ellipsoid = new Vector3(1, 1, 1);
    this.ellipsoidOffset = new Vector3(0, 0, 0);
    this.checkCollisions = false;
    this.applyGravity = false;
    this.cameraDirection = Vector3.Zero();
    this._trackRoll = 0;
    this.rollCorrect = 100;
    this.bankedTurn = false;
    this.bankedTurnLimit = Math.PI / 2;
    this.bankedTurnMultiplier = 1;
    this._needMoveForGravity = false;
    this._oldPosition = Vector3.Zero();
    this._diffPosition = Vector3.Zero();
    this._newPosition = Vector3.Zero();
    this._collisionMask = -1;
    this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {
      const updatePosition = (newPos) => {
        this._newPosition.copyFrom(newPos);
        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);
        if (this._diffPosition.length() > Engine.CollisionsEpsilon) {
          this.position.addInPlace(this._diffPosition);
          if (this.onCollide && collidedMesh) {
            this.onCollide(collidedMesh);
          }
        }
      };
      updatePosition(newPosition);
    };
    this.inputs = new FlyCameraInputsManager(this);
    this.inputs.addKeyboard().addMouse();
  }
  get angularSensibility() {
    const mouse = this.inputs.attached["mouse"];
    if (mouse) {
      return mouse.angularSensibility;
    }
    return 0;
  }
  set angularSensibility(value) {
    const mouse = this.inputs.attached["mouse"];
    if (mouse) {
      mouse.angularSensibility = value;
    }
  }
  get keysForward() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysForward;
    }
    return [];
  }
  set keysForward(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysForward = value;
    }
  }
  get keysBackward() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysBackward;
    }
    return [];
  }
  set keysBackward(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysBackward = value;
    }
  }
  get keysUp() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysUp;
    }
    return [];
  }
  set keysUp(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysUp = value;
    }
  }
  get keysDown() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysDown;
    }
    return [];
  }
  set keysDown(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysDown = value;
    }
  }
  get keysLeft() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysLeft;
    }
    return [];
  }
  set keysLeft(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysLeft = value;
    }
  }
  get keysRight() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysRight;
    }
    return [];
  }
  set keysRight(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysRight = value;
    }
  }
  attachControl(ignored, noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this.inputs.attachElement(noPreventDefault);
  }
  detachControl() {
    this.inputs.detachElement();
    this.cameraDirection = new Vector3(0, 0, 0);
  }
  get collisionMask() {
    return this._collisionMask;
  }
  set collisionMask(mask) {
    this._collisionMask = !isNaN(mask) ? mask : -1;
  }
  _collideWithWorld(displacement) {
    let globalPosition;
    if (this.parent) {
      globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());
    } else {
      globalPosition = this.position;
    }
    globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);
    this._oldPosition.addInPlace(this.ellipsoidOffset);
    const coordinator = this.getScene().collisionCoordinator;
    if (!this._collider) {
      this._collider = coordinator.createCollider();
    }
    this._collider._radius = this.ellipsoid;
    this._collider.collisionMask = this._collisionMask;
    let actualDisplacement = displacement;
    if (this.applyGravity) {
      actualDisplacement = displacement.add(this.getScene().gravity);
    }
    coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
  }
  _checkInputs() {
    if (!this._localDirection) {
      this._localDirection = Vector3.Zero();
      this._transformedDirection = Vector3.Zero();
    }
    this.inputs.checkInputs();
    super._checkInputs();
  }
  _decideIfNeedsToMove() {
    return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
  }
  _updatePosition() {
    if (this.checkCollisions && this.getScene().collisionsEnabled) {
      this._collideWithWorld(this.cameraDirection);
    } else {
      super._updatePosition();
    }
  }
  restoreRoll(rate) {
    const limit = this._trackRoll;
    const z = this.rotation.z;
    const delta = limit - z;
    const minRad = 1e-3;
    if (Math.abs(delta) >= minRad) {
      this.rotation.z += delta / rate;
      if (Math.abs(limit - this.rotation.z) <= minRad) {
        this.rotation.z = limit;
      }
    }
  }
  dispose() {
    this.inputs.clear();
    super.dispose();
  }
  getClassName() {
    return "FlyCamera";
  }
};
__decorate([
  serializeAsVector3()
], FlyCamera.prototype, "ellipsoid", void 0);
__decorate([
  serializeAsVector3()
], FlyCamera.prototype, "ellipsoidOffset", void 0);
__decorate([
  serialize()
], FlyCamera.prototype, "checkCollisions", void 0);
__decorate([
  serialize()
], FlyCamera.prototype, "applyGravity", void 0);

// node_modules/@babylonjs/core/Cameras/followCameraInputsManager.js
var FollowCameraInputsManager = class extends CameraInputsManager {
  constructor(camera) {
    super(camera);
  }
  addKeyboard() {
    this.add(new FollowCameraKeyboardMoveInput());
    return this;
  }
  addMouseWheel() {
    this.add(new FollowCameraMouseWheelInput());
    return this;
  }
  addPointers() {
    this.add(new FollowCameraPointersInput());
    return this;
  }
  addVRDeviceOrientation() {
    console.warn("DeviceOrientation support not yet implemented for FollowCamera.");
    return this;
  }
};

// node_modules/@babylonjs/core/Cameras/followCamera.js
Node2.AddNodeConstructor("FollowCamera", (name137, scene) => {
  return () => new FollowCamera(name137, Vector3.Zero(), scene);
});
Node2.AddNodeConstructor("ArcFollowCamera", (name137, scene) => {
  return () => new ArcFollowCamera(name137, 0, 0, 1, null, scene);
});
var FollowCamera = class extends TargetCamera {
  constructor(name137, position, scene, lockedTarget = null) {
    super(name137, position, scene);
    this.radius = 12;
    this.lowerRadiusLimit = null;
    this.upperRadiusLimit = null;
    this.rotationOffset = 0;
    this.lowerRotationOffsetLimit = null;
    this.upperRotationOffsetLimit = null;
    this.heightOffset = 4;
    this.lowerHeightOffsetLimit = null;
    this.upperHeightOffsetLimit = null;
    this.cameraAcceleration = 0.05;
    this.maxCameraSpeed = 20;
    this.lockedTarget = lockedTarget;
    this.inputs = new FollowCameraInputsManager(this);
    this.inputs.addKeyboard().addMouseWheel().addPointers();
  }
  _follow(cameraTarget) {
    if (!cameraTarget) {
      return;
    }
    const rotMatrix = TmpVectors.Matrix[0];
    cameraTarget.absoluteRotationQuaternion.toRotationMatrix(rotMatrix);
    const yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);
    const radians = Tools.ToRadians(this.rotationOffset) + yRotation;
    const targetPosition = cameraTarget.getAbsolutePosition();
    const targetX = targetPosition.x + Math.sin(radians) * this.radius;
    const targetZ = targetPosition.z + Math.cos(radians) * this.radius;
    const dx = targetX - this.position.x;
    const dy = targetPosition.y + this.heightOffset - this.position.y;
    const dz = targetZ - this.position.z;
    let vx = dx * this.cameraAcceleration * 2;
    let vy = dy * this.cameraAcceleration;
    let vz = dz * this.cameraAcceleration * 2;
    if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {
      vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;
    }
    if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {
      vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;
    }
    if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {
      vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;
    }
    this.position = new Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);
    this.setTarget(targetPosition);
  }
  attachControl(ignored, noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this.inputs.attachElement(noPreventDefault);
    this._reset = () => {
    };
  }
  detachControl() {
    this.inputs.detachElement();
    if (this._reset) {
      this._reset();
    }
  }
  _checkInputs() {
    this.inputs.checkInputs();
    this._checkLimits();
    super._checkInputs();
    if (this.lockedTarget) {
      this._follow(this.lockedTarget);
    }
  }
  _checkLimits() {
    if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {
      this.radius = this.lowerRadiusLimit;
    }
    if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {
      this.radius = this.upperRadiusLimit;
    }
    if (this.lowerHeightOffsetLimit !== null && this.heightOffset < this.lowerHeightOffsetLimit) {
      this.heightOffset = this.lowerHeightOffsetLimit;
    }
    if (this.upperHeightOffsetLimit !== null && this.heightOffset > this.upperHeightOffsetLimit) {
      this.heightOffset = this.upperHeightOffsetLimit;
    }
    if (this.lowerRotationOffsetLimit !== null && this.rotationOffset < this.lowerRotationOffsetLimit) {
      this.rotationOffset = this.lowerRotationOffsetLimit;
    }
    if (this.upperRotationOffsetLimit !== null && this.rotationOffset > this.upperRotationOffsetLimit) {
      this.rotationOffset = this.upperRotationOffsetLimit;
    }
  }
  getClassName() {
    return "FollowCamera";
  }
};
__decorate([
  serialize()
], FollowCamera.prototype, "radius", void 0);
__decorate([
  serialize()
], FollowCamera.prototype, "lowerRadiusLimit", void 0);
__decorate([
  serialize()
], FollowCamera.prototype, "upperRadiusLimit", void 0);
__decorate([
  serialize()
], FollowCamera.prototype, "rotationOffset", void 0);
__decorate([
  serialize()
], FollowCamera.prototype, "lowerRotationOffsetLimit", void 0);
__decorate([
  serialize()
], FollowCamera.prototype, "upperRotationOffsetLimit", void 0);
__decorate([
  serialize()
], FollowCamera.prototype, "heightOffset", void 0);
__decorate([
  serialize()
], FollowCamera.prototype, "lowerHeightOffsetLimit", void 0);
__decorate([
  serialize()
], FollowCamera.prototype, "upperHeightOffsetLimit", void 0);
__decorate([
  serialize()
], FollowCamera.prototype, "cameraAcceleration", void 0);
__decorate([
  serialize()
], FollowCamera.prototype, "maxCameraSpeed", void 0);
__decorate([
  serializeAsMeshReference("lockedTargetId")
], FollowCamera.prototype, "lockedTarget", void 0);
var ArcFollowCamera = class extends TargetCamera {
  constructor(name137, alpha, beta, radius, target, scene) {
    super(name137, Vector3.Zero(), scene);
    this.alpha = alpha;
    this.beta = beta;
    this.radius = radius;
    this._cartesianCoordinates = Vector3.Zero();
    this.setMeshTarget(target);
  }
  setMeshTarget(target) {
    this._meshTarget = target;
    this._follow();
  }
  _follow() {
    if (!this._meshTarget) {
      return;
    }
    this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);
    this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);
    this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);
    const targetPosition = this._meshTarget.getAbsolutePosition();
    this.position = targetPosition.add(this._cartesianCoordinates);
    this.setTarget(targetPosition);
  }
  _checkInputs() {
    super._checkInputs();
    this._follow();
  }
  getClassName() {
    return "ArcFollowCamera";
  }
};

// node_modules/@babylonjs/core/Gamepads/Controllers/poseEnabledController.js
var PoseEnabledControllerType;
(function(PoseEnabledControllerType2) {
  PoseEnabledControllerType2[PoseEnabledControllerType2["VIVE"] = 0] = "VIVE";
  PoseEnabledControllerType2[PoseEnabledControllerType2["OCULUS"] = 1] = "OCULUS";
  PoseEnabledControllerType2[PoseEnabledControllerType2["WINDOWS"] = 2] = "WINDOWS";
  PoseEnabledControllerType2[PoseEnabledControllerType2["GEAR_VR"] = 3] = "GEAR_VR";
  PoseEnabledControllerType2[PoseEnabledControllerType2["DAYDREAM"] = 4] = "DAYDREAM";
  PoseEnabledControllerType2[PoseEnabledControllerType2["GENERIC"] = 5] = "GENERIC";
})(PoseEnabledControllerType || (PoseEnabledControllerType = {}));
var PoseEnabledControllerHelper = class {
  static InitiateController(vrGamepad) {
    for (const factory of this._ControllerFactories) {
      if (factory.canCreate(vrGamepad)) {
        return factory.create(vrGamepad);
      }
    }
    if (this._DefaultControllerFactory) {
      return this._DefaultControllerFactory(vrGamepad);
    }
    throw "The type of gamepad you are trying to load needs to be imported first or is not supported.";
  }
};
PoseEnabledControllerHelper._ControllerFactories = [];
PoseEnabledControllerHelper._DefaultControllerFactory = null;
var PoseEnabledController = class extends Gamepad {
  constructor(browserGamepad) {
    super(browserGamepad.id, browserGamepad.index, browserGamepad);
    this.isXR = false;
    this._deviceRoomPosition = Vector3.Zero();
    this._deviceRoomRotationQuaternion = new Quaternion();
    this.devicePosition = Vector3.Zero();
    this.deviceRotationQuaternion = new Quaternion();
    this.deviceScaleFactor = 1;
    this._trackPosition = true;
    this._maxRotationDistFromHeadset = Math.PI / 5;
    this._draggedRoomRotation = 0;
    this._leftHandSystemQuaternion = new Quaternion();
    this._deviceToWorld = Matrix.Identity();
    this._pointingPoseNode = null;
    this._workingMatrix = Matrix.Identity();
    this._meshAttachedObservable = new Observable();
    this.type = Gamepad.POSE_ENABLED;
    this.controllerType = PoseEnabledControllerType.GENERIC;
    this.position = Vector3.Zero();
    this.rotationQuaternion = new Quaternion();
    this._calculatedPosition = Vector3.Zero();
    this._calculatedRotation = new Quaternion();
    Quaternion.RotationYawPitchRollToRef(Math.PI, 0, 0, this._leftHandSystemQuaternion);
  }
  _disableTrackPosition(fixedPosition) {
    if (this._trackPosition) {
      this._calculatedPosition.copyFrom(fixedPosition);
      this._trackPosition = false;
    }
  }
  update() {
    super.update();
    this._updatePoseAndMesh();
  }
  _updatePoseAndMesh() {
    if (this.isXR) {
      return;
    }
    const pose = this.browserGamepad.pose;
    this.updateFromDevice(pose);
    if (!this._trackPosition && EngineStore.LastCreatedScene && EngineStore.LastCreatedScene.activeCamera && EngineStore.LastCreatedScene.activeCamera.devicePosition) {
      const camera = EngineStore.LastCreatedScene.activeCamera;
      camera._computeDevicePosition();
      this._deviceToWorld.setTranslation(camera.devicePosition);
      if (camera.deviceRotationQuaternion) {
        camera._deviceRoomRotationQuaternion.toEulerAnglesToRef(TmpVectors.Vector3[0]);
        const distanceAway = Math.atan2(Math.sin(TmpVectors.Vector3[0].y - this._draggedRoomRotation), Math.cos(TmpVectors.Vector3[0].y - this._draggedRoomRotation));
        if (Math.abs(distanceAway) > this._maxRotationDistFromHeadset) {
          const rotationAmount = distanceAway - (distanceAway < 0 ? -this._maxRotationDistFromHeadset : this._maxRotationDistFromHeadset);
          this._draggedRoomRotation += rotationAmount;
          const sin = Math.sin(-rotationAmount);
          const cos = Math.cos(-rotationAmount);
          this._calculatedPosition.x = this._calculatedPosition.x * cos - this._calculatedPosition.z * sin;
          this._calculatedPosition.z = this._calculatedPosition.x * sin + this._calculatedPosition.z * cos;
        }
      }
    }
    Vector3.TransformCoordinatesToRef(this._calculatedPosition, this._deviceToWorld, this.devicePosition);
    this._deviceToWorld.getRotationMatrixToRef(this._workingMatrix);
    Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);
    this.deviceRotationQuaternion.multiplyInPlace(this._calculatedRotation);
    if (this._mesh) {
      this._mesh.position.copyFrom(this.devicePosition);
      if (this._mesh.rotationQuaternion) {
        this._mesh.rotationQuaternion.copyFrom(this.deviceRotationQuaternion);
      }
    }
  }
  updateFromDevice(poseData) {
    if (this.isXR) {
      return;
    }
    if (poseData) {
      this.rawPose = poseData;
      if (poseData.position) {
        this._deviceRoomPosition.copyFromFloats(poseData.position[0], poseData.position[1], -poseData.position[2]);
        if (this._mesh && this._mesh.getScene().useRightHandedSystem) {
          this._deviceRoomPosition.z *= -1;
        }
        if (this._trackPosition) {
          this._deviceRoomPosition.scaleToRef(this.deviceScaleFactor, this._calculatedPosition);
        }
        this._calculatedPosition.addInPlace(this.position);
      }
      const pose = this.rawPose;
      if (poseData.orientation && pose.orientation && pose.orientation.length === 4) {
        this._deviceRoomRotationQuaternion.copyFromFloats(pose.orientation[0], pose.orientation[1], -pose.orientation[2], -pose.orientation[3]);
        if (this._mesh) {
          if (this._mesh.getScene().useRightHandedSystem) {
            this._deviceRoomRotationQuaternion.z *= -1;
            this._deviceRoomRotationQuaternion.w *= -1;
          } else {
            this._deviceRoomRotationQuaternion.multiplyToRef(this._leftHandSystemQuaternion, this._deviceRoomRotationQuaternion);
          }
        }
        this._deviceRoomRotationQuaternion.multiplyToRef(this.rotationQuaternion, this._calculatedRotation);
      }
    }
  }
  attachToMesh(mesh) {
    if (this._mesh) {
      this._mesh.parent = null;
    }
    this._mesh = mesh;
    if (this._poseControlledCamera) {
      this._mesh.parent = this._poseControlledCamera;
    }
    if (!this._mesh.rotationQuaternion) {
      this._mesh.rotationQuaternion = new Quaternion();
    }
    if (!this.isXR) {
      this._updatePoseAndMesh();
      if (this._pointingPoseNode) {
        const parents = [];
        let obj = this._pointingPoseNode;
        while (obj.parent) {
          parents.push(obj.parent);
          obj = obj.parent;
        }
        parents.reverse().forEach((p) => {
          p.computeWorldMatrix(true);
        });
      }
    }
    this._meshAttachedObservable.notifyObservers(mesh);
  }
  attachToPoseControlledCamera(camera) {
    this._poseControlledCamera = camera;
    if (this._mesh) {
      this._mesh.parent = this._poseControlledCamera;
    }
  }
  dispose() {
    if (this._mesh) {
      this._mesh.dispose();
    }
    this._mesh = null;
    super.dispose();
  }
  get mesh() {
    return this._mesh;
  }
  getForwardRay(length = 100) {
    if (!this.mesh) {
      return new Ray(Vector3.Zero(), new Vector3(0, 0, 1), length);
    }
    const m = this._pointingPoseNode ? this._pointingPoseNode.getWorldMatrix() : this.mesh.getWorldMatrix();
    const origin = m.getTranslation();
    const forward = new Vector3(0, 0, -1);
    const forwardWorld = Vector3.TransformNormal(forward, m);
    const direction = Vector3.Normalize(forwardWorld);
    return new Ray(origin, direction, length);
  }
};
PoseEnabledController.POINTING_POSE = "POINTING_POSE";

// node_modules/@babylonjs/core/Gamepads/xboxGamepad.js
var Xbox360Button;
(function(Xbox360Button2) {
  Xbox360Button2[Xbox360Button2["A"] = 0] = "A";
  Xbox360Button2[Xbox360Button2["B"] = 1] = "B";
  Xbox360Button2[Xbox360Button2["X"] = 2] = "X";
  Xbox360Button2[Xbox360Button2["Y"] = 3] = "Y";
  Xbox360Button2[Xbox360Button2["LB"] = 4] = "LB";
  Xbox360Button2[Xbox360Button2["RB"] = 5] = "RB";
  Xbox360Button2[Xbox360Button2["Back"] = 8] = "Back";
  Xbox360Button2[Xbox360Button2["Start"] = 9] = "Start";
  Xbox360Button2[Xbox360Button2["LeftStick"] = 10] = "LeftStick";
  Xbox360Button2[Xbox360Button2["RightStick"] = 11] = "RightStick";
})(Xbox360Button || (Xbox360Button = {}));
var Xbox360Dpad;
(function(Xbox360Dpad2) {
  Xbox360Dpad2[Xbox360Dpad2["Up"] = 12] = "Up";
  Xbox360Dpad2[Xbox360Dpad2["Down"] = 13] = "Down";
  Xbox360Dpad2[Xbox360Dpad2["Left"] = 14] = "Left";
  Xbox360Dpad2[Xbox360Dpad2["Right"] = 15] = "Right";
})(Xbox360Dpad || (Xbox360Dpad = {}));
var Xbox360Pad = class extends Gamepad {
  constructor(id, index, gamepad, xboxOne = false) {
    super(id, index, gamepad, 0, 1, 2, 3);
    this._leftTrigger = 0;
    this._rightTrigger = 0;
    this.onButtonDownObservable = new Observable();
    this.onButtonUpObservable = new Observable();
    this.onPadDownObservable = new Observable();
    this.onPadUpObservable = new Observable();
    this._buttonA = 0;
    this._buttonB = 0;
    this._buttonX = 0;
    this._buttonY = 0;
    this._buttonBack = 0;
    this._buttonStart = 0;
    this._buttonLB = 0;
    this._buttonRB = 0;
    this._buttonLeftStick = 0;
    this._buttonRightStick = 0;
    this._dPadUp = 0;
    this._dPadDown = 0;
    this._dPadLeft = 0;
    this._dPadRight = 0;
    this._isXboxOnePad = false;
    this.type = Gamepad.XBOX;
    this._isXboxOnePad = xboxOne;
  }
  onlefttriggerchanged(callback) {
    this._onlefttriggerchanged = callback;
  }
  onrighttriggerchanged(callback) {
    this._onrighttriggerchanged = callback;
  }
  get leftTrigger() {
    return this._leftTrigger;
  }
  set leftTrigger(newValue) {
    if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {
      this._onlefttriggerchanged(newValue);
    }
    this._leftTrigger = newValue;
  }
  get rightTrigger() {
    return this._rightTrigger;
  }
  set rightTrigger(newValue) {
    if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {
      this._onrighttriggerchanged(newValue);
    }
    this._rightTrigger = newValue;
  }
  onbuttondown(callback) {
    this._onbuttondown = callback;
  }
  onbuttonup(callback) {
    this._onbuttonup = callback;
  }
  ondpaddown(callback) {
    this._ondpaddown = callback;
  }
  ondpadup(callback) {
    this._ondpadup = callback;
  }
  _setButtonValue(newValue, currentValue, buttonType) {
    if (newValue !== currentValue) {
      if (newValue === 1) {
        if (this._onbuttondown) {
          this._onbuttondown(buttonType);
        }
        this.onButtonDownObservable.notifyObservers(buttonType);
      }
      if (newValue === 0) {
        if (this._onbuttonup) {
          this._onbuttonup(buttonType);
        }
        this.onButtonUpObservable.notifyObservers(buttonType);
      }
    }
    return newValue;
  }
  _setDPadValue(newValue, currentValue, buttonType) {
    if (newValue !== currentValue) {
      if (newValue === 1) {
        if (this._ondpaddown) {
          this._ondpaddown(buttonType);
        }
        this.onPadDownObservable.notifyObservers(buttonType);
      }
      if (newValue === 0) {
        if (this._ondpadup) {
          this._ondpadup(buttonType);
        }
        this.onPadUpObservable.notifyObservers(buttonType);
      }
    }
    return newValue;
  }
  get buttonA() {
    return this._buttonA;
  }
  set buttonA(value) {
    this._buttonA = this._setButtonValue(value, this._buttonA, Xbox360Button.A);
  }
  get buttonB() {
    return this._buttonB;
  }
  set buttonB(value) {
    this._buttonB = this._setButtonValue(value, this._buttonB, Xbox360Button.B);
  }
  get buttonX() {
    return this._buttonX;
  }
  set buttonX(value) {
    this._buttonX = this._setButtonValue(value, this._buttonX, Xbox360Button.X);
  }
  get buttonY() {
    return this._buttonY;
  }
  set buttonY(value) {
    this._buttonY = this._setButtonValue(value, this._buttonY, Xbox360Button.Y);
  }
  get buttonStart() {
    return this._buttonStart;
  }
  set buttonStart(value) {
    this._buttonStart = this._setButtonValue(value, this._buttonStart, Xbox360Button.Start);
  }
  get buttonBack() {
    return this._buttonBack;
  }
  set buttonBack(value) {
    this._buttonBack = this._setButtonValue(value, this._buttonBack, Xbox360Button.Back);
  }
  get buttonLB() {
    return this._buttonLB;
  }
  set buttonLB(value) {
    this._buttonLB = this._setButtonValue(value, this._buttonLB, Xbox360Button.LB);
  }
  get buttonRB() {
    return this._buttonRB;
  }
  set buttonRB(value) {
    this._buttonRB = this._setButtonValue(value, this._buttonRB, Xbox360Button.RB);
  }
  get buttonLeftStick() {
    return this._buttonLeftStick;
  }
  set buttonLeftStick(value) {
    this._buttonLeftStick = this._setButtonValue(value, this._buttonLeftStick, Xbox360Button.LeftStick);
  }
  get buttonRightStick() {
    return this._buttonRightStick;
  }
  set buttonRightStick(value) {
    this._buttonRightStick = this._setButtonValue(value, this._buttonRightStick, Xbox360Button.RightStick);
  }
  get dPadUp() {
    return this._dPadUp;
  }
  set dPadUp(value) {
    this._dPadUp = this._setDPadValue(value, this._dPadUp, Xbox360Dpad.Up);
  }
  get dPadDown() {
    return this._dPadDown;
  }
  set dPadDown(value) {
    this._dPadDown = this._setDPadValue(value, this._dPadDown, Xbox360Dpad.Down);
  }
  get dPadLeft() {
    return this._dPadLeft;
  }
  set dPadLeft(value) {
    this._dPadLeft = this._setDPadValue(value, this._dPadLeft, Xbox360Dpad.Left);
  }
  get dPadRight() {
    return this._dPadRight;
  }
  set dPadRight(value) {
    this._dPadRight = this._setDPadValue(value, this._dPadRight, Xbox360Dpad.Right);
  }
  update() {
    super.update();
    if (this._isXboxOnePad) {
      this.buttonA = this.browserGamepad.buttons[0].value;
      this.buttonB = this.browserGamepad.buttons[1].value;
      this.buttonX = this.browserGamepad.buttons[2].value;
      this.buttonY = this.browserGamepad.buttons[3].value;
      this.buttonLB = this.browserGamepad.buttons[4].value;
      this.buttonRB = this.browserGamepad.buttons[5].value;
      this.leftTrigger = this.browserGamepad.buttons[6].value;
      this.rightTrigger = this.browserGamepad.buttons[7].value;
      this.buttonBack = this.browserGamepad.buttons[8].value;
      this.buttonStart = this.browserGamepad.buttons[9].value;
      this.buttonLeftStick = this.browserGamepad.buttons[10].value;
      this.buttonRightStick = this.browserGamepad.buttons[11].value;
      this.dPadUp = this.browserGamepad.buttons[12].value;
      this.dPadDown = this.browserGamepad.buttons[13].value;
      this.dPadLeft = this.browserGamepad.buttons[14].value;
      this.dPadRight = this.browserGamepad.buttons[15].value;
    } else {
      this.buttonA = this.browserGamepad.buttons[0].value;
      this.buttonB = this.browserGamepad.buttons[1].value;
      this.buttonX = this.browserGamepad.buttons[2].value;
      this.buttonY = this.browserGamepad.buttons[3].value;
      this.buttonLB = this.browserGamepad.buttons[4].value;
      this.buttonRB = this.browserGamepad.buttons[5].value;
      this.leftTrigger = this.browserGamepad.buttons[6].value;
      this.rightTrigger = this.browserGamepad.buttons[7].value;
      this.buttonBack = this.browserGamepad.buttons[8].value;
      this.buttonStart = this.browserGamepad.buttons[9].value;
      this.buttonLeftStick = this.browserGamepad.buttons[10].value;
      this.buttonRightStick = this.browserGamepad.buttons[11].value;
      this.dPadUp = this.browserGamepad.buttons[12].value;
      this.dPadDown = this.browserGamepad.buttons[13].value;
      this.dPadLeft = this.browserGamepad.buttons[14].value;
      this.dPadRight = this.browserGamepad.buttons[15].value;
    }
  }
  dispose() {
    super.dispose();
    this.onButtonDownObservable.clear();
    this.onButtonUpObservable.clear();
    this.onPadDownObservable.clear();
    this.onPadUpObservable.clear();
  }
};

// node_modules/@babylonjs/core/Gamepads/dualShockGamepad.js
var DualShockButton;
(function(DualShockButton2) {
  DualShockButton2[DualShockButton2["Cross"] = 0] = "Cross";
  DualShockButton2[DualShockButton2["Circle"] = 1] = "Circle";
  DualShockButton2[DualShockButton2["Square"] = 2] = "Square";
  DualShockButton2[DualShockButton2["Triangle"] = 3] = "Triangle";
  DualShockButton2[DualShockButton2["L1"] = 4] = "L1";
  DualShockButton2[DualShockButton2["R1"] = 5] = "R1";
  DualShockButton2[DualShockButton2["Share"] = 8] = "Share";
  DualShockButton2[DualShockButton2["Options"] = 9] = "Options";
  DualShockButton2[DualShockButton2["LeftStick"] = 10] = "LeftStick";
  DualShockButton2[DualShockButton2["RightStick"] = 11] = "RightStick";
})(DualShockButton || (DualShockButton = {}));
var DualShockDpad;
(function(DualShockDpad2) {
  DualShockDpad2[DualShockDpad2["Up"] = 12] = "Up";
  DualShockDpad2[DualShockDpad2["Down"] = 13] = "Down";
  DualShockDpad2[DualShockDpad2["Left"] = 14] = "Left";
  DualShockDpad2[DualShockDpad2["Right"] = 15] = "Right";
})(DualShockDpad || (DualShockDpad = {}));
var DualShockPad = class extends Gamepad {
  constructor(id, index, gamepad) {
    super(id.replace("STANDARD GAMEPAD", "SONY PLAYSTATION DUALSHOCK"), index, gamepad, 0, 1, 2, 3);
    this._leftTrigger = 0;
    this._rightTrigger = 0;
    this.onButtonDownObservable = new Observable();
    this.onButtonUpObservable = new Observable();
    this.onPadDownObservable = new Observable();
    this.onPadUpObservable = new Observable();
    this._buttonCross = 0;
    this._buttonCircle = 0;
    this._buttonSquare = 0;
    this._buttonTriangle = 0;
    this._buttonShare = 0;
    this._buttonOptions = 0;
    this._buttonL1 = 0;
    this._buttonR1 = 0;
    this._buttonLeftStick = 0;
    this._buttonRightStick = 0;
    this._dPadUp = 0;
    this._dPadDown = 0;
    this._dPadLeft = 0;
    this._dPadRight = 0;
    this.type = Gamepad.DUALSHOCK;
  }
  onlefttriggerchanged(callback) {
    this._onlefttriggerchanged = callback;
  }
  onrighttriggerchanged(callback) {
    this._onrighttriggerchanged = callback;
  }
  get leftTrigger() {
    return this._leftTrigger;
  }
  set leftTrigger(newValue) {
    if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {
      this._onlefttriggerchanged(newValue);
    }
    this._leftTrigger = newValue;
  }
  get rightTrigger() {
    return this._rightTrigger;
  }
  set rightTrigger(newValue) {
    if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {
      this._onrighttriggerchanged(newValue);
    }
    this._rightTrigger = newValue;
  }
  onbuttondown(callback) {
    this._onbuttondown = callback;
  }
  onbuttonup(callback) {
    this._onbuttonup = callback;
  }
  ondpaddown(callback) {
    this._ondpaddown = callback;
  }
  ondpadup(callback) {
    this._ondpadup = callback;
  }
  _setButtonValue(newValue, currentValue, buttonType) {
    if (newValue !== currentValue) {
      if (newValue === 1) {
        if (this._onbuttondown) {
          this._onbuttondown(buttonType);
        }
        this.onButtonDownObservable.notifyObservers(buttonType);
      }
      if (newValue === 0) {
        if (this._onbuttonup) {
          this._onbuttonup(buttonType);
        }
        this.onButtonUpObservable.notifyObservers(buttonType);
      }
    }
    return newValue;
  }
  _setDPadValue(newValue, currentValue, buttonType) {
    if (newValue !== currentValue) {
      if (newValue === 1) {
        if (this._ondpaddown) {
          this._ondpaddown(buttonType);
        }
        this.onPadDownObservable.notifyObservers(buttonType);
      }
      if (newValue === 0) {
        if (this._ondpadup) {
          this._ondpadup(buttonType);
        }
        this.onPadUpObservable.notifyObservers(buttonType);
      }
    }
    return newValue;
  }
  get buttonCross() {
    return this._buttonCross;
  }
  set buttonCross(value) {
    this._buttonCross = this._setButtonValue(value, this._buttonCross, DualShockButton.Cross);
  }
  get buttonCircle() {
    return this._buttonCircle;
  }
  set buttonCircle(value) {
    this._buttonCircle = this._setButtonValue(value, this._buttonCircle, DualShockButton.Circle);
  }
  get buttonSquare() {
    return this._buttonSquare;
  }
  set buttonSquare(value) {
    this._buttonSquare = this._setButtonValue(value, this._buttonSquare, DualShockButton.Square);
  }
  get buttonTriangle() {
    return this._buttonTriangle;
  }
  set buttonTriangle(value) {
    this._buttonTriangle = this._setButtonValue(value, this._buttonTriangle, DualShockButton.Triangle);
  }
  get buttonOptions() {
    return this._buttonOptions;
  }
  set buttonOptions(value) {
    this._buttonOptions = this._setButtonValue(value, this._buttonOptions, DualShockButton.Options);
  }
  get buttonShare() {
    return this._buttonShare;
  }
  set buttonShare(value) {
    this._buttonShare = this._setButtonValue(value, this._buttonShare, DualShockButton.Share);
  }
  get buttonL1() {
    return this._buttonL1;
  }
  set buttonL1(value) {
    this._buttonL1 = this._setButtonValue(value, this._buttonL1, DualShockButton.L1);
  }
  get buttonR1() {
    return this._buttonR1;
  }
  set buttonR1(value) {
    this._buttonR1 = this._setButtonValue(value, this._buttonR1, DualShockButton.R1);
  }
  get buttonLeftStick() {
    return this._buttonLeftStick;
  }
  set buttonLeftStick(value) {
    this._buttonLeftStick = this._setButtonValue(value, this._buttonLeftStick, DualShockButton.LeftStick);
  }
  get buttonRightStick() {
    return this._buttonRightStick;
  }
  set buttonRightStick(value) {
    this._buttonRightStick = this._setButtonValue(value, this._buttonRightStick, DualShockButton.RightStick);
  }
  get dPadUp() {
    return this._dPadUp;
  }
  set dPadUp(value) {
    this._dPadUp = this._setDPadValue(value, this._dPadUp, DualShockDpad.Up);
  }
  get dPadDown() {
    return this._dPadDown;
  }
  set dPadDown(value) {
    this._dPadDown = this._setDPadValue(value, this._dPadDown, DualShockDpad.Down);
  }
  get dPadLeft() {
    return this._dPadLeft;
  }
  set dPadLeft(value) {
    this._dPadLeft = this._setDPadValue(value, this._dPadLeft, DualShockDpad.Left);
  }
  get dPadRight() {
    return this._dPadRight;
  }
  set dPadRight(value) {
    this._dPadRight = this._setDPadValue(value, this._dPadRight, DualShockDpad.Right);
  }
  update() {
    super.update();
    this.buttonCross = this.browserGamepad.buttons[0].value;
    this.buttonCircle = this.browserGamepad.buttons[1].value;
    this.buttonSquare = this.browserGamepad.buttons[2].value;
    this.buttonTriangle = this.browserGamepad.buttons[3].value;
    this.buttonL1 = this.browserGamepad.buttons[4].value;
    this.buttonR1 = this.browserGamepad.buttons[5].value;
    this.leftTrigger = this.browserGamepad.buttons[6].value;
    this.rightTrigger = this.browserGamepad.buttons[7].value;
    this.buttonShare = this.browserGamepad.buttons[8].value;
    this.buttonOptions = this.browserGamepad.buttons[9].value;
    this.buttonLeftStick = this.browserGamepad.buttons[10].value;
    this.buttonRightStick = this.browserGamepad.buttons[11].value;
    this.dPadUp = this.browserGamepad.buttons[12].value;
    this.dPadDown = this.browserGamepad.buttons[13].value;
    this.dPadLeft = this.browserGamepad.buttons[14].value;
    this.dPadRight = this.browserGamepad.buttons[15].value;
  }
  dispose() {
    super.dispose();
    this.onButtonDownObservable.clear();
    this.onButtonUpObservable.clear();
    this.onPadDownObservable.clear();
    this.onPadUpObservable.clear();
  }
};

// node_modules/@babylonjs/core/Gamepads/gamepadManager.js
var GamepadManager = class {
  constructor(_scene) {
    this._scene = _scene;
    this._babylonGamepads = [];
    this._oneGamepadConnected = false;
    this._isMonitoring = false;
    this.onGamepadDisconnectedObservable = new Observable();
    if (!IsWindowObjectExist()) {
      this._gamepadEventSupported = false;
    } else {
      this._gamepadEventSupported = "GamepadEvent" in window;
      this._gamepadSupport = navigator && navigator.getGamepads;
    }
    this.onGamepadConnectedObservable = new Observable((observer) => {
      for (const i in this._babylonGamepads) {
        const gamepad = this._babylonGamepads[i];
        if (gamepad && gamepad._isConnected) {
          this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);
        }
      }
    });
    this._onGamepadConnectedEvent = (evt) => {
      const gamepad = evt.gamepad;
      if (gamepad.index in this._babylonGamepads) {
        if (this._babylonGamepads[gamepad.index].isConnected) {
          return;
        }
      }
      let newGamepad;
      if (this._babylonGamepads[gamepad.index]) {
        newGamepad = this._babylonGamepads[gamepad.index];
        newGamepad.browserGamepad = gamepad;
        newGamepad._isConnected = true;
      } else {
        newGamepad = this._addNewGamepad(gamepad);
      }
      this.onGamepadConnectedObservable.notifyObservers(newGamepad);
      this._startMonitoringGamepads();
    };
    this._onGamepadDisconnectedEvent = (evt) => {
      const gamepad = evt.gamepad;
      for (const i in this._babylonGamepads) {
        if (this._babylonGamepads[i].index === gamepad.index) {
          const disconnectedGamepad = this._babylonGamepads[i];
          disconnectedGamepad._isConnected = false;
          this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);
          disconnectedGamepad.dispose && disconnectedGamepad.dispose();
          break;
        }
      }
    };
    if (this._gamepadSupport) {
      this._updateGamepadObjects();
      if (this._babylonGamepads.length) {
        this._startMonitoringGamepads();
      }
      if (this._gamepadEventSupported) {
        const hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;
        if (hostWindow) {
          hostWindow.addEventListener("gamepadconnected", this._onGamepadConnectedEvent, false);
          hostWindow.addEventListener("gamepaddisconnected", this._onGamepadDisconnectedEvent, false);
        }
      } else {
        this._startMonitoringGamepads();
      }
    }
  }
  get gamepads() {
    return this._babylonGamepads;
  }
  getGamepadByType(type = Gamepad.XBOX) {
    for (const gamepad of this._babylonGamepads) {
      if (gamepad && gamepad.type === type) {
        return gamepad;
      }
    }
    return null;
  }
  dispose() {
    if (this._gamepadEventSupported) {
      if (this._onGamepadConnectedEvent) {
        window.removeEventListener("gamepadconnected", this._onGamepadConnectedEvent);
      }
      if (this._onGamepadDisconnectedEvent) {
        window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnectedEvent);
      }
      this._onGamepadConnectedEvent = null;
      this._onGamepadDisconnectedEvent = null;
    }
    this._babylonGamepads.forEach((gamepad) => {
      gamepad.dispose();
    });
    this.onGamepadConnectedObservable.clear();
    this.onGamepadDisconnectedObservable.clear();
    this._oneGamepadConnected = false;
    this._stopMonitoringGamepads();
    this._babylonGamepads = [];
  }
  _addNewGamepad(gamepad) {
    if (!this._oneGamepadConnected) {
      this._oneGamepadConnected = true;
    }
    let newGamepad;
    const dualShock = gamepad.id.search("054c") !== -1 && gamepad.id.search("0ce6") === -1;
    const xboxOne = gamepad.id.search("Xbox One") !== -1;
    if (xboxOne || gamepad.id.search("Xbox 360") !== -1 || gamepad.id.search("xinput") !== -1 || gamepad.id.search("045e") !== -1 && gamepad.id.search("Surface Dock") === -1) {
      newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);
    } else if (dualShock) {
      newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);
    } else if (gamepad.pose) {
      newGamepad = PoseEnabledControllerHelper.InitiateController(gamepad);
    } else {
      newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);
    }
    this._babylonGamepads[newGamepad.index] = newGamepad;
    return newGamepad;
  }
  _startMonitoringGamepads() {
    if (!this._isMonitoring) {
      this._isMonitoring = true;
      if (!this._scene) {
        this._checkGamepadsStatus();
      }
    }
  }
  _stopMonitoringGamepads() {
    this._isMonitoring = false;
  }
  _checkGamepadsStatus() {
    this._updateGamepadObjects();
    for (const i in this._babylonGamepads) {
      const gamepad = this._babylonGamepads[i];
      if (!gamepad || !gamepad.isConnected) {
        continue;
      }
      try {
        gamepad.update();
      } catch (_a) {
        if (this._loggedErrors.indexOf(gamepad.index) === -1) {
          Tools.Warn(`Error updating gamepad ${gamepad.id}`);
          this._loggedErrors.push(gamepad.index);
        }
      }
    }
    if (this._isMonitoring && !this._scene) {
      Engine.QueueNewFrame(() => {
        this._checkGamepadsStatus();
      });
    }
  }
  _updateGamepadObjects() {
    const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
    for (let i = 0; i < gamepads.length; i++) {
      const gamepad = gamepads[i];
      if (gamepad) {
        if (!this._babylonGamepads[gamepad.index]) {
          const newGamepad = this._addNewGamepad(gamepad);
          this.onGamepadConnectedObservable.notifyObservers(newGamepad);
        } else {
          this._babylonGamepads[i].browserGamepad = gamepad;
          if (!this._babylonGamepads[i].isConnected) {
            this._babylonGamepads[i]._isConnected = true;
            this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);
          }
        }
      }
    }
  }
};

// node_modules/@babylonjs/core/Gamepads/gamepadSceneComponent.js
Object.defineProperty(Scene.prototype, "gamepadManager", {
  get: function() {
    if (!this._gamepadManager) {
      this._gamepadManager = new GamepadManager(this);
      let component = this._getComponent(SceneComponentConstants.NAME_GAMEPAD);
      if (!component) {
        component = new GamepadSystemSceneComponent(this);
        this._addComponent(component);
      }
    }
    return this._gamepadManager;
  },
  enumerable: true,
  configurable: true
});
FreeCameraInputsManager.prototype.addGamepad = function() {
  this.add(new FreeCameraGamepadInput());
  return this;
};
ArcRotateCameraInputsManager.prototype.addGamepad = function() {
  this.add(new ArcRotateCameraGamepadInput());
  return this;
};
var GamepadSystemSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_GAMEPAD;
    this.scene = scene;
  }
  register() {
    this.scene._beforeCameraUpdateStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERAUPDATE_GAMEPAD, this, this._beforeCameraUpdate);
  }
  rebuild() {
  }
  dispose() {
    const gamepadManager = this.scene._gamepadManager;
    if (gamepadManager) {
      gamepadManager.dispose();
      this.scene._gamepadManager = null;
    }
  }
  _beforeCameraUpdate() {
    const gamepadManager = this.scene._gamepadManager;
    if (gamepadManager && gamepadManager._isMonitoring) {
      gamepadManager._checkGamepadsStatus();
    }
  }
};

// node_modules/@babylonjs/core/Cameras/universalCamera.js
Node2.AddNodeConstructor("FreeCamera", (name137, scene) => {
  return () => new UniversalCamera(name137, Vector3.Zero(), scene);
});
var UniversalCamera = class extends TouchCamera {
  get gamepadAngularSensibility() {
    const gamepad = this.inputs.attached["gamepad"];
    if (gamepad) {
      return gamepad.gamepadAngularSensibility;
    }
    return 0;
  }
  set gamepadAngularSensibility(value) {
    const gamepad = this.inputs.attached["gamepad"];
    if (gamepad) {
      gamepad.gamepadAngularSensibility = value;
    }
  }
  get gamepadMoveSensibility() {
    const gamepad = this.inputs.attached["gamepad"];
    if (gamepad) {
      return gamepad.gamepadMoveSensibility;
    }
    return 0;
  }
  set gamepadMoveSensibility(value) {
    const gamepad = this.inputs.attached["gamepad"];
    if (gamepad) {
      gamepad.gamepadMoveSensibility = value;
    }
  }
  constructor(name137, position, scene) {
    super(name137, position, scene);
    this.inputs.addGamepad();
  }
  getClassName() {
    return "UniversalCamera";
  }
};
Camera._CreateDefaultParsedCamera = (name137, scene) => {
  return new UniversalCamera(name137, Vector3.Zero(), scene);
};

// node_modules/@babylonjs/core/Cameras/gamepadCamera.js
Node2.AddNodeConstructor("GamepadCamera", (name137, scene) => {
  return () => new GamepadCamera(name137, Vector3.Zero(), scene);
});
var GamepadCamera = class extends UniversalCamera {
  constructor(name137, position, scene) {
    super(name137, position, scene);
  }
  getClassName() {
    return "GamepadCamera";
  }
};

// node_modules/@babylonjs/core/Shaders/anaglyph.fragment.js
var name = "anaglyphPixelShader";
var shader = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform sampler2D leftSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
vec4 leftFrag=texture2D(leftSampler,vUV);
leftFrag=vec4(1.0,leftFrag.g,leftFrag.b,1.0);
vec4 rightFrag=texture2D(textureSampler,vUV);
rightFrag=vec4(rightFrag.r,1.0,1.0,1.0);
gl_FragColor=vec4(rightFrag.rgb*leftFrag.rgb,1.0);
}`;
ShaderStore.ShadersStore[name] = shader;

// node_modules/@babylonjs/core/PostProcesses/anaglyphPostProcess.js
var AnaglyphPostProcess = class extends PostProcess {
  constructor(name137, options, rigCameras, samplingMode, engine, reusable) {
    super(name137, "anaglyph", null, ["leftSampler"], options, rigCameras[1], samplingMode, engine, reusable);
    this._passedProcess = rigCameras[0]._rigPostProcess;
    this.onApplyObservable.add((effect) => {
      effect.setTextureFromPostProcess("leftSampler", this._passedProcess);
    });
  }
  getClassName() {
    return "AnaglyphPostProcess";
  }
};
RegisterClass("BABYLON.AnaglyphPostProcess", AnaglyphPostProcess);

// node_modules/@babylonjs/core/Cameras/RigModes/stereoscopicAnaglyphRigMode.js
function setStereoscopicAnaglyphRigMode(camera) {
  camera._rigCameras[0]._rigPostProcess = new PassPostProcess(camera.name + "_passthru", 1, camera._rigCameras[0]);
  camera._rigCameras[1]._rigPostProcess = new AnaglyphPostProcess(camera.name + "_anaglyph", 1, camera._rigCameras);
}

// node_modules/@babylonjs/core/Cameras/Stereoscopic/anaglyphArcRotateCamera.js
Node2.AddNodeConstructor("AnaglyphArcRotateCamera", (name137, scene, options) => {
  return () => new AnaglyphArcRotateCamera(name137, 0, 0, 1, Vector3.Zero(), options.interaxial_distance, scene);
});
var AnaglyphArcRotateCamera = class extends ArcRotateCamera {
  constructor(name137, alpha, beta, radius, target, interaxialDistance, scene) {
    super(name137, alpha, beta, radius, target, scene);
    this._setRigMode = setStereoscopicAnaglyphRigMode.bind(null, this);
    this.interaxialDistance = interaxialDistance;
    this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance });
  }
  getClassName() {
    return "AnaglyphArcRotateCamera";
  }
};

// node_modules/@babylonjs/core/Cameras/Stereoscopic/anaglyphFreeCamera.js
Node2.AddNodeConstructor("AnaglyphFreeCamera", (name137, scene, options) => {
  return () => new AnaglyphFreeCamera(name137, Vector3.Zero(), options.interaxial_distance, scene);
});
var AnaglyphFreeCamera = class extends FreeCamera {
  constructor(name137, position, interaxialDistance, scene) {
    super(name137, position, scene);
    this._setRigMode = setStereoscopicAnaglyphRigMode.bind(null, this);
    this.interaxialDistance = interaxialDistance;
    this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance });
  }
  getClassName() {
    return "AnaglyphFreeCamera";
  }
};

// node_modules/@babylonjs/core/Cameras/Stereoscopic/anaglyphGamepadCamera.js
Node2.AddNodeConstructor("AnaglyphGamepadCamera", (name137, scene, options) => {
  return () => new AnaglyphGamepadCamera(name137, Vector3.Zero(), options.interaxial_distance, scene);
});
var AnaglyphGamepadCamera = class extends GamepadCamera {
  constructor(name137, position, interaxialDistance, scene) {
    super(name137, position, scene);
    this._setRigMode = setStereoscopicAnaglyphRigMode.bind(null, this);
    this.interaxialDistance = interaxialDistance;
    this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance });
  }
  getClassName() {
    return "AnaglyphGamepadCamera";
  }
};

// node_modules/@babylonjs/core/Cameras/Stereoscopic/anaglyphUniversalCamera.js
Node2.AddNodeConstructor("AnaglyphUniversalCamera", (name137, scene, options) => {
  return () => new AnaglyphUniversalCamera(name137, Vector3.Zero(), options.interaxial_distance, scene);
});
var AnaglyphUniversalCamera = class extends UniversalCamera {
  constructor(name137, position, interaxialDistance, scene) {
    super(name137, position, scene);
    this._setRigMode = setStereoscopicAnaglyphRigMode.bind(null, this);
    this.interaxialDistance = interaxialDistance;
    this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance });
  }
  getClassName() {
    return "AnaglyphUniversalCamera";
  }
};

// node_modules/@babylonjs/core/Shaders/stereoscopicInterlace.fragment.js
var name2 = "stereoscopicInterlacePixelShader";
var shader2 = `const vec3 TWO=vec3(2.0,2.0,2.0);
varying vec2 vUV;
uniform sampler2D camASampler;
uniform sampler2D textureSampler;
uniform vec2 stepSize;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
bool useCamA;
bool useCamB;
vec2 texCoord1;
vec2 texCoord2;
vec3 frag1;
vec3 frag2;
#ifdef IS_STEREOSCOPIC_HORIZ
useCamB=vUV.x>0.5;
useCamA=!useCamB;
texCoord1=vec2(useCamB ? (vUV.x-0.5)*2.0 : vUV.x*2.0,vUV.y);
texCoord2=vec2(texCoord1.x+stepSize.x,vUV.y);
#else
#ifdef IS_STEREOSCOPIC_INTERLACED
float rowNum=floor(vUV.y/stepSize.y);
useCamA=mod(rowNum,2.0)==1.0;
useCamB=mod(rowNum,2.0)==0.0;
texCoord1=vec2(vUV.x,vUV.y);
texCoord2=vec2(vUV.x,vUV.y);
#else
useCamB=vUV.y>0.5;
useCamA=!useCamB;
texCoord1=vec2(vUV.x,useCamB ? (vUV.y-0.5)*2.0 : vUV.y*2.0);
texCoord2=vec2(vUV.x,texCoord1.y+stepSize.y);
#endif
#endif
if (useCamB){
frag1=texture2D(textureSampler,texCoord1).rgb;
frag2=texture2D(textureSampler,texCoord2).rgb;
}else if (useCamA){
frag1=texture2D(camASampler ,texCoord1).rgb;
frag2=texture2D(camASampler ,texCoord2).rgb;
}else {
discard;
}
gl_FragColor=vec4((frag1+frag2)/TWO,1.0);
}
`;
ShaderStore.ShadersStore[name2] = shader2;

// node_modules/@babylonjs/core/PostProcesses/stereoscopicInterlacePostProcess.js
var StereoscopicInterlacePostProcessI = class extends PostProcess {
  constructor(name137, rigCameras, isStereoscopicHoriz, isStereoscopicInterlaced, samplingMode, engine, reusable) {
    super(name137, "stereoscopicInterlace", ["stepSize"], ["camASampler"], 1, rigCameras[1], samplingMode, engine, reusable, isStereoscopicInterlaced ? "#define IS_STEREOSCOPIC_INTERLACED 1" : isStereoscopicHoriz ? "#define IS_STEREOSCOPIC_HORIZ 1" : void 0);
    this._passedProcess = rigCameras[0]._rigPostProcess;
    this._stepSize = new Vector2(1 / this.width, 1 / this.height);
    this.onSizeChangedObservable.add(() => {
      this._stepSize = new Vector2(1 / this.width, 1 / this.height);
    });
    this.onApplyObservable.add((effect) => {
      effect.setTextureFromPostProcess("camASampler", this._passedProcess);
      effect.setFloat2("stepSize", this._stepSize.x, this._stepSize.y);
    });
  }
  getClassName() {
    return "StereoscopicInterlacePostProcessI";
  }
};
var StereoscopicInterlacePostProcess = class extends PostProcess {
  constructor(name137, rigCameras, isStereoscopicHoriz, samplingMode, engine, reusable) {
    super(name137, "stereoscopicInterlace", ["stepSize"], ["camASampler"], 1, rigCameras[1], samplingMode, engine, reusable, isStereoscopicHoriz ? "#define IS_STEREOSCOPIC_HORIZ 1" : void 0);
    this._passedProcess = rigCameras[0]._rigPostProcess;
    this._stepSize = new Vector2(1 / this.width, 1 / this.height);
    this.onSizeChangedObservable.add(() => {
      this._stepSize = new Vector2(1 / this.width, 1 / this.height);
    });
    this.onApplyObservable.add((effect) => {
      effect.setTextureFromPostProcess("camASampler", this._passedProcess);
      effect.setFloat2("stepSize", this._stepSize.x, this._stepSize.y);
    });
  }
  getClassName() {
    return "StereoscopicInterlacePostProcess";
  }
};

// node_modules/@babylonjs/core/Cameras/RigModes/stereoscopicRigMode.js
function setStereoscopicRigMode(camera) {
  const isStereoscopicHoriz = camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL || camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;
  const isCrossEye = camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;
  const isInterlaced = camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_INTERLACED;
  if (isInterlaced) {
    camera._rigCameras[0]._rigPostProcess = new PassPostProcess(camera.name + "_passthru", 1, camera._rigCameras[0]);
    camera._rigCameras[1]._rigPostProcess = new StereoscopicInterlacePostProcessI(camera.name + "_stereoInterlace", camera._rigCameras, false, true);
  } else {
    camera._rigCameras[isCrossEye ? 1 : 0].viewport = new Viewport(0, 0, isStereoscopicHoriz ? 0.5 : 1, isStereoscopicHoriz ? 1 : 0.5);
    camera._rigCameras[isCrossEye ? 0 : 1].viewport = new Viewport(isStereoscopicHoriz ? 0.5 : 0, isStereoscopicHoriz ? 0 : 0.5, isStereoscopicHoriz ? 0.5 : 1, isStereoscopicHoriz ? 1 : 0.5);
  }
}

// node_modules/@babylonjs/core/Cameras/Stereoscopic/stereoscopicArcRotateCamera.js
Node2.AddNodeConstructor("StereoscopicArcRotateCamera", (name137, scene, options) => {
  return () => new StereoscopicArcRotateCamera(name137, 0, 0, 1, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);
});
var StereoscopicArcRotateCamera = class extends ArcRotateCamera {
  constructor(name137, alpha, beta, radius, target, interaxialDistance, isStereoscopicSideBySide, scene) {
    super(name137, alpha, beta, radius, target, scene);
    this._setRigMode = setStereoscopicRigMode.bind(null, this);
    this.interaxialDistance = interaxialDistance;
    this.isStereoscopicSideBySide = isStereoscopicSideBySide;
    this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {
      interaxialDistance
    });
  }
  getClassName() {
    return "StereoscopicArcRotateCamera";
  }
};

// node_modules/@babylonjs/core/Cameras/Stereoscopic/stereoscopicFreeCamera.js
Node2.AddNodeConstructor("StereoscopicFreeCamera", (name137, scene, options) => {
  return () => new StereoscopicFreeCamera(name137, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);
});
var StereoscopicFreeCamera = class extends FreeCamera {
  constructor(name137, position, interaxialDistance, isStereoscopicSideBySide, scene) {
    super(name137, position, scene);
    this._setRigMode = setStereoscopicRigMode.bind(null, this);
    this.interaxialDistance = interaxialDistance;
    this.isStereoscopicSideBySide = isStereoscopicSideBySide;
    this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {
      interaxialDistance
    });
  }
  getClassName() {
    return "StereoscopicFreeCamera";
  }
};

// node_modules/@babylonjs/core/Cameras/Stereoscopic/stereoscopicGamepadCamera.js
Node2.AddNodeConstructor("StereoscopicGamepadCamera", (name137, scene, options) => {
  return () => new StereoscopicGamepadCamera(name137, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);
});
var StereoscopicGamepadCamera = class extends GamepadCamera {
  constructor(name137, position, interaxialDistance, isStereoscopicSideBySide, scene) {
    super(name137, position, scene);
    this._setRigMode = setStereoscopicRigMode.bind(null, this);
    this.interaxialDistance = interaxialDistance;
    this.isStereoscopicSideBySide = isStereoscopicSideBySide;
    this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {
      interaxialDistance
    });
  }
  getClassName() {
    return "StereoscopicGamepadCamera";
  }
};

// node_modules/@babylonjs/core/Cameras/Stereoscopic/stereoscopicUniversalCamera.js
Node2.AddNodeConstructor("StereoscopicFreeCamera", (name137, scene, options) => {
  return () => new StereoscopicUniversalCamera(name137, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);
});
var StereoscopicUniversalCamera = class extends UniversalCamera {
  constructor(name137, position, interaxialDistance, isStereoscopicSideBySide, scene) {
    super(name137, position, scene);
    this._setRigMode = setStereoscopicRigMode.bind(null, this);
    this.interaxialDistance = interaxialDistance;
    this.isStereoscopicSideBySide = isStereoscopicSideBySide;
    this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {
      interaxialDistance
    });
  }
  getClassName() {
    return "StereoscopicUniversalCamera";
  }
};

// node_modules/@babylonjs/core/Cameras/Stereoscopic/stereoscopicScreenUniversalCamera.js
var StereoscopicScreenUniversalCamera = class extends UniversalCamera {
  constructor(name137, position, scene, distanceToProjectionPlane = 1, distanceBetweenEyes = 0.065) {
    super(name137, position, scene);
    this._distanceBetweenEyes = distanceBetweenEyes;
    this._distanceToProjectionPlane = distanceToProjectionPlane;
    this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL, {
      stereoHalfAngle: 0
    });
    this._cameraRigParams.stereoHalfAngle = 0;
    this._cameraRigParams.interaxialDistance = distanceBetweenEyes;
  }
  set distanceBetweenEyes(newValue) {
    this._distanceBetweenEyes = newValue;
  }
  get distanceBetweenEyes() {
    return this._distanceBetweenEyes;
  }
  set distanceToProjectionPlane(newValue) {
    this._distanceToProjectionPlane = newValue;
  }
  get distanceToProjectionPlane() {
    return this._distanceToProjectionPlane;
  }
  getClassName() {
    return "StereoscopicUniversalCamera";
  }
  createRigCamera(name137) {
    const camera = new TargetCamera(name137, Vector3.Zero(), this.getScene());
    const transform = new TransformNode("tm_" + name137, this.getScene());
    camera.parent = transform;
    transform.setPivotMatrix(Matrix.Identity(), false);
    camera.isRigCamera = true;
    camera.rigParent = this;
    return camera;
  }
  _updateRigCameras() {
    for (let cameraIndex = 0; cameraIndex < this._rigCameras.length; cameraIndex++) {
      const cam = this._rigCameras[cameraIndex];
      cam.minZ = this.minZ;
      cam.maxZ = this.maxZ;
      cam.fov = this.fov;
      cam.upVector.copyFrom(this.upVector);
      if (cam.rotationQuaternion) {
        cam.rotationQuaternion.copyFrom(this.rotationQuaternion);
      } else {
        cam.rotation.copyFrom(this.rotation);
      }
      this._updateCamera(this._rigCameras[cameraIndex], cameraIndex);
    }
  }
  _updateCamera(camera, cameraIndex) {
    const b = this.distanceBetweenEyes / 2;
    const z = b / this.distanceToProjectionPlane;
    camera.position.copyFrom(this.position);
    camera.position.addInPlaceFromFloats(cameraIndex === 0 ? -b : b, 0, -this._distanceToProjectionPlane);
    const transform = camera.parent;
    const m = transform.getPivotMatrix();
    m.setTranslationFromFloats(cameraIndex === 0 ? b : -b, 0, 0);
    m.setRowFromFloats(2, cameraIndex === 0 ? z : -z, 0, 1, 0);
    transform.setPivotMatrix(m, false);
  }
  _setRigMode() {
    this._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1);
    this._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1);
    for (let cameraIndex = 0; cameraIndex < this._rigCameras.length; cameraIndex++) {
      this._updateCamera(this._rigCameras[cameraIndex], cameraIndex);
    }
  }
};

// node_modules/@babylonjs/core/Cameras/virtualJoysticksCamera.js
Node2.AddNodeConstructor("VirtualJoysticksCamera", (name137, scene) => {
  return () => new VirtualJoysticksCamera(name137, Vector3.Zero(), scene);
});
var VirtualJoysticksCamera = class extends FreeCamera {
  constructor(name137, position, scene) {
    super(name137, position, scene);
    this.inputs.addVirtualJoystick();
  }
  getClassName() {
    return "VirtualJoysticksCamera";
  }
};

// node_modules/@babylonjs/core/Cameras/VR/vrCameraMetrics.js
var VRCameraMetrics = class {
  constructor() {
    this.compensateDistortion = true;
    this.multiviewEnabled = false;
  }
  get aspectRatio() {
    return this.hResolution / (2 * this.vResolution);
  }
  get aspectRatioFov() {
    return 2 * Math.atan(this.postProcessScaleFactor * this.vScreenSize / (2 * this.eyeToScreenDistance));
  }
  get leftHMatrix() {
    const meters = this.hScreenSize / 4 - this.lensSeparationDistance / 2;
    const h = 4 * meters / this.hScreenSize;
    return Matrix.Translation(h, 0, 0);
  }
  get rightHMatrix() {
    const meters = this.hScreenSize / 4 - this.lensSeparationDistance / 2;
    const h = 4 * meters / this.hScreenSize;
    return Matrix.Translation(-h, 0, 0);
  }
  get leftPreViewMatrix() {
    return Matrix.Translation(0.5 * this.interpupillaryDistance, 0, 0);
  }
  get rightPreViewMatrix() {
    return Matrix.Translation(-0.5 * this.interpupillaryDistance, 0, 0);
  }
  static GetDefault() {
    const result = new VRCameraMetrics();
    result.hResolution = 1280;
    result.vResolution = 800;
    result.hScreenSize = 0.149759993;
    result.vScreenSize = 0.0935999975;
    result.vScreenCenter = 0.0467999987;
    result.eyeToScreenDistance = 0.0410000011;
    result.lensSeparationDistance = 0.063500002;
    result.interpupillaryDistance = 0.064000003;
    result.distortionK = [1, 0.219999999, 0.239999995, 0];
    result.chromaAbCorrection = [0.995999992, -0.00400000019, 1.01400006, 0];
    result.postProcessScaleFactor = 1.714605507808412;
    result.lensCenterOffset = 0.151976421;
    return result;
  }
};

// node_modules/@babylonjs/core/Shaders/vrDistortionCorrection.fragment.js
var name3 = "vrDistortionCorrectionPixelShader";
var shader3 = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform vec2 LensCenter;
uniform vec2 Scale;
uniform vec2 ScaleIn;
uniform vec4 HmdWarpParam;
vec2 HmdWarp(vec2 in01) {
vec2 theta=(in01-LensCenter)*ScaleIn; 
float rSq=theta.x*theta.x+theta.y*theta.y;
vec2 rvector=theta*(HmdWarpParam.x+HmdWarpParam.y*rSq+HmdWarpParam.z*rSq*rSq+HmdWarpParam.w*rSq*rSq*rSq);
return LensCenter+Scale*rvector;
}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
vec2 tc=HmdWarp(vUV);
if (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)
gl_FragColor=vec4(0.0,0.0,0.0,0.0);
else{
gl_FragColor=texture2D(textureSampler,tc);
}
}`;
ShaderStore.ShadersStore[name3] = shader3;

// node_modules/@babylonjs/core/PostProcesses/vrDistortionCorrectionPostProcess.js
var VRDistortionCorrectionPostProcess = class extends PostProcess {
  constructor(name137, camera, isRightEye, vrMetrics) {
    super(name137, "vrDistortionCorrection", ["LensCenter", "Scale", "ScaleIn", "HmdWarpParam"], null, vrMetrics.postProcessScaleFactor, camera, Texture.BILINEAR_SAMPLINGMODE);
    this._isRightEye = isRightEye;
    this._distortionFactors = vrMetrics.distortionK;
    this._postProcessScaleFactor = vrMetrics.postProcessScaleFactor;
    this._lensCenterOffset = vrMetrics.lensCenterOffset;
    this.adaptScaleToCurrentViewport = true;
    this.onSizeChangedObservable.add(() => {
      this._scaleIn = new Vector2(2, 2 / this.aspectRatio);
      this._scaleFactor = new Vector2(0.5 * (1 / this._postProcessScaleFactor), 0.5 * (1 / this._postProcessScaleFactor) * this.aspectRatio);
      this._lensCenter = new Vector2(this._isRightEye ? 0.5 - this._lensCenterOffset * 0.5 : 0.5 + this._lensCenterOffset * 0.5, 0.5);
    });
    this.onApplyObservable.add((effect) => {
      effect.setFloat2("LensCenter", this._lensCenter.x, this._lensCenter.y);
      effect.setFloat2("Scale", this._scaleFactor.x, this._scaleFactor.y);
      effect.setFloat2("ScaleIn", this._scaleIn.x, this._scaleIn.y);
      effect.setFloat4("HmdWarpParam", this._distortionFactors[0], this._distortionFactors[1], this._distortionFactors[2], this._distortionFactors[3]);
    });
  }
  getClassName() {
    return "VRDistortionCorrectionPostProcess";
  }
};

// node_modules/@babylonjs/core/Shaders/vrMultiviewToSingleview.fragment.js
var name4 = "vrMultiviewToSingleviewPixelShader";
var shader4 = `precision mediump sampler2DArray;
varying vec2 vUV;
uniform sampler2DArray multiviewSampler;
uniform int imageIndex;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
gl_FragColor=texture2D(multiviewSampler,vec3(vUV,imageIndex));
}`;
ShaderStore.ShadersStore[name4] = shader4;

// node_modules/@babylonjs/core/Materials/Textures/MultiviewRenderTarget.js
var MultiviewRenderTarget = class extends RenderTargetTexture {
  set samples(value) {
    this._samples = value;
  }
  get samples() {
    return this._samples;
  }
  constructor(scene, size = 512) {
    super("multiview rtt", size, scene, false, true, 0, false, void 0, false, false, true, void 0, true);
    this._renderTarget = this.getScene().getEngine().createMultiviewRenderTargetTexture(this.getRenderWidth(), this.getRenderHeight());
    this._texture = this._renderTarget.texture;
    this._texture.isMultiview = true;
    this._texture.format = 5;
    this.samples = this._getEngine().getCaps().maxSamples || this.samples;
    this._texture.samples = this._samples;
  }
  _bindFrameBuffer() {
    if (!this._renderTarget) {
      return;
    }
    this.getScene().getEngine().bindMultiviewFramebuffer(this._renderTarget);
  }
  getViewCount() {
    return 2;
  }
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.multiview.js
Engine.prototype.createMultiviewRenderTargetTexture = function(width, height) {
  const gl = this._gl;
  if (!this.getCaps().multiview) {
    throw "Multiview is not supported";
  }
  const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, { width, height });
  rtWrapper._framebuffer = gl.createFramebuffer();
  const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);
  internalTexture.width = width;
  internalTexture.height = height;
  internalTexture.isMultiview = true;
  rtWrapper._colorTextureArray = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D_ARRAY, rtWrapper._colorTextureArray);
  gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.RGBA8, width, height, 2);
  rtWrapper._depthStencilTextureArray = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D_ARRAY, rtWrapper._depthStencilTextureArray);
  gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.DEPTH24_STENCIL8, width, height, 2);
  internalTexture.isReady = true;
  rtWrapper.setTextures(internalTexture);
  rtWrapper._depthStencilTexture = internalTexture;
  return rtWrapper;
};
Engine.prototype.bindMultiviewFramebuffer = function(_multiviewTexture) {
  const multiviewTexture = _multiviewTexture;
  const gl = this._gl;
  const ext = this.getCaps().oculusMultiview || this.getCaps().multiview;
  this.bindFramebuffer(multiviewTexture, void 0, void 0, void 0, true);
  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, multiviewTexture._framebuffer);
  if (multiviewTexture._colorTextureArray && multiviewTexture._depthStencilTextureArray) {
    if (this.getCaps().oculusMultiview) {
      ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, multiviewTexture.samples, 0, 2);
      ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, multiviewTexture.samples, 0, 2);
    } else {
      ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, 0, 2);
      ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, 0, 2);
    }
  } else {
    throw "Invalid multiview frame buffer";
  }
};
Camera.prototype._useMultiviewToSingleView = false;
Camera.prototype._multiviewTexture = null;
Camera.prototype._resizeOrCreateMultiviewTexture = function(width, height) {
  if (!this._multiviewTexture) {
    this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), { width, height });
  } else if (this._multiviewTexture.getRenderWidth() != width || this._multiviewTexture.getRenderHeight() != height) {
    this._multiviewTexture.dispose();
    this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), { width, height });
  }
};
function createMultiviewUbo(engine, name137) {
  const ubo = new UniformBuffer(engine, void 0, true, name137);
  ubo.addUniform("viewProjection", 16);
  ubo.addUniform("viewProjectionR", 16);
  ubo.addUniform("view", 16);
  ubo.addUniform("projection", 16);
  ubo.addUniform("vEyePosition", 4);
  return ubo;
}
var currentCreateSceneUniformBuffer = Scene.prototype.createSceneUniformBuffer;
Scene.prototype._transformMatrixR = Matrix.Zero();
Scene.prototype._multiviewSceneUbo = null;
Scene.prototype._createMultiviewUbo = function() {
  this._multiviewSceneUbo = createMultiviewUbo(this.getEngine(), "scene_multiview");
};
Scene.prototype.createSceneUniformBuffer = function(name137) {
  if (this._multiviewSceneUbo) {
    return createMultiviewUbo(this.getEngine(), name137);
  }
  return currentCreateSceneUniformBuffer.bind(this)(name137);
};
Scene.prototype._updateMultiviewUbo = function(viewR, projectionR) {
  if (viewR && projectionR) {
    viewR.multiplyToRef(projectionR, this._transformMatrixR);
  }
  if (viewR && projectionR) {
    viewR.multiplyToRef(projectionR, TmpVectors.Matrix[0]);
    Frustum.GetRightPlaneToRef(TmpVectors.Matrix[0], this._frustumPlanes[3]);
  }
  if (this._multiviewSceneUbo) {
    this._multiviewSceneUbo.updateMatrix("viewProjection", this.getTransformMatrix());
    this._multiviewSceneUbo.updateMatrix("viewProjectionR", this._transformMatrixR);
    this._multiviewSceneUbo.updateMatrix("view", this._viewMatrix);
    this._multiviewSceneUbo.updateMatrix("projection", this._projectionMatrix);
  }
};
Scene.prototype._renderMultiviewToSingleView = function(camera) {
  camera._resizeOrCreateMultiviewTexture(camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.width > 0 ? camera._rigPostProcess.width : this.getEngine().getRenderWidth(true), camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.height > 0 ? camera._rigPostProcess.height : this.getEngine().getRenderHeight(true));
  if (!this._multiviewSceneUbo) {
    this._createMultiviewUbo();
  }
  camera.outputRenderTarget = camera._multiviewTexture;
  this._renderForCamera(camera);
  camera.outputRenderTarget = null;
  for (let index = 0; index < camera._rigCameras.length; index++) {
    const engine = this.getEngine();
    this._activeCamera = camera._rigCameras[index];
    engine.setViewport(this._activeCamera.viewport);
    if (this.postProcessManager) {
      this.postProcessManager._prepareFrame();
      this.postProcessManager._finalizeFrame(this._activeCamera.isIntermediate);
    }
  }
};

// node_modules/@babylonjs/core/PostProcesses/vrMultiviewToSingleviewPostProcess.js
var VRMultiviewToSingleviewPostProcess = class extends PostProcess {
  getClassName() {
    return "VRMultiviewToSingleviewPostProcess";
  }
  constructor(name137, camera, scaleFactor) {
    super(name137, "vrMultiviewToSingleview", ["imageIndex"], ["multiviewSampler"], scaleFactor, camera, Texture.BILINEAR_SAMPLINGMODE);
    const cam = camera !== null && camera !== void 0 ? camera : this.getCamera();
    this.onSizeChangedObservable.add(() => {
    });
    this.onApplyObservable.add((effect) => {
      if (cam._scene.activeCamera && cam._scene.activeCamera.isLeftCamera) {
        effect.setInt("imageIndex", 0);
      } else {
        effect.setInt("imageIndex", 1);
      }
      effect.setTexture("multiviewSampler", cam._multiviewTexture);
    });
  }
};

// node_modules/@babylonjs/core/Cameras/RigModes/vrRigMode.js
function setVRRigMode(camera, rigParams) {
  const metrics = rigParams.vrCameraMetrics || VRCameraMetrics.GetDefault();
  camera._rigCameras[0]._cameraRigParams.vrMetrics = metrics;
  camera._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1);
  camera._rigCameras[0]._cameraRigParams.vrWorkMatrix = new Matrix();
  camera._rigCameras[0]._cameraRigParams.vrHMatrix = metrics.leftHMatrix;
  camera._rigCameras[0]._cameraRigParams.vrPreViewMatrix = metrics.leftPreViewMatrix;
  camera._rigCameras[0].getProjectionMatrix = camera._rigCameras[0]._getVRProjectionMatrix;
  camera._rigCameras[1]._cameraRigParams.vrMetrics = metrics;
  camera._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1);
  camera._rigCameras[1]._cameraRigParams.vrWorkMatrix = new Matrix();
  camera._rigCameras[1]._cameraRigParams.vrHMatrix = metrics.rightHMatrix;
  camera._rigCameras[1]._cameraRigParams.vrPreViewMatrix = metrics.rightPreViewMatrix;
  camera._rigCameras[1].getProjectionMatrix = camera._rigCameras[1]._getVRProjectionMatrix;
  if (metrics.multiviewEnabled) {
    if (!camera.getScene().getEngine().getCaps().multiview) {
      Logger.Warn("Multiview is not supported, falling back to standard rendering");
      metrics.multiviewEnabled = false;
    } else {
      camera._useMultiviewToSingleView = true;
      camera._rigPostProcess = new VRMultiviewToSingleviewPostProcess("VRMultiviewToSingleview", camera, metrics.postProcessScaleFactor);
    }
  }
  if (metrics.compensateDistortion) {
    camera._rigCameras[0]._rigPostProcess = new VRDistortionCorrectionPostProcess("VR_Distort_Compensation_Left", camera._rigCameras[0], false, metrics);
    camera._rigCameras[1]._rigPostProcess = new VRDistortionCorrectionPostProcess("VR_Distort_Compensation_Right", camera._rigCameras[1], true, metrics);
  }
}

// node_modules/@babylonjs/core/Cameras/VR/vrDeviceOrientationArcRotateCamera.js
Node2.AddNodeConstructor("VRDeviceOrientationArcRotateCamera", (name137, scene) => {
  return () => new VRDeviceOrientationArcRotateCamera(name137, 0, 0, 1, Vector3.Zero(), scene);
});
var VRDeviceOrientationArcRotateCamera = class extends ArcRotateCamera {
  constructor(name137, alpha, beta, radius, target, scene, compensateDistortion = true, vrCameraMetrics = VRCameraMetrics.GetDefault()) {
    super(name137, alpha, beta, radius, target, scene);
    this._setRigMode = setVRRigMode.bind(null, this);
    vrCameraMetrics.compensateDistortion = compensateDistortion;
    this.setCameraRigMode(Camera.RIG_MODE_VR, { vrCameraMetrics });
    this.inputs.addVRDeviceOrientation();
  }
  getClassName() {
    return "VRDeviceOrientationArcRotateCamera";
  }
};

// node_modules/@babylonjs/core/Cameras/VR/vrDeviceOrientationFreeCamera.js
Node2.AddNodeConstructor("VRDeviceOrientationFreeCamera", (name137, scene) => {
  return () => new VRDeviceOrientationFreeCamera(name137, Vector3.Zero(), scene);
});
var VRDeviceOrientationFreeCamera = class extends DeviceOrientationCamera {
  constructor(name137, position, scene, compensateDistortion = true, vrCameraMetrics = VRCameraMetrics.GetDefault()) {
    super(name137, position, scene);
    this._setRigMode = setVRRigMode.bind(null, this);
    vrCameraMetrics.compensateDistortion = compensateDistortion;
    this.setCameraRigMode(Camera.RIG_MODE_VR, { vrCameraMetrics });
  }
  getClassName() {
    return "VRDeviceOrientationFreeCamera";
  }
};

// node_modules/@babylonjs/core/Cameras/VR/vrDeviceOrientationGamepadCamera.js
Node2.AddNodeConstructor("VRDeviceOrientationGamepadCamera", (name137, scene) => {
  return () => new VRDeviceOrientationGamepadCamera(name137, Vector3.Zero(), scene);
});
var VRDeviceOrientationGamepadCamera = class extends VRDeviceOrientationFreeCamera {
  constructor(name137, position, scene, compensateDistortion = true, vrCameraMetrics = VRCameraMetrics.GetDefault()) {
    super(name137, position, scene, compensateDistortion, vrCameraMetrics);
    this._setRigMode = setVRRigMode.bind(null, this);
    this.inputs.addGamepad();
  }
  getClassName() {
    return "VRDeviceOrientationGamepadCamera";
  }
};

// node_modules/@babylonjs/core/Cameras/RigModes/webVRRigMode.js
function setWebVRRigMode(camera, rigParams) {
  if (rigParams.vrDisplay) {
    const leftEye = rigParams.vrDisplay.getEyeParameters("left");
    const rightEye = rigParams.vrDisplay.getEyeParameters("right");
    camera._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1);
    camera._rigCameras[0].setCameraRigParameter("left", true);
    camera._rigCameras[0].setCameraRigParameter("specs", rigParams.specs);
    camera._rigCameras[0].setCameraRigParameter("eyeParameters", leftEye);
    camera._rigCameras[0].setCameraRigParameter("frameData", rigParams.frameData);
    camera._rigCameras[0].setCameraRigParameter("parentCamera", rigParams.parentCamera);
    camera._rigCameras[0]._cameraRigParams.vrWorkMatrix = new Matrix();
    camera._rigCameras[0].getProjectionMatrix = camera._getWebVRProjectionMatrix;
    camera._rigCameras[0].parent = camera;
    camera._rigCameras[0]._getViewMatrix = camera._getWebVRViewMatrix;
    camera._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1);
    camera._rigCameras[1].setCameraRigParameter("eyeParameters", rightEye);
    camera._rigCameras[1].setCameraRigParameter("specs", rigParams.specs);
    camera._rigCameras[1].setCameraRigParameter("frameData", rigParams.frameData);
    camera._rigCameras[1].setCameraRigParameter("parentCamera", rigParams.parentCamera);
    camera._rigCameras[1]._cameraRigParams.vrWorkMatrix = new Matrix();
    camera._rigCameras[1].getProjectionMatrix = camera._getWebVRProjectionMatrix;
    camera._rigCameras[1].parent = camera;
    camera._rigCameras[1]._getViewMatrix = camera._getWebVRViewMatrix;
  }
}

// node_modules/@babylonjs/core/Engines/Extensions/engine.webVR.js
Object.defineProperty(Engine.prototype, "isInVRExclusivePointerMode", {
  get: function() {
    return this._vrExclusivePointerMode;
  },
  enumerable: true,
  configurable: true
});
Engine.prototype._prepareVRComponent = function() {
  this._vrSupported = false;
  this._vrExclusivePointerMode = false;
  this.onVRDisplayChangedObservable = new Observable();
  this.onVRRequestPresentComplete = new Observable();
  this.onVRRequestPresentStart = new Observable();
};
Engine.prototype.isVRDevicePresent = function() {
  return !!this._vrDisplay;
};
Engine.prototype.getVRDevice = function() {
  return this._vrDisplay;
};
Engine.prototype.initWebVR = function() {
  this.initWebVRAsync();
  return this.onVRDisplayChangedObservable;
};
Engine.prototype.initWebVRAsync = function() {
  const notifyObservers = () => {
    const eventArgs = {
      vrDisplay: this._vrDisplay,
      vrSupported: this._vrSupported
    };
    this.onVRDisplayChangedObservable.notifyObservers(eventArgs);
    this._webVRInitPromise = new Promise((res) => {
      res(eventArgs);
    });
  };
  if (!this._onVrDisplayConnect) {
    this._onVrDisplayConnect = (event) => {
      this._vrDisplay = event.display;
      notifyObservers();
    };
    this._onVrDisplayDisconnect = () => {
      this._vrDisplay.cancelAnimationFrame(this._frameHandler);
      this._vrDisplay = void 0;
      this._frameHandler = Engine.QueueNewFrame(this._boundRenderFunction);
      notifyObservers();
    };
    this._onVrDisplayPresentChange = () => {
      this._vrExclusivePointerMode = this._vrDisplay && this._vrDisplay.isPresenting;
    };
    const hostWindow = this.getHostWindow();
    if (hostWindow) {
      hostWindow.addEventListener("vrdisplayconnect", this._onVrDisplayConnect);
      hostWindow.addEventListener("vrdisplaydisconnect", this._onVrDisplayDisconnect);
      hostWindow.addEventListener("vrdisplaypresentchange", this._onVrDisplayPresentChange);
    }
  }
  this._webVRInitPromise = this._webVRInitPromise || this._getVRDisplaysAsync();
  this._webVRInitPromise.then(notifyObservers);
  return this._webVRInitPromise;
};
Engine.prototype._getVRDisplaysAsync = function() {
  return new Promise((res) => {
    if (navigator.getVRDisplays) {
      navigator.getVRDisplays().then((devices) => {
        this._vrSupported = true;
        this._vrDisplay = devices[0];
        res({
          vrDisplay: this._vrDisplay,
          vrSupported: this._vrSupported
        });
      });
    } else {
      this._vrDisplay = void 0;
      this._vrSupported = false;
      res({
        vrDisplay: this._vrDisplay,
        vrSupported: this._vrSupported
      });
    }
  });
};
Engine.prototype.enableVR = function(options) {
  if (this._vrDisplay && !this._vrDisplay.isPresenting) {
    const onResolved = () => {
      this.onVRRequestPresentComplete.notifyObservers(true);
      this._onVRFullScreenTriggered();
    };
    const onRejected = () => {
      this.onVRRequestPresentComplete.notifyObservers(false);
    };
    this.onVRRequestPresentStart.notifyObservers(this);
    const presentationAttributes = {
      highRefreshRate: this.vrPresentationAttributes ? this.vrPresentationAttributes.highRefreshRate : false,
      foveationLevel: this.vrPresentationAttributes ? this.vrPresentationAttributes.foveationLevel : 1,
      multiview: (this.getCaps().multiview || this.getCaps().oculusMultiview) && options.useMultiview
    };
    this._vrDisplay.requestPresent([
      {
        source: this.getRenderingCanvas(),
        attributes: presentationAttributes,
        ...presentationAttributes
      }
    ]).then(onResolved).catch(onRejected);
  }
};
Engine.prototype._onVRFullScreenTriggered = function() {
  if (this._vrDisplay && this._vrDisplay.isPresenting) {
    this._oldSize = new Size(this.getRenderWidth(), this.getRenderHeight());
    this._oldHardwareScaleFactor = this.getHardwareScalingLevel();
    const leftEye = this._vrDisplay.getEyeParameters("left");
    this.setHardwareScalingLevel(1);
    this.setSize(leftEye.renderWidth * 2, leftEye.renderHeight);
  } else {
    this.setHardwareScalingLevel(this._oldHardwareScaleFactor);
    this.setSize(this._oldSize.width, this._oldSize.height);
  }
};
Engine.prototype.disableVR = function() {
  if (this._vrDisplay && this._vrDisplay.isPresenting) {
    this._vrDisplay.exitPresent().then(() => this._onVRFullScreenTriggered()).catch(() => this._onVRFullScreenTriggered());
  }
  if (IsWindowObjectExist()) {
    window.removeEventListener("vrdisplaypointerrestricted", this._onVRDisplayPointerRestricted);
    window.removeEventListener("vrdisplaypointerunrestricted", this._onVRDisplayPointerUnrestricted);
    if (this._onVrDisplayConnect) {
      window.removeEventListener("vrdisplayconnect", this._onVrDisplayConnect);
      if (this._onVrDisplayDisconnect) {
        window.removeEventListener("vrdisplaydisconnect", this._onVrDisplayDisconnect);
      }
      if (this._onVrDisplayPresentChange) {
        window.removeEventListener("vrdisplaypresentchange", this._onVrDisplayPresentChange);
      }
      this._onVrDisplayConnect = null;
      this._onVrDisplayDisconnect = null;
    }
  }
};
Engine.prototype._connectVREvents = function(canvas, document2) {
  this._onVRDisplayPointerRestricted = () => {
    if (canvas) {
      canvas.requestPointerLock();
    }
  };
  this._onVRDisplayPointerUnrestricted = () => {
    if (!document2) {
      const hostWindow = this.getHostWindow();
      if (hostWindow.document && hostWindow.document.exitPointerLock) {
        hostWindow.document.exitPointerLock();
      }
      return;
    }
    if (!document2.exitPointerLock) {
      return;
    }
    document2.exitPointerLock();
  };
  if (IsWindowObjectExist()) {
    const hostWindow = this.getHostWindow();
    hostWindow.addEventListener("vrdisplaypointerrestricted", this._onVRDisplayPointerRestricted, false);
    hostWindow.addEventListener("vrdisplaypointerunrestricted", this._onVRDisplayPointerUnrestricted, false);
  }
};
Engine.prototype._submitVRFrame = function() {
  if (this._vrDisplay && this._vrDisplay.isPresenting) {
    try {
      this._vrDisplay.submitFrame();
    } catch (e) {
      Tools.Warn("webVR submitFrame has had an unexpected failure: " + e);
    }
  }
};
Engine.prototype.isVRPresenting = function() {
  return this._vrDisplay && this._vrDisplay.isPresenting;
};
Engine.prototype._requestVRFrame = function() {
  this._frameHandler = Engine.QueueNewFrame(this._boundRenderFunction, this._vrDisplay);
};

// node_modules/@babylonjs/core/Cameras/VR/webVRCamera.js
Node2.AddNodeConstructor("WebVRFreeCamera", (name137, scene) => {
  return () => new WebVRFreeCamera(name137, Vector3.Zero(), scene);
});
Node2.AddNodeConstructor("WebVRGamepadCamera", (name137, scene) => {
  return () => new WebVRFreeCamera(name137, Vector3.Zero(), scene);
});
var WebVRFreeCamera = class extends FreeCamera {
  constructor(name137, position, scene, _webVROptions = {}) {
    super(name137, position, scene);
    this._webVROptions = _webVROptions;
    this._vrDevice = null;
    this.rawPose = null;
    this._specsVersion = "1.1";
    this._attached = false;
    this._descendants = [];
    this._deviceRoomPosition = Vector3.Zero();
    this._deviceRoomRotationQuaternion = Quaternion.Identity();
    this._standingMatrix = null;
    this.devicePosition = Vector3.Zero();
    this.deviceRotationQuaternion = Quaternion.Identity();
    this.deviceScaleFactor = 1;
    this._deviceToWorld = Matrix.Identity();
    this._worldToDevice = Matrix.Identity();
    this.controllers = [];
    this.onControllersAttachedObservable = new Observable();
    this.onControllerMeshLoadedObservable = new Observable();
    this.onPoseUpdatedFromDeviceObservable = new Observable();
    this._poseSet = false;
    this.rigParenting = true;
    this._defaultHeight = void 0;
    this._setRigMode = setWebVRRigMode.bind(null, this);
    this._detachIfAttached = () => {
      const vrDisplay = this.getEngine().getVRDevice();
      if (vrDisplay && !vrDisplay.isPresenting) {
        this.detachControl();
      }
    };
    this._workingVector = Vector3.Zero();
    this._oneVector = Vector3.One();
    this._workingMatrix = Matrix.Identity();
    this._tmpMatrix = new Matrix();
    this._cache.position = Vector3.Zero();
    if (_webVROptions.defaultHeight) {
      this._defaultHeight = _webVROptions.defaultHeight;
      this.position.y = this._defaultHeight;
    }
    this.minZ = 0.1;
    if (arguments.length === 5) {
      this._webVROptions = arguments[4];
    }
    if (this._webVROptions.trackPosition == void 0) {
      this._webVROptions.trackPosition = true;
    }
    if (this._webVROptions.controllerMeshes == void 0) {
      this._webVROptions.controllerMeshes = true;
    }
    if (this._webVROptions.defaultLightingOnControllers == void 0) {
      this._webVROptions.defaultLightingOnControllers = true;
    }
    this.rotationQuaternion = new Quaternion();
    if (this._webVROptions && this._webVROptions.positionScale) {
      this.deviceScaleFactor = this._webVROptions.positionScale;
    }
    const engine = this.getEngine();
    this._onVREnabled = (success) => {
      if (success) {
        this.initControllers();
      }
    };
    engine.onVRRequestPresentComplete.add(this._onVREnabled);
    engine.initWebVR().add((event) => {
      if (!event.vrDisplay || this._vrDevice === event.vrDisplay) {
        return;
      }
      this._vrDevice = event.vrDisplay;
      this.setCameraRigMode(Camera.RIG_MODE_WEBVR, { parentCamera: this, vrDisplay: this._vrDevice, frameData: this._frameData, specs: this._specsVersion });
      if (this._attached) {
        this.getEngine().enableVR(this._webVROptions);
      }
    });
    if (typeof VRFrameData !== "undefined") {
      this._frameData = new VRFrameData();
    }
    if (_webVROptions.useMultiview) {
      if (!this.getScene().getEngine().getCaps().multiview) {
        Logger.Warn("Multiview is not supported, falling back to standard rendering");
        this._useMultiviewToSingleView = false;
      } else {
        this._useMultiviewToSingleView = true;
        this._rigPostProcess = new VRMultiviewToSingleviewPostProcess("VRMultiviewToSingleview", this, 1);
      }
    }
    this.getScene().onBeforeCameraRenderObservable.add((camera) => {
      if (camera.parent === this && this.rigParenting) {
        this._descendants = this.getDescendants(true, (n) => {
          const isController = this.controllers.some((controller) => {
            return controller._mesh === n;
          });
          const isRigCamera = this._rigCameras.indexOf(n) !== -1;
          return !isController && !isRigCamera;
        });
        this._descendants.forEach((node) => {
          node.parent = camera;
        });
      }
    });
    this.getScene().onAfterCameraRenderObservable.add((camera) => {
      if (camera.parent === this && this.rigParenting) {
        this._descendants.forEach((node) => {
          node.parent = this;
        });
      }
    });
  }
  deviceDistanceToRoomGround() {
    if (this._standingMatrix) {
      this._standingMatrix.getTranslationToRef(this._workingVector);
      return this._deviceRoomPosition.y + this._workingVector.y;
    }
    return this._defaultHeight || 0;
  }
  useStandingMatrix(callback = (bool) => {
  }) {
    this.getEngine().initWebVRAsync().then((result) => {
      if (!result.vrDisplay || !result.vrDisplay.stageParameters || !result.vrDisplay.stageParameters.sittingToStandingTransform || !this._webVROptions.trackPosition) {
        callback(false);
      } else {
        this._standingMatrix = new Matrix();
        Matrix.FromFloat32ArrayToRefScaled(result.vrDisplay.stageParameters.sittingToStandingTransform, 0, 1, this._standingMatrix);
        if (!this.getScene().useRightHandedSystem) {
          if (this._standingMatrix) {
            this._standingMatrix.toggleModelMatrixHandInPlace();
          }
        }
        callback(true);
      }
    });
  }
  useStandingMatrixAsync() {
    return new Promise((res) => {
      this.useStandingMatrix((supported) => {
        res(supported);
      });
    });
  }
  dispose() {
    this._detachIfAttached();
    this.getEngine().onVRRequestPresentComplete.removeCallback(this._onVREnabled);
    if (this._updateCacheWhenTrackingDisabledObserver) {
      this._scene.onBeforeRenderObservable.remove(this._updateCacheWhenTrackingDisabledObserver);
    }
    super.dispose();
  }
  getControllerByName(name137) {
    for (const gp of this.controllers) {
      if (gp.hand === name137) {
        return gp;
      }
    }
    return null;
  }
  get leftController() {
    if (!this._leftController) {
      this._leftController = this.getControllerByName("left");
    }
    return this._leftController;
  }
  get rightController() {
    if (!this._rightController) {
      this._rightController = this.getControllerByName("right");
    }
    return this._rightController;
  }
  getForwardRay(length = 100) {
    if (this.leftCamera) {
      return super.getForwardRay(length, this.leftCamera.getWorldMatrix(), this.leftCamera.globalPosition);
    } else {
      return super.getForwardRay(length);
    }
  }
  _checkInputs() {
    if (this._vrDevice && this._vrDevice.isPresenting) {
      this._vrDevice.getFrameData(this._frameData);
      this.updateFromDevice(this._frameData.pose);
    }
    super._checkInputs();
  }
  updateFromDevice(poseData) {
    if (poseData && poseData.orientation && poseData.orientation.length === 4) {
      this.rawPose = poseData;
      this._deviceRoomRotationQuaternion.copyFromFloats(poseData.orientation[0], poseData.orientation[1], -poseData.orientation[2], -poseData.orientation[3]);
      if (this.getScene().useRightHandedSystem) {
        this._deviceRoomRotationQuaternion.z *= -1;
        this._deviceRoomRotationQuaternion.w *= -1;
      }
      if (this._webVROptions.trackPosition && this.rawPose.position) {
        this._deviceRoomPosition.copyFromFloats(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2]);
        if (this.getScene().useRightHandedSystem) {
          this._deviceRoomPosition.z *= -1;
        }
      }
      this._poseSet = true;
    }
  }
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    super.attachControl(noPreventDefault);
    this._attached = true;
    noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;
    if (this._vrDevice) {
      this.getEngine().enableVR(this._webVROptions);
    }
    const hostWindow = this._scene.getEngine().getHostWindow();
    if (hostWindow) {
      hostWindow.addEventListener("vrdisplaypresentchange", this._detachIfAttached);
    }
  }
  detachControl() {
    this.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);
    this.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);
    super.detachControl();
    this._attached = false;
    this.getEngine().disableVR();
    window.removeEventListener("vrdisplaypresentchange", this._detachIfAttached);
  }
  getClassName() {
    return "WebVRFreeCamera";
  }
  resetToCurrentRotation() {
    this._vrDevice.resetPose();
  }
  _updateRigCameras() {
    const camLeft = this._rigCameras[0];
    const camRight = this._rigCameras[1];
    camLeft.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);
    camRight.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);
    camLeft.position.copyFrom(this._deviceRoomPosition);
    camRight.position.copyFrom(this._deviceRoomPosition);
  }
  _correctPositionIfNotTrackPosition(matrix, isViewMatrix = false) {
    if (this.rawPose && this.rawPose.position && !this._webVROptions.trackPosition) {
      Matrix.TranslationToRef(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2], this._tmpMatrix);
      if (!isViewMatrix) {
        this._tmpMatrix.invert();
      }
      this._tmpMatrix.multiplyToRef(matrix, matrix);
    }
  }
  _updateCache(ignoreParentClass) {
    if (!this.rotationQuaternion.equals(this._cache.rotationQuaternion) || !this.position.equals(this._cache.position)) {
      if (!this._updateCacheCalled) {
        this._updateCacheCalled = true;
        this.update();
      }
      this.rotationQuaternion.toRotationMatrix(this._workingMatrix);
      Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._workingMatrix, this._workingVector);
      this.devicePosition.subtractToRef(this._workingVector, this._workingVector);
      Matrix.ComposeToRef(this._oneVector, this.rotationQuaternion, this._workingVector, this._deviceToWorld);
      this._deviceToWorld.getTranslationToRef(this._workingVector);
      this._workingVector.addInPlace(this.position);
      this._workingVector.subtractInPlace(this._cache.position);
      this._deviceToWorld.setTranslation(this._workingVector);
      this._deviceToWorld.invertToRef(this._worldToDevice);
      this.controllers.forEach((controller) => {
        controller._deviceToWorld.copyFrom(this._deviceToWorld);
        this._correctPositionIfNotTrackPosition(controller._deviceToWorld);
        controller.update();
      });
    }
    if (!ignoreParentClass) {
      super._updateCache();
    }
    this._updateCacheCalled = false;
  }
  _computeDevicePosition() {
    Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._deviceToWorld, this.devicePosition);
  }
  update() {
    this._computeDevicePosition();
    Matrix.FromQuaternionToRef(this._deviceRoomRotationQuaternion, this._workingMatrix);
    this._workingMatrix.multiplyToRef(this._deviceToWorld, this._workingMatrix);
    Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);
    if (this._poseSet) {
      this.onPoseUpdatedFromDeviceObservable.notifyObservers(null);
    }
    super.update();
  }
  _getViewMatrix() {
    return Matrix.Identity();
  }
  _getWebVRViewMatrix() {
    const parentCamera = this._cameraRigParams["parentCamera"];
    parentCamera._updateCache();
    const viewArray = this._cameraRigParams["left"] ? this._cameraRigParams["frameData"].leftViewMatrix : this._cameraRigParams["frameData"].rightViewMatrix;
    Matrix.FromArrayToRef(viewArray, 0, this._webvrViewMatrix);
    if (!this.getScene().useRightHandedSystem) {
      this._webvrViewMatrix.toggleModelMatrixHandInPlace();
    }
    this._webvrViewMatrix.getRotationMatrixToRef(this._cameraRotationMatrix);
    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);
    this.position.addToRef(this._transformedReferencePoint, this._currentTarget);
    if (parentCamera.deviceScaleFactor !== 1) {
      this._webvrViewMatrix.invert();
      if (parentCamera.deviceScaleFactor) {
        this._webvrViewMatrix.multiplyAtIndex(12, parentCamera.deviceScaleFactor);
        this._webvrViewMatrix.multiplyAtIndex(13, parentCamera.deviceScaleFactor);
        this._webvrViewMatrix.multiplyAtIndex(14, parentCamera.deviceScaleFactor);
      }
      this._webvrViewMatrix.invert();
    }
    parentCamera._correctPositionIfNotTrackPosition(this._webvrViewMatrix, true);
    parentCamera._worldToDevice.multiplyToRef(this._webvrViewMatrix, this._webvrViewMatrix);
    this._workingMatrix = this._workingMatrix || Matrix.Identity();
    this._webvrViewMatrix.invertToRef(this._workingMatrix);
    this._workingMatrix.multiplyToRef(parentCamera.getWorldMatrix(), this._workingMatrix);
    this._workingMatrix.getTranslationToRef(this._globalPosition);
    this._markSyncedWithParent();
    return this._webvrViewMatrix;
  }
  _getWebVRProjectionMatrix() {
    const parentCamera = this.parent;
    parentCamera._vrDevice.depthNear = parentCamera.minZ;
    parentCamera._vrDevice.depthFar = parentCamera.maxZ;
    const projectionArray = this._cameraRigParams["left"] ? this._cameraRigParams["frameData"].leftProjectionMatrix : this._cameraRigParams["frameData"].rightProjectionMatrix;
    Matrix.FromArrayToRef(projectionArray, 0, this._projectionMatrix);
    if (!this.getScene().useRightHandedSystem) {
      this._projectionMatrix.toggleProjectionMatrixHandInPlace();
    }
    return this._projectionMatrix;
  }
  initControllers() {
    this.controllers.length = 0;
    const manager = this.getScene().gamepadManager;
    this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {
      if (gamepad.type === Gamepad.POSE_ENABLED) {
        const webVrController = gamepad;
        if (webVrController.defaultModel) {
          webVrController.defaultModel.setEnabled(false);
        }
        if (webVrController.hand === "right") {
          this._rightController = null;
        }
        if (webVrController.hand === "left") {
          this._leftController = null;
        }
        const controllerIndex = this.controllers.indexOf(webVrController);
        if (controllerIndex !== -1) {
          this.controllers.splice(controllerIndex, 1);
        }
      }
    });
    this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {
      if (gamepad.type === Gamepad.POSE_ENABLED) {
        const webVrController = gamepad;
        if (!this._webVROptions.trackPosition) {
          webVrController._disableTrackPosition(new Vector3(webVrController.hand == "left" ? -0.15 : 0.15, -0.5, 0.25));
          if (!this._updateCacheWhenTrackingDisabledObserver) {
            this._updateCacheWhenTrackingDisabledObserver = this._scene.onBeforeRenderObservable.add(() => {
              this._updateCache();
            });
          }
        }
        webVrController.deviceScaleFactor = this.deviceScaleFactor;
        webVrController._deviceToWorld.copyFrom(this._deviceToWorld);
        this._correctPositionIfNotTrackPosition(webVrController._deviceToWorld);
        if (this._webVROptions.controllerMeshes) {
          if (webVrController.defaultModel) {
            webVrController.defaultModel.setEnabled(true);
          } else {
            webVrController.initControllerMesh(this.getScene(), (loadedMesh) => {
              loadedMesh.scaling.scaleInPlace(this.deviceScaleFactor);
              this.onControllerMeshLoadedObservable.notifyObservers(webVrController);
              if (this._webVROptions.defaultLightingOnControllers) {
                if (!this._lightOnControllers) {
                  this._lightOnControllers = new HemisphericLight("vrControllersLight", new Vector3(0, 1, 0), this.getScene());
                }
                const activateLightOnSubMeshes = function(mesh, light) {
                  const children = mesh.getChildren();
                  if (children && children.length !== 0) {
                    children.forEach((mesh2) => {
                      light.includedOnlyMeshes.push(mesh2);
                      activateLightOnSubMeshes(mesh2, light);
                    });
                  }
                };
                this._lightOnControllers.includedOnlyMeshes.push(loadedMesh);
                activateLightOnSubMeshes(loadedMesh, this._lightOnControllers);
              }
            });
          }
        }
        webVrController.attachToPoseControlledCamera(this);
        if (this.controllers.indexOf(webVrController) === -1) {
          this.controllers.push(webVrController);
          let firstViveWandDetected = false;
          for (let i = 0; i < this.controllers.length; i++) {
            if (this.controllers[i].controllerType === PoseEnabledControllerType.VIVE) {
              if (!firstViveWandDetected) {
                firstViveWandDetected = true;
                this.controllers[i].hand = "left";
              } else {
                this.controllers[i].hand = "right";
              }
            }
          }
          if (this.controllers.length >= 2) {
            this.onControllersAttachedObservable.notifyObservers(this.controllers);
          }
        }
      }
    });
  }
};

// node_modules/@babylonjs/core/Gamepads/Controllers/webVRController.js
var WebVRController = class extends PoseEnabledController {
  constructor(vrGamepad) {
    super(vrGamepad);
    this.onTriggerStateChangedObservable = new Observable();
    this.onMainButtonStateChangedObservable = new Observable();
    this.onSecondaryButtonStateChangedObservable = new Observable();
    this.onPadStateChangedObservable = new Observable();
    this.onPadValuesChangedObservable = new Observable();
    this.pad = { x: 0, y: 0 };
    this._changes = {
      pressChanged: false,
      touchChanged: false,
      valueChanged: false,
      changed: false
    };
    this._buttons = new Array(vrGamepad.buttons.length);
    this.hand = vrGamepad.hand;
  }
  onButtonStateChange(callback) {
    this._onButtonStateChange = callback;
  }
  get defaultModel() {
    return this._defaultModel;
  }
  update() {
    super.update();
    for (let index = 0; index < this._buttons.length; index++) {
      this._setButtonValue(this.browserGamepad.buttons[index], this._buttons[index], index);
    }
    if (this.leftStick.x !== this.pad.x || this.leftStick.y !== this.pad.y) {
      this.pad.x = this.leftStick.x;
      this.pad.y = this.leftStick.y;
      this.onPadValuesChangedObservable.notifyObservers(this.pad);
    }
  }
  _setButtonValue(newState, currentState, buttonIndex) {
    if (!newState) {
      newState = {
        pressed: false,
        touched: false,
        value: 0
      };
    }
    if (!currentState) {
      this._buttons[buttonIndex] = {
        pressed: newState.pressed,
        touched: newState.touched,
        value: newState.value
      };
      return;
    }
    this._checkChanges(newState, currentState);
    if (this._changes.changed) {
      this._onButtonStateChange && this._onButtonStateChange(this.index, buttonIndex, newState);
      this._handleButtonChange(buttonIndex, newState, this._changes);
    }
    this._buttons[buttonIndex].pressed = newState.pressed;
    this._buttons[buttonIndex].touched = newState.touched;
    this._buttons[buttonIndex].value = newState.value < 1e-8 ? 0 : newState.value;
  }
  _checkChanges(newState, currentState) {
    this._changes.pressChanged = newState.pressed !== currentState.pressed;
    this._changes.touchChanged = newState.touched !== currentState.touched;
    this._changes.valueChanged = newState.value !== currentState.value;
    this._changes.changed = this._changes.pressChanged || this._changes.touchChanged || this._changes.valueChanged;
    return this._changes;
  }
  dispose() {
    super.dispose();
    this._defaultModel = null;
    this.onTriggerStateChangedObservable.clear();
    this.onMainButtonStateChangedObservable.clear();
    this.onSecondaryButtonStateChangedObservable.clear();
    this.onPadStateChangedObservable.clear();
    this.onPadValuesChangedObservable.clear();
  }
};

// node_modules/@babylonjs/core/Shaders/imageProcessing.fragment.js
var name5 = "imageProcessingPixelShader";
var shader5 = `varying vec2 vUV;
uniform sampler2D textureSampler;
#include<imageProcessingDeclaration>
#include<helperFunctions>
#include<imageProcessingFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
vec4 result=texture2D(textureSampler,vUV);
#ifdef IMAGEPROCESSING
#ifndef FROMLINEARSPACE
result.rgb=toLinearSpace(result.rgb);
#endif
result=applyImageProcessing(result);
#else
#ifdef FROMLINEARSPACE
result=applyImageProcessing(result);
#endif
#endif
gl_FragColor=result;
}`;
ShaderStore.ShadersStore[name5] = shader5;

// node_modules/@babylonjs/core/PostProcesses/imageProcessingPostProcess.js
var ImageProcessingPostProcess = class extends PostProcess {
  constructor(name137, options, camera = null, samplingMode, engine, reusable, textureType = 0, imageProcessingConfiguration) {
    super(name137, "imageProcessing", [], [], options, camera, samplingMode, engine, reusable, null, textureType, "postprocess", null, true);
    this._fromLinearSpace = true;
    this._defines = {
      IMAGEPROCESSING: false,
      VIGNETTE: false,
      VIGNETTEBLENDMODEMULTIPLY: false,
      VIGNETTEBLENDMODEOPAQUE: false,
      TONEMAPPING: false,
      TONEMAPPING_ACES: false,
      CONTRAST: false,
      COLORCURVES: false,
      COLORGRADING: false,
      COLORGRADING3D: false,
      FROMLINEARSPACE: false,
      SAMPLER3DGREENDEPTH: false,
      SAMPLER3DBGRMAP: false,
      DITHER: false,
      IMAGEPROCESSINGPOSTPROCESS: false,
      EXPOSURE: false,
      SKIPFINALCOLORCLAMP: false
    };
    if (imageProcessingConfiguration) {
      imageProcessingConfiguration.applyByPostProcess = true;
      this._attachImageProcessingConfiguration(imageProcessingConfiguration, true);
      this._updateParameters();
    } else {
      this._attachImageProcessingConfiguration(null, true);
      this.imageProcessingConfiguration.applyByPostProcess = true;
    }
    this.onApply = (effect) => {
      this.imageProcessingConfiguration.bind(effect, this.aspectRatio);
    };
  }
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  set imageProcessingConfiguration(value) {
    value.applyByPostProcess = true;
    this._attachImageProcessingConfiguration(value);
  }
  _attachImageProcessingConfiguration(configuration, doNotBuild = false) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (!configuration) {
      let scene = null;
      const engine = this.getEngine();
      const camera = this.getCamera();
      if (camera) {
        scene = camera.getScene();
      } else if (engine && engine.scenes) {
        const scenes = engine.scenes;
        scene = scenes[scenes.length - 1];
      } else {
        scene = EngineStore.LastCreatedScene;
      }
      if (scene) {
        this._imageProcessingConfiguration = scene.imageProcessingConfiguration;
      } else {
        this._imageProcessingConfiguration = new ImageProcessingConfiguration();
      }
    } else {
      this._imageProcessingConfiguration = configuration;
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
        this._updateParameters();
      });
    }
    if (!doNotBuild) {
      this._updateParameters();
    }
  }
  get isSupported() {
    const effect = this.getEffect();
    return !effect || effect.isSupported;
  }
  get colorCurves() {
    return this.imageProcessingConfiguration.colorCurves;
  }
  set colorCurves(value) {
    this.imageProcessingConfiguration.colorCurves = value;
  }
  get colorCurvesEnabled() {
    return this.imageProcessingConfiguration.colorCurvesEnabled;
  }
  set colorCurvesEnabled(value) {
    this.imageProcessingConfiguration.colorCurvesEnabled = value;
  }
  get colorGradingTexture() {
    return this.imageProcessingConfiguration.colorGradingTexture;
  }
  set colorGradingTexture(value) {
    this.imageProcessingConfiguration.colorGradingTexture = value;
  }
  get colorGradingEnabled() {
    return this.imageProcessingConfiguration.colorGradingEnabled;
  }
  set colorGradingEnabled(value) {
    this.imageProcessingConfiguration.colorGradingEnabled = value;
  }
  get exposure() {
    return this.imageProcessingConfiguration.exposure;
  }
  set exposure(value) {
    this.imageProcessingConfiguration.exposure = value;
  }
  get toneMappingEnabled() {
    return this._imageProcessingConfiguration.toneMappingEnabled;
  }
  set toneMappingEnabled(value) {
    this._imageProcessingConfiguration.toneMappingEnabled = value;
  }
  get toneMappingType() {
    return this._imageProcessingConfiguration.toneMappingType;
  }
  set toneMappingType(value) {
    this._imageProcessingConfiguration.toneMappingType = value;
  }
  get contrast() {
    return this.imageProcessingConfiguration.contrast;
  }
  set contrast(value) {
    this.imageProcessingConfiguration.contrast = value;
  }
  get vignetteStretch() {
    return this.imageProcessingConfiguration.vignetteStretch;
  }
  set vignetteStretch(value) {
    this.imageProcessingConfiguration.vignetteStretch = value;
  }
  get vignetteCentreX() {
    return this.imageProcessingConfiguration.vignetteCenterX;
  }
  set vignetteCentreX(value) {
    this.imageProcessingConfiguration.vignetteCenterX = value;
  }
  get vignetteCentreY() {
    return this.imageProcessingConfiguration.vignetteCenterY;
  }
  set vignetteCentreY(value) {
    this.imageProcessingConfiguration.vignetteCenterY = value;
  }
  get vignetteCenterY() {
    return this.imageProcessingConfiguration.vignetteCenterY;
  }
  set vignetteCenterY(value) {
    this.imageProcessingConfiguration.vignetteCenterY = value;
  }
  get vignetteCenterX() {
    return this.imageProcessingConfiguration.vignetteCenterX;
  }
  set vignetteCenterX(value) {
    this.imageProcessingConfiguration.vignetteCenterX = value;
  }
  get vignetteWeight() {
    return this.imageProcessingConfiguration.vignetteWeight;
  }
  set vignetteWeight(value) {
    this.imageProcessingConfiguration.vignetteWeight = value;
  }
  get vignetteColor() {
    return this.imageProcessingConfiguration.vignetteColor;
  }
  set vignetteColor(value) {
    this.imageProcessingConfiguration.vignetteColor = value;
  }
  get vignetteCameraFov() {
    return this.imageProcessingConfiguration.vignetteCameraFov;
  }
  set vignetteCameraFov(value) {
    this.imageProcessingConfiguration.vignetteCameraFov = value;
  }
  get vignetteBlendMode() {
    return this.imageProcessingConfiguration.vignetteBlendMode;
  }
  set vignetteBlendMode(value) {
    this.imageProcessingConfiguration.vignetteBlendMode = value;
  }
  get vignetteEnabled() {
    return this.imageProcessingConfiguration.vignetteEnabled;
  }
  set vignetteEnabled(value) {
    this.imageProcessingConfiguration.vignetteEnabled = value;
  }
  get ditheringIntensity() {
    return this.imageProcessingConfiguration.ditheringIntensity;
  }
  set ditheringIntensity(value) {
    this.imageProcessingConfiguration.ditheringIntensity = value;
  }
  get ditheringEnabled() {
    return this.imageProcessingConfiguration.ditheringEnabled;
  }
  set ditheringEnabled(value) {
    this.imageProcessingConfiguration.ditheringEnabled = value;
  }
  get fromLinearSpace() {
    return this._fromLinearSpace;
  }
  set fromLinearSpace(value) {
    if (this._fromLinearSpace === value) {
      return;
    }
    this._fromLinearSpace = value;
    this._updateParameters();
  }
  getClassName() {
    return "ImageProcessingPostProcess";
  }
  _updateParameters() {
    this._defines.FROMLINEARSPACE = this._fromLinearSpace;
    this.imageProcessingConfiguration.prepareDefines(this._defines, true);
    let defines = "";
    for (const define in this._defines) {
      if (this._defines[define]) {
        defines += `#define ${define};\r
`;
      }
    }
    const samplers = ["textureSampler"];
    const uniforms = ["scale"];
    if (ImageProcessingConfiguration) {
      ImageProcessingConfiguration.PrepareSamplers(samplers, this._defines);
      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._defines);
    }
    this.updateEffect(defines, uniforms, samplers);
  }
  dispose(camera) {
    super.dispose(camera);
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (this._imageProcessingConfiguration) {
      this.imageProcessingConfiguration.applyByPostProcess = false;
    }
  }
};
__decorate([
  serialize()
], ImageProcessingPostProcess.prototype, "_fromLinearSpace", void 0);

// node_modules/@babylonjs/core/XR/webXRLayerWrapper.js
var WebXRLayerWrapper = class {
  constructor(getWidth, getHeight, layer, layerType, createRenderTargetTextureProvider) {
    this.getWidth = getWidth;
    this.getHeight = getHeight;
    this.layer = layer;
    this.layerType = layerType;
    this.createRenderTargetTextureProvider = createRenderTargetTextureProvider;
  }
  get isFixedFoveationSupported() {
    return this.layerType == "XRWebGLLayer" && typeof this.layer.fixedFoveation == "number";
  }
  get fixedFoveation() {
    if (this.isFixedFoveationSupported) {
      return this.layer.fixedFoveation;
    }
    return null;
  }
  set fixedFoveation(value) {
    if (this.isFixedFoveationSupported) {
      const val = Math.max(0, Math.min(1, value || 0));
      this.layer.fixedFoveation = val;
    }
  }
};

// node_modules/@babylonjs/core/XR/webXRRenderTargetTextureProvider.js
var WebXRLayerRenderTargetTextureProvider = class {
  constructor(_scene, layerWrapper) {
    this._scene = _scene;
    this.layerWrapper = layerWrapper;
    this._renderTargetTextures = new Array();
    this._engine = _scene.getEngine();
  }
  _createInternalTexture(textureSize, texture) {
    const internalTexture = new InternalTexture(this._engine, InternalTextureSource.Unknown, true);
    internalTexture.width = textureSize.width;
    internalTexture.height = textureSize.height;
    internalTexture._hardwareTexture = new WebGLHardwareTexture(texture, this._engine._gl);
    internalTexture.isReady = true;
    return internalTexture;
  }
  _createRenderTargetTexture(width, height, framebuffer, colorTexture, depthStencilTexture, multiview) {
    if (!this._engine) {
      throw new Error("Engine is disposed");
    }
    const textureSize = { width, height };
    const renderTargetTexture = multiview ? new MultiviewRenderTarget(this._scene, textureSize) : new RenderTargetTexture("XR renderTargetTexture", textureSize, this._scene);
    const renderTargetWrapper = renderTargetTexture.renderTarget;
    renderTargetWrapper._samples = renderTargetTexture.samples;
    if (framebuffer || !colorTexture) {
      renderTargetWrapper._framebuffer = framebuffer;
    }
    if (colorTexture) {
      if (multiview) {
        renderTargetWrapper._colorTextureArray = colorTexture;
      } else {
        const internalTexture = this._createInternalTexture(textureSize, colorTexture);
        renderTargetWrapper.setTexture(internalTexture, 0);
        renderTargetTexture._texture = internalTexture;
      }
    }
    if (depthStencilTexture) {
      if (multiview) {
        renderTargetWrapper._depthStencilTextureArray = depthStencilTexture;
      } else {
        renderTargetWrapper._depthStencilTexture = this._createInternalTexture(textureSize, depthStencilTexture);
      }
    }
    renderTargetTexture.disableRescaling();
    if (typeof XRWebGLBinding !== "undefined") {
      renderTargetTexture.skipInitialClear = true;
    }
    this._renderTargetTextures.push(renderTargetTexture);
    return renderTargetTexture;
  }
  _destroyRenderTargetTexture(renderTargetTexture) {
    this._renderTargetTextures.splice(this._renderTargetTextures.indexOf(renderTargetTexture), 1);
    renderTargetTexture.dispose();
  }
  getFramebufferDimensions() {
    return this._framebufferDimensions;
  }
  dispose() {
    this._renderTargetTextures.forEach((rtt) => rtt.dispose());
    this._renderTargetTextures.length = 0;
  }
};

// node_modules/@babylonjs/core/XR/webXRWebGLLayer.js
var WebXRWebGLLayerWrapper = class extends WebXRLayerWrapper {
  constructor(layer) {
    super(() => layer.framebufferWidth, () => layer.framebufferHeight, layer, "XRWebGLLayer", (sessionManager) => new WebXRWebGLLayerRenderTargetTextureProvider(sessionManager.scene, this));
    this.layer = layer;
  }
};
var WebXRWebGLLayerRenderTargetTextureProvider = class extends WebXRLayerRenderTargetTextureProvider {
  constructor(scene, layerWrapper) {
    super(scene, layerWrapper);
    this.layerWrapper = layerWrapper;
    this._layer = layerWrapper.layer;
    this._framebufferDimensions = {
      framebufferWidth: this._layer.framebufferWidth,
      framebufferHeight: this._layer.framebufferHeight
    };
  }
  trySetViewportForView(viewport, view) {
    const xrViewport = this._layer.getViewport(view);
    if (!xrViewport) {
      return false;
    }
    const framebufferWidth = this._framebufferDimensions.framebufferWidth;
    const framebufferHeight = this._framebufferDimensions.framebufferHeight;
    viewport.x = xrViewport.x / framebufferWidth;
    viewport.y = xrViewport.y / framebufferHeight;
    viewport.width = xrViewport.width / framebufferWidth;
    viewport.height = xrViewport.height / framebufferHeight;
    return true;
  }
  getRenderTargetTextureForEye(eye) {
    const layerWidth = this._layer.framebufferWidth;
    const layerHeight = this._layer.framebufferHeight;
    const framebuffer = this._layer.framebuffer;
    if (!this._rtt || layerWidth !== this._framebufferDimensions.framebufferWidth || layerHeight !== this._framebufferDimensions.framebufferHeight || framebuffer !== this._framebuffer) {
      this._rtt = this._createRenderTargetTexture(layerWidth, layerHeight, framebuffer);
      this._framebufferDimensions.framebufferWidth = layerWidth;
      this._framebufferDimensions.framebufferHeight = layerHeight;
      this._framebuffer = framebuffer;
    }
    return this._rtt;
  }
  getRenderTargetTextureForView(view) {
    return this.getRenderTargetTextureForEye(view.eye);
  }
};

// node_modules/@babylonjs/core/XR/webXRManagedOutputCanvas.js
var WebXRManagedOutputCanvasOptions = class {
  static GetDefaults(engine) {
    const defaults = new WebXRManagedOutputCanvasOptions();
    defaults.canvasOptions = {
      antialias: true,
      depth: true,
      stencil: engine ? engine.isStencilEnable : true,
      alpha: true,
      framebufferScaleFactor: 1
    };
    defaults.newCanvasCssStyle = "position:absolute; bottom:0px;right:0px;z-index:10;width:90%;height:100%;background-color: #000000;";
    return defaults;
  }
};
var WebXRManagedOutputCanvas = class {
  constructor(_xrSessionManager, _options = WebXRManagedOutputCanvasOptions.GetDefaults()) {
    this._options = _options;
    this._canvas = null;
    this._engine = null;
    this.xrLayer = null;
    this._xrLayerWrapper = null;
    this.onXRLayerInitObservable = new Observable();
    this._engine = _xrSessionManager.scene.getEngine();
    this._engine.onDisposeObservable.addOnce(() => {
      this._engine = null;
    });
    if (!_options.canvasElement) {
      const canvas = document.createElement("canvas");
      canvas.style.cssText = this._options.newCanvasCssStyle || "position:absolute; bottom:0px;right:0px;";
      this._setManagedOutputCanvas(canvas);
    } else {
      this._setManagedOutputCanvas(_options.canvasElement);
    }
    _xrSessionManager.onXRSessionInit.add(() => {
      this._addCanvas();
    });
    _xrSessionManager.onXRSessionEnded.add(() => {
      this._removeCanvas();
    });
  }
  dispose() {
    this._removeCanvas();
    this._setManagedOutputCanvas(null);
  }
  async initializeXRLayerAsync(xrSession) {
    const createLayer = () => {
      this.xrLayer = new XRWebGLLayer(xrSession, this.canvasContext, this._options.canvasOptions);
      this._xrLayerWrapper = new WebXRWebGLLayerWrapper(this.xrLayer);
      this.onXRLayerInitObservable.notifyObservers(this.xrLayer);
      return this.xrLayer;
    };
    if (!this.canvasContext.makeXRCompatible) {
      return Promise.resolve(createLayer());
    }
    return this.canvasContext.makeXRCompatible().then(
      () => {
      },
      () => {
        Tools.Warn("Error executing makeXRCompatible. This does not mean that the session will work incorrectly.");
      }
    ).then(() => {
      return createLayer();
    });
  }
  _addCanvas() {
    if (this._canvas && this._engine && this._canvas !== this._engine.getRenderingCanvas()) {
      document.body.appendChild(this._canvas);
    }
    if (this.xrLayer) {
      this._setCanvasSize(true);
    } else {
      this.onXRLayerInitObservable.addOnce(() => {
        this._setCanvasSize(true);
      });
    }
  }
  _removeCanvas() {
    if (this._canvas && this._engine && document.body.contains(this._canvas) && this._canvas !== this._engine.getRenderingCanvas()) {
      document.body.removeChild(this._canvas);
    }
    this._setCanvasSize(false);
  }
  _setCanvasSize(init = true, xrLayer = this._xrLayerWrapper) {
    if (!this._canvas || !this._engine) {
      return;
    }
    if (init) {
      if (xrLayer) {
        if (this._canvas !== this._engine.getRenderingCanvas()) {
          this._canvas.style.width = xrLayer.getWidth() + "px";
          this._canvas.style.height = xrLayer.getHeight() + "px";
        } else {
          this._engine.setSize(xrLayer.getWidth(), xrLayer.getHeight());
        }
      }
    } else {
      if (this._originalCanvasSize) {
        if (this._canvas !== this._engine.getRenderingCanvas()) {
          this._canvas.style.width = this._originalCanvasSize.width + "px";
          this._canvas.style.height = this._originalCanvasSize.height + "px";
        } else {
          this._engine.setSize(this._originalCanvasSize.width, this._originalCanvasSize.height);
        }
      }
    }
  }
  _setManagedOutputCanvas(canvas) {
    this._removeCanvas();
    if (!canvas) {
      this._canvas = null;
      this.canvasContext = null;
    } else {
      this._originalCanvasSize = {
        width: canvas.offsetWidth,
        height: canvas.offsetHeight
      };
      this._canvas = canvas;
      this.canvasContext = this._canvas.getContext("webgl2");
      if (!this.canvasContext) {
        this.canvasContext = this._canvas.getContext("webgl");
      }
    }
  }
};

// node_modules/@babylonjs/core/XR/native/nativeXRRenderTarget.js
var NativeXRLayerWrapper = class extends WebXRLayerWrapper {
  constructor(layer) {
    super(() => layer.framebufferWidth, () => layer.framebufferHeight, layer, "XRWebGLLayer", (sessionManager) => new NativeXRLayerRenderTargetTextureProvider(sessionManager, this));
    this.layer = layer;
  }
};
var NativeXRLayerRenderTargetTextureProvider = class extends WebXRLayerRenderTargetTextureProvider {
  constructor(sessionManager, layerWrapper) {
    super(sessionManager.scene, layerWrapper);
    this.layerWrapper = layerWrapper;
    this._nativeRTTProvider = navigator.xr.getNativeRenderTargetProvider(sessionManager.session, this._createRenderTargetTexture.bind(this), this._destroyRenderTargetTexture.bind(this));
    this._nativeLayer = layerWrapper.layer;
  }
  trySetViewportForView(viewport) {
    viewport.x = 0;
    viewport.y = 0;
    viewport.width = 1;
    viewport.height = 1;
    return true;
  }
  getRenderTargetTextureForEye(eye) {
    return this._nativeRTTProvider.getRenderTargetForEye(eye);
  }
  getRenderTargetTextureForView(view) {
    return this._nativeRTTProvider.getRenderTargetForEye(view.eye);
  }
  getFramebufferDimensions() {
    return {
      framebufferWidth: this._nativeLayer.framebufferWidth,
      framebufferHeight: this._nativeLayer.framebufferHeight
    };
  }
};
var NativeXRRenderTarget = class {
  constructor(_xrSessionManager) {
    this._nativeRenderTarget = navigator.xr.getWebXRRenderTarget(_xrSessionManager.scene.getEngine());
  }
  async initializeXRLayerAsync(xrSession) {
    await this._nativeRenderTarget.initializeXRLayerAsync(xrSession);
    this.xrLayer = this._nativeRenderTarget.xrLayer;
    return this.xrLayer;
  }
  dispose() {
  }
};

// node_modules/@babylonjs/core/XR/webXRSessionManager.js
var WebXRSessionManager = class {
  constructor(scene) {
    this.scene = scene;
    this.currentTimestamp = -1;
    this.defaultHeightCompensation = 1.7;
    this.onXRFrameObservable = new Observable();
    this.onXRReferenceSpaceChanged = new Observable();
    this.onXRSessionEnded = new Observable();
    this.onXRSessionInit = new Observable();
    this.inXRFrameLoop = false;
    this.inXRSession = false;
    this._engine = scene.getEngine();
    this._onEngineDisposedObserver = this._engine.onDisposeObservable.addOnce(() => {
      this._engine = null;
    });
    scene.onDisposeObservable.addOnce(() => {
      this.dispose();
    });
  }
  get referenceSpace() {
    return this._referenceSpace;
  }
  set referenceSpace(newReferenceSpace) {
    this._referenceSpace = newReferenceSpace;
    this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);
  }
  get sessionMode() {
    return this._sessionMode;
  }
  dispose() {
    var _a;
    if (this.inXRSession) {
      this.exitXRAsync();
    }
    this.onXRFrameObservable.clear();
    this.onXRSessionEnded.clear();
    this.onXRReferenceSpaceChanged.clear();
    this.onXRSessionInit.clear();
    (_a = this._engine) === null || _a === void 0 ? void 0 : _a.onDisposeObservable.remove(this._onEngineDisposedObserver);
    this._engine = null;
  }
  exitXRAsync() {
    if (this.session && this.inXRSession) {
      this.inXRSession = false;
      return this.session.end().catch(() => {
        Logger.Warn("Could not end XR session.");
      });
    }
    return Promise.resolve();
  }
  trySetViewportForView(viewport, view) {
    var _a;
    return ((_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.trySetViewportForView(viewport, view)) || false;
  }
  getRenderTargetTextureForEye(eye) {
    var _a;
    return ((_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.getRenderTargetTextureForEye(eye)) || null;
  }
  getRenderTargetTextureForView(view) {
    var _a;
    return ((_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.getRenderTargetTextureForView(view)) || null;
  }
  getWebXRRenderTarget(options) {
    const engine = this.scene.getEngine();
    if (this._xrNavigator.xr.native) {
      return new NativeXRRenderTarget(this);
    } else {
      options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);
      options.canvasElement = options.canvasElement || engine.getRenderingCanvas() || void 0;
      return new WebXRManagedOutputCanvas(this, options);
    }
  }
  initializeAsync() {
    this._xrNavigator = navigator;
    if (!this._xrNavigator.xr) {
      return Promise.reject("WebXR not available");
    }
    return Promise.resolve();
  }
  initializeSessionAsync(xrSessionMode = "immersive-vr", xrSessionInit = {}) {
    return this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit).then((session) => {
      this.session = session;
      this._sessionMode = xrSessionMode;
      this.onXRSessionInit.notifyObservers(session);
      this.inXRSession = true;
      this.session.addEventListener("end", () => {
        var _a;
        this.inXRSession = false;
        this.onXRSessionEnded.notifyObservers(null);
        if (this._engine) {
          this._engine.framebufferDimensionsObject = null;
          this._engine.restoreDefaultFramebuffer();
          this._engine.customAnimationFrameRequester = null;
          this._engine._renderLoop();
        }
        if (this.isNative) {
          (_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.dispose();
        }
        this._baseLayerRTTProvider = null;
        this._baseLayerWrapper = null;
      }, { once: true });
      return this.session;
    });
  }
  isSessionSupportedAsync(sessionMode) {
    return WebXRSessionManager.IsSessionSupportedAsync(sessionMode);
  }
  resetReferenceSpace() {
    this.referenceSpace = this.baseReferenceSpace;
  }
  runXRRenderLoop() {
    var _a;
    if (!this.inXRSession || !this._engine) {
      return;
    }
    this._engine.customAnimationFrameRequester = {
      requestAnimationFrame: this.session.requestAnimationFrame.bind(this.session),
      renderFunction: (timestamp, xrFrame) => {
        var _a2;
        if (!this.inXRSession || !this._engine) {
          return;
        }
        this.currentFrame = xrFrame;
        this.currentTimestamp = timestamp;
        if (xrFrame) {
          this.inXRFrameLoop = true;
          this._engine.framebufferDimensionsObject = ((_a2 = this._baseLayerRTTProvider) === null || _a2 === void 0 ? void 0 : _a2.getFramebufferDimensions()) || null;
          this.onXRFrameObservable.notifyObservers(xrFrame);
          this._engine._renderLoop();
          this._engine.framebufferDimensionsObject = null;
          this.inXRFrameLoop = false;
        }
      }
    };
    this._engine.framebufferDimensionsObject = ((_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.getFramebufferDimensions()) || null;
    if (typeof window !== "undefined" && window.cancelAnimationFrame) {
      window.cancelAnimationFrame(this._engine._frameHandler);
    }
    this._engine._renderLoop();
  }
  setReferenceSpaceTypeAsync(referenceSpaceType = "local-floor") {
    return this.session.requestReferenceSpace(referenceSpaceType).then((referenceSpace) => {
      return referenceSpace;
    }, (rejectionReason) => {
      Logger.Error("XR.requestReferenceSpace failed for the following reason: ");
      Logger.Error(rejectionReason);
      Logger.Log('Defaulting to universally-supported "viewer" reference space type.');
      return this.session.requestReferenceSpace("viewer").then((referenceSpace) => {
        const heightCompensation = new XRRigidTransform({ x: 0, y: -this.defaultHeightCompensation, z: 0 });
        return referenceSpace.getOffsetReferenceSpace(heightCompensation);
      }, (rejectionReason2) => {
        Logger.Error(rejectionReason2);
        throw 'XR initialization failed: required "viewer" reference space type not supported.';
      });
    }).then((referenceSpace) => {
      return this.session.requestReferenceSpace("viewer").then((viewerReferenceSpace) => {
        this.viewerReferenceSpace = viewerReferenceSpace;
        return referenceSpace;
      });
    }).then((referenceSpace) => {
      this.referenceSpace = this.baseReferenceSpace = referenceSpace;
      return this.referenceSpace;
    });
  }
  updateRenderStateAsync(state) {
    return Promise.resolve(this.session.updateRenderState(state));
  }
  _setBaseLayerWrapper(baseLayerWrapper) {
    var _a, _b;
    if (this.isNative) {
      (_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.dispose();
    }
    this._baseLayerWrapper = baseLayerWrapper;
    this._baseLayerRTTProvider = ((_b = this._baseLayerWrapper) === null || _b === void 0 ? void 0 : _b.createRenderTargetTextureProvider(this)) || null;
  }
  updateRenderState(state) {
    if (state.baseLayer) {
      this._setBaseLayerWrapper(this.isNative ? new NativeXRLayerWrapper(state.baseLayer) : new WebXRWebGLLayerWrapper(state.baseLayer));
    }
    this.session.updateRenderState(state);
  }
  static IsSessionSupportedAsync(sessionMode) {
    if (!navigator.xr) {
      return Promise.resolve(false);
    }
    const functionToUse = navigator.xr.isSessionSupported || navigator.xr.supportsSession;
    if (!functionToUse) {
      return Promise.resolve(false);
    } else {
      return functionToUse.call(navigator.xr, sessionMode).then((result) => {
        const returnValue = typeof result === "undefined" ? true : result;
        return Promise.resolve(returnValue);
      }).catch((e) => {
        Logger.Warn(e);
        return Promise.resolve(false);
      });
    }
  }
  get isNative() {
    var _a;
    return (_a = this._xrNavigator.xr.native) !== null && _a !== void 0 ? _a : false;
  }
  get currentFrameRate() {
    var _a;
    return (_a = this.session) === null || _a === void 0 ? void 0 : _a.frameRate;
  }
  get supportedFrameRates() {
    var _a;
    return (_a = this.session) === null || _a === void 0 ? void 0 : _a.supportedFrameRates;
  }
  updateTargetFrameRate(rate) {
    return this.session.updateTargetFrameRate(rate);
  }
  runInXRFrame(callback, ignoreIfNotInSession = true) {
    if (this.inXRFrameLoop) {
      callback();
    } else if (this.inXRSession || !ignoreIfNotInSession) {
      this.onXRFrameObservable.addOnce(callback);
    }
  }
  get isFixedFoveationSupported() {
    var _a;
    return ((_a = this._baseLayerWrapper) === null || _a === void 0 ? void 0 : _a.isFixedFoveationSupported) || false;
  }
  get fixedFoveation() {
    var _a;
    return ((_a = this._baseLayerWrapper) === null || _a === void 0 ? void 0 : _a.fixedFoveation) || null;
  }
  set fixedFoveation(value) {
    const val = Math.max(0, Math.min(1, value || 0));
    if (this._baseLayerWrapper) {
      this._baseLayerWrapper.fixedFoveation = val;
    }
  }
};

// node_modules/@babylonjs/core/XR/webXRTypes.js
var WebXRState;
(function(WebXRState2) {
  WebXRState2[WebXRState2["ENTERING_XR"] = 0] = "ENTERING_XR";
  WebXRState2[WebXRState2["EXITING_XR"] = 1] = "EXITING_XR";
  WebXRState2[WebXRState2["IN_XR"] = 2] = "IN_XR";
  WebXRState2[WebXRState2["NOT_IN_XR"] = 3] = "NOT_IN_XR";
})(WebXRState || (WebXRState = {}));
var WebXRTrackingState;
(function(WebXRTrackingState2) {
  WebXRTrackingState2[WebXRTrackingState2["NOT_TRACKING"] = 0] = "NOT_TRACKING";
  WebXRTrackingState2[WebXRTrackingState2["TRACKING_LOST"] = 1] = "TRACKING_LOST";
  WebXRTrackingState2[WebXRTrackingState2["TRACKING"] = 2] = "TRACKING";
})(WebXRTrackingState || (WebXRTrackingState = {}));

// node_modules/@babylonjs/core/Meshes/Builders/cylinderBuilder.js
function CreateCylinderVertexData(options) {
  const height = options.height || 2;
  let diameterTop = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;
  let diameterBottom = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;
  diameterTop = diameterTop || 1e-5;
  diameterBottom = diameterBottom || 1e-5;
  const tessellation = options.tessellation || 24;
  const subdivisions = options.subdivisions || 1;
  const hasRings = options.hasRings ? true : false;
  const enclose = options.enclose ? true : false;
  const cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;
  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const faceUV = options.faceUV || new Array(3);
  const faceColors = options.faceColors;
  const quadNb = arc !== 1 && enclose ? 2 : 0;
  const ringNb = hasRings ? subdivisions : 1;
  const surfaceNb = 2 + (1 + quadNb) * ringNb;
  let f;
  for (f = 0; f < surfaceNb; f++) {
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  for (f = 0; f < surfaceNb; f++) {
    if (faceUV && faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
  }
  const indices = new Array();
  const positions = new Array();
  const normals = new Array();
  const uvs = new Array();
  const colors = new Array();
  const angleStep = Math.PI * 2 * arc / tessellation;
  let angle;
  let h;
  let radius;
  const tan = (diameterBottom - diameterTop) / 2 / height;
  const ringVertex = Vector3.Zero();
  const ringNormal = Vector3.Zero();
  const ringFirstVertex = Vector3.Zero();
  const ringFirstNormal = Vector3.Zero();
  const quadNormal = Vector3.Zero();
  const Y = Axis.Y;
  let i;
  let j;
  let r;
  let ringIdx = 1;
  let s = 1;
  let cs = 0;
  let v = 0;
  for (i = 0; i <= subdivisions; i++) {
    h = i / subdivisions;
    radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;
    ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;
    for (r = 0; r < ringIdx; r++) {
      if (hasRings) {
        s += r;
      }
      if (enclose) {
        s += 2 * r;
      }
      for (j = 0; j <= tessellation; j++) {
        angle = j * angleStep;
        ringVertex.x = Math.cos(-angle) * radius;
        ringVertex.y = -height / 2 + h * height;
        ringVertex.z = Math.sin(-angle) * radius;
        if (diameterTop === 0 && i === subdivisions) {
          ringNormal.x = normals[normals.length - (tessellation + 1) * 3];
          ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];
          ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];
        } else {
          ringNormal.x = ringVertex.x;
          ringNormal.z = ringVertex.z;
          ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;
          ringNormal.normalize();
        }
        if (j === 0) {
          ringFirstVertex.copyFrom(ringVertex);
          ringFirstNormal.copyFrom(ringNormal);
        }
        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);
        normals.push(ringNormal.x, ringNormal.y, ringNormal.z);
        if (hasRings) {
          v = cs !== s ? faceUV[s].y : faceUV[s].w;
        } else {
          v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;
        }
        uvs.push(faceUV[s].x + (faceUV[s].z - faceUV[s].x) * j / tessellation, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
        if (faceColors) {
          colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);
        }
      }
      if (arc !== 1 && enclose) {
        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);
        positions.push(0, ringVertex.y, 0);
        positions.push(0, ringVertex.y, 0);
        positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);
        Vector3.CrossToRef(Y, ringNormal, quadNormal);
        quadNormal.normalize();
        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);
        Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);
        quadNormal.normalize();
        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);
        if (hasRings) {
          v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;
        } else {
          v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;
        }
        uvs.push(faceUV[s + 1].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
        uvs.push(faceUV[s + 1].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
        if (hasRings) {
          v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;
        } else {
          v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;
        }
        uvs.push(faceUV[s + 2].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
        uvs.push(faceUV[s + 2].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
        if (faceColors) {
          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);
          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);
          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);
          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);
        }
      }
      if (cs !== s) {
        cs = s;
      }
    }
  }
  const e = arc !== 1 && enclose ? tessellation + 4 : tessellation;
  i = 0;
  for (s = 0; s < subdivisions; s++) {
    let i0 = 0;
    let i1 = 0;
    let i2 = 0;
    let i3 = 0;
    for (j = 0; j < tessellation; j++) {
      i0 = i * (e + 1) + j;
      i1 = (i + 1) * (e + 1) + j;
      i2 = i * (e + 1) + (j + 1);
      i3 = (i + 1) * (e + 1) + (j + 1);
      indices.push(i0, i1, i2);
      indices.push(i3, i2, i1);
    }
    if (arc !== 1 && enclose) {
      indices.push(i0 + 2, i1 + 2, i2 + 2);
      indices.push(i3 + 2, i2 + 2, i1 + 2);
      indices.push(i0 + 4, i1 + 4, i2 + 4);
      indices.push(i3 + 4, i2 + 4, i1 + 4);
    }
    i = hasRings ? i + 2 : i + 1;
  }
  const createCylinderCap = (isTop) => {
    const radius2 = isTop ? diameterTop / 2 : diameterBottom / 2;
    if (radius2 === 0) {
      return;
    }
    let angle2;
    let circleVector;
    let i2;
    const u = isTop ? faceUV[surfaceNb - 1] : faceUV[0];
    let c = null;
    if (faceColors) {
      c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];
    }
    const vbase = positions.length / 3;
    const offset = isTop ? height / 2 : -height / 2;
    const center = new Vector3(0, offset, 0);
    positions.push(center.x, center.y, center.z);
    normals.push(0, isTop ? 1 : -1, 0);
    const v2 = u.y + (u.w - u.y) * 0.5;
    uvs.push(u.x + (u.z - u.x) * 0.5, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v2 : v2);
    if (c) {
      colors.push(c.r, c.g, c.b, c.a);
    }
    const textureScale = new Vector2(0.5, 0.5);
    for (i2 = 0; i2 <= tessellation; i2++) {
      angle2 = Math.PI * 2 * i2 * arc / tessellation;
      const cos = Math.cos(-angle2);
      const sin = Math.sin(-angle2);
      circleVector = new Vector3(cos * radius2, offset, sin * radius2);
      const textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);
      positions.push(circleVector.x, circleVector.y, circleVector.z);
      normals.push(0, isTop ? 1 : -1, 0);
      const v3 = u.y + (u.w - u.y) * textureCoordinate.y;
      uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v3 : v3);
      if (c) {
        colors.push(c.r, c.g, c.b, c.a);
      }
    }
    for (i2 = 0; i2 < tessellation; i2++) {
      if (!isTop) {
        indices.push(vbase);
        indices.push(vbase + (i2 + 1));
        indices.push(vbase + (i2 + 2));
      } else {
        indices.push(vbase);
        indices.push(vbase + (i2 + 2));
        indices.push(vbase + (i2 + 1));
      }
    }
  };
  if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {
    createCylinderCap(false);
  }
  if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {
    createCylinderCap(true);
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    vertexData.colors = colors;
  }
  return vertexData;
}
function CreateCylinder(name137, options = {}, scene) {
  const cylinder = new Mesh(name137, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  cylinder._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateCylinderVertexData(options);
  vertexData.applyToMesh(cylinder, options.updatable);
  return cylinder;
}
var CylinderBuilder = {
  CreateCylinder
};
VertexData.CreateCylinder = CreateCylinderVertexData;
Mesh.CreateCylinder = (name137, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) => {
  if (scene === void 0 || !(scene instanceof Scene)) {
    if (scene !== void 0) {
      sideOrientation = updatable || Mesh.DEFAULTSIDE;
      updatable = scene;
    }
    scene = subdivisions;
    subdivisions = 1;
  }
  const options = {
    height,
    diameterTop,
    diameterBottom,
    tessellation,
    subdivisions,
    sideOrientation,
    updatable
  };
  return CreateCylinder(name137, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/torusBuilder.js
function CreateTorusVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  const diameter = options.diameter || 1;
  const thickness = options.thickness || 0.5;
  const tessellation = options.tessellation || 16;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const stride = tessellation + 1;
  for (let i = 0; i <= tessellation; i++) {
    const u = i / tessellation;
    const outerAngle = i * Math.PI * 2 / tessellation - Math.PI / 2;
    const transform = Matrix.Translation(diameter / 2, 0, 0).multiply(Matrix.RotationY(outerAngle));
    for (let j = 0; j <= tessellation; j++) {
      const v = 1 - j / tessellation;
      const innerAngle = j * Math.PI * 2 / tessellation + Math.PI;
      const dx = Math.cos(innerAngle);
      const dy = Math.sin(innerAngle);
      let normal = new Vector3(dx, dy, 0);
      let position = normal.scale(thickness / 2);
      const textureCoordinate = new Vector2(u, v);
      position = Vector3.TransformCoordinates(position, transform);
      normal = Vector3.TransformNormal(normal, transform);
      positions.push(position.x, position.y, position.z);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - textureCoordinate.y : textureCoordinate.y);
      const nextI = (i + 1) % stride;
      const nextJ = (j + 1) % stride;
      indices.push(i * stride + j);
      indices.push(i * stride + nextJ);
      indices.push(nextI * stride + j);
      indices.push(i * stride + nextJ);
      indices.push(nextI * stride + nextJ);
      indices.push(nextI * stride + j);
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateTorus(name137, options = {}, scene) {
  const torus = new Mesh(name137, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  torus._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateTorusVertexData(options);
  vertexData.applyToMesh(torus, options.updatable);
  return torus;
}
var TorusBuilder = {
  CreateTorus
};
VertexData.CreateTorus = CreateTorusVertexData;
Mesh.CreateTorus = (name137, diameter, thickness, tessellation, scene, updatable, sideOrientation) => {
  const options = {
    diameter,
    thickness,
    tessellation,
    sideOrientation,
    updatable
  };
  return CreateTorus(name137, options, scene);
};

// node_modules/@babylonjs/core/Meshes/groundMesh.js
Mesh._GroundMeshParser = (parsedMesh, scene) => {
  return GroundMesh.Parse(parsedMesh, scene);
};
var GroundMesh = class extends Mesh {
  constructor(name137, scene) {
    super(name137, scene);
    this.generateOctree = false;
  }
  getClassName() {
    return "GroundMesh";
  }
  get subdivisions() {
    return Math.min(this._subdivisionsX, this._subdivisionsY);
  }
  get subdivisionsX() {
    return this._subdivisionsX;
  }
  get subdivisionsY() {
    return this._subdivisionsY;
  }
  optimize(chunksCount, octreeBlocksSize = 32) {
    this._subdivisionsX = chunksCount;
    this._subdivisionsY = chunksCount;
    this.subdivide(chunksCount);
    const thisAsAny = this;
    if (thisAsAny.createOrUpdateSubmeshesOctree) {
      thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);
    }
  }
  getHeightAtCoordinates(x, z) {
    const world = this.getWorldMatrix();
    const invMat = TmpVectors.Matrix[5];
    world.invertToRef(invMat);
    const tmpVect = TmpVectors.Vector3[8];
    Vector3.TransformCoordinatesFromFloatsToRef(x, 0, z, invMat, tmpVect);
    x = tmpVect.x;
    z = tmpVect.z;
    if (x < this._minX || x >= this._maxX || z <= this._minZ || z > this._maxZ) {
      return this.position.y;
    }
    if (!this._heightQuads || this._heightQuads.length == 0) {
      this._initHeightQuads();
      this._computeHeightQuads();
    }
    const facet = this._getFacetAt(x, z);
    const y = -(facet.x * x + facet.z * z + facet.w) / facet.y;
    Vector3.TransformCoordinatesFromFloatsToRef(0, y, 0, world, tmpVect);
    return tmpVect.y;
  }
  getNormalAtCoordinates(x, z) {
    const normal = new Vector3(0, 1, 0);
    this.getNormalAtCoordinatesToRef(x, z, normal);
    return normal;
  }
  getNormalAtCoordinatesToRef(x, z, ref) {
    const world = this.getWorldMatrix();
    const tmpMat = TmpVectors.Matrix[5];
    world.invertToRef(tmpMat);
    const tmpVect = TmpVectors.Vector3[8];
    Vector3.TransformCoordinatesFromFloatsToRef(x, 0, z, tmpMat, tmpVect);
    x = tmpVect.x;
    z = tmpVect.z;
    if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {
      return this;
    }
    if (!this._heightQuads || this._heightQuads.length == 0) {
      this._initHeightQuads();
      this._computeHeightQuads();
    }
    const facet = this._getFacetAt(x, z);
    Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);
    return this;
  }
  updateCoordinateHeights() {
    if (!this._heightQuads || this._heightQuads.length == 0) {
      this._initHeightQuads();
    }
    this._computeHeightQuads();
    return this;
  }
  _getFacetAt(x, z) {
    const col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);
    const row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);
    const quad = this._heightQuads[row * this._subdivisionsX + col];
    let facet;
    if (z < quad.slope.x * x + quad.slope.y) {
      facet = quad.facet1;
    } else {
      facet = quad.facet2;
    }
    return facet;
  }
  _initHeightQuads() {
    const subdivisionsX = this._subdivisionsX;
    const subdivisionsY = this._subdivisionsY;
    this._heightQuads = new Array();
    for (let row = 0; row < subdivisionsY; row++) {
      for (let col = 0; col < subdivisionsX; col++) {
        const quad = { slope: Vector2.Zero(), facet1: new Vector4(0, 0, 0, 0), facet2: new Vector4(0, 0, 0, 0) };
        this._heightQuads[row * subdivisionsX + col] = quad;
      }
    }
    return this;
  }
  _computeHeightQuads() {
    const positions = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positions) {
      return this;
    }
    const v1 = TmpVectors.Vector3[3];
    const v2 = TmpVectors.Vector3[2];
    const v3 = TmpVectors.Vector3[1];
    const v4 = TmpVectors.Vector3[0];
    const v1v2 = TmpVectors.Vector3[4];
    const v1v3 = TmpVectors.Vector3[5];
    const v1v4 = TmpVectors.Vector3[6];
    const norm1 = TmpVectors.Vector3[7];
    const norm2 = TmpVectors.Vector3[8];
    let i = 0;
    let j = 0;
    let k = 0;
    let cd = 0;
    let h = 0;
    let d1 = 0;
    let d2 = 0;
    const subdivisionsX = this._subdivisionsX;
    const subdivisionsY = this._subdivisionsY;
    for (let row = 0; row < subdivisionsY; row++) {
      for (let col = 0; col < subdivisionsX; col++) {
        i = col * 3;
        j = row * (subdivisionsX + 1) * 3;
        k = (row + 1) * (subdivisionsX + 1) * 3;
        v1.x = positions[j + i];
        v1.y = positions[j + i + 1];
        v1.z = positions[j + i + 2];
        v2.x = positions[j + i + 3];
        v2.y = positions[j + i + 4];
        v2.z = positions[j + i + 5];
        v3.x = positions[k + i];
        v3.y = positions[k + i + 1];
        v3.z = positions[k + i + 2];
        v4.x = positions[k + i + 3];
        v4.y = positions[k + i + 4];
        v4.z = positions[k + i + 5];
        cd = (v4.z - v1.z) / (v4.x - v1.x);
        h = v1.z - cd * v1.x;
        v2.subtractToRef(v1, v1v2);
        v3.subtractToRef(v1, v1v3);
        v4.subtractToRef(v1, v1v4);
        Vector3.CrossToRef(v1v4, v1v3, norm1);
        Vector3.CrossToRef(v1v2, v1v4, norm2);
        norm1.normalize();
        norm2.normalize();
        d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);
        d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);
        const quad = this._heightQuads[row * subdivisionsX + col];
        quad.slope.copyFromFloats(cd, h);
        quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);
        quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);
      }
    }
    return this;
  }
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.subdivisionsX = this._subdivisionsX;
    serializationObject.subdivisionsY = this._subdivisionsY;
    serializationObject.minX = this._minX;
    serializationObject.maxX = this._maxX;
    serializationObject.minZ = this._minZ;
    serializationObject.maxZ = this._maxZ;
    serializationObject.width = this._width;
    serializationObject.height = this._height;
  }
  static Parse(parsedMesh, scene) {
    const result = new GroundMesh(parsedMesh.name, scene);
    result._subdivisionsX = parsedMesh.subdivisionsX || 1;
    result._subdivisionsY = parsedMesh.subdivisionsY || 1;
    result._minX = parsedMesh.minX;
    result._maxX = parsedMesh.maxX;
    result._minZ = parsedMesh.minZ;
    result._maxZ = parsedMesh.maxZ;
    result._width = parsedMesh.width;
    result._height = parsedMesh.height;
    return result;
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/groundBuilder.js
function CreateGroundVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let row, col;
  const width = options.width || 1;
  const height = options.height || 1;
  const subdivisionsX = options.subdivisionsX || options.subdivisions || 1;
  const subdivisionsY = options.subdivisionsY || options.subdivisions || 1;
  for (row = 0; row <= subdivisionsY; row++) {
    for (col = 0; col <= subdivisionsX; col++) {
      const position = new Vector3(col * width / subdivisionsX - width / 2, 0, (subdivisionsY - row) * height / subdivisionsY - height / 2);
      const normal = new Vector3(0, 1, 0);
      positions.push(position.x, position.y, position.z);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(col / subdivisionsX, CompatibilityOptions.UseOpenGLOrientationForUV ? row / subdivisionsY : 1 - row / subdivisionsY);
    }
  }
  for (row = 0; row < subdivisionsY; row++) {
    for (col = 0; col < subdivisionsX; col++) {
      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));
      indices.push(col + 1 + row * (subdivisionsX + 1));
      indices.push(col + row * (subdivisionsX + 1));
      indices.push(col + (row + 1) * (subdivisionsX + 1));
      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));
      indices.push(col + row * (subdivisionsX + 1));
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateTiledGroundVertexData(options) {
  const xmin = options.xmin !== void 0 && options.xmin !== null ? options.xmin : -1;
  const zmin = options.zmin !== void 0 && options.zmin !== null ? options.zmin : -1;
  const xmax = options.xmax !== void 0 && options.xmax !== null ? options.xmax : 1;
  const zmax = options.zmax !== void 0 && options.zmax !== null ? options.zmax : 1;
  const subdivisions = options.subdivisions || { w: 1, h: 1 };
  const precision = options.precision || { w: 1, h: 1 };
  const indices = new Array();
  const positions = new Array();
  const normals = new Array();
  const uvs = new Array();
  let row, col, tileRow, tileCol;
  subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;
  subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;
  precision.w = precision.w < 1 ? 1 : precision.w;
  precision.h = precision.h < 1 ? 1 : precision.h;
  const tileSize = {
    w: (xmax - xmin) / subdivisions.w,
    h: (zmax - zmin) / subdivisions.h
  };
  function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {
    const base = positions.length / 3;
    const rowLength = precision.w + 1;
    for (row = 0; row < precision.h; row++) {
      for (col = 0; col < precision.w; col++) {
        const square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];
        indices.push(square[1]);
        indices.push(square[2]);
        indices.push(square[3]);
        indices.push(square[0]);
        indices.push(square[1]);
        indices.push(square[3]);
      }
    }
    const position = Vector3.Zero();
    const normal = new Vector3(0, 1, 0);
    for (row = 0; row <= precision.h; row++) {
      position.z = row * (zTileMax - zTileMin) / precision.h + zTileMin;
      for (col = 0; col <= precision.w; col++) {
        position.x = col * (xTileMax - xTileMin) / precision.w + xTileMin;
        position.y = 0;
        positions.push(position.x, position.y, position.z);
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(col / precision.w, row / precision.h);
      }
    }
  }
  for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {
    for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {
      applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateGroundFromHeightMapVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let row, col;
  const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);
  const alphaFilter = options.alphaFilter || 0;
  let invert = false;
  if (options.minHeight > options.maxHeight) {
    invert = true;
    const temp = options.maxHeight;
    options.maxHeight = options.minHeight;
    options.minHeight = temp;
  }
  for (row = 0; row <= options.subdivisions; row++) {
    for (col = 0; col <= options.subdivisions; col++) {
      const position = new Vector3(col * options.width / options.subdivisions - options.width / 2, 0, (options.subdivisions - row) * options.height / options.subdivisions - options.height / 2);
      const heightMapX = (position.x + options.width / 2) / options.width * (options.bufferWidth - 1) | 0;
      const heightMapY = (1 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1) | 0;
      const pos = (heightMapX + heightMapY * options.bufferWidth) * 4;
      let r = options.buffer[pos] / 255;
      let g = options.buffer[pos + 1] / 255;
      let b = options.buffer[pos + 2] / 255;
      const a = options.buffer[pos + 3] / 255;
      if (invert) {
        r = 1 - r;
        g = 1 - g;
        b = 1 - b;
      }
      const gradient = r * filter.r + g * filter.g + b * filter.b;
      if (a >= alphaFilter) {
        position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;
      } else {
        position.y = options.minHeight - Epsilon;
      }
      positions.push(position.x, position.y, position.z);
      normals.push(0, 0, 0);
      uvs.push(col / options.subdivisions, 1 - row / options.subdivisions);
    }
  }
  for (row = 0; row < options.subdivisions; row++) {
    for (col = 0; col < options.subdivisions; col++) {
      const idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);
      const idx2 = col + 1 + row * (options.subdivisions + 1);
      const idx3 = col + row * (options.subdivisions + 1);
      const idx4 = col + (row + 1) * (options.subdivisions + 1);
      const isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;
      const isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;
      const isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;
      if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {
        indices.push(idx1);
        indices.push(idx2);
        indices.push(idx3);
      }
      const isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;
      if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {
        indices.push(idx4);
        indices.push(idx1);
        indices.push(idx3);
      }
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateGround(name137, options = {}, scene) {
  const ground = new GroundMesh(name137, scene);
  ground._setReady(false);
  ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;
  ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;
  ground._width = options.width || 1;
  ground._height = options.height || 1;
  ground._maxX = ground._width / 2;
  ground._maxZ = ground._height / 2;
  ground._minX = -ground._maxX;
  ground._minZ = -ground._maxZ;
  const vertexData = CreateGroundVertexData(options);
  vertexData.applyToMesh(ground, options.updatable);
  ground._setReady(true);
  return ground;
}
function CreateTiledGround(name137, options, scene = null) {
  const tiledGround = new Mesh(name137, scene);
  const vertexData = CreateTiledGroundVertexData(options);
  vertexData.applyToMesh(tiledGround, options.updatable);
  return tiledGround;
}
function CreateGroundFromHeightMap(name137, url, options = {}, scene = null) {
  const width = options.width || 10;
  const height = options.height || 10;
  const subdivisions = options.subdivisions || 1 | 0;
  const minHeight = options.minHeight || 0;
  const maxHeight = options.maxHeight || 1;
  const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);
  const alphaFilter = options.alphaFilter || 0;
  const updatable = options.updatable;
  const onReady = options.onReady;
  scene = scene || EngineStore.LastCreatedScene;
  const ground = new GroundMesh(name137, scene);
  ground._subdivisionsX = subdivisions;
  ground._subdivisionsY = subdivisions;
  ground._width = width;
  ground._height = height;
  ground._maxX = ground._width / 2;
  ground._maxZ = ground._height / 2;
  ground._minX = -ground._maxX;
  ground._minZ = -ground._maxZ;
  ground._setReady(false);
  const onload = (img) => {
    const bufferWidth = img.width;
    const bufferHeight = img.height;
    if (scene.isDisposed) {
      return;
    }
    const buffer = scene === null || scene === void 0 ? void 0 : scene.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);
    const vertexData = CreateGroundFromHeightMapVertexData({
      width,
      height,
      subdivisions,
      minHeight,
      maxHeight,
      colorFilter: filter,
      buffer,
      bufferWidth,
      bufferHeight,
      alphaFilter
    });
    vertexData.applyToMesh(ground, updatable);
    if (onReady) {
      onReady(ground);
    }
    ground._setReady(true);
  };
  Tools.LoadImage(url, onload, () => {
  }, scene.offlineProvider);
  return ground;
}
var GroundBuilder = {
  CreateGround,
  CreateGroundFromHeightMap,
  CreateTiledGround
};
VertexData.CreateGround = CreateGroundVertexData;
VertexData.CreateTiledGround = CreateTiledGroundVertexData;
VertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;
Mesh.CreateGround = (name137, width, height, subdivisions, scene, updatable) => {
  const options = {
    width,
    height,
    subdivisions,
    updatable
  };
  return CreateGround(name137, options, scene);
};
Mesh.CreateTiledGround = (name137, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) => {
  const options = {
    xmin,
    zmin,
    xmax,
    zmax,
    subdivisions,
    precision,
    updatable
  };
  return CreateTiledGround(name137, options, scene);
};
Mesh.CreateGroundFromHeightMap = (name137, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) => {
  const options = {
    width,
    height,
    subdivisions,
    minHeight,
    maxHeight,
    updatable,
    onReady,
    alphaFilter
  };
  return CreateGroundFromHeightMap(name137, url, options, scene);
};

// node_modules/@babylonjs/core/Cameras/VR/vrExperienceHelper.js
var VRExperienceHelperGazer = class {
  constructor(scene, gazeTrackerToClone = null) {
    this.scene = scene;
    this._pointerDownOnMeshAsked = false;
    this._isActionableMesh = false;
    this._teleportationRequestInitiated = false;
    this._teleportationBackRequestInitiated = false;
    this._rotationRightAsked = false;
    this._rotationLeftAsked = false;
    this._dpadPressed = true;
    this._activePointer = false;
    this._id = VRExperienceHelperGazer._IdCounter++;
    if (!gazeTrackerToClone) {
      this._gazeTracker = CreateTorus("gazeTracker", {
        diameter: 35e-4,
        thickness: 25e-4,
        tessellation: 20,
        updatable: false
      }, scene);
      this._gazeTracker.bakeCurrentTransformIntoVertices();
      this._gazeTracker.isPickable = false;
      this._gazeTracker.isVisible = false;
      const targetMat = new StandardMaterial("targetMat", scene);
      targetMat.specularColor = Color3.Black();
      targetMat.emissiveColor = new Color3(0.7, 0.7, 0.7);
      targetMat.backFaceCulling = false;
      this._gazeTracker.material = targetMat;
    } else {
      this._gazeTracker = gazeTrackerToClone.clone("gazeTracker");
    }
  }
  _getForwardRay(length) {
    return new Ray(Vector3.Zero(), new Vector3(0, 0, length));
  }
  _selectionPointerDown() {
    this._pointerDownOnMeshAsked = true;
    if (this._currentHit) {
      this.scene.simulatePointerDown(this._currentHit, { pointerId: this._id });
    }
  }
  _selectionPointerUp() {
    if (this._currentHit) {
      this.scene.simulatePointerUp(this._currentHit, { pointerId: this._id });
    }
    this._pointerDownOnMeshAsked = false;
  }
  _activatePointer() {
    this._activePointer = true;
  }
  _deactivatePointer() {
    this._activePointer = false;
  }
  _updatePointerDistance(distance = 100) {
  }
  dispose() {
    this._interactionsEnabled = false;
    this._teleportationEnabled = false;
    if (this._gazeTracker) {
      this._gazeTracker.dispose();
    }
  }
};
VRExperienceHelperGazer._IdCounter = 0;
var VRExperienceHelperControllerGazer = class extends VRExperienceHelperGazer {
  constructor(webVRController, scene, gazeTrackerToClone) {
    super(scene, gazeTrackerToClone);
    this.webVRController = webVRController;
    this._laserPointer = CreateCylinder("laserPointer", {
      updatable: false,
      height: 1,
      diameterTop: 4e-3,
      diameterBottom: 2e-4,
      tessellation: 20,
      subdivisions: 1
    }, scene);
    const laserPointerMaterial = new StandardMaterial("laserPointerMat", scene);
    laserPointerMaterial.emissiveColor = new Color3(0.7, 0.7, 0.7);
    laserPointerMaterial.alpha = 0.6;
    this._laserPointer.material = laserPointerMaterial;
    this._laserPointer.rotation.x = Math.PI / 2;
    this._laserPointer.position.z = -0.5;
    this._laserPointer.isVisible = false;
    this._laserPointer.isPickable = false;
    if (!webVRController.mesh) {
      const preloadMesh = new Mesh("preloadControllerMesh", scene);
      const preloadPointerPose = new Mesh(PoseEnabledController.POINTING_POSE, scene);
      preloadPointerPose.rotation.x = -0.7;
      preloadMesh.addChild(preloadPointerPose);
      webVRController.attachToMesh(preloadMesh);
    }
    this._setLaserPointerParent(webVRController.mesh);
    this._meshAttachedObserver = webVRController._meshAttachedObservable.add((mesh) => {
      this._setLaserPointerParent(mesh);
    });
  }
  _getForwardRay(length) {
    return this.webVRController.getForwardRay(length);
  }
  _activatePointer() {
    super._activatePointer();
    this._laserPointer.isVisible = true;
  }
  _deactivatePointer() {
    super._deactivatePointer();
    this._laserPointer.isVisible = false;
  }
  _setLaserPointerColor(color) {
    this._laserPointer.material.emissiveColor = color;
  }
  _setLaserPointerLightingDisabled(disabled) {
    this._laserPointer.material.disableLighting = disabled;
  }
  _setLaserPointerParent(mesh) {
    const makeNotPick = (root) => {
      root.isPickable = false;
      root.getChildMeshes().forEach((c) => {
        makeNotPick(c);
      });
    };
    makeNotPick(mesh);
    const meshChildren = mesh.getChildren(void 0, false);
    let laserParent = mesh;
    this.webVRController._pointingPoseNode = null;
    for (let i = 0; i < meshChildren.length; i++) {
      if (meshChildren[i].name && meshChildren[i].name.indexOf(PoseEnabledController.POINTING_POSE) >= 0) {
        laserParent = meshChildren[i];
        this.webVRController._pointingPoseNode = laserParent;
        break;
      }
    }
    this._laserPointer.parent = laserParent;
  }
  _updatePointerDistance(distance = 100) {
    this._laserPointer.scaling.y = distance;
    this._laserPointer.position.z = -distance / 2;
  }
  dispose() {
    super.dispose();
    this._laserPointer.dispose();
    if (this._meshAttachedObserver) {
      this.webVRController._meshAttachedObservable.remove(this._meshAttachedObserver);
    }
  }
};
var VRExperienceHelperCameraGazer = class extends VRExperienceHelperGazer {
  constructor(_getCamera, scene) {
    super(scene);
    this._getCamera = _getCamera;
  }
  _getForwardRay(length) {
    const camera = this._getCamera();
    if (camera) {
      return camera.getForwardRay(length);
    } else {
      return new Ray(Vector3.Zero(), Vector3.Forward());
    }
  }
};
var OnAfterEnteringVRObservableEvent = class {
};
var VRExperienceHelper = class {
  constructor(scene, webVROptions = {}) {
    this.webVROptions = webVROptions;
    this._webVRsupported = false;
    this._webVRready = false;
    this._webVRrequesting = false;
    this._webVRpresenting = false;
    this._fullscreenVRpresenting = false;
    this.enableGazeEvenWhenNoPointerLock = false;
    this.exitVROnDoubleTap = true;
    this.onEnteringVRObservable = new Observable();
    this.onAfterEnteringVRObservable = new Observable();
    this.onExitingVRObservable = new Observable();
    this.onControllerMeshLoadedObservable = new Observable();
    this._useCustomVRButton = false;
    this._teleportationRequested = false;
    this._teleportActive = false;
    this._floorMeshesCollection = [];
    this._teleportationMode = VRExperienceHelper.TELEPORTATIONMODE_CONSTANTTIME;
    this._teleportationTime = 122;
    this._teleportationSpeed = 20;
    this._rotationAllowed = true;
    this._teleportBackwardsVector = new Vector3(0, -1, -1);
    this._isDefaultTeleportationTarget = true;
    this._teleportationFillColor = "#444444";
    this._teleportationBorderColor = "#FFFFFF";
    this._rotationAngle = 0;
    this._haloCenter = new Vector3(0, 0, 0);
    this._padSensibilityUp = 0.65;
    this._padSensibilityDown = 0.35;
    this._leftController = null;
    this._rightController = null;
    this._gazeColor = new Color3(0.7, 0.7, 0.7);
    this._laserColor = new Color3(0.7, 0.7, 0.7);
    this._pickedLaserColor = new Color3(0.2, 0.2, 1);
    this._pickedGazeColor = new Color3(0, 0, 1);
    this.onNewMeshSelected = new Observable();
    this.onMeshSelectedWithController = new Observable();
    this.onNewMeshPicked = new Observable();
    this.onBeforeCameraTeleport = new Observable();
    this.onAfterCameraTeleport = new Observable();
    this.onSelectedMeshUnselected = new Observable();
    this.teleportationEnabled = true;
    this._teleportationInitialized = false;
    this._interactionsEnabled = false;
    this._interactionsRequested = false;
    this._displayGaze = true;
    this._displayLaserPointer = true;
    this.updateGazeTrackerScale = true;
    this.updateGazeTrackerColor = true;
    this.updateControllerLaserColor = true;
    this.requestPointerLockOnFullScreen = true;
    this.xrTestDone = false;
    this._onResize = () => {
      this._moveButtonToBottomRight();
      if (this._fullscreenVRpresenting && this._webVRready) {
        this.exitVR();
      }
    };
    this._onFullscreenChange = () => {
      this._fullscreenVRpresenting = !!document.fullscreenElement;
      if (!this._fullscreenVRpresenting && this._inputElement) {
        this.exitVR();
        if (!this._useCustomVRButton && this._btnVR) {
          this._btnVR.style.top = this._inputElement.offsetTop + this._inputElement.offsetHeight - 70 + "px";
          this._btnVR.style.left = this._inputElement.offsetLeft + this._inputElement.offsetWidth - 100 + "px";
          this._updateButtonVisibility();
        }
      }
    };
    this._cachedAngularSensibility = { angularSensibilityX: null, angularSensibilityY: null, angularSensibility: null };
    this._beforeRender = () => {
      if (this._leftController && this._leftController._activePointer) {
        this._castRayAndSelectObject(this._leftController);
      }
      if (this._rightController && this._rightController._activePointer) {
        this._castRayAndSelectObject(this._rightController);
      }
      if (this._noControllerIsActive && (this._scene.getEngine().isPointerLock || this.enableGazeEvenWhenNoPointerLock)) {
        this._castRayAndSelectObject(this._cameraGazer);
      } else {
        this._cameraGazer._gazeTracker.isVisible = false;
      }
    };
    this._onNewGamepadConnected = (gamepad) => {
      if (gamepad.type !== Gamepad.POSE_ENABLED) {
        if (gamepad.leftStick) {
          gamepad.onleftstickchanged((stickValues) => {
            if (this._teleportationInitialized && this.teleportationEnabled) {
              if (!this._leftController && !this._rightController || this._leftController && !this._leftController._activePointer && this._rightController && !this._rightController._activePointer) {
                this._checkTeleportWithRay(stickValues, this._cameraGazer);
                this._checkTeleportBackwards(stickValues, this._cameraGazer);
              }
            }
          });
        }
        if (gamepad.rightStick) {
          gamepad.onrightstickchanged((stickValues) => {
            if (this._teleportationInitialized) {
              this._checkRotate(stickValues, this._cameraGazer);
            }
          });
        }
        if (gamepad.type === Gamepad.XBOX) {
          gamepad.onbuttondown((buttonPressed) => {
            if (this._interactionsEnabled && buttonPressed === Xbox360Button.A) {
              this._cameraGazer._selectionPointerDown();
            }
          });
          gamepad.onbuttonup((buttonPressed) => {
            if (this._interactionsEnabled && buttonPressed === Xbox360Button.A) {
              this._cameraGazer._selectionPointerUp();
            }
          });
        }
      } else {
        const webVRController = gamepad;
        const controller = new VRExperienceHelperControllerGazer(webVRController, this._scene, this._cameraGazer._gazeTracker);
        if (webVRController.hand === "right" || this._leftController && this._leftController.webVRController != webVRController) {
          this._rightController = controller;
        } else {
          this._leftController = controller;
        }
        this._tryEnableInteractionOnController(controller);
      }
    };
    this._tryEnableInteractionOnController = (controller) => {
      if (this._interactionsRequested && !controller._interactionsEnabled) {
        this._enableInteractionOnController(controller);
      }
      if (this._teleportationRequested && !controller._teleportationEnabled) {
        this._enableTeleportationOnController(controller);
      }
    };
    this._onNewGamepadDisconnected = (gamepad) => {
      if (gamepad instanceof WebVRController) {
        if (gamepad.hand === "left" && this._leftController != null) {
          this._leftController.dispose();
          this._leftController = null;
        }
        if (gamepad.hand === "right" && this._rightController != null) {
          this._rightController.dispose();
          this._rightController = null;
        }
      }
    };
    this._workingVector = Vector3.Zero();
    this._workingQuaternion = Quaternion.Identity();
    this._workingMatrix = Matrix.Identity();
    Logger.Warn("WebVR is deprecated. Please avoid using this experience helper and use the WebXR experience helper instead");
    this._scene = scene;
    this._inputElement = scene.getEngine().getInputElement();
    const vrSupported = "getVRDisplays" in navigator;
    if (!vrSupported && webVROptions.useXR === void 0) {
      webVROptions.useXR = true;
    }
    if (webVROptions.createFallbackVRDeviceOrientationFreeCamera === void 0) {
      webVROptions.createFallbackVRDeviceOrientationFreeCamera = true;
    }
    if (webVROptions.createDeviceOrientationCamera === void 0) {
      webVROptions.createDeviceOrientationCamera = true;
    }
    if (webVROptions.laserToggle === void 0) {
      webVROptions.laserToggle = true;
    }
    if (webVROptions.defaultHeight === void 0) {
      webVROptions.defaultHeight = 1.7;
    }
    if (webVROptions.useCustomVRButton) {
      this._useCustomVRButton = true;
      if (webVROptions.customVRButton) {
        this._btnVR = webVROptions.customVRButton;
      }
    }
    if (webVROptions.rayLength) {
      this._rayLength = webVROptions.rayLength;
    }
    this._defaultHeight = webVROptions.defaultHeight;
    if (webVROptions.positionScale) {
      this._rayLength *= webVROptions.positionScale;
      this._defaultHeight *= webVROptions.positionScale;
    }
    this._hasEnteredVR = false;
    if (this._scene.activeCamera) {
      this._position = this._scene.activeCamera.position.clone();
    } else {
      this._position = new Vector3(0, this._defaultHeight, 0);
    }
    if (webVROptions.createDeviceOrientationCamera || !this._scene.activeCamera) {
      this._deviceOrientationCamera = new DeviceOrientationCamera("deviceOrientationVRHelper", this._position.clone(), scene);
      if (this._scene.activeCamera) {
        this._deviceOrientationCamera.minZ = this._scene.activeCamera.minZ;
        this._deviceOrientationCamera.maxZ = this._scene.activeCamera.maxZ;
        if (this._scene.activeCamera instanceof TargetCamera && this._scene.activeCamera.rotation) {
          const targetCamera = this._scene.activeCamera;
          if (targetCamera.rotationQuaternion) {
            this._deviceOrientationCamera.rotationQuaternion.copyFrom(targetCamera.rotationQuaternion);
          } else {
            this._deviceOrientationCamera.rotationQuaternion.copyFrom(Quaternion.RotationYawPitchRoll(targetCamera.rotation.y, targetCamera.rotation.x, targetCamera.rotation.z));
          }
          this._deviceOrientationCamera.rotation = targetCamera.rotation.clone();
        }
      }
      this._scene.activeCamera = this._deviceOrientationCamera;
      if (this._inputElement) {
        this._scene.activeCamera.attachControl();
      }
    } else {
      this._existingCamera = this._scene.activeCamera;
    }
    if (this.webVROptions.useXR && navigator.xr) {
      WebXRSessionManager.IsSessionSupportedAsync("immersive-vr").then((supported) => {
        if (supported) {
          Logger.Log("Using WebXR. It is recommended to use the WebXRDefaultExperience directly");
          scene.createDefaultXRExperienceAsync({
            floorMeshes: webVROptions.floorMeshes || []
          }).then((xr) => {
            this.xr = xr;
            this.xrTestDone = true;
            this._cameraGazer = new VRExperienceHelperCameraGazer(() => {
              return this.xr.baseExperience.camera;
            }, scene);
            this.xr.baseExperience.onStateChangedObservable.add((state) => {
              switch (state) {
                case WebXRState.ENTERING_XR:
                  this.onEnteringVRObservable.notifyObservers(this);
                  if (!this._interactionsEnabled) {
                    this.xr.pointerSelection.detach();
                  }
                  this.xr.pointerSelection.displayLaserPointer = this._displayLaserPointer;
                  break;
                case WebXRState.EXITING_XR:
                  this.onExitingVRObservable.notifyObservers(this);
                  this._scene.getEngine().resize();
                  break;
                case WebXRState.IN_XR:
                  this._hasEnteredVR = true;
                  break;
                case WebXRState.NOT_IN_XR:
                  this._hasEnteredVR = false;
                  break;
              }
            });
          });
        } else {
          this._completeVRInit(scene, webVROptions);
        }
      });
    } else {
      this._completeVRInit(scene, webVROptions);
    }
  }
  get onEnteringVR() {
    return this.onEnteringVRObservable;
  }
  get onExitingVR() {
    return this.onExitingVRObservable;
  }
  get onControllerMeshLoaded() {
    return this.onControllerMeshLoadedObservable;
  }
  get teleportationTarget() {
    return this._teleportationTarget;
  }
  set teleportationTarget(value) {
    if (value) {
      value.name = "teleportationTarget";
      this._isDefaultTeleportationTarget = false;
      this._teleportationTarget = value;
    }
  }
  get gazeTrackerMesh() {
    return this._cameraGazer._gazeTracker;
  }
  set gazeTrackerMesh(value) {
    if (value) {
      if (this._cameraGazer._gazeTracker) {
        this._cameraGazer._gazeTracker.dispose();
      }
      if (this._leftController && this._leftController._gazeTracker) {
        this._leftController._gazeTracker.dispose();
      }
      if (this._rightController && this._rightController._gazeTracker) {
        this._rightController._gazeTracker.dispose();
      }
      this._cameraGazer._gazeTracker = value;
      this._cameraGazer._gazeTracker.bakeCurrentTransformIntoVertices();
      this._cameraGazer._gazeTracker.isPickable = false;
      this._cameraGazer._gazeTracker.isVisible = false;
      this._cameraGazer._gazeTracker.name = "gazeTracker";
      if (this._leftController) {
        this._leftController._gazeTracker = this._cameraGazer._gazeTracker.clone("gazeTracker");
      }
      if (this._rightController) {
        this._rightController._gazeTracker = this._cameraGazer._gazeTracker.clone("gazeTracker");
      }
    }
  }
  get leftControllerGazeTrackerMesh() {
    if (this._leftController) {
      return this._leftController._gazeTracker;
    }
    return null;
  }
  get rightControllerGazeTrackerMesh() {
    if (this._rightController) {
      return this._rightController._gazeTracker;
    }
    return null;
  }
  get displayGaze() {
    return this._displayGaze;
  }
  set displayGaze(value) {
    this._displayGaze = value;
    if (!value) {
      this._cameraGazer._gazeTracker.isVisible = false;
      if (this._leftController) {
        this._leftController._gazeTracker.isVisible = false;
      }
      if (this._rightController) {
        this._rightController._gazeTracker.isVisible = false;
      }
    }
  }
  get displayLaserPointer() {
    return this._displayLaserPointer;
  }
  set displayLaserPointer(value) {
    this._displayLaserPointer = value;
    if (!value) {
      if (this._rightController) {
        this._rightController._deactivatePointer();
        this._rightController._gazeTracker.isVisible = false;
      }
      if (this._leftController) {
        this._leftController._deactivatePointer();
        this._leftController._gazeTracker.isVisible = false;
      }
    } else {
      if (this._rightController) {
        this._rightController._activatePointer();
      }
      if (this._leftController) {
        this._leftController._activatePointer();
      }
    }
  }
  get deviceOrientationCamera() {
    return this._deviceOrientationCamera;
  }
  get currentVRCamera() {
    if (this._webVRready) {
      return this._webVRCamera;
    } else {
      return this._scene.activeCamera;
    }
  }
  get webVRCamera() {
    return this._webVRCamera;
  }
  get vrDeviceOrientationCamera() {
    return this._vrDeviceOrientationCamera;
  }
  get vrButton() {
    return this._btnVR;
  }
  get _teleportationRequestInitiated() {
    const result = this._cameraGazer._teleportationRequestInitiated || this._leftController !== null && this._leftController._teleportationRequestInitiated || this._rightController !== null && this._rightController._teleportationRequestInitiated;
    return result;
  }
  _completeVRInit(scene, webVROptions) {
    this.xrTestDone = true;
    if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {
      if (webVROptions.useMultiview) {
        if (!webVROptions.vrDeviceOrientationCameraMetrics) {
          webVROptions.vrDeviceOrientationCameraMetrics = VRCameraMetrics.GetDefault();
        }
        webVROptions.vrDeviceOrientationCameraMetrics.multiviewEnabled = true;
      }
      this._vrDeviceOrientationCamera = new VRDeviceOrientationFreeCamera("VRDeviceOrientationVRHelper", this._position, this._scene, true, webVROptions.vrDeviceOrientationCameraMetrics);
      this._vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;
    }
    this._webVRCamera = new WebVRFreeCamera("WebVRHelper", this._position, this._scene, webVROptions);
    this._webVRCamera.useStandingMatrix();
    this._cameraGazer = new VRExperienceHelperCameraGazer(() => {
      return this.currentVRCamera;
    }, scene);
    if (!this._useCustomVRButton) {
      this._btnVR = document.createElement("BUTTON");
      this._btnVR.className = "babylonVRicon";
      this._btnVR.id = "babylonVRiconbtn";
      this._btnVR.title = "Click to switch to VR";
      const url = !window.SVGSVGElement ? "https://cdn.babylonjs.com/Assets/vrButton.png" : "data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A";
      let css = ".babylonVRicon { position: absolute; right: 20px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(" + url + "); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }";
      css += ".babylonVRicon.vrdisplaypresenting { display: none; }";
      const style = document.createElement("style");
      style.appendChild(document.createTextNode(css));
      document.getElementsByTagName("head")[0].appendChild(style);
      this._moveButtonToBottomRight();
    }
    if (this._btnVR) {
      this._btnVR.addEventListener("click", () => {
        if (!this.isInVRMode) {
          this.enterVR();
        } else {
          this._scene.getEngine().disableVR();
        }
      });
    }
    const hostWindow = this._scene.getEngine().getHostWindow();
    if (!hostWindow) {
      return;
    }
    hostWindow.addEventListener("resize", this._onResize);
    document.addEventListener("fullscreenchange", this._onFullscreenChange, false);
    if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {
      this._displayVRButton();
    } else {
      this._scene.getEngine().onVRDisplayChangedObservable.add((e) => {
        if (e.vrDisplay) {
          this._displayVRButton();
        }
      });
    }
    this._onKeyDown = (event) => {
      if (event.keyCode === 27 && this.isInVRMode) {
        this.exitVR();
      }
    };
    document.addEventListener("keydown", this._onKeyDown);
    this._scene.onPrePointerObservable.add(() => {
      if (this._hasEnteredVR && this.exitVROnDoubleTap) {
        this.exitVR();
        if (this._fullscreenVRpresenting) {
          this._scene.getEngine().exitFullscreen();
        }
      }
    }, PointerEventTypes.POINTERDOUBLETAP, false);
    this._onVRDisplayChangedBind = (eventArgs) => this._onVRDisplayChanged(eventArgs);
    this._onVrDisplayPresentChangeBind = () => this._onVrDisplayPresentChange();
    this._onVRRequestPresentStart = () => {
      this._webVRrequesting = true;
      this._updateButtonVisibility();
    };
    this._onVRRequestPresentComplete = () => {
      this._webVRrequesting = false;
      this._updateButtonVisibility();
    };
    scene.getEngine().onVRDisplayChangedObservable.add(this._onVRDisplayChangedBind);
    scene.getEngine().onVRRequestPresentStart.add(this._onVRRequestPresentStart);
    scene.getEngine().onVRRequestPresentComplete.add(this._onVRRequestPresentComplete);
    hostWindow.addEventListener("vrdisplaypresentchange", this._onVrDisplayPresentChangeBind);
    scene.onDisposeObservable.add(() => {
      this.dispose();
    });
    this._webVRCamera.onControllerMeshLoadedObservable.add((webVRController) => this._onDefaultMeshLoaded(webVRController));
    this._scene.gamepadManager.onGamepadConnectedObservable.add(this._onNewGamepadConnected);
    this._scene.gamepadManager.onGamepadDisconnectedObservable.add(this._onNewGamepadDisconnected);
    this._updateButtonVisibility();
    this._circleEase = new CircleEase();
    this._circleEase.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);
    this._teleportationEasing = this._circleEase;
    scene.onPointerObservable.add((e) => {
      if (this._interactionsEnabled) {
        if (scene.activeCamera === this.vrDeviceOrientationCamera && e.event.pointerType === "mouse") {
          if (e.type === PointerEventTypes.POINTERDOWN) {
            this._cameraGazer._selectionPointerDown();
          } else if (e.type === PointerEventTypes.POINTERUP) {
            this._cameraGazer._selectionPointerUp();
          }
        }
      }
    });
    if (this.webVROptions.floorMeshes) {
      this.enableTeleportation({ floorMeshes: this.webVROptions.floorMeshes });
    }
  }
  _onDefaultMeshLoaded(webVRController) {
    if (this._leftController && this._leftController.webVRController == webVRController) {
      if (webVRController.mesh) {
        this._leftController._setLaserPointerParent(webVRController.mesh);
      }
    }
    if (this._rightController && this._rightController.webVRController == webVRController) {
      if (webVRController.mesh) {
        this._rightController._setLaserPointerParent(webVRController.mesh);
      }
    }
    try {
      this.onControllerMeshLoadedObservable.notifyObservers(webVRController);
    } catch (err) {
      Logger.Warn("Error in your custom logic onControllerMeshLoaded: " + err);
    }
  }
  get isInVRMode() {
    return this.xr && this.webVROptions.useXR && this.xr.baseExperience.state === WebXRState.IN_XR || this._webVRpresenting || this._fullscreenVRpresenting;
  }
  _onVrDisplayPresentChange() {
    const vrDisplay = this._scene.getEngine().getVRDevice();
    if (vrDisplay) {
      const wasPresenting = this._webVRpresenting;
      this._webVRpresenting = vrDisplay.isPresenting;
      if (wasPresenting && !this._webVRpresenting) {
        this.exitVR();
      }
    } else {
      Logger.Warn("Detected VRDisplayPresentChange on an unknown VRDisplay. Did you can enterVR on the vrExperienceHelper?");
    }
    this._updateButtonVisibility();
  }
  _onVRDisplayChanged(eventArgs) {
    this._webVRsupported = eventArgs.vrSupported;
    this._webVRready = !!eventArgs.vrDisplay;
    this._webVRpresenting = eventArgs.vrDisplay && eventArgs.vrDisplay.isPresenting;
    this._updateButtonVisibility();
  }
  _moveButtonToBottomRight() {
    if (this._inputElement && !this._useCustomVRButton && this._btnVR) {
      const rect = this._inputElement.getBoundingClientRect();
      this._btnVR.style.top = rect.top + rect.height - 70 + "px";
      this._btnVR.style.left = rect.left + rect.width - 100 + "px";
    }
  }
  _displayVRButton() {
    if (!this._useCustomVRButton && !this._btnVRDisplayed && this._btnVR) {
      document.body.appendChild(this._btnVR);
      this._btnVRDisplayed = true;
    }
  }
  _updateButtonVisibility() {
    if (!this._btnVR || this._useCustomVRButton) {
      return;
    }
    this._btnVR.className = "babylonVRicon";
    if (this.isInVRMode) {
      this._btnVR.className += " vrdisplaypresenting";
    } else {
      if (this._webVRready) {
        this._btnVR.className += " vrdisplayready";
      }
      if (this._webVRsupported) {
        this._btnVR.className += " vrdisplaysupported";
      }
      if (this._webVRrequesting) {
        this._btnVR.className += " vrdisplayrequesting";
      }
    }
  }
  enterVR() {
    if (this.xr) {
      this.xr.baseExperience.enterXRAsync("immersive-vr", "local-floor", this.xr.renderTarget);
      return;
    }
    if (this.onEnteringVRObservable) {
      try {
        this.onEnteringVRObservable.notifyObservers(this);
      } catch (err) {
        Logger.Warn("Error in your custom logic onEnteringVR: " + err);
      }
    }
    if (this._scene.activeCamera) {
      this._position = this._scene.activeCamera.position.clone();
      if (this.vrDeviceOrientationCamera) {
        this.vrDeviceOrientationCamera.rotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles();
        this.vrDeviceOrientationCamera.angularSensibility = 2e3;
      }
      if (this.webVRCamera) {
        const currentYRotation = this.webVRCamera.deviceRotationQuaternion.toEulerAngles().y;
        const desiredYRotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles().y;
        const delta = desiredYRotation - currentYRotation;
        const currentGlobalRotation = this.webVRCamera.rotationQuaternion.toEulerAngles().y;
        this.webVRCamera.rotationQuaternion = Quaternion.FromEulerAngles(0, currentGlobalRotation + delta, 0);
      }
      this._existingCamera = this._scene.activeCamera;
      if (this._existingCamera.angularSensibilityX) {
        this._cachedAngularSensibility.angularSensibilityX = this._existingCamera.angularSensibilityX;
        this._existingCamera.angularSensibilityX = Number.MAX_VALUE;
      }
      if (this._existingCamera.angularSensibilityY) {
        this._cachedAngularSensibility.angularSensibilityY = this._existingCamera.angularSensibilityY;
        this._existingCamera.angularSensibilityY = Number.MAX_VALUE;
      }
      if (this._existingCamera.angularSensibility) {
        this._cachedAngularSensibility.angularSensibility = this._existingCamera.angularSensibility;
        this._existingCamera.angularSensibility = Number.MAX_VALUE;
      }
    }
    if (this._webVRrequesting) {
      return;
    }
    if (this._webVRready) {
      if (!this._webVRpresenting) {
        this._scene.getEngine().onVRRequestPresentComplete.addOnce((result) => {
          this.onAfterEnteringVRObservable.notifyObservers({ success: result });
        });
        this._webVRCamera.position = this._position;
        this._scene.activeCamera = this._webVRCamera;
      }
    } else if (this._vrDeviceOrientationCamera) {
      this._vrDeviceOrientationCamera.position = this._position;
      if (this._scene.activeCamera) {
        this._vrDeviceOrientationCamera.minZ = this._scene.activeCamera.minZ;
      }
      this._scene.activeCamera = this._vrDeviceOrientationCamera;
      this._scene.getEngine().enterFullscreen(this.requestPointerLockOnFullScreen);
      this._updateButtonVisibility();
      this._vrDeviceOrientationCamera.onViewMatrixChangedObservable.addOnce(() => {
        this.onAfterEnteringVRObservable.notifyObservers({ success: true });
      });
    }
    if (this._scene.activeCamera && this._inputElement) {
      this._scene.activeCamera.attachControl();
    }
    if (this._interactionsEnabled) {
      this._scene.registerBeforeRender(this._beforeRender);
    }
    if (this._displayLaserPointer) {
      [this._leftController, this._rightController].forEach((controller) => {
        if (controller) {
          controller._activatePointer();
        }
      });
    }
    this._hasEnteredVR = true;
  }
  exitVR() {
    if (this.xr) {
      this.xr.baseExperience.exitXRAsync();
      return;
    }
    if (this._hasEnteredVR) {
      if (this.onExitingVRObservable) {
        try {
          this.onExitingVRObservable.notifyObservers(this);
        } catch (err) {
          Logger.Warn("Error in your custom logic onExitingVR: " + err);
        }
      }
      if (this._webVRpresenting) {
        this._scene.getEngine().disableVR();
      }
      if (this._scene.activeCamera) {
        this._position = this._scene.activeCamera.position.clone();
      }
      if (this.vrDeviceOrientationCamera) {
        this.vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;
      }
      if (this._deviceOrientationCamera) {
        this._deviceOrientationCamera.position = this._position;
        this._scene.activeCamera = this._deviceOrientationCamera;
        if (this._cachedAngularSensibility.angularSensibilityX) {
          this._deviceOrientationCamera.angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;
          this._cachedAngularSensibility.angularSensibilityX = null;
        }
        if (this._cachedAngularSensibility.angularSensibilityY) {
          this._deviceOrientationCamera.angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;
          this._cachedAngularSensibility.angularSensibilityY = null;
        }
        if (this._cachedAngularSensibility.angularSensibility) {
          this._deviceOrientationCamera.angularSensibility = this._cachedAngularSensibility.angularSensibility;
          this._cachedAngularSensibility.angularSensibility = null;
        }
      } else if (this._existingCamera) {
        this._existingCamera.position = this._position;
        this._scene.activeCamera = this._existingCamera;
        if (this._inputElement) {
          this._scene.activeCamera.attachControl();
        }
        if (this._cachedAngularSensibility.angularSensibilityX) {
          this._existingCamera.angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;
          this._cachedAngularSensibility.angularSensibilityX = null;
        }
        if (this._cachedAngularSensibility.angularSensibilityY) {
          this._existingCamera.angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;
          this._cachedAngularSensibility.angularSensibilityY = null;
        }
        if (this._cachedAngularSensibility.angularSensibility) {
          this._existingCamera.angularSensibility = this._cachedAngularSensibility.angularSensibility;
          this._cachedAngularSensibility.angularSensibility = null;
        }
      }
      this._updateButtonVisibility();
      if (this._interactionsEnabled) {
        this._scene.unregisterBeforeRender(this._beforeRender);
        this._cameraGazer._gazeTracker.isVisible = false;
        if (this._leftController) {
          this._leftController._gazeTracker.isVisible = false;
        }
        if (this._rightController) {
          this._rightController._gazeTracker.isVisible = false;
        }
      }
      this._scene.getEngine().resize();
      [this._leftController, this._rightController].forEach((controller) => {
        if (controller) {
          controller._deactivatePointer();
        }
      });
      this._hasEnteredVR = false;
      const engine = this._scene.getEngine();
      if (engine._onVrDisplayPresentChange) {
        engine._onVrDisplayPresentChange();
      }
    }
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    if (this._scene.activeCamera) {
      this._scene.activeCamera.position = value;
    }
  }
  enableInteractions() {
    if (!this._interactionsEnabled) {
      this._interactionsRequested = true;
      if (this.xr) {
        if (this.xr.baseExperience.state === WebXRState.IN_XR) {
          this.xr.pointerSelection.attach();
        }
        return;
      }
      if (this._leftController) {
        this._enableInteractionOnController(this._leftController);
      }
      if (this._rightController) {
        this._enableInteractionOnController(this._rightController);
      }
      this.raySelectionPredicate = (mesh) => {
        return mesh.isVisible && (mesh.isPickable || mesh.name === this._floorMeshName);
      };
      this.meshSelectionPredicate = () => {
        return true;
      };
      this._raySelectionPredicate = (mesh) => {
        if (this._isTeleportationFloor(mesh) || mesh.name.indexOf("gazeTracker") === -1 && mesh.name.indexOf("teleportationTarget") === -1 && mesh.name.indexOf("torusTeleportation") === -1) {
          return this.raySelectionPredicate(mesh);
        }
        return false;
      };
      this._interactionsEnabled = true;
    }
  }
  get _noControllerIsActive() {
    return !(this._leftController && this._leftController._activePointer) && !(this._rightController && this._rightController._activePointer);
  }
  _isTeleportationFloor(mesh) {
    for (let i = 0; i < this._floorMeshesCollection.length; i++) {
      if (this._floorMeshesCollection[i].id === mesh.id) {
        return true;
      }
    }
    if (this._floorMeshName && mesh.name === this._floorMeshName) {
      return true;
    }
    return false;
  }
  addFloorMesh(floorMesh) {
    if (!this._floorMeshesCollection) {
      return;
    }
    if (this._floorMeshesCollection.indexOf(floorMesh) > -1) {
      return;
    }
    this._floorMeshesCollection.push(floorMesh);
  }
  removeFloorMesh(floorMesh) {
    if (!this._floorMeshesCollection) {
      return;
    }
    const meshIndex = this._floorMeshesCollection.indexOf(floorMesh);
    if (meshIndex !== -1) {
      this._floorMeshesCollection.splice(meshIndex, 1);
    }
  }
  enableTeleportation(vrTeleportationOptions = {}) {
    if (!this._teleportationInitialized) {
      this._teleportationRequested = true;
      this.enableInteractions();
      if (this.webVROptions.useXR && (vrTeleportationOptions.floorMeshes || vrTeleportationOptions.floorMeshName)) {
        const floorMeshes = vrTeleportationOptions.floorMeshes || [];
        if (!floorMeshes.length) {
          const floorMesh = this._scene.getMeshByName(vrTeleportationOptions.floorMeshName);
          if (floorMesh) {
            floorMeshes.push(floorMesh);
          }
        }
        if (this.xr) {
          floorMeshes.forEach((mesh) => {
            this.xr.teleportation.addFloorMesh(mesh);
          });
          if (!this.xr.teleportation.attached) {
            this.xr.teleportation.attach();
          }
          return;
        } else if (!this.xrTestDone) {
          const waitForXr = () => {
            if (this.xrTestDone) {
              this._scene.unregisterBeforeRender(waitForXr);
              if (this.xr) {
                if (!this.xr.teleportation.attached) {
                  this.xr.teleportation.attach();
                }
              } else {
                this.enableTeleportation(vrTeleportationOptions);
              }
            }
          };
          this._scene.registerBeforeRender(waitForXr);
          return;
        }
      }
      if (vrTeleportationOptions.floorMeshName) {
        this._floorMeshName = vrTeleportationOptions.floorMeshName;
      }
      if (vrTeleportationOptions.floorMeshes) {
        this._floorMeshesCollection = vrTeleportationOptions.floorMeshes;
      }
      if (vrTeleportationOptions.teleportationMode) {
        this._teleportationMode = vrTeleportationOptions.teleportationMode;
      }
      if (vrTeleportationOptions.teleportationTime && vrTeleportationOptions.teleportationTime > 0) {
        this._teleportationTime = vrTeleportationOptions.teleportationTime;
      }
      if (vrTeleportationOptions.teleportationSpeed && vrTeleportationOptions.teleportationSpeed > 0) {
        this._teleportationSpeed = vrTeleportationOptions.teleportationSpeed;
      }
      if (vrTeleportationOptions.easingFunction !== void 0) {
        this._teleportationEasing = vrTeleportationOptions.easingFunction;
      }
      if (this._leftController != null) {
        this._enableTeleportationOnController(this._leftController);
      }
      if (this._rightController != null) {
        this._enableTeleportationOnController(this._rightController);
      }
      const imageProcessingConfiguration = new ImageProcessingConfiguration();
      imageProcessingConfiguration.vignetteColor = new Color4(0, 0, 0, 0);
      imageProcessingConfiguration.vignetteEnabled = true;
      this._postProcessMove = new ImageProcessingPostProcess("postProcessMove", 1, this._webVRCamera, void 0, void 0, void 0, void 0, imageProcessingConfiguration);
      this._webVRCamera.detachPostProcess(this._postProcessMove);
      this._teleportationInitialized = true;
      if (this._isDefaultTeleportationTarget) {
        this._createTeleportationCircles();
        this._teleportationTarget.scaling.scaleInPlace(this._webVRCamera.deviceScaleFactor);
      }
    }
  }
  _enableInteractionOnController(controller) {
    const controllerMesh = controller.webVRController.mesh;
    if (controllerMesh) {
      controller._interactionsEnabled = true;
      if (this.isInVRMode && this._displayLaserPointer) {
        controller._activatePointer();
      }
      if (this.webVROptions.laserToggle) {
        controller.webVRController.onMainButtonStateChangedObservable.add((stateObject) => {
          if (this._displayLaserPointer && stateObject.value === 1) {
            if (controller._activePointer) {
              controller._deactivatePointer();
            } else {
              controller._activatePointer();
            }
            if (this.displayGaze) {
              controller._gazeTracker.isVisible = controller._activePointer;
            }
          }
        });
      }
      controller.webVRController.onTriggerStateChangedObservable.add((stateObject) => {
        let gazer = controller;
        if (this._noControllerIsActive) {
          gazer = this._cameraGazer;
        }
        if (!gazer._pointerDownOnMeshAsked) {
          if (stateObject.value > this._padSensibilityUp) {
            gazer._selectionPointerDown();
          }
        } else if (stateObject.value < this._padSensibilityDown) {
          gazer._selectionPointerUp();
        }
      });
    }
  }
  _checkTeleportWithRay(stateObject, gazer) {
    if (this._teleportationRequestInitiated && !gazer._teleportationRequestInitiated) {
      return;
    }
    if (!gazer._teleportationRequestInitiated) {
      if (stateObject.y < -this._padSensibilityUp && gazer._dpadPressed) {
        gazer._activatePointer();
        gazer._teleportationRequestInitiated = true;
      }
    } else {
      if (Math.sqrt(stateObject.y * stateObject.y + stateObject.x * stateObject.x) < this._padSensibilityDown) {
        if (this._teleportActive) {
          this.teleportCamera(this._haloCenter);
        }
        gazer._teleportationRequestInitiated = false;
      }
    }
  }
  _checkRotate(stateObject, gazer) {
    if (gazer._teleportationRequestInitiated) {
      return;
    }
    if (!gazer._rotationLeftAsked) {
      if (stateObject.x < -this._padSensibilityUp && gazer._dpadPressed) {
        gazer._rotationLeftAsked = true;
        if (this._rotationAllowed) {
          this._rotateCamera(false);
        }
      }
    } else {
      if (stateObject.x > -this._padSensibilityDown) {
        gazer._rotationLeftAsked = false;
      }
    }
    if (!gazer._rotationRightAsked) {
      if (stateObject.x > this._padSensibilityUp && gazer._dpadPressed) {
        gazer._rotationRightAsked = true;
        if (this._rotationAllowed) {
          this._rotateCamera(true);
        }
      }
    } else {
      if (stateObject.x < this._padSensibilityDown) {
        gazer._rotationRightAsked = false;
      }
    }
  }
  _checkTeleportBackwards(stateObject, gazer) {
    if (gazer._teleportationRequestInitiated) {
      return;
    }
    if (stateObject.y > this._padSensibilityUp && gazer._dpadPressed) {
      if (!gazer._teleportationBackRequestInitiated) {
        if (!this.currentVRCamera) {
          return;
        }
        let rotation = Quaternion.FromRotationMatrix(this.currentVRCamera.getWorldMatrix().getRotationMatrix());
        let position = this.currentVRCamera.position;
        if (this.currentVRCamera.devicePosition && this.currentVRCamera.deviceRotationQuaternion) {
          rotation = this.currentVRCamera.deviceRotationQuaternion;
          position = this.currentVRCamera.devicePosition;
        }
        rotation.toEulerAnglesToRef(this._workingVector);
        this._workingVector.z = 0;
        this._workingVector.x = 0;
        Quaternion.RotationYawPitchRollToRef(this._workingVector.y, this._workingVector.x, this._workingVector.z, this._workingQuaternion);
        this._workingQuaternion.toRotationMatrix(this._workingMatrix);
        Vector3.TransformCoordinatesToRef(this._teleportBackwardsVector, this._workingMatrix, this._workingVector);
        const ray = new Ray(position, this._workingVector);
        const hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);
        if (hit && hit.pickedPoint && hit.pickedMesh && this._isTeleportationFloor(hit.pickedMesh) && hit.distance < 5) {
          this.teleportCamera(hit.pickedPoint);
        }
        gazer._teleportationBackRequestInitiated = true;
      }
    } else {
      gazer._teleportationBackRequestInitiated = false;
    }
  }
  _enableTeleportationOnController(controller) {
    const controllerMesh = controller.webVRController.mesh;
    if (controllerMesh) {
      if (!controller._interactionsEnabled) {
        this._enableInteractionOnController(controller);
      }
      controller._interactionsEnabled = true;
      controller._teleportationEnabled = true;
      if (controller.webVRController.controllerType === PoseEnabledControllerType.VIVE) {
        controller._dpadPressed = false;
        controller.webVRController.onPadStateChangedObservable.add((stateObject) => {
          controller._dpadPressed = stateObject.pressed;
          if (!controller._dpadPressed) {
            controller._rotationLeftAsked = false;
            controller._rotationRightAsked = false;
            controller._teleportationBackRequestInitiated = false;
          }
        });
      }
      controller.webVRController.onPadValuesChangedObservable.add((stateObject) => {
        if (this.teleportationEnabled) {
          this._checkTeleportBackwards(stateObject, controller);
          this._checkTeleportWithRay(stateObject, controller);
        }
        this._checkRotate(stateObject, controller);
      });
    }
  }
  _createTeleportationCircles() {
    this._teleportationTarget = CreateGround("teleportationTarget", { width: 2, height: 2, subdivisions: 2 }, this._scene);
    this._teleportationTarget.isPickable = false;
    const length = 512;
    const dynamicTexture = new DynamicTexture("DynamicTexture", length, this._scene, true);
    dynamicTexture.hasAlpha = true;
    const context = dynamicTexture.getContext();
    const centerX = length / 2;
    const centerY = length / 2;
    const radius = 200;
    context.beginPath();
    context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
    context.fillStyle = this._teleportationFillColor;
    context.fill();
    context.lineWidth = 10;
    context.strokeStyle = this._teleportationBorderColor;
    context.stroke();
    context.closePath();
    dynamicTexture.update();
    const teleportationCircleMaterial = new StandardMaterial("TextPlaneMaterial", this._scene);
    teleportationCircleMaterial.diffuseTexture = dynamicTexture;
    this._teleportationTarget.material = teleportationCircleMaterial;
    const torus = CreateTorus("torusTeleportation", {
      diameter: 0.75,
      thickness: 0.1,
      tessellation: 25,
      updatable: false
    }, this._scene);
    torus.isPickable = false;
    torus.parent = this._teleportationTarget;
    const animationInnerCircle = new Animation("animationInnerCircle", "position.y", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);
    const keys = [];
    keys.push({
      frame: 0,
      value: 0
    });
    keys.push({
      frame: 30,
      value: 0.4
    });
    keys.push({
      frame: 60,
      value: 0
    });
    animationInnerCircle.setKeys(keys);
    const easingFunction = new SineEase();
    easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);
    animationInnerCircle.setEasingFunction(easingFunction);
    torus.animations = [];
    torus.animations.push(animationInnerCircle);
    this._scene.beginAnimation(torus, 0, 60, true);
    this._hideTeleportationTarget();
  }
  _displayTeleportationTarget() {
    this._teleportActive = true;
    if (this._teleportationInitialized) {
      this._teleportationTarget.isVisible = true;
      if (this._isDefaultTeleportationTarget) {
        this._teleportationTarget.getChildren()[0].isVisible = true;
      }
    }
  }
  _hideTeleportationTarget() {
    this._teleportActive = false;
    if (this._teleportationInitialized) {
      this._teleportationTarget.isVisible = false;
      if (this._isDefaultTeleportationTarget) {
        this._teleportationTarget.getChildren()[0].isVisible = false;
      }
    }
  }
  _rotateCamera(right) {
    if (!(this.currentVRCamera instanceof FreeCamera)) {
      return;
    }
    if (right) {
      this._rotationAngle++;
    } else {
      this._rotationAngle--;
    }
    this.currentVRCamera.animations = [];
    const target = Quaternion.FromRotationMatrix(Matrix.RotationY(Math.PI / 4 * this._rotationAngle));
    const animationRotation = new Animation("animationRotation", "rotationQuaternion", 90, Animation.ANIMATIONTYPE_QUATERNION, Animation.ANIMATIONLOOPMODE_CONSTANT);
    const animationRotationKeys = [];
    animationRotationKeys.push({
      frame: 0,
      value: this.currentVRCamera.rotationQuaternion
    });
    animationRotationKeys.push({
      frame: 6,
      value: target
    });
    animationRotation.setKeys(animationRotationKeys);
    animationRotation.setEasingFunction(this._circleEase);
    this.currentVRCamera.animations.push(animationRotation);
    this._postProcessMove.animations = [];
    const animationPP = new Animation("animationPP", "vignetteWeight", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
    const vignetteWeightKeys = [];
    vignetteWeightKeys.push({
      frame: 0,
      value: 0
    });
    vignetteWeightKeys.push({
      frame: 3,
      value: 4
    });
    vignetteWeightKeys.push({
      frame: 6,
      value: 0
    });
    animationPP.setKeys(vignetteWeightKeys);
    animationPP.setEasingFunction(this._circleEase);
    this._postProcessMove.animations.push(animationPP);
    const animationPP2 = new Animation("animationPP2", "vignetteStretch", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
    const vignetteStretchKeys = [];
    vignetteStretchKeys.push({
      frame: 0,
      value: 0
    });
    vignetteStretchKeys.push({
      frame: 3,
      value: 10
    });
    vignetteStretchKeys.push({
      frame: 6,
      value: 0
    });
    animationPP2.setKeys(vignetteStretchKeys);
    animationPP2.setEasingFunction(this._circleEase);
    this._postProcessMove.animations.push(animationPP2);
    this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;
    this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;
    this._postProcessMove.samples = 4;
    this._webVRCamera.attachPostProcess(this._postProcessMove);
    this._scene.beginAnimation(this._postProcessMove, 0, 6, false, 1, () => {
      this._webVRCamera.detachPostProcess(this._postProcessMove);
    });
    this._scene.beginAnimation(this.currentVRCamera, 0, 6, false, 1);
  }
  _moveTeleportationSelectorTo(hit, gazer, ray) {
    if (hit.pickedPoint) {
      if (gazer._teleportationRequestInitiated) {
        this._displayTeleportationTarget();
        this._haloCenter.copyFrom(hit.pickedPoint);
        this._teleportationTarget.position.copyFrom(hit.pickedPoint);
      }
      const pickNormal = this._convertNormalToDirectionOfRay(hit.getNormal(true, false), ray);
      if (pickNormal) {
        const axis1 = Vector3.Cross(Axis.Y, pickNormal);
        const axis2 = Vector3.Cross(pickNormal, axis1);
        Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, this._teleportationTarget.rotation);
      }
      this._teleportationTarget.position.y += 0.1;
    }
  }
  teleportCamera(location) {
    if (!(this.currentVRCamera instanceof FreeCamera)) {
      return;
    }
    if (this.webVRCamera.leftCamera) {
      this._workingVector.copyFrom(this.webVRCamera.leftCamera.globalPosition);
      this._workingVector.subtractInPlace(this.webVRCamera.position);
      location.subtractToRef(this._workingVector, this._workingVector);
    } else {
      this._workingVector.copyFrom(location);
    }
    if (this.isInVRMode) {
      this._workingVector.y += this.webVRCamera.deviceDistanceToRoomGround() * this._webVRCamera.deviceScaleFactor;
    } else {
      this._workingVector.y += this._defaultHeight;
    }
    this.onBeforeCameraTeleport.notifyObservers(this._workingVector);
    const FPS = 90;
    let speedRatio, lastFrame;
    if (this._teleportationMode == VRExperienceHelper.TELEPORTATIONMODE_CONSTANTSPEED) {
      lastFrame = FPS;
      const dist = Vector3.Distance(this.currentVRCamera.position, this._workingVector);
      speedRatio = this._teleportationSpeed / dist;
    } else {
      lastFrame = Math.round(this._teleportationTime * FPS / 1e3);
      speedRatio = 1;
    }
    this.currentVRCamera.animations = [];
    const animationCameraTeleportation = new Animation("animationCameraTeleportation", "position", FPS, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
    const animationCameraTeleportationKeys = [
      {
        frame: 0,
        value: this.currentVRCamera.position
      },
      {
        frame: lastFrame,
        value: this._workingVector
      }
    ];
    animationCameraTeleportation.setKeys(animationCameraTeleportationKeys);
    animationCameraTeleportation.setEasingFunction(this._teleportationEasing);
    this.currentVRCamera.animations.push(animationCameraTeleportation);
    this._postProcessMove.animations = [];
    const midFrame = Math.round(lastFrame / 2);
    const animationPP = new Animation("animationPP", "vignetteWeight", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
    const vignetteWeightKeys = [];
    vignetteWeightKeys.push({
      frame: 0,
      value: 0
    });
    vignetteWeightKeys.push({
      frame: midFrame,
      value: 8
    });
    vignetteWeightKeys.push({
      frame: lastFrame,
      value: 0
    });
    animationPP.setKeys(vignetteWeightKeys);
    this._postProcessMove.animations.push(animationPP);
    const animationPP2 = new Animation("animationPP2", "vignetteStretch", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
    const vignetteStretchKeys = [];
    vignetteStretchKeys.push({
      frame: 0,
      value: 0
    });
    vignetteStretchKeys.push({
      frame: midFrame,
      value: 10
    });
    vignetteStretchKeys.push({
      frame: lastFrame,
      value: 0
    });
    animationPP2.setKeys(vignetteStretchKeys);
    this._postProcessMove.animations.push(animationPP2);
    this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;
    this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;
    this._webVRCamera.attachPostProcess(this._postProcessMove);
    this._scene.beginAnimation(this._postProcessMove, 0, lastFrame, false, speedRatio, () => {
      this._webVRCamera.detachPostProcess(this._postProcessMove);
    });
    this._scene.beginAnimation(this.currentVRCamera, 0, lastFrame, false, speedRatio, () => {
      this.onAfterCameraTeleport.notifyObservers(this._workingVector);
    });
    this._hideTeleportationTarget();
  }
  _convertNormalToDirectionOfRay(normal, ray) {
    if (normal) {
      const angle = Math.acos(Vector3.Dot(normal, ray.direction));
      if (angle < Math.PI / 2) {
        normal.scaleInPlace(-1);
      }
    }
    return normal;
  }
  _castRayAndSelectObject(gazer) {
    if (!(this.currentVRCamera instanceof FreeCamera)) {
      return;
    }
    const ray = gazer._getForwardRay(this._rayLength);
    const hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);
    if (hit) {
      this._scene.simulatePointerMove(hit, { pointerId: gazer._id });
    }
    gazer._currentHit = hit;
    if (hit && hit.pickedPoint) {
      if (this._displayGaze) {
        let multiplier = 1;
        gazer._gazeTracker.isVisible = true;
        if (gazer._isActionableMesh) {
          multiplier = 3;
        }
        if (this.updateGazeTrackerScale) {
          gazer._gazeTracker.scaling.x = hit.distance * multiplier;
          gazer._gazeTracker.scaling.y = hit.distance * multiplier;
          gazer._gazeTracker.scaling.z = hit.distance * multiplier;
        }
        const pickNormal = this._convertNormalToDirectionOfRay(hit.getNormal(), ray);
        const deltaFighting = 2e-3;
        if (pickNormal) {
          const axis1 = Vector3.Cross(Axis.Y, pickNormal);
          const axis2 = Vector3.Cross(pickNormal, axis1);
          Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, gazer._gazeTracker.rotation);
        }
        gazer._gazeTracker.position.copyFrom(hit.pickedPoint);
        if (gazer._gazeTracker.position.x < 0) {
          gazer._gazeTracker.position.x += deltaFighting;
        } else {
          gazer._gazeTracker.position.x -= deltaFighting;
        }
        if (gazer._gazeTracker.position.y < 0) {
          gazer._gazeTracker.position.y += deltaFighting;
        } else {
          gazer._gazeTracker.position.y -= deltaFighting;
        }
        if (gazer._gazeTracker.position.z < 0) {
          gazer._gazeTracker.position.z += deltaFighting;
        } else {
          gazer._gazeTracker.position.z -= deltaFighting;
        }
      }
      gazer._updatePointerDistance(hit.distance);
    } else {
      gazer._updatePointerDistance();
      gazer._gazeTracker.isVisible = false;
    }
    if (hit && hit.pickedMesh) {
      if (this._teleportationInitialized && this._isTeleportationFloor(hit.pickedMesh) && hit.pickedPoint) {
        if (gazer._currentMeshSelected && !this._isTeleportationFloor(gazer._currentMeshSelected)) {
          this._notifySelectedMeshUnselected(gazer._currentMeshSelected);
        }
        gazer._currentMeshSelected = null;
        if (gazer._teleportationRequestInitiated) {
          this._moveTeleportationSelectorTo(hit, gazer, ray);
        }
        return;
      }
      if (hit.pickedMesh !== gazer._currentMeshSelected) {
        if (this.meshSelectionPredicate(hit.pickedMesh)) {
          this.onNewMeshPicked.notifyObservers(hit);
          gazer._currentMeshSelected = hit.pickedMesh;
          if (hit.pickedMesh.isPickable && hit.pickedMesh.actionManager) {
            this.changeGazeColor(this._pickedGazeColor);
            this.changeLaserColor(this._pickedLaserColor);
            gazer._isActionableMesh = true;
          } else {
            this.changeGazeColor(this._gazeColor);
            this.changeLaserColor(this._laserColor);
            gazer._isActionableMesh = false;
          }
          try {
            this.onNewMeshSelected.notifyObservers(hit.pickedMesh);
            const gazerAsControllerGazer = gazer;
            if (gazerAsControllerGazer.webVRController) {
              this.onMeshSelectedWithController.notifyObservers({ mesh: hit.pickedMesh, controller: gazerAsControllerGazer.webVRController });
            }
          } catch (err) {
            Logger.Warn("Error while raising onNewMeshSelected or onMeshSelectedWithController: " + err);
          }
        } else {
          this._notifySelectedMeshUnselected(gazer._currentMeshSelected);
          gazer._currentMeshSelected = null;
          this.changeGazeColor(this._gazeColor);
          this.changeLaserColor(this._laserColor);
        }
      }
    } else {
      this._notifySelectedMeshUnselected(gazer._currentMeshSelected);
      gazer._currentMeshSelected = null;
      this.changeGazeColor(this._gazeColor);
      this.changeLaserColor(this._laserColor);
    }
  }
  _notifySelectedMeshUnselected(mesh) {
    if (mesh) {
      this.onSelectedMeshUnselected.notifyObservers(mesh);
    }
  }
  setLaserColor(color, pickedColor = this._pickedLaserColor) {
    this._laserColor = color;
    this._pickedLaserColor = pickedColor;
  }
  setLaserLightingState(enabled = true) {
    if (this._leftController) {
      this._leftController._setLaserPointerLightingDisabled(!enabled);
    }
    if (this._rightController) {
      this._rightController._setLaserPointerLightingDisabled(!enabled);
    }
  }
  setGazeColor(color, pickedColor = this._pickedGazeColor) {
    this._gazeColor = color;
    this._pickedGazeColor = pickedColor;
  }
  changeLaserColor(color) {
    if (!this.updateControllerLaserColor) {
      return;
    }
    if (this._leftController) {
      this._leftController._setLaserPointerColor(color);
    }
    if (this._rightController) {
      this._rightController._setLaserPointerColor(color);
    }
  }
  changeGazeColor(color) {
    if (!this.updateGazeTrackerColor) {
      return;
    }
    if (!this._cameraGazer._gazeTracker.material) {
      return;
    }
    this._cameraGazer._gazeTracker.material.emissiveColor = color;
    if (this._leftController) {
      this._leftController._gazeTracker.material.emissiveColor = color;
    }
    if (this._rightController) {
      this._rightController._gazeTracker.material.emissiveColor = color;
    }
  }
  dispose() {
    if (this.isInVRMode) {
      this.exitVR();
    }
    if (this._postProcessMove) {
      this._postProcessMove.dispose();
    }
    if (this._webVRCamera) {
      this._webVRCamera.dispose();
    }
    if (this._vrDeviceOrientationCamera) {
      this._vrDeviceOrientationCamera.dispose();
    }
    if (!this._useCustomVRButton && this._btnVR && this._btnVR.parentNode) {
      document.body.removeChild(this._btnVR);
    }
    if (this._deviceOrientationCamera && this._scene.activeCamera != this._deviceOrientationCamera) {
      this._deviceOrientationCamera.dispose();
    }
    if (this._cameraGazer) {
      this._cameraGazer.dispose();
    }
    if (this._leftController) {
      this._leftController.dispose();
    }
    if (this._rightController) {
      this._rightController.dispose();
    }
    if (this._teleportationTarget) {
      this._teleportationTarget.dispose();
    }
    if (this.xr) {
      this.xr.dispose();
    }
    this._floorMeshesCollection.length = 0;
    document.removeEventListener("keydown", this._onKeyDown);
    window.removeEventListener("vrdisplaypresentchange", this._onVrDisplayPresentChangeBind);
    window.removeEventListener("resize", this._onResize);
    document.removeEventListener("fullscreenchange", this._onFullscreenChange);
    this._scene.getEngine().onVRDisplayChangedObservable.removeCallback(this._onVRDisplayChangedBind);
    this._scene.getEngine().onVRRequestPresentStart.removeCallback(this._onVRRequestPresentStart);
    this._scene.getEngine().onVRRequestPresentComplete.removeCallback(this._onVRRequestPresentComplete);
    this._scene.gamepadManager.onGamepadConnectedObservable.removeCallback(this._onNewGamepadConnected);
    this._scene.gamepadManager.onGamepadDisconnectedObservable.removeCallback(this._onNewGamepadDisconnected);
    this._scene.unregisterBeforeRender(this._beforeRender);
  }
  getClassName() {
    return "VRExperienceHelper";
  }
};
VRExperienceHelper.TELEPORTATIONMODE_CONSTANTTIME = 0;
VRExperienceHelper.TELEPORTATIONMODE_CONSTANTSPEED = 1;

// node_modules/@babylonjs/core/Collisions/collider.js
var intersectBoxAASphere = (boxMin, boxMax, sphereCenter, sphereRadius) => {
  if (boxMin.x > sphereCenter.x + sphereRadius) {
    return false;
  }
  if (sphereCenter.x - sphereRadius > boxMax.x) {
    return false;
  }
  if (boxMin.y > sphereCenter.y + sphereRadius) {
    return false;
  }
  if (sphereCenter.y - sphereRadius > boxMax.y) {
    return false;
  }
  if (boxMin.z > sphereCenter.z + sphereRadius) {
    return false;
  }
  if (sphereCenter.z - sphereRadius > boxMax.z) {
    return false;
  }
  return true;
};
var getLowestRoot = function() {
  const result = { root: 0, found: false };
  return function(a, b, c, maxR) {
    result.root = 0;
    result.found = false;
    const determinant = b * b - 4 * a * c;
    if (determinant < 0) {
      return result;
    }
    const sqrtD = Math.sqrt(determinant);
    let r1 = (-b - sqrtD) / (2 * a);
    let r2 = (-b + sqrtD) / (2 * a);
    if (r1 > r2) {
      const temp = r2;
      r2 = r1;
      r1 = temp;
    }
    if (r1 > 0 && r1 < maxR) {
      result.root = r1;
      result.found = true;
      return result;
    }
    if (r2 > 0 && r2 < maxR) {
      result.root = r2;
      result.found = true;
      return result;
    }
    return result;
  };
}();
var Collider = class {
  constructor() {
    this._collisionPoint = Vector3.Zero();
    this._planeIntersectionPoint = Vector3.Zero();
    this._tempVector = Vector3.Zero();
    this._tempVector2 = Vector3.Zero();
    this._tempVector3 = Vector3.Zero();
    this._tempVector4 = Vector3.Zero();
    this._edge = Vector3.Zero();
    this._baseToVertex = Vector3.Zero();
    this._destinationPoint = Vector3.Zero();
    this._slidePlaneNormal = Vector3.Zero();
    this._displacementVector = Vector3.Zero();
    this._radius = Vector3.One();
    this._retry = 0;
    this._basePointWorld = Vector3.Zero();
    this._velocityWorld = Vector3.Zero();
    this._normalizedVelocity = Vector3.Zero();
    this._collisionMask = -1;
  }
  get collisionMask() {
    return this._collisionMask;
  }
  set collisionMask(mask) {
    this._collisionMask = !isNaN(mask) ? mask : -1;
  }
  get slidePlaneNormal() {
    return this._slidePlaneNormal;
  }
  _initialize(source, dir, e) {
    this._velocity = dir;
    this._velocitySquaredLength = this._velocity.lengthSquared();
    const len = Math.sqrt(this._velocitySquaredLength);
    if (len === 0 || len === 1) {
      this._normalizedVelocity.copyFromFloats(dir._x, dir._y, dir._z);
    } else {
      dir.scaleToRef(1 / len, this._normalizedVelocity);
    }
    this._basePoint = source;
    source.multiplyToRef(this._radius, this._basePointWorld);
    dir.multiplyToRef(this._radius, this._velocityWorld);
    this._velocityWorldLength = this._velocityWorld.length();
    this._epsilon = e;
    this.collisionFound = false;
  }
  _checkPointInTriangle(point, pa, pb, pc, n) {
    pa.subtractToRef(point, this._tempVector);
    pb.subtractToRef(point, this._tempVector2);
    Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);
    let d = Vector3.Dot(this._tempVector4, n);
    if (d < 0) {
      return false;
    }
    pc.subtractToRef(point, this._tempVector3);
    Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);
    d = Vector3.Dot(this._tempVector4, n);
    if (d < 0) {
      return false;
    }
    Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);
    d = Vector3.Dot(this._tempVector4, n);
    return d >= 0;
  }
  _canDoCollision(sphereCenter, sphereRadius, vecMin, vecMax) {
    const distance = Vector3.Distance(this._basePointWorld, sphereCenter);
    const max = Math.max(this._radius.x, this._radius.y, this._radius.z);
    if (distance > this._velocityWorldLength + max + sphereRadius) {
      return false;
    }
    if (!intersectBoxAASphere(vecMin, vecMax, this._basePointWorld, this._velocityWorldLength + max)) {
      return false;
    }
    return true;
  }
  _testTriangle(faceIndex, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh) {
    let t0;
    let embeddedInPlane = false;
    if (!trianglePlaneArray) {
      trianglePlaneArray = [];
    }
    if (!trianglePlaneArray[faceIndex]) {
      trianglePlaneArray[faceIndex] = new Plane(0, 0, 0, 0);
      trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);
    }
    const trianglePlane = trianglePlaneArray[faceIndex];
    if (!hasMaterial && !trianglePlane.isFrontFacingTo(this._normalizedVelocity, 0)) {
      return;
    }
    const signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this._basePoint);
    const normalDotVelocity = Vector3.Dot(trianglePlane.normal, this._velocity);
    if (Collider.DoubleSidedCheck && normalDotVelocity > 1e-4) {
      return;
    }
    if (normalDotVelocity == 0) {
      if (Math.abs(signedDistToTrianglePlane) >= 1) {
        return;
      }
      embeddedInPlane = true;
      t0 = 0;
    } else {
      t0 = (-1 - signedDistToTrianglePlane) / normalDotVelocity;
      let t1 = (1 - signedDistToTrianglePlane) / normalDotVelocity;
      if (t0 > t1) {
        const temp = t1;
        t1 = t0;
        t0 = temp;
      }
      if (t0 > 1 || t1 < 0) {
        return;
      }
      if (t0 < 0) {
        t0 = 0;
      }
      if (t0 > 1) {
        t0 = 1;
      }
    }
    this._collisionPoint.copyFromFloats(0, 0, 0);
    let found = false;
    let t = 1;
    if (!embeddedInPlane) {
      this._basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);
      this._velocity.scaleToRef(t0, this._tempVector);
      this._planeIntersectionPoint.addInPlace(this._tempVector);
      if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {
        found = true;
        t = t0;
        this._collisionPoint.copyFrom(this._planeIntersectionPoint);
      }
    }
    if (!found) {
      let a = this._velocitySquaredLength;
      this._basePoint.subtractToRef(p1, this._tempVector);
      let b = 2 * Vector3.Dot(this._velocity, this._tempVector);
      let c = this._tempVector.lengthSquared() - 1;
      let lowestRoot = getLowestRoot(a, b, c, t);
      if (lowestRoot.found) {
        t = lowestRoot.root;
        found = true;
        this._collisionPoint.copyFrom(p1);
      }
      this._basePoint.subtractToRef(p2, this._tempVector);
      b = 2 * Vector3.Dot(this._velocity, this._tempVector);
      c = this._tempVector.lengthSquared() - 1;
      lowestRoot = getLowestRoot(a, b, c, t);
      if (lowestRoot.found) {
        t = lowestRoot.root;
        found = true;
        this._collisionPoint.copyFrom(p2);
      }
      this._basePoint.subtractToRef(p3, this._tempVector);
      b = 2 * Vector3.Dot(this._velocity, this._tempVector);
      c = this._tempVector.lengthSquared() - 1;
      lowestRoot = getLowestRoot(a, b, c, t);
      if (lowestRoot.found) {
        t = lowestRoot.root;
        found = true;
        this._collisionPoint.copyFrom(p3);
      }
      p2.subtractToRef(p1, this._edge);
      p1.subtractToRef(this._basePoint, this._baseToVertex);
      let edgeSquaredLength = this._edge.lengthSquared();
      let edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);
      let edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);
      a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;
      b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);
      c = edgeSquaredLength * (1 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;
      lowestRoot = getLowestRoot(a, b, c, t);
      if (lowestRoot.found) {
        const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;
        if (f >= 0 && f <= 1) {
          t = lowestRoot.root;
          found = true;
          this._edge.scaleInPlace(f);
          p1.addToRef(this._edge, this._collisionPoint);
        }
      }
      p3.subtractToRef(p2, this._edge);
      p2.subtractToRef(this._basePoint, this._baseToVertex);
      edgeSquaredLength = this._edge.lengthSquared();
      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);
      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);
      a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;
      b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);
      c = edgeSquaredLength * (1 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;
      lowestRoot = getLowestRoot(a, b, c, t);
      if (lowestRoot.found) {
        const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;
        if (f >= 0 && f <= 1) {
          t = lowestRoot.root;
          found = true;
          this._edge.scaleInPlace(f);
          p2.addToRef(this._edge, this._collisionPoint);
        }
      }
      p1.subtractToRef(p3, this._edge);
      p3.subtractToRef(this._basePoint, this._baseToVertex);
      edgeSquaredLength = this._edge.lengthSquared();
      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);
      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);
      a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;
      b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);
      c = edgeSquaredLength * (1 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;
      lowestRoot = getLowestRoot(a, b, c, t);
      if (lowestRoot.found) {
        const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;
        if (f >= 0 && f <= 1) {
          t = lowestRoot.root;
          found = true;
          this._edge.scaleInPlace(f);
          p3.addToRef(this._edge, this._collisionPoint);
        }
      }
    }
    if (found) {
      const distToCollisionSquared = t * t * this._velocitySquaredLength;
      if (!this.collisionFound || distToCollisionSquared < this._nearestDistanceSquared) {
        if (hostMesh.collisionResponse) {
          if (!this.intersectionPoint) {
            this.intersectionPoint = this._collisionPoint.clone();
          } else {
            this.intersectionPoint.copyFrom(this._collisionPoint);
          }
          this._nearestDistanceSquared = distToCollisionSquared;
          this._nearestDistance = Math.sqrt(distToCollisionSquared);
          this.collisionFound = true;
        }
        this.collidedMesh = hostMesh;
      }
    }
  }
  _collide(trianglePlaneArray, pts, indices, indexStart, indexEnd, decal, hasMaterial, hostMesh, invertTriangles, triangleStrip = false) {
    if (triangleStrip) {
      if (!indices || indices.length === 0) {
        for (let i = 0; i < pts.length - 2; i += 1) {
          const p1 = pts[i];
          const p2 = pts[i + 1];
          const p3 = pts[i + 2];
          if (!p1 || !p2 || !p3) {
            continue;
          }
          if ((invertTriangles ? 1 : 0) ^ i % 2) {
            this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);
          } else {
            this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);
          }
        }
      } else {
        for (let i = indexStart; i < indexEnd - 2; i += 1) {
          const indexA = indices[i];
          const indexB = indices[i + 1];
          const indexC = indices[i + 2];
          if (indexC === 4294967295) {
            i += 2;
            continue;
          }
          const p1 = pts[indexA];
          const p2 = pts[indexB];
          const p3 = pts[indexC];
          if (!p1 || !p2 || !p3) {
            continue;
          }
          if ((invertTriangles ? 1 : 0) ^ i % 2) {
            this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);
          } else {
            this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);
          }
        }
      }
    } else if (!indices || indices.length === 0) {
      for (let i = 0; i < pts.length; i += 3) {
        const p1 = pts[i];
        const p2 = pts[i + 1];
        const p3 = pts[i + 2];
        if (invertTriangles) {
          this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);
        } else {
          this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);
        }
      }
    } else {
      for (let i = indexStart; i < indexEnd; i += 3) {
        const p1 = pts[indices[i] - decal];
        const p2 = pts[indices[i + 1] - decal];
        const p3 = pts[indices[i + 2] - decal];
        if (invertTriangles) {
          this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);
        } else {
          this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);
        }
      }
    }
  }
  _getResponse(pos, vel) {
    pos.addToRef(vel, this._destinationPoint);
    vel.scaleInPlace(this._nearestDistance / vel.length());
    this._basePoint.addToRef(vel, pos);
    pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);
    this._slidePlaneNormal.normalize();
    this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector);
    pos.addInPlace(this._displacementVector);
    this.intersectionPoint.addInPlace(this._displacementVector);
    this._slidePlaneNormal.scaleInPlace(Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));
    this._destinationPoint.subtractInPlace(this._slidePlaneNormal);
    this._destinationPoint.subtractToRef(this.intersectionPoint, vel);
  }
};
Collider.DoubleSidedCheck = false;

// node_modules/@babylonjs/core/Collisions/collisionCoordinator.js
var DefaultCollisionCoordinator = class {
  constructor() {
    this._scaledPosition = Vector3.Zero();
    this._scaledVelocity = Vector3.Zero();
    this._finalPosition = Vector3.Zero();
  }
  getNewPosition(position, displacement, collider, maximumRetry, excludedMesh, onNewPosition, collisionIndex) {
    position.divideToRef(collider._radius, this._scaledPosition);
    displacement.divideToRef(collider._radius, this._scaledVelocity);
    collider.collidedMesh = null;
    collider._retry = 0;
    collider._initialVelocity = this._scaledVelocity;
    collider._initialPosition = this._scaledPosition;
    this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);
    this._finalPosition.multiplyInPlace(collider._radius);
    onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);
  }
  createCollider() {
    return new Collider();
  }
  init(scene) {
    this._scene = scene;
  }
  _collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh = null) {
    const closeDistance = Engine.CollisionsEpsilon * 10;
    if (collider._retry >= maximumRetry) {
      finalPosition.copyFrom(position);
      return;
    }
    const collisionMask = excludedMesh ? excludedMesh.collisionMask : collider.collisionMask;
    collider._initialize(position, velocity, closeDistance);
    const meshes = excludedMesh && excludedMesh.surroundingMeshes || this._scene.meshes;
    for (let index = 0; index < meshes.length; index++) {
      const mesh = meshes[index];
      if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && (collisionMask & mesh.collisionGroup) !== 0) {
        mesh._checkCollision(collider);
      }
    }
    if (!collider.collisionFound) {
      position.addToRef(velocity, finalPosition);
      return;
    }
    if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {
      collider._getResponse(position, velocity);
    }
    if (velocity.length() <= closeDistance) {
      finalPosition.copyFrom(position);
      return;
    }
    collider._retry++;
    this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);
  }
};
Scene.CollisionCoordinatorFactory = () => {
  return new DefaultCollisionCoordinator();
};

// node_modules/@babylonjs/core/Compute/computeEffect.js
var ComputeEffect = class {
  constructor(baseName, options, engine, key = "") {
    var _a, _b;
    this.name = null;
    this.defines = "";
    this.onCompiled = null;
    this.onError = null;
    this.uniqueId = 0;
    this.onCompileObservable = new Observable();
    this.onErrorObservable = new Observable();
    this.onBindObservable = new Observable();
    this._wasPreviouslyReady = false;
    this._isReady = false;
    this._compilationError = "";
    this._key = "";
    this._computeSourceCodeOverride = "";
    this._pipelineContext = null;
    this._computeSourceCode = "";
    this._rawComputeSourceCode = "";
    this._shaderLanguage = ShaderLanguage.WGSL;
    this.name = baseName;
    this._key = key;
    this._engine = engine;
    this.uniqueId = ComputeEffect._UniqueIdSeed++;
    this.defines = (_a = options.defines) !== null && _a !== void 0 ? _a : "";
    this.onError = options.onError;
    this.onCompiled = options.onCompiled;
    this._entryPoint = (_b = options.entryPoint) !== null && _b !== void 0 ? _b : "main";
    this._shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);
    this._shaderRepository = ShaderStore.GetShadersRepository(this._shaderLanguage);
    this._includeShaderStore = ShaderStore.GetIncludesShadersStore(this._shaderLanguage);
    let computeSource;
    const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;
    if (baseName.computeSource) {
      computeSource = "source:" + baseName.computeSource;
    } else if (baseName.computeElement) {
      computeSource = hostDocument ? hostDocument.getElementById(baseName.computeElement) : null;
      if (!computeSource) {
        computeSource = baseName.computeElement;
      }
    } else {
      computeSource = baseName.compute || baseName;
    }
    const processorOptions = {
      defines: this.defines.split("\n"),
      indexParameters: void 0,
      isFragment: false,
      shouldUseHighPrecisionShader: false,
      processor: null,
      supportsUniformBuffers: this._engine.supportsUniformBuffers,
      shadersRepository: this._shaderRepository,
      includesShadersStore: this._includeShaderStore,
      version: (this._engine.version * 100).toString(),
      platformName: this._engine.shaderPlatformName,
      processingContext: null,
      isNDCHalfZRange: this._engine.isNDCHalfZRange,
      useReverseDepthBuffer: this._engine.useReverseDepthBuffer
    };
    this._loadShader(computeSource, "Compute", "", (computeCode) => {
      ShaderProcessor.Initialize(processorOptions);
      ShaderProcessor.PreProcess(computeCode, processorOptions, (migratedCommputeCode) => {
        this._rawComputeSourceCode = computeCode;
        if (options.processFinalCode) {
          migratedCommputeCode = options.processFinalCode(migratedCommputeCode);
        }
        const finalShaders = ShaderProcessor.Finalize(migratedCommputeCode, "", processorOptions);
        this._useFinalCode(finalShaders.vertexCode, baseName);
      }, this._engine);
    });
  }
  _useFinalCode(migratedCommputeCode, baseName) {
    if (baseName) {
      const compute = baseName.computeElement || baseName.compute || baseName.spectorName || baseName;
      this._computeSourceCode = "//#define SHADER_NAME compute:" + compute + "\n" + migratedCommputeCode;
    } else {
      this._computeSourceCode = migratedCommputeCode;
    }
    this._prepareEffect();
  }
  get key() {
    return this._key;
  }
  isReady() {
    try {
      return this._isReadyInternal();
    } catch (_a) {
      return false;
    }
  }
  _isReadyInternal() {
    if (this._isReady) {
      return true;
    }
    if (this._pipelineContext) {
      return this._pipelineContext.isReady;
    }
    return false;
  }
  getEngine() {
    return this._engine;
  }
  getPipelineContext() {
    return this._pipelineContext;
  }
  getCompilationError() {
    return this._compilationError;
  }
  executeWhenCompiled(func) {
    if (this.isReady()) {
      func(this);
      return;
    }
    this.onCompileObservable.add((effect) => {
      func(effect);
    });
    if (!this._pipelineContext || this._pipelineContext.isAsync) {
      setTimeout(() => {
        this._checkIsReady(null);
      }, 16);
    }
  }
  _checkIsReady(previousPipelineContext) {
    try {
      if (this._isReadyInternal()) {
        return;
      }
    } catch (e) {
      this._processCompilationErrors(e, previousPipelineContext);
      return;
    }
    setTimeout(() => {
      this._checkIsReady(previousPipelineContext);
    }, 16);
  }
  _loadShader(shader137, key, optionalKey, callback) {
    if (typeof HTMLElement !== "undefined") {
      if (shader137 instanceof HTMLElement) {
        const shaderCode = GetDOMTextContent(shader137);
        callback(shaderCode);
        return;
      }
    }
    if (shader137.substr(0, 7) === "source:") {
      callback(shader137.substr(7));
      return;
    }
    if (shader137.substr(0, 7) === "base64:") {
      const shaderBinary = window.atob(shader137.substr(7));
      callback(shaderBinary);
      return;
    }
    if (this._shaderStore[shader137 + key + "Shader"]) {
      callback(this._shaderStore[shader137 + key + "Shader"]);
      return;
    }
    if (optionalKey && this._shaderStore[shader137 + optionalKey + "Shader"]) {
      callback(this._shaderStore[shader137 + optionalKey + "Shader"]);
      return;
    }
    let shaderUrl;
    if (shader137[0] === "." || shader137[0] === "/" || shader137.indexOf("http") > -1) {
      shaderUrl = shader137;
    } else {
      shaderUrl = this._shaderRepository + shader137;
    }
    this._engine._loadFile(shaderUrl + "." + key.toLowerCase() + ".fx", callback);
  }
  get computeSourceCode() {
    var _a, _b;
    return this._computeSourceCodeOverride ? this._computeSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getComputeShaderCode()) !== null && _b !== void 0 ? _b : this._computeSourceCode;
  }
  get rawComputeSourceCode() {
    return this._rawComputeSourceCode;
  }
  _prepareEffect() {
    const defines = this.defines;
    const previousPipelineContext = this._pipelineContext;
    this._isReady = false;
    try {
      const engine = this._engine;
      this._pipelineContext = engine.createComputePipelineContext();
      this._pipelineContext._name = this._key;
      engine._prepareComputePipelineContext(this._pipelineContext, this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._computeSourceCode, this._rawComputeSourceCode, this._computeSourceCodeOverride ? null : defines, this._entryPoint);
      engine._executeWhenComputeStateIsCompiled(this._pipelineContext, () => {
        this._compilationError = "";
        this._isReady = true;
        if (this.onCompiled) {
          this.onCompiled(this);
        }
        this.onCompileObservable.notifyObservers(this);
        this.onCompileObservable.clear();
        if (previousPipelineContext) {
          this.getEngine()._deleteComputePipelineContext(previousPipelineContext);
        }
      });
      if (this._pipelineContext.isAsync) {
        this._checkIsReady(previousPipelineContext);
      }
    } catch (e) {
      this._processCompilationErrors(e, previousPipelineContext);
    }
  }
  _getShaderCodeAndErrorLine(code, error) {
    const regexp = /COMPUTE SHADER ERROR: 0:(\d+?):/;
    let errorLine = null;
    if (error && code) {
      const res = error.match(regexp);
      if (res && res.length === 2) {
        const lineNumber = parseInt(res[1]);
        const lines = code.split("\n", -1);
        if (lines.length >= lineNumber) {
          errorLine = `Offending line [${lineNumber}] in compute code: ${lines[lineNumber - 1]}`;
        }
      }
    }
    return [code, errorLine];
  }
  _processCompilationErrors(e, previousPipelineContext = null) {
    var _a;
    this._compilationError = e.message;
    Logger.Error("Unable to compile compute effect:");
    Logger.Error("Defines:\r\n" + this.defines);
    if (ComputeEffect.LogShaderCodeOnCompilationError) {
      let lineErrorVertex = null, code = null;
      if ((_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getComputeShaderCode()) {
        [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getComputeShaderCode(), this._compilationError);
        if (code) {
          Logger.Error("Compute code:");
          Logger.Error(code);
        }
      }
      if (lineErrorVertex) {
        Logger.Error(lineErrorVertex);
      }
    }
    Logger.Error("Error: " + this._compilationError);
    if (previousPipelineContext) {
      this._pipelineContext = previousPipelineContext;
      this._isReady = true;
      if (this.onError) {
        this.onError(this, this._compilationError);
      }
      this.onErrorObservable.notifyObservers(this);
    }
  }
  dispose() {
    if (this._pipelineContext) {
      this._pipelineContext.dispose();
    }
    this._engine._releaseComputeEffect(this);
  }
  static RegisterShader(name137, computeShader) {
    ShaderStore.GetShadersStore(ShaderLanguage.WGSL)[`${name137}ComputeShader`] = computeShader;
  }
};
ComputeEffect._UniqueIdSeed = 0;
ComputeEffect.LogShaderCodeOnCompilationError = true;

// node_modules/@babylonjs/core/Engines/Extensions/engine.computeShader.js
var ComputeBindingType;
(function(ComputeBindingType2) {
  ComputeBindingType2[ComputeBindingType2["Texture"] = 0] = "Texture";
  ComputeBindingType2[ComputeBindingType2["StorageTexture"] = 1] = "StorageTexture";
  ComputeBindingType2[ComputeBindingType2["UniformBuffer"] = 2] = "UniformBuffer";
  ComputeBindingType2[ComputeBindingType2["StorageBuffer"] = 3] = "StorageBuffer";
  ComputeBindingType2[ComputeBindingType2["TextureWithoutSampler"] = 4] = "TextureWithoutSampler";
  ComputeBindingType2[ComputeBindingType2["Sampler"] = 5] = "Sampler";
})(ComputeBindingType || (ComputeBindingType = {}));
ThinEngine.prototype.createComputeEffect = function(baseName, options) {
  throw new Error("createComputeEffect: This engine does not support compute shaders!");
};
ThinEngine.prototype.createComputePipelineContext = function() {
  throw new Error("createComputePipelineContext: This engine does not support compute shaders!");
};
ThinEngine.prototype.createComputeContext = function() {
  return void 0;
};
ThinEngine.prototype.computeDispatch = function(effect, context, bindings, x, y, z, bindingsMapping) {
  throw new Error("computeDispatch: This engine does not support compute shaders!");
};
ThinEngine.prototype.areAllComputeEffectsReady = function() {
  return true;
};
ThinEngine.prototype.releaseComputeEffects = function() {
};
ThinEngine.prototype._prepareComputePipelineContext = function(pipelineContext, computeSourceCode, rawComputeSourceCode, defines, entryPoint) {
};
ThinEngine.prototype._rebuildComputeEffects = function() {
};
ThinEngine.prototype._executeWhenComputeStateIsCompiled = function(pipelineContext, action) {
  action();
};
ThinEngine.prototype._releaseComputeEffect = function(effect) {
};
ThinEngine.prototype._deleteComputePipelineContext = function(pipelineContext) {
};

// node_modules/@babylonjs/core/Compute/computeShader.js
var ComputeShader = class {
  constructor(name137, engine, shaderPath, options = {}) {
    this._bindings = {};
    this._samplers = {};
    this._contextIsDirty = false;
    this.onCompiled = null;
    this.onError = null;
    this.name = name137;
    this._engine = engine;
    this.uniqueId = UniqueIdGenerator.UniqueId;
    if (!this._engine.getCaps().supportComputeShaders) {
      Logger.Error("This engine does not support compute shaders!");
      return;
    }
    if (!options.bindingsMapping) {
      Logger.Error("You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!");
      return;
    }
    this._context = engine.createComputeContext();
    this._shaderPath = shaderPath;
    this._options = {
      bindingsMapping: {},
      defines: [],
      ...options
    };
  }
  get options() {
    return this._options;
  }
  get shaderPath() {
    return this._shaderPath;
  }
  getClassName() {
    return "ComputeShader";
  }
  setTexture(name137, texture, bindSampler = true) {
    const current = this._bindings[name137];
    this._bindings[name137] = {
      type: bindSampler ? ComputeBindingType.Texture : ComputeBindingType.TextureWithoutSampler,
      object: texture,
      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries
    };
    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture || current.type !== this._bindings[name137].type);
  }
  setStorageTexture(name137, texture) {
    const current = this._bindings[name137];
    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture);
    this._bindings[name137] = {
      type: ComputeBindingType.StorageTexture,
      object: texture,
      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries
    };
  }
  setUniformBuffer(name137, buffer) {
    const current = this._bindings[name137];
    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== buffer);
    this._bindings[name137] = {
      type: ComputeBindingType.UniformBuffer,
      object: buffer,
      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries
    };
  }
  setStorageBuffer(name137, buffer) {
    const current = this._bindings[name137];
    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== buffer);
    this._bindings[name137] = {
      type: ComputeBindingType.StorageBuffer,
      object: buffer,
      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries
    };
  }
  setTextureSampler(name137, sampler) {
    const current = this._bindings[name137];
    this._contextIsDirty || (this._contextIsDirty = !current || !sampler.compareSampler(current.object));
    this._bindings[name137] = {
      type: ComputeBindingType.Sampler,
      object: sampler,
      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries
    };
  }
  isReady() {
    let effect = this._effect;
    for (const key in this._bindings) {
      const binding = this._bindings[key], type = binding.type, object = binding.object;
      switch (type) {
        case ComputeBindingType.Texture:
        case ComputeBindingType.TextureWithoutSampler:
        case ComputeBindingType.StorageTexture: {
          const texture = object;
          if (!texture.isReady()) {
            return false;
          }
          break;
        }
      }
    }
    const defines = [];
    const shaderName = this._shaderPath;
    if (this._options.defines) {
      for (let index = 0; index < this._options.defines.length; index++) {
        defines.push(this._options.defines[index]);
      }
    }
    const join = defines.join("\n");
    if (this._cachedDefines !== join) {
      this._cachedDefines = join;
      effect = this._engine.createComputeEffect(shaderName, {
        defines: join,
        entryPoint: this._options.entryPoint,
        onCompiled: this.onCompiled,
        onError: this.onError
      });
      this._effect = effect;
    }
    if (!effect.isReady()) {
      return false;
    }
    return true;
  }
  dispatch(x, y, z) {
    var _a;
    if (!this.isReady()) {
      return false;
    }
    for (const key in this._bindings) {
      const binding = this._bindings[key];
      if (!this._options.bindingsMapping[key]) {
        throw new Error("ComputeShader ('" + this.name + "'): No binding mapping has been provided for the property '" + key + "'");
      }
      if (binding.type !== ComputeBindingType.Texture) {
        continue;
      }
      const sampler = this._samplers[key];
      const texture = binding.object;
      if (!sampler || !texture._texture || !sampler.compareSampler(texture._texture)) {
        this._samplers[key] = new TextureSampler().setParameters(texture.wrapU, texture.wrapV, texture.wrapR, texture.anisotropicFilteringLevel, texture._texture.samplingMode, (_a = texture._texture) === null || _a === void 0 ? void 0 : _a._comparisonFunction);
        this._contextIsDirty = true;
      }
    }
    if (this._contextIsDirty) {
      this._contextIsDirty = false;
      this._context.clear();
    }
    this._engine.computeDispatch(this._effect, this._context, this._bindings, x, y, z, this._options.bindingsMapping);
    return true;
  }
  dispatchWhenReady(x, y, z, delay = 10) {
    return new Promise((resolve) => {
      const check = () => {
        if (!this.dispatch(x, y, z)) {
          setTimeout(check, delay);
        } else {
          resolve();
        }
      };
      check();
    });
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.options = this._options;
    serializationObject.shaderPath = this._shaderPath;
    serializationObject.bindings = {};
    serializationObject.textures = {};
    for (const key in this._bindings) {
      const binding = this._bindings[key];
      const object = binding.object;
      switch (binding.type) {
        case ComputeBindingType.Texture:
        case ComputeBindingType.TextureWithoutSampler:
        case ComputeBindingType.StorageTexture: {
          const serializedData = object.serialize();
          if (serializedData) {
            serializationObject.textures[key] = serializedData;
            serializationObject.bindings[key] = {
              type: binding.type
            };
          }
          break;
        }
        case ComputeBindingType.UniformBuffer: {
          break;
        }
      }
    }
    return serializationObject;
  }
  static Parse(source, scene, rootUrl) {
    const compute = SerializationHelper.Parse(() => new ComputeShader(source.name, scene.getEngine(), source.shaderPath, source.options), source, scene, rootUrl);
    for (const key in source.textures) {
      const binding = source.bindings[key];
      const texture = Texture.Parse(source.textures[key], scene, rootUrl);
      if (binding.type === ComputeBindingType.Texture) {
        compute.setTexture(key, texture);
      } else if (binding.type === ComputeBindingType.TextureWithoutSampler) {
        compute.setTexture(key, texture, false);
      } else {
        compute.setStorageTexture(key, texture);
      }
    }
    return compute;
  }
};
__decorate([
  serialize()
], ComputeShader.prototype, "name", void 0);
RegisterClass("BABYLON.ComputeShader", ComputeShader);

// node_modules/@babylonjs/core/Culling/Octrees/octreeBlock.js
var OctreeBlock = class {
  constructor(minPoint, maxPoint, capacity, depth, maxDepth, creationFunc) {
    this.entries = new Array();
    this._boundingVectors = new Array();
    this._capacity = capacity;
    this._depth = depth;
    this._maxDepth = maxDepth;
    this._creationFunc = creationFunc;
    this._minPoint = minPoint;
    this._maxPoint = maxPoint;
    this._boundingVectors.push(minPoint.clone());
    this._boundingVectors.push(maxPoint.clone());
    this._boundingVectors.push(minPoint.clone());
    this._boundingVectors[2].x = maxPoint.x;
    this._boundingVectors.push(minPoint.clone());
    this._boundingVectors[3].y = maxPoint.y;
    this._boundingVectors.push(minPoint.clone());
    this._boundingVectors[4].z = maxPoint.z;
    this._boundingVectors.push(maxPoint.clone());
    this._boundingVectors[5].z = minPoint.z;
    this._boundingVectors.push(maxPoint.clone());
    this._boundingVectors[6].x = minPoint.x;
    this._boundingVectors.push(maxPoint.clone());
    this._boundingVectors[7].y = minPoint.y;
  }
  get capacity() {
    return this._capacity;
  }
  get minPoint() {
    return this._minPoint;
  }
  get maxPoint() {
    return this._maxPoint;
  }
  addEntry(entry) {
    if (this.blocks) {
      for (let index = 0; index < this.blocks.length; index++) {
        const block = this.blocks[index];
        block.addEntry(entry);
      }
      return;
    }
    this._creationFunc(entry, this);
    if (this.entries.length > this.capacity && this._depth < this._maxDepth) {
      this.createInnerBlocks();
    }
  }
  removeEntry(entry) {
    if (this.blocks) {
      for (let index = 0; index < this.blocks.length; index++) {
        const block = this.blocks[index];
        block.removeEntry(entry);
      }
      return;
    }
    const entryIndex = this.entries.indexOf(entry);
    if (entryIndex > -1) {
      this.entries.splice(entryIndex, 1);
    }
  }
  addEntries(entries) {
    for (let index = 0; index < entries.length; index++) {
      const mesh = entries[index];
      this.addEntry(mesh);
    }
  }
  select(frustumPlanes, selection, allowDuplicate) {
    if (BoundingBox.IsInFrustum(this._boundingVectors, frustumPlanes)) {
      if (this.blocks) {
        for (let index = 0; index < this.blocks.length; index++) {
          const block = this.blocks[index];
          block.select(frustumPlanes, selection, allowDuplicate);
        }
        return;
      }
      if (allowDuplicate) {
        selection.concat(this.entries);
      } else {
        selection.concatWithNoDuplicate(this.entries);
      }
    }
  }
  intersects(sphereCenter, sphereRadius, selection, allowDuplicate) {
    if (BoundingBox.IntersectsSphere(this._minPoint, this._maxPoint, sphereCenter, sphereRadius)) {
      if (this.blocks) {
        for (let index = 0; index < this.blocks.length; index++) {
          const block = this.blocks[index];
          block.intersects(sphereCenter, sphereRadius, selection, allowDuplicate);
        }
        return;
      }
      if (allowDuplicate) {
        selection.concat(this.entries);
      } else {
        selection.concatWithNoDuplicate(this.entries);
      }
    }
  }
  intersectsRay(ray, selection) {
    if (ray.intersectsBoxMinMax(this._minPoint, this._maxPoint)) {
      if (this.blocks) {
        for (let index = 0; index < this.blocks.length; index++) {
          const block = this.blocks[index];
          block.intersectsRay(ray, selection);
        }
        return;
      }
      selection.concatWithNoDuplicate(this.entries);
    }
  }
  createInnerBlocks() {
    OctreeBlock._CreateBlocks(this._minPoint, this._maxPoint, this.entries, this._capacity, this._depth, this._maxDepth, this, this._creationFunc);
    this.entries.splice(0);
  }
  static _CreateBlocks(worldMin, worldMax, entries, maxBlockCapacity, currentDepth, maxDepth, target, creationFunc) {
    target.blocks = new Array();
    const blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);
    for (let x = 0; x < 2; x++) {
      for (let y = 0; y < 2; y++) {
        for (let z = 0; z < 2; z++) {
          const localMin = worldMin.add(blockSize.multiplyByFloats(x, y, z));
          const localMax = worldMin.add(blockSize.multiplyByFloats(x + 1, y + 1, z + 1));
          const block = new OctreeBlock(localMin, localMax, maxBlockCapacity, currentDepth + 1, maxDepth, creationFunc);
          block.addEntries(entries);
          target.blocks.push(block);
        }
      }
    }
  }
};

// node_modules/@babylonjs/core/Culling/Octrees/octree.js
var Octree = class {
  constructor(creationFunc, maxBlockCapacity, maxDepth = 2) {
    this.maxDepth = maxDepth;
    this.dynamicContent = new Array();
    this._maxBlockCapacity = maxBlockCapacity || 64;
    this._selectionContent = new SmartArrayNoDuplicate(1024);
    this._creationFunc = creationFunc;
  }
  update(worldMin, worldMax, entries) {
    OctreeBlock._CreateBlocks(worldMin, worldMax, entries, this._maxBlockCapacity, 0, this.maxDepth, this, this._creationFunc);
  }
  addMesh(entry) {
    for (let index = 0; index < this.blocks.length; index++) {
      const block = this.blocks[index];
      block.addEntry(entry);
    }
  }
  removeMesh(entry) {
    for (let index = 0; index < this.blocks.length; index++) {
      const block = this.blocks[index];
      block.removeEntry(entry);
    }
  }
  select(frustumPlanes, allowDuplicate) {
    this._selectionContent.reset();
    for (let index = 0; index < this.blocks.length; index++) {
      const block = this.blocks[index];
      block.select(frustumPlanes, this._selectionContent, allowDuplicate);
    }
    if (allowDuplicate) {
      this._selectionContent.concat(this.dynamicContent);
    } else {
      this._selectionContent.concatWithNoDuplicate(this.dynamicContent);
    }
    return this._selectionContent;
  }
  intersects(sphereCenter, sphereRadius, allowDuplicate) {
    this._selectionContent.reset();
    for (let index = 0; index < this.blocks.length; index++) {
      const block = this.blocks[index];
      block.intersects(sphereCenter, sphereRadius, this._selectionContent, allowDuplicate);
    }
    if (allowDuplicate) {
      this._selectionContent.concat(this.dynamicContent);
    } else {
      this._selectionContent.concatWithNoDuplicate(this.dynamicContent);
    }
    return this._selectionContent;
  }
  intersectsRay(ray) {
    this._selectionContent.reset();
    for (let index = 0; index < this.blocks.length; index++) {
      const block = this.blocks[index];
      block.intersectsRay(ray, this._selectionContent);
    }
    this._selectionContent.concatWithNoDuplicate(this.dynamicContent);
    return this._selectionContent;
  }
};
Octree.CreationFuncForMeshes = (entry, block) => {
  const boundingInfo = entry.getBoundingInfo();
  if (!entry.isBlocked && boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {
    block.entries.push(entry);
  }
};
Octree.CreationFuncForSubMeshes = (entry, block) => {
  const boundingInfo = entry.getBoundingInfo();
  if (boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {
    block.entries.push(entry);
  }
};

// node_modules/@babylonjs/core/Culling/Octrees/octreeSceneComponent.js
Scene.prototype.createOrUpdateSelectionOctree = function(maxCapacity = 64, maxDepth = 2) {
  let component = this._getComponent(SceneComponentConstants.NAME_OCTREE);
  if (!component) {
    component = new OctreeSceneComponent(this);
    this._addComponent(component);
  }
  if (!this._selectionOctree) {
    this._selectionOctree = new Octree(Octree.CreationFuncForMeshes, maxCapacity, maxDepth);
  }
  const worldExtends = this.getWorldExtends();
  this._selectionOctree.update(worldExtends.min, worldExtends.max, this.meshes);
  return this._selectionOctree;
};
Object.defineProperty(Scene.prototype, "selectionOctree", {
  get: function() {
    return this._selectionOctree;
  },
  enumerable: true,
  configurable: true
});
AbstractMesh.prototype.createOrUpdateSubmeshesOctree = function(maxCapacity = 64, maxDepth = 2) {
  const scene = this.getScene();
  let component = scene._getComponent(SceneComponentConstants.NAME_OCTREE);
  if (!component) {
    component = new OctreeSceneComponent(scene);
    scene._addComponent(component);
  }
  if (!this._submeshesOctree) {
    this._submeshesOctree = new Octree(Octree.CreationFuncForSubMeshes, maxCapacity, maxDepth);
  }
  this.computeWorldMatrix(true);
  const boundingInfo = this.getBoundingInfo();
  const bbox = boundingInfo.boundingBox;
  this._submeshesOctree.update(bbox.minimumWorld, bbox.maximumWorld, this.subMeshes);
  return this._submeshesOctree;
};
var OctreeSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_OCTREE;
    this.checksIsEnabled = true;
    this._tempRay = new Ray(Vector3.Zero(), new Vector3(1, 1, 1));
    scene = scene || EngineStore.LastCreatedScene;
    if (!scene) {
      return;
    }
    this.scene = scene;
    this.scene.getActiveMeshCandidates = this.getActiveMeshCandidates.bind(this);
    this.scene.getActiveSubMeshCandidates = this.getActiveSubMeshCandidates.bind(this);
    this.scene.getCollidingSubMeshCandidates = this.getCollidingSubMeshCandidates.bind(this);
    this.scene.getIntersectingSubMeshCandidates = this.getIntersectingSubMeshCandidates.bind(this);
  }
  register() {
    this.scene.onMeshRemovedObservable.add((mesh) => {
      const sceneOctree = this.scene.selectionOctree;
      if (sceneOctree !== void 0 && sceneOctree !== null) {
        const index = sceneOctree.dynamicContent.indexOf(mesh);
        if (index !== -1) {
          sceneOctree.dynamicContent.splice(index, 1);
        }
      }
    });
    this.scene.onMeshImportedObservable.add((mesh) => {
      const sceneOctree = this.scene.selectionOctree;
      if (sceneOctree !== void 0 && sceneOctree !== null) {
        sceneOctree.addMesh(mesh);
      }
    });
  }
  getActiveMeshCandidates() {
    var _a;
    return ((_a = this.scene._selectionOctree) === null || _a === void 0 ? void 0 : _a.select(this.scene.frustumPlanes)) || this.scene._getDefaultMeshCandidates();
  }
  getActiveSubMeshCandidates(mesh) {
    if (mesh._submeshesOctree && mesh.useOctreeForRenderingSelection) {
      const intersections = mesh._submeshesOctree.select(this.scene.frustumPlanes);
      return intersections;
    }
    return this.scene._getDefaultSubMeshCandidates(mesh);
  }
  getIntersectingSubMeshCandidates(mesh, localRay) {
    if (mesh._submeshesOctree && mesh.useOctreeForPicking) {
      Ray.TransformToRef(localRay, mesh.getWorldMatrix(), this._tempRay);
      const intersections = mesh._submeshesOctree.intersectsRay(this._tempRay);
      return intersections;
    }
    return this.scene._getDefaultSubMeshCandidates(mesh);
  }
  getCollidingSubMeshCandidates(mesh, collider) {
    if (mesh._submeshesOctree && mesh.useOctreeForCollisions) {
      const radius = collider._velocityWorldLength + Math.max(collider._radius.x, collider._radius.y, collider._radius.z);
      const intersections = mesh._submeshesOctree.intersects(collider._basePointWorld, radius);
      return intersections;
    }
    return this.scene._getDefaultSubMeshCandidates(mesh);
  }
  rebuild() {
  }
  dispose() {
  }
};

// node_modules/@babylonjs/core/Gizmos/axisDragGizmo.js
var AxisDragGizmo = class extends Gizmo {
  constructor(dragAxis, color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, parent = null, thickness = 1) {
    var _a;
    super(gizmoLayer);
    this._pointerObserver = null;
    this.snapDistance = 0;
    this.onSnapObservable = new Observable();
    this._isEnabled = true;
    this._parent = null;
    this._dragging = false;
    this._parent = parent;
    this._coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    this._coloredMaterial.diffuseColor = color;
    this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));
    this._hoverMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    this._hoverMaterial.diffuseColor = Color3.Yellow();
    this._disableMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    this._disableMaterial.diffuseColor = Color3.Gray();
    this._disableMaterial.alpha = 0.4;
    const arrow = AxisDragGizmo._CreateArrow(gizmoLayer.utilityLayerScene, this._coloredMaterial, thickness);
    const collider = AxisDragGizmo._CreateArrow(gizmoLayer.utilityLayerScene, this._coloredMaterial, thickness + 4, true);
    this._gizmoMesh = new Mesh("", gizmoLayer.utilityLayerScene);
    this._gizmoMesh.addChild(arrow);
    this._gizmoMesh.addChild(collider);
    this._gizmoMesh.lookAt(this._rootMesh.position.add(dragAxis));
    this._gizmoMesh.scaling.scaleInPlace(1 / 3);
    this._gizmoMesh.parent = this._rootMesh;
    let currentSnapDragDistance = 0;
    const tmpSnapEvent = { snapDistance: 0 };
    this.dragBehavior = new PointerDragBehavior({ dragAxis });
    this.dragBehavior.moveAttached = false;
    this.dragBehavior.updateDragPlane = false;
    this._rootMesh.addBehavior(this.dragBehavior);
    this.dragBehavior.onDragObservable.add((event) => {
      if (this.attachedNode) {
        this._handlePivot();
        let matrixChanged = false;
        if (this.snapDistance == 0) {
          this.attachedNode.getWorldMatrix().getTranslationToRef(TmpVectors.Vector3[2]);
          TmpVectors.Vector3[2].addInPlace(event.delta);
          if (this.dragBehavior.validateDrag(TmpVectors.Vector3[2])) {
            if (this.attachedNode.position) {
              this.attachedNode.position.addInPlaceFromFloats(event.delta.x, event.delta.y, event.delta.z);
            }
            this.attachedNode.getWorldMatrix().addTranslationFromFloats(event.delta.x, event.delta.y, event.delta.z);
            this.attachedNode.updateCache();
            matrixChanged = true;
          }
        } else {
          currentSnapDragDistance += event.dragDistance;
          if (Math.abs(currentSnapDragDistance) > this.snapDistance) {
            const dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);
            currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;
            event.delta.normalizeToRef(TmpVectors.Vector3[1]);
            TmpVectors.Vector3[1].scaleInPlace(this.snapDistance * dragSteps);
            this.attachedNode.getWorldMatrix().getTranslationToRef(TmpVectors.Vector3[2]);
            TmpVectors.Vector3[2].addInPlace(TmpVectors.Vector3[1]);
            if (this.dragBehavior.validateDrag(TmpVectors.Vector3[2])) {
              this.attachedNode.getWorldMatrix().addTranslationFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[1].z);
              this.attachedNode.updateCache();
              tmpSnapEvent.snapDistance = this.snapDistance * dragSteps;
              this.onSnapObservable.notifyObservers(tmpSnapEvent);
              matrixChanged = true;
            }
          }
        }
        if (matrixChanged) {
          this._matrixChanged();
        }
      }
    });
    this.dragBehavior.onDragStartObservable.add(() => {
      this._dragging = true;
    });
    this.dragBehavior.onDragEndObservable.add(() => {
      this._dragging = false;
    });
    const light = gizmoLayer._getSharedGizmoLight();
    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));
    const cache = {
      gizmoMeshes: arrow.getChildMeshes(),
      colliderMeshes: collider.getChildMeshes(),
      material: this._coloredMaterial,
      hoverMaterial: this._hoverMaterial,
      disableMaterial: this._disableMaterial,
      active: false,
      dragBehavior: this.dragBehavior
    };
    (_a = this._parent) === null || _a === void 0 ? void 0 : _a.addToAxisCache(collider, cache);
    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
      var _a2;
      if (this._customMeshSet) {
        return;
      }
      this._isHovered = !!(cache.colliderMeshes.indexOf((_a2 = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _a2 === void 0 ? void 0 : _a2.pickedMesh) != -1);
      if (!this._parent) {
        const material = this.dragBehavior.enabled ? this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial : this._disableMaterial;
        this._setGizmoMeshMaterial(cache.gizmoMeshes, material);
      }
    });
    this.dragBehavior.onEnabledObservable.add((newState) => {
      this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? cache.material : cache.disableMaterial);
    });
  }
  get coloredMaterial() {
    return this._coloredMaterial;
  }
  get hoverMaterial() {
    return this._hoverMaterial;
  }
  get disableMaterial() {
    return this._disableMaterial;
  }
  static _CreateArrow(scene, material, thickness = 1, isCollider = false) {
    const arrow = new TransformNode("arrow", scene);
    const cylinder = CreateCylinder("cylinder", { diameterTop: 0, height: 0.075, diameterBottom: 0.0375 * (1 + (thickness - 1) / 4), tessellation: 96 }, scene);
    const line = CreateCylinder("cylinder", { diameterTop: 5e-3 * thickness, height: 0.275, diameterBottom: 5e-3 * thickness, tessellation: 96 }, scene);
    cylinder.parent = arrow;
    cylinder.material = material;
    cylinder.rotation.x = Math.PI / 2;
    cylinder.position.z += 0.3;
    line.parent = arrow;
    line.material = material;
    line.position.z += 0.275 / 2;
    line.rotation.x = Math.PI / 2;
    if (isCollider) {
      line.visibility = 0;
      cylinder.visibility = 0;
    }
    return arrow;
  }
  static _CreateArrowInstance(scene, arrow) {
    const instance = new TransformNode("arrow", scene);
    for (const mesh of arrow.getChildMeshes()) {
      const childInstance = mesh.createInstance(mesh.name);
      childInstance.parent = instance;
    }
    return instance;
  }
  _attachedNodeChanged(value) {
    if (this.dragBehavior) {
      this.dragBehavior.enabled = value ? true : false;
    }
  }
  set isEnabled(value) {
    this._isEnabled = value;
    if (!value) {
      this.attachedMesh = null;
      this.attachedNode = null;
    } else {
      if (this._parent) {
        this.attachedMesh = this._parent.attachedMesh;
        this.attachedNode = this._parent.attachedNode;
      }
    }
  }
  get isEnabled() {
    return this._isEnabled;
  }
  dispose() {
    this.onSnapObservable.clear();
    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
    this.dragBehavior.detach();
    if (this._gizmoMesh) {
      this._gizmoMesh.dispose();
    }
    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach((matl) => {
      if (matl) {
        matl.dispose();
      }
    });
    super.dispose();
  }
};

// node_modules/@babylonjs/core/Debug/axesViewer.js
var AxesViewer = class {
  constructor(scene, scaleLines = 1, renderingGroupId = 2, xAxis, yAxis, zAxis, lineThickness = 1) {
    this._scaleLinesFactor = 4;
    this._instanced = false;
    this.scene = null;
    this.scaleLines = 1;
    scene = scene || EngineStore.LastCreatedScene;
    if (!scene) {
      return;
    }
    this.scaleLines = scaleLines;
    if (!xAxis) {
      const redColoredMaterial = new StandardMaterial("", scene);
      redColoredMaterial.disableLighting = true;
      redColoredMaterial.emissiveColor = Color3.Red().scale(0.5);
      xAxis = AxisDragGizmo._CreateArrow(scene, redColoredMaterial, lineThickness);
    }
    if (!yAxis) {
      const greenColoredMaterial = new StandardMaterial("", scene);
      greenColoredMaterial.disableLighting = true;
      greenColoredMaterial.emissiveColor = Color3.Green().scale(0.5);
      yAxis = AxisDragGizmo._CreateArrow(scene, greenColoredMaterial, lineThickness);
    }
    if (!zAxis) {
      const blueColoredMaterial = new StandardMaterial("", scene);
      blueColoredMaterial.disableLighting = true;
      blueColoredMaterial.emissiveColor = Color3.Blue().scale(0.5);
      zAxis = AxisDragGizmo._CreateArrow(scene, blueColoredMaterial, lineThickness);
    }
    this._xAxis = xAxis;
    this._xAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
    this._yAxis = yAxis;
    this._yAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
    this._zAxis = zAxis;
    this._zAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
    if (renderingGroupId != null) {
      AxesViewer._SetRenderingGroupId(this._xAxis, renderingGroupId);
      AxesViewer._SetRenderingGroupId(this._yAxis, renderingGroupId);
      AxesViewer._SetRenderingGroupId(this._zAxis, renderingGroupId);
    }
    this.scene = scene;
    this.update(new Vector3(), Vector3.Right(), Vector3.Up(), Vector3.Forward());
  }
  get xAxis() {
    return this._xAxis;
  }
  get yAxis() {
    return this._yAxis;
  }
  get zAxis() {
    return this._zAxis;
  }
  update(position, xaxis, yaxis, zaxis) {
    this._xAxis.position.copyFrom(position);
    this._xAxis.setDirection(xaxis);
    this._xAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
    this._yAxis.position.copyFrom(position);
    this._yAxis.setDirection(yaxis);
    this._yAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
    this._zAxis.position.copyFrom(position);
    this._zAxis.setDirection(zaxis);
    this._zAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
  }
  createInstance() {
    const xAxis = AxisDragGizmo._CreateArrowInstance(this.scene, this._xAxis);
    const yAxis = AxisDragGizmo._CreateArrowInstance(this.scene, this._yAxis);
    const zAxis = AxisDragGizmo._CreateArrowInstance(this.scene, this._zAxis);
    const axesViewer = new AxesViewer(this.scene, this.scaleLines, null, xAxis, yAxis, zAxis);
    axesViewer._instanced = true;
    return axesViewer;
  }
  dispose() {
    if (this._xAxis) {
      this._xAxis.dispose(false, !this._instanced);
    }
    if (this._yAxis) {
      this._yAxis.dispose(false, !this._instanced);
    }
    if (this._zAxis) {
      this._zAxis.dispose(false, !this._instanced);
    }
    this.scene = null;
  }
  static _SetRenderingGroupId(node, id) {
    node.getChildMeshes().forEach((mesh) => {
      mesh.renderingGroupId = id;
    });
  }
};

// node_modules/@babylonjs/core/Debug/boneAxesViewer.js
var BoneAxesViewer = class extends AxesViewer {
  constructor(scene, bone, mesh, scaleLines = 1) {
    super(scene, scaleLines);
    this.pos = Vector3.Zero();
    this.xaxis = Vector3.Zero();
    this.yaxis = Vector3.Zero();
    this.zaxis = Vector3.Zero();
    this.mesh = mesh;
    this.bone = bone;
  }
  update() {
    if (!this.mesh || !this.bone) {
      return;
    }
    const bone = this.bone;
    bone.getAbsolutePositionToRef(this.mesh, this.pos);
    bone.getDirectionToRef(Axis.X, this.mesh, this.xaxis);
    bone.getDirectionToRef(Axis.Y, this.mesh, this.yaxis);
    bone.getDirectionToRef(Axis.Z, this.mesh, this.zaxis);
    super.update(this.pos, this.xaxis, this.yaxis, this.zaxis);
  }
  dispose() {
    if (this.mesh) {
      this.mesh = null;
      this.bone = null;
      super.dispose();
    }
  }
};

// node_modules/@babylonjs/core/Debug/debugLayer.js
Object.defineProperty(Scene.prototype, "debugLayer", {
  get: function() {
    if (!this._debugLayer) {
      this._debugLayer = new DebugLayer(this);
    }
    return this._debugLayer;
  },
  enumerable: true,
  configurable: true
});
var DebugLayerTab;
(function(DebugLayerTab2) {
  DebugLayerTab2[DebugLayerTab2["Properties"] = 0] = "Properties";
  DebugLayerTab2[DebugLayerTab2["Debug"] = 1] = "Debug";
  DebugLayerTab2[DebugLayerTab2["Statistics"] = 2] = "Statistics";
  DebugLayerTab2[DebugLayerTab2["Tools"] = 3] = "Tools";
  DebugLayerTab2[DebugLayerTab2["Settings"] = 4] = "Settings";
})(DebugLayerTab || (DebugLayerTab = {}));
var DebugLayer = class {
  constructor(scene) {
    this.BJSINSPECTOR = this._getGlobalInspector();
    this._scene = scene || EngineStore.LastCreatedScene;
    if (!this._scene) {
      return;
    }
    this._scene.onDisposeObservable.add(() => {
      if (this._scene._debugLayer) {
        this._scene._debugLayer.hide();
      }
    });
  }
  get onPropertyChangedObservable() {
    if (this.BJSINSPECTOR && this.BJSINSPECTOR.Inspector) {
      return this.BJSINSPECTOR.Inspector.OnPropertyChangedObservable;
    }
    if (!this._onPropertyChangedObservable) {
      this._onPropertyChangedObservable = new Observable();
    }
    return this._onPropertyChangedObservable;
  }
  get onSelectionChangedObservable() {
    if (this.BJSINSPECTOR && this.BJSINSPECTOR.Inspector) {
      return this.BJSINSPECTOR.Inspector.OnSelectionChangeObservable;
    }
    if (!this._onSelectionChangedObservable) {
      this._onSelectionChangedObservable = new Observable();
    }
    return this._onSelectionChangedObservable;
  }
  _createInspector(config) {
    if (this.isVisible()) {
      return;
    }
    if (this._onPropertyChangedObservable) {
      for (const observer of this._onPropertyChangedObservable.observers) {
        this.BJSINSPECTOR.Inspector.OnPropertyChangedObservable.add(observer);
      }
      this._onPropertyChangedObservable.clear();
      this._onPropertyChangedObservable = void 0;
    }
    if (this._onSelectionChangedObservable) {
      for (const observer of this._onSelectionChangedObservable.observers) {
        this.BJSINSPECTOR.Inspector.OnSelectionChangedObservable.add(observer);
      }
      this._onSelectionChangedObservable.clear();
      this._onSelectionChangedObservable = void 0;
    }
    const userOptions = {
      overlay: false,
      showExplorer: true,
      showInspector: true,
      embedMode: false,
      handleResize: true,
      enablePopup: true,
      ...config
    };
    this.BJSINSPECTOR = this.BJSINSPECTOR || this._getGlobalInspector();
    this.BJSINSPECTOR.Inspector.Show(this._scene, userOptions);
  }
  select(entity, lineContainerTitles) {
    if (this.BJSINSPECTOR) {
      if (lineContainerTitles) {
        if (Object.prototype.toString.call(lineContainerTitles) == "[object String]") {
          this.BJSINSPECTOR.Inspector.MarkLineContainerTitleForHighlighting(lineContainerTitles);
        } else {
          this.BJSINSPECTOR.Inspector.MarkMultipleLineContainerTitlesForHighlighting(lineContainerTitles);
        }
      }
      this.BJSINSPECTOR.Inspector.OnSelectionChangeObservable.notifyObservers(entity);
    }
  }
  _getGlobalInspector() {
    if (typeof INSPECTOR !== "undefined") {
      return INSPECTOR;
    }
    if (typeof BABYLON !== "undefined" && typeof BABYLON.Inspector !== "undefined") {
      return BABYLON;
    }
    return void 0;
  }
  isVisible() {
    return this.BJSINSPECTOR && this.BJSINSPECTOR.Inspector.IsVisible;
  }
  hide() {
    if (this.BJSINSPECTOR) {
      this.BJSINSPECTOR.Inspector.Hide();
    }
  }
  setAsActiveScene() {
    if (this.BJSINSPECTOR) {
      this.BJSINSPECTOR.Inspector._SetNewScene(this._scene);
    }
  }
  show(config) {
    return new Promise((resolve) => {
      if (typeof this.BJSINSPECTOR == "undefined") {
        const inspectorUrl = config && config.inspectorURL ? config.inspectorURL : DebugLayer.InspectorURL;
        Tools.LoadScript(inspectorUrl, () => {
          this._createInspector(config);
          resolve(this);
        });
      } else {
        this._createInspector(config);
        resolve(this);
      }
    });
  }
};
DebugLayer.InspectorURL = `https://unpkg.com/babylonjs-inspector@${Engine.Version}/babylon.inspector.bundle.js`;

// node_modules/@babylonjs/core/Meshes/Builders/sphereBuilder.js
function CreateSphereVertexData(options) {
  const segments = options.segments || 32;
  const diameterX = options.diameterX || options.diameter || 1;
  const diameterY = options.diameterY || options.diameter || 1;
  const diameterZ = options.diameterZ || options.diameter || 1;
  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  const slice = options.slice && options.slice <= 0 ? 1 : options.slice || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const dedupTopBottomIndices = !!options.dedupTopBottomIndices;
  const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);
  const totalZRotationSteps = 2 + segments;
  const totalYRotationSteps = 2 * totalZRotationSteps;
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {
    const normalizedZ = zRotationStep / totalZRotationSteps;
    const angleZ = normalizedZ * Math.PI * slice;
    for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {
      const normalizedY = yRotationStep / totalYRotationSteps;
      const angleY = normalizedY * Math.PI * 2 * arc;
      const rotationZ = Matrix.RotationZ(-angleZ);
      const rotationY = Matrix.RotationY(angleY);
      const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);
      const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);
      const vertex = complete.multiply(radius);
      const normal = complete.divide(radius).normalize();
      positions.push(vertex.x, vertex.y, vertex.z);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - normalizedZ : normalizedZ);
    }
    if (zRotationStep > 0) {
      const verticesCount = positions.length / 3;
      for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {
        if (dedupTopBottomIndices) {
          if (zRotationStep > 1) {
            indices.push(firstIndex);
            indices.push(firstIndex + 1);
            indices.push(firstIndex + totalYRotationSteps + 1);
          }
          if (zRotationStep < totalZRotationSteps || slice < 1) {
            indices.push(firstIndex + totalYRotationSteps + 1);
            indices.push(firstIndex + 1);
            indices.push(firstIndex + totalYRotationSteps + 2);
          }
        } else {
          indices.push(firstIndex);
          indices.push(firstIndex + 1);
          indices.push(firstIndex + totalYRotationSteps + 1);
          indices.push(firstIndex + totalYRotationSteps + 1);
          indices.push(firstIndex + 1);
          indices.push(firstIndex + totalYRotationSteps + 2);
        }
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateSphere(name137, options = {}, scene = null) {
  const sphere = new Mesh(name137, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  sphere._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateSphereVertexData(options);
  vertexData.applyToMesh(sphere, options.updatable);
  return sphere;
}
var SphereBuilder = {
  CreateSphere
};
VertexData.CreateSphere = CreateSphereVertexData;
Mesh.CreateSphere = (name137, segments, diameter, scene, updatable, sideOrientation) => {
  const options = {
    segments,
    diameterX: diameter,
    diameterY: diameter,
    diameterZ: diameter,
    sideOrientation,
    updatable
  };
  return CreateSphere(name137, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/capsuleBuilder.js
function CreateCapsuleVertexData(options = {
  subdivisions: 2,
  tessellation: 16,
  height: 1,
  radius: 0.25,
  capSubdivisions: 6
}) {
  const subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1);
  const tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3);
  const height = Math.max(options.height ? options.height : 1, 0);
  const radius = Math.max(options.radius ? options.radius : 0.25, 0);
  const capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1);
  const radialSegments = tessellation;
  const heightSegments = subdivisions;
  const radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0);
  const radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0);
  const heightMinusCaps = height - (radiusTop + radiusBottom);
  const thetaStart = 0;
  const thetaLength = 2 * Math.PI;
  const capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);
  const capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);
  const alpha = Math.acos((radiusBottom - radiusTop) / height);
  let indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  let index = 0;
  const indexArray = [], halfHeight = heightMinusCaps * 0.5;
  const pi2 = Math.PI * 0.5;
  let x, y;
  const normal = Vector3.Zero();
  const vertex = Vector3.Zero();
  const cosAlpha = Math.cos(alpha);
  const sinAlpha = Math.sin(alpha);
  const coneLength = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha).subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha)).length();
  const vl = radiusTop * alpha + coneLength + radiusBottom * (pi2 - alpha);
  let v = 0;
  for (y = 0; y <= capsTopSegments; y++) {
    const indexRow = [];
    const a = pi2 - alpha * (y / capsTopSegments);
    v += radiusTop * alpha / capsTopSegments;
    const cosA = Math.cos(a);
    const sinA = Math.sin(a);
    const _radius = cosA * radiusTop;
    for (x = 0; x <= radialSegments; x++) {
      const u = x / radialSegments;
      const theta = u * thetaLength + thetaStart;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      vertex.x = _radius * sinTheta;
      vertex.y = halfHeight + sinA * radiusTop;
      vertex.z = _radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);
      indexRow.push(index);
      index++;
    }
    indexArray.push(indexRow);
  }
  const coneHeight = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;
  const slope = sinAlpha * (radiusBottom - radiusTop) / coneHeight;
  for (y = 1; y <= heightSegments; y++) {
    const indexRow = [];
    v += coneLength / heightSegments;
    const _radius = sinAlpha * (y * (radiusBottom - radiusTop) / heightSegments + radiusTop);
    for (x = 0; x <= radialSegments; x++) {
      const u = x / radialSegments;
      const theta = u * thetaLength + thetaStart;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      vertex.x = _radius * sinTheta;
      vertex.y = halfHeight + cosAlpha * radiusTop - y * coneHeight / heightSegments;
      vertex.z = _radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.set(sinTheta, slope, cosTheta).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);
      indexRow.push(index);
      index++;
    }
    indexArray.push(indexRow);
  }
  for (y = 1; y <= capsBottomSegments; y++) {
    const indexRow = [];
    const a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);
    v += radiusBottom * alpha / capsBottomSegments;
    const cosA = Math.cos(a);
    const sinA = Math.sin(a);
    const _radius = cosA * radiusBottom;
    for (x = 0; x <= radialSegments; x++) {
      const u = x / radialSegments;
      const theta = u * thetaLength + thetaStart;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      vertex.x = _radius * sinTheta;
      vertex.y = -halfHeight + sinA * radiusBottom;
      vertex.z = _radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);
      indexRow.push(index);
      index++;
    }
    indexArray.push(indexRow);
  }
  for (x = 0; x < radialSegments; x++) {
    for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {
      const i1 = indexArray[y][x];
      const i2 = indexArray[y + 1][x];
      const i3 = indexArray[y + 1][x + 1];
      const i4 = indexArray[y][x + 1];
      indices.push(i1);
      indices.push(i2);
      indices.push(i4);
      indices.push(i2);
      indices.push(i3);
      indices.push(i4);
    }
  }
  indices = indices.reverse();
  if (options.orientation && !options.orientation.equals(Vector3.Up())) {
    const m = new Matrix();
    options.orientation.clone().scale(Math.PI * 0.5).cross(Vector3.Up()).toQuaternion().toRotationMatrix(m);
    const v2 = Vector3.Zero();
    for (let i = 0; i < vertices.length; i += 3) {
      v2.set(vertices[i], vertices[i + 1], vertices[i + 2]);
      Vector3.TransformCoordinatesToRef(v2.clone(), m, v2);
      vertices[i] = v2.x;
      vertices[i + 1] = v2.y;
      vertices[i + 2] = v2.z;
    }
  }
  const vDat = new VertexData();
  vDat.positions = vertices;
  vDat.normals = normals;
  vDat.uvs = uvs;
  vDat.indices = indices;
  return vDat;
}
function CreateCapsule(name137, options = {
  orientation: Vector3.Up(),
  subdivisions: 2,
  tessellation: 16,
  height: 1,
  radius: 0.25,
  capSubdivisions: 6,
  updatable: false
}, scene = null) {
  const capsule = new Mesh(name137, scene);
  const vertexData = CreateCapsuleVertexData(options);
  vertexData.applyToMesh(capsule, options.updatable);
  return capsule;
}
var CapsuleBuilder = {
  CreateCapsule
};
Mesh.CreateCapsule = (name137, options, scene) => {
  return CreateCapsule(name137, options, scene);
};
VertexData.CreateCapsule = CreateCapsuleVertexData;

// node_modules/@babylonjs/core/Debug/physicsViewer.js
var PhysicsViewer = class {
  constructor(scene) {
    this._impostors = [];
    this._meshes = [];
    this._bodies = [];
    this._bodyMeshes = [];
    this._numMeshes = 0;
    this._numBodies = 0;
    this._debugMeshMeshes = new Array();
    this._scene = scene || EngineStore.LastCreatedScene;
    if (!this._scene) {
      return;
    }
    const physicEngine = this._scene.getPhysicsEngine();
    if (physicEngine) {
      this._physicsEnginePlugin = physicEngine.getPhysicsPlugin();
    }
    this._utilityLayer = new UtilityLayerRenderer(this._scene, false);
    this._utilityLayer.pickUtilitySceneFirst = false;
    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;
  }
  _updateDebugMeshes() {
    const plugin = this._physicsEnginePlugin;
    for (let i = 0; i < this._numMeshes; i++) {
      const impostor = this._impostors[i];
      if (!impostor) {
        continue;
      }
      if (impostor.isDisposed) {
        this.hideImpostor(this._impostors[i--]);
      } else {
        if (impostor.type === PhysicsImpostor.MeshImpostor) {
          continue;
        }
        const mesh = this._meshes[i];
        if (mesh && plugin && plugin.getPluginVersion() === 1) {
          plugin.syncMeshWithImpostor(mesh, impostor);
        }
      }
    }
  }
  showImpostor(impostor, targetMesh) {
    if (!this._scene) {
      return null;
    }
    for (let i = 0; i < this._numMeshes; i++) {
      if (this._impostors[i] == impostor) {
        return null;
      }
    }
    const debugMesh = this._getDebugMesh(impostor, targetMesh);
    if (debugMesh) {
      this._impostors[this._numMeshes] = impostor;
      this._meshes[this._numMeshes] = debugMesh;
      if (this._numMeshes === 0) {
        this._renderFunction = this._updateDebugMeshes.bind(this);
        this._scene.registerBeforeRender(this._renderFunction);
      }
      this._numMeshes++;
    }
    return debugMesh;
  }
  showBody(body) {
    if (!this._scene) {
      return null;
    }
    for (let i = 0; i < this._numBodies; i++) {
      if (this._bodies[i] == body) {
        return null;
      }
    }
    const debugMesh = this._getDebugBodyMesh(body);
    if (debugMesh) {
      this._bodies[this._numBodies] = body;
      this._bodyMeshes[this._numBodies] = debugMesh;
      if (this._numBodies === 0) {
        this._renderFunction = this._updateDebugMeshes.bind(this);
        this._scene.registerBeforeRender(this._renderFunction);
      }
      this._numBodies++;
    }
    return debugMesh;
  }
  hideImpostor(impostor) {
    if (!impostor || !this._scene || !this._utilityLayer) {
      return;
    }
    let removed = false;
    const utilityLayerScene = this._utilityLayer.utilityLayerScene;
    for (let i = 0; i < this._numMeshes; i++) {
      if (this._impostors[i] == impostor) {
        const mesh = this._meshes[i];
        if (!mesh) {
          continue;
        }
        utilityLayerScene.removeMesh(mesh);
        mesh.dispose();
        const index = this._debugMeshMeshes.indexOf(mesh);
        if (index > -1) {
          this._debugMeshMeshes.splice(index, 1);
        }
        this._numMeshes--;
        if (this._numMeshes > 0) {
          this._meshes[i] = this._meshes[this._numMeshes];
          this._impostors[i] = this._impostors[this._numMeshes];
          this._meshes[this._numMeshes] = null;
          this._impostors[this._numMeshes] = null;
        } else {
          this._meshes[0] = null;
          this._impostors[0] = null;
        }
        removed = true;
        break;
      }
    }
    if (removed && this._numMeshes === 0) {
      this._scene.unregisterBeforeRender(this._renderFunction);
    }
  }
  _getDebugMaterial(scene) {
    if (!this._debugMaterial) {
      this._debugMaterial = new StandardMaterial("", scene);
      this._debugMaterial.wireframe = true;
      this._debugMaterial.emissiveColor = Color3.White();
      this._debugMaterial.disableLighting = true;
    }
    return this._debugMaterial;
  }
  _getDebugBoxMesh(scene) {
    if (!this._debugBoxMesh) {
      this._debugBoxMesh = CreateBox("physicsBodyBoxViewMesh", { size: 1 }, scene);
      this._debugBoxMesh.rotationQuaternion = Quaternion.Identity();
      this._debugBoxMesh.material = this._getDebugMaterial(scene);
      this._debugBoxMesh.setEnabled(false);
    }
    return this._debugBoxMesh.createInstance("physicsBodyBoxViewInstance");
  }
  _getDebugSphereMesh(scene) {
    if (!this._debugSphereMesh) {
      this._debugSphereMesh = CreateSphere("physicsBodySphereViewMesh", { diameter: 1 }, scene);
      this._debugSphereMesh.rotationQuaternion = Quaternion.Identity();
      this._debugSphereMesh.material = this._getDebugMaterial(scene);
      this._debugSphereMesh.setEnabled(false);
    }
    return this._debugSphereMesh.createInstance("physicsBodySphereViewInstance");
  }
  _getDebugCapsuleMesh(scene) {
    if (!this._debugCapsuleMesh) {
      this._debugCapsuleMesh = CreateCapsule("physicsBodyCapsuleViewMesh", { height: 1 }, scene);
      this._debugCapsuleMesh.rotationQuaternion = Quaternion.Identity();
      this._debugCapsuleMesh.material = this._getDebugMaterial(scene);
      this._debugCapsuleMesh.setEnabled(false);
    }
    return this._debugCapsuleMesh.createInstance("physicsBodyCapsuleViewInstance");
  }
  _getDebugCylinderMesh(scene) {
    if (!this._debugCylinderMesh) {
      this._debugCylinderMesh = CreateCylinder("physicsBodyCylinderViewMesh", { diameterTop: 1, diameterBottom: 1, height: 1 }, scene);
      this._debugCylinderMesh.rotationQuaternion = Quaternion.Identity();
      this._debugCylinderMesh.material = this._getDebugMaterial(scene);
      this._debugCylinderMesh.setEnabled(false);
    }
    return this._debugCylinderMesh.createInstance("physicsBodyCylinderViewInstance");
  }
  _getDebugMeshMesh(mesh, scene) {
    const wireframeOver = new Mesh(mesh.name, scene, null, mesh);
    wireframeOver.setParent(mesh);
    wireframeOver.position = Vector3.Zero();
    wireframeOver.material = this._getDebugMaterial(scene);
    this._debugMeshMeshes.push(wireframeOver);
    return wireframeOver;
  }
  _getDebugMesh(impostor, targetMesh) {
    if (!this._utilityLayer) {
      return null;
    }
    if (targetMesh && targetMesh.parent && targetMesh.parent.physicsImpostor) {
      return null;
    }
    let mesh = null;
    const utilityLayerScene = this._utilityLayer.utilityLayerScene;
    if (!impostor.physicsBody) {
      Logger.Warn("Unable to get physicsBody of impostor. It might be initialized later by its parent's impostor.");
      return null;
    }
    switch (impostor.type) {
      case PhysicsImpostor.BoxImpostor:
        mesh = this._getDebugBoxMesh(utilityLayerScene);
        impostor.getBoxSizeToRef(mesh.scaling);
        break;
      case PhysicsImpostor.SphereImpostor: {
        mesh = this._getDebugSphereMesh(utilityLayerScene);
        const radius = impostor.getRadius();
        mesh.scaling.x = radius * 2;
        mesh.scaling.y = radius * 2;
        mesh.scaling.z = radius * 2;
        break;
      }
      case PhysicsImpostor.CapsuleImpostor: {
        mesh = this._getDebugCapsuleMesh(utilityLayerScene);
        const bi = impostor.object.getBoundingInfo();
        mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * 2 * impostor.object.scaling.x;
        mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;
        mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * 2 * impostor.object.scaling.z;
        break;
      }
      case PhysicsImpostor.MeshImpostor:
        if (targetMesh) {
          mesh = this._getDebugMeshMesh(targetMesh, utilityLayerScene);
        }
        break;
      case PhysicsImpostor.NoImpostor:
        if (targetMesh) {
          const childMeshes = targetMesh.getChildMeshes().filter((c) => {
            return c.physicsImpostor ? 1 : 0;
          });
          childMeshes.forEach((m) => {
            if (m.physicsImpostor && m.getClassName() === "Mesh") {
              const boundingInfo = m.getBoundingInfo();
              const min = boundingInfo.boundingBox.minimum;
              const max = boundingInfo.boundingBox.maximum;
              switch (m.physicsImpostor.type) {
                case PhysicsImpostor.BoxImpostor:
                  mesh = this._getDebugBoxMesh(utilityLayerScene);
                  mesh.position.copyFrom(min);
                  mesh.position.addInPlace(max);
                  mesh.position.scaleInPlace(0.5);
                  break;
                case PhysicsImpostor.SphereImpostor:
                  mesh = this._getDebugSphereMesh(utilityLayerScene);
                  break;
                case PhysicsImpostor.CylinderImpostor:
                  mesh = this._getDebugCylinderMesh(utilityLayerScene);
                  break;
                default:
                  mesh = null;
                  break;
              }
              if (mesh) {
                mesh.scaling.x = max.x - min.x;
                mesh.scaling.y = max.y - min.y;
                mesh.scaling.z = max.z - min.z;
                mesh.parent = m;
              }
            }
          });
        } else {
          Logger.Warn("No target mesh parameter provided for NoImpostor. Skipping.");
        }
        mesh = null;
        break;
      case PhysicsImpostor.CylinderImpostor: {
        mesh = this._getDebugCylinderMesh(utilityLayerScene);
        const bi = impostor.object.getBoundingInfo();
        mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * impostor.object.scaling.x;
        mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;
        mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * impostor.object.scaling.z;
        break;
      }
    }
    return mesh;
  }
  _getDebugBodyMesh(body) {
    if (!this._utilityLayer) {
      return null;
    }
    const utilityLayerScene = this._utilityLayer.utilityLayerScene;
    const mesh = new Mesh("custom", utilityLayerScene);
    const vertexData = new VertexData();
    const geometry = body.getGeometry();
    vertexData.positions = geometry.positions;
    vertexData.indices = geometry.indices;
    vertexData.applyToMesh(mesh);
    mesh.material = this._getDebugMaterial(utilityLayerScene);
    return mesh;
  }
  dispose() {
    const count = this._numMeshes;
    for (let index = 0; index < count; index++) {
      this.hideImpostor(this._impostors[0]);
    }
    if (this._debugBoxMesh) {
      this._debugBoxMesh.dispose();
    }
    if (this._debugSphereMesh) {
      this._debugSphereMesh.dispose();
    }
    if (this._debugCylinderMesh) {
      this._debugCylinderMesh.dispose();
    }
    if (this._debugMaterial) {
      this._debugMaterial.dispose();
    }
    this._impostors.length = 0;
    this._scene = null;
    this._physicsEnginePlugin = null;
    if (this._utilityLayer) {
      this._utilityLayer.dispose();
      this._utilityLayer = null;
    }
  }
};

// node_modules/@babylonjs/core/Meshes/instancedMesh.js
Mesh._instancedMeshFactory = (name137, mesh) => {
  const instance = new InstancedMesh(name137, mesh);
  if (mesh.instancedBuffers) {
    instance.instancedBuffers = {};
    for (const key in mesh.instancedBuffers) {
      instance.instancedBuffers[key] = mesh.instancedBuffers[key];
    }
  }
  return instance;
};
var InstancedMesh = class extends AbstractMesh {
  constructor(name137, source) {
    super(name137, source.getScene());
    this._indexInSourceMeshInstanceArray = -1;
    this._distanceToCamera = 0;
    source.addInstance(this);
    this._sourceMesh = source;
    this._unIndexed = source._unIndexed;
    this.position.copyFrom(source.position);
    this.rotation.copyFrom(source.rotation);
    this.scaling.copyFrom(source.scaling);
    if (source.rotationQuaternion) {
      this.rotationQuaternion = source.rotationQuaternion.clone();
    }
    this.animations = source.animations.slice();
    for (const range of source.getAnimationRanges()) {
      if (range != null) {
        this.createAnimationRange(range.name, range.from, range.to);
      }
    }
    this.infiniteDistance = source.infiniteDistance;
    this.setPivotMatrix(source.getPivotMatrix());
    this.refreshBoundingInfo(true, true);
    this._syncSubMeshes();
  }
  getClassName() {
    return "InstancedMesh";
  }
  get lightSources() {
    return this._sourceMesh._lightSources;
  }
  _resyncLightSources() {
  }
  _resyncLightSource() {
  }
  _removeLightSource() {
  }
  get receiveShadows() {
    return this._sourceMesh.receiveShadows;
  }
  get material() {
    return this._sourceMesh.material;
  }
  get visibility() {
    return this._sourceMesh.visibility;
  }
  get skeleton() {
    return this._sourceMesh.skeleton;
  }
  get renderingGroupId() {
    return this._sourceMesh.renderingGroupId;
  }
  set renderingGroupId(value) {
    if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {
      return;
    }
    Logger.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene");
  }
  getTotalVertices() {
    return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;
  }
  getTotalIndices() {
    return this._sourceMesh.getTotalIndices();
  }
  get sourceMesh() {
    return this._sourceMesh;
  }
  createInstance(name137) {
    return this._sourceMesh.createInstance(name137);
  }
  isReady(completeCheck = false) {
    return this._sourceMesh.isReady(completeCheck, true);
  }
  getVerticesData(kind, copyWhenShared) {
    return this._sourceMesh.getVerticesData(kind, copyWhenShared);
  }
  setVerticesData(kind, data, updatable, stride) {
    if (this.sourceMesh) {
      this.sourceMesh.setVerticesData(kind, data, updatable, stride);
    }
    return this.sourceMesh;
  }
  updateVerticesData(kind, data, updateExtends, makeItUnique) {
    if (this.sourceMesh) {
      this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);
    }
    return this.sourceMesh;
  }
  setIndices(indices, totalVertices = null) {
    if (this.sourceMesh) {
      this.sourceMesh.setIndices(indices, totalVertices);
    }
    return this.sourceMesh;
  }
  isVerticesDataPresent(kind) {
    return this._sourceMesh.isVerticesDataPresent(kind);
  }
  getIndices() {
    return this._sourceMesh.getIndices();
  }
  get _positions() {
    return this._sourceMesh._positions;
  }
  refreshBoundingInfo(applySkeleton = false, applyMorph = false) {
    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {
      return this;
    }
    const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;
    this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);
    return this;
  }
  _preActivate() {
    if (this._currentLOD) {
      this._currentLOD._preActivate();
    }
    return this;
  }
  _activate(renderId, intermediateRendering) {
    super._activate(renderId, intermediateRendering);
    if (!this._sourceMesh.subMeshes) {
      Logger.Warn("Instances should only be created for meshes with geometry.");
    }
    if (this._currentLOD) {
      const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;
      if (differentSign) {
        this._internalAbstractMeshDataInfo._actAsRegularMesh = true;
        return true;
      }
      this._internalAbstractMeshDataInfo._actAsRegularMesh = false;
      this._currentLOD._registerInstanceForRenderId(this, renderId);
      if (intermediateRendering) {
        if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {
          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;
          return true;
        }
      } else {
        if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {
          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;
          return true;
        }
      }
    }
    return false;
  }
  _postActivate() {
    if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
      this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);
      this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());
    } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
      this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);
    }
  }
  getWorldMatrix() {
    if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {
      if (!this._billboardWorldMatrix) {
        this._billboardWorldMatrix = new Matrix();
      }
      const tempMaster = this._currentLOD._masterMesh;
      this._currentLOD._masterMesh = this;
      TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);
      this._currentLOD.position.set(0, 0, 0);
      this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));
      this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);
      this._currentLOD._masterMesh = tempMaster;
      return this._billboardWorldMatrix;
    }
    return super.getWorldMatrix();
  }
  get isAnInstance() {
    return true;
  }
  getLOD(camera) {
    if (!camera) {
      return this;
    }
    const sourceMeshLODLevels = this.sourceMesh.getLODLevels();
    if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {
      this._currentLOD = this.sourceMesh;
    } else {
      const boundingInfo = this.getBoundingInfo();
      this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);
    }
    return this._currentLOD;
  }
  _preActivateForIntermediateRendering(renderId) {
    return this.sourceMesh._preActivateForIntermediateRendering(renderId);
  }
  _syncSubMeshes() {
    this.releaseSubMeshes();
    if (this._sourceMesh.subMeshes) {
      for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {
        this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);
      }
    }
    return this;
  }
  _generatePointsArray() {
    return this._sourceMesh._generatePointsArray();
  }
  _updateBoundingInfo() {
    if (this.hasBoundingInfo) {
      this.getBoundingInfo().update(this.worldMatrixFromCache);
    } else {
      this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);
    }
    this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
    return this;
  }
  clone(name137, newParent = null, doNotCloneChildren, newSourceMesh) {
    const result = (newSourceMesh || this._sourceMesh).createInstance(name137);
    DeepCopier.DeepCopy(this, result, [
      "name",
      "subMeshes",
      "uniqueId",
      "parent",
      "lightSources",
      "receiveShadows",
      "material",
      "visibility",
      "skeleton",
      "sourceMesh",
      "isAnInstance",
      "facetNb",
      "isFacetDataEnabled",
      "isBlocked",
      "useBones",
      "hasInstances",
      "collider",
      "edgesRenderer",
      "forward",
      "up",
      "right",
      "absolutePosition",
      "absoluteScaling",
      "absoluteRotationQuaternion",
      "isWorldMatrixFrozen",
      "nonUniformScaling",
      "behaviors",
      "worldMatrixFromCache",
      "hasThinInstances",
      "hasBoundingInfo"
    ], []);
    this.refreshBoundingInfo();
    if (newParent) {
      result.parent = newParent;
    }
    if (!doNotCloneChildren) {
      for (let index = 0; index < this.getScene().meshes.length; index++) {
        const mesh = this.getScene().meshes[index];
        if (mesh.parent === this) {
          mesh.clone(mesh.name, result);
        }
      }
    }
    result.computeWorldMatrix(true);
    this.onClonedObservable.notifyObservers(result);
    return result;
  }
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this._sourceMesh.removeInstance(this);
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  _serializeAsParent(serializationObject) {
    super._serializeAsParent(serializationObject);
    serializationObject.parentId = this._sourceMesh.uniqueId;
    serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;
  }
  instantiateHierarchy(newParent = null, options, onNewNodeCreated) {
    const clone = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);
    if (clone) {
      if (onNewNodeCreated) {
        onNewNodeCreated(this, clone);
      }
    }
    for (const child of this.getChildTransformNodes(true)) {
      child.instantiateHierarchy(clone, options, onNewNodeCreated);
    }
    return clone;
  }
};
Mesh.prototype.registerInstancedBuffer = function(kind, stride) {
  var _a, _b;
  (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.dispose();
  if (!this.instancedBuffers) {
    this.instancedBuffers = {};
    for (const instance of this.instances) {
      instance.instancedBuffers = {};
    }
    if (!this._userInstancedBuffersStorage) {
      this._userInstancedBuffersStorage = {
        data: {},
        vertexBuffers: {},
        strides: {},
        sizes: {},
        vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
      };
    }
  }
  this.instancedBuffers[kind] = null;
  this._userInstancedBuffersStorage.strides[kind] = stride;
  this._userInstancedBuffersStorage.sizes[kind] = stride * 32;
  this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);
  this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
  for (const instance of this.instances) {
    instance.instancedBuffers[kind] = null;
  }
  this._invalidateInstanceVertexArrayObject();
  this._markSubMeshesAsAttributesDirty();
};
Mesh.prototype._processInstancedBuffers = function(visibleInstances, renderSelf) {
  const instanceCount = visibleInstances ? visibleInstances.length : 0;
  for (const kind in this.instancedBuffers) {
    let size = this._userInstancedBuffersStorage.sizes[kind];
    const stride = this._userInstancedBuffersStorage.strides[kind];
    const expectedSize = (instanceCount + 1) * stride;
    while (size < expectedSize) {
      size *= 2;
    }
    if (this._userInstancedBuffersStorage.data[kind].length != size) {
      this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);
      this._userInstancedBuffersStorage.sizes[kind] = size;
      if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
        this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
        this._userInstancedBuffersStorage.vertexBuffers[kind] = null;
      }
    }
    const data = this._userInstancedBuffersStorage.data[kind];
    let offset = 0;
    if (renderSelf) {
      const value = this.instancedBuffers[kind];
      if (value.toArray) {
        value.toArray(data, offset);
      } else if (value.copyToArray) {
        value.copyToArray(data, offset);
      } else {
        data[offset] = value;
      }
      offset += stride;
    }
    for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {
      const instance = visibleInstances[instanceIndex];
      const value = instance.instancedBuffers[kind];
      if (value.toArray) {
        value.toArray(data, offset);
      } else if (value.copyToArray) {
        value.copyToArray(data, offset);
      } else {
        data[offset] = value;
      }
      offset += stride;
    }
    if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {
      this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
      this._invalidateInstanceVertexArrayObject();
    } else {
      this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);
    }
  }
};
Mesh.prototype._invalidateInstanceVertexArrayObject = function() {
  if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === void 0) {
    return;
  }
  for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {
    this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);
  }
  this._userInstancedBuffersStorage.vertexArrayObjects = {};
};
Mesh.prototype._disposeInstanceSpecificData = function() {
  if (this._instanceDataStorage.instancesBuffer) {
    this._instanceDataStorage.instancesBuffer.dispose();
    this._instanceDataStorage.instancesBuffer = null;
  }
  while (this.instances.length) {
    this.instances[0].dispose();
  }
  for (const kind in this.instancedBuffers) {
    if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
      this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
    }
  }
  this._invalidateInstanceVertexArrayObject();
  this.instancedBuffers = {};
};

// node_modules/@babylonjs/core/Shaders/color.fragment.js
var name6 = "colorPixelShader";
var shader6 = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
#define VERTEXCOLOR
varying vec4 vColor;
#else
uniform vec4 color;
#endif
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
gl_FragColor=vColor;
#else
gl_FragColor=color;
#endif
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name6] = shader6;

// node_modules/@babylonjs/core/Shaders/color.vertex.js
var name7 = "colorVertexShader";
var shader7 = `attribute vec3 position;
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {
gl_Position=viewProjection*worldPos;
} else {
gl_Position=viewProjectionR*worldPos;
}
#else
gl_Position=viewProjection*worldPos;
#endif
#include<clipPlaneVertex>
#include<vertexColorMixing>
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name7] = shader7;

// node_modules/@babylonjs/core/Meshes/linesMesh.js
Mesh._LinesMeshParser = (parsedMesh, scene) => {
  return LinesMesh.Parse(parsedMesh, scene);
};
var LinesMesh = class extends Mesh {
  constructor(name137, scene = null, parent = null, source = null, doNotCloneChildren, useVertexColor, useVertexAlpha, material) {
    super(name137, scene, parent, source, doNotCloneChildren);
    this.useVertexColor = useVertexColor;
    this.useVertexAlpha = useVertexAlpha;
    this.color = new Color3(1, 1, 1);
    this.alpha = 1;
    if (source) {
      this.color = source.color.clone();
      this.alpha = source.alpha;
      this.useVertexColor = source.useVertexColor;
      this.useVertexAlpha = source.useVertexAlpha;
    }
    this.intersectionThreshold = 0.1;
    const defines = [];
    const options = {
      attributes: [VertexBuffer.PositionKind],
      uniforms: ["world", "viewProjection"],
      needAlphaBlending: true,
      defines,
      useClipPlane: null
    };
    if (useVertexAlpha === false) {
      options.needAlphaBlending = false;
    } else {
      options.defines.push("#define VERTEXALPHA");
    }
    if (!useVertexColor) {
      options.uniforms.push("color");
      this._color4 = new Color4();
    } else {
      options.defines.push("#define VERTEXCOLOR");
      options.attributes.push(VertexBuffer.ColorKind);
    }
    if (material) {
      this.material = material;
    } else {
      this.material = new ShaderMaterial("colorShader", this.getScene(), "color", options, false);
      this.material.doNotSerialize = true;
    }
  }
  _isShaderMaterial(shader137) {
    return shader137.getClassName() === "ShaderMaterial";
  }
  isReady() {
    if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage)) {
      return false;
    }
    return super.isReady();
  }
  getClassName() {
    return "LinesMesh";
  }
  get material() {
    return this._lineMaterial;
  }
  set material(value) {
    this._lineMaterial = value;
    this._lineMaterial.fillMode = Material.LineListDrawMode;
  }
  get checkCollisions() {
    return false;
  }
  set checkCollisions(value) {
  }
  _bind() {
    if (!this._geometry) {
      return this;
    }
    const colorEffect = this._lineMaterial.getEffect();
    const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();
    if (!this._userInstancedBuffersStorage) {
      this._geometry._bind(colorEffect, indexToBind);
    } else {
      this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);
    }
    if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {
      const { r, g, b } = this.color;
      this._color4.set(r, g, b, this.alpha);
      this._lineMaterial.setColor4("color", this._color4);
    }
    return this;
  }
  _draw(subMesh, fillMode, instancesCount) {
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
      return this;
    }
    const engine = this.getScene().getEngine();
    if (this._unIndexed) {
      engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);
    } else {
      engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);
    }
    return this;
  }
  dispose(doNotRecurse, disposeMaterialAndTextures = false, doNotDisposeMaterial) {
    if (!doNotDisposeMaterial) {
      this._lineMaterial.dispose(false, false, true);
    }
    super.dispose(doNotRecurse);
  }
  clone(name137, newParent = null, doNotCloneChildren) {
    return new LinesMesh(name137, this.getScene(), newParent, this, doNotCloneChildren);
  }
  createInstance(name137) {
    const instance = new InstancedLinesMesh(name137, this);
    if (this.instancedBuffers) {
      instance.instancedBuffers = {};
      for (const key in this.instancedBuffers) {
        instance.instancedBuffers[key] = this.instancedBuffers[key];
      }
    }
    return instance;
  }
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.color = this.color.asArray();
    serializationObject.alpha = this.alpha;
  }
  static Parse(parsedMesh, scene) {
    const result = new LinesMesh(parsedMesh.name, scene);
    result.color = Color3.FromArray(parsedMesh.color);
    result.alpha = parsedMesh.alpha;
    return result;
  }
};
var InstancedLinesMesh = class extends InstancedMesh {
  constructor(name137, source) {
    super(name137, source);
    this.intersectionThreshold = source.intersectionThreshold;
  }
  getClassName() {
    return "InstancedLinesMesh";
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/linesBuilder.js
function CreateLineSystemVertexData(options) {
  const indices = [];
  const positions = [];
  const lines = options.lines;
  const colors = options.colors;
  const vertexColors = [];
  let idx = 0;
  for (let l = 0; l < lines.length; l++) {
    const points = lines[l];
    for (let index = 0; index < points.length; index++) {
      positions.push(points[index].x, points[index].y, points[index].z);
      if (colors) {
        const color = colors[l];
        vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);
      }
      if (index > 0) {
        indices.push(idx - 1);
        indices.push(idx);
      }
      idx++;
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  if (colors) {
    vertexData.colors = vertexColors;
  }
  return vertexData;
}
function CreateDashedLinesVertexData(options) {
  const dashSize = options.dashSize || 3;
  const gapSize = options.gapSize || 1;
  const dashNb = options.dashNb || 200;
  const points = options.points;
  const positions = new Array();
  const indices = new Array();
  const curvect = Vector3.Zero();
  let lg = 0;
  let nb = 0;
  let shft = 0;
  let dashshft = 0;
  let curshft = 0;
  let idx = 0;
  let i = 0;
  for (i = 0; i < points.length - 1; i++) {
    points[i + 1].subtractToRef(points[i], curvect);
    lg += curvect.length();
  }
  shft = lg / dashNb;
  dashshft = dashSize * shft / (dashSize + gapSize);
  for (i = 0; i < points.length - 1; i++) {
    points[i + 1].subtractToRef(points[i], curvect);
    nb = Math.floor(curvect.length() / shft);
    curvect.normalize();
    for (let j = 0; j < nb; j++) {
      curshft = shft * j;
      positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);
      positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);
      indices.push(idx, idx + 1);
      idx += 2;
    }
  }
  const vertexData = new VertexData();
  vertexData.positions = positions;
  vertexData.indices = indices;
  return vertexData;
}
function CreateLineSystem(name137, options, scene) {
  const instance = options.instance;
  const lines = options.lines;
  const colors = options.colors;
  if (instance) {
    const positions = instance.getVerticesData(VertexBuffer.PositionKind);
    let vertexColor;
    let lineColors;
    if (colors) {
      vertexColor = instance.getVerticesData(VertexBuffer.ColorKind);
    }
    let i = 0;
    let c = 0;
    for (let l = 0; l < lines.length; l++) {
      const points = lines[l];
      for (let p = 0; p < points.length; p++) {
        positions[i] = points[p].x;
        positions[i + 1] = points[p].y;
        positions[i + 2] = points[p].z;
        if (colors && vertexColor) {
          lineColors = colors[l];
          vertexColor[c] = lineColors[p].r;
          vertexColor[c + 1] = lineColors[p].g;
          vertexColor[c + 2] = lineColors[p].b;
          vertexColor[c + 3] = lineColors[p].a;
          c += 4;
        }
        i += 3;
      }
    }
    instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
    if (colors && vertexColor) {
      instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);
    }
    return instance;
  }
  const useVertexColor = colors ? true : false;
  const lineSystem = new LinesMesh(name137, scene, null, void 0, void 0, useVertexColor, options.useVertexAlpha, options.material);
  const vertexData = CreateLineSystemVertexData(options);
  vertexData.applyToMesh(lineSystem, options.updatable);
  return lineSystem;
}
function CreateLines(name137, options, scene = null) {
  const colors = options.colors ? [options.colors] : null;
  const lines = CreateLineSystem(name137, { lines: [options.points], updatable: options.updatable, instance: options.instance, colors, useVertexAlpha: options.useVertexAlpha, material: options.material }, scene);
  return lines;
}
function CreateDashedLines(name137, options, scene = null) {
  const points = options.points;
  const instance = options.instance;
  const gapSize = options.gapSize || 1;
  const dashSize = options.dashSize || 3;
  if (instance) {
    const positionFunction = (positions) => {
      const curvect = Vector3.Zero();
      const nbSeg = positions.length / 6;
      let lg = 0;
      let nb = 0;
      let shft = 0;
      let dashshft = 0;
      let curshft = 0;
      let p = 0;
      let i = 0;
      let j = 0;
      for (i = 0; i < points.length - 1; i++) {
        points[i + 1].subtractToRef(points[i], curvect);
        lg += curvect.length();
      }
      shft = lg / nbSeg;
      const dashSize2 = instance._creationDataStorage.dashSize;
      const gapSize2 = instance._creationDataStorage.gapSize;
      dashshft = dashSize2 * shft / (dashSize2 + gapSize2);
      for (i = 0; i < points.length - 1; i++) {
        points[i + 1].subtractToRef(points[i], curvect);
        nb = Math.floor(curvect.length() / shft);
        curvect.normalize();
        j = 0;
        while (j < nb && p < positions.length) {
          curshft = shft * j;
          positions[p] = points[i].x + curshft * curvect.x;
          positions[p + 1] = points[i].y + curshft * curvect.y;
          positions[p + 2] = points[i].z + curshft * curvect.z;
          positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;
          positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;
          positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;
          p += 6;
          j++;
        }
      }
      while (p < positions.length) {
        positions[p] = points[i].x;
        positions[p + 1] = points[i].y;
        positions[p + 2] = points[i].z;
        p += 3;
      }
    };
    if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {
      Logger.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored.");
    }
    instance.updateMeshPositions(positionFunction, false);
    return instance;
  }
  const dashedLines = new LinesMesh(name137, scene, null, void 0, void 0, void 0, options.useVertexAlpha, options.material);
  const vertexData = CreateDashedLinesVertexData(options);
  vertexData.applyToMesh(dashedLines, options.updatable);
  dashedLines._creationDataStorage = new _CreationDataStorage();
  dashedLines._creationDataStorage.dashSize = dashSize;
  dashedLines._creationDataStorage.gapSize = gapSize;
  return dashedLines;
}
var LinesBuilder = {
  CreateDashedLines,
  CreateLineSystem,
  CreateLines
};
VertexData.CreateLineSystem = CreateLineSystemVertexData;
VertexData.CreateDashedLines = CreateDashedLinesVertexData;
Mesh.CreateLines = (name137, points, scene = null, updatable = false, instance = null) => {
  const options = {
    points,
    updatable,
    instance
  };
  return CreateLines(name137, options, scene);
};
Mesh.CreateDashedLines = (name137, points, dashSize, gapSize, dashNb, scene = null, updatable, instance) => {
  const options = {
    points,
    dashSize,
    gapSize,
    dashNb,
    updatable,
    instance
  };
  return CreateDashedLines(name137, options, scene);
};

// node_modules/@babylonjs/core/Debug/rayHelper.js
var RayHelper = class {
  constructor(ray) {
    this.ray = ray;
  }
  static CreateAndShow(ray, scene, color) {
    const helper = new RayHelper(ray);
    helper.show(scene, color);
    return helper;
  }
  show(scene, color) {
    if (!this._renderFunction && this.ray) {
      const ray = this.ray;
      this._renderFunction = this._render.bind(this);
      this._scene = scene;
      this._renderPoints = [ray.origin, ray.origin.add(ray.direction.scale(ray.length))];
      this._renderLine = CreateLines("ray", { points: this._renderPoints, updatable: true }, scene);
      this._renderLine.isPickable = false;
      if (this._renderFunction) {
        this._scene.registerBeforeRender(this._renderFunction);
      }
    }
    if (color && this._renderLine) {
      this._renderLine.color.copyFrom(color);
    }
  }
  hide() {
    if (this._renderFunction && this._scene) {
      this._scene.unregisterBeforeRender(this._renderFunction);
      this._scene = null;
      this._renderFunction = null;
      if (this._renderLine) {
        this._renderLine.dispose();
        this._renderLine = null;
      }
      this._renderPoints = [];
    }
  }
  _render() {
    var _a;
    const ray = this.ray;
    if (!ray) {
      return;
    }
    const point = this._renderPoints[1];
    const len = Math.min(ray.length, 1e6);
    point.copyFrom(ray.direction);
    point.scaleInPlace(len);
    point.addInPlace(ray.origin);
    this._renderPoints[0].copyFrom(ray.origin);
    CreateLines("ray", { points: this._renderPoints, updatable: true, instance: this._renderLine }, this._scene);
    (_a = this._renderLine) === null || _a === void 0 ? void 0 : _a.refreshBoundingInfo();
  }
  attachToMesh(mesh, meshSpaceDirection, meshSpaceOrigin, length) {
    this._attachedToMesh = mesh;
    const ray = this.ray;
    if (!ray) {
      return;
    }
    if (!ray.direction) {
      ray.direction = Vector3.Zero();
    }
    if (!ray.origin) {
      ray.origin = Vector3.Zero();
    }
    if (length) {
      ray.length = length;
    }
    if (!meshSpaceOrigin) {
      meshSpaceOrigin = Vector3.Zero();
    }
    if (!meshSpaceDirection) {
      meshSpaceDirection = new Vector3(0, 0, -1);
    }
    if (!this._scene) {
      this._scene = mesh.getScene();
    }
    if (!this._meshSpaceDirection) {
      this._meshSpaceDirection = meshSpaceDirection.clone();
      this._meshSpaceOrigin = meshSpaceOrigin.clone();
    } else {
      this._meshSpaceDirection.copyFrom(meshSpaceDirection);
      this._meshSpaceOrigin.copyFrom(meshSpaceOrigin);
    }
    if (!this._onAfterRenderObserver) {
      this._onAfterRenderObserver = this._scene.onBeforeRenderObservable.add(() => this._updateToMesh());
      this._onAfterStepObserver = this._scene.onAfterStepObservable.add(() => this._updateToMesh());
    }
    this._attachedToMesh.computeWorldMatrix(true);
    this._updateToMesh();
  }
  detachFromMesh() {
    if (this._attachedToMesh && this._scene) {
      if (this._onAfterRenderObserver) {
        this._scene.onBeforeRenderObservable.remove(this._onAfterRenderObserver);
        this._scene.onAfterStepObservable.remove(this._onAfterStepObserver);
      }
      this._attachedToMesh = null;
      this._onAfterRenderObserver = null;
      this._onAfterStepObserver = null;
      this._scene = null;
    }
  }
  _updateToMesh() {
    const ray = this.ray;
    if (!this._attachedToMesh || !ray) {
      return;
    }
    if (this._attachedToMesh.isDisposed()) {
      this.detachFromMesh();
      return;
    }
    this._attachedToMesh.getDirectionToRef(this._meshSpaceDirection, ray.direction);
    Vector3.TransformCoordinatesToRef(this._meshSpaceOrigin, this._attachedToMesh.getWorldMatrix(), ray.origin);
  }
  dispose() {
    this.hide();
    this.detachFromMesh();
    this.ray = null;
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/ribbonBuilder.js
function CreateRibbonVertexData(options) {
  let pathArray = options.pathArray;
  const closeArray = options.closeArray || false;
  const closePath = options.closePath || false;
  const invertUV = options.invertUV || false;
  const defaultOffset = Math.floor(pathArray[0].length / 2);
  let offset = options.offset || defaultOffset;
  offset = offset > defaultOffset ? defaultOffset : Math.floor(offset);
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const customUV = options.uvs;
  const customColors = options.colors;
  const positions = [];
  const indices = [];
  const normals = [];
  const uvs = [];
  const us = [];
  const vs = [];
  const uTotalDistance = [];
  const vTotalDistance = [];
  let minlg;
  const lg = [];
  const idx = [];
  let p;
  let i;
  let j;
  if (pathArray.length < 2) {
    const ar1 = [];
    const ar2 = [];
    for (i = 0; i < pathArray[0].length - offset; i++) {
      ar1.push(pathArray[0][i]);
      ar2.push(pathArray[0][i + offset]);
    }
    pathArray = [ar1, ar2];
  }
  let idc = 0;
  const closePathCorr = closePath ? 1 : 0;
  let path;
  let l;
  minlg = pathArray[0].length;
  let vectlg;
  let dist;
  for (p = 0; p < pathArray.length; p++) {
    uTotalDistance[p] = 0;
    us[p] = [0];
    path = pathArray[p];
    l = path.length;
    minlg = minlg < l ? minlg : l;
    j = 0;
    while (j < l) {
      positions.push(path[j].x, path[j].y, path[j].z);
      if (j > 0) {
        vectlg = path[j].subtract(path[j - 1]).length();
        dist = vectlg + uTotalDistance[p];
        us[p].push(dist);
        uTotalDistance[p] = dist;
      }
      j++;
    }
    if (closePath) {
      j--;
      positions.push(path[0].x, path[0].y, path[0].z);
      vectlg = path[j].subtract(path[0]).length();
      dist = vectlg + uTotalDistance[p];
      us[p].push(dist);
      uTotalDistance[p] = dist;
    }
    lg[p] = l + closePathCorr;
    idx[p] = idc;
    idc += l + closePathCorr;
  }
  let path1;
  let path2;
  let vertex1 = null;
  let vertex2 = null;
  for (i = 0; i < minlg + closePathCorr; i++) {
    vTotalDistance[i] = 0;
    vs[i] = [0];
    for (p = 0; p < pathArray.length - 1; p++) {
      path1 = pathArray[p];
      path2 = pathArray[p + 1];
      if (i === minlg) {
        vertex1 = path1[0];
        vertex2 = path2[0];
      } else {
        vertex1 = path1[i];
        vertex2 = path2[i];
      }
      vectlg = vertex2.subtract(vertex1).length();
      dist = vectlg + vTotalDistance[i];
      vs[i].push(dist);
      vTotalDistance[i] = dist;
    }
    if (closeArray && vertex2 && vertex1) {
      path1 = pathArray[p];
      path2 = pathArray[0];
      if (i === minlg) {
        vertex2 = path2[0];
      }
      vectlg = vertex2.subtract(vertex1).length();
      dist = vectlg + vTotalDistance[i];
      vTotalDistance[i] = dist;
    }
  }
  let u;
  let v;
  if (customUV) {
    for (p = 0; p < customUV.length; p++) {
      uvs.push(customUV[p].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - customUV[p].y : customUV[p].y);
    }
  } else {
    for (p = 0; p < pathArray.length; p++) {
      for (i = 0; i < minlg + closePathCorr; i++) {
        u = uTotalDistance[p] != 0 ? us[p][i] / uTotalDistance[p] : 0;
        v = vTotalDistance[i] != 0 ? vs[i][p] / vTotalDistance[i] : 0;
        if (invertUV) {
          uvs.push(v, u);
        } else {
          uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
        }
      }
    }
  }
  p = 0;
  let pi = 0;
  let l1 = lg[p] - 1;
  let l2 = lg[p + 1] - 1;
  let min = l1 < l2 ? l1 : l2;
  let shft = idx[1] - idx[0];
  const path1nb = closeArray ? lg.length : lg.length - 1;
  while (pi <= min && p < path1nb) {
    indices.push(pi, pi + shft, pi + 1);
    indices.push(pi + shft + 1, pi + 1, pi + shft);
    pi += 1;
    if (pi === min) {
      p++;
      if (p === lg.length - 1) {
        shft = idx[0] - idx[p];
        l1 = lg[p] - 1;
        l2 = lg[0] - 1;
      } else {
        shft = idx[p + 1] - idx[p];
        l1 = lg[p] - 1;
        l2 = lg[p + 1] - 1;
      }
      pi = idx[p];
      min = l1 < l2 ? l1 + pi : l2 + pi;
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  if (closePath) {
    let indexFirst = 0;
    let indexLast = 0;
    for (p = 0; p < pathArray.length; p++) {
      indexFirst = idx[p] * 3;
      if (p + 1 < pathArray.length) {
        indexLast = (idx[p + 1] - 1) * 3;
      } else {
        indexLast = normals.length - 3;
      }
      normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;
      normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;
      normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;
      normals[indexLast] = normals[indexFirst];
      normals[indexLast + 1] = normals[indexFirst + 1];
      normals[indexLast + 2] = normals[indexFirst + 2];
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  let colors = null;
  if (customColors) {
    colors = new Float32Array(customColors.length * 4);
    for (let c = 0; c < customColors.length; c++) {
      colors[c * 4] = customColors[c].r;
      colors[c * 4 + 1] = customColors[c].g;
      colors[c * 4 + 2] = customColors[c].b;
      colors[c * 4 + 3] = customColors[c].a;
    }
  }
  const vertexData = new VertexData();
  const positions32 = new Float32Array(positions);
  const normals32 = new Float32Array(normals);
  const uvs32 = new Float32Array(uvs);
  vertexData.indices = indices;
  vertexData.positions = positions32;
  vertexData.normals = normals32;
  vertexData.uvs = uvs32;
  if (colors) {
    vertexData.set(colors, VertexBuffer.ColorKind);
  }
  if (closePath) {
    vertexData._idx = idx;
  }
  return vertexData;
}
function CreateRibbon(name137, options, scene = null) {
  const pathArray = options.pathArray;
  const closeArray = options.closeArray;
  const closePath = options.closePath;
  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const instance = options.instance;
  const updatable = options.updatable;
  if (instance) {
    const minimum = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);
    const maximum = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);
    const positionFunction = (positions2) => {
      let minlg = pathArray[0].length;
      const mesh = instance;
      let i = 0;
      const ns = mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE ? 2 : 1;
      for (let si = 1; si <= ns; ++si) {
        for (let p = 0; p < pathArray.length; ++p) {
          const path = pathArray[p];
          const l = path.length;
          minlg = minlg < l ? minlg : l;
          for (let j = 0; j < minlg; ++j) {
            const pathPoint = path[j];
            positions2[i] = pathPoint.x;
            positions2[i + 1] = pathPoint.y;
            positions2[i + 2] = pathPoint.z;
            minimum.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);
            maximum.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);
            i += 3;
          }
          if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {
            const pathPoint = path[0];
            positions2[i] = pathPoint.x;
            positions2[i + 1] = pathPoint.y;
            positions2[i + 2] = pathPoint.z;
            i += 3;
          }
        }
      }
    };
    const positions = instance.getVerticesData(VertexBuffer.PositionKind);
    positionFunction(positions);
    if (instance.hasBoundingInfo) {
      instance.getBoundingInfo().reConstruct(minimum, maximum, instance._worldMatrix);
    } else {
      instance.buildBoundingInfo(minimum, maximum, instance._worldMatrix);
    }
    instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
    if (options.colors) {
      const colors = instance.getVerticesData(VertexBuffer.ColorKind);
      for (let c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {
        const color = options.colors[c];
        colors[colorIndex] = color.r;
        colors[colorIndex + 1] = color.g;
        colors[colorIndex + 2] = color.b;
        colors[colorIndex + 3] = color.a;
      }
      instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);
    }
    if (options.uvs) {
      const uvs = instance.getVerticesData(VertexBuffer.UVKind);
      for (let i = 0; i < options.uvs.length; i++) {
        uvs[i * 2] = options.uvs[i].x;
        uvs[i * 2 + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - options.uvs[i].y : options.uvs[i].y;
      }
      instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);
    }
    if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {
      const indices = instance.getIndices();
      const normals = instance.getVerticesData(VertexBuffer.NormalKind);
      const params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;
      VertexData.ComputeNormals(positions, indices, normals, params);
      if (instance._creationDataStorage && instance._creationDataStorage.closePath) {
        let indexFirst = 0;
        let indexLast = 0;
        for (let p = 0; p < pathArray.length; p++) {
          indexFirst = instance._creationDataStorage.idx[p] * 3;
          if (p + 1 < pathArray.length) {
            indexLast = (instance._creationDataStorage.idx[p + 1] - 1) * 3;
          } else {
            indexLast = normals.length - 3;
          }
          normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;
          normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;
          normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;
          normals[indexLast] = normals[indexFirst];
          normals[indexLast + 1] = normals[indexFirst + 1];
          normals[indexLast + 2] = normals[indexFirst + 2];
        }
      }
      if (!instance.areNormalsFrozen) {
        instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);
      }
    }
    return instance;
  } else {
    const ribbon = new Mesh(name137, scene);
    ribbon._originalBuilderSideOrientation = sideOrientation;
    ribbon._creationDataStorage = new _CreationDataStorage();
    const vertexData = CreateRibbonVertexData(options);
    if (closePath) {
      ribbon._creationDataStorage.idx = vertexData._idx;
    }
    ribbon._creationDataStorage.closePath = closePath;
    ribbon._creationDataStorage.closeArray = closeArray;
    vertexData.applyToMesh(ribbon, updatable);
    return ribbon;
  }
}
var RibbonBuilder = {
  CreateRibbon
};
VertexData.CreateRibbon = CreateRibbonVertexData;
Mesh.CreateRibbon = (name137, pathArray, closeArray = false, closePath, offset, scene, updatable = false, sideOrientation, instance) => {
  return CreateRibbon(name137, {
    pathArray,
    closeArray,
    closePath,
    offset,
    updatable,
    sideOrientation,
    instance
  }, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/shapeBuilder.js
function ExtrudeShape(name137, options, scene = null) {
  const path = options.path;
  const shape = options.shape;
  const scale = options.scale || 1;
  const rotation = options.rotation || 0;
  const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;
  const updatable = options.updatable;
  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const instance = options.instance || null;
  const invertUV = options.invertUV || false;
  const closeShape = options.closeShape || false;
  const closePath = options.closePath || false;
  return _ExtrudeShapeGeneric(name137, shape, path, scale, rotation, null, null, closePath, closeShape, cap, false, scene, updatable ? true : false, sideOrientation, instance, invertUV, options.frontUVs || null, options.backUVs || null, options.firstNormal || null, options.adjustFrame ? true : false);
}
function ExtrudeShapeCustom(name137, options, scene = null) {
  const path = options.path;
  const shape = options.shape;
  const scaleFunction = options.scaleFunction || (() => {
    return 1;
  });
  const rotationFunction = options.rotationFunction || (() => {
    return 0;
  });
  const ribbonCloseArray = options.closePath || options.ribbonCloseArray || false;
  const ribbonClosePath = options.closeShape || options.ribbonClosePath || false;
  const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;
  const updatable = options.updatable;
  const firstNormal = options.firstNormal || null;
  const adjustFrame = options.adjustFrame || false;
  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const instance = options.instance;
  const invertUV = options.invertUV || false;
  return _ExtrudeShapeGeneric(name137, shape, path, null, null, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable ? true : false, sideOrientation, instance || null, invertUV, options.frontUVs || null, options.backUVs || null, firstNormal, adjustFrame);
}
function _ExtrudeShapeGeneric(name137, shape, curve, scale, rotation, scaleFunction, rotateFunction, rbCA, rbCP, cap, custom, scene, updtbl, side, instance, invertUV, frontUVs, backUVs, firstNormal, adjustFrame) {
  const extrusionPathArray = (shape2, curve2, path3D2, shapePaths, scale2, rotation2, scaleFunction2, rotateFunction2, cap2, custom2, adjustFrame2) => {
    const tangents = path3D2.getTangents();
    const normals = path3D2.getNormals();
    const binormals = path3D2.getBinormals();
    const distances = path3D2.getDistances();
    if (adjustFrame2) {
      for (let i = 0; i < tangents.length; i++) {
        if (tangents[i].x == 0 && tangents[i].y == 0 && tangents[i].z == 0) {
          tangents[i].copyFrom(tangents[i - 1]);
        }
        if (normals[i].x == 0 && normals[i].y == 0 && normals[i].z == 0) {
          normals[i].copyFrom(normals[i - 1]);
        }
        if (binormals[i].x == 0 && binormals[i].y == 0 && binormals[i].z == 0) {
          binormals[i].copyFrom(binormals[i - 1]);
        }
        if (i > 0) {
          let v = tangents[i - 1];
          if (Vector3.Dot(v, tangents[i]) < 0) {
            tangents[i].scaleInPlace(-1);
          }
          v = normals[i - 1];
          if (Vector3.Dot(v, normals[i]) < 0) {
            normals[i].scaleInPlace(-1);
          }
          v = binormals[i - 1];
          if (Vector3.Dot(v, binormals[i]) < 0) {
            binormals[i].scaleInPlace(-1);
          }
        }
      }
    }
    let angle = 0;
    const returnScale = () => {
      return scale2 !== null ? scale2 : 1;
    };
    const returnRotation = () => {
      return rotation2 !== null ? rotation2 : 0;
    };
    const rotate = custom2 && rotateFunction2 ? rotateFunction2 : returnRotation;
    const scl = custom2 && scaleFunction2 ? scaleFunction2 : returnScale;
    let index = cap2 === Mesh.NO_CAP || cap2 === Mesh.CAP_END ? 0 : 2;
    const rotationMatrix = TmpVectors.Matrix[0];
    for (let i = 0; i < curve2.length; i++) {
      const shapePath = new Array();
      const angleStep = rotate(i, distances[i]);
      const scaleRatio = scl(i, distances[i]);
      Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);
      for (let p = 0; p < shape2.length; p++) {
        const planed = tangents[i].scale(shape2[p].z).add(normals[i].scale(shape2[p].x)).add(binormals[i].scale(shape2[p].y));
        const rotated = Vector3.Zero();
        Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);
        rotated.scaleInPlace(scaleRatio).addInPlace(curve2[i]);
        shapePath[p] = rotated;
      }
      shapePaths[index] = shapePath;
      angle += angleStep;
      index++;
    }
    const capPath = (shapePath) => {
      const pointCap = Array();
      const barycenter = Vector3.Zero();
      let i;
      for (i = 0; i < shapePath.length; i++) {
        barycenter.addInPlace(shapePath[i]);
      }
      barycenter.scaleInPlace(1 / shapePath.length);
      for (i = 0; i < shapePath.length; i++) {
        pointCap.push(barycenter);
      }
      return pointCap;
    };
    switch (cap2) {
      case Mesh.NO_CAP:
        break;
      case Mesh.CAP_START:
        shapePaths[0] = capPath(shapePaths[2]);
        shapePaths[1] = shapePaths[2];
        break;
      case Mesh.CAP_END:
        shapePaths[index] = shapePaths[index - 1];
        shapePaths[index + 1] = capPath(shapePaths[index - 1]);
        break;
      case Mesh.CAP_ALL:
        shapePaths[0] = capPath(shapePaths[2]);
        shapePaths[1] = shapePaths[2];
        shapePaths[index] = shapePaths[index - 1];
        shapePaths[index + 1] = capPath(shapePaths[index - 1]);
        break;
      default:
        break;
    }
    return shapePaths;
  };
  let path3D;
  let pathArray;
  if (instance) {
    const storage = instance._creationDataStorage;
    path3D = firstNormal ? storage.path3D.update(curve, firstNormal) : storage.path3D.update(curve);
    pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom, adjustFrame);
    instance = CreateRibbon("", { pathArray, closeArray: false, closePath: false, offset: 0, updatable: false, sideOrientation: 0, instance }, scene || void 0);
    return instance;
  }
  path3D = firstNormal ? new Path3D(curve, firstNormal) : new Path3D(curve);
  const newShapePaths = new Array();
  cap = cap < 0 || cap > 3 ? 0 : cap;
  pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom, adjustFrame);
  const extrudedGeneric = CreateRibbon(name137, {
    pathArray,
    closeArray: rbCA,
    closePath: rbCP,
    updatable: updtbl,
    sideOrientation: side,
    invertUV,
    frontUVs: frontUVs || void 0,
    backUVs: backUVs || void 0
  }, scene);
  extrudedGeneric._creationDataStorage.pathArray = pathArray;
  extrudedGeneric._creationDataStorage.path3D = path3D;
  extrudedGeneric._creationDataStorage.cap = cap;
  return extrudedGeneric;
}
var ShapeBuilder = {
  ExtrudeShape,
  ExtrudeShapeCustom
};
Mesh.ExtrudeShape = (name137, shape, path, scale, rotation, cap, scene = null, updatable, sideOrientation, instance) => {
  const options = {
    shape,
    path,
    scale,
    rotation,
    cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,
    sideOrientation,
    instance,
    updatable
  };
  return ExtrudeShape(name137, options, scene);
};
Mesh.ExtrudeShapeCustom = (name137, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) => {
  const options = {
    shape,
    path,
    scaleFunction,
    rotationFunction,
    ribbonCloseArray,
    ribbonClosePath,
    cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,
    sideOrientation,
    instance,
    updatable
  };
  return ExtrudeShapeCustom(name137, options, scene);
};

// node_modules/@babylonjs/core/Debug/skeletonViewer.js
var SkeletonViewer = class {
  constructor(skeleton, mesh, scene, autoUpdateBonesMatrices = true, renderingGroupId = 3, options = {}) {
    var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    this.skeleton = skeleton;
    this.mesh = mesh;
    this.autoUpdateBonesMatrices = autoUpdateBonesMatrices;
    this.renderingGroupId = renderingGroupId;
    this.options = options;
    this.color = Color3.White();
    this._debugLines = new Array();
    this._localAxes = null;
    this._isEnabled = true;
    this._obs = null;
    this._scene = scene;
    this._ready = false;
    options.pauseAnimations = (_a = options.pauseAnimations) !== null && _a !== void 0 ? _a : true;
    options.returnToRest = (_c = options.returnToRest) !== null && _c !== void 0 ? _c : false;
    options.displayMode = (_d = options.displayMode) !== null && _d !== void 0 ? _d : SkeletonViewer.DISPLAY_LINES;
    options.displayOptions = (_e = options.displayOptions) !== null && _e !== void 0 ? _e : {};
    options.displayOptions.midStep = (_f = options.displayOptions.midStep) !== null && _f !== void 0 ? _f : 0.235;
    options.displayOptions.midStepFactor = (_g = options.displayOptions.midStepFactor) !== null && _g !== void 0 ? _g : 0.155;
    options.displayOptions.sphereBaseSize = (_h = options.displayOptions.sphereBaseSize) !== null && _h !== void 0 ? _h : 0.15;
    options.displayOptions.sphereScaleUnit = (_j = options.displayOptions.sphereScaleUnit) !== null && _j !== void 0 ? _j : 2;
    options.displayOptions.sphereFactor = (_k = options.displayOptions.sphereFactor) !== null && _k !== void 0 ? _k : 0.865;
    options.displayOptions.spurFollowsChild = (_l = options.displayOptions.spurFollowsChild) !== null && _l !== void 0 ? _l : false;
    options.displayOptions.showLocalAxes = (_m = options.displayOptions.showLocalAxes) !== null && _m !== void 0 ? _m : false;
    options.displayOptions.localAxesSize = (_o = options.displayOptions.localAxesSize) !== null && _o !== void 0 ? _o : 0.075;
    options.computeBonesUsingShaders = (_p = options.computeBonesUsingShaders) !== null && _p !== void 0 ? _p : true;
    options.useAllBones = (_q = options.useAllBones) !== null && _q !== void 0 ? _q : true;
    const initialMeshBoneIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);
    const initialMeshBoneWeights = mesh.getVerticesData(VertexBuffer.MatricesWeightsKind);
    this._boneIndices = /* @__PURE__ */ new Set();
    if (!options.useAllBones) {
      if (initialMeshBoneIndices && initialMeshBoneWeights) {
        for (let i = 0; i < initialMeshBoneIndices.length; ++i) {
          const index = initialMeshBoneIndices[i], weight = initialMeshBoneWeights[i];
          if (weight !== 0) {
            this._boneIndices.add(index);
          }
        }
      }
    }
    this._utilityLayer = new UtilityLayerRenderer(this._scene, false);
    this._utilityLayer.pickUtilitySceneFirst = false;
    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;
    let displayMode = this.options.displayMode || 0;
    if (displayMode > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {
      displayMode = SkeletonViewer.DISPLAY_LINES;
    }
    this.displayMode = displayMode;
    this.update();
    this._bindObs();
  }
  static CreateBoneWeightShader(options, scene) {
    var _a, _c, _d, _e, _f, _g;
    const skeleton = options.skeleton;
    const colorBase = (_a = options.colorBase) !== null && _a !== void 0 ? _a : Color3.Black();
    const colorZero = (_c = options.colorZero) !== null && _c !== void 0 ? _c : Color3.Blue();
    const colorQuarter = (_d = options.colorQuarter) !== null && _d !== void 0 ? _d : Color3.Green();
    const colorHalf = (_e = options.colorHalf) !== null && _e !== void 0 ? _e : Color3.Yellow();
    const colorFull = (_f = options.colorFull) !== null && _f !== void 0 ? _f : Color3.Red();
    const targetBoneIndex = (_g = options.targetBoneIndex) !== null && _g !== void 0 ? _g : 0;
    Effect.ShadersStore["boneWeights:" + skeleton.name + "VertexShader"] = `precision highp float;

        attribute vec3 position;
        attribute vec2 uv;

        uniform mat4 view;
        uniform mat4 projection;
        uniform mat4 worldViewProjection;

        #include<bonesDeclaration>
        #if NUM_BONE_INFLUENCERS == 0
            attribute vec4 matricesIndices;
            attribute vec4 matricesWeights;
        #endif
        #include<bakedVertexAnimationDeclaration>

        #include<instancesDeclaration>

        varying vec3 vColor;

        uniform vec3 colorBase;
        uniform vec3 colorZero;
        uniform vec3 colorQuarter;
        uniform vec3 colorHalf;
        uniform vec3 colorFull;

        uniform float targetBoneIndex;

        void main() {
            vec3 positionUpdated = position;

            #include<instancesVertex>
            #include<bonesVertex>
            #include<bakedVertexAnimation>

            vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);

            vec3 color = colorBase;
            float totalWeight = 0.;
            if(matricesIndices[0] == targetBoneIndex && matricesWeights[0] > 0.){
                totalWeight += matricesWeights[0];
            }
            if(matricesIndices[1] == targetBoneIndex && matricesWeights[1] > 0.){
                totalWeight += matricesWeights[1];
            }
            if(matricesIndices[2] == targetBoneIndex && matricesWeights[2] > 0.){
                totalWeight += matricesWeights[2];
            }
            if(matricesIndices[3] == targetBoneIndex && matricesWeights[3] > 0.){
                totalWeight += matricesWeights[3];
            }

            color = mix(color, colorZero, smoothstep(0., 0.25, totalWeight));
            color = mix(color, colorQuarter, smoothstep(0.25, 0.5, totalWeight));
            color = mix(color, colorHalf, smoothstep(0.5, 0.75, totalWeight));
            color = mix(color, colorFull, smoothstep(0.75, 1.0, totalWeight));
            vColor = color;

        gl_Position = projection * view * worldPos;
        }`;
    Effect.ShadersStore["boneWeights:" + skeleton.name + "FragmentShader"] = `
            precision highp float;
            varying vec3 vPosition;

            varying vec3 vColor;

            void main() {
                vec4 color = vec4(vColor, 1.0);
                gl_FragColor = color;
            }
        `;
    const shader137 = new ShaderMaterial("boneWeight:" + skeleton.name, scene, {
      vertex: "boneWeights:" + skeleton.name,
      fragment: "boneWeights:" + skeleton.name
    }, {
      attributes: ["position", "normal", "matricesIndices", "matricesWeights"],
      uniforms: [
        "world",
        "worldView",
        "worldViewProjection",
        "view",
        "projection",
        "viewProjection",
        "colorBase",
        "colorZero",
        "colorQuarter",
        "colorHalf",
        "colorFull",
        "targetBoneIndex"
      ]
    });
    shader137.setColor3("colorBase", colorBase);
    shader137.setColor3("colorZero", colorZero);
    shader137.setColor3("colorQuarter", colorQuarter);
    shader137.setColor3("colorHalf", colorHalf);
    shader137.setColor3("colorFull", colorFull);
    shader137.setFloat("targetBoneIndex", targetBoneIndex);
    shader137.getClassName = () => {
      return "BoneWeightShader";
    };
    shader137.transparencyMode = Material.MATERIAL_OPAQUE;
    return shader137;
  }
  static CreateSkeletonMapShader(options, scene) {
    var _a;
    const skeleton = options.skeleton;
    const colorMap = (_a = options.colorMap) !== null && _a !== void 0 ? _a : [
      {
        color: new Color3(1, 0.38, 0.18),
        location: 0
      },
      {
        color: new Color3(0.59, 0.18, 1),
        location: 0.2
      },
      {
        color: new Color3(0.59, 1, 0.18),
        location: 0.4
      },
      {
        color: new Color3(1, 0.87, 0.17),
        location: 0.6
      },
      {
        color: new Color3(1, 0.17, 0.42),
        location: 0.8
      },
      {
        color: new Color3(0.17, 0.68, 1),
        location: 1
      }
    ];
    const bufferWidth = skeleton.bones.length + 1;
    const colorMapBuffer = SkeletonViewer._CreateBoneMapColorBuffer(bufferWidth, colorMap, scene);
    const shader137 = new ShaderMaterial("boneWeights:" + skeleton.name, scene, {
      vertexSource: `precision highp float;

            attribute vec3 position;
            attribute vec2 uv;

            uniform mat4 view;
            uniform mat4 projection;
            uniform mat4 worldViewProjection;
            uniform float colorMap[` + skeleton.bones.length * 4 + `];

            #include<bonesDeclaration>
            #if NUM_BONE_INFLUENCERS == 0
                attribute vec4 matricesIndices;
                attribute vec4 matricesWeights;
            #endif
            #include<bakedVertexAnimationDeclaration>
            #include<instancesDeclaration>

            varying vec3 vColor;

            void main() {
                vec3 positionUpdated = position;

                #include<instancesVertex>
                #include<bonesVertex>
                #include<bakedVertexAnimation>

                vec3 color = vec3(0.);
                bool first = true;

                for (int i = 0; i < 4; i++) {
                    int boneIdx = int(matricesIndices[i]);
                    float boneWgt = matricesWeights[i];

                    vec3 c = vec3(colorMap[boneIdx * 4 + 0], colorMap[boneIdx * 4 + 1], colorMap[boneIdx * 4 + 2]);

                    if (boneWgt > 0.) {
                        if (first) {
                            first = false;
                            color = c;
                        } else {
                            color = mix(color, c, boneWgt);
                        }
                    }
                }

                vColor = color;

                vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);

                gl_Position = projection * view * worldPos;
            }`,
      fragmentSource: `
            precision highp float;
            varying vec3 vColor;

            void main() {
                vec4 color = vec4( vColor, 1.0 );
                gl_FragColor = color;
            }
            `
    }, {
      attributes: ["position", "normal", "matricesIndices", "matricesWeights"],
      uniforms: ["world", "worldView", "worldViewProjection", "view", "projection", "viewProjection", "colorMap"]
    });
    shader137.setFloats("colorMap", colorMapBuffer);
    shader137.getClassName = () => {
      return "SkeletonMapShader";
    };
    shader137.transparencyMode = Material.MATERIAL_OPAQUE;
    return shader137;
  }
  static _CreateBoneMapColorBuffer(size, colorMap, scene) {
    const tempGrad = new DynamicTexture("temp", { width: size, height: 1 }, scene, false);
    const ctx = tempGrad.getContext();
    const grad = ctx.createLinearGradient(0, 0, size, 0);
    colorMap.forEach((stop) => {
      grad.addColorStop(stop.location, stop.color.toHexString());
    });
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, size, 1);
    tempGrad.update();
    const buffer = [];
    const data = ctx.getImageData(0, 0, size, 1).data;
    const rUnit = 1 / 255;
    for (let i = 0; i < data.length; i++) {
      buffer.push(data[i] * rUnit);
    }
    tempGrad.dispose();
    return buffer;
  }
  get scene() {
    return this._scene;
  }
  get utilityLayer() {
    return this._utilityLayer;
  }
  get isReady() {
    return this._ready;
  }
  set ready(value) {
    this._ready = value;
  }
  get debugMesh() {
    return this._debugMesh;
  }
  set debugMesh(value) {
    this._debugMesh = value;
  }
  get displayMode() {
    return this.options.displayMode || SkeletonViewer.DISPLAY_LINES;
  }
  set displayMode(value) {
    if (value > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {
      value = SkeletonViewer.DISPLAY_LINES;
    }
    this.options.displayMode = value;
  }
  _bindObs() {
    switch (this.displayMode) {
      case SkeletonViewer.DISPLAY_LINES: {
        this._obs = this.scene.onBeforeRenderObservable.add(() => {
          this._displayLinesUpdate();
        });
        break;
      }
    }
  }
  update() {
    switch (this.displayMode) {
      case SkeletonViewer.DISPLAY_LINES: {
        this._displayLinesUpdate();
        break;
      }
      case SkeletonViewer.DISPLAY_SPHERES: {
        this._buildSpheresAndSpurs(true);
        break;
      }
      case SkeletonViewer.DISPLAY_SPHERE_AND_SPURS: {
        this._buildSpheresAndSpurs(false);
        break;
      }
    }
    this._buildLocalAxes();
  }
  set isEnabled(value) {
    if (this.isEnabled === value) {
      return;
    }
    this._isEnabled = value;
    if (this.debugMesh) {
      this.debugMesh.setEnabled(value);
    }
    if (value && !this._obs) {
      this._bindObs();
    } else if (!value && this._obs) {
      this.scene.onBeforeRenderObservable.remove(this._obs);
      this._obs = null;
    }
  }
  get isEnabled() {
    return this._isEnabled;
  }
  _getBonePosition(position, bone, meshMat, x = 0, y = 0, z = 0) {
    const tmat = TmpVectors.Matrix[0];
    const parentBone = bone.getParent();
    tmat.copyFrom(bone.getLocalMatrix());
    if (x !== 0 || y !== 0 || z !== 0) {
      const tmat2 = TmpVectors.Matrix[1];
      Matrix.IdentityToRef(tmat2);
      tmat2.setTranslationFromFloats(x, y, z);
      tmat2.multiplyToRef(tmat, tmat);
    }
    if (parentBone) {
      tmat.multiplyToRef(parentBone.getAbsoluteTransform(), tmat);
    }
    tmat.multiplyToRef(meshMat, tmat);
    position.x = tmat.m[12];
    position.y = tmat.m[13];
    position.z = tmat.m[14];
  }
  _getLinesForBonesWithLength(bones, meshMat) {
    const len = bones.length;
    const mesh = this.mesh;
    const meshPos = mesh.position;
    let idx = 0;
    for (let i = 0; i < len; i++) {
      const bone = bones[i];
      let points = this._debugLines[idx];
      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {
        continue;
      }
      if (!points) {
        points = [Vector3.Zero(), Vector3.Zero()];
        this._debugLines[idx] = points;
      }
      this._getBonePosition(points[0], bone, meshMat);
      this._getBonePosition(points[1], bone, meshMat, 0, bone.length, 0);
      points[0].subtractInPlace(meshPos);
      points[1].subtractInPlace(meshPos);
      idx++;
    }
  }
  _getLinesForBonesNoLength(bones) {
    const len = bones.length;
    let boneNum = 0;
    const mesh = this.mesh;
    const meshPos = mesh.position;
    for (let i = len - 1; i >= 0; i--) {
      const childBone = bones[i];
      const parentBone = childBone.getParent();
      if (!parentBone || !this._boneIndices.has(childBone.getIndex()) && !this.options.useAllBones) {
        continue;
      }
      let points = this._debugLines[boneNum];
      if (!points) {
        points = [Vector3.Zero(), Vector3.Zero()];
        this._debugLines[boneNum] = points;
      }
      childBone.getAbsolutePositionToRef(mesh, points[0]);
      parentBone.getAbsolutePositionToRef(mesh, points[1]);
      points[0].subtractInPlace(meshPos);
      points[1].subtractInPlace(meshPos);
      boneNum++;
    }
  }
  _revert(animationState) {
    if (this.options.pauseAnimations) {
      this.scene.animationsEnabled = animationState;
      this.utilityLayer.utilityLayerScene.animationsEnabled = animationState;
    }
  }
  _getAbsoluteBindPoseToRef(bone, matrix) {
    if (bone === null || bone._index === -1) {
      matrix.copyFrom(Matrix.Identity());
      return;
    }
    this._getAbsoluteBindPoseToRef(bone.getParent(), matrix);
    bone.getBaseMatrix().multiplyToRef(matrix, matrix);
    return;
  }
  _buildSpheresAndSpurs(spheresOnly = true) {
    var _a, _c;
    if (this._debugMesh) {
      this._debugMesh.dispose();
      this._debugMesh = null;
      this.ready = false;
    }
    this._ready = false;
    const utilityLayerScene = (_a = this.utilityLayer) === null || _a === void 0 ? void 0 : _a.utilityLayerScene;
    const bones = this.skeleton.bones;
    const spheres = [];
    const spurs = [];
    const animationState = this.scene.animationsEnabled;
    try {
      if (this.options.pauseAnimations) {
        this.scene.animationsEnabled = false;
        utilityLayerScene.animationsEnabled = false;
      }
      if (this.options.returnToRest) {
        this.skeleton.returnToRest();
      }
      if (this.autoUpdateBonesMatrices) {
        this.skeleton.computeAbsoluteTransforms();
      }
      let longestBoneLength = Number.NEGATIVE_INFINITY;
      const displayOptions = this.options.displayOptions || {};
      for (let i = 0; i < bones.length; i++) {
        const bone = bones[i];
        if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {
          continue;
        }
        const boneAbsoluteBindPoseTransform = new Matrix();
        this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);
        const anchorPoint = new Vector3();
        boneAbsoluteBindPoseTransform.decompose(void 0, void 0, anchorPoint);
        bone.children.forEach((bc) => {
          const childAbsoluteBindPoseTransform = new Matrix();
          bc.getBaseMatrix().multiplyToRef(boneAbsoluteBindPoseTransform, childAbsoluteBindPoseTransform);
          const childPoint = new Vector3();
          childAbsoluteBindPoseTransform.decompose(void 0, void 0, childPoint);
          const distanceFromParent = Vector3.Distance(anchorPoint, childPoint);
          if (distanceFromParent > longestBoneLength) {
            longestBoneLength = distanceFromParent;
          }
          if (spheresOnly) {
            return;
          }
          const dir = childPoint.clone().subtract(anchorPoint.clone());
          const h = dir.length();
          const up = dir.normalize().scale(h);
          const midStep = displayOptions.midStep || 0.165;
          const midStepFactor = displayOptions.midStepFactor || 0.215;
          const up0 = up.scale(midStep);
          const spur = ExtrudeShapeCustom("skeletonViewer", {
            shape: [new Vector3(1, -1, 0), new Vector3(1, 1, 0), new Vector3(-1, 1, 0), new Vector3(-1, -1, 0), new Vector3(1, -1, 0)],
            path: [Vector3.Zero(), up0, up],
            scaleFunction: (i2) => {
              switch (i2) {
                case 0:
                case 2:
                  return 0;
                case 1:
                  return h * midStepFactor;
              }
              return 0;
            },
            sideOrientation: Mesh.DEFAULTSIDE,
            updatable: false
          }, utilityLayerScene);
          const numVertices2 = spur.getTotalVertices();
          const mwk2 = [], mik2 = [];
          for (let i2 = 0; i2 < numVertices2; i2++) {
            mwk2.push(1, 0, 0, 0);
            if (displayOptions.spurFollowsChild && i2 > 9) {
              mik2.push(bc.getIndex(), 0, 0, 0);
            } else {
              mik2.push(bone.getIndex(), 0, 0, 0);
            }
          }
          spur.position = anchorPoint.clone();
          spur.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk2, false);
          spur.setVerticesData(VertexBuffer.MatricesIndicesKind, mik2, false);
          spur.convertToFlatShadedMesh();
          spurs.push(spur);
        });
        const sphereBaseSize = displayOptions.sphereBaseSize || 0.2;
        const sphere = CreateSphere("skeletonViewer", {
          segments: 6,
          diameter: sphereBaseSize,
          updatable: true
        }, utilityLayerScene);
        const numVertices = sphere.getTotalVertices();
        const mwk = [], mik = [];
        for (let i2 = 0; i2 < numVertices; i2++) {
          mwk.push(1, 0, 0, 0);
          mik.push(bone.getIndex(), 0, 0, 0);
        }
        sphere.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);
        sphere.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);
        sphere.position = anchorPoint.clone();
        spheres.push([sphere, bone]);
      }
      const sphereScaleUnit = displayOptions.sphereScaleUnit || 2;
      const sphereFactor = displayOptions.sphereFactor || 0.85;
      const meshes = [];
      for (let i = 0; i < spheres.length; i++) {
        const [sphere, bone] = spheres[i];
        const scale = 1 / (sphereScaleUnit / longestBoneLength);
        let _stepsOut = 0;
        let _b = bone;
        while (_b.getParent() && _b.getParent().getIndex() !== -1) {
          _stepsOut++;
          _b = _b.getParent();
        }
        sphere.scaling.scaleInPlace(scale * Math.pow(sphereFactor, _stepsOut));
        meshes.push(sphere);
      }
      this.debugMesh = Mesh.MergeMeshes(meshes.concat(spurs), true, true);
      if (this.debugMesh) {
        this.debugMesh.renderingGroupId = this.renderingGroupId;
        this.debugMesh.skeleton = this.skeleton;
        this.debugMesh.parent = this.mesh;
        this.debugMesh.computeBonesUsingShaders = (_c = this.options.computeBonesUsingShaders) !== null && _c !== void 0 ? _c : true;
        this.debugMesh.alwaysSelectAsActiveMesh = true;
      }
      const light = this.utilityLayer._getSharedGizmoLight();
      light.intensity = 0.7;
      this._revert(animationState);
      this.ready = true;
    } catch (err) {
      console.error(err);
      this._revert(animationState);
      this.dispose();
    }
  }
  _buildLocalAxes() {
    var _a;
    if (this._localAxes) {
      this._localAxes.dispose();
    }
    this._localAxes = null;
    const displayOptions = this.options.displayOptions || {};
    if (!displayOptions.showLocalAxes) {
      return;
    }
    const targetScene = this._utilityLayer.utilityLayerScene;
    const size = displayOptions.localAxesSize || 0.075;
    const lines = [];
    const colors = [];
    const red = new Color4(1, 0, 0, 1);
    const green = new Color4(0, 1, 0, 1);
    const blue = new Color4(0, 0, 1, 1);
    const mwk = [];
    const mik = [];
    const vertsPerBone = 6;
    for (const i in this.skeleton.bones) {
      const bone = this.skeleton.bones[i];
      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {
        continue;
      }
      const boneAbsoluteBindPoseTransform = new Matrix();
      const boneOrigin = new Vector3();
      this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);
      boneAbsoluteBindPoseTransform.decompose(void 0, TmpVectors.Quaternion[0], boneOrigin);
      const m = new Matrix();
      TmpVectors.Quaternion[0].toRotationMatrix(m);
      const boneAxisX = Vector3.TransformCoordinates(new Vector3(0 + size, 0, 0), m);
      const boneAxisY = Vector3.TransformCoordinates(new Vector3(0, 0 + size, 0), m);
      const boneAxisZ = Vector3.TransformCoordinates(new Vector3(0, 0, 0 + size), m);
      const axisX = [boneOrigin, boneOrigin.add(boneAxisX)];
      const axisY = [boneOrigin, boneOrigin.add(boneAxisY)];
      const axisZ = [boneOrigin, boneOrigin.add(boneAxisZ)];
      const linePoints = [axisX, axisY, axisZ];
      const lineColors = [
        [red, red],
        [green, green],
        [blue, blue]
      ];
      lines.push(...linePoints);
      colors.push(...lineColors);
      for (let j = 0; j < vertsPerBone; j++) {
        mwk.push(1, 0, 0, 0);
        mik.push(bone.getIndex(), 0, 0, 0);
      }
    }
    this._localAxes = CreateLineSystem("localAxes", { lines, colors, updatable: true }, targetScene);
    this._localAxes.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);
    this._localAxes.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);
    this._localAxes.skeleton = this.skeleton;
    this._localAxes.renderingGroupId = this.renderingGroupId + 1;
    this._localAxes.parent = this.mesh;
    this._localAxes.computeBonesUsingShaders = (_a = this.options.computeBonesUsingShaders) !== null && _a !== void 0 ? _a : true;
  }
  _displayLinesUpdate() {
    if (!this._utilityLayer) {
      return;
    }
    if (this.autoUpdateBonesMatrices) {
      this.skeleton.computeAbsoluteTransforms();
    }
    if (this.skeleton.bones[0].length === void 0) {
      this._getLinesForBonesNoLength(this.skeleton.bones);
    } else {
      this._getLinesForBonesWithLength(this.skeleton.bones, this.mesh.getWorldMatrix());
    }
    const targetScene = this._utilityLayer.utilityLayerScene;
    if (targetScene) {
      if (!this._debugMesh) {
        this._debugMesh = CreateLineSystem("", { lines: this._debugLines, updatable: true, instance: null }, targetScene);
        this._debugMesh.renderingGroupId = this.renderingGroupId;
      } else {
        CreateLineSystem("", { lines: this._debugLines, updatable: true, instance: this._debugMesh }, targetScene);
      }
      this._debugMesh.position.copyFrom(this.mesh.position);
      this._debugMesh.color = this.color;
    }
  }
  changeDisplayMode(mode) {
    const wasEnabled = this.isEnabled ? true : false;
    if (this.displayMode !== mode) {
      this.isEnabled = false;
      if (this._debugMesh) {
        this._debugMesh.dispose();
        this._debugMesh = null;
        this.ready = false;
      }
      this.displayMode = mode;
      this.update();
      this._bindObs();
      this.isEnabled = wasEnabled;
    }
  }
  changeDisplayOptions(option, value) {
    const wasEnabled = this.isEnabled ? true : false;
    this.options.displayOptions[option] = value;
    this.isEnabled = false;
    if (this._debugMesh) {
      this._debugMesh.dispose();
      this._debugMesh = null;
      this.ready = false;
    }
    this.update();
    this._bindObs();
    this.isEnabled = wasEnabled;
  }
  dispose() {
    this.isEnabled = false;
    if (this._debugMesh) {
      this._debugMesh.dispose();
      this._debugMesh = null;
    }
    if (this._utilityLayer) {
      this._utilityLayer.dispose();
      this._utilityLayer = null;
    }
    this.ready = false;
  }
};
SkeletonViewer.DISPLAY_LINES = 0;
SkeletonViewer.DISPLAY_SPHERES = 1;
SkeletonViewer.DISPLAY_SPHERE_AND_SPURS = 2;

// node_modules/@babylonjs/core/Debug/directionalLightFrustumViewer.js
var DirectionalLightFrustumViewer = class {
  constructor(light, camera) {
    this._oldPosition = new Vector3(Number.NaN, Number.NaN, Number.NaN);
    this._oldDirection = new Vector3(Number.NaN, Number.NaN, Number.NaN);
    this._transparency = 0.3;
    this._showLines = true;
    this._showPlanes = true;
    this._scene = light.getScene();
    this._light = light;
    this._camera = camera;
    this._inverseViewMatrix = Matrix.Identity();
    this._lightHelperFrustumMeshes = [];
    this._createGeometry();
    this.show();
    this.update();
  }
  get transparency() {
    return this._transparency;
  }
  set transparency(alpha) {
    this._transparency = alpha;
    for (let i = 6; i < 12; ++i) {
      this._lightHelperFrustumMeshes[i].material.alpha = alpha;
    }
  }
  get showLines() {
    return this._showLines;
  }
  set showLines(show) {
    if (this._showLines === show) {
      return;
    }
    this._showLines = show;
    for (let i = 0; i < 6; ++i) {
      this._lightHelperFrustumMeshes[i].setEnabled(show);
    }
  }
  get showPlanes() {
    return this._showPlanes;
  }
  set showPlanes(show) {
    if (this._showPlanes === show) {
      return;
    }
    this._showPlanes = show;
    for (let i = 6; i < 12; ++i) {
      this._lightHelperFrustumMeshes[i].setEnabled(show);
    }
  }
  show() {
    this._lightHelperFrustumMeshes.forEach((mesh, index) => {
      mesh.setEnabled(index < 6 && this._showLines || index >= 6 && this._showPlanes);
    });
    this._oldPosition.set(Number.NaN, Number.NaN, Number.NaN);
    this._visible = true;
  }
  hide() {
    this._lightHelperFrustumMeshes.forEach((mesh) => {
      mesh.setEnabled(false);
    });
    this._visible = false;
  }
  update() {
    var _a, _b, _c, _d, _e, _f;
    if (!this._visible) {
      return;
    }
    if (this._oldPosition.equals(this._light.position) && this._oldDirection.equals(this._light.direction) && this._oldAutoCalc === this._light.autoCalcShadowZBounds && this._oldMinZ === this._light.shadowMinZ && this._oldMaxZ === this._light.shadowMaxZ) {
      return;
    }
    this._oldPosition.copyFrom(this._light.position);
    this._oldDirection.copyFrom(this._light.direction);
    this._oldAutoCalc = this._light.autoCalcShadowZBounds;
    this._oldMinZ = this._light.shadowMinZ;
    this._oldMaxZ = this._light.shadowMaxZ;
    TmpVectors.Vector3[0].set(this._light.orthoLeft, this._light.orthoBottom, this._light.shadowMinZ !== void 0 ? this._light.shadowMinZ : this._camera.minZ);
    TmpVectors.Vector3[1].set(this._light.orthoRight, this._light.orthoTop, this._light.shadowMaxZ !== void 0 ? this._light.shadowMaxZ : this._camera.maxZ);
    const invLightView = this._getInvertViewMatrix();
    TmpVectors.Vector3[2].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[0].z);
    TmpVectors.Vector3[3].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);
    TmpVectors.Vector3[4].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);
    TmpVectors.Vector3[5].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[0].z);
    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[2], invLightView, TmpVectors.Vector3[2]);
    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[3], invLightView, TmpVectors.Vector3[3]);
    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[4], invLightView, TmpVectors.Vector3[4]);
    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[5], invLightView, TmpVectors.Vector3[5]);
    TmpVectors.Vector3[6].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[1].z);
    TmpVectors.Vector3[7].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[1].z);
    TmpVectors.Vector3[8].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[1].z);
    TmpVectors.Vector3[9].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[1].z);
    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[6], invLightView, TmpVectors.Vector3[6]);
    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[7], invLightView, TmpVectors.Vector3[7]);
    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[8], invLightView, TmpVectors.Vector3[8]);
    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[9], invLightView, TmpVectors.Vector3[9]);
    CreateLines("nearlines", { updatable: true, points: this._nearLinesPoints, instance: this._lightHelperFrustumMeshes[0] }, this._scene);
    CreateLines("farlines", { updatable: true, points: this._farLinesPoints, instance: this._lightHelperFrustumMeshes[1] }, this._scene);
    CreateLines("trlines", { updatable: true, points: this._trLinesPoints, instance: this._lightHelperFrustumMeshes[2] }, this._scene);
    CreateLines("brlines", { updatable: true, points: this._brLinesPoints, instance: this._lightHelperFrustumMeshes[3] }, this._scene);
    CreateLines("tllines", { updatable: true, points: this._tlLinesPoints, instance: this._lightHelperFrustumMeshes[4] }, this._scene);
    CreateLines("bllines", { updatable: true, points: this._blLinesPoints, instance: this._lightHelperFrustumMeshes[5] }, this._scene);
    TmpVectors.Vector3[2].toArray(this._nearPlaneVertices, 0);
    TmpVectors.Vector3[3].toArray(this._nearPlaneVertices, 3);
    TmpVectors.Vector3[4].toArray(this._nearPlaneVertices, 6);
    TmpVectors.Vector3[5].toArray(this._nearPlaneVertices, 9);
    (_a = this._lightHelperFrustumMeshes[6].geometry) === null || _a === void 0 ? void 0 : _a.updateVerticesDataDirectly("position", this._nearPlaneVertices, 0);
    TmpVectors.Vector3[6].toArray(this._farPlaneVertices, 0);
    TmpVectors.Vector3[7].toArray(this._farPlaneVertices, 3);
    TmpVectors.Vector3[8].toArray(this._farPlaneVertices, 6);
    TmpVectors.Vector3[9].toArray(this._farPlaneVertices, 9);
    (_b = this._lightHelperFrustumMeshes[7].geometry) === null || _b === void 0 ? void 0 : _b.updateVerticesDataDirectly("position", this._farPlaneVertices, 0);
    TmpVectors.Vector3[2].toArray(this._rightPlaneVertices, 0);
    TmpVectors.Vector3[6].toArray(this._rightPlaneVertices, 3);
    TmpVectors.Vector3[7].toArray(this._rightPlaneVertices, 6);
    TmpVectors.Vector3[3].toArray(this._rightPlaneVertices, 9);
    (_c = this._lightHelperFrustumMeshes[8].geometry) === null || _c === void 0 ? void 0 : _c.updateVerticesDataDirectly("position", this._rightPlaneVertices, 0);
    TmpVectors.Vector3[5].toArray(this._leftPlaneVertices, 0);
    TmpVectors.Vector3[9].toArray(this._leftPlaneVertices, 3);
    TmpVectors.Vector3[8].toArray(this._leftPlaneVertices, 6);
    TmpVectors.Vector3[4].toArray(this._leftPlaneVertices, 9);
    (_d = this._lightHelperFrustumMeshes[9].geometry) === null || _d === void 0 ? void 0 : _d.updateVerticesDataDirectly("position", this._leftPlaneVertices, 0);
    TmpVectors.Vector3[2].toArray(this._topPlaneVertices, 0);
    TmpVectors.Vector3[6].toArray(this._topPlaneVertices, 3);
    TmpVectors.Vector3[9].toArray(this._topPlaneVertices, 6);
    TmpVectors.Vector3[5].toArray(this._topPlaneVertices, 9);
    (_e = this._lightHelperFrustumMeshes[10].geometry) === null || _e === void 0 ? void 0 : _e.updateVerticesDataDirectly("position", this._topPlaneVertices, 0);
    TmpVectors.Vector3[3].toArray(this._bottomPlaneVertices, 0);
    TmpVectors.Vector3[7].toArray(this._bottomPlaneVertices, 3);
    TmpVectors.Vector3[8].toArray(this._bottomPlaneVertices, 6);
    TmpVectors.Vector3[4].toArray(this._bottomPlaneVertices, 9);
    (_f = this._lightHelperFrustumMeshes[11].geometry) === null || _f === void 0 ? void 0 : _f.updateVerticesDataDirectly("position", this._bottomPlaneVertices, 0);
  }
  dispose() {
    this._lightHelperFrustumMeshes.forEach((mesh) => {
      var _a;
      (_a = mesh.material) === null || _a === void 0 ? void 0 : _a.dispose();
      mesh.dispose();
    });
    this._rootNode.dispose();
  }
  _createGeometry() {
    this._rootNode = new TransformNode("directionalLightHelperRoot_" + this._light.name, this._scene);
    this._rootNode.parent = this._light.parent;
    this._nearLinesPoints = [Vector3.ZeroReadOnly, Vector3.ZeroReadOnly, Vector3.ZeroReadOnly, Vector3.ZeroReadOnly, Vector3.ZeroReadOnly];
    const nearLines = CreateLines("nearlines", { updatable: true, points: this._nearLinesPoints }, this._scene);
    nearLines.parent = this._rootNode;
    nearLines.alwaysSelectAsActiveMesh = true;
    this._farLinesPoints = [Vector3.ZeroReadOnly, Vector3.ZeroReadOnly, Vector3.ZeroReadOnly, Vector3.ZeroReadOnly, Vector3.ZeroReadOnly];
    const farLines = CreateLines("farlines", { updatable: true, points: this._farLinesPoints }, this._scene);
    farLines.parent = this._rootNode;
    farLines.alwaysSelectAsActiveMesh = true;
    this._trLinesPoints = [Vector3.ZeroReadOnly, Vector3.ZeroReadOnly];
    const trLines = CreateLines("trlines", { updatable: true, points: this._trLinesPoints }, this._scene);
    trLines.parent = this._rootNode;
    trLines.alwaysSelectAsActiveMesh = true;
    this._brLinesPoints = [Vector3.ZeroReadOnly, Vector3.ZeroReadOnly];
    const brLines = CreateLines("brlines", { updatable: true, points: this._brLinesPoints }, this._scene);
    brLines.parent = this._rootNode;
    brLines.alwaysSelectAsActiveMesh = true;
    this._tlLinesPoints = [Vector3.ZeroReadOnly, Vector3.ZeroReadOnly];
    const tlLines = CreateLines("tllines", { updatable: true, points: this._tlLinesPoints }, this._scene);
    tlLines.parent = this._rootNode;
    tlLines.alwaysSelectAsActiveMesh = true;
    this._blLinesPoints = [Vector3.ZeroReadOnly, Vector3.ZeroReadOnly];
    const blLines = CreateLines("bllines", { updatable: true, points: this._blLinesPoints }, this._scene);
    blLines.parent = this._rootNode;
    blLines.alwaysSelectAsActiveMesh = true;
    this._lightHelperFrustumMeshes.push(nearLines, farLines, trLines, brLines, tlLines, blLines);
    const makePlane = (name137, color, positions) => {
      const plane = new Mesh(name137 + "plane", this._scene);
      const mat = new StandardMaterial(name137 + "PlaneMat", this._scene);
      plane.material = mat;
      plane.parent = this._rootNode;
      plane.alwaysSelectAsActiveMesh = true;
      mat.emissiveColor = color;
      mat.alpha = this.transparency;
      mat.backFaceCulling = false;
      mat.disableLighting = true;
      const indices = [0, 1, 2, 0, 2, 3];
      const vertexData = new VertexData();
      vertexData.positions = positions;
      vertexData.indices = indices;
      vertexData.applyToMesh(plane, true);
      this._lightHelperFrustumMeshes.push(plane);
    };
    this._nearPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    this._farPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    this._rightPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    this._leftPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    this._topPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    this._bottomPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    makePlane("near", new Color3(1, 0, 0), this._nearPlaneVertices);
    makePlane("far", new Color3(0.3, 0, 0), this._farPlaneVertices);
    makePlane("right", new Color3(0, 1, 0), this._rightPlaneVertices);
    makePlane("left", new Color3(0, 0.3, 0), this._leftPlaneVertices);
    makePlane("top", new Color3(0, 0, 1), this._topPlaneVertices);
    makePlane("bottom", new Color3(0, 0, 0.3), this._bottomPlaneVertices);
    this._nearLinesPoints[0] = TmpVectors.Vector3[2];
    this._nearLinesPoints[1] = TmpVectors.Vector3[3];
    this._nearLinesPoints[2] = TmpVectors.Vector3[4];
    this._nearLinesPoints[3] = TmpVectors.Vector3[5];
    this._nearLinesPoints[4] = TmpVectors.Vector3[2];
    this._farLinesPoints[0] = TmpVectors.Vector3[6];
    this._farLinesPoints[1] = TmpVectors.Vector3[7];
    this._farLinesPoints[2] = TmpVectors.Vector3[8];
    this._farLinesPoints[3] = TmpVectors.Vector3[9];
    this._farLinesPoints[4] = TmpVectors.Vector3[6];
    this._trLinesPoints[0] = TmpVectors.Vector3[2];
    this._trLinesPoints[1] = TmpVectors.Vector3[6];
    this._brLinesPoints[0] = TmpVectors.Vector3[3];
    this._brLinesPoints[1] = TmpVectors.Vector3[7];
    this._tlLinesPoints[0] = TmpVectors.Vector3[4];
    this._tlLinesPoints[1] = TmpVectors.Vector3[8];
    this._blLinesPoints[0] = TmpVectors.Vector3[5];
    this._blLinesPoints[1] = TmpVectors.Vector3[9];
  }
  _getInvertViewMatrix() {
    Matrix.LookAtLHToRef(this._light.position, this._light.position.add(this._light.direction), Vector3.UpReadOnly, this._inverseViewMatrix);
    this._inverseViewMatrix.invertToRef(this._inverseViewMatrix);
    return this._inverseViewMatrix;
  }
};

// node_modules/@babylonjs/core/Engines/nullEngine.js
var NullEngineOptions = class {
  constructor() {
    this.renderWidth = 512;
    this.renderHeight = 256;
    this.textureSize = 512;
    this.deterministicLockstep = false;
    this.lockstepMaxSteps = 4;
  }
};
var NullEngine = class extends Engine {
  constructor(options = new NullEngineOptions()) {
    super(null);
    Engine.Instances.push(this);
    if (options.deterministicLockstep === void 0) {
      options.deterministicLockstep = false;
    }
    if (options.lockstepMaxSteps === void 0) {
      options.lockstepMaxSteps = 4;
    }
    this._options = options;
    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);
    this._caps = {
      maxTexturesImageUnits: 16,
      maxVertexTextureImageUnits: 16,
      maxCombinedTexturesImageUnits: 32,
      maxTextureSize: 512,
      maxCubemapTextureSize: 512,
      maxRenderTextureSize: 512,
      maxVertexAttribs: 16,
      maxVaryingVectors: 16,
      maxFragmentUniformVectors: 16,
      maxVertexUniformVectors: 16,
      standardDerivatives: false,
      astc: null,
      pvrtc: null,
      etc1: null,
      etc2: null,
      bptc: null,
      maxAnisotropy: 0,
      uintIndices: false,
      fragmentDepthSupported: false,
      highPrecisionShaderSupported: true,
      colorBufferFloat: false,
      textureFloat: false,
      textureFloatLinearFiltering: false,
      textureFloatRender: false,
      textureHalfFloat: false,
      textureHalfFloatLinearFiltering: false,
      textureHalfFloatRender: false,
      textureLOD: false,
      drawBuffersExtension: false,
      depthTextureExtension: false,
      vertexArrayObject: false,
      instancedArrays: false,
      supportOcclusionQuery: false,
      canUseTimestampForTimerQuery: false,
      maxMSAASamples: 1,
      blendMinMax: false,
      canUseGLInstanceID: false,
      canUseGLVertexID: false,
      supportComputeShaders: false,
      supportSRGBBuffers: false,
      supportTransformFeedbacks: false,
      textureMaxLevel: false,
      texture2DArrayMaxLayerCount: 128
    };
    this._features = {
      forceBitmapOverHTMLImageElement: false,
      supportRenderAndCopyToLodForFloatTextures: false,
      supportDepthStencilTexture: false,
      supportShadowSamplers: false,
      uniformBufferHardCheckMatrix: false,
      allowTexturePrefiltering: false,
      trackUbosInFrame: false,
      checkUbosContentBeforeUpload: false,
      supportCSM: false,
      basisNeedsPOT: false,
      support3DTextures: false,
      needTypeSuffixInShaderConstants: false,
      supportMSAA: false,
      supportSSAO2: false,
      supportExtendedTextureFormats: false,
      supportSwitchCaseInShader: false,
      supportSyncTextureRead: false,
      needsInvertingBitmap: false,
      useUBOBindingCache: false,
      needShaderCodeInlining: false,
      needToAlwaysBindUniformBuffers: false,
      supportRenderPasses: true,
      supportSpriteInstancing: false,
      _collectUbosUpdatedInFrame: false
    };
    Logger.Log(`Babylon.js v${Engine.Version} - Null engine`);
    const theCurrentGlobal = typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : window;
    if (typeof URL === "undefined") {
      theCurrentGlobal.URL = {
        createObjectURL: function() {
        },
        revokeObjectURL: function() {
        }
      };
    }
    if (typeof Blob === "undefined") {
      theCurrentGlobal.Blob = function() {
      };
    }
  }
  isDeterministicLockStep() {
    return this._options.deterministicLockstep;
  }
  getLockstepMaxSteps() {
    return this._options.lockstepMaxSteps;
  }
  getHardwareScalingLevel() {
    return 1;
  }
  createVertexBuffer(vertices) {
    const buffer = new DataBuffer();
    buffer.references = 1;
    return buffer;
  }
  createIndexBuffer(indices) {
    const buffer = new DataBuffer();
    buffer.references = 1;
    return buffer;
  }
  clear(color, backBuffer, depth, stencil = false) {
  }
  getRenderWidth(useScreen = false) {
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.width;
    }
    return this._options.renderWidth;
  }
  getRenderHeight(useScreen = false) {
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.height;
    }
    return this._options.renderHeight;
  }
  setViewport(viewport, requiredWidth, requiredHeight) {
    this._cachedViewport = viewport;
  }
  createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context) {
    return {
      __SPECTOR_rebuildProgram: null
    };
  }
  getUniforms(pipelineContext, uniformsNames) {
    return [];
  }
  getAttributes(pipelineContext, attributesNames) {
    return [];
  }
  bindSamplers(effect) {
    this._currentEffect = null;
  }
  enableEffect(effect) {
    effect = effect !== null && DrawWrapper.IsWrapper(effect) ? effect.effect : effect;
    this._currentEffect = effect;
    if (!effect) {
      return;
    }
    if (effect.onBind) {
      effect.onBind(effect);
    }
    if (effect._onBindObservable) {
      effect._onBindObservable.notifyObservers(effect);
    }
  }
  setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {
  }
  setIntArray(uniform, array) {
    return true;
  }
  setIntArray2(uniform, array) {
    return true;
  }
  setIntArray3(uniform, array) {
    return true;
  }
  setIntArray4(uniform, array) {
    return true;
  }
  setFloatArray(uniform, array) {
    return true;
  }
  setFloatArray2(uniform, array) {
    return true;
  }
  setFloatArray3(uniform, array) {
    return true;
  }
  setFloatArray4(uniform, array) {
    return true;
  }
  setArray(uniform, array) {
    return true;
  }
  setArray2(uniform, array) {
    return true;
  }
  setArray3(uniform, array) {
    return true;
  }
  setArray4(uniform, array) {
    return true;
  }
  setMatrices(uniform, matrices) {
    return true;
  }
  setMatrix3x3(uniform, matrix) {
    return true;
  }
  setMatrix2x2(uniform, matrix) {
    return true;
  }
  setFloat(uniform, value) {
    return true;
  }
  setFloat2(uniform, x, y) {
    return true;
  }
  setFloat3(uniform, x, y, z) {
    return true;
  }
  setBool(uniform, bool) {
    return true;
  }
  setFloat4(uniform, x, y, z, w) {
    return true;
  }
  setAlphaMode(mode, noDepthWriteChange = false) {
    if (this._alphaMode === mode) {
      return;
    }
    this.alphaState.alphaBlend = mode !== 0;
    if (!noDepthWriteChange) {
      this.setDepthWrite(mode === 0);
    }
    this._alphaMode = mode;
  }
  bindBuffers(vertexBuffers, indexBuffer, effect) {
  }
  wipeCaches(bruteForce) {
    if (this.preventCacheWipeBetweenFrames) {
      return;
    }
    this.resetTextureCache();
    this._currentEffect = null;
    if (bruteForce) {
      this._currentProgram = null;
      this._stencilStateComposer.reset();
      this.depthCullingState.reset();
      this.alphaState.reset();
    }
    this._cachedVertexBuffers = null;
    this._cachedIndexBuffer = null;
    this._cachedEffectForVertexBuffers = null;
  }
  draw(useTriangles, indexStart, indexCount, instancesCount) {
  }
  drawElementsType(fillMode, indexStart, indexCount, instancesCount) {
  }
  drawArraysType(fillMode, verticesStart, verticesCount, instancesCount) {
  }
  _createTexture() {
    return {};
  }
  _releaseTexture(texture) {
  }
  createTexture(urlArg, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType) {
    const texture = new InternalTexture(this, InternalTextureSource.Url);
    const url = String(urlArg);
    texture.url = url;
    texture.generateMipMaps = !noMipmap;
    texture.samplingMode = samplingMode;
    texture.invertY = invertY;
    texture.baseWidth = this._options.textureSize;
    texture.baseHeight = this._options.textureSize;
    texture.width = this._options.textureSize;
    texture.height = this._options.textureSize;
    if (format) {
      texture.format = format;
    }
    texture.isReady = true;
    if (onLoad) {
      setTimeout(() => {
        onLoad(texture);
      });
    }
    this._internalTexturesCache.push(texture);
    return texture;
  }
  _createHardwareRenderTargetWrapper(isMulti, isCube, size) {
    const rtWrapper = new RenderTargetWrapper(isMulti, isCube, size, this);
    this._renderTargetWrapperCache.push(rtWrapper);
    return rtWrapper;
  }
  createRenderTargetTexture(size, options) {
    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);
    const fullOptions = {};
    if (options !== void 0 && typeof options === "object") {
      fullOptions.generateMipMaps = options.generateMipMaps;
      fullOptions.generateDepthBuffer = options.generateDepthBuffer === void 0 ? true : options.generateDepthBuffer;
      fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;
      fullOptions.type = options.type === void 0 ? 0 : options.type;
      fullOptions.samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
    } else {
      fullOptions.generateMipMaps = options;
      fullOptions.generateDepthBuffer = true;
      fullOptions.generateStencilBuffer = false;
      fullOptions.type = 0;
      fullOptions.samplingMode = 3;
    }
    const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);
    const width = size.width || size;
    const height = size.height || size;
    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.isReady = true;
    texture.samples = 1;
    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;
    texture.samplingMode = fullOptions.samplingMode;
    texture.type = fullOptions.type;
    this._internalTexturesCache.push(texture);
    return rtWrapper;
  }
  createRenderTargetCubeTexture(size, options) {
    const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);
    const fullOptions = {
      generateMipMaps: true,
      generateDepthBuffer: true,
      generateStencilBuffer: false,
      type: 0,
      samplingMode: 3,
      format: 5,
      ...options
    };
    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;
    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
      fullOptions.samplingMode = 1;
    } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
      fullOptions.samplingMode = 1;
    }
    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;
    const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);
    texture.baseWidth = size;
    texture.baseHeight = size;
    texture.width = size;
    texture.height = size;
    texture.isReady = true;
    texture.isCube = true;
    texture.samples = 1;
    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;
    texture.samplingMode = fullOptions.samplingMode;
    texture.type = fullOptions.type;
    this._internalTexturesCache.push(texture);
    return rtWrapper;
  }
  updateTextureSamplingMode(samplingMode, texture) {
    texture.samplingMode = samplingMode;
  }
  createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {
    const texture = new InternalTexture(this, InternalTextureSource.Raw);
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.format = format;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    texture.invertY = invertY;
    texture._compression = compression;
    texture.type = type;
    texture._useSRGBBuffer = useSRGBBuffer;
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
    }
    return texture;
  }
  updateRawTexture(texture, data, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {
    if (texture) {
      texture._bufferView = data;
      texture.format = format;
      texture.invertY = invertY;
      texture._compression = compression;
      texture.type = type;
      texture._useSRGBBuffer = useSRGBBuffer;
    }
  }
  bindFramebuffer(rtWrapper, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    }
    this._currentRenderTarget = rtWrapper;
    this._currentFramebuffer = null;
    if (this._cachedViewport && !forceFullscreenViewport) {
      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);
    }
  }
  unBindFramebuffer(rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {
    this._currentRenderTarget = null;
    if (onBeforeUnbind) {
      onBeforeUnbind();
    }
    this._currentFramebuffer = null;
  }
  createDynamicVertexBuffer(vertices) {
    const buffer = new DataBuffer();
    buffer.references = 1;
    buffer.capacity = 1;
    return buffer;
  }
  updateDynamicTexture(texture, canvas, invertY, premulAlpha = false, format) {
  }
  areAllEffectsReady() {
    return true;
  }
  getError() {
    return 0;
  }
  _getUnpackAlignement() {
    return 1;
  }
  _unpackFlipY(value) {
  }
  updateDynamicIndexBuffer(indexBuffer, indices, offset = 0) {
  }
  updateDynamicVertexBuffer(vertexBuffer, vertices, byteOffset, byteLength) {
  }
  _bindTextureDirectly(target, texture) {
    if (this._boundTexturesCache[this._activeChannel] !== texture) {
      this._boundTexturesCache[this._activeChannel] = texture;
      return true;
    }
    return false;
  }
  _bindTexture(channel, texture) {
    if (channel < 0) {
      return;
    }
    this._bindTextureDirectly(0, texture);
  }
  _deleteBuffer(buffer) {
  }
  releaseEffects() {
  }
  displayLoadingUI() {
  }
  hideLoadingUI() {
  }
  set loadingUIText(_) {
  }
  _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, data, faceIndex = 0, lod = 0) {
  }
  _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0) {
  }
  _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {
  }
  _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {
  }
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.debugging.js
ThinEngine.prototype._debugPushGroup = function(groupName, targetObject) {
};
ThinEngine.prototype._debugPopGroup = function(targetObject) {
};
ThinEngine.prototype._debugInsertMarker = function(text, targetObject) {
};
ThinEngine.prototype._debugFlushPendingCommands = function() {
};

// node_modules/@babylonjs/core/Instrumentation/timeToken.js
var _TimeToken = class {
  constructor() {
    this._timeElapsedQueryEnded = false;
  }
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.query.js
var _OcclusionDataStorage = class {
  constructor() {
    this.occlusionInternalRetryCounter = 0;
    this.isOcclusionQueryInProgress = false;
    this.isOccluded = false;
    this.occlusionRetryCount = -1;
    this.occlusionType = AbstractMesh.OCCLUSION_TYPE_NONE;
    this.occlusionQueryAlgorithmType = AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE;
    this.forceRenderingWhenOccluded = false;
  }
};
Engine.prototype.createQuery = function() {
  const query = this._gl.createQuery();
  if (!query) {
    throw new Error("Unable to create Occlusion Query");
  }
  return query;
};
Engine.prototype.deleteQuery = function(query) {
  this._gl.deleteQuery(query);
  return this;
};
Engine.prototype.isQueryResultAvailable = function(query) {
  return this._gl.getQueryParameter(query, this._gl.QUERY_RESULT_AVAILABLE);
};
Engine.prototype.getQueryResult = function(query) {
  return this._gl.getQueryParameter(query, this._gl.QUERY_RESULT);
};
Engine.prototype.beginOcclusionQuery = function(algorithmType, query) {
  const glAlgorithm = this._getGlAlgorithmType(algorithmType);
  this._gl.beginQuery(glAlgorithm, query);
  return true;
};
Engine.prototype.endOcclusionQuery = function(algorithmType) {
  const glAlgorithm = this._getGlAlgorithmType(algorithmType);
  this._gl.endQuery(glAlgorithm);
  return this;
};
Engine.prototype._createTimeQuery = function() {
  const timerQuery = this.getCaps().timerQuery;
  if (timerQuery.createQueryEXT) {
    return timerQuery.createQueryEXT();
  }
  return this.createQuery();
};
Engine.prototype._deleteTimeQuery = function(query) {
  const timerQuery = this.getCaps().timerQuery;
  if (timerQuery.deleteQueryEXT) {
    timerQuery.deleteQueryEXT(query);
    return;
  }
  this.deleteQuery(query);
};
Engine.prototype._getTimeQueryResult = function(query) {
  const timerQuery = this.getCaps().timerQuery;
  if (timerQuery.getQueryObjectEXT) {
    return timerQuery.getQueryObjectEXT(query, timerQuery.QUERY_RESULT_EXT);
  }
  return this.getQueryResult(query);
};
Engine.prototype._getTimeQueryAvailability = function(query) {
  const timerQuery = this.getCaps().timerQuery;
  if (timerQuery.getQueryObjectEXT) {
    return timerQuery.getQueryObjectEXT(query, timerQuery.QUERY_RESULT_AVAILABLE_EXT);
  }
  return this.isQueryResultAvailable(query);
};
Engine.prototype.startTimeQuery = function() {
  const caps = this.getCaps();
  const timerQuery = caps.timerQuery;
  if (!timerQuery) {
    return null;
  }
  const token = new _TimeToken();
  this._gl.getParameter(timerQuery.GPU_DISJOINT_EXT);
  if (caps.canUseTimestampForTimerQuery) {
    token._startTimeQuery = this._createTimeQuery();
    timerQuery.queryCounterEXT(token._startTimeQuery, timerQuery.TIMESTAMP_EXT);
  } else {
    if (this._currentNonTimestampToken) {
      return this._currentNonTimestampToken;
    }
    token._timeElapsedQuery = this._createTimeQuery();
    if (timerQuery.beginQueryEXT) {
      timerQuery.beginQueryEXT(timerQuery.TIME_ELAPSED_EXT, token._timeElapsedQuery);
    } else {
      this._gl.beginQuery(timerQuery.TIME_ELAPSED_EXT, token._timeElapsedQuery);
    }
    this._currentNonTimestampToken = token;
  }
  return token;
};
Engine.prototype.endTimeQuery = function(token) {
  const caps = this.getCaps();
  const timerQuery = caps.timerQuery;
  if (!timerQuery || !token) {
    return -1;
  }
  if (caps.canUseTimestampForTimerQuery) {
    if (!token._startTimeQuery) {
      return -1;
    }
    if (!token._endTimeQuery) {
      token._endTimeQuery = this._createTimeQuery();
      timerQuery.queryCounterEXT(token._endTimeQuery, timerQuery.TIMESTAMP_EXT);
    }
  } else if (!token._timeElapsedQueryEnded) {
    if (!token._timeElapsedQuery) {
      return -1;
    }
    if (timerQuery.endQueryEXT) {
      timerQuery.endQueryEXT(timerQuery.TIME_ELAPSED_EXT);
    } else {
      this._gl.endQuery(timerQuery.TIME_ELAPSED_EXT);
      this._currentNonTimestampToken = null;
    }
    token._timeElapsedQueryEnded = true;
  }
  const disjoint = this._gl.getParameter(timerQuery.GPU_DISJOINT_EXT);
  let available = false;
  if (token._endTimeQuery) {
    available = this._getTimeQueryAvailability(token._endTimeQuery);
  } else if (token._timeElapsedQuery) {
    available = this._getTimeQueryAvailability(token._timeElapsedQuery);
  }
  if (available && !disjoint) {
    let result = 0;
    if (caps.canUseTimestampForTimerQuery) {
      if (!token._startTimeQuery || !token._endTimeQuery) {
        return -1;
      }
      const timeStart = this._getTimeQueryResult(token._startTimeQuery);
      const timeEnd = this._getTimeQueryResult(token._endTimeQuery);
      result = timeEnd - timeStart;
      this._deleteTimeQuery(token._startTimeQuery);
      this._deleteTimeQuery(token._endTimeQuery);
      token._startTimeQuery = null;
      token._endTimeQuery = null;
    } else {
      if (!token._timeElapsedQuery) {
        return -1;
      }
      result = this._getTimeQueryResult(token._timeElapsedQuery);
      this._deleteTimeQuery(token._timeElapsedQuery);
      token._timeElapsedQuery = null;
      token._timeElapsedQueryEnded = false;
    }
    return result;
  }
  return -1;
};
Engine.prototype._captureGPUFrameTime = false;
Engine.prototype._gpuFrameTime = new PerfCounter();
Engine.prototype.getGPUFrameTimeCounter = function() {
  return this._gpuFrameTime;
};
Engine.prototype.captureGPUFrameTime = function(value) {
  if (value === this._captureGPUFrameTime) {
    return;
  }
  this._captureGPUFrameTime = value;
  if (value) {
    this._onBeginFrameObserver = this.onBeginFrameObservable.add(() => {
      if (!this._gpuFrameTimeToken) {
        this._gpuFrameTimeToken = this.startTimeQuery();
      }
    });
    this._onEndFrameObserver = this.onEndFrameObservable.add(() => {
      if (!this._gpuFrameTimeToken) {
        return;
      }
      const time = this.endTimeQuery(this._gpuFrameTimeToken);
      if (time > -1) {
        this._gpuFrameTimeToken = null;
        this._gpuFrameTime.fetchNewFrame();
        this._gpuFrameTime.addCount(time, true);
      }
    });
  } else {
    this.onBeginFrameObservable.remove(this._onBeginFrameObserver);
    this._onBeginFrameObserver = null;
    this.onEndFrameObservable.remove(this._onEndFrameObserver);
    this._onEndFrameObserver = null;
  }
};
Engine.prototype._getGlAlgorithmType = function(algorithmType) {
  return algorithmType === AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE ? this._gl.ANY_SAMPLES_PASSED_CONSERVATIVE : this._gl.ANY_SAMPLES_PASSED;
};
Object.defineProperty(AbstractMesh.prototype, "isOcclusionQueryInProgress", {
  get: function() {
    return this._occlusionDataStorage.isOcclusionQueryInProgress;
  },
  set: function(value) {
    this._occlusionDataStorage.isOcclusionQueryInProgress = value;
  },
  enumerable: false,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "_occlusionDataStorage", {
  get: function() {
    if (!this.__occlusionDataStorage) {
      this.__occlusionDataStorage = new _OcclusionDataStorage();
    }
    return this.__occlusionDataStorage;
  },
  enumerable: false,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "isOccluded", {
  get: function() {
    return this._occlusionDataStorage.isOccluded;
  },
  set: function(value) {
    this._occlusionDataStorage.isOccluded = value;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "occlusionQueryAlgorithmType", {
  get: function() {
    return this._occlusionDataStorage.occlusionQueryAlgorithmType;
  },
  set: function(value) {
    this._occlusionDataStorage.occlusionQueryAlgorithmType = value;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "occlusionType", {
  get: function() {
    return this._occlusionDataStorage.occlusionType;
  },
  set: function(value) {
    this._occlusionDataStorage.occlusionType = value;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "occlusionRetryCount", {
  get: function() {
    return this._occlusionDataStorage.occlusionRetryCount;
  },
  set: function(value) {
    this._occlusionDataStorage.occlusionRetryCount = value;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "forceRenderingWhenOccluded", {
  get: function() {
    return this._occlusionDataStorage.forceRenderingWhenOccluded;
  },
  set: function(value) {
    this._occlusionDataStorage.forceRenderingWhenOccluded = value;
  },
  enumerable: true,
  configurable: true
});
AbstractMesh.prototype._checkOcclusionQuery = function() {
  const dataStorage = this._occlusionDataStorage;
  if (dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_NONE) {
    dataStorage.isOccluded = false;
    return false;
  }
  const engine = this.getEngine();
  if (!engine.getCaps().supportOcclusionQuery) {
    dataStorage.isOccluded = false;
    return false;
  }
  if (!engine.isQueryResultAvailable) {
    dataStorage.isOccluded = false;
    return false;
  }
  if (this.isOcclusionQueryInProgress && this._occlusionQuery) {
    const isOcclusionQueryAvailable = engine.isQueryResultAvailable(this._occlusionQuery);
    if (isOcclusionQueryAvailable) {
      const occlusionQueryResult = engine.getQueryResult(this._occlusionQuery);
      dataStorage.isOcclusionQueryInProgress = false;
      dataStorage.occlusionInternalRetryCounter = 0;
      dataStorage.isOccluded = occlusionQueryResult > 0 ? false : true;
    } else {
      dataStorage.occlusionInternalRetryCounter++;
      if (dataStorage.occlusionRetryCount !== -1 && dataStorage.occlusionInternalRetryCounter > dataStorage.occlusionRetryCount) {
        dataStorage.isOcclusionQueryInProgress = false;
        dataStorage.occlusionInternalRetryCounter = 0;
        dataStorage.isOccluded = dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC ? false : dataStorage.isOccluded;
      } else {
        return dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC ? false : dataStorage.isOccluded;
      }
    }
  }
  const scene = this.getScene();
  if (scene.getBoundingBoxRenderer) {
    const occlusionBoundingBoxRenderer = scene.getBoundingBoxRenderer();
    if (this._occlusionQuery === null) {
      this._occlusionQuery = engine.createQuery();
    }
    if (engine.beginOcclusionQuery(dataStorage.occlusionQueryAlgorithmType, this._occlusionQuery)) {
      occlusionBoundingBoxRenderer.renderOcclusionBoundingBox(this);
      engine.endOcclusionQuery(dataStorage.occlusionQueryAlgorithmType);
      this._occlusionDataStorage.isOcclusionQueryInProgress = true;
    }
  }
  return dataStorage.isOccluded;
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.transformFeedback.js
var _forceTransformFeedbackToBundle = true;
Engine.prototype.createTransformFeedback = function() {
  const transformFeedback = this._gl.createTransformFeedback();
  if (!transformFeedback) {
    throw new Error("Unable to create Transform Feedback");
  }
  return transformFeedback;
};
Engine.prototype.deleteTransformFeedback = function(value) {
  this._gl.deleteTransformFeedback(value);
};
Engine.prototype.bindTransformFeedback = function(value) {
  this._gl.bindTransformFeedback(this._gl.TRANSFORM_FEEDBACK, value);
};
Engine.prototype.beginTransformFeedback = function(usePoints = true) {
  this._gl.beginTransformFeedback(usePoints ? this._gl.POINTS : this._gl.TRIANGLES);
};
Engine.prototype.endTransformFeedback = function() {
  this._gl.endTransformFeedback();
};
Engine.prototype.setTranformFeedbackVaryings = function(program, value) {
  this._gl.transformFeedbackVaryings(program, value, this._gl.INTERLEAVED_ATTRIBS);
};
Engine.prototype.bindTransformFeedbackBuffer = function(value) {
  this._gl.bindBufferBase(this._gl.TRANSFORM_FEEDBACK_BUFFER, 0, value ? value.underlyingResource : null);
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.externalTexture.js
ThinEngine.prototype.createExternalTexture = function(video) {
  return null;
};
ThinEngine.prototype.setExternalTexture = function(name137, texture) {
  throw new Error("setExternalTexture: This engine does not support external textures!");
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.videoTexture.js
ThinEngine.prototype.updateVideoTexture = function(texture, video, invertY) {
  if (!texture || texture._isDisabled) {
    return;
  }
  const glformat = this._getInternalFormat(texture.format);
  const internalFormat = this._getRGBABufferInternalSizedFormat(0, texture.format);
  const wasPreviouslyBound = this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
  this._unpackFlipY(!invertY);
  try {
    if (this._videoTextureSupported === void 0) {
      this._gl.getError();
      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, glformat, this._gl.UNSIGNED_BYTE, video);
      if (this._gl.getError() !== 0) {
        this._videoTextureSupported = false;
      } else {
        this._videoTextureSupported = true;
      }
    }
    if (!this._videoTextureSupported) {
      if (!texture._workingCanvas) {
        texture._workingCanvas = this.createCanvas(texture.width, texture.height);
        const context = texture._workingCanvas.getContext("2d");
        if (!context) {
          throw new Error("Unable to get 2d context");
        }
        texture._workingContext = context;
        texture._workingCanvas.width = texture.width;
        texture._workingCanvas.height = texture.height;
      }
      texture._workingContext.clearRect(0, 0, texture.width, texture.height);
      texture._workingContext.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, texture.width, texture.height);
      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, glformat, this._gl.UNSIGNED_BYTE, texture._workingCanvas);
    } else {
      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, glformat, this._gl.UNSIGNED_BYTE, video);
    }
    if (texture.generateMipMaps) {
      this._gl.generateMipmap(this._gl.TEXTURE_2D);
    }
    if (!wasPreviouslyBound) {
      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
    }
    texture.isReady = true;
  } catch (ex) {
    texture._isDisabled = true;
  }
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.multiRender.js
ThinEngine.prototype.restoreSingleAttachment = function() {
  const gl = this._gl;
  this.bindAttachments([gl.BACK]);
};
ThinEngine.prototype.restoreSingleAttachmentForRenderTarget = function() {
  const gl = this._gl;
  this.bindAttachments([gl.COLOR_ATTACHMENT0]);
};
ThinEngine.prototype.buildTextureLayout = function(textureStatus) {
  const gl = this._gl;
  const result = [];
  for (let i = 0; i < textureStatus.length; i++) {
    if (textureStatus[i]) {
      result.push(gl["COLOR_ATTACHMENT" + i]);
    } else {
      result.push(gl.NONE);
    }
  }
  return result;
};
ThinEngine.prototype.bindAttachments = function(attachments) {
  const gl = this._gl;
  gl.drawBuffers(attachments);
};
ThinEngine.prototype.unBindMultiColorAttachmentFramebuffer = function(rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {
  this._currentRenderTarget = null;
  const gl = this._gl;
  const attachments = rtWrapper._attachments;
  const count = attachments.length;
  if (rtWrapper._MSAAFramebuffer) {
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, rtWrapper._MSAAFramebuffer);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, rtWrapper._framebuffer);
    for (let i = 0; i < count; i++) {
      const texture = rtWrapper.textures[i];
      for (let j = 0; j < count; j++) {
        attachments[j] = gl.NONE;
      }
      attachments[i] = gl[this.webGLVersion > 1 ? "COLOR_ATTACHMENT" + i : "COLOR_ATTACHMENT" + i + "_WEBGL"];
      gl.readBuffer(attachments[i]);
      gl.drawBuffers(attachments);
      gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
    }
    for (let i = 0; i < count; i++) {
      attachments[i] = gl[this.webGLVersion > 1 ? "COLOR_ATTACHMENT" + i : "COLOR_ATTACHMENT" + i + "_WEBGL"];
    }
    gl.drawBuffers(attachments);
  }
  for (let i = 0; i < count; i++) {
    const texture = rtWrapper.textures[i];
    if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {
      this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
      gl.generateMipmap(gl.TEXTURE_2D);
      this._bindTextureDirectly(gl.TEXTURE_2D, null);
    }
  }
  if (onBeforeUnbind) {
    if (rtWrapper._MSAAFramebuffer) {
      this._bindUnboundFramebuffer(rtWrapper._framebuffer);
    }
    onBeforeUnbind();
  }
  this._bindUnboundFramebuffer(null);
};
ThinEngine.prototype.createMultipleRenderTarget = function(size, options, initializeBuffers = true) {
  let generateMipMaps = false;
  let generateDepthBuffer = true;
  let generateStencilBuffer = false;
  let generateDepthTexture = false;
  let depthTextureFormat = 15;
  let textureCount = 1;
  const defaultType = 0;
  const defaultSamplingMode = 3;
  const defaultUseSRGBBuffer = false;
  let types = new Array();
  let samplingModes = new Array();
  let useSRGBBuffers = new Array();
  const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size);
  if (options !== void 0) {
    generateMipMaps = options.generateMipMaps === void 0 ? false : options.generateMipMaps;
    generateDepthBuffer = options.generateDepthBuffer === void 0 ? true : options.generateDepthBuffer;
    generateStencilBuffer = options.generateStencilBuffer === void 0 ? false : options.generateStencilBuffer;
    generateDepthTexture = options.generateDepthTexture === void 0 ? false : options.generateDepthTexture;
    textureCount = options.textureCount || 1;
    if (options.types) {
      types = options.types;
    }
    if (options.samplingModes) {
      samplingModes = options.samplingModes;
    }
    if (options.useSRGBBuffers) {
      useSRGBBuffers = options.useSRGBBuffers;
    }
    if (this.webGLVersion > 1 && (options.depthTextureFormat === 13 || options.depthTextureFormat === 17 || options.depthTextureFormat === 16 || options.depthTextureFormat === 14 || options.depthTextureFormat === 18)) {
      depthTextureFormat = options.depthTextureFormat;
    }
  }
  const gl = this._gl;
  const framebuffer = gl.createFramebuffer();
  this._bindUnboundFramebuffer(framebuffer);
  const width = size.width || size;
  const height = size.height || size;
  const textures = [];
  const attachments = [];
  const useStencilTexture = this.webGLVersion > 1 && generateDepthTexture && (options.depthTextureFormat === 13 || options.depthTextureFormat === 17 || options.depthTextureFormat === 18);
  const depthStencilBuffer = this._setupFramebufferDepthAttachments(!useStencilTexture && generateStencilBuffer, !generateDepthTexture && generateDepthBuffer, width, height);
  rtWrapper._framebuffer = framebuffer;
  rtWrapper._depthStencilBuffer = depthStencilBuffer;
  rtWrapper._generateDepthBuffer = !generateDepthTexture && generateDepthBuffer;
  rtWrapper._generateStencilBuffer = !useStencilTexture && generateStencilBuffer;
  rtWrapper._attachments = attachments;
  for (let i = 0; i < textureCount; i++) {
    let samplingMode = samplingModes[i] || defaultSamplingMode;
    let type = types[i] || defaultType;
    let useSRGBBuffer = useSRGBBuffers[i] || defaultUseSRGBBuffer;
    if (type === 1 && !this._caps.textureFloatLinearFiltering) {
      samplingMode = 1;
    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
      samplingMode = 1;
    }
    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
    if (type === 1 && !this._caps.textureFloat) {
      type = 0;
      Logger.Warn("Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type");
    }
    useSRGBBuffer = useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU);
    const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);
    const attachment = gl[this.webGLVersion > 1 ? "COLOR_ATTACHMENT" + i : "COLOR_ATTACHMENT" + i + "_WEBGL"];
    textures.push(texture);
    attachments.push(attachment);
    gl.activeTexture(gl["TEXTURE" + i]);
    gl.bindTexture(gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    const internalSizedFormat = this._getRGBABufferInternalSizedFormat(type, 5, useSRGBBuffer);
    gl.texImage2D(gl.TEXTURE_2D, 0, internalSizedFormat, width, height, 0, gl.RGBA, this._getWebGLTextureType(type), null);
    gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource, 0);
    if (generateMipMaps) {
      this._gl.generateMipmap(this._gl.TEXTURE_2D);
    }
    this._bindTextureDirectly(gl.TEXTURE_2D, null);
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.isReady = true;
    texture.samples = 1;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    texture.type = type;
    texture._useSRGBBuffer = useSRGBBuffer;
    this._internalTexturesCache.push(texture);
  }
  if (generateDepthTexture && this._caps.depthTextureExtension) {
    const depthTexture = new InternalTexture(this, InternalTextureSource.Depth);
    let depthTextureType = 5;
    let glDepthTextureInternalFormat = gl.DEPTH_COMPONENT16;
    let glDepthTextureFormat = gl.DEPTH_COMPONENT;
    let glDepthTextureType = gl.UNSIGNED_SHORT;
    let glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;
    if (this.webGLVersion < 2) {
      glDepthTextureInternalFormat = gl.DEPTH_COMPONENT;
    } else {
      if (depthTextureFormat === 14) {
        depthTextureType = 1;
        glDepthTextureType = gl.FLOAT;
        glDepthTextureInternalFormat = gl.DEPTH_COMPONENT32F;
      } else if (depthTextureFormat === 18) {
        depthTextureType = 0;
        glDepthTextureType = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
        glDepthTextureInternalFormat = gl.DEPTH32F_STENCIL8;
        glDepthTextureFormat = gl.DEPTH_STENCIL;
        glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;
      } else if (depthTextureFormat === 16) {
        depthTextureType = 0;
        glDepthTextureType = gl.UNSIGNED_INT;
        glDepthTextureInternalFormat = gl.DEPTH_COMPONENT24;
        glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;
      } else if (depthTextureFormat === 13 || depthTextureFormat === 17) {
        depthTextureType = 12;
        glDepthTextureType = gl.UNSIGNED_INT_24_8;
        glDepthTextureInternalFormat = gl.DEPTH24_STENCIL8;
        glDepthTextureFormat = gl.DEPTH_STENCIL;
        glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;
      }
    }
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, depthTexture._hardwareTexture.underlyingResource);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, glDepthTextureInternalFormat, width, height, 0, glDepthTextureFormat, glDepthTextureType, null);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, glDepthTextureAttachment, gl.TEXTURE_2D, depthTexture._hardwareTexture.underlyingResource, 0);
    depthTexture.baseWidth = width;
    depthTexture.baseHeight = height;
    depthTexture.width = width;
    depthTexture.height = height;
    depthTexture.isReady = true;
    depthTexture.samples = 1;
    depthTexture.generateMipMaps = generateMipMaps;
    depthTexture.samplingMode = 1;
    depthTexture.format = depthTextureFormat;
    depthTexture.type = depthTextureType;
    textures.push(depthTexture);
    this._internalTexturesCache.push(depthTexture);
  }
  rtWrapper.setTextures(textures);
  if (initializeBuffers) {
    gl.drawBuffers(attachments);
  }
  this._bindUnboundFramebuffer(null);
  this.resetTextureCache();
  return rtWrapper;
};
ThinEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function(rtWrapper, samples, initializeBuffers = true) {
  if (this.webGLVersion < 2 || !rtWrapper || !rtWrapper.texture) {
    return 1;
  }
  if (rtWrapper.samples === samples) {
    return samples;
  }
  const count = rtWrapper._attachments.length;
  if (count === 0) {
    return 1;
  }
  const gl = this._gl;
  samples = Math.min(samples, this.getCaps().maxMSAASamples);
  const useDepthStencil = !!rtWrapper._depthStencilBuffer;
  if (useDepthStencil) {
    gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);
    rtWrapper._depthStencilBuffer = null;
  }
  if (rtWrapper._MSAAFramebuffer) {
    gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);
    rtWrapper._MSAAFramebuffer = null;
  }
  if (samples > 1 && gl.renderbufferStorageMultisample) {
    const framebuffer = gl.createFramebuffer();
    if (!framebuffer) {
      throw new Error("Unable to create multi sampled framebuffer");
    }
    rtWrapper._MSAAFramebuffer = framebuffer;
    this._bindUnboundFramebuffer(framebuffer);
    const attachments = [];
    for (let i = 0; i < count; i++) {
      const texture = rtWrapper.textures[i];
      const hardwareTexture = texture._hardwareTexture;
      const attachment = gl[this.webGLVersion > 1 ? "COLOR_ATTACHMENT" + i : "COLOR_ATTACHMENT" + i + "_WEBGL"];
      const colorRenderbuffer = hardwareTexture._MSAARenderBuffer ? this._updateRenderBuffer(hardwareTexture._MSAARenderBuffer, texture.width, texture.height, samples, -1, this._getRGBAMultiSampleBufferFormat(texture.type), attachment) : this._createRenderBuffer(texture.width, texture.height, samples, -1, this._getRGBAMultiSampleBufferFormat(texture.type), attachment);
      if (!colorRenderbuffer) {
        throw new Error("Unable to create multi sampled framebuffer");
      }
      hardwareTexture._MSAARenderBuffer = colorRenderbuffer;
      texture.samples = samples;
      attachments.push(attachment);
    }
    if (initializeBuffers) {
      gl.drawBuffers(attachments);
    }
  } else {
    this._bindUnboundFramebuffer(rtWrapper._framebuffer);
  }
  if (useDepthStencil) {
    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, rtWrapper.texture.width, rtWrapper.texture.height, samples);
  }
  this._bindUnboundFramebuffer(null);
  return samples;
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.textureSampler.js
ThinEngine.prototype.setTextureSampler = function(name137, sampler) {
  throw new Error("setTextureSampler: This engine does not support separate texture sampler objects!");
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.views.js
var EngineView = class {
};
var _onBeforeViewRenderObservable = new Observable();
var _onAfterViewRenderObservable = new Observable();
Object.defineProperty(Engine.prototype, "onBeforeViewRenderObservable", {
  get: function() {
    return _onBeforeViewRenderObservable;
  }
});
Object.defineProperty(Engine.prototype, "onAfterViewRenderObservable", {
  get: function() {
    return _onAfterViewRenderObservable;
  }
});
Object.defineProperty(Engine.prototype, "inputElement", {
  get: function() {
    return this._inputElement;
  },
  set: function(value) {
    var _a;
    if (this._inputElement !== value) {
      this._inputElement = value;
      (_a = this._onEngineViewChanged) === null || _a === void 0 ? void 0 : _a.call(this);
    }
  }
});
Engine.prototype.getInputElement = function() {
  return this.inputElement || this.getRenderingCanvas();
};
Engine.prototype.registerView = function(canvas, camera, clearBeforeCopy) {
  if (!this.views) {
    this.views = [];
  }
  for (const view of this.views) {
    if (view.target === canvas) {
      return view;
    }
  }
  const masterCanvas = this.getRenderingCanvas();
  if (masterCanvas) {
    canvas.width = masterCanvas.width;
    canvas.height = masterCanvas.height;
  }
  const newView = { target: canvas, camera, clearBeforeCopy, enabled: true, id: (Math.random() * 1e5).toFixed() };
  this.views.push(newView);
  if (camera) {
    camera.onDisposeObservable.add(() => {
      this.unRegisterView(canvas);
    });
  }
  return newView;
};
Engine.prototype.unRegisterView = function(canvas) {
  if (!this.views || this.views.length === 0) {
    return this;
  }
  for (const view of this.views) {
    if (view.target === canvas) {
      const index = this.views.indexOf(view);
      if (index !== -1) {
        this.views.splice(index, 1);
      }
      break;
    }
  }
  return this;
};
Engine.prototype._renderViewStep = function(view) {
  const canvas = view.target;
  const context = canvas.getContext("2d");
  if (!context) {
    return true;
  }
  const parent = this.getRenderingCanvas();
  _onBeforeViewRenderObservable.notifyObservers(view);
  const camera = view.camera;
  let previewCamera = null;
  let scene = null;
  if (camera) {
    scene = camera.getScene();
    if (!scene || scene.activeCameras && scene.activeCameras.length) {
      return true;
    }
    this.activeView = view;
    previewCamera = scene.activeCamera;
    scene.activeCamera = camera;
  }
  if (view.customResize) {
    view.customResize(canvas);
  } else {
    const width = Math.floor(canvas.clientWidth / this._hardwareScalingLevel);
    const height = Math.floor(canvas.clientHeight / this._hardwareScalingLevel);
    const dimsChanged = width !== canvas.width || parent.width !== canvas.width || height !== canvas.height || parent.height !== canvas.height;
    if (canvas.clientWidth && canvas.clientHeight && dimsChanged) {
      canvas.width = width;
      canvas.height = height;
      this.setSize(width, height);
    }
  }
  if (!parent.width || !parent.height) {
    return false;
  }
  this._renderFrame();
  this.flushFramebuffer();
  if (view.clearBeforeCopy) {
    context.clearRect(0, 0, parent.width, parent.height);
  }
  context.drawImage(parent, 0, 0);
  if (previewCamera && scene) {
    scene.activeCamera = previewCamera;
  }
  _onAfterViewRenderObservable.notifyObservers(view);
  return true;
};
Engine.prototype._renderViews = function() {
  if (!this.views || this.views.length === 0) {
    return false;
  }
  const parent = this.getRenderingCanvas();
  if (!parent) {
    return false;
  }
  let inputElementView;
  for (const view of this.views) {
    if (!view.enabled) {
      continue;
    }
    const canvas = view.target;
    if (canvas === this.inputElement) {
      inputElementView = view;
      continue;
    }
    if (!this._renderViewStep(view)) {
      return false;
    }
  }
  if (inputElementView) {
    if (!this._renderViewStep(inputElementView)) {
      return false;
    }
  }
  this.activeView = null;
  return true;
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.storageBuffer.js
ThinEngine.prototype.createStorageBuffer = function(data, creationFlags) {
  throw new Error("createStorageBuffer: Unsupported method in this engine!");
};
ThinEngine.prototype.updateStorageBuffer = function(buffer, data, byteOffset, byteLength) {
};
ThinEngine.prototype.readFromStorageBuffer = function(storageBuffer, offset, size, buffer) {
  throw new Error("readFromStorageBuffer: Unsupported method in this engine!");
};
ThinEngine.prototype.setStorageBuffer = function(name137, buffer) {
  throw new Error("setStorageBuffer: Unsupported method in this engine!");
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.textureSelector.js
function transformTextureUrl(url) {
  const excludeFn = (entry) => {
    const strRegExPattern = "\\b" + entry + "\\b";
    return url && (url === entry || url.match(new RegExp(strRegExPattern, "g")));
  };
  if (this._excludedCompressedTextures && this._excludedCompressedTextures.some(excludeFn)) {
    return url;
  }
  const lastDot = url.lastIndexOf(".");
  const lastQuestionMark = url.lastIndexOf("?");
  const querystring = lastQuestionMark > -1 ? url.substring(lastQuestionMark, url.length) : "";
  return (lastDot > -1 ? url.substring(0, lastDot) : url) + this._textureFormatInUse + querystring;
}
Object.defineProperty(Engine.prototype, "texturesSupported", {
  get: function() {
    const texturesSupported = new Array();
    if (this._caps.astc) {
      texturesSupported.push("-astc.ktx");
    }
    if (this._caps.s3tc) {
      texturesSupported.push("-dxt.ktx");
    }
    if (this._caps.pvrtc) {
      texturesSupported.push("-pvrtc.ktx");
    }
    if (this._caps.etc2) {
      texturesSupported.push("-etc2.ktx");
    }
    if (this._caps.etc1) {
      texturesSupported.push("-etc1.ktx");
    }
    return texturesSupported;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(Engine.prototype, "textureFormatInUse", {
  get: function() {
    return this._textureFormatInUse || null;
  },
  enumerable: true,
  configurable: true
});
Engine.prototype.setCompressedTextureExclusions = function(skippedFiles) {
  this._excludedCompressedTextures = skippedFiles;
};
Engine.prototype.setTextureFormatToUse = function(formatsAvailable) {
  const texturesSupported = this.texturesSupported;
  for (let i = 0, len1 = texturesSupported.length; i < len1; i++) {
    for (let j = 0, len2 = formatsAvailable.length; j < len2; j++) {
      if (texturesSupported[i] === formatsAvailable[j].toLowerCase()) {
        this._transformTextureUrl = transformTextureUrl.bind(this);
        return this._textureFormatInUse = texturesSupported[i];
      }
    }
  }
  this._textureFormatInUse = "";
  this._transformTextureUrl = null;
  return null;
};

// node_modules/@babylonjs/core/Engines/Native/nativeDataStream.js
var NativeDataStream = class {
  constructor() {
    const buffer = new ArrayBuffer(NativeDataStream.DEFAULT_BUFFER_SIZE);
    this._uint32s = new Uint32Array(buffer);
    this._int32s = new Int32Array(buffer);
    this._float32s = new Float32Array(buffer);
    this._length = NativeDataStream.DEFAULT_BUFFER_SIZE / 4;
    this._position = 0;
    this._nativeDataStream = new _native.NativeDataStream(() => {
      this._flush();
    });
  }
  writeUint32(value) {
    this._flushIfNecessary(1);
    this._uint32s[this._position++] = value;
  }
  writeInt32(value) {
    this._flushIfNecessary(1);
    this._int32s[this._position++] = value;
  }
  writeFloat32(value) {
    this._flushIfNecessary(1);
    this._float32s[this._position++] = value;
  }
  writeUint32Array(values) {
    this._flushIfNecessary(1 + values.length);
    this._uint32s[this._position++] = values.length;
    this._uint32s.set(values, this._position);
    this._position += values.length;
  }
  writeInt32Array(values) {
    this._flushIfNecessary(1 + values.length);
    this._uint32s[this._position++] = values.length;
    this._int32s.set(values, this._position);
    this._position += values.length;
  }
  writeFloat32Array(values) {
    this._flushIfNecessary(1 + values.length);
    this._uint32s[this._position++] = values.length;
    this._float32s.set(values, this._position);
    this._position += values.length;
  }
  writeNativeData(handle) {
    this._flushIfNecessary(handle.length);
    this._uint32s.set(handle, this._position);
    this._position += handle.length;
  }
  writeBoolean(value) {
    this.writeUint32(value ? 1 : 0);
  }
  _flushIfNecessary(required) {
    if (this._position + required > this._length) {
      this._flush();
    }
  }
  _flush() {
    this._nativeDataStream.writeBuffer(this._uint32s.buffer, this._position);
    this._position = 0;
  }
};
NativeDataStream.DEFAULT_BUFFER_SIZE = 65536;

// node_modules/@babylonjs/core/Misc/codeStringParsingTools.js
function ExtractBetweenMarkers(markerOpen, markerClose, block, startIndex) {
  let currPos = startIndex, openMarkers = 0, waitForChar = "";
  while (currPos < block.length) {
    const currChar = block.charAt(currPos);
    if (!waitForChar) {
      switch (currChar) {
        case markerOpen:
          openMarkers++;
          break;
        case markerClose:
          openMarkers--;
          break;
        case '"':
        case "'":
        case "`":
          waitForChar = currChar;
          break;
        case "/":
          if (currPos + 1 < block.length) {
            const nextChar = block.charAt(currPos + 1);
            if (nextChar === "/") {
              waitForChar = "\n";
            } else if (nextChar === "*") {
              waitForChar = "*/";
            }
          }
          break;
      }
    } else {
      if (currChar === waitForChar) {
        if (waitForChar === '"' || waitForChar === "'") {
          block.charAt(currPos - 1) !== "\\" && (waitForChar = "");
        } else {
          waitForChar = "";
        }
      } else if (waitForChar === "*/" && currChar === "*" && currPos + 1 < block.length) {
        block.charAt(currPos + 1) === "/" && (waitForChar = "");
        if (waitForChar === "") {
          currPos++;
        }
      }
    }
    currPos++;
    if (openMarkers === 0) {
      break;
    }
  }
  return openMarkers === 0 ? currPos - 1 : -1;
}
function SkipWhitespaces(s, index) {
  while (index < s.length) {
    const c = s[index];
    if (c !== " " && c !== "\n" && c !== "\r" && c !== "	" && c !== "\n" && c !== "\xA0") {
      break;
    }
    index++;
  }
  return index;
}
function IsIdentifierChar(c) {
  const v = c.charCodeAt(0);
  return v >= 48 && v <= 57 || v >= 65 && v <= 90 || v >= 97 && v <= 122 || v == 95;
}
function RemoveComments(block) {
  let currPos = 0, waitForChar = "", inComments = false;
  const s = [];
  while (currPos < block.length) {
    const currChar = block.charAt(currPos);
    if (!waitForChar) {
      switch (currChar) {
        case '"':
        case "'":
        case "`":
          waitForChar = currChar;
          break;
        case "/":
          if (currPos + 1 < block.length) {
            const nextChar = block.charAt(currPos + 1);
            if (nextChar === "/") {
              waitForChar = "\n";
              inComments = true;
            } else if (nextChar === "*") {
              waitForChar = "*/";
              inComments = true;
            }
          }
          break;
      }
      if (!inComments) {
        s.push(currChar);
      }
    } else {
      if (currChar === waitForChar) {
        if (waitForChar === '"' || waitForChar === "'") {
          block.charAt(currPos - 1) !== "\\" && (waitForChar = "");
          s.push(currChar);
        } else {
          waitForChar = "";
          inComments = false;
        }
      } else if (waitForChar === "*/" && currChar === "*" && currPos + 1 < block.length) {
        block.charAt(currPos + 1) === "/" && (waitForChar = "");
        if (waitForChar === "") {
          inComments = false;
          currPos++;
        }
      } else {
        if (!inComments) {
          s.push(currChar);
        }
      }
    }
    currPos++;
  }
  return s.join("");
}
function FindBackward(s, index, c) {
  while (index >= 0 && s.charAt(index) !== c) {
    index--;
  }
  return index;
}
function EscapeRegExp(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeInliner.js
var ShaderCodeInliner = class {
  constructor(sourceCode, numMaxIterations = 20) {
    this.debug = false;
    this._sourceCode = sourceCode;
    this._numMaxIterations = numMaxIterations;
    this._functionDescr = [];
    this.inlineToken = "#define inline";
  }
  get code() {
    return this._sourceCode;
  }
  processCode() {
    if (this.debug) {
      console.log(`Start inlining process (code size=${this._sourceCode.length})...`);
    }
    this._collectFunctions();
    this._processInlining(this._numMaxIterations);
    if (this.debug) {
      console.log("End of inlining process.");
    }
  }
  _collectFunctions() {
    let startIndex = 0;
    while (startIndex < this._sourceCode.length) {
      const inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);
      if (inlineTokenIndex < 0) {
        break;
      }
      const funcParamsStartIndex = this._sourceCode.indexOf("(", inlineTokenIndex + this.inlineToken.length);
      if (funcParamsStartIndex < 0) {
        if (this.debug) {
          console.warn(`Could not find the opening parenthesis after the token. startIndex=${startIndex}`);
        }
        startIndex = inlineTokenIndex + this.inlineToken.length;
        continue;
      }
      const funcNameMatch = ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex));
      if (!funcNameMatch) {
        if (this.debug) {
          console.warn(`Could not extract the name/type of the function from: ${this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)}`);
        }
        startIndex = inlineTokenIndex + this.inlineToken.length;
        continue;
      }
      const [funcType, funcName] = [funcNameMatch[3], funcNameMatch[4]];
      const funcParamsEndIndex = ExtractBetweenMarkers("(", ")", this._sourceCode, funcParamsStartIndex);
      if (funcParamsEndIndex < 0) {
        if (this.debug) {
          console.warn(`Could not extract the parameters the function '${funcName}' (type=${funcType}). funcParamsStartIndex=${funcParamsStartIndex}`);
        }
        startIndex = inlineTokenIndex + this.inlineToken.length;
        continue;
      }
      const funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex);
      const funcBodyStartIndex = SkipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);
      if (funcBodyStartIndex === this._sourceCode.length) {
        if (this.debug) {
          console.warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcParamsEndIndex=${funcParamsEndIndex}`);
        }
        startIndex = inlineTokenIndex + this.inlineToken.length;
        continue;
      }
      const funcBodyEndIndex = ExtractBetweenMarkers("{", "}", this._sourceCode, funcBodyStartIndex);
      if (funcBodyEndIndex < 0) {
        if (this.debug) {
          console.warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcBodyStartIndex=${funcBodyStartIndex}`);
        }
        startIndex = inlineTokenIndex + this.inlineToken.length;
        continue;
      }
      const funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1);
      const params = RemoveComments(funcParams).split(",");
      const paramNames = [];
      for (let p = 0; p < params.length; ++p) {
        const param = params[p].trim();
        const idx = param.lastIndexOf(" ");
        if (idx >= 0) {
          paramNames.push(param.substring(idx + 1));
        }
      }
      if (funcType !== "void") {
        paramNames.push("return");
      }
      this._functionDescr.push({
        name: funcName,
        type: funcType,
        parameters: paramNames,
        body: funcBody,
        callIndex: 0
      });
      startIndex = funcBodyEndIndex + 1;
      const partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : "";
      const partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : "";
      this._sourceCode = partBefore + partAfter;
      startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;
    }
    if (this.debug) {
      console.log(`Collect functions: ${this._functionDescr.length} functions found. functionDescr=`, this._functionDescr);
    }
  }
  _processInlining(numMaxIterations = 20) {
    while (numMaxIterations-- >= 0) {
      if (!this._replaceFunctionCallsByCode()) {
        break;
      }
    }
    if (this.debug) {
      console.log(`numMaxIterations is ${numMaxIterations} after inlining process`);
    }
    return numMaxIterations >= 0;
  }
  _replaceFunctionCallsByCode() {
    let doAgain = false;
    for (const func of this._functionDescr) {
      const { name: name137, type, parameters, body } = func;
      let startIndex = 0;
      while (startIndex < this._sourceCode.length) {
        const functionCallIndex = this._sourceCode.indexOf(name137, startIndex);
        if (functionCallIndex < 0) {
          break;
        }
        if (functionCallIndex === 0 || IsIdentifierChar(this._sourceCode.charAt(functionCallIndex - 1))) {
          startIndex = functionCallIndex + name137.length;
          continue;
        }
        const callParamsStartIndex = SkipWhitespaces(this._sourceCode, functionCallIndex + name137.length);
        if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== "(") {
          startIndex = functionCallIndex + name137.length;
          continue;
        }
        const callParamsEndIndex = ExtractBetweenMarkers("(", ")", this._sourceCode, callParamsStartIndex);
        if (callParamsEndIndex < 0) {
          if (this.debug) {
            console.warn(`Could not extract the parameters of the function call. Function '${name137}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}`);
          }
          startIndex = functionCallIndex + name137.length;
          continue;
        }
        const callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex);
        const splitParameterCall = (s) => {
          const parameters2 = [];
          let curIdx = 0, startParamIdx = 0;
          while (curIdx < s.length) {
            if (s.charAt(curIdx) === "(") {
              const idx2 = ExtractBetweenMarkers("(", ")", s, curIdx);
              if (idx2 < 0) {
                return null;
              }
              curIdx = idx2;
            } else if (s.charAt(curIdx) === ",") {
              parameters2.push(s.substring(startParamIdx, curIdx));
              startParamIdx = curIdx + 1;
            }
            curIdx++;
          }
          if (startParamIdx < curIdx) {
            parameters2.push(s.substring(startParamIdx, curIdx));
          }
          return parameters2;
        };
        const params = splitParameterCall(RemoveComments(callParams));
        if (params === null) {
          if (this.debug) {
            console.warn(`Invalid function call: can't extract the parameters of the function call. Function '${name137}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}, callParams=` + callParams);
          }
          startIndex = functionCallIndex + name137.length;
          continue;
        }
        const paramNames = [];
        for (let p = 0; p < params.length; ++p) {
          const param = params[p].trim();
          paramNames.push(param);
        }
        const retParamName = type !== "void" ? name137 + "_" + func.callIndex++ : null;
        if (retParamName) {
          paramNames.push(retParamName + " =");
        }
        if (paramNames.length !== parameters.length) {
          if (this.debug) {
            console.warn(`Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '${name137}' (type=${type}). function parameters=${parameters}, call parameters=${paramNames}`);
          }
          startIndex = functionCallIndex + name137.length;
          continue;
        }
        startIndex = callParamsEndIndex + 1;
        const funcBody = this._replaceNames(body, parameters, paramNames);
        let partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : "";
        const partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : "";
        if (retParamName) {
          const injectDeclarationIndex = FindBackward(this._sourceCode, functionCallIndex - 1, "\n");
          partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);
          const partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);
          this._sourceCode = partBefore + type + " " + retParamName + ";\n" + funcBody + "\n" + partBetween + retParamName + partAfter;
          if (this.debug) {
            console.log(`Replace function call by code. Function '${name137}' (type=${type}). injectDeclarationIndex=${injectDeclarationIndex}, call parameters=${paramNames}`);
          }
        } else {
          this._sourceCode = partBefore + funcBody + partAfter;
          startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);
          if (this.debug) {
            console.log(`Replace function call by code. Function '${name137}' (type=${type}). functionCallIndex=${functionCallIndex}, call parameters=${paramNames}`);
          }
        }
        doAgain = true;
      }
    }
    return doAgain;
  }
  _replaceNames(code, sources, destinations) {
    for (let i = 0; i < sources.length; ++i) {
      const source = new RegExp(EscapeRegExp(sources[i]), "g"), sourceLen = sources[i].length, destination = destinations[i];
      code = code.replace(source, (match, ...args) => {
        const offset = args[0];
        if (IsIdentifierChar(code.charAt(offset - 1)) || IsIdentifierChar(code.charAt(offset + sourceLen))) {
          return sources[i];
        }
        return destination;
      });
    }
    return code;
  }
};
ShaderCodeInliner._RegexpFindFunctionNameAndType = /((\s+?)(\w+)\s+(\w+)\s*?)$/;

// node_modules/@babylonjs/core/Engines/Native/nativePipelineContext.js
var NativePipelineContext = class {
  constructor(engine) {
    this.isAsync = false;
    this.isReady = false;
    this._valueCache = {};
    this._engine = engine;
  }
  _getVertexShaderCode() {
    return null;
  }
  _getFragmentShaderCode() {
    return null;
  }
  _handlesSpectorRebuildCallback(onCompiled) {
    throw new Error("Not implemented");
  }
  _fillEffectInformation(effect, uniformBuffersNames, uniformsNames, uniforms, samplerList, samplers, attributesNames, attributes) {
    const engine = this._engine;
    if (engine.supportsUniformBuffers) {
      for (const name137 in uniformBuffersNames) {
        effect.bindUniformBlock(name137, uniformBuffersNames[name137]);
      }
    }
    const effectAvailableUniforms = this._engine.getUniforms(this, uniformsNames);
    effectAvailableUniforms.forEach((uniform, index2) => {
      uniforms[uniformsNames[index2]] = uniform;
    });
    this._uniforms = uniforms;
    let index;
    for (index = 0; index < samplerList.length; index++) {
      const sampler = effect.getUniform(samplerList[index]);
      if (sampler == null) {
        samplerList.splice(index, 1);
        index--;
      }
    }
    samplerList.forEach((name137, index2) => {
      samplers[name137] = index2;
    });
    attributes.push(...engine.getAttributes(this, attributesNames));
  }
  dispose() {
    this._uniforms = {};
  }
  _cacheMatrix(uniformName, matrix) {
    const cache = this._valueCache[uniformName];
    const flag = matrix.updateFlag;
    if (cache !== void 0 && cache === flag) {
      return false;
    }
    this._valueCache[uniformName] = flag;
    return true;
  }
  _cacheFloat2(uniformName, x, y) {
    let cache = this._valueCache[uniformName];
    if (!cache) {
      cache = [x, y];
      this._valueCache[uniformName] = cache;
      return true;
    }
    let changed = false;
    if (cache[0] !== x) {
      cache[0] = x;
      changed = true;
    }
    if (cache[1] !== y) {
      cache[1] = y;
      changed = true;
    }
    return changed;
  }
  _cacheFloat3(uniformName, x, y, z) {
    let cache = this._valueCache[uniformName];
    if (!cache) {
      cache = [x, y, z];
      this._valueCache[uniformName] = cache;
      return true;
    }
    let changed = false;
    if (cache[0] !== x) {
      cache[0] = x;
      changed = true;
    }
    if (cache[1] !== y) {
      cache[1] = y;
      changed = true;
    }
    if (cache[2] !== z) {
      cache[2] = z;
      changed = true;
    }
    return changed;
  }
  _cacheFloat4(uniformName, x, y, z, w) {
    let cache = this._valueCache[uniformName];
    if (!cache) {
      cache = [x, y, z, w];
      this._valueCache[uniformName] = cache;
      return true;
    }
    let changed = false;
    if (cache[0] !== x) {
      cache[0] = x;
      changed = true;
    }
    if (cache[1] !== y) {
      cache[1] = y;
      changed = true;
    }
    if (cache[2] !== z) {
      cache[2] = z;
      changed = true;
    }
    if (cache[3] !== w) {
      cache[3] = w;
      changed = true;
    }
    return changed;
  }
  setInt(uniformName, value) {
    const cache = this._valueCache[uniformName];
    if (cache !== void 0 && cache === value) {
      return;
    }
    if (this._engine.setInt(this._uniforms[uniformName], value)) {
      this._valueCache[uniformName] = value;
    }
  }
  setInt2(uniformName, x, y) {
    if (this._cacheFloat2(uniformName, x, y)) {
      if (!this._engine.setInt2(this._uniforms[uniformName], x, y)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  setInt3(uniformName, x, y, z) {
    if (this._cacheFloat3(uniformName, x, y, z)) {
      if (!this._engine.setInt3(this._uniforms[uniformName], x, y, z)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  setInt4(uniformName, x, y, z, w) {
    if (this._cacheFloat4(uniformName, x, y, z, w)) {
      if (!this._engine.setInt4(this._uniforms[uniformName], x, y, z, w)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  setIntArray(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setIntArray(this._uniforms[uniformName], array);
  }
  setIntArray2(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setIntArray2(this._uniforms[uniformName], array);
  }
  setIntArray3(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setIntArray3(this._uniforms[uniformName], array);
  }
  setIntArray4(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setIntArray4(this._uniforms[uniformName], array);
  }
  setFloatArray(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setFloatArray(this._uniforms[uniformName], array);
  }
  setFloatArray2(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setFloatArray2(this._uniforms[uniformName], array);
  }
  setFloatArray3(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setFloatArray3(this._uniforms[uniformName], array);
  }
  setFloatArray4(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setFloatArray4(this._uniforms[uniformName], array);
  }
  setArray(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setArray(this._uniforms[uniformName], array);
  }
  setArray2(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setArray2(this._uniforms[uniformName], array);
  }
  setArray3(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setArray3(this._uniforms[uniformName], array);
  }
  setArray4(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setArray4(this._uniforms[uniformName], array);
  }
  setMatrices(uniformName, matrices) {
    if (!matrices) {
      return;
    }
    this._valueCache[uniformName] = null;
    this._engine.setMatrices(this._uniforms[uniformName], matrices);
  }
  setMatrix(uniformName, matrix) {
    if (this._cacheMatrix(uniformName, matrix)) {
      if (!this._engine.setMatrices(this._uniforms[uniformName], matrix.toArray())) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  setMatrix3x3(uniformName, matrix) {
    this._valueCache[uniformName] = null;
    this._engine.setMatrix3x3(this._uniforms[uniformName], matrix);
  }
  setMatrix2x2(uniformName, matrix) {
    this._valueCache[uniformName] = null;
    this._engine.setMatrix2x2(this._uniforms[uniformName], matrix);
  }
  setFloat(uniformName, value) {
    const cache = this._valueCache[uniformName];
    if (cache !== void 0 && cache === value) {
      return;
    }
    if (this._engine.setFloat(this._uniforms[uniformName], value)) {
      this._valueCache[uniformName] = value;
    }
  }
  setBool(uniformName, bool) {
    const cache = this._valueCache[uniformName];
    if (cache !== void 0 && cache === bool) {
      return;
    }
    if (this._engine.setInt(this._uniforms[uniformName], bool ? 1 : 0)) {
      this._valueCache[uniformName] = bool ? 1 : 0;
    }
  }
  setVector2(uniformName, vector2) {
    if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {
      if (!this._engine.setFloat2(this._uniforms[uniformName], vector2.x, vector2.y)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  setFloat2(uniformName, x, y) {
    if (this._cacheFloat2(uniformName, x, y)) {
      if (!this._engine.setFloat2(this._uniforms[uniformName], x, y)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  setVector3(uniformName, vector3) {
    if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {
      if (!this._engine.setFloat3(this._uniforms[uniformName], vector3.x, vector3.y, vector3.z)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  setFloat3(uniformName, x, y, z) {
    if (this._cacheFloat3(uniformName, x, y, z)) {
      if (!this._engine.setFloat3(this._uniforms[uniformName], x, y, z)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  setVector4(uniformName, vector4) {
    if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {
      if (!this._engine.setFloat4(this._uniforms[uniformName], vector4.x, vector4.y, vector4.z, vector4.w)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  setQuaternion(uniformName, quaternion) {
    if (this._cacheFloat4(uniformName, quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {
      if (!this._engine.setFloat4(this._uniforms[uniformName], quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  setFloat4(uniformName, x, y, z, w) {
    if (this._cacheFloat4(uniformName, x, y, z, w)) {
      if (!this._engine.setFloat4(this._uniforms[uniformName], x, y, z, w)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  setColor3(uniformName, color3) {
    if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {
      if (!this._engine.setFloat3(this._uniforms[uniformName], color3.r, color3.g, color3.b)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  setColor4(uniformName, color3, alpha) {
    if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {
      if (!this._engine.setFloat4(this._uniforms[uniformName], color3.r, color3.g, color3.b, alpha)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  setDirectColor4(uniformName, color4) {
    if (this._cacheFloat4(uniformName, color4.r, color4.g, color4.b, color4.a)) {
      if (!this._engine.setFloat4(this._uniforms[uniformName], color4.r, color4.g, color4.b, color4.a)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
};

// node_modules/@babylonjs/core/Engines/Native/nativeRenderTargetWrapper.js
var NativeRenderTargetWrapper = class extends RenderTargetWrapper {
  constructor(isMulti, isCube, size, engine) {
    super(isMulti, isCube, size, engine);
    this.__framebuffer = null;
    this.__framebufferDepthStencil = null;
    this._engine = engine;
  }
  get _framebuffer() {
    return this.__framebuffer;
  }
  set _framebuffer(framebuffer) {
    if (this.__framebuffer) {
      this._engine._releaseFramebufferObjects(this.__framebuffer);
    }
    this.__framebuffer = framebuffer;
  }
  get _framebufferDepthStencil() {
    return this.__framebufferDepthStencil;
  }
  set _framebufferDepthStencil(framebufferDepthStencil) {
    if (this.__framebufferDepthStencil) {
      this._engine._releaseFramebufferObjects(this.__framebufferDepthStencil);
    }
    this.__framebufferDepthStencil = framebufferDepthStencil;
  }
  dispose(disposeOnlyFramebuffers = false) {
    this._framebuffer = null;
    this._framebufferDepthStencil = null;
    super.dispose(disposeOnlyFramebuffers);
  }
};

// node_modules/@babylonjs/core/Engines/Native/nativeHardwareTexture.js
var NativeHardwareTexture = class {
  constructor(existingTexture, engine) {
    this._engine = engine;
    this.set(existingTexture);
  }
  get underlyingResource() {
    return this._nativeTexture;
  }
  setUsage() {
  }
  set(hardwareTexture) {
    this._nativeTexture = hardwareTexture;
  }
  reset() {
    this._nativeTexture = null;
  }
  release() {
    if (this._nativeTexture) {
      this._engine.deleteTexture(this._nativeTexture);
    }
    this.reset();
  }
};

// node_modules/@babylonjs/core/Engines/nativeEngine.js
var onNativeObjectInitialized = new Observable();
if (typeof self !== "undefined" && !Object.prototype.hasOwnProperty.call(self, "_native")) {
  let __native;
  Object.defineProperty(self, "_native", {
    get: () => __native,
    set: (value) => {
      __native = value;
      if (__native) {
        onNativeObjectInitialized.notifyObservers(__native);
      }
    }
  });
}
function AcquireNativeObjectAsync() {
  return new Promise((resolve) => {
    if (typeof _native === "undefined") {
      onNativeObjectInitialized.addOnce((nativeObject) => resolve(nativeObject));
    } else {
      resolve(_native);
    }
  });
}
async function RegisterNativeTypeAsync(typeName, constructor) {
  (await AcquireNativeObjectAsync())[typeName] = constructor;
}
var NativeDataBuffer = class extends DataBuffer {
};
var CommandBufferEncoder = class {
  constructor(_engine) {
    this._engine = _engine;
    this._pending = new Array();
    this._isCommandBufferScopeActive = false;
    this._commandStream = NativeEngine._createNativeDataStream();
    this._engine.setCommandDataStream(this._commandStream);
  }
  beginCommandScope() {
    if (this._isCommandBufferScopeActive) {
      throw new Error("Command scope already active.");
    }
    this._isCommandBufferScopeActive = true;
  }
  endCommandScope() {
    if (!this._isCommandBufferScopeActive) {
      throw new Error("Command scope is not active.");
    }
    this._isCommandBufferScopeActive = false;
    this._submit();
  }
  startEncodingCommand(command) {
    this._commandStream.writeNativeData(command);
  }
  encodeCommandArgAsUInt32(commandArg) {
    this._commandStream.writeUint32(commandArg);
  }
  encodeCommandArgAsUInt32s(commandArg) {
    this._commandStream.writeUint32Array(commandArg);
  }
  encodeCommandArgAsInt32(commandArg) {
    this._commandStream.writeInt32(commandArg);
  }
  encodeCommandArgAsInt32s(commandArg) {
    this._commandStream.writeInt32Array(commandArg);
  }
  encodeCommandArgAsFloat32(commandArg) {
    this._commandStream.writeFloat32(commandArg);
  }
  encodeCommandArgAsFloat32s(commandArg) {
    this._commandStream.writeFloat32Array(commandArg);
  }
  encodeCommandArgAsNativeData(commandArg) {
    this._commandStream.writeNativeData(commandArg);
    this._pending.push(commandArg);
  }
  finishEncodingCommand() {
    if (!this._isCommandBufferScopeActive) {
      this._submit();
    }
  }
  _submit() {
    this._engine.submitCommands();
    this._pending.length = 0;
  }
};
var NativeEngine = class extends Engine {
  constructor(options = {}) {
    super(null, false, void 0, options.adaptToDeviceRatio);
    this._engine = new _native.Engine();
    this._camera = _native.Camera ? new _native.Camera() : null;
    this._commandBufferEncoder = new CommandBufferEncoder(this._engine);
    this._boundBuffersVertexArray = null;
    this._currentDepthTest = _native.Engine.DEPTH_TEST_LEQUAL;
    this._stencilTest = false;
    this._stencilMask = 255;
    this._stencilFunc = 519;
    this._stencilFuncRef = 0;
    this._stencilFuncMask = 255;
    this._stencilOpStencilFail = 7680;
    this._stencilOpDepthFail = 7680;
    this._stencilOpStencilDepthPass = 7681;
    this._zOffset = 0;
    this._zOffsetUnits = 0;
    this._depthWrite = true;
    if (_native.Engine.PROTOCOL_VERSION !== NativeEngine.PROTOCOL_VERSION) {
      throw new Error(`Protocol version mismatch: ${_native.Engine.PROTOCOL_VERSION} (Native) !== ${NativeEngine.PROTOCOL_VERSION} (JS)`);
    }
    this._webGLVersion = 2;
    this.disableUniformBuffers = true;
    this._shaderPlatformName = "NATIVE";
    this._caps = {
      maxTexturesImageUnits: 16,
      maxVertexTextureImageUnits: 16,
      maxCombinedTexturesImageUnits: 32,
      maxTextureSize: _native.Engine.CAPS_LIMITS_MAX_TEXTURE_SIZE,
      maxCubemapTextureSize: 512,
      maxRenderTextureSize: 512,
      maxVertexAttribs: 16,
      maxVaryingVectors: 16,
      maxFragmentUniformVectors: 16,
      maxVertexUniformVectors: 16,
      standardDerivatives: true,
      astc: null,
      pvrtc: null,
      etc1: null,
      etc2: null,
      bptc: null,
      maxAnisotropy: 16,
      uintIndices: true,
      fragmentDepthSupported: false,
      highPrecisionShaderSupported: true,
      colorBufferFloat: false,
      textureFloat: true,
      textureFloatLinearFiltering: false,
      textureFloatRender: false,
      textureHalfFloat: false,
      textureHalfFloatLinearFiltering: false,
      textureHalfFloatRender: false,
      textureLOD: true,
      drawBuffersExtension: false,
      depthTextureExtension: false,
      vertexArrayObject: true,
      instancedArrays: true,
      supportOcclusionQuery: false,
      canUseTimestampForTimerQuery: false,
      blendMinMax: false,
      maxMSAASamples: 1,
      canUseGLInstanceID: true,
      canUseGLVertexID: true,
      supportComputeShaders: false,
      supportSRGBBuffers: true,
      supportTransformFeedbacks: false,
      textureMaxLevel: false,
      texture2DArrayMaxLayerCount: _native.Engine.CAPS_LIMITS_MAX_TEXTURE_LAYERS
    };
    this._features = {
      forceBitmapOverHTMLImageElement: false,
      supportRenderAndCopyToLodForFloatTextures: false,
      supportDepthStencilTexture: false,
      supportShadowSamplers: false,
      uniformBufferHardCheckMatrix: false,
      allowTexturePrefiltering: false,
      trackUbosInFrame: false,
      checkUbosContentBeforeUpload: false,
      supportCSM: false,
      basisNeedsPOT: false,
      support3DTextures: false,
      needTypeSuffixInShaderConstants: false,
      supportMSAA: false,
      supportSSAO2: false,
      supportExtendedTextureFormats: false,
      supportSwitchCaseInShader: false,
      supportSyncTextureRead: false,
      needsInvertingBitmap: true,
      useUBOBindingCache: true,
      needShaderCodeInlining: true,
      needToAlwaysBindUniformBuffers: false,
      supportRenderPasses: true,
      supportSpriteInstancing: false,
      _collectUbosUpdatedInFrame: false
    };
    Tools.Log("Babylon Native (v" + Engine.Version + ") launched");
    Tools.LoadScript = function(scriptUrl, onSuccess, onError, scriptId) {
      Tools.LoadFile(scriptUrl, (data) => {
        Function(data).apply(null);
        if (onSuccess) {
          onSuccess();
        }
      }, void 0, void 0, false, (request, exception) => {
        if (onError) {
          onError("LoadScript Error", exception);
        }
      });
    };
    if (typeof URL === "undefined") {
      window.URL = {
        createObjectURL: function() {
        },
        revokeObjectURL: function() {
        }
      };
    }
    if (typeof Blob === "undefined") {
      window.Blob = function(v) {
        return v;
      };
    }
    if (!Array.prototype.flat) {
      Object.defineProperty(Array.prototype, "flat", {
        configurable: true,
        value: function flat() {
          const depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);
          return depth ? Array.prototype.reduce.call(this, function(acc, cur) {
            if (Array.isArray(cur)) {
              acc.push.apply(acc, flat.call(cur, depth - 1));
            } else {
              acc.push(cur);
            }
            return acc;
          }, []) : Array.prototype.slice.call(this);
        },
        writable: true
      });
    }
    const devicePixelRatio = window ? window.devicePixelRatio || 1 : 1;
    this._hardwareScalingLevel = options.adaptToDeviceRatio ? devicePixelRatio : 1;
    this.resize();
    const currentDepthFunction = this.getDepthFunction();
    if (currentDepthFunction) {
      this.setDepthFunction(currentDepthFunction);
    }
    this._shaderProcessor = new WebGL2ShaderProcessor();
    this.onNewSceneAddedObservable.add((scene) => {
      const originalRender = scene.render;
      scene.render = (...args) => {
        this._commandBufferEncoder.beginCommandScope();
        originalRender.apply(scene, args);
        this._commandBufferEncoder.endCommandScope();
      };
    });
  }
  getHardwareScalingLevel() {
    return this._engine.getHardwareScalingLevel();
  }
  setHardwareScalingLevel(level) {
    this._engine.setHardwareScalingLevel(level);
  }
  dispose() {
    super.dispose();
    if (this._boundBuffersVertexArray) {
      this._deleteVertexArray(this._boundBuffersVertexArray);
    }
    this._engine.dispose();
  }
  static _createNativeDataStream() {
    return new NativeDataStream();
  }
  _queueNewFrame(bindedRenderFunction, requester) {
    if (requester.requestAnimationFrame && requester !== window) {
      requester.requestAnimationFrame(bindedRenderFunction);
    } else {
      this._engine.requestAnimationFrame(bindedRenderFunction);
    }
    return 0;
  }
  _bindUnboundFramebuffer(framebuffer) {
    if (this._currentFramebuffer !== framebuffer) {
      if (this._currentFramebuffer) {
        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_UNBINDFRAMEBUFFER);
        this._commandBufferEncoder.encodeCommandArgAsNativeData(this._currentFramebuffer);
        this._commandBufferEncoder.finishEncodingCommand();
      }
      if (framebuffer) {
        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDFRAMEBUFFER);
        this._commandBufferEncoder.encodeCommandArgAsNativeData(framebuffer);
        this._commandBufferEncoder.finishEncodingCommand();
      }
      this._currentFramebuffer = framebuffer;
    }
  }
  getHostDocument() {
    return null;
  }
  clear(color, backBuffer, depth, stencil = false) {
    if (this.useReverseDepthBuffer) {
      throw new Error("reverse depth buffer is not currently implemented");
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_CLEAR);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(backBuffer && color ? 1 : 0);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.r : 0);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.g : 0);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.b : 0);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.a : 1);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(depth ? 1 : 0);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(1);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(stencil ? 1 : 0);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(0);
    this._commandBufferEncoder.finishEncodingCommand();
  }
  createIndexBuffer(indices, updateable) {
    const data = this._normalizeIndexData(indices);
    const buffer = new NativeDataBuffer();
    buffer.references = 1;
    buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;
    if (data.byteLength) {
      buffer.nativeIndexBuffer = this._engine.createIndexBuffer(data.buffer, data.byteOffset, data.byteLength, buffer.is32Bits, updateable !== null && updateable !== void 0 ? updateable : false);
    }
    return buffer;
  }
  createVertexBuffer(vertices, updateable) {
    const data = ArrayBuffer.isView(vertices) ? vertices : new Float32Array(vertices);
    const buffer = new NativeDataBuffer();
    buffer.references = 1;
    if (data.byteLength) {
      buffer.nativeVertexBuffer = this._engine.createVertexBuffer(data.buffer, data.byteOffset, data.byteLength, updateable !== null && updateable !== void 0 ? updateable : false);
    }
    return buffer;
  }
  _recordVertexArrayObject(vertexArray, vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
    if (indexBuffer) {
      this._engine.recordIndexBuffer(vertexArray, indexBuffer.nativeIndexBuffer);
    }
    const attributes = effect.getAttributesNames();
    for (let index = 0; index < attributes.length; index++) {
      const location = effect.getAttributeLocation(index);
      if (location >= 0) {
        const kind = attributes[index];
        let vertexBuffer = null;
        if (overrideVertexBuffers) {
          vertexBuffer = overrideVertexBuffers[kind];
        }
        if (!vertexBuffer) {
          vertexBuffer = vertexBuffers[kind];
        }
        if (vertexBuffer) {
          const buffer = vertexBuffer.getBuffer();
          if (buffer && buffer.nativeVertexBuffer) {
            this._engine.recordVertexBuffer(vertexArray, buffer.nativeVertexBuffer, location, vertexBuffer.byteOffset, vertexBuffer.byteStride, vertexBuffer.getSize(), this._getNativeAttribType(vertexBuffer.type), vertexBuffer.normalized, vertexBuffer.getInstanceDivisor());
          }
        }
      }
    }
  }
  bindBuffers(vertexBuffers, indexBuffer, effect) {
    if (this._boundBuffersVertexArray) {
      this._deleteVertexArray(this._boundBuffersVertexArray);
    }
    this._boundBuffersVertexArray = this._engine.createVertexArray();
    this._recordVertexArrayObject(this._boundBuffersVertexArray, vertexBuffers, indexBuffer, effect);
    this.bindVertexArrayObject(this._boundBuffersVertexArray);
  }
  recordVertexArrayObject(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
    const vertexArray = this._engine.createVertexArray();
    this._recordVertexArrayObject(vertexArray, vertexBuffers, indexBuffer, effect, overrideVertexBuffers);
    return vertexArray;
  }
  _deleteVertexArray(vertexArray) {
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXARRAY);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(vertexArray);
    this._commandBufferEncoder.finishEncodingCommand();
  }
  bindVertexArrayObject(vertexArray) {
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDVERTEXARRAY);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(vertexArray);
    this._commandBufferEncoder.finishEncodingCommand();
  }
  releaseVertexArrayObject(vertexArray) {
    this._deleteVertexArray(vertexArray);
  }
  getAttributes(pipelineContext, attributesNames) {
    const nativePipelineContext = pipelineContext;
    return this._engine.getAttributes(nativePipelineContext.nativeProgram, attributesNames);
  }
  drawElementsType(fillMode, indexStart, indexCount, instancesCount) {
    this._drawCalls.addCount(1, false);
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINDEXED);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(indexStart);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(indexCount);
    this._commandBufferEncoder.finishEncodingCommand();
  }
  drawArraysType(fillMode, verticesStart, verticesCount, instancesCount) {
    this._drawCalls.addCount(1, false);
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAW);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesStart);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesCount);
    this._commandBufferEncoder.finishEncodingCommand();
  }
  createPipelineContext() {
    return new NativePipelineContext(this);
  }
  createMaterialContext() {
    return void 0;
  }
  createDrawContext() {
    return void 0;
  }
  _preparePipelineContext(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, _rawVertexSourceCode, _rawFragmentSourceCode, _rebuildRebind, defines) {
    const nativePipelineContext = pipelineContext;
    if (createAsRaw) {
      nativePipelineContext.nativeProgram = this.createRawShaderProgram();
    } else {
      nativePipelineContext.nativeProgram = this.createShaderProgram(pipelineContext, vertexSourceCode, fragmentSourceCode, defines);
    }
  }
  _isRenderingStateCompiled(pipelineContext) {
    return true;
  }
  _executeWhenRenderingStateIsCompiled(pipelineContext, action) {
    action();
  }
  createRawShaderProgram() {
    throw new Error("Not Supported");
  }
  createShaderProgram(_pipelineContext, vertexCode, fragmentCode, defines) {
    this.onBeforeShaderCompilationObservable.notifyObservers(this);
    const vertexInliner = new ShaderCodeInliner(vertexCode);
    vertexInliner.processCode();
    vertexCode = vertexInliner.code;
    const fragmentInliner = new ShaderCodeInliner(fragmentCode);
    fragmentInliner.processCode();
    fragmentCode = fragmentInliner.code;
    vertexCode = ThinEngine._ConcatenateShader(vertexCode, defines);
    fragmentCode = ThinEngine._ConcatenateShader(fragmentCode, defines);
    const program = this._engine.createProgram(vertexCode, fragmentCode);
    this.onAfterShaderCompilationObservable.notifyObservers(this);
    return program;
  }
  inlineShaderCode(code) {
    const sci = new ShaderCodeInliner(code);
    sci.debug = false;
    sci.processCode();
    return sci.code;
  }
  _setProgram(program) {
    if (this._currentProgram !== program) {
      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETPROGRAM);
      this._commandBufferEncoder.encodeCommandArgAsNativeData(program);
      this._commandBufferEncoder.finishEncodingCommand();
      this._currentProgram = program;
    }
  }
  _deletePipelineContext(pipelineContext) {
    const nativePipelineContext = pipelineContext;
    if (nativePipelineContext && nativePipelineContext.nativeProgram) {
      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEPROGRAM);
      this._commandBufferEncoder.encodeCommandArgAsNativeData(nativePipelineContext.nativeProgram);
      this._commandBufferEncoder.finishEncodingCommand();
    }
  }
  getUniforms(pipelineContext, uniformsNames) {
    const nativePipelineContext = pipelineContext;
    return this._engine.getUniforms(nativePipelineContext.nativeProgram, uniformsNames);
  }
  bindUniformBlock(pipelineContext, blockName, index) {
    throw new Error("Not Implemented");
  }
  bindSamplers(effect) {
    const nativePipelineContext = effect.getPipelineContext();
    this._setProgram(nativePipelineContext.nativeProgram);
    const samplers = effect.getSamplers();
    for (let index = 0; index < samplers.length; index++) {
      const uniform = effect.getUniform(samplers[index]);
      if (uniform) {
        this._boundUniforms[index] = uniform;
      }
    }
    this._currentEffect = null;
  }
  getRenderWidth(useScreen = false) {
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.width;
    }
    return this._engine.getRenderWidth();
  }
  getRenderHeight(useScreen = false) {
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.height;
    }
    return this._engine.getRenderHeight();
  }
  setViewport(viewport, requiredWidth, requiredHeight) {
    this._cachedViewport = viewport;
    this._engine.setViewPort(viewport.x, viewport.y, viewport.width, viewport.height);
  }
  setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {
    var _a, _b;
    this._zOffset = zOffset;
    this._zOffsetUnits = zOffsetUnits;
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTATE);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(culling ? 1 : 0);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(zOffset);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(zOffsetUnits);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(((_b = (_a = this.cullBackFaces) !== null && _a !== void 0 ? _a : cullBackFaces) !== null && _b !== void 0 ? _b : true) ? 1 : 0);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(reverseSide ? 1 : 0);
    this._commandBufferEncoder.finishEncodingCommand();
  }
  getInputElementClientRect() {
    const rect = {
      bottom: this.getRenderHeight(),
      height: this.getRenderHeight(),
      left: 0,
      right: this.getRenderWidth(),
      top: 0,
      width: this.getRenderWidth(),
      x: 0,
      y: 0,
      toJSON: () => {
      }
    };
    return rect;
  }
  setZOffset(value) {
    if (value !== this._zOffset) {
      this._zOffset = value;
      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSET);
      this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer ? -value : value);
      this._commandBufferEncoder.finishEncodingCommand();
    }
  }
  getZOffset() {
    return this._zOffset;
  }
  setZOffsetUnits(value) {
    if (value !== this._zOffsetUnits) {
      this._zOffsetUnits = value;
      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSETUNITS);
      this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer ? -value : value);
      this._commandBufferEncoder.finishEncodingCommand();
    }
  }
  getZOffsetUnits() {
    return this._zOffsetUnits;
  }
  setDepthBuffer(enable) {
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(enable ? this._currentDepthTest : _native.Engine.DEPTH_TEST_ALWAYS);
    this._commandBufferEncoder.finishEncodingCommand();
  }
  getDepthWrite() {
    return this._depthWrite;
  }
  getDepthFunction() {
    switch (this._currentDepthTest) {
      case _native.Engine.DEPTH_TEST_NEVER:
        return 512;
      case _native.Engine.DEPTH_TEST_ALWAYS:
        return 519;
      case _native.Engine.DEPTH_TEST_GREATER:
        return 516;
      case _native.Engine.DEPTH_TEST_GEQUAL:
        return 518;
      case _native.Engine.DEPTH_TEST_NOTEQUAL:
        return 517;
      case _native.Engine.DEPTH_TEST_EQUAL:
        return 514;
      case _native.Engine.DEPTH_TEST_LESS:
        return 513;
      case _native.Engine.DEPTH_TEST_LEQUAL:
        return 515;
    }
    return null;
  }
  setDepthFunction(depthFunc) {
    let nativeDepthFunc = 0;
    switch (depthFunc) {
      case 512:
        nativeDepthFunc = _native.Engine.DEPTH_TEST_NEVER;
        break;
      case 519:
        nativeDepthFunc = _native.Engine.DEPTH_TEST_ALWAYS;
        break;
      case 516:
        nativeDepthFunc = _native.Engine.DEPTH_TEST_GREATER;
        break;
      case 518:
        nativeDepthFunc = _native.Engine.DEPTH_TEST_GEQUAL;
        break;
      case 517:
        nativeDepthFunc = _native.Engine.DEPTH_TEST_NOTEQUAL;
        break;
      case 514:
        nativeDepthFunc = _native.Engine.DEPTH_TEST_EQUAL;
        break;
      case 513:
        nativeDepthFunc = _native.Engine.DEPTH_TEST_LESS;
        break;
      case 515:
        nativeDepthFunc = _native.Engine.DEPTH_TEST_LEQUAL;
        break;
    }
    this._currentDepthTest = nativeDepthFunc;
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(this._currentDepthTest);
    this._commandBufferEncoder.finishEncodingCommand();
  }
  setDepthWrite(enable) {
    this._depthWrite = enable;
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHWRITE);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(enable));
    this._commandBufferEncoder.finishEncodingCommand();
  }
  setColorWrite(enable) {
    this._colorWrite = enable;
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETCOLORWRITE);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(enable));
    this._commandBufferEncoder.finishEncodingCommand();
  }
  getColorWrite() {
    return this._colorWrite;
  }
  applyStencil() {
    this._setStencil(this._stencilMask, this._getStencilOpFail(this._stencilOpStencilFail), this._getStencilDepthFail(this._stencilOpDepthFail), this._getStencilDepthPass(this._stencilOpStencilDepthPass), this._getStencilFunc(this._stencilFunc), this._stencilFuncRef);
  }
  _setStencil(mask, stencilOpFail, depthOpFail, depthOpPass, func, ref) {
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTENCIL);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(mask);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(stencilOpFail);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(depthOpFail);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(depthOpPass);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(func);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(ref);
    this._commandBufferEncoder.finishEncodingCommand();
  }
  setStencilBuffer(enable) {
    this._stencilTest = enable;
    if (enable) {
      this.applyStencil();
    } else {
      this._setStencil(255, _native.Engine.STENCIL_OP_FAIL_S_KEEP, _native.Engine.STENCIL_OP_FAIL_Z_KEEP, _native.Engine.STENCIL_OP_PASS_Z_KEEP, _native.Engine.STENCIL_TEST_ALWAYS, 0);
    }
  }
  getStencilBuffer() {
    return this._stencilTest;
  }
  getStencilOperationPass() {
    return this._stencilOpStencilDepthPass;
  }
  setStencilOperationPass(operation) {
    this._stencilOpStencilDepthPass = operation;
    this.applyStencil();
  }
  setStencilMask(mask) {
    this._stencilMask = mask;
    this.applyStencil();
  }
  setStencilFunction(stencilFunc) {
    this._stencilFunc = stencilFunc;
    this.applyStencil();
  }
  setStencilFunctionReference(reference) {
    this._stencilFuncRef = reference;
    this.applyStencil();
  }
  setStencilFunctionMask(mask) {
    this._stencilFuncMask = mask;
  }
  setStencilOperationFail(operation) {
    this._stencilOpStencilFail = operation;
    this.applyStencil();
  }
  setStencilOperationDepthFail(operation) {
    this._stencilOpDepthFail = operation;
    this.applyStencil();
  }
  getStencilMask() {
    return this._stencilMask;
  }
  getStencilFunction() {
    return this._stencilFunc;
  }
  getStencilFunctionReference() {
    return this._stencilFuncRef;
  }
  getStencilFunctionMask() {
    return this._stencilFuncMask;
  }
  getStencilOperationFail() {
    return this._stencilOpStencilFail;
  }
  getStencilOperationDepthFail() {
    return this._stencilOpDepthFail;
  }
  setAlphaConstants(r, g, b, a) {
    throw new Error("Setting alpha blend constant color not yet implemented.");
  }
  setAlphaMode(mode, noDepthWriteChange = false) {
    if (this._alphaMode === mode) {
      return;
    }
    const nativeMode = this._getNativeAlphaMode(mode);
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETBLENDMODE);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(nativeMode);
    this._commandBufferEncoder.finishEncodingCommand();
    if (!noDepthWriteChange) {
      this.setDepthWrite(mode === 0);
    }
    this._alphaMode = mode;
  }
  getAlphaMode() {
    return this._alphaMode;
  }
  setInt(uniform, int) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINT);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsInt32(int);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setIntArray(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setIntArray2(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY2);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setIntArray3(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY3);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setIntArray4(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY4);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setFloatArray(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setFloatArray2(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY2);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setFloatArray3(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY3);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setFloatArray4(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY4);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setArray(uniform, array) {
    if (!uniform) {
      return false;
    }
    return this.setFloatArray(uniform, new Float32Array(array));
  }
  setArray2(uniform, array) {
    if (!uniform) {
      return false;
    }
    return this.setFloatArray2(uniform, new Float32Array(array));
  }
  setArray3(uniform, array) {
    if (!uniform) {
      return false;
    }
    return this.setFloatArray3(uniform, new Float32Array(array));
  }
  setArray4(uniform, array) {
    if (!uniform) {
      return false;
    }
    return this.setFloatArray4(uniform, new Float32Array(array));
  }
  setMatrices(uniform, matrices) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRICES);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrices);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setMatrix3x3(uniform, matrix) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX3X3);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrix);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setMatrix2x2(uniform, matrix) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX2X2);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrix);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setFloat(uniform, value) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(value);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setFloat2(uniform, x, y) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT2);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(x);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(y);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setFloat3(uniform, x, y, z) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT3);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(x);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(y);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(z);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setFloat4(uniform, x, y, z, w) {
    if (!uniform) {
      return false;
    }
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT4);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(x);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(y);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(z);
    this._commandBufferEncoder.encodeCommandArgAsFloat32(w);
    this._commandBufferEncoder.finishEncodingCommand();
    return true;
  }
  setColor3(uniform, color3) {
    if (!uniform) {
      return false;
    }
    this.setFloat3(uniform, color3.r, color3.g, color3.b);
    return true;
  }
  setColor4(uniform, color3, alpha) {
    if (!uniform) {
      return false;
    }
    this.setFloat4(uniform, color3.r, color3.g, color3.b, alpha);
    return true;
  }
  wipeCaches(bruteForce) {
    if (this.preventCacheWipeBetweenFrames) {
      return;
    }
    this.resetTextureCache();
    this._currentEffect = null;
    if (bruteForce) {
      this._currentProgram = null;
      this._stencilStateComposer.reset();
      this._depthCullingState.reset();
      this._alphaState.reset();
    }
    this._cachedVertexBuffers = null;
    this._cachedIndexBuffer = null;
    this._cachedEffectForVertexBuffers = null;
  }
  _createTexture() {
    return this._engine.createTexture();
  }
  _deleteTexture(texture) {
    if (texture) {
      this._engine.deleteTexture(texture);
    }
  }
  updateDynamicTexture(texture, canvas, invertY, premulAlpha = false, format) {
    if (premulAlpha === void 0) {
      premulAlpha = false;
    }
    if (!!texture && !!texture._hardwareTexture) {
      const source = canvas.getCanvasTexture();
      const destination = texture._hardwareTexture.underlyingResource;
      this._engine.copyTexture(destination, source);
      texture.isReady = true;
    }
  }
  createDynamicTexture(width, height, generateMipMaps, samplingMode) {
    width = Math.max(width, 1);
    height = Math.max(height, 1);
    return this.createRawTexture(new Uint8Array(width * height * 4), width, height, 5, false, false, samplingMode);
  }
  createVideoElement(constraints) {
    if (this._camera) {
      return this._camera.createVideo(constraints);
    }
    return null;
  }
  updateVideoTexture(texture, video, invertY) {
    if (texture && texture._hardwareTexture && this._camera) {
      const webGLTexture = texture._hardwareTexture.underlyingResource;
      this._camera.updateVideoTexture(webGLTexture, video, invertY);
    }
  }
  createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {
    const texture = new InternalTexture(this, InternalTextureSource.Raw);
    texture.format = format;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    texture.invertY = invertY;
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = texture.baseWidth;
    texture.height = texture.baseHeight;
    texture._compression = compression;
    texture.type = type;
    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);
    this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);
    if (texture._hardwareTexture) {
      const webGLTexture = texture._hardwareTexture.underlyingResource;
      const filter = this._getNativeSamplingMode(samplingMode);
      this._setTextureSampling(webGLTexture, filter);
    }
    this._internalTexturesCache.push(texture);
    return texture;
  }
  createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {
    const texture = new InternalTexture(this, InternalTextureSource.Raw2DArray);
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.baseDepth = depth;
    texture.width = width;
    texture.height = height;
    texture.depth = depth;
    texture.format = format;
    texture.type = textureType;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    texture.is2DArray = true;
    if (texture._hardwareTexture) {
      const nativeTexture = texture._hardwareTexture.underlyingResource;
      this._engine.loadRawTexture2DArray(nativeTexture, data, width, height, depth, this._getNativeTextureFormat(format, textureType), generateMipMaps, invertY);
      const filter = this._getNativeSamplingMode(samplingMode);
      this._setTextureSampling(nativeTexture, filter);
    }
    texture.isReady = true;
    this._internalTexturesCache.push(texture);
    return texture;
  }
  updateRawTexture(texture, bufferView, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {
    if (!texture) {
      return;
    }
    if (bufferView && texture._hardwareTexture) {
      const underlyingResource = texture._hardwareTexture.underlyingResource;
      this._engine.loadRawTexture(underlyingResource, bufferView, texture.width, texture.height, this._getNativeTextureFormat(format, type), texture.generateMipMaps, texture.invertY);
    }
    texture.isReady = true;
  }
  createTexture(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, creationFlags, useSRGBBuffer = false) {
    url = url || "";
    const fromData = url.substr(0, 5) === "data:";
    const isBase64 = fromData && url.indexOf(";base64,") !== -1;
    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);
    const originalUrl = url;
    if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {
      url = this._transformTextureUrl(url);
    }
    const lastDot = url.lastIndexOf(".");
    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : "";
    let loader = null;
    for (const availableLoader of Engine._TextureLoaders) {
      if (availableLoader.canLoad(extension)) {
        loader = availableLoader;
        break;
      }
    }
    if (scene) {
      scene.addPendingData(texture);
    }
    texture.url = url;
    texture.generateMipMaps = !noMipmap;
    texture.samplingMode = samplingMode;
    texture.invertY = invertY;
    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, noMipmap);
    if (!this.doNotHandleContextLost) {
      texture._buffer = buffer;
    }
    let onLoadObserver = null;
    if (onLoad && !fallback) {
      onLoadObserver = texture.onLoadedObservable.add(onLoad);
    }
    if (!fallback) {
      this._internalTexturesCache.push(texture);
    }
    const onInternalError = (message, exception) => {
      if (scene) {
        scene.removePendingData(texture);
      }
      if (url === originalUrl) {
        if (onLoadObserver) {
          texture.onLoadedObservable.remove(onLoadObserver);
        }
        if (EngineStore.UseFallbackTexture) {
          this.createTexture(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, buffer, texture);
        }
        if (onError) {
          onError((message || "Unknown error") + (EngineStore.UseFallbackTexture ? " - Fallback texture was used" : ""), exception);
        }
      } else {
        Logger.Warn(`Failed to load ${url}, falling back to ${originalUrl}`);
        this.createTexture(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, buffer, texture, format, forcedExtension, mimeType, loaderOptions);
      }
    };
    if (loader) {
      throw new Error("Loading textures from IInternalTextureLoader not yet implemented.");
    } else {
      const onload = (data) => {
        if (!texture._hardwareTexture) {
          if (scene) {
            scene.removePendingData(texture);
          }
          return;
        }
        const underlyingResource = texture._hardwareTexture.underlyingResource;
        this._engine.loadTexture(underlyingResource, data, !noMipmap, invertY, useSRGBBuffer, () => {
          texture.baseWidth = this._engine.getTextureWidth(underlyingResource);
          texture.baseHeight = this._engine.getTextureHeight(underlyingResource);
          texture.width = texture.baseWidth;
          texture.height = texture.baseHeight;
          texture.isReady = true;
          const filter = this._getNativeSamplingMode(samplingMode);
          this._setTextureSampling(underlyingResource, filter);
          if (scene) {
            scene.removePendingData(texture);
          }
          texture.onLoadedObservable.notifyObservers(texture);
          texture.onLoadedObservable.clear();
        }, () => {
          throw new Error("Could not load a native texture.");
        });
      };
      if (fromData && buffer) {
        if (buffer instanceof ArrayBuffer) {
          onload(new Uint8Array(buffer));
        } else if (ArrayBuffer.isView(buffer)) {
          onload(buffer);
        } else if (typeof buffer === "string") {
          onload(new Uint8Array(Tools.DecodeBase64(buffer)));
        } else {
          throw new Error("Unsupported buffer type");
        }
      } else {
        if (isBase64) {
          onload(new Uint8Array(Tools.DecodeBase64(url)));
        } else {
          this._loadFile(url, (data) => onload(new Uint8Array(data)), void 0, void 0, true, (request, exception) => {
            onInternalError("Unable to load " + (request ? request.responseURL : url, exception));
          });
        }
      }
    }
    return texture;
  }
  wrapNativeTexture(texture) {
    const hardwareTexture = new NativeHardwareTexture(texture, this._engine);
    const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);
    internalTexture._hardwareTexture = hardwareTexture;
    internalTexture.isReady = true;
    return internalTexture;
  }
  wrapWebGLTexture() {
    throw new Error("wrapWebGLTexture is not supported, use wrapNativeTexture instead.");
  }
  _createDepthStencilTexture(size, options, rtWrapper) {
    const nativeRTWrapper = rtWrapper;
    const texture = new InternalTexture(this, InternalTextureSource.DepthStencil);
    const width = size.width || size;
    const height = size.height || size;
    const framebuffer = this._engine.createFrameBuffer(texture._hardwareTexture.underlyingResource, width, height, true, true);
    nativeRTWrapper._framebufferDepthStencil = framebuffer;
    return texture;
  }
  _releaseFramebufferObjects(framebuffer) {
    if (framebuffer) {
      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEFRAMEBUFFER);
      this._commandBufferEncoder.encodeCommandArgAsNativeData(framebuffer);
      this._commandBufferEncoder.finishEncodingCommand();
    }
  }
  _createImageBitmapFromSource(imageSource, options) {
    const promise = new Promise((resolve, reject) => {
      const image = this.createCanvasImage();
      image.onload = () => {
        try {
          const imageBitmap = this._engine.createImageBitmap(image);
          resolve(imageBitmap);
        } catch (error) {
          reject(`Error loading image ${image.src} with exception: ${error}`);
        }
      };
      image.onerror = (error) => {
        reject(`Error loading image ${image.src} with exception: ${error}`);
      };
      image.src = imageSource;
    });
    return promise;
  }
  createImageBitmap(image, options) {
    return new Promise((resolve, reject) => {
      if (Array.isArray(image)) {
        const arr = image;
        if (arr.length) {
          const image2 = this._engine.createImageBitmap(arr[0]);
          if (image2) {
            resolve(image2);
            return;
          }
        }
      }
      reject(`Unsupported data for createImageBitmap.`);
    });
  }
  resizeImageBitmap(image, bufferWidth, bufferHeight) {
    return this._engine.resizeImageBitmap(image, bufferWidth, bufferHeight);
  }
  createCubeTexture(rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, loaderOptions, useSRGBBuffer = false) {
    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);
    texture.isCube = true;
    texture.url = rootUrl;
    texture.generateMipMaps = !noMipmap;
    texture._lodGenerationScale = lodScale;
    texture._lodGenerationOffset = lodOffset;
    if (!this._doNotHandleContextLost) {
      texture._extension = forcedExtension;
      texture._files = files;
    }
    const lastDot = rootUrl.lastIndexOf(".");
    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : "";
    if (extension === ".env") {
      const onloaddata = (data) => {
        const info = GetEnvInfo(data);
        texture.width = info.width;
        texture.height = info.width;
        UploadEnvSpherical(texture, info);
        const specularInfo = info.specular;
        if (!specularInfo) {
          throw new Error(`Nothing else parsed so far`);
        }
        texture._lodGenerationScale = specularInfo.lodGenerationScale;
        const imageData = CreateImageDataArrayBufferViews(data, info);
        texture.format = 5;
        texture.type = 0;
        texture.generateMipMaps = true;
        texture.getEngine().updateTextureSamplingMode(Texture.TRILINEAR_SAMPLINGMODE, texture);
        texture._isRGBD = true;
        texture.invertY = true;
        this._engine.loadCubeTextureWithMips(texture._hardwareTexture.underlyingResource, imageData, false, useSRGBBuffer, () => {
          texture.isReady = true;
          if (onLoad) {
            onLoad();
          }
        }, () => {
          throw new Error("Could not load a native cube texture.");
        });
      };
      if (files && files.length === 6) {
        throw new Error(`Multi-file loading not allowed on env files.`);
      } else {
        const onInternalError = (request, exception) => {
          if (onError && request) {
            onError(request.status + " " + request.statusText, exception);
          }
        };
        this._loadFile(rootUrl, (data) => onloaddata(new Uint8Array(data)), void 0, void 0, true, onInternalError);
      }
    } else {
      if (!files || files.length !== 6) {
        throw new Error("Cannot load cubemap because 6 files were not defined");
      }
      const reorderedFiles = [files[0], files[3], files[1], files[4], files[2], files[5]];
      Promise.all(reorderedFiles.map((file) => Tools.LoadFileAsync(file).then((data) => new Uint8Array(data)))).then((data) => {
        return new Promise((resolve, reject) => {
          this._engine.loadCubeTexture(texture._hardwareTexture.underlyingResource, data, !noMipmap, true, useSRGBBuffer, resolve, reject);
        });
      }).then(() => {
        texture.isReady = true;
        if (onLoad) {
          onLoad();
        }
      }, (error) => {
        if (onError) {
          onError(`Failed to load cubemap: ${error.message}`, error);
        }
      });
    }
    this._internalTexturesCache.push(texture);
    return texture;
  }
  _createHardwareTexture() {
    return new NativeHardwareTexture(this._createTexture(), this._engine);
  }
  _createHardwareRenderTargetWrapper(isMulti, isCube, size) {
    const rtWrapper = new NativeRenderTargetWrapper(isMulti, isCube, size, this);
    this._renderTargetWrapperCache.push(rtWrapper);
    return rtWrapper;
  }
  _createInternalTexture(size, options, _delayGPUTextureCreation = true, source = InternalTextureSource.Unknown) {
    var _a;
    let generateMipMaps = false;
    let type = 0;
    let samplingMode = 3;
    let format = 5;
    let useSRGBBuffer = false;
    let samples = 1;
    if (options !== void 0 && typeof options === "object") {
      generateMipMaps = !!options.generateMipMaps;
      type = options.type === void 0 ? 0 : options.type;
      samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
      format = options.format === void 0 ? 5 : options.format;
      useSRGBBuffer = options.useSRGBBuffer === void 0 ? false : options.useSRGBBuffer;
      samples = (_a = options.samples) !== null && _a !== void 0 ? _a : 1;
    } else {
      generateMipMaps = !!options;
    }
    useSRGBBuffer && (useSRGBBuffer = this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU));
    if (type === 1 && !this._caps.textureFloatLinearFiltering) {
      samplingMode = 1;
    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
      samplingMode = 1;
    }
    if (type === 1 && !this._caps.textureFloat) {
      type = 0;
      Logger.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE");
    }
    const texture = new InternalTexture(this, source);
    const width = size.width || size;
    const height = size.height || size;
    const layers = size.layers || 0;
    if (layers !== 0) {
      throw new Error("Texture layers are not supported in Babylon Native");
    }
    const nativeTexture = texture._hardwareTexture.underlyingResource;
    const nativeTextureFormat = this._getNativeTextureFormat(format, type);
    this._engine.initializeTexture(nativeTexture, width, height, generateMipMaps, nativeTextureFormat, true, useSRGBBuffer);
    this._setTextureSampling(nativeTexture, this._getNativeSamplingMode(samplingMode));
    texture._useSRGBBuffer = useSRGBBuffer;
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.depth = layers;
    texture.isReady = true;
    texture.samples = samples;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    texture.type = type;
    texture.format = format;
    this._internalTexturesCache.push(texture);
    return texture;
  }
  createRenderTargetTexture(size, options) {
    var _a;
    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);
    let generateDepthBuffer = true;
    let generateStencilBuffer = false;
    let noColorAttachment = false;
    let colorAttachment = void 0;
    if (options !== void 0 && typeof options === "object") {
      generateDepthBuffer = (_a = options.generateDepthBuffer) !== null && _a !== void 0 ? _a : true;
      generateStencilBuffer = !!options.generateStencilBuffer;
      noColorAttachment = !!options.noColorAttachment;
      colorAttachment = options.colorAttachment;
    }
    const texture = colorAttachment || (noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget));
    const width = size.width || size;
    const height = size.height || size;
    const framebuffer = this._engine.createFrameBuffer(texture ? texture._hardwareTexture.underlyingResource : null, width, height, generateStencilBuffer, generateDepthBuffer);
    rtWrapper._framebuffer = framebuffer;
    rtWrapper._generateDepthBuffer = generateDepthBuffer;
    rtWrapper._generateStencilBuffer = generateStencilBuffer;
    rtWrapper.setTextures(texture);
    return rtWrapper;
  }
  updateTextureSamplingMode(samplingMode, texture) {
    if (texture._hardwareTexture) {
      const filter = this._getNativeSamplingMode(samplingMode);
      this._setTextureSampling(texture._hardwareTexture.underlyingResource, filter);
    }
    texture.samplingMode = samplingMode;
  }
  bindFramebuffer(texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {
    const nativeRTWrapper = texture;
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    }
    this._currentRenderTarget = texture;
    if (faceIndex) {
      throw new Error("Cuboid frame buffers are not yet supported in NativeEngine.");
    }
    if (requiredWidth || requiredHeight) {
      throw new Error("Required width/height for frame buffers not yet supported in NativeEngine.");
    }
    if (forceFullscreenViewport) {
    }
    if (nativeRTWrapper._framebufferDepthStencil) {
      this._bindUnboundFramebuffer(nativeRTWrapper._framebufferDepthStencil);
    } else {
      this._bindUnboundFramebuffer(nativeRTWrapper._framebuffer);
    }
  }
  unBindFramebuffer(texture, disableGenerateMipMaps = false, onBeforeUnbind) {
    this._currentRenderTarget = null;
    if (onBeforeUnbind) {
      onBeforeUnbind();
    }
    this._bindUnboundFramebuffer(null);
  }
  createDynamicVertexBuffer(data) {
    return this.createVertexBuffer(data, true);
  }
  updateDynamicIndexBuffer(indexBuffer, indices, offset = 0) {
    const buffer = indexBuffer;
    const data = this._normalizeIndexData(indices);
    buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;
    this._engine.updateDynamicIndexBuffer(buffer.nativeIndexBuffer, data.buffer, data.byteOffset, data.byteLength, offset);
  }
  updateDynamicVertexBuffer(vertexBuffer, verticies, byteOffset, byteLength) {
    const buffer = vertexBuffer;
    const data = ArrayBuffer.isView(verticies) ? verticies : new Float32Array(verticies);
    this._engine.updateDynamicVertexBuffer(buffer.nativeVertexBuffer, data.buffer, data.byteOffset + (byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0), byteLength !== null && byteLength !== void 0 ? byteLength : data.byteLength);
  }
  _setTexture(channel, texture, isPartOfTextureArray = false, depthStencilTexture = false) {
    const uniform = this._boundUniforms[channel];
    if (!uniform) {
      return false;
    }
    if (!texture) {
      if (this._boundTexturesCache[channel] != null) {
        this._activeChannel = channel;
        this._boundTexturesCache[channel] = null;
      }
      return false;
    }
    if (texture.video) {
      this._activeChannel = channel;
      texture.update();
    } else if (texture.delayLoadState === 4) {
      texture.delayLoad();
      return false;
    }
    let internalTexture;
    if (depthStencilTexture) {
      internalTexture = texture.depthStencilTexture;
    } else if (texture.isReady()) {
      internalTexture = texture.getInternalTexture();
    } else if (texture.isCube) {
      internalTexture = this.emptyCubeTexture;
    } else if (texture.is3D) {
      internalTexture = this.emptyTexture3D;
    } else if (texture.is2DArray) {
      internalTexture = this.emptyTexture2DArray;
    } else {
      internalTexture = this.emptyTexture;
    }
    this._activeChannel = channel;
    if (!internalTexture || !internalTexture._hardwareTexture) {
      return false;
    }
    this._setTextureWrapMode(internalTexture._hardwareTexture.underlyingResource, this._getAddressMode(texture.wrapU), this._getAddressMode(texture.wrapV), this._getAddressMode(texture.wrapR));
    this._updateAnisotropicLevel(texture);
    this._setTextureCore(uniform, internalTexture._hardwareTexture.underlyingResource);
    return true;
  }
  _setTextureSampling(texture, filter) {
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURESAMPLING);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(texture);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(filter);
    this._commandBufferEncoder.finishEncodingCommand();
  }
  _setTextureWrapMode(texture, addressModeU, addressModeV, addressModeW) {
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREWRAPMODE);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(texture);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeU);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeV);
    this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeW);
    this._commandBufferEncoder.finishEncodingCommand();
  }
  _setTextureCore(uniform, texture) {
    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURE);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);
    this._commandBufferEncoder.encodeCommandArgAsNativeData(texture);
    this._commandBufferEncoder.finishEncodingCommand();
  }
  _updateAnisotropicLevel(texture) {
    const internalTexture = texture.getInternalTexture();
    const value = texture.anisotropicFilteringLevel;
    if (!internalTexture || !internalTexture._hardwareTexture) {
      return;
    }
    if (internalTexture._cachedAnisotropicFilteringLevel !== value) {
      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREANISOTROPICLEVEL);
      this._commandBufferEncoder.encodeCommandArgAsNativeData(internalTexture._hardwareTexture.underlyingResource);
      this._commandBufferEncoder.encodeCommandArgAsUInt32(value);
      this._commandBufferEncoder.finishEncodingCommand();
      internalTexture._cachedAnisotropicFilteringLevel = value;
    }
  }
  _getAddressMode(wrapMode) {
    switch (wrapMode) {
      case 1:
        return _native.Engine.ADDRESS_MODE_WRAP;
      case 0:
        return _native.Engine.ADDRESS_MODE_CLAMP;
      case 2:
        return _native.Engine.ADDRESS_MODE_MIRROR;
      default:
        throw new Error("Unexpected wrap mode: " + wrapMode + ".");
    }
  }
  _bindTexture(channel, texture) {
    const uniform = this._boundUniforms[channel];
    if (!uniform) {
      return;
    }
    if (texture && texture._hardwareTexture) {
      const underlyingResource = texture._hardwareTexture.underlyingResource;
      this._setTextureCore(uniform, underlyingResource);
    }
  }
  _deleteBuffer(buffer) {
    if (buffer.nativeIndexBuffer) {
      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEINDEXBUFFER);
      this._commandBufferEncoder.encodeCommandArgAsNativeData(buffer.nativeIndexBuffer);
      this._commandBufferEncoder.finishEncodingCommand();
      delete buffer.nativeIndexBuffer;
    }
    if (buffer.nativeVertexBuffer) {
      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXBUFFER);
      this._commandBufferEncoder.encodeCommandArgAsNativeData(buffer.nativeVertexBuffer);
      this._commandBufferEncoder.finishEncodingCommand();
      delete buffer.nativeVertexBuffer;
    }
  }
  createCanvas(width, height) {
    if (!_native.Canvas) {
      throw new Error("Native Canvas plugin not available.");
    }
    const canvas = new _native.Canvas();
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }
  createCanvasImage() {
    if (!_native.Canvas) {
      throw new Error("Native Canvas plugin not available.");
    }
    const image = new _native.Image();
    return image;
  }
  updateTextureData(texture, imageData, xOffset, yOffset, width, height, faceIndex = 0, lod = 0, generateMipMaps = false) {
    throw new Error("updateTextureData not implemented.");
  }
  _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, data, faceIndex = 0, lod = 0) {
    throw new Error("_uploadCompressedDataToTextureDirectly not implemented.");
  }
  _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0) {
    throw new Error("_uploadDataToTextureDirectly not implemented.");
  }
  _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {
    throw new Error("_uploadArrayBufferViewToTexture not implemented.");
  }
  _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {
    throw new Error("_uploadArrayBufferViewToTexture not implemented.");
  }
  _getNativeSamplingMode(samplingMode) {
    switch (samplingMode) {
      case 1:
        return _native.Engine.TEXTURE_NEAREST_NEAREST;
      case 2:
        return _native.Engine.TEXTURE_LINEAR_LINEAR;
      case 3:
        return _native.Engine.TEXTURE_LINEAR_LINEAR_MIPLINEAR;
      case 4:
        return _native.Engine.TEXTURE_NEAREST_NEAREST_MIPNEAREST;
      case 5:
        return _native.Engine.TEXTURE_NEAREST_LINEAR_MIPNEAREST;
      case 6:
        return _native.Engine.TEXTURE_NEAREST_LINEAR_MIPLINEAR;
      case 7:
        return _native.Engine.TEXTURE_NEAREST_LINEAR;
      case 8:
        return _native.Engine.TEXTURE_NEAREST_NEAREST_MIPLINEAR;
      case 9:
        return _native.Engine.TEXTURE_LINEAR_NEAREST_MIPNEAREST;
      case 10:
        return _native.Engine.TEXTURE_LINEAR_NEAREST_MIPLINEAR;
      case 11:
        return _native.Engine.TEXTURE_LINEAR_LINEAR_MIPNEAREST;
      case 12:
        return _native.Engine.TEXTURE_LINEAR_NEAREST;
      default:
        throw new Error(`Unsupported sampling mode: ${samplingMode}.`);
    }
  }
  _getStencilFunc(func) {
    switch (func) {
      case 513:
        return _native.Engine.STENCIL_TEST_LESS;
      case 515:
        return _native.Engine.STENCIL_TEST_LEQUAL;
      case 514:
        return _native.Engine.STENCIL_TEST_EQUAL;
      case 518:
        return _native.Engine.STENCIL_TEST_GEQUAL;
      case 516:
        return _native.Engine.STENCIL_TEST_GREATER;
      case 517:
        return _native.Engine.STENCIL_TEST_NOTEQUAL;
      case 512:
        return _native.Engine.STENCIL_TEST_NEVER;
      case 519:
        return _native.Engine.STENCIL_TEST_ALWAYS;
      default:
        throw new Error(`Unsupported stencil func mode: ${func}.`);
    }
  }
  _getStencilOpFail(opFail) {
    switch (opFail) {
      case 7680:
        return _native.Engine.STENCIL_OP_FAIL_S_KEEP;
      case 0:
        return _native.Engine.STENCIL_OP_FAIL_S_ZERO;
      case 7681:
        return _native.Engine.STENCIL_OP_FAIL_S_REPLACE;
      case 7682:
        return _native.Engine.STENCIL_OP_FAIL_S_INCR;
      case 7683:
        return _native.Engine.STENCIL_OP_FAIL_S_DECR;
      case 5386:
        return _native.Engine.STENCIL_OP_FAIL_S_INVERT;
      case 34055:
        return _native.Engine.STENCIL_OP_FAIL_S_INCRSAT;
      case 34056:
        return _native.Engine.STENCIL_OP_FAIL_S_DECRSAT;
      default:
        throw new Error(`Unsupported stencil OpFail mode: ${opFail}.`);
    }
  }
  _getStencilDepthFail(depthFail) {
    switch (depthFail) {
      case 7680:
        return _native.Engine.STENCIL_OP_FAIL_Z_KEEP;
      case 0:
        return _native.Engine.STENCIL_OP_FAIL_Z_ZERO;
      case 7681:
        return _native.Engine.STENCIL_OP_FAIL_Z_REPLACE;
      case 7682:
        return _native.Engine.STENCIL_OP_FAIL_Z_INCR;
      case 7683:
        return _native.Engine.STENCIL_OP_FAIL_Z_DECR;
      case 5386:
        return _native.Engine.STENCIL_OP_FAIL_Z_INVERT;
      case 34055:
        return _native.Engine.STENCIL_OP_FAIL_Z_INCRSAT;
      case 34056:
        return _native.Engine.STENCIL_OP_FAIL_Z_DECRSAT;
      default:
        throw new Error(`Unsupported stencil depthFail mode: ${depthFail}.`);
    }
  }
  _getStencilDepthPass(opPass) {
    switch (opPass) {
      case 7680:
        return _native.Engine.STENCIL_OP_PASS_Z_KEEP;
      case 0:
        return _native.Engine.STENCIL_OP_PASS_Z_ZERO;
      case 7681:
        return _native.Engine.STENCIL_OP_PASS_Z_REPLACE;
      case 7682:
        return _native.Engine.STENCIL_OP_PASS_Z_INCR;
      case 7683:
        return _native.Engine.STENCIL_OP_PASS_Z_DECR;
      case 5386:
        return _native.Engine.STENCIL_OP_PASS_Z_INVERT;
      case 34055:
        return _native.Engine.STENCIL_OP_PASS_Z_INCRSAT;
      case 34056:
        return _native.Engine.STENCIL_OP_PASS_Z_DECRSAT;
      default:
        throw new Error(`Unsupported stencil opPass mode: ${opPass}.`);
    }
  }
  _getNativeTextureFormat(format, type) {
    if (format == 4 && type == 0) {
      return _native.Engine.TEXTURE_FORMAT_RGB8;
    } else if (format == 5 && type == 0) {
      return _native.Engine.TEXTURE_FORMAT_RGBA8;
    } else if (format == 5 && type == 2) {
      return _native.Engine.TEXTURE_FORMAT_RGBA16F;
    } else if (format == 5 && type == 1) {
      return _native.Engine.TEXTURE_FORMAT_RGBA32F;
    } else {
      throw new RuntimeError(`Unsupported texture format or type: format ${format}, type ${type}.`, ErrorCodes.UnsupportedTextureError);
    }
  }
  _getNativeAlphaMode(mode) {
    switch (mode) {
      case 0:
        return _native.Engine.ALPHA_DISABLE;
      case 1:
        return _native.Engine.ALPHA_ADD;
      case 2:
        return _native.Engine.ALPHA_COMBINE;
      case 3:
        return _native.Engine.ALPHA_SUBTRACT;
      case 4:
        return _native.Engine.ALPHA_MULTIPLY;
      case 5:
        return _native.Engine.ALPHA_MAXIMIZED;
      case 6:
        return _native.Engine.ALPHA_ONEONE;
      case 7:
        return _native.Engine.ALPHA_PREMULTIPLIED;
      case 8:
        return _native.Engine.ALPHA_PREMULTIPLIED_PORTERDUFF;
      case 9:
        return _native.Engine.ALPHA_INTERPOLATE;
      case 10:
        return _native.Engine.ALPHA_SCREENMODE;
      default:
        throw new Error(`Unsupported alpha mode: ${mode}.`);
    }
  }
  _getNativeAttribType(type) {
    switch (type) {
      case VertexBuffer.BYTE:
        return _native.Engine.ATTRIB_TYPE_INT8;
      case VertexBuffer.UNSIGNED_BYTE:
        return _native.Engine.ATTRIB_TYPE_UINT8;
      case VertexBuffer.SHORT:
        return _native.Engine.ATTRIB_TYPE_INT16;
      case VertexBuffer.UNSIGNED_SHORT:
        return _native.Engine.ATTRIB_TYPE_UINT16;
      case VertexBuffer.FLOAT:
        return _native.Engine.ATTRIB_TYPE_FLOAT;
      default:
        throw new Error(`Unsupported attribute type: ${type}.`);
    }
  }
  getFontOffset(font) {
    const result = { ascent: 0, height: 0, descent: 0 };
    return result;
  }
  _readTexturePixels(texture, width, height, faceIndex, level, buffer, _flushRenderer, _noDataConversion, x, y) {
    var _a, _b, _c, _d;
    if (faceIndex !== void 0 && faceIndex !== -1) {
      throw new Error(`Reading cubemap faces is not supported, but faceIndex is ${faceIndex}.`);
    }
    return this._engine.readTexture((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource, level !== null && level !== void 0 ? level : 0, x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0, width, height, (_b = buffer === null || buffer === void 0 ? void 0 : buffer.buffer) !== null && _b !== void 0 ? _b : null, (_c = buffer === null || buffer === void 0 ? void 0 : buffer.byteOffset) !== null && _c !== void 0 ? _c : 0, (_d = buffer === null || buffer === void 0 ? void 0 : buffer.byteLength) !== null && _d !== void 0 ? _d : 0).then((rawBuffer) => {
      if (!buffer) {
        buffer = new Uint8Array(rawBuffer);
      }
      return buffer;
    });
  }
};
NativeEngine.PROTOCOL_VERSION = 7;

// node_modules/@babylonjs/core/Engines/Native/validatedNativeDataStream.js
NativeEngine._createNativeDataStream = function() {
  if (_native.NativeDataStream.VALIDATION_ENABLED) {
    return new ValidatedNativeDataStream();
  } else {
    return new NativeDataStream();
  }
};
var ValidatedNativeDataStream = class extends NativeDataStream {
  constructor() {
    super();
  }
  writeUint32(value) {
    super.writeUint32(_native.NativeDataStream.VALIDATION_UINT_32);
    super.writeUint32(value);
  }
  writeInt32(value) {
    super.writeUint32(_native.NativeDataStream.VALIDATION_INT_32);
    super.writeInt32(value);
  }
  writeFloat32(value) {
    super.writeUint32(_native.NativeDataStream.VALIDATION_FLOAT_32);
    super.writeFloat32(value);
  }
  writeUint32Array(values) {
    super.writeUint32(_native.NativeDataStream.VALIDATION_UINT_32_ARRAY);
    super.writeUint32Array(values);
  }
  writeInt32Array(values) {
    super.writeUint32(_native.NativeDataStream.VALIDATION_INT_32_ARRAY);
    super.writeInt32Array(values);
  }
  writeFloat32Array(values) {
    super.writeUint32(_native.NativeDataStream.VALIDATION_FLOAT_32_ARRAY);
    super.writeFloat32Array(values);
  }
  writeNativeData(handle) {
    super.writeUint32(_native.NativeDataStream.VALIDATION_NATIVE_DATA);
    super.writeNativeData(handle);
  }
  writeBoolean(value) {
    super.writeUint32(_native.NativeDataStream.VALIDATION_BOOLEAN);
    super.writeBoolean(value);
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuConstants.js
var PredefinedColorSpace;
(function(PredefinedColorSpace2) {
  PredefinedColorSpace2["SRGB"] = "srgb";
})(PredefinedColorSpace || (PredefinedColorSpace = {}));
var PowerPreference;
(function(PowerPreference2) {
  PowerPreference2["LowPower"] = "low-power";
  PowerPreference2["HighPerformance"] = "high-performance";
})(PowerPreference || (PowerPreference = {}));
var FeatureName;
(function(FeatureName2) {
  FeatureName2["DepthClipControl"] = "depth-clip-control";
  FeatureName2["Depth24UnormStencil8"] = "depth24unorm-stencil8";
  FeatureName2["Depth32FloatStencil8"] = "depth32float-stencil8";
  FeatureName2["TextureCompressionBC"] = "texture-compression-bc";
  FeatureName2["TextureCompressionETC2"] = "texture-compression-etc2";
  FeatureName2["TextureCompressionASTC"] = "texture-compression-astc";
  FeatureName2["TimestampQuery"] = "timestamp-query";
  FeatureName2["IndirectFirstInstance"] = "indirect-first-instance";
  FeatureName2["ShaderF16"] = "shader-f16";
  FeatureName2["BGRA8UnormStorage"] = "bgra8unorm-storage";
})(FeatureName || (FeatureName = {}));
var BufferUsage;
(function(BufferUsage2) {
  BufferUsage2[BufferUsage2["MapRead"] = 1] = "MapRead";
  BufferUsage2[BufferUsage2["MapWrite"] = 2] = "MapWrite";
  BufferUsage2[BufferUsage2["CopySrc"] = 4] = "CopySrc";
  BufferUsage2[BufferUsage2["CopyDst"] = 8] = "CopyDst";
  BufferUsage2[BufferUsage2["Index"] = 16] = "Index";
  BufferUsage2[BufferUsage2["Vertex"] = 32] = "Vertex";
  BufferUsage2[BufferUsage2["Uniform"] = 64] = "Uniform";
  BufferUsage2[BufferUsage2["Storage"] = 128] = "Storage";
  BufferUsage2[BufferUsage2["Indirect"] = 256] = "Indirect";
  BufferUsage2[BufferUsage2["QueryResolve"] = 512] = "QueryResolve";
})(BufferUsage || (BufferUsage = {}));
var MapMode;
(function(MapMode2) {
  MapMode2[MapMode2["Read"] = 1] = "Read";
  MapMode2[MapMode2["Write"] = 2] = "Write";
})(MapMode || (MapMode = {}));
var TextureDimension;
(function(TextureDimension2) {
  TextureDimension2["E1d"] = "1d";
  TextureDimension2["E2d"] = "2d";
  TextureDimension2["E3d"] = "3d";
})(TextureDimension || (TextureDimension = {}));
var TextureUsage;
(function(TextureUsage2) {
  TextureUsage2[TextureUsage2["CopySrc"] = 1] = "CopySrc";
  TextureUsage2[TextureUsage2["CopyDst"] = 2] = "CopyDst";
  TextureUsage2[TextureUsage2["TextureBinding"] = 4] = "TextureBinding";
  TextureUsage2[TextureUsage2["StorageBinding"] = 8] = "StorageBinding";
  TextureUsage2[TextureUsage2["RenderAttachment"] = 16] = "RenderAttachment";
})(TextureUsage || (TextureUsage = {}));
var TextureViewDimension;
(function(TextureViewDimension2) {
  TextureViewDimension2["E1d"] = "1d";
  TextureViewDimension2["E2d"] = "2d";
  TextureViewDimension2["E2dArray"] = "2d-array";
  TextureViewDimension2["Cube"] = "cube";
  TextureViewDimension2["CubeArray"] = "cube-array";
  TextureViewDimension2["E3d"] = "3d";
})(TextureViewDimension || (TextureViewDimension = {}));
var TextureAspect;
(function(TextureAspect2) {
  TextureAspect2["All"] = "all";
  TextureAspect2["StencilOnly"] = "stencil-only";
  TextureAspect2["DepthOnly"] = "depth-only";
})(TextureAspect || (TextureAspect = {}));
var TextureFormat;
(function(TextureFormat2) {
  TextureFormat2["R8Unorm"] = "r8unorm";
  TextureFormat2["R8Snorm"] = "r8snorm";
  TextureFormat2["R8Uint"] = "r8uint";
  TextureFormat2["R8Sint"] = "r8sint";
  TextureFormat2["R16Uint"] = "r16uint";
  TextureFormat2["R16Sint"] = "r16sint";
  TextureFormat2["R16Float"] = "r16float";
  TextureFormat2["RG8Unorm"] = "rg8unorm";
  TextureFormat2["RG8Snorm"] = "rg8snorm";
  TextureFormat2["RG8Uint"] = "rg8uint";
  TextureFormat2["RG8Sint"] = "rg8sint";
  TextureFormat2["R32Uint"] = "r32uint";
  TextureFormat2["R32Sint"] = "r32sint";
  TextureFormat2["R32Float"] = "r32float";
  TextureFormat2["RG16Uint"] = "rg16uint";
  TextureFormat2["RG16Sint"] = "rg16sint";
  TextureFormat2["RG16Float"] = "rg16float";
  TextureFormat2["RGBA8Unorm"] = "rgba8unorm";
  TextureFormat2["RGBA8UnormSRGB"] = "rgba8unorm-srgb";
  TextureFormat2["RGBA8Snorm"] = "rgba8snorm";
  TextureFormat2["RGBA8Uint"] = "rgba8uint";
  TextureFormat2["RGBA8Sint"] = "rgba8sint";
  TextureFormat2["BGRA8Unorm"] = "bgra8unorm";
  TextureFormat2["BGRA8UnormSRGB"] = "bgra8unorm-srgb";
  TextureFormat2["RGB9E5UFloat"] = "rgb9e5ufloat";
  TextureFormat2["RGB10A2Unorm"] = "rgb10a2unorm";
  TextureFormat2["RG11B10UFloat"] = "rg11b10ufloat";
  TextureFormat2["RG32Uint"] = "rg32uint";
  TextureFormat2["RG32Sint"] = "rg32sint";
  TextureFormat2["RG32Float"] = "rg32float";
  TextureFormat2["RGBA16Uint"] = "rgba16uint";
  TextureFormat2["RGBA16Sint"] = "rgba16sint";
  TextureFormat2["RGBA16Float"] = "rgba16float";
  TextureFormat2["RGBA32Uint"] = "rgba32uint";
  TextureFormat2["RGBA32Sint"] = "rgba32sint";
  TextureFormat2["RGBA32Float"] = "rgba32float";
  TextureFormat2["Stencil8"] = "stencil8";
  TextureFormat2["Depth16Unorm"] = "depth16unorm";
  TextureFormat2["Depth24Plus"] = "depth24plus";
  TextureFormat2["Depth24PlusStencil8"] = "depth24plus-stencil8";
  TextureFormat2["Depth32Float"] = "depth32float";
  TextureFormat2["BC1RGBAUnorm"] = "bc1-rgba-unorm";
  TextureFormat2["BC1RGBAUnormSRGB"] = "bc1-rgba-unorm-srgb";
  TextureFormat2["BC2RGBAUnorm"] = "bc2-rgba-unorm";
  TextureFormat2["BC2RGBAUnormSRGB"] = "bc2-rgba-unorm-srgb";
  TextureFormat2["BC3RGBAUnorm"] = "bc3-rgba-unorm";
  TextureFormat2["BC3RGBAUnormSRGB"] = "bc3-rgba-unorm-srgb";
  TextureFormat2["BC4RUnorm"] = "bc4-r-unorm";
  TextureFormat2["BC4RSnorm"] = "bc4-r-snorm";
  TextureFormat2["BC5RGUnorm"] = "bc5-rg-unorm";
  TextureFormat2["BC5RGSnorm"] = "bc5-rg-snorm";
  TextureFormat2["BC6HRGBUFloat"] = "bc6h-rgb-ufloat";
  TextureFormat2["BC6HRGBFloat"] = "bc6h-rgb-float";
  TextureFormat2["BC7RGBAUnorm"] = "bc7-rgba-unorm";
  TextureFormat2["BC7RGBAUnormSRGB"] = "bc7-rgba-unorm-srgb";
  TextureFormat2["ETC2RGB8Unorm"] = "etc2-rgb8unorm";
  TextureFormat2["ETC2RGB8UnormSRGB"] = "etc2-rgb8unorm-srgb";
  TextureFormat2["ETC2RGB8A1Unorm"] = "etc2-rgb8a1unorm";
  TextureFormat2["ETC2RGB8A1UnormSRGB"] = "etc2-rgb8a1unorm-srgb";
  TextureFormat2["ETC2RGBA8Unorm"] = "etc2-rgba8unorm";
  TextureFormat2["ETC2RGBA8UnormSRGB"] = "etc2-rgba8unorm-srgb";
  TextureFormat2["EACR11Unorm"] = "eac-r11unorm";
  TextureFormat2["EACR11Snorm"] = "eac-r11snorm";
  TextureFormat2["EACRG11Unorm"] = "eac-rg11unorm";
  TextureFormat2["EACRG11Snorm"] = "eac-rg11snorm";
  TextureFormat2["ASTC4x4Unorm"] = "astc-4x4-unorm";
  TextureFormat2["ASTC4x4UnormSRGB"] = "astc-4x4-unorm-srgb";
  TextureFormat2["ASTC5x4Unorm"] = "astc-5x4-unorm";
  TextureFormat2["ASTC5x4UnormSRGB"] = "astc-5x4-unorm-srgb";
  TextureFormat2["ASTC5x5Unorm"] = "astc-5x5-unorm";
  TextureFormat2["ASTC5x5UnormSRGB"] = "astc-5x5-unorm-srgb";
  TextureFormat2["ASTC6x5Unorm"] = "astc-6x5-unorm";
  TextureFormat2["ASTC6x5UnormSRGB"] = "astc-6x5-unorm-srgb";
  TextureFormat2["ASTC6x6Unorm"] = "astc-6x6-unorm";
  TextureFormat2["ASTC6x6UnormSRGB"] = "astc-6x6-unorm-srgb";
  TextureFormat2["ASTC8x5Unorm"] = "astc-8x5-unorm";
  TextureFormat2["ASTC8x5UnormSRGB"] = "astc-8x5-unorm-srgb";
  TextureFormat2["ASTC8x6Unorm"] = "astc-8x6-unorm";
  TextureFormat2["ASTC8x6UnormSRGB"] = "astc-8x6-unorm-srgb";
  TextureFormat2["ASTC8x8Unorm"] = "astc-8x8-unorm";
  TextureFormat2["ASTC8x8UnormSRGB"] = "astc-8x8-unorm-srgb";
  TextureFormat2["ASTC10x5Unorm"] = "astc-10x5-unorm";
  TextureFormat2["ASTC10x5UnormSRGB"] = "astc-10x5-unorm-srgb";
  TextureFormat2["ASTC10x6Unorm"] = "astc-10x6-unorm";
  TextureFormat2["ASTC10x6UnormSRGB"] = "astc-10x6-unorm-srgb";
  TextureFormat2["ASTC10x8Unorm"] = "astc-10x8-unorm";
  TextureFormat2["ASTC10x8UnormSRGB"] = "astc-10x8-unorm-srgb";
  TextureFormat2["ASTC10x10Unorm"] = "astc-10x10-unorm";
  TextureFormat2["ASTC10x10UnormSRGB"] = "astc-10x10-unorm-srgb";
  TextureFormat2["ASTC12x10Unorm"] = "astc-12x10-unorm";
  TextureFormat2["ASTC12x10UnormSRGB"] = "astc-12x10-unorm-srgb";
  TextureFormat2["ASTC12x12Unorm"] = "astc-12x12-unorm";
  TextureFormat2["ASTC12x12UnormSRGB"] = "astc-12x12-unorm-srgb";
  TextureFormat2["Depth24UnormStencil8"] = "depth24unorm-stencil8";
  TextureFormat2["Depth32FloatStencil8"] = "depth32float-stencil8";
})(TextureFormat || (TextureFormat = {}));
var AddressMode;
(function(AddressMode2) {
  AddressMode2["ClampToEdge"] = "clamp-to-edge";
  AddressMode2["Repeat"] = "repeat";
  AddressMode2["MirrorRepeat"] = "mirror-repeat";
})(AddressMode || (AddressMode = {}));
var FilterMode;
(function(FilterMode2) {
  FilterMode2["Nearest"] = "nearest";
  FilterMode2["Linear"] = "linear";
})(FilterMode || (FilterMode = {}));
var CompareFunction;
(function(CompareFunction2) {
  CompareFunction2["Never"] = "never";
  CompareFunction2["Less"] = "less";
  CompareFunction2["Equal"] = "equal";
  CompareFunction2["LessEqual"] = "less-equal";
  CompareFunction2["Greater"] = "greater";
  CompareFunction2["NotEqual"] = "not-equal";
  CompareFunction2["GreaterEqual"] = "greater-equal";
  CompareFunction2["Always"] = "always";
})(CompareFunction || (CompareFunction = {}));
var ShaderStage;
(function(ShaderStage2) {
  ShaderStage2[ShaderStage2["Vertex"] = 1] = "Vertex";
  ShaderStage2[ShaderStage2["Fragment"] = 2] = "Fragment";
  ShaderStage2[ShaderStage2["Compute"] = 4] = "Compute";
})(ShaderStage || (ShaderStage = {}));
var BufferBindingType;
(function(BufferBindingType2) {
  BufferBindingType2["Uniform"] = "uniform";
  BufferBindingType2["Storage"] = "storage";
  BufferBindingType2["ReadOnlyStorage"] = "read-only-storage";
})(BufferBindingType || (BufferBindingType = {}));
var SamplerBindingType;
(function(SamplerBindingType2) {
  SamplerBindingType2["Filtering"] = "filtering";
  SamplerBindingType2["NonFiltering"] = "non-filtering";
  SamplerBindingType2["Comparison"] = "comparison";
})(SamplerBindingType || (SamplerBindingType = {}));
var TextureSampleType;
(function(TextureSampleType2) {
  TextureSampleType2["Float"] = "float";
  TextureSampleType2["UnfilterableFloat"] = "unfilterable-float";
  TextureSampleType2["Depth"] = "depth";
  TextureSampleType2["Sint"] = "sint";
  TextureSampleType2["Uint"] = "uint";
})(TextureSampleType || (TextureSampleType = {}));
var StorageTextureAccess;
(function(StorageTextureAccess2) {
  StorageTextureAccess2["WriteOnly"] = "write-only";
})(StorageTextureAccess || (StorageTextureAccess = {}));
var CompilationMessageType;
(function(CompilationMessageType2) {
  CompilationMessageType2["Error"] = "error";
  CompilationMessageType2["Warning"] = "warning";
  CompilationMessageType2["Info"] = "info";
})(CompilationMessageType || (CompilationMessageType = {}));
var AutoLayoutMode;
(function(AutoLayoutMode2) {
  AutoLayoutMode2["Auto"] = "auto";
})(AutoLayoutMode || (AutoLayoutMode = {}));
var PrimitiveTopology;
(function(PrimitiveTopology2) {
  PrimitiveTopology2["PointList"] = "point-list";
  PrimitiveTopology2["LineList"] = "line-list";
  PrimitiveTopology2["LineStrip"] = "line-strip";
  PrimitiveTopology2["TriangleList"] = "triangle-list";
  PrimitiveTopology2["TriangleStrip"] = "triangle-strip";
})(PrimitiveTopology || (PrimitiveTopology = {}));
var FrontFace;
(function(FrontFace2) {
  FrontFace2["CCW"] = "ccw";
  FrontFace2["CW"] = "cw";
})(FrontFace || (FrontFace = {}));
var CullMode;
(function(CullMode2) {
  CullMode2["None"] = "none";
  CullMode2["Front"] = "front";
  CullMode2["Back"] = "back";
})(CullMode || (CullMode = {}));
var ColorWriteFlags;
(function(ColorWriteFlags2) {
  ColorWriteFlags2[ColorWriteFlags2["Red"] = 1] = "Red";
  ColorWriteFlags2[ColorWriteFlags2["Green"] = 2] = "Green";
  ColorWriteFlags2[ColorWriteFlags2["Blue"] = 4] = "Blue";
  ColorWriteFlags2[ColorWriteFlags2["Alpha"] = 8] = "Alpha";
  ColorWriteFlags2[ColorWriteFlags2["All"] = 15] = "All";
})(ColorWriteFlags || (ColorWriteFlags = {}));
var BlendFactor;
(function(BlendFactor2) {
  BlendFactor2["Zero"] = "zero";
  BlendFactor2["One"] = "one";
  BlendFactor2["Src"] = "src";
  BlendFactor2["OneMinusSrc"] = "one-minus-src";
  BlendFactor2["SrcAlpha"] = "src-alpha";
  BlendFactor2["OneMinusSrcAlpha"] = "one-minus-src-alpha";
  BlendFactor2["Dst"] = "dst";
  BlendFactor2["OneMinusDst"] = "one-minus-dst";
  BlendFactor2["DstAlpha"] = "dst-alpha";
  BlendFactor2["OneMinusDstAlpha"] = "one-minus-dst-alpha";
  BlendFactor2["SrcAlphaSaturated"] = "src-alpha-saturated";
  BlendFactor2["Constant"] = "constant";
  BlendFactor2["OneMinusConstant"] = "one-minus-constant";
})(BlendFactor || (BlendFactor = {}));
var BlendOperation;
(function(BlendOperation2) {
  BlendOperation2["Add"] = "add";
  BlendOperation2["Subtract"] = "subtract";
  BlendOperation2["ReverseSubtract"] = "reverse-subtract";
  BlendOperation2["Min"] = "min";
  BlendOperation2["Max"] = "max";
})(BlendOperation || (BlendOperation = {}));
var StencilOperation;
(function(StencilOperation2) {
  StencilOperation2["Keep"] = "keep";
  StencilOperation2["Zero"] = "zero";
  StencilOperation2["Replace"] = "replace";
  StencilOperation2["Invert"] = "invert";
  StencilOperation2["IncrementClamp"] = "increment-clamp";
  StencilOperation2["DecrementClamp"] = "decrement-clamp";
  StencilOperation2["IncrementWrap"] = "increment-wrap";
  StencilOperation2["DecrementWrap"] = "decrement-wrap";
})(StencilOperation || (StencilOperation = {}));
var IndexFormat;
(function(IndexFormat2) {
  IndexFormat2["Uint16"] = "uint16";
  IndexFormat2["Uint32"] = "uint32";
})(IndexFormat || (IndexFormat = {}));
var VertexFormat;
(function(VertexFormat2) {
  VertexFormat2["Uint8x2"] = "uint8x2";
  VertexFormat2["Uint8x4"] = "uint8x4";
  VertexFormat2["Sint8x2"] = "sint8x2";
  VertexFormat2["Sint8x4"] = "sint8x4";
  VertexFormat2["Unorm8x2"] = "unorm8x2";
  VertexFormat2["Unorm8x4"] = "unorm8x4";
  VertexFormat2["Snorm8x2"] = "snorm8x2";
  VertexFormat2["Snorm8x4"] = "snorm8x4";
  VertexFormat2["Uint16x2"] = "uint16x2";
  VertexFormat2["Uint16x4"] = "uint16x4";
  VertexFormat2["Sint16x2"] = "sint16x2";
  VertexFormat2["Sint16x4"] = "sint16x4";
  VertexFormat2["Unorm16x2"] = "unorm16x2";
  VertexFormat2["Unorm16x4"] = "unorm16x4";
  VertexFormat2["Snorm16x2"] = "snorm16x2";
  VertexFormat2["Snorm16x4"] = "snorm16x4";
  VertexFormat2["Float16x2"] = "float16x2";
  VertexFormat2["Float16x4"] = "float16x4";
  VertexFormat2["Float32"] = "float32";
  VertexFormat2["Float32x2"] = "float32x2";
  VertexFormat2["Float32x3"] = "float32x3";
  VertexFormat2["Float32x4"] = "float32x4";
  VertexFormat2["Uint32"] = "uint32";
  VertexFormat2["Uint32x2"] = "uint32x2";
  VertexFormat2["Uint32x3"] = "uint32x3";
  VertexFormat2["Uint32x4"] = "uint32x4";
  VertexFormat2["Sint32"] = "sint32";
  VertexFormat2["Sint32x2"] = "sint32x2";
  VertexFormat2["Sint32x3"] = "sint32x3";
  VertexFormat2["Sint32x4"] = "sint32x4";
})(VertexFormat || (VertexFormat = {}));
var InputStepMode;
(function(InputStepMode2) {
  InputStepMode2["Vertex"] = "vertex";
  InputStepMode2["Instance"] = "instance";
})(InputStepMode || (InputStepMode = {}));
var ComputePassTimestampLocation;
(function(ComputePassTimestampLocation2) {
  ComputePassTimestampLocation2["Beginning"] = "beginning";
  ComputePassTimestampLocation2["End"] = "end";
})(ComputePassTimestampLocation || (ComputePassTimestampLocation = {}));
var RenderPassTimestampLocation;
(function(RenderPassTimestampLocation2) {
  RenderPassTimestampLocation2["Beginning"] = "beginning";
  RenderPassTimestampLocation2["End"] = "end";
})(RenderPassTimestampLocation || (RenderPassTimestampLocation = {}));
var LoadOp;
(function(LoadOp2) {
  LoadOp2["Load"] = "load";
  LoadOp2["Clear"] = "clear";
})(LoadOp || (LoadOp = {}));
var StoreOp;
(function(StoreOp2) {
  StoreOp2["Store"] = "store";
  StoreOp2["Discard"] = "discard";
})(StoreOp || (StoreOp = {}));
var QueryType;
(function(QueryType2) {
  QueryType2["Occlusion"] = "occlusion";
  QueryType2["Timestamp"] = "timestamp";
})(QueryType || (QueryType = {}));
var CanvasAlphaMode;
(function(CanvasAlphaMode2) {
  CanvasAlphaMode2["Opaque"] = "opaque";
  CanvasAlphaMode2["Premultiplied"] = "premultiplied";
})(CanvasAlphaMode || (CanvasAlphaMode = {}));
var DeviceLostReason;
(function(DeviceLostReason2) {
  DeviceLostReason2["Destroyed"] = "destroyed";
})(DeviceLostReason || (DeviceLostReason = {}));
var ErrorFilter;
(function(ErrorFilter2) {
  ErrorFilter2["OutOfMemory"] = "out-of-memory";
  ErrorFilter2["Validation"] = "validation";
})(ErrorFilter || (ErrorFilter = {}));

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuShaderProcessor.js
var WebGPUShaderProcessor = class {
  constructor() {
    this.shaderLanguage = ShaderLanguage.GLSL;
  }
  _addUniformToLeftOverUBO(name137, uniformType, preProcessors) {
    let length = 0;
    [name137, uniformType, length] = this._getArraySize(name137, uniformType, preProcessors);
    for (let i = 0; i < this._webgpuProcessingContext.leftOverUniforms.length; i++) {
      if (this._webgpuProcessingContext.leftOverUniforms[i].name === name137) {
        return;
      }
    }
    this._webgpuProcessingContext.leftOverUniforms.push({
      name: name137,
      type: uniformType,
      length
    });
  }
  _buildLeftOverUBO() {
    if (!this._webgpuProcessingContext.leftOverUniforms.length) {
      return "";
    }
    const name137 = WebGPUShaderProcessor.LeftOvertUBOName;
    let availableUBO = this._webgpuProcessingContext.availableBuffers[name137];
    if (!availableUBO) {
      availableUBO = {
        binding: this._webgpuProcessingContext.getNextFreeUBOBinding()
      };
      this._webgpuProcessingContext.availableBuffers[name137] = availableUBO;
      this._addBufferBindingDescription(name137, availableUBO, BufferBindingType.Uniform, true);
      this._addBufferBindingDescription(name137, availableUBO, BufferBindingType.Uniform, false);
    }
    return this._generateLeftOverUBOCode(name137, availableUBO);
  }
  _collectBindingNames() {
    for (let i = 0; i < this._webgpuProcessingContext.bindGroupLayoutEntries.length; i++) {
      const setDefinition = this._webgpuProcessingContext.bindGroupLayoutEntries[i];
      if (setDefinition === void 0) {
        this._webgpuProcessingContext.bindGroupLayoutEntries[i] = [];
        continue;
      }
      for (let j = 0; j < setDefinition.length; j++) {
        const entry = this._webgpuProcessingContext.bindGroupLayoutEntries[i][j];
        const name137 = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].name;
        const nameInArrayOfTexture = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].nameInArrayOfTexture;
        if (entry) {
          if (entry.texture || entry.externalTexture || entry.storageTexture) {
            this._webgpuProcessingContext.textureNames.push(nameInArrayOfTexture);
          } else if (entry.sampler) {
            this._webgpuProcessingContext.samplerNames.push(name137);
          } else if (entry.buffer) {
            this._webgpuProcessingContext.bufferNames.push(name137);
          }
        }
      }
    }
  }
  _preCreateBindGroupEntries() {
    const bindGroupEntries = this._webgpuProcessingContext.bindGroupEntries;
    for (let i = 0; i < this._webgpuProcessingContext.bindGroupLayoutEntries.length; i++) {
      const setDefinition = this._webgpuProcessingContext.bindGroupLayoutEntries[i];
      const entries = [];
      for (let j = 0; j < setDefinition.length; j++) {
        const entry = this._webgpuProcessingContext.bindGroupLayoutEntries[i][j];
        if (entry.sampler || entry.texture || entry.storageTexture || entry.externalTexture) {
          entries.push({
            binding: entry.binding,
            resource: void 0
          });
        } else if (entry.buffer) {
          entries.push({
            binding: entry.binding,
            resource: {
              buffer: void 0,
              offset: 0,
              size: 0
            }
          });
        }
      }
      bindGroupEntries[i] = entries;
    }
  }
  _addTextureBindingDescription(name137, textureInfo, textureIndex, dimension, format, isVertex) {
    let { groupIndex, bindingIndex } = textureInfo.textures[textureIndex];
    if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];
      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];
    }
    if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {
      let len;
      if (dimension === null) {
        len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({
          binding: bindingIndex,
          visibility: 0,
          externalTexture: {}
        });
      } else if (format) {
        len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({
          binding: bindingIndex,
          visibility: 0,
          storageTexture: {
            access: StorageTextureAccess.WriteOnly,
            format,
            viewDimension: dimension
          }
        });
      } else {
        len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({
          binding: bindingIndex,
          visibility: 0,
          texture: {
            sampleType: textureInfo.sampleType,
            viewDimension: dimension,
            multisampled: false
          }
        });
      }
      const textureName = textureInfo.isTextureArray ? name137 + textureIndex : name137;
      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = { name: name137, index: len - 1, nameInArrayOfTexture: textureName };
    }
    bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;
    if (isVertex) {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= ShaderStage.Vertex;
    } else {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= ShaderStage.Fragment;
    }
  }
  _addSamplerBindingDescription(name137, samplerInfo, isVertex) {
    let { groupIndex, bindingIndex } = samplerInfo.binding;
    if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];
      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];
    }
    if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {
      const len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({
        binding: bindingIndex,
        visibility: 0,
        sampler: {
          type: samplerInfo.type
        }
      });
      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = { name: name137, index: len - 1 };
    }
    bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;
    if (isVertex) {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= ShaderStage.Vertex;
    } else {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= ShaderStage.Fragment;
    }
  }
  _addBufferBindingDescription(name137, uniformBufferInfo, bufferType, isVertex) {
    let { groupIndex, bindingIndex } = uniformBufferInfo.binding;
    if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];
      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];
    }
    if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {
      const len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({
        binding: bindingIndex,
        visibility: 0,
        buffer: {
          type: bufferType
        }
      });
      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = { name: name137, index: len - 1 };
    }
    bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;
    if (isVertex) {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= ShaderStage.Vertex;
    } else {
      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= ShaderStage.Fragment;
    }
  }
  _injectStartingAndEndingCode(code, mainFuncDecl, startingCode, endingCode) {
    let idx = code.indexOf(mainFuncDecl);
    if (idx < 0) {
      console.error(`No "main" function found in shader code! Processing aborted.`);
      return code;
    }
    if (startingCode) {
      while (idx++ < code.length && code.charAt(idx) != "{") {
      }
      if (idx < code.length) {
        const part1 = code.substring(0, idx + 1);
        const part2 = code.substring(idx + 1);
        code = part1 + startingCode + part2;
      }
    }
    if (endingCode) {
      const lastClosingCurly = code.lastIndexOf("}");
      code = code.substring(0, lastClosingCurly);
      code += endingCode + "\n}";
    }
    return code;
  }
};
WebGPUShaderProcessor.AutoSamplerSuffix = "Sampler";
WebGPUShaderProcessor.LeftOvertUBOName = "LeftOver";
WebGPUShaderProcessor.InternalsUBOName = "Internals";
WebGPUShaderProcessor.UniformSizes = {
  bool: 1,
  int: 1,
  float: 1,
  vec2: 2,
  ivec2: 2,
  vec3: 3,
  ivec3: 3,
  vec4: 4,
  ivec4: 4,
  mat2: 4,
  mat3: 12,
  mat4: 16,
  i32: 1,
  u32: 1,
  f32: 1,
  mat2x2: 4,
  mat3x3: 12,
  mat4x4: 16
};
WebGPUShaderProcessor._SamplerFunctionByWebGLSamplerType = {
  sampler2D: "sampler2D",
  sampler2DArray: "sampler2DArray",
  sampler2DShadow: "sampler2DShadow",
  sampler2DArrayShadow: "sampler2DArrayShadow",
  samplerCube: "samplerCube",
  sampler3D: "sampler3D"
};
WebGPUShaderProcessor._TextureTypeByWebGLSamplerType = {
  sampler2D: "texture2D",
  sampler2DArray: "texture2DArray",
  sampler2DShadow: "texture2D",
  sampler2DArrayShadow: "texture2DArray",
  samplerCube: "textureCube",
  samplerCubeArray: "textureCubeArray",
  sampler3D: "texture3D"
};
WebGPUShaderProcessor._GpuTextureViewDimensionByWebGPUTextureType = {
  textureCube: TextureViewDimension.Cube,
  textureCubeArray: TextureViewDimension.CubeArray,
  texture2D: TextureViewDimension.E2d,
  texture2DArray: TextureViewDimension.E2dArray,
  texture3D: TextureViewDimension.E3d
};
WebGPUShaderProcessor._SamplerTypeByWebGLSamplerType = {
  sampler2DShadow: "samplerShadow",
  sampler2DArrayShadow: "samplerShadow"
};
WebGPUShaderProcessor._IsComparisonSamplerByWebGPUSamplerType = {
  samplerShadow: true,
  samplerArrayShadow: true,
  sampler: false
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuPipelineContext.js
var WebGPUPipelineContext = class {
  constructor(shaderProcessingContext, engine) {
    this._name = "unnamed";
    this.shaderProcessingContext = shaderProcessingContext;
    this._leftOverUniformsByName = {};
    this.engine = engine;
  }
  get isAsync() {
    return false;
  }
  get isReady() {
    if (this.stages) {
      return true;
    }
    return false;
  }
  _handlesSpectorRebuildCallback() {
  }
  _fillEffectInformation(effect, uniformBuffersNames, uniformsNames, uniforms, samplerList, samplers, attributesNames, attributes) {
    const engine = this.engine;
    effect._fragmentSourceCode = "";
    effect._vertexSourceCode = "";
    const foundSamplers = this.shaderProcessingContext.availableTextures;
    let index;
    for (index = 0; index < samplerList.length; index++) {
      const name137 = samplerList[index];
      const sampler = foundSamplers[samplerList[index]];
      if (sampler == null || sampler == void 0) {
        samplerList.splice(index, 1);
        index--;
      } else {
        samplers[name137] = index;
      }
    }
    for (const attr of engine.getAttributes(this, attributesNames)) {
      attributes.push(attr);
    }
    this.buildUniformLayout();
    const attributeNamesFromEffect = [];
    const attributeLocationsFromEffect = [];
    for (index = 0; index < attributesNames.length; index++) {
      const location = attributes[index];
      if (location >= 0) {
        attributeNamesFromEffect.push(attributesNames[index]);
        attributeLocationsFromEffect.push(location);
      }
    }
    this.shaderProcessingContext.attributeNamesFromEffect = attributeNamesFromEffect;
    this.shaderProcessingContext.attributeLocationsFromEffect = attributeLocationsFromEffect;
  }
  buildUniformLayout() {
    if (!this.shaderProcessingContext.leftOverUniforms.length) {
      return;
    }
    this.uniformBuffer = new UniformBuffer(this.engine, void 0, void 0, "leftOver-" + this._name);
    for (const leftOverUniform of this.shaderProcessingContext.leftOverUniforms) {
      const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, "$1");
      const size = WebGPUShaderProcessor.UniformSizes[type];
      this.uniformBuffer.addUniform(leftOverUniform.name, size, leftOverUniform.length);
      this._leftOverUniformsByName[leftOverUniform.name] = leftOverUniform.type;
    }
    this.uniformBuffer.create();
  }
  dispose() {
    if (this.uniformBuffer) {
      this.uniformBuffer.dispose();
    }
  }
  setInt(uniformName, value) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateInt(uniformName, value);
  }
  setInt2(uniformName, x, y) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateInt2(uniformName, x, y);
  }
  setInt3(uniformName, x, y, z) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateInt3(uniformName, x, y, z);
  }
  setInt4(uniformName, x, y, z, w) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateInt4(uniformName, x, y, z, w);
  }
  setIntArray(uniformName, array) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateIntArray(uniformName, array);
  }
  setIntArray2(uniformName, array) {
    this.setIntArray(uniformName, array);
  }
  setIntArray3(uniformName, array) {
    this.setIntArray(uniformName, array);
  }
  setIntArray4(uniformName, array) {
    this.setIntArray(uniformName, array);
  }
  setArray(uniformName, array) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateArray(uniformName, array);
  }
  setArray2(uniformName, array) {
    this.setArray(uniformName, array);
  }
  setArray3(uniformName, array) {
    this.setArray(uniformName, array);
  }
  setArray4(uniformName, array) {
    this.setArray(uniformName, array);
  }
  setMatrices(uniformName, matrices) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateMatrices(uniformName, matrices);
  }
  setMatrix(uniformName, matrix) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateMatrix(uniformName, matrix);
  }
  setMatrix3x3(uniformName, matrix) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateMatrix3x3(uniformName, matrix);
  }
  setMatrix2x2(uniformName, matrix) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateMatrix2x2(uniformName, matrix);
  }
  setFloat(uniformName, value) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateFloat(uniformName, value);
  }
  setVector2(uniformName, vector2) {
    this.setFloat2(uniformName, vector2.x, vector2.y);
  }
  setFloat2(uniformName, x, y) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateFloat2(uniformName, x, y);
  }
  setVector3(uniformName, vector3) {
    this.setFloat3(uniformName, vector3.x, vector3.y, vector3.z);
  }
  setFloat3(uniformName, x, y, z) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateFloat3(uniformName, x, y, z);
  }
  setVector4(uniformName, vector4) {
    this.setFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w);
  }
  setQuaternion(uniformName, quaternion) {
    this.setFloat4(uniformName, quaternion.x, quaternion.y, quaternion.z, quaternion.w);
  }
  setFloat4(uniformName, x, y, z, w) {
    if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {
      return;
    }
    this.uniformBuffer.updateFloat4(uniformName, x, y, z, w);
  }
  setColor3(uniformName, color3) {
    this.setFloat3(uniformName, color3.r, color3.g, color3.b);
  }
  setColor4(uniformName, color3, alpha) {
    this.setFloat4(uniformName, color3.r, color3.g, color3.b, alpha);
  }
  setDirectColor4(uniformName, color4) {
    this.setFloat4(uniformName, color4.r, color4.g, color4.b, color4.a);
  }
  _getVertexShaderCode() {
    var _a;
    return (_a = this.sources) === null || _a === void 0 ? void 0 : _a.vertex;
  }
  _getFragmentShaderCode() {
    var _a;
    return (_a = this.sources) === null || _a === void 0 ? void 0 : _a.fragment;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuShaderProcessingContext.js
var _maxGroups = 4;
var _maxBindingsPerGroup = 1 << 16;
var _typeToLocationSize = {
  mat2: 2,
  mat3: 3,
  mat4: 4,
  mat2x2: 2,
  mat3x3: 3,
  mat4x4: 4
};
var WebGPUShaderProcessingContext = class {
  constructor(shaderLanguage) {
    this.shaderLanguage = shaderLanguage;
    this._attributeNextLocation = 0;
    this._varyingNextLocation = 0;
    this.freeGroupIndex = 0;
    this.freeBindingIndex = 0;
    this.availableVaryings = {};
    this.availableAttributes = {};
    this.availableBuffers = {};
    this.availableTextures = {};
    this.availableSamplers = {};
    this.orderedAttributes = [];
    this.bindGroupLayoutEntries = [];
    this.bindGroupLayoutEntryInfo = [];
    this.bindGroupEntries = [];
    this.bufferNames = [];
    this.textureNames = [];
    this.samplerNames = [];
    this.leftOverUniforms = [];
    this._findStartingGroupBinding();
  }
  static get KnownUBOs() {
    return WebGPUShaderProcessingContext._SimplifiedKnownBindings ? WebGPUShaderProcessingContext._SimplifiedKnownUBOs : WebGPUShaderProcessingContext._KnownUBOs;
  }
  _findStartingGroupBinding() {
    const knownUBOs = WebGPUShaderProcessingContext.KnownUBOs;
    const groups = [];
    for (const name137 in knownUBOs) {
      const binding = knownUBOs[name137].binding;
      if (binding.groupIndex === -1) {
        continue;
      }
      if (groups[binding.groupIndex] === void 0) {
        groups[binding.groupIndex] = binding.bindingIndex;
      } else {
        groups[binding.groupIndex] = Math.max(groups[binding.groupIndex], binding.bindingIndex);
      }
    }
    this.freeGroupIndex = groups.length - 1;
    if (this.freeGroupIndex === 0) {
      this.freeGroupIndex++;
      this.freeBindingIndex = 0;
    } else {
      this.freeBindingIndex = groups[groups.length - 1] + 1;
    }
  }
  getAttributeNextLocation(dataType, arrayLength = 0) {
    var _a;
    const index = this._attributeNextLocation;
    this._attributeNextLocation += ((_a = _typeToLocationSize[dataType]) !== null && _a !== void 0 ? _a : 1) * (arrayLength || 1);
    return index;
  }
  getVaryingNextLocation(dataType, arrayLength = 0) {
    var _a;
    const index = this._varyingNextLocation;
    this._varyingNextLocation += ((_a = _typeToLocationSize[dataType]) !== null && _a !== void 0 ? _a : 1) * (arrayLength || 1);
    return index;
  }
  getNextFreeUBOBinding() {
    return this._getNextFreeBinding(1);
  }
  _getNextFreeBinding(bindingCount) {
    if (this.freeBindingIndex > _maxBindingsPerGroup - bindingCount) {
      this.freeGroupIndex++;
      this.freeBindingIndex = 0;
    }
    if (this.freeGroupIndex === _maxGroups) {
      throw "Too many textures or UBOs have been declared and it is not supported in WebGPU.";
    }
    const returnValue = {
      groupIndex: this.freeGroupIndex,
      bindingIndex: this.freeBindingIndex
    };
    this.freeBindingIndex += bindingCount;
    return returnValue;
  }
};
WebGPUShaderProcessingContext._SimplifiedKnownBindings = true;
WebGPUShaderProcessingContext._SimplifiedKnownUBOs = {
  Scene: { binding: { groupIndex: 0, bindingIndex: 0 } },
  Light0: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light1: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light2: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light3: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light4: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light5: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light6: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light7: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light8: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light9: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light10: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light11: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light12: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light13: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light14: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light15: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light16: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light17: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light18: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light19: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light20: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light21: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light22: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light23: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light24: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light25: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light26: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light27: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light28: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light29: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light30: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Light31: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Material: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Mesh: { binding: { groupIndex: -1, bindingIndex: -1 } },
  Internals: { binding: { groupIndex: -1, bindingIndex: -1 } }
};
WebGPUShaderProcessingContext._KnownUBOs = {
  Scene: { binding: { groupIndex: 0, bindingIndex: 0 } },
  Light0: { binding: { groupIndex: 1, bindingIndex: 0 } },
  Light1: { binding: { groupIndex: 1, bindingIndex: 1 } },
  Light2: { binding: { groupIndex: 1, bindingIndex: 2 } },
  Light3: { binding: { groupIndex: 1, bindingIndex: 3 } },
  Light4: { binding: { groupIndex: 1, bindingIndex: 4 } },
  Light5: { binding: { groupIndex: 1, bindingIndex: 5 } },
  Light6: { binding: { groupIndex: 1, bindingIndex: 6 } },
  Light7: { binding: { groupIndex: 1, bindingIndex: 7 } },
  Light8: { binding: { groupIndex: 1, bindingIndex: 8 } },
  Light9: { binding: { groupIndex: 1, bindingIndex: 9 } },
  Light10: { binding: { groupIndex: 1, bindingIndex: 10 } },
  Light11: { binding: { groupIndex: 1, bindingIndex: 11 } },
  Light12: { binding: { groupIndex: 1, bindingIndex: 12 } },
  Light13: { binding: { groupIndex: 1, bindingIndex: 13 } },
  Light14: { binding: { groupIndex: 1, bindingIndex: 14 } },
  Light15: { binding: { groupIndex: 1, bindingIndex: 15 } },
  Light16: { binding: { groupIndex: 1, bindingIndex: 16 } },
  Light17: { binding: { groupIndex: 1, bindingIndex: 17 } },
  Light18: { binding: { groupIndex: 1, bindingIndex: 18 } },
  Light19: { binding: { groupIndex: 1, bindingIndex: 19 } },
  Light20: { binding: { groupIndex: 1, bindingIndex: 20 } },
  Light21: { binding: { groupIndex: 1, bindingIndex: 21 } },
  Light22: { binding: { groupIndex: 1, bindingIndex: 22 } },
  Light23: { binding: { groupIndex: 1, bindingIndex: 23 } },
  Light24: { binding: { groupIndex: 1, bindingIndex: 24 } },
  Light25: { binding: { groupIndex: 1, bindingIndex: 25 } },
  Light26: { binding: { groupIndex: 1, bindingIndex: 26 } },
  Light27: { binding: { groupIndex: 1, bindingIndex: 27 } },
  Light28: { binding: { groupIndex: 1, bindingIndex: 28 } },
  Light29: { binding: { groupIndex: 1, bindingIndex: 29 } },
  Light30: { binding: { groupIndex: 1, bindingIndex: 30 } },
  Light31: { binding: { groupIndex: 1, bindingIndex: 31 } },
  Material: { binding: { groupIndex: 2, bindingIndex: 0 } },
  Mesh: { binding: { groupIndex: 2, bindingIndex: 1 } },
  Internals: { binding: { groupIndex: 2, bindingIndex: 2 } }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuShaderProcessorsGLSL.js
var WebGPUShaderProcessorGLSL = class extends WebGPUShaderProcessor {
  constructor() {
    super(...arguments);
    this._missingVaryings = [];
    this._textureArrayProcessing = [];
    this._vertexIsGLES3 = false;
    this._fragmentIsGLES3 = false;
    this.shaderLanguage = ShaderLanguage.GLSL;
    this.parseGLES3 = true;
  }
  _getArraySize(name137, type, preProcessors) {
    let length = 0;
    const startArray = name137.indexOf("[");
    const endArray = name137.indexOf("]");
    if (startArray > 0 && endArray > 0) {
      const lengthInString = name137.substring(startArray + 1, endArray);
      length = +lengthInString;
      if (isNaN(length)) {
        length = +preProcessors[lengthInString.trim()];
      }
      name137 = name137.substr(0, startArray);
    }
    return [name137, type, length];
  }
  initializeShaders(processingContext) {
    this._webgpuProcessingContext = processingContext;
    this._missingVaryings.length = 0;
    this._textureArrayProcessing.length = 0;
    this.attributeKeywordName = void 0;
    this.varyingVertexKeywordName = void 0;
    this.varyingFragmentKeywordName = void 0;
  }
  preProcessShaderCode(code, isFragment) {
    const ubDeclaration = `// Internals UBO\r
uniform ${WebGPUShaderProcessor.InternalsUBOName} {
float yFactor_;
float textureOutputHeight_;
};
`;
    const alreadyInjected = code.indexOf("// Internals UBO") !== -1;
    if (isFragment) {
      this._fragmentIsGLES3 = code.indexOf("#version 3") !== -1;
      if (this._fragmentIsGLES3) {
        this.varyingFragmentKeywordName = "in";
      }
      return alreadyInjected ? code : ubDeclaration + "##INJECTCODE##\n" + code;
    }
    this._vertexIsGLES3 = code.indexOf("#version 3") !== -1;
    if (this._vertexIsGLES3) {
      this.attributeKeywordName = "in";
      this.varyingVertexKeywordName = "out";
    }
    return alreadyInjected ? code : ubDeclaration + code;
  }
  varyingProcessor(varying, isFragment, preProcessors) {
    this._preProcessors = preProcessors;
    const outRegex = /\s*out\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/gm;
    const inRegex = /\s*in\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/gm;
    const varyingRegex = /\s*varying\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/gm;
    const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;
    const match = regex.exec(varying);
    if (match !== null) {
      const varyingType = match[1];
      const name137 = match[2];
      let location;
      if (isFragment) {
        location = this._webgpuProcessingContext.availableVaryings[name137];
        this._missingVaryings[location] = "";
        if (location === void 0) {
          Logger.Warn(`Invalid fragment shader: The varying named "${name137}" is not declared in the vertex shader! This declaration will be ignored.`);
        }
      } else {
        location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name137, varyingType, preProcessors)[2]);
        this._webgpuProcessingContext.availableVaryings[name137] = location;
        this._missingVaryings[location] = `layout(location = ${location}) in ${varyingType} ${name137};`;
      }
      varying = varying.replace(match[0], location === void 0 ? "" : `layout(location = ${location}) ${isFragment ? "in" : "out"} ${varyingType} ${name137};`);
    }
    return varying;
  }
  attributeProcessor(attribute, preProcessors) {
    this._preProcessors = preProcessors;
    const inRegex = /\s*in\s+(\S+)\s+(\S+)\s*;/gm;
    const attribRegex = /\s*attribute\s+(\S+)\s+(\S+)\s*;/gm;
    const regex = this._vertexIsGLES3 ? inRegex : attribRegex;
    const match = regex.exec(attribute);
    if (match !== null) {
      const attributeType = match[1];
      const name137 = match[2];
      const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name137, attributeType, preProcessors)[2]);
      this._webgpuProcessingContext.availableAttributes[name137] = location;
      this._webgpuProcessingContext.orderedAttributes[location] = name137;
      attribute = attribute.replace(match[0], `layout(location = ${location}) in ${attributeType} ${name137};`);
    }
    return attribute;
  }
  uniformProcessor(uniform, isFragment, preProcessors) {
    var _a;
    this._preProcessors = preProcessors;
    const uniformRegex = /\s*uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/gm;
    const match = uniformRegex.exec(uniform);
    if (match !== null) {
      let uniformType = match[1];
      let name137 = match[2];
      if (uniformType.indexOf("sampler") === 0 || uniformType.indexOf("sampler") === 1) {
        let arraySize = 0;
        [name137, uniformType, arraySize] = this._getArraySize(name137, uniformType, preProcessors);
        let textureInfo = this._webgpuProcessingContext.availableTextures[name137];
        if (!textureInfo) {
          textureInfo = {
            autoBindSampler: true,
            isTextureArray: arraySize > 0,
            isStorageTexture: false,
            textures: [],
            sampleType: TextureSampleType.Float
          };
          for (let i = 0; i < (arraySize || 1); ++i) {
            textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());
          }
        }
        const samplerType = (_a = WebGPUShaderProcessor._SamplerTypeByWebGLSamplerType[uniformType]) !== null && _a !== void 0 ? _a : "sampler";
        const isComparisonSampler = !!WebGPUShaderProcessor._IsComparisonSamplerByWebGPUSamplerType[samplerType];
        const samplerBindingType = isComparisonSampler ? SamplerBindingType.Comparison : SamplerBindingType.Filtering;
        const samplerName = name137 + WebGPUShaderProcessor.AutoSamplerSuffix;
        let samplerInfo = this._webgpuProcessingContext.availableSamplers[samplerName];
        if (!samplerInfo) {
          samplerInfo = {
            binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),
            type: samplerBindingType
          };
        }
        const componentType = uniformType.charAt(0) === "u" ? "u" : uniformType.charAt(0) === "i" ? "i" : "";
        if (componentType) {
          uniformType = uniformType.substr(1);
        }
        const sampleType = isComparisonSampler ? TextureSampleType.Depth : componentType === "u" ? TextureSampleType.Uint : componentType === "i" ? TextureSampleType.Sint : TextureSampleType.Float;
        textureInfo.sampleType = sampleType;
        const isTextureArray = arraySize > 0;
        const samplerGroupIndex = samplerInfo.binding.groupIndex;
        const samplerBindingIndex = samplerInfo.binding.bindingIndex;
        const samplerFunction = WebGPUShaderProcessor._SamplerFunctionByWebGLSamplerType[uniformType];
        const textureType = WebGPUShaderProcessor._TextureTypeByWebGLSamplerType[uniformType];
        const textureDimension = WebGPUShaderProcessor._GpuTextureViewDimensionByWebGPUTextureType[textureType];
        if (!isTextureArray) {
          arraySize = 1;
          uniform = `layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${samplerName};
                        layout(set = ${textureInfo.textures[0].groupIndex}, binding = ${textureInfo.textures[0].bindingIndex}) uniform ${textureType} ${name137}Texture;
                        #define ${name137} ${componentType}${samplerFunction}(${name137}Texture, ${samplerName})`;
        } else {
          const layouts = [];
          layouts.push(`layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${samplerName};`);
          uniform = `\r
`;
          for (let i = 0; i < arraySize; ++i) {
            const textureSetIndex = textureInfo.textures[i].groupIndex;
            const textureBindingIndex = textureInfo.textures[i].bindingIndex;
            layouts.push(`layout(set = ${textureSetIndex}, binding = ${textureBindingIndex}) uniform ${textureType} ${name137}Texture${i};`);
            uniform += `${i > 0 ? "\r\n" : ""}#define ${name137}${i} ${componentType}${samplerFunction}(${name137}Texture${i}, ${samplerName})`;
          }
          uniform = layouts.join("\r\n") + uniform;
          this._textureArrayProcessing.push(name137);
        }
        this._webgpuProcessingContext.availableTextures[name137] = textureInfo;
        this._webgpuProcessingContext.availableSamplers[samplerName] = samplerInfo;
        this._addSamplerBindingDescription(samplerName, samplerInfo, !isFragment);
        for (let i = 0; i < arraySize; ++i) {
          this._addTextureBindingDescription(name137, textureInfo, i, textureDimension, null, !isFragment);
        }
      } else {
        this._addUniformToLeftOverUBO(name137, uniformType, preProcessors);
        uniform = "";
      }
    }
    return uniform;
  }
  uniformBufferProcessor(uniformBuffer, isFragment) {
    const uboRegex = /uniform\s+(\w+)/gm;
    const match = uboRegex.exec(uniformBuffer);
    if (match !== null) {
      const name137 = match[1];
      let uniformBufferInfo = this._webgpuProcessingContext.availableBuffers[name137];
      if (!uniformBufferInfo) {
        const knownUBO = WebGPUShaderProcessingContext.KnownUBOs[name137];
        let binding;
        if (knownUBO && knownUBO.binding.groupIndex !== -1) {
          binding = knownUBO.binding;
        } else {
          binding = this._webgpuProcessingContext.getNextFreeUBOBinding();
        }
        uniformBufferInfo = { binding };
        this._webgpuProcessingContext.availableBuffers[name137] = uniformBufferInfo;
      }
      this._addBufferBindingDescription(name137, uniformBufferInfo, BufferBindingType.Uniform, !isFragment);
      uniformBuffer = uniformBuffer.replace("uniform", `layout(set = ${uniformBufferInfo.binding.groupIndex}, binding = ${uniformBufferInfo.binding.bindingIndex}) uniform`);
    }
    return uniformBuffer;
  }
  postProcessor(code, defines, isFragment, processingContext, engine) {
    const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;
    const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;
    code = code.replace(regex, "");
    code = code.replace(/texture2D\s*\(/g, "texture(");
    if (isFragment) {
      const hasFragCoord = code.indexOf("gl_FragCoord") >= 0;
      const fragCoordCode = `
                glFragCoord_ = gl_FragCoord;
                if (yFactor_ == 1.) {
                    glFragCoord_.y = textureOutputHeight_ - glFragCoord_.y;
                }
            `;
      const injectCode = hasFragCoord ? "vec4 glFragCoord_;\n" : "";
      code = code.replace(/texture2DLodEXT\s*\(/g, "textureLod(");
      code = code.replace(/textureCubeLodEXT\s*\(/g, "textureLod(");
      code = code.replace(/textureCube\s*\(/g, "texture(");
      code = code.replace(/gl_FragDepthEXT/g, "gl_FragDepth");
      code = code.replace(/gl_FragColor/g, "glFragColor");
      code = code.replace(/gl_FragData/g, "glFragData");
      code = code.replace(/gl_FragCoord/g, "glFragCoord_");
      if (!this._fragmentIsGLES3) {
        code = code.replace(/void\s+?main\s*\(/g, (hasDrawBuffersExtension ? "" : "layout(location = 0) out vec4 glFragColor;\n") + "void main(");
      } else {
        const match = /^\s*out\s+\S+\s+\S+\s*;/gm.exec(code);
        if (match !== null) {
          code = code.substring(0, match.index) + "layout(location = 0) " + code.substring(match.index);
        }
      }
      code = code.replace(/dFdy/g, "(-yFactor_)*dFdy");
      code = code.replace("##INJECTCODE##", injectCode);
      if (hasFragCoord) {
        code = this._injectStartingAndEndingCode(code, "void main", fragCoordCode);
      }
    } else {
      code = code.replace(/gl_InstanceID/g, "gl_InstanceIndex");
      code = code.replace(/gl_VertexID/g, "gl_VertexIndex");
      const hasMultiviewExtension = defines.indexOf("#define MULTIVIEW") !== -1;
      if (hasMultiviewExtension) {
        return "#extension GL_OVR_multiview2 : require\nlayout (num_views = 2) in;\n" + code;
      }
    }
    if (!isFragment) {
      const lastClosingCurly = code.lastIndexOf("}");
      code = code.substring(0, lastClosingCurly);
      code += "gl_Position.y *= yFactor_;\n";
      if (!engine.isNDCHalfZRange) {
        code += "gl_Position.z = (gl_Position.z + gl_Position.w) / 2.0;\n";
      }
      code += "}";
    }
    return code;
  }
  _applyTextureArrayProcessing(code, name137) {
    const regex = new RegExp(name137 + "\\s*\\[(.+)?\\]", "gm");
    let match = regex.exec(code);
    while (match !== null) {
      const index = match[1];
      let iindex = +index;
      if (this._preProcessors && isNaN(iindex)) {
        iindex = +this._preProcessors[index.trim()];
      }
      code = code.replace(match[0], name137 + iindex);
      match = regex.exec(code);
    }
    return code;
  }
  _generateLeftOverUBOCode(name137, uniformBufferDescription) {
    let ubo = `layout(set = ${uniformBufferDescription.binding.groupIndex}, binding = ${uniformBufferDescription.binding.bindingIndex}) uniform ${name137} {
    `;
    for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {
      if (leftOverUniform.length > 0) {
        ubo += `    ${leftOverUniform.type} ${leftOverUniform.name}[${leftOverUniform.length}];
`;
      } else {
        ubo += `    ${leftOverUniform.type} ${leftOverUniform.name};
`;
      }
    }
    ubo += "};\n\n";
    return ubo;
  }
  finalizeShaders(vertexCode, fragmentCode) {
    for (let i = 0; i < this._textureArrayProcessing.length; ++i) {
      const name137 = this._textureArrayProcessing[i];
      vertexCode = this._applyTextureArrayProcessing(vertexCode, name137);
      fragmentCode = this._applyTextureArrayProcessing(fragmentCode, name137);
    }
    for (let i = 0; i < this._missingVaryings.length; ++i) {
      const decl = this._missingVaryings[i];
      if (decl && decl.length > 0) {
        fragmentCode = decl + "\n" + fragmentCode;
      }
    }
    const leftOverUBO = this._buildLeftOverUBO();
    vertexCode = leftOverUBO + vertexCode;
    fragmentCode = leftOverUBO + fragmentCode;
    this._collectBindingNames();
    this._preCreateBindGroupEntries();
    this._preProcessors = null;
    return { vertexCode, fragmentCode };
  }
};

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bonesDeclaration.js
var name8 = "bonesDeclaration";
var shader8 = `#if NUM_BONE_INFLUENCERS>0
attribute matricesIndices : vec4<f32>;
attribute matricesWeights : vec4<f32>;
#if NUM_BONE_INFLUENCERS>4
attribute matricesIndicesExtra : vec4<f32>;
attribute matricesWeightsExtra : vec4<f32>;
#endif
#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#ifdef BONETEXTURE
var boneSampler : texture_2d<f32>;
uniform boneTextureWidth : f32;
#else
uniform mBones : array<mat4x4,BonesPerMesh>;
#ifdef BONES_VELOCITY_ENABLED
uniform mPreviousBones : array<mat4x4,BonesPerMesh>;
#endif
#endif
#ifdef BONETEXTURE
fn readMatrixFromRawSampler(smp : texture_2d<f32>,index : f32)->mat4x4<f32>
{
let offset=i32(index) *4; 
let m0=textureLoad(smp,vec2<i32>(offset+0,0),0);
let m1=textureLoad(smp,vec2<i32>(offset+1,0),0);
let m2=textureLoad(smp,vec2<i32>(offset+2,0),0);
let m3=textureLoad(smp,vec2<i32>(offset+3,0),0);
return mat4x4<f32>(m0,m1,m2,m3);
}
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStoreWGSL[name8] = shader8;

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bonesVertex.js
var name9 = "bonesVertex";
var shader9 = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#if NUM_BONE_INFLUENCERS>0
var influence : mat4x4<f32>;
#ifdef BONETEXTURE
influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif 
#if NUM_BONE_INFLUENCERS>4
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];
#endif 
#else 
influence=uniforms.mBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence=influence+uniforms.mBones[int(matricesIndices[1])]*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
influence=influence+uniforms.mBones[int(matricesIndices[2])]*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
influence=influence+uniforms.mBones[int(matricesIndices[3])]*matricesWeights[3];
#endif 
#if NUM_BONE_INFLUENCERS>4
influence=influence+uniforms.mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
influence=influence+uniforms.mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
influence=influence+uniforms.mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
influence=influence+uniforms.mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif 
#endif
finalWorld=finalWorld*influence;
#endif
#endif
`;
ShaderStore.IncludesShadersStoreWGSL[name9] = shader9;

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration.js
var name10 = "bakedVertexAnimationDeclaration";
var shader10 = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
uniform bakedVertexAnimationTime: f32;
uniform bakedVertexAnimationTextureSizeInverted: vec2<f32>;
uniform bakedVertexAnimationSettings: vec4<f32>;
var bakedVertexAnimationTexture : texture_2d<f32>;
#ifdef INSTANCES
attribute bakedVertexAnimationSettingsInstanced : vec4<f32>;
#endif
fn readMatrixFromRawSamplerVAT(smp : texture_2d<f32>,index : f32,frame : f32)->mat4x4<f32>
{
let offset=i32(index)*4;
let frameUV=i32(frame);
let m0=textureLoad(smp,vec2<i32>(offset+0,frameUV),0);
let m1=textureLoad(smp,vec2<i32>(offset+1,frameUV),0);
let m2=textureLoad(smp,vec2<i32>(offset+2,frameUV),0);
let m3=textureLoad(smp,vec2<i32>(offset+3,frameUV),0);
return mat4x4<f32>(m0,m1,m2,m3);
}
#endif
`;
ShaderStore.IncludesShadersStoreWGSL[name10] = shader10;

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bakedVertexAnimation.js
var name11 = "bakedVertexAnimation";
var shader11 = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
{
#ifdef INSTANCES
let VATStartFrame: f32=bakedVertexAnimationSettingsInstanced.x;
let VATEndFrame: f32=bakedVertexAnimationSettingsInstanced.y;
let VATOffsetFrame: f32=bakedVertexAnimationSettingsInstanced.z;
let VATSpeed: f32=bakedVertexAnimationSettingsInstanced.w;
#else
let VATStartFrame: f32=uniforms.bakedVertexAnimationSettings.x;
let VATEndFrame: f32=uniforms.bakedVertexAnimationSettings.y;
let VATOffsetFrame: f32=uniforms.bakedVertexAnimationSettings.z;
let VATSpeed: f32=uniforms.bakedVertexAnimationSettings.w;
#endif
let totalFrames: f32=VATEndFrame-VATStartFrame+1.0;
let time: f32=uniforms.bakedVertexAnimationTime*VATSpeed/totalFrames;
let frameCorrection: f32=select(1.0,0.0,time<1.0);
let numOfFrames: f32=totalFrames-frameCorrection;
var VATFrameNum: f32=fract(time)*numOfFrames;
VATFrameNum=(VATFrameNum+VATOffsetFrame) % numOfFrames;
VATFrameNum=floor(VATFrameNum);
VATFrameNum=VATFrameNum+VATStartFrame+frameCorrection;
var VATInfluence : mat4x4<f32>;
VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];
#endif
finalWorld=finalWorld*VATInfluence;
}
#endif
`;
ShaderStore.IncludesShadersStoreWGSL[name11] = shader11;

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneFragment.js
var name12 = "clipPlaneFragment";
var shader12 = `#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
if (false) {}
#endif
#ifdef CLIPPLANE
else if (fClipDistance>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE2
else if (fClipDistance2>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE3
else if (fClipDistance3>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE4
else if (fClipDistance4>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE5
else if (fClipDistance5>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE6
else if (fClipDistance6>0.0)
{
discard;
}
#endif
`;
ShaderStore.IncludesShadersStoreWGSL[name12] = shader12;

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneFragmentDeclaration.js
var name13 = "clipPlaneFragmentDeclaration";
var shader13 = `#ifdef CLIPPLANE
varying fClipDistance: f32;
#endif
#ifdef CLIPPLANE2
varying fClipDistance2: f32;
#endif
#ifdef CLIPPLANE3
varying fClipDistance3: f32;
#endif
#ifdef CLIPPLANE4
varying fClipDistance4: f32;
#endif
#ifdef CLIPPLANE5
varying fClipDistance5: f32;
#endif
#ifdef CLIPPLANE6
varying fClipDistance6: f32;
#endif
`;
ShaderStore.IncludesShadersStoreWGSL[name13] = shader13;

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneVertex.js
var name14 = "clipPlaneVertex";
var shader14 = `#ifdef CLIPPLANE
fClipDistance=dot(worldPos,uniforms.vClipPlane);
#endif
#ifdef CLIPPLANE2
fClipDistance2=dot(worldPos,uniforms.vClipPlane2);
#endif
#ifdef CLIPPLANE3
fClipDistance3=dot(worldPos,uniforms.vClipPlane3);
#endif
#ifdef CLIPPLANE4
fClipDistance4=dot(worldPos,uniforms.vClipPlane4);
#endif
#ifdef CLIPPLANE5
fClipDistance5=dot(worldPos,uniforms.vClipPlane5);
#endif
#ifdef CLIPPLANE6
fClipDistance6=dot(worldPos,uniforms.vClipPlane6);
#endif
`;
ShaderStore.IncludesShadersStoreWGSL[name14] = shader14;

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneVertexDeclaration.js
var name15 = "clipPlaneVertexDeclaration";
var shader15 = `#ifdef CLIPPLANE
uniform vClipPlane: vec4<f32>;
varying fClipDistance: f32;
#endif
#ifdef CLIPPLANE2
uniform vClipPlane2: vec4<f32>;
varying fClipDistance2: f32;
#endif
#ifdef CLIPPLANE3
uniform vClipPlane3: vec4<f32>;
varying fClipDistance3: f32;
#endif
#ifdef CLIPPLANE4
uniform vClipPlane4: vec4<f32>;
varying fClipDistance4: f32;
#endif
#ifdef CLIPPLANE5
uniform vClipPlane5: vec4<f32>;
varying fClipDistance5: f32;
#endif
#ifdef CLIPPLANE6
uniform vClipPlane6: vec4<f32>;
varying fClipDistance6: f32;
#endif
`;
ShaderStore.IncludesShadersStoreWGSL[name15] = shader15;

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/instancesDeclaration.js
var name16 = "instancesDeclaration";
var shader16 = `#ifdef INSTANCES
attribute world0 : vec4<f32>;
attribute world1 : vec4<f32>;
attribute world2 : vec4<f32>;
attribute world3 : vec4<f32>;
#ifdef INSTANCESCOLOR
attribute instanceColor : vec4<f32>;
#endif
#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)
uniform world : mat4x4<f32>;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
attribute previousWorld0 : vec4<f32>;
attribute previousWorld1 : vec4<f32>;
attribute previousWorld2 : vec4<f32>;
attribute previousWorld3 : vec4<f32>;
#ifdef THIN_INSTANCES
uniform previousWorld : mat4x4<f32>;
#endif
#endif
#else
#if !defined(WORLD_UBO)
uniform world : mat4x4<f32>;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
uniform previousWorld : mat4x4<f32>;
#endif
#endif
`;
ShaderStore.IncludesShadersStoreWGSL[name16] = shader16;

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/instancesVertex.js
var name17 = "instancesVertex";
var shader17 = `#ifdef INSTANCES
var finalWorld=mat4x4<f32>(world0,world1,world2,world3);
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
var finalPreviousWorld=mat4x4<f32>(previousWorld0,previousWorld1,previousWorld2,previousWorld3);
#endif
#ifdef THIN_INSTANCES
#if !defined(WORLD_UBO)
finalWorld=uniforms.world*finalWorld;
#else
finalWorld=mesh.world*finalWorld;
#endif
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
finalPreviousWorld=previousWorld*finalPreviousWorld;
#endif
#endif
#else
#if !defined(WORLD_UBO)
var finalWorld=uniforms.world;
#else
var finalWorld=mesh.world;
#endif
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
var finalPreviousWorld=previousWorld;
#endif
#endif
`;
ShaderStore.IncludesShadersStoreWGSL[name17] = shader17;

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/meshUboDeclaration.js
var name18 = "meshUboDeclaration";
var shader18 = `struct Mesh {
world : mat4x4<f32>,
visibility : f32,
};
var<uniform> mesh : Mesh;
#define WORLD_UBO
`;
ShaderStore.IncludesShadersStoreWGSL[name18] = shader18;

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertex.js
var name19 = "morphTargetsVertex";
var shader19 = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE 
vertexID=f32(gl_VertexID)*uniforms.morphTargetTextureInfo.x;
positionUpdated=positionUpdated+(readVector3FromRawSampler({X},vertexID)-position)*uniforms.morphTargetInfluences[{X}];
vertexID=vertexID+1.0;
#ifdef MORPHTARGETS_NORMAL
normalUpdated=normalUpdated+(readVector3FromRawSampler({X},vertexID) -normal)*uniforms.morphTargetInfluences[{X}];
vertexID=vertexID+1.0;
#endif
#ifdef MORPHTARGETS_UV
uvUpdated=uvUpdated+(readVector3FromRawSampler({X},vertexID).xy-uv)*uniforms.morphTargetInfluences[{X}];
vertexID=vertexID+1.0;
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz=tangentUpdated.xyz+(readVector3FromRawSampler({X},vertexID) -tangent.xyz)*uniforms.morphTargetInfluences[{X}];
#endif
#else
positionUpdated=positionUpdated+(position{X}-position)*uniforms.morphTargetInfluences[{X}];
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(normal{X}-normal)*uniforms.morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz=tangentUpdated.xyz+(tangent{X}-tangent.xyz)*uniforms.morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV
uvUpdated=uvUpdated+(uv_{X}-uv)*uniforms.morphTargetInfluences[{X}];
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStoreWGSL[name19] = shader19;

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexDeclaration.js
var name20 = "morphTargetsVertexDeclaration";
var shader20 = `#ifdef MORPHTARGETS
#ifndef MORPHTARGETS_TEXTURE
attribute position{X} : vec3<f32>;
#ifdef MORPHTARGETS_NORMAL
attribute normal{X} : vec3<f32>;
#endif
#ifdef MORPHTARGETS_TANGENT
attribute tangent{X} : vec3<f32>;
#endif
#ifdef MORPHTARGETS_UV
attribute uv_{X} : vec2<f32>;
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStoreWGSL[name20] = shader20;

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexGlobal.js
var name21 = "morphTargetsVertexGlobal";
var shader21 = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
var vertexID : f32;
#endif
#endif
`;
ShaderStore.IncludesShadersStoreWGSL[name21] = shader21;

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexGlobalDeclaration.js
var name22 = "morphTargetsVertexGlobalDeclaration";
var shader22 = `#ifdef MORPHTARGETS
uniform morphTargetInfluences : array<f32,NUM_MORPH_INFLUENCERS>;
#ifdef MORPHTARGETS_TEXTURE 
uniform morphTargetTextureIndices : array<f32,NUM_MORPH_INFLUENCERS>;
uniform morphTargetTextureInfo : vec3<f32>;
var morphTargets : texture_2d_array<f32>;
var morphTargetsSampler : sampler;
fn readVector3FromRawSampler(targetIndex : i32,vertexIndex : f32)->vec3<f32>
{ 
let y=floor(vertexIndex/uniforms.morphTargetTextureInfo.y);
let x=vertexIndex-y*uniforms.morphTargetTextureInfo.y;
let textureUV=vec2<f32>((x+0.5)/uniforms.morphTargetTextureInfo.y,(y+0.5)/uniforms.morphTargetTextureInfo.z);
return textureSampleLevel(morphTargets,morphTargetsSampler,textureUV,i32(uniforms.morphTargetTextureIndices[targetIndex]),0.0).xyz;
}
#endif
#endif
`;
ShaderStore.IncludesShadersStoreWGSL[name22] = shader22;

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/sceneUboDeclaration.js
var name23 = "sceneUboDeclaration";
var shader23 = `struct Scene {
viewProjection : mat4x4<f32>,
#ifdef MULTIVIEW
viewProjectionR : mat4x4<f32>,
#endif 
view : mat4x4<f32>,
projection : mat4x4<f32>,
vEyePosition : vec4<f32>,
};
var<uniform> scene : Scene;
`;
ShaderStore.IncludesShadersStoreWGSL[name23] = shader23;

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuShaderProcessorsWGSL.js
var builtInName_vertex_index = "gl_VertexID";
var builtInName_instance_index = "gl_InstanceID";
var builtInName_position = "gl_Position";
var builtInName_position_frag = "gl_FragCoord";
var builtInName_front_facing = "gl_FrontFacing";
var builtInName_frag_depth = "gl_FragDepth";
var builtInName_FragColor = "gl_FragColor";
var leftOverVarName = "uniforms";
var internalsVarName = "internals";
var gpuTextureViewDimensionByWebGPUTextureFunction = {
  texture_1d: TextureViewDimension.E1d,
  texture_2d: TextureViewDimension.E2d,
  texture_2d_array: TextureViewDimension.E2dArray,
  texture_3d: TextureViewDimension.E3d,
  texture_cube: TextureViewDimension.Cube,
  texture_cube_array: TextureViewDimension.CubeArray,
  texture_multisampled_2d: TextureViewDimension.E2d,
  texture_depth_2d: TextureViewDimension.E2d,
  texture_depth_2d_array: TextureViewDimension.E2dArray,
  texture_depth_cube: TextureViewDimension.Cube,
  texture_depth_cube_array: TextureViewDimension.CubeArray,
  texture_depth_multisampled_2d: TextureViewDimension.E2d,
  texture_storage_1d: TextureViewDimension.E1d,
  texture_storage_2d: TextureViewDimension.E2d,
  texture_storage_2d_array: TextureViewDimension.E2dArray,
  texture_storage_3d: TextureViewDimension.E3d,
  texture_external: null
};
var WebGPUShaderProcessorWGSL = class extends WebGPUShaderProcessor {
  constructor() {
    super(...arguments);
    this.shaderLanguage = ShaderLanguage.WGSL;
    this.uniformRegexp = /uniform\s+(\w+)\s*:\s*(.+)\s*;/;
    this.textureRegexp = /var\s+(\w+)\s*:\s*((array<\s*)?(texture_\w+)\s*(<\s*(.+)\s*>)?\s*(,\s*\w+\s*>\s*)?);/;
    this.noPrecision = true;
  }
  _getArraySize(name137, uniformType, preProcessors) {
    let length = 0;
    const endArray = uniformType.lastIndexOf(">");
    if (uniformType.indexOf("array") >= 0 && endArray > 0) {
      let startArray = endArray;
      while (startArray > 0 && uniformType.charAt(startArray) !== " " && uniformType.charAt(startArray) !== ",") {
        startArray--;
      }
      const lengthInString = uniformType.substring(startArray + 1, endArray);
      length = +lengthInString;
      if (isNaN(length)) {
        length = +preProcessors[lengthInString.trim()];
      }
      while (startArray > 0 && (uniformType.charAt(startArray) === " " || uniformType.charAt(startArray) === ",")) {
        startArray--;
      }
      uniformType = uniformType.substring(uniformType.indexOf("<") + 1, startArray + 1);
    }
    return [name137, uniformType, length];
  }
  initializeShaders(processingContext) {
    this._webgpuProcessingContext = processingContext;
    this._attributesWGSL = [];
    this._attributesDeclWGSL = [];
    this._attributeNamesWGSL = [];
    this._varyingsWGSL = [];
    this._varyingsDeclWGSL = [];
    this._varyingNamesWGSL = [];
    this._stridedUniformArrays = [];
  }
  preProcessShaderCode(code) {
    return `struct ${WebGPUShaderProcessor.InternalsUBOName} {
yFactor_: f32,
textureOutputHeight_: f32,
};
var<uniform> ${internalsVarName} : ${WebGPUShaderProcessor.InternalsUBOName};
` + RemoveComments(code);
  }
  varyingProcessor(varying, isFragment, preProcessors) {
    const varyingRegex = /\s*varying\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s*:\s*(.+)\s*;/gm;
    const match = varyingRegex.exec(varying);
    if (match !== null) {
      const varyingType = match[2];
      const name137 = match[1];
      let location;
      if (isFragment) {
        location = this._webgpuProcessingContext.availableVaryings[name137];
        if (location === void 0) {
          Logger.Warn(`Invalid fragment shader: The varying named "${name137}" is not declared in the vertex shader! This declaration will be ignored.`);
        }
      } else {
        location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name137, varyingType, preProcessors)[2]);
        this._webgpuProcessingContext.availableVaryings[name137] = location;
        this._varyingsWGSL.push(`@location(${location}) ${name137} : ${varyingType},`);
        this._varyingsDeclWGSL.push(`var<private> ${name137} : ${varyingType};`);
        this._varyingNamesWGSL.push(name137);
      }
      varying = "";
    }
    return varying;
  }
  attributeProcessor(attribute, preProcessors) {
    const attribRegex = /\s*attribute\s+(\S+)\s*:\s*(.+)\s*;/gm;
    const match = attribRegex.exec(attribute);
    if (match !== null) {
      const attributeType = match[2];
      const name137 = match[1];
      const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name137, attributeType, preProcessors)[2]);
      this._webgpuProcessingContext.availableAttributes[name137] = location;
      this._webgpuProcessingContext.orderedAttributes[location] = name137;
      this._attributesWGSL.push(`@location(${location}) ${name137} : ${attributeType},`);
      this._attributesDeclWGSL.push(`var<private> ${name137} : ${attributeType};`);
      this._attributeNamesWGSL.push(name137);
      attribute = "";
    }
    return attribute;
  }
  uniformProcessor(uniform, isFragment, preProcessors) {
    const match = this.uniformRegexp.exec(uniform);
    if (match !== null) {
      const uniformType = match[2];
      const name137 = match[1];
      this._addUniformToLeftOverUBO(name137, uniformType, preProcessors);
      uniform = "";
    }
    return uniform;
  }
  textureProcessor(texture, isFragment, preProcessors) {
    const match = this.textureRegexp.exec(texture);
    if (match !== null) {
      const name137 = match[1];
      const type = match[2];
      const isArrayOfTexture = !!match[3];
      const textureFunc = match[4];
      const isStorageTexture = textureFunc.indexOf("storage") > 0;
      const componentType = match[6];
      const storageTextureFormat = isStorageTexture ? componentType.substring(0, componentType.indexOf(",")).trim() : null;
      let arraySize = isArrayOfTexture ? this._getArraySize(name137, type, preProcessors)[2] : 0;
      let textureInfo = this._webgpuProcessingContext.availableTextures[name137];
      if (!textureInfo) {
        textureInfo = {
          isTextureArray: arraySize > 0,
          isStorageTexture,
          textures: [],
          sampleType: TextureSampleType.Float
        };
        arraySize = arraySize || 1;
        for (let i = 0; i < arraySize; ++i) {
          textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());
        }
      } else {
        arraySize = textureInfo.textures.length;
      }
      this._webgpuProcessingContext.availableTextures[name137] = textureInfo;
      const isDepthTexture = textureFunc.indexOf("depth") > 0;
      const textureDimension = gpuTextureViewDimensionByWebGPUTextureFunction[textureFunc];
      const sampleType = isDepthTexture ? TextureSampleType.Depth : componentType === "u32" ? TextureSampleType.Uint : componentType === "i32" ? TextureSampleType.Sint : TextureSampleType.Float;
      textureInfo.sampleType = sampleType;
      if (textureDimension === void 0) {
        throw `Can't get the texture dimension corresponding to the texture function "${textureFunc}"!`;
      }
      for (let i = 0; i < arraySize; ++i) {
        const { groupIndex, bindingIndex } = textureInfo.textures[i];
        if (i === 0) {
          texture = `@group(${groupIndex}) @binding(${bindingIndex}) ${texture}`;
        }
        this._addTextureBindingDescription(name137, textureInfo, i, textureDimension, storageTextureFormat, !isFragment);
      }
    }
    return texture;
  }
  postProcessor(code) {
    return code;
  }
  finalizeShaders(vertexCode, fragmentCode) {
    const fragCoordCode = fragmentCode.indexOf("gl_FragCoord") >= 0 ? `
            if (internals.yFactor_ == 1.) {
                gl_FragCoord.y = internals.textureOutputHeight_ - gl_FragCoord.y;
            }
        ` : "";
    vertexCode = this._processSamplers(vertexCode, true);
    fragmentCode = this._processSamplers(fragmentCode, false);
    vertexCode = this._processCustomBuffers(vertexCode, true);
    fragmentCode = this._processCustomBuffers(fragmentCode, false);
    const leftOverUBO = this._buildLeftOverUBO();
    vertexCode = leftOverUBO + vertexCode;
    fragmentCode = leftOverUBO + fragmentCode;
    vertexCode = vertexCode.replace(/#define /g, "//#define ");
    vertexCode = this._processStridedUniformArrays(vertexCode);
    const varyingsDecl = this._varyingsDeclWGSL.join("\n") + "\n";
    const vertexBuiltinDecl = `var<private> ${builtInName_vertex_index} : u32;
var<private> ${builtInName_instance_index} : u32;
var<private> ${builtInName_position} : vec4<f32>;
`;
    const vertexAttributesDecl = this._attributesDeclWGSL.join("\n") + "\n";
    let vertexInputs = "struct VertexInputs {\n  @builtin(vertex_index) vertexIndex : u32,\n  @builtin(instance_index) instanceIndex : u32,\n";
    if (this._attributesWGSL.length > 0) {
      vertexInputs += this._attributesWGSL.join("\n");
    }
    vertexInputs += "\n};\n";
    let vertexFragmentInputs = "struct FragmentInputs {\n  @builtin(position) position : vec4<f32>,\n";
    if (this._varyingsWGSL.length > 0) {
      vertexFragmentInputs += this._varyingsWGSL.join("\n");
    }
    vertexFragmentInputs += "\n};\n";
    vertexCode = vertexBuiltinDecl + vertexInputs + vertexAttributesDecl + vertexFragmentInputs + varyingsDecl + vertexCode;
    let vertexStartingCode = `  var output : FragmentInputs;
  ${builtInName_vertex_index} = input.vertexIndex;
  ${builtInName_instance_index} = input.instanceIndex;
`;
    for (let i = 0; i < this._attributeNamesWGSL.length; ++i) {
      const name137 = this._attributeNamesWGSL[i];
      vertexStartingCode += `  ${name137} = input.${name137};
`;
    }
    let vertexEndingCode = `  output.position = ${builtInName_position};
  output.position.y = output.position.y * internals.yFactor_;
`;
    for (let i = 0; i < this._varyingNamesWGSL.length; ++i) {
      const name137 = this._varyingNamesWGSL[i];
      vertexEndingCode += `  output.${name137} = ${name137};
`;
    }
    vertexEndingCode += "  return output;";
    vertexCode = this._injectStartingAndEndingCode(vertexCode, "fn main", vertexStartingCode, vertexEndingCode);
    fragmentCode = fragmentCode.replace(/#define /g, "//#define ");
    fragmentCode = this._processStridedUniformArrays(fragmentCode);
    fragmentCode = fragmentCode.replace(/dpdy/g, "(-internals.yFactor_)*dpdy");
    const fragmentBuiltinDecl = `var<private> ${builtInName_position_frag} : vec4<f32>;
var<private> ${builtInName_front_facing} : bool;
var<private> ${builtInName_FragColor} : vec4<f32>;
var<private> ${builtInName_frag_depth} : f32;
`;
    let fragmentFragmentInputs = "struct FragmentInputs {\n  @builtin(position) position : vec4<f32>,\n  @builtin(front_facing) frontFacing : bool,\n";
    if (this._varyingsWGSL.length > 0) {
      fragmentFragmentInputs += this._varyingsWGSL.join("\n");
    }
    fragmentFragmentInputs += "\n};\n";
    let fragmentOutputs = "struct FragmentOutputs {\n  @location(0) color : vec4<f32>,\n";
    let hasFragDepth = false;
    let idx = 0;
    while (!hasFragDepth) {
      idx = fragmentCode.indexOf(builtInName_frag_depth, idx);
      if (idx < 0) {
        break;
      }
      const saveIndex = idx;
      hasFragDepth = true;
      while (idx > 1 && fragmentCode.charAt(idx) !== "\n") {
        if (fragmentCode.charAt(idx) === "/" && fragmentCode.charAt(idx - 1) === "/") {
          hasFragDepth = false;
          break;
        }
        idx--;
      }
      idx = saveIndex + builtInName_frag_depth.length;
    }
    if (hasFragDepth) {
      fragmentOutputs += "  @builtin(frag_depth) fragDepth: f32,\n";
    }
    fragmentOutputs += "};\n";
    fragmentCode = fragmentBuiltinDecl + fragmentFragmentInputs + varyingsDecl + fragmentOutputs + fragmentCode;
    let fragmentStartingCode = `  var output : FragmentOutputs;
  ${builtInName_position_frag} = input.position;
  ${builtInName_front_facing} = input.frontFacing;
` + fragCoordCode;
    for (let i = 0; i < this._varyingNamesWGSL.length; ++i) {
      const name137 = this._varyingNamesWGSL[i];
      fragmentStartingCode += `  ${name137} = input.${name137};
`;
    }
    let fragmentEndingCode = `  output.color = ${builtInName_FragColor};
`;
    if (hasFragDepth) {
      fragmentEndingCode += `  output.fragDepth = ${builtInName_frag_depth};
`;
    }
    fragmentEndingCode += "  return output;";
    fragmentCode = this._injectStartingAndEndingCode(fragmentCode, "fn main", fragmentStartingCode, fragmentEndingCode);
    this._collectBindingNames();
    this._preCreateBindGroupEntries();
    return { vertexCode, fragmentCode };
  }
  _generateLeftOverUBOCode(name137, uniformBufferDescription) {
    let stridedArrays = "";
    let ubo = `struct ${name137} {
`;
    for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {
      const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, "$1");
      const size = WebGPUShaderProcessor.UniformSizes[type];
      if (leftOverUniform.length > 0) {
        if (size <= 2) {
          const stridedArrayType = `${name137}_${this._stridedUniformArrays.length}_strided_arr`;
          stridedArrays += `struct ${stridedArrayType} {
                        @size(16)
                        el: ${type},
                    }`;
          this._stridedUniformArrays.push(leftOverUniform.name);
          ubo += ` @align(16) ${leftOverUniform.name} : array<${stridedArrayType}, ${leftOverUniform.length}>,
`;
        } else {
          ubo += ` ${leftOverUniform.name} : array<${leftOverUniform.type}, ${leftOverUniform.length}>,
`;
        }
      } else {
        ubo += `  ${leftOverUniform.name} : ${leftOverUniform.type},
`;
      }
    }
    ubo += "};\n";
    ubo = `${stridedArrays}
${ubo}`;
    ubo += `@group(${uniformBufferDescription.binding.groupIndex}) @binding(${uniformBufferDescription.binding.bindingIndex}) var<uniform> ${leftOverVarName} : ${name137};
`;
    return ubo;
  }
  _processSamplers(code, isVertex) {
    const samplerRegexp = /var\s+(\w+Sampler)\s*:\s*(sampler|sampler_comparison)\s*;/gm;
    while (true) {
      const match = samplerRegexp.exec(code);
      if (match === null) {
        break;
      }
      const name137 = match[1];
      const samplerType = match[2];
      const textureName = name137.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix) === name137.length - WebGPUShaderProcessor.AutoSamplerSuffix.length ? name137.substring(0, name137.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix)) : null;
      const samplerBindingType = samplerType === "sampler_comparison" ? SamplerBindingType.Comparison : SamplerBindingType.Filtering;
      if (textureName) {
        const textureInfo = this._webgpuProcessingContext.availableTextures[textureName];
        if (textureInfo) {
          textureInfo.autoBindSampler = true;
        }
      }
      let samplerInfo = this._webgpuProcessingContext.availableSamplers[name137];
      if (!samplerInfo) {
        samplerInfo = {
          binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),
          type: samplerBindingType
        };
        this._webgpuProcessingContext.availableSamplers[name137] = samplerInfo;
      }
      this._addSamplerBindingDescription(name137, samplerInfo, isVertex);
      const part1 = code.substring(0, match.index);
      const insertPart = `@group(${samplerInfo.binding.groupIndex}) @binding(${samplerInfo.binding.bindingIndex}) `;
      const part2 = code.substring(match.index);
      code = part1 + insertPart + part2;
      samplerRegexp.lastIndex += insertPart.length;
    }
    return code;
  }
  _processCustomBuffers(code, isVertex) {
    const instantiateBufferRegexp = /var<\s*(uniform|storage)\s*(,\s*(read|read_write)\s*)?>\s+(\S+)\s*:\s*(\S+)\s*;/gm;
    while (true) {
      const match = instantiateBufferRegexp.exec(code);
      if (match === null) {
        break;
      }
      const type = match[1];
      const decoration = match[3];
      let name137 = match[4];
      const structName = match[5];
      let bufferInfo = this._webgpuProcessingContext.availableBuffers[name137];
      if (!bufferInfo) {
        const knownUBO = type === "uniform" ? WebGPUShaderProcessingContext.KnownUBOs[structName] : null;
        let binding;
        if (knownUBO) {
          name137 = structName;
          binding = knownUBO.binding;
          if (binding.groupIndex === -1) {
            binding = this._webgpuProcessingContext.getNextFreeUBOBinding();
          }
        } else {
          binding = this._webgpuProcessingContext.getNextFreeUBOBinding();
        }
        bufferInfo = { binding };
        this._webgpuProcessingContext.availableBuffers[name137] = bufferInfo;
      }
      this._addBufferBindingDescription(name137, this._webgpuProcessingContext.availableBuffers[name137], decoration === "read_write" ? BufferBindingType.Storage : type === "storage" ? BufferBindingType.ReadOnlyStorage : BufferBindingType.Uniform, isVertex);
      const groupIndex = bufferInfo.binding.groupIndex;
      const bindingIndex = bufferInfo.binding.bindingIndex;
      const part1 = code.substring(0, match.index);
      const insertPart = `@group(${groupIndex}) @binding(${bindingIndex}) `;
      const part2 = code.substring(match.index);
      code = part1 + insertPart + part2;
      instantiateBufferRegexp.lastIndex += insertPart.length;
    }
    return code;
  }
  _processStridedUniformArrays(code) {
    for (const uniformArrayName of this._stridedUniformArrays) {
      code = code.replace(new RegExp(`${uniformArrayName}\\s*\\[(.*)\\]`, "g"), `${uniformArrayName}[$1].el`);
    }
    return code;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuHardwareTexture.js
var WebGPUHardwareTexture = class {
  constructor(existingTexture = null) {
    this.format = TextureFormat.RGBA8Unorm;
    this.textureUsages = 0;
    this.textureAdditionalUsages = 0;
    this._webgpuTexture = existingTexture;
    this._webgpuMSAATexture = null;
    this.view = null;
    this.viewForWriting = null;
  }
  get underlyingResource() {
    return this._webgpuTexture;
  }
  get msaaTexture() {
    return this._webgpuMSAATexture;
  }
  set msaaTexture(texture) {
    this._webgpuMSAATexture = texture;
  }
  set(hardwareTexture) {
    this._webgpuTexture = hardwareTexture;
  }
  setUsage(textureSource, generateMipMaps, isCube, width, height) {
    generateMipMaps = textureSource === InternalTextureSource.RenderTarget ? false : generateMipMaps;
    this.createView({
      format: this.format,
      dimension: isCube ? TextureViewDimension.Cube : TextureViewDimension.E2d,
      mipLevelCount: generateMipMaps ? Scalar.ILog2(Math.max(width, height)) + 1 : 1,
      baseArrayLayer: 0,
      baseMipLevel: 0,
      arrayLayerCount: isCube ? 6 : 1,
      aspect: TextureAspect.All
    });
  }
  createView(descriptor, createViewForWriting = false) {
    this.view = this._webgpuTexture.createView(descriptor);
    if (createViewForWriting && descriptor) {
      const saveNumMipMaps = descriptor.mipLevelCount;
      descriptor.mipLevelCount = 1;
      this.viewForWriting = this._webgpuTexture.createView(descriptor);
      descriptor.mipLevelCount = saveNumMipMaps;
    }
  }
  reset() {
    this._webgpuTexture = null;
    this._webgpuMSAATexture = null;
    this.view = null;
    this.viewForWriting = null;
  }
  release() {
    var _a, _b, _c;
    (_a = this._webgpuTexture) === null || _a === void 0 ? void 0 : _a.destroy();
    (_b = this._webgpuMSAATexture) === null || _b === void 0 ? void 0 : _b.destroy();
    (_c = this._copyInvertYTempTexture) === null || _c === void 0 ? void 0 : _c.destroy();
    this.reset();
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuTextureHelper.js
var mipmapVertexSource = `
    const vec2 pos[4] = vec2[4](vec2(-1.0f, 1.0f), vec2(1.0f, 1.0f), vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f));
    const vec2 tex[4] = vec2[4](vec2(0.0f, 0.0f), vec2(1.0f, 0.0f), vec2(0.0f, 1.0f), vec2(1.0f, 1.0f));

    layout(location = 0) out vec2 vTex;

    void main() {
        vTex = tex[gl_VertexIndex];
        gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);
    }
    `;
var mipmapFragmentSource = `
    layout(set = 0, binding = 0) uniform sampler imgSampler;
    layout(set = 0, binding = 1) uniform texture2D img;

    layout(location = 0) in vec2 vTex;
    layout(location = 0) out vec4 outColor;

    void main() {
        outColor = texture(sampler2D(img, imgSampler), vTex);
    }
    `;
var invertYPreMultiplyAlphaVertexSource = `
    #extension GL_EXT_samplerless_texture_functions : enable

    const vec2 pos[4] = vec2[4](vec2(-1.0f, 1.0f), vec2(1.0f, 1.0f), vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f));
    const vec2 tex[4] = vec2[4](vec2(0.0f, 0.0f), vec2(1.0f, 0.0f), vec2(0.0f, 1.0f), vec2(1.0f, 1.0f));

    layout(set = 0, binding = 0) uniform texture2D img;

    #ifdef INVERTY
        layout(location = 0) out flat ivec2 vTextureSize;
    #endif

    void main() {
        #ifdef INVERTY
            vTextureSize = textureSize(img, 0);
        #endif
        gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);
    }
    `;
var invertYPreMultiplyAlphaFragmentSource = `
    #extension GL_EXT_samplerless_texture_functions : enable

    layout(set = 0, binding = 0) uniform texture2D img;

    #ifdef INVERTY
        layout(location = 0) in flat ivec2 vTextureSize;
    #endif
    layout(location = 0) out vec4 outColor;

    void main() {
    #ifdef INVERTY
        vec4 color = texelFetch(img, ivec2(gl_FragCoord.x, vTextureSize.y - gl_FragCoord.y), 0);
    #else
        vec4 color = texelFetch(img, ivec2(gl_FragCoord.xy), 0);
    #endif
    #ifdef PREMULTIPLYALPHA
        color.rgb *= color.a;
    #endif
        outColor = color;
    }
    `;
var invertYPreMultiplyAlphaWithOfstVertexSource = invertYPreMultiplyAlphaVertexSource;
var invertYPreMultiplyAlphaWithOfstFragmentSource = `
    #extension GL_EXT_samplerless_texture_functions : enable

    layout(set = 0, binding = 0) uniform texture2D img;
    layout(set = 0, binding = 1) uniform Params {
        float ofstX;
        float ofstY;
        float width;
        float height;
    };

    #ifdef INVERTY
        layout(location = 0) in flat ivec2 vTextureSize;
    #endif
    layout(location = 0) out vec4 outColor;

    void main() {
        if (gl_FragCoord.x < ofstX || gl_FragCoord.x >= ofstX + width) {
            discard;
        }
        if (gl_FragCoord.y < ofstY || gl_FragCoord.y >= ofstY + height) {
            discard;
        }
    #ifdef INVERTY
        vec4 color = texelFetch(img, ivec2(gl_FragCoord.x, ofstY + height - (gl_FragCoord.y - ofstY)), 0);
    #else
        vec4 color = texelFetch(img, ivec2(gl_FragCoord.xy), 0);
    #endif
    #ifdef PREMULTIPLYALPHA
        color.rgb *= color.a;
    #endif
        outColor = color;
    }
    `;
var clearVertexSource = `
    const vec2 pos[4] = vec2[4](vec2(-1.0f, 1.0f), vec2(1.0f, 1.0f), vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f));

    void main() {
        gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);
    }
    `;
var clearFragmentSource = `
    layout(set = 0, binding = 0) uniform Uniforms {
        uniform vec4 color;
    };

    layout(location = 0) out vec4 outColor;

    void main() {
        outColor = color;
    }
    `;
var copyVideoToTextureVertexSource = `
    struct VertexOutput {
        @builtin(position) Position : vec4<f32>,
        @location(0) fragUV : vec2<f32>
    }
  
    @vertex
    fn main(
        @builtin(vertex_index) VertexIndex : u32
    ) -> VertexOutput {
        var pos = array<vec2<f32>, 4>(
            vec2(-1.0,  1.0),
            vec2( 1.0,  1.0),
            vec2(-1.0, -1.0),
            vec2( 1.0, -1.0)
        );
        var tex = array<vec2<f32>, 4>(
            vec2(0.0, 0.0),
            vec2(1.0, 0.0),
            vec2(0.0, 1.0),
            vec2(1.0, 1.0)
        );

        var output: VertexOutput;

        output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);
        output.fragUV = tex[VertexIndex];

        return output;
    }
    `;
var copyVideoToTextureFragmentSource = `
    @group(0) @binding(0) var videoSampler: sampler;
    @group(0) @binding(1) var videoTexture: texture_external;

    @fragment
    fn main(
        @location(0) fragUV: vec2<f32>
    ) -> @location(0) vec4<f32> {
        return textureSampleBaseClampToEdge(videoTexture, videoSampler, fragUV);
    }
    `;
var copyVideoToTextureInvertYFragmentSource = `
    @group(0) @binding(0) var videoSampler: sampler;
    @group(0) @binding(1) var videoTexture: texture_external;

    @fragment
    fn main(
        @location(0) fragUV: vec2<f32>
    ) -> @location(0) vec4<f32> {
        return textureSampleBaseClampToEdge(videoTexture, videoSampler, vec2<f32>(fragUV.x, 1.0 - fragUV.y));
    }
    `;
var PipelineType;
(function(PipelineType2) {
  PipelineType2[PipelineType2["MipMap"] = 0] = "MipMap";
  PipelineType2[PipelineType2["InvertYPremultiplyAlpha"] = 1] = "InvertYPremultiplyAlpha";
  PipelineType2[PipelineType2["Clear"] = 2] = "Clear";
  PipelineType2[PipelineType2["InvertYPremultiplyAlphaWithOfst"] = 3] = "InvertYPremultiplyAlphaWithOfst";
})(PipelineType || (PipelineType = {}));
var VideoPipelineType;
(function(VideoPipelineType2) {
  VideoPipelineType2[VideoPipelineType2["DontInvertY"] = 0] = "DontInvertY";
  VideoPipelineType2[VideoPipelineType2["InvertY"] = 1] = "InvertY";
})(VideoPipelineType || (VideoPipelineType = {}));
var shadersForPipelineType = [
  { vertex: mipmapVertexSource, fragment: mipmapFragmentSource },
  { vertex: invertYPreMultiplyAlphaVertexSource, fragment: invertYPreMultiplyAlphaFragmentSource },
  { vertex: clearVertexSource, fragment: clearFragmentSource },
  { vertex: invertYPreMultiplyAlphaWithOfstVertexSource, fragment: invertYPreMultiplyAlphaWithOfstFragmentSource }
];
var renderableTextureFormatToIndex = {
  "": 0,
  r8unorm: 1,
  r8uint: 2,
  r8sint: 3,
  r16uint: 4,
  r16sint: 5,
  r16float: 6,
  rg8unorm: 7,
  rg8uint: 8,
  rg8sint: 9,
  r32uint: 10,
  r32sint: 11,
  r32float: 12,
  rg16uint: 13,
  rg16sint: 14,
  rg16float: 15,
  rgba8unorm: 16,
  "rgba8unorm-srgb": 17,
  rgba8uint: 18,
  rgba8sint: 19,
  bgra8unorm: 20,
  "bgra8unorm-srgb": 21,
  rgb10a2unorm: 22,
  rg32uint: 23,
  rg32sint: 24,
  rg32float: 25,
  rgba16uint: 26,
  rgba16sint: 27,
  rgba16float: 28,
  rgba32uint: 29,
  rgba32sint: 30,
  rgba32float: 31,
  stencil8: 32,
  depth16unorm: 33,
  depth24plus: 34,
  "depth24plus-stencil8": 35,
  depth32float: 36,
  "depth24unorm-stencil8": 37,
  "depth32float-stencil8": 38
};
var WebGPUTextureHelper = class {
  constructor(device, glslang, tintWASM, bufferManager) {
    this._pipelines = {};
    this._compiledShaders = [];
    this._videoPipelines = {};
    this._videoCompiledShaders = [];
    this._deferredReleaseTextures = [];
    this._device = device;
    this._glslang = glslang;
    this._tintWASM = tintWASM;
    this._bufferManager = bufferManager;
    this._mipmapSampler = device.createSampler({ minFilter: FilterMode.Linear });
    this._videoSampler = device.createSampler({ minFilter: FilterMode.Linear });
    this._ubCopyWithOfst = this._bufferManager.createBuffer(4 * 4, BufferUsage.Uniform | BufferUsage.CopyDst).underlyingResource;
    this._getPipeline(TextureFormat.RGBA8Unorm);
    this._getVideoPipeline(TextureFormat.RGBA8Unorm);
  }
  static ComputeNumMipmapLevels(width, height) {
    return Scalar.ILog2(Math.max(width, height)) + 1;
  }
  _getPipeline(format, type = PipelineType.MipMap, params) {
    const index = type === PipelineType.MipMap ? 1 << 0 : type === PipelineType.InvertYPremultiplyAlpha ? ((params.invertY ? 1 : 0) << 1) + ((params.premultiplyAlpha ? 1 : 0) << 2) : type === PipelineType.Clear ? 1 << 3 : type === PipelineType.InvertYPremultiplyAlphaWithOfst ? ((params.invertY ? 1 : 0) << 4) + ((params.premultiplyAlpha ? 1 : 0) << 5) : 0;
    if (!this._pipelines[format]) {
      this._pipelines[format] = [];
    }
    let pipelineAndBGL = this._pipelines[format][index];
    if (!pipelineAndBGL) {
      let defines = "#version 450\r\n";
      if (type === PipelineType.InvertYPremultiplyAlpha || type === PipelineType.InvertYPremultiplyAlphaWithOfst) {
        if (params.invertY) {
          defines += "#define INVERTY\r\n";
        }
        if (params.premultiplyAlpha) {
          defines += "#define PREMULTIPLYALPHA\r\n";
        }
      }
      let modules = this._compiledShaders[index];
      if (!modules) {
        let vertexCode = this._glslang.compileGLSL(defines + shadersForPipelineType[type].vertex, "vertex");
        let fragmentCode = this._glslang.compileGLSL(defines + shadersForPipelineType[type].fragment, "fragment");
        if (this._tintWASM) {
          vertexCode = this._tintWASM.convertSpirV2WGSL(vertexCode);
          fragmentCode = this._tintWASM.convertSpirV2WGSL(fragmentCode);
        }
        const vertexModule = this._device.createShaderModule({
          code: vertexCode
        });
        const fragmentModule = this._device.createShaderModule({
          code: fragmentCode
        });
        modules = this._compiledShaders[index] = [vertexModule, fragmentModule];
      }
      const pipeline = this._device.createRenderPipeline({
        layout: AutoLayoutMode.Auto,
        vertex: {
          module: modules[0],
          entryPoint: "main"
        },
        fragment: {
          module: modules[1],
          entryPoint: "main",
          targets: [
            {
              format
            }
          ]
        },
        primitive: {
          topology: PrimitiveTopology.TriangleStrip,
          stripIndexFormat: IndexFormat.Uint16
        }
      });
      pipelineAndBGL = this._pipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];
    }
    return pipelineAndBGL;
  }
  _getVideoPipeline(format, type = VideoPipelineType.DontInvertY) {
    const index = type === VideoPipelineType.InvertY ? 1 << 0 : 0;
    if (!this._videoPipelines[format]) {
      this._videoPipelines[format] = [];
    }
    let pipelineAndBGL = this._videoPipelines[format][index];
    if (!pipelineAndBGL) {
      let modules = this._videoCompiledShaders[index];
      if (!modules) {
        const vertexModule = this._device.createShaderModule({
          code: copyVideoToTextureVertexSource
        });
        const fragmentModule = this._device.createShaderModule({
          code: index === 0 ? copyVideoToTextureFragmentSource : copyVideoToTextureInvertYFragmentSource
        });
        modules = this._videoCompiledShaders[index] = [vertexModule, fragmentModule];
      }
      const pipeline = this._device.createRenderPipeline({
        label: `CopyVideoToTexture_${format}_${index === 0 ? "DontInvertY" : "InvertY"}`,
        layout: AutoLayoutMode.Auto,
        vertex: {
          module: modules[0],
          entryPoint: "main"
        },
        fragment: {
          module: modules[1],
          entryPoint: "main",
          targets: [
            {
              format
            }
          ]
        },
        primitive: {
          topology: PrimitiveTopology.TriangleStrip,
          stripIndexFormat: IndexFormat.Uint16
        }
      });
      pipelineAndBGL = this._videoPipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];
    }
    return pipelineAndBGL;
  }
  static _GetTextureTypeFromFormat(format) {
    switch (format) {
      case TextureFormat.R8Unorm:
      case TextureFormat.R8Snorm:
      case TextureFormat.R8Uint:
      case TextureFormat.R8Sint:
      case TextureFormat.RG8Unorm:
      case TextureFormat.RG8Snorm:
      case TextureFormat.RG8Uint:
      case TextureFormat.RG8Sint:
      case TextureFormat.RGBA8Unorm:
      case TextureFormat.RGBA8UnormSRGB:
      case TextureFormat.RGBA8Snorm:
      case TextureFormat.RGBA8Uint:
      case TextureFormat.RGBA8Sint:
      case TextureFormat.BGRA8Unorm:
      case TextureFormat.BGRA8UnormSRGB:
      case TextureFormat.RGB10A2Unorm:
      case TextureFormat.RGB9E5UFloat:
      case TextureFormat.RG11B10UFloat:
      case TextureFormat.Depth24UnormStencil8:
      case TextureFormat.Depth32FloatStencil8:
      case TextureFormat.BC7RGBAUnorm:
      case TextureFormat.BC7RGBAUnormSRGB:
      case TextureFormat.BC6HRGBUFloat:
      case TextureFormat.BC6HRGBFloat:
      case TextureFormat.BC5RGUnorm:
      case TextureFormat.BC5RGSnorm:
      case TextureFormat.BC3RGBAUnorm:
      case TextureFormat.BC3RGBAUnormSRGB:
      case TextureFormat.BC2RGBAUnorm:
      case TextureFormat.BC2RGBAUnormSRGB:
      case TextureFormat.BC4RUnorm:
      case TextureFormat.BC4RSnorm:
      case TextureFormat.BC1RGBAUnorm:
      case TextureFormat.BC1RGBAUnormSRGB:
      case TextureFormat.ETC2RGB8Unorm:
      case TextureFormat.ETC2RGB8UnormSRGB:
      case TextureFormat.ETC2RGB8A1Unorm:
      case TextureFormat.ETC2RGB8A1UnormSRGB:
      case TextureFormat.ETC2RGBA8Unorm:
      case TextureFormat.ETC2RGBA8UnormSRGB:
      case TextureFormat.EACR11Unorm:
      case TextureFormat.EACR11Snorm:
      case TextureFormat.EACRG11Unorm:
      case TextureFormat.EACRG11Snorm:
      case TextureFormat.ASTC4x4Unorm:
      case TextureFormat.ASTC4x4UnormSRGB:
      case TextureFormat.ASTC5x4Unorm:
      case TextureFormat.ASTC5x4UnormSRGB:
      case TextureFormat.ASTC5x5Unorm:
      case TextureFormat.ASTC5x5UnormSRGB:
      case TextureFormat.ASTC6x5Unorm:
      case TextureFormat.ASTC6x5UnormSRGB:
      case TextureFormat.ASTC6x6Unorm:
      case TextureFormat.ASTC6x6UnormSRGB:
      case TextureFormat.ASTC8x5Unorm:
      case TextureFormat.ASTC8x5UnormSRGB:
      case TextureFormat.ASTC8x6Unorm:
      case TextureFormat.ASTC8x6UnormSRGB:
      case TextureFormat.ASTC8x8Unorm:
      case TextureFormat.ASTC8x8UnormSRGB:
      case TextureFormat.ASTC10x5Unorm:
      case TextureFormat.ASTC10x5UnormSRGB:
      case TextureFormat.ASTC10x6Unorm:
      case TextureFormat.ASTC10x6UnormSRGB:
      case TextureFormat.ASTC10x8Unorm:
      case TextureFormat.ASTC10x8UnormSRGB:
      case TextureFormat.ASTC10x10Unorm:
      case TextureFormat.ASTC10x10UnormSRGB:
      case TextureFormat.ASTC12x10Unorm:
      case TextureFormat.ASTC12x10UnormSRGB:
      case TextureFormat.ASTC12x12Unorm:
      case TextureFormat.ASTC12x12UnormSRGB:
        return 0;
      case TextureFormat.R16Uint:
      case TextureFormat.R16Sint:
      case TextureFormat.RG16Uint:
      case TextureFormat.RG16Sint:
      case TextureFormat.RGBA16Uint:
      case TextureFormat.RGBA16Sint:
      case TextureFormat.Depth16Unorm:
        return 5;
      case TextureFormat.R16Float:
      case TextureFormat.RG16Float:
      case TextureFormat.RGBA16Float:
        return 2;
      case TextureFormat.R32Uint:
      case TextureFormat.R32Sint:
      case TextureFormat.RG32Uint:
      case TextureFormat.RG32Sint:
      case TextureFormat.RGBA32Uint:
      case TextureFormat.RGBA32Sint:
        return 7;
      case TextureFormat.R32Float:
      case TextureFormat.RG32Float:
      case TextureFormat.RGBA32Float:
      case TextureFormat.Depth32Float:
        return 1;
      case TextureFormat.Stencil8:
        throw "No fixed size for Stencil8 format!";
      case TextureFormat.Depth24Plus:
        throw "No fixed size for Depth24Plus format!";
      case TextureFormat.Depth24PlusStencil8:
        throw "No fixed size for Depth24PlusStencil8 format!";
    }
    return 0;
  }
  static _GetBlockInformationFromFormat(format) {
    switch (format) {
      case TextureFormat.R8Unorm:
      case TextureFormat.R8Snorm:
      case TextureFormat.R8Uint:
      case TextureFormat.R8Sint:
        return { width: 1, height: 1, length: 1 };
      case TextureFormat.R16Uint:
      case TextureFormat.R16Sint:
      case TextureFormat.R16Float:
      case TextureFormat.RG8Unorm:
      case TextureFormat.RG8Snorm:
      case TextureFormat.RG8Uint:
      case TextureFormat.RG8Sint:
        return { width: 1, height: 1, length: 2 };
      case TextureFormat.R32Uint:
      case TextureFormat.R32Sint:
      case TextureFormat.R32Float:
      case TextureFormat.RG16Uint:
      case TextureFormat.RG16Sint:
      case TextureFormat.RG16Float:
      case TextureFormat.RGBA8Unorm:
      case TextureFormat.RGBA8UnormSRGB:
      case TextureFormat.RGBA8Snorm:
      case TextureFormat.RGBA8Uint:
      case TextureFormat.RGBA8Sint:
      case TextureFormat.BGRA8Unorm:
      case TextureFormat.BGRA8UnormSRGB:
      case TextureFormat.RGB9E5UFloat:
      case TextureFormat.RGB10A2Unorm:
      case TextureFormat.RG11B10UFloat:
        return { width: 1, height: 1, length: 4 };
      case TextureFormat.RG32Uint:
      case TextureFormat.RG32Sint:
      case TextureFormat.RG32Float:
      case TextureFormat.RGBA16Uint:
      case TextureFormat.RGBA16Sint:
      case TextureFormat.RGBA16Float:
        return { width: 1, height: 1, length: 8 };
      case TextureFormat.RGBA32Uint:
      case TextureFormat.RGBA32Sint:
      case TextureFormat.RGBA32Float:
        return { width: 1, height: 1, length: 16 };
      case TextureFormat.Stencil8:
        throw "No fixed size for Stencil8 format!";
      case TextureFormat.Depth16Unorm:
        return { width: 1, height: 1, length: 2 };
      case TextureFormat.Depth24Plus:
        throw "No fixed size for Depth24Plus format!";
      case TextureFormat.Depth24PlusStencil8:
        throw "No fixed size for Depth24PlusStencil8 format!";
      case TextureFormat.Depth32Float:
        return { width: 1, height: 1, length: 4 };
      case TextureFormat.Depth24UnormStencil8:
        return { width: 1, height: 1, length: 4 };
      case TextureFormat.Depth32FloatStencil8:
        return { width: 1, height: 1, length: 5 };
      case TextureFormat.BC7RGBAUnorm:
      case TextureFormat.BC7RGBAUnormSRGB:
      case TextureFormat.BC6HRGBUFloat:
      case TextureFormat.BC6HRGBFloat:
      case TextureFormat.BC5RGUnorm:
      case TextureFormat.BC5RGSnorm:
      case TextureFormat.BC3RGBAUnorm:
      case TextureFormat.BC3RGBAUnormSRGB:
      case TextureFormat.BC2RGBAUnorm:
      case TextureFormat.BC2RGBAUnormSRGB:
        return { width: 4, height: 4, length: 16 };
      case TextureFormat.BC4RUnorm:
      case TextureFormat.BC4RSnorm:
      case TextureFormat.BC1RGBAUnorm:
      case TextureFormat.BC1RGBAUnormSRGB:
        return { width: 4, height: 4, length: 8 };
      case TextureFormat.ETC2RGB8Unorm:
      case TextureFormat.ETC2RGB8UnormSRGB:
      case TextureFormat.ETC2RGB8A1Unorm:
      case TextureFormat.ETC2RGB8A1UnormSRGB:
      case TextureFormat.EACR11Unorm:
      case TextureFormat.EACR11Snorm:
        return { width: 4, height: 4, length: 8 };
      case TextureFormat.ETC2RGBA8Unorm:
      case TextureFormat.ETC2RGBA8UnormSRGB:
      case TextureFormat.EACRG11Unorm:
      case TextureFormat.EACRG11Snorm:
        return { width: 4, height: 4, length: 16 };
      case TextureFormat.ASTC4x4Unorm:
      case TextureFormat.ASTC4x4UnormSRGB:
        return { width: 4, height: 4, length: 16 };
      case TextureFormat.ASTC5x4Unorm:
      case TextureFormat.ASTC5x4UnormSRGB:
        return { width: 5, height: 4, length: 16 };
      case TextureFormat.ASTC5x5Unorm:
      case TextureFormat.ASTC5x5UnormSRGB:
        return { width: 5, height: 5, length: 16 };
      case TextureFormat.ASTC6x5Unorm:
      case TextureFormat.ASTC6x5UnormSRGB:
        return { width: 6, height: 5, length: 16 };
      case TextureFormat.ASTC6x6Unorm:
      case TextureFormat.ASTC6x6UnormSRGB:
        return { width: 6, height: 6, length: 16 };
      case TextureFormat.ASTC8x5Unorm:
      case TextureFormat.ASTC8x5UnormSRGB:
        return { width: 8, height: 5, length: 16 };
      case TextureFormat.ASTC8x6Unorm:
      case TextureFormat.ASTC8x6UnormSRGB:
        return { width: 8, height: 6, length: 16 };
      case TextureFormat.ASTC8x8Unorm:
      case TextureFormat.ASTC8x8UnormSRGB:
        return { width: 8, height: 8, length: 16 };
      case TextureFormat.ASTC10x5Unorm:
      case TextureFormat.ASTC10x5UnormSRGB:
        return { width: 10, height: 5, length: 16 };
      case TextureFormat.ASTC10x6Unorm:
      case TextureFormat.ASTC10x6UnormSRGB:
        return { width: 10, height: 6, length: 16 };
      case TextureFormat.ASTC10x8Unorm:
      case TextureFormat.ASTC10x8UnormSRGB:
        return { width: 10, height: 8, length: 16 };
      case TextureFormat.ASTC10x10Unorm:
      case TextureFormat.ASTC10x10UnormSRGB:
        return { width: 10, height: 10, length: 16 };
      case TextureFormat.ASTC12x10Unorm:
      case TextureFormat.ASTC12x10UnormSRGB:
        return { width: 12, height: 10, length: 16 };
      case TextureFormat.ASTC12x12Unorm:
      case TextureFormat.ASTC12x12UnormSRGB:
        return { width: 12, height: 12, length: 16 };
    }
    return { width: 1, height: 1, length: 4 };
  }
  static _IsHardwareTexture(texture) {
    return !!texture.release;
  }
  static _IsInternalTexture(texture) {
    return !!texture.dispose;
  }
  static IsImageBitmap(imageBitmap) {
    return imageBitmap.close !== void 0;
  }
  static IsImageBitmapArray(imageBitmap) {
    return Array.isArray(imageBitmap) && imageBitmap[0].close !== void 0;
  }
  setCommandEncoder(encoder) {
    this._commandEncoderForCreation = encoder;
  }
  static IsCompressedFormat(format) {
    switch (format) {
      case TextureFormat.BC7RGBAUnormSRGB:
      case TextureFormat.BC7RGBAUnorm:
      case TextureFormat.BC6HRGBFloat:
      case TextureFormat.BC6HRGBUFloat:
      case TextureFormat.BC5RGSnorm:
      case TextureFormat.BC5RGUnorm:
      case TextureFormat.BC4RSnorm:
      case TextureFormat.BC4RUnorm:
      case TextureFormat.BC3RGBAUnormSRGB:
      case TextureFormat.BC3RGBAUnorm:
      case TextureFormat.BC2RGBAUnormSRGB:
      case TextureFormat.BC2RGBAUnorm:
      case TextureFormat.BC1RGBAUnormSRGB:
      case TextureFormat.BC1RGBAUnorm:
      case TextureFormat.ETC2RGB8Unorm:
      case TextureFormat.ETC2RGB8UnormSRGB:
      case TextureFormat.ETC2RGB8A1Unorm:
      case TextureFormat.ETC2RGB8A1UnormSRGB:
      case TextureFormat.ETC2RGBA8Unorm:
      case TextureFormat.ETC2RGBA8UnormSRGB:
      case TextureFormat.EACR11Unorm:
      case TextureFormat.EACR11Snorm:
      case TextureFormat.EACRG11Unorm:
      case TextureFormat.EACRG11Snorm:
      case TextureFormat.ASTC4x4Unorm:
      case TextureFormat.ASTC4x4UnormSRGB:
      case TextureFormat.ASTC5x4Unorm:
      case TextureFormat.ASTC5x4UnormSRGB:
      case TextureFormat.ASTC5x5Unorm:
      case TextureFormat.ASTC5x5UnormSRGB:
      case TextureFormat.ASTC6x5Unorm:
      case TextureFormat.ASTC6x5UnormSRGB:
      case TextureFormat.ASTC6x6Unorm:
      case TextureFormat.ASTC6x6UnormSRGB:
      case TextureFormat.ASTC8x5Unorm:
      case TextureFormat.ASTC8x5UnormSRGB:
      case TextureFormat.ASTC8x6Unorm:
      case TextureFormat.ASTC8x6UnormSRGB:
      case TextureFormat.ASTC8x8Unorm:
      case TextureFormat.ASTC8x8UnormSRGB:
      case TextureFormat.ASTC10x5Unorm:
      case TextureFormat.ASTC10x5UnormSRGB:
      case TextureFormat.ASTC10x6Unorm:
      case TextureFormat.ASTC10x6UnormSRGB:
      case TextureFormat.ASTC10x8Unorm:
      case TextureFormat.ASTC10x8UnormSRGB:
      case TextureFormat.ASTC10x10Unorm:
      case TextureFormat.ASTC10x10UnormSRGB:
      case TextureFormat.ASTC12x10Unorm:
      case TextureFormat.ASTC12x10UnormSRGB:
      case TextureFormat.ASTC12x12Unorm:
      case TextureFormat.ASTC12x12UnormSRGB:
        return true;
    }
    return false;
  }
  static GetWebGPUTextureFormat(type, format, useSRGBBuffer = false) {
    switch (format) {
      case 15:
        return TextureFormat.Depth16Unorm;
      case 16:
        return TextureFormat.Depth24Plus;
      case 13:
        return TextureFormat.Depth24PlusStencil8;
      case 14:
        return TextureFormat.Depth32Float;
      case 17:
        return TextureFormat.Depth24UnormStencil8;
      case 18:
        return TextureFormat.Depth32FloatStencil8;
      case 36492:
        return useSRGBBuffer ? TextureFormat.BC7RGBAUnormSRGB : TextureFormat.BC7RGBAUnorm;
      case 36495:
        return TextureFormat.BC6HRGBUFloat;
      case 36494:
        return TextureFormat.BC6HRGBFloat;
      case 33779:
        return useSRGBBuffer ? TextureFormat.BC3RGBAUnormSRGB : TextureFormat.BC3RGBAUnorm;
      case 33778:
        return useSRGBBuffer ? TextureFormat.BC2RGBAUnormSRGB : TextureFormat.BC2RGBAUnorm;
      case 33777:
      case 33776:
        return useSRGBBuffer ? TextureFormat.BC1RGBAUnormSRGB : TextureFormat.BC1RGBAUnorm;
      case 37808:
        return useSRGBBuffer ? TextureFormat.ASTC4x4UnormSRGB : TextureFormat.ASTC4x4Unorm;
      case 36196:
      case 37492:
        return useSRGBBuffer ? TextureFormat.ETC2RGB8UnormSRGB : TextureFormat.ETC2RGB8Unorm;
      case 37496:
        return useSRGBBuffer ? TextureFormat.ETC2RGBA8UnormSRGB : TextureFormat.ETC2RGBA8Unorm;
    }
    switch (type) {
      case 3:
        switch (format) {
          case 6:
            return TextureFormat.R8Snorm;
          case 7:
            return TextureFormat.RG8Snorm;
          case 4:
            throw "RGB format not supported in WebGPU";
          case 8:
            return TextureFormat.R8Sint;
          case 9:
            return TextureFormat.RG8Sint;
          case 10:
            throw "RGB_INTEGER format not supported in WebGPU";
          case 11:
            return TextureFormat.RGBA8Sint;
          default:
            return TextureFormat.RGBA8Snorm;
        }
      case 0:
        switch (format) {
          case 6:
            return TextureFormat.R8Unorm;
          case 7:
            return TextureFormat.RG8Unorm;
          case 4:
            throw "TEXTUREFORMAT_RGB format not supported in WebGPU";
          case 5:
            return useSRGBBuffer ? TextureFormat.RGBA8UnormSRGB : TextureFormat.RGBA8Unorm;
          case 12:
            return useSRGBBuffer ? TextureFormat.BGRA8UnormSRGB : TextureFormat.BGRA8Unorm;
          case 8:
            return TextureFormat.R8Uint;
          case 9:
            return TextureFormat.RG8Uint;
          case 10:
            throw "RGB_INTEGER format not supported in WebGPU";
          case 11:
            return TextureFormat.RGBA8Uint;
          case 0:
            throw "TEXTUREFORMAT_ALPHA format not supported in WebGPU";
          case 1:
            throw "TEXTUREFORMAT_LUMINANCE format not supported in WebGPU";
          case 2:
            throw "TEXTUREFORMAT_LUMINANCE_ALPHA format not supported in WebGPU";
          default:
            return TextureFormat.RGBA8Unorm;
        }
      case 4:
        switch (format) {
          case 8:
            return TextureFormat.R16Sint;
          case 9:
            return TextureFormat.RG16Sint;
          case 10:
            throw "TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";
          case 11:
            return TextureFormat.RGBA16Sint;
          default:
            return TextureFormat.RGBA16Sint;
        }
      case 5:
        switch (format) {
          case 8:
            return TextureFormat.R16Uint;
          case 9:
            return TextureFormat.RG16Uint;
          case 10:
            throw "TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";
          case 11:
            return TextureFormat.RGBA16Uint;
          default:
            return TextureFormat.RGBA16Uint;
        }
      case 6:
        switch (format) {
          case 8:
            return TextureFormat.R32Sint;
          case 9:
            return TextureFormat.RG32Sint;
          case 10:
            throw "TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";
          case 11:
            return TextureFormat.RGBA32Sint;
          default:
            return TextureFormat.RGBA32Sint;
        }
      case 7:
        switch (format) {
          case 8:
            return TextureFormat.R32Uint;
          case 9:
            return TextureFormat.RG32Uint;
          case 10:
            throw "TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";
          case 11:
            return TextureFormat.RGBA32Uint;
          default:
            return TextureFormat.RGBA32Uint;
        }
      case 1:
        switch (format) {
          case 6:
            return TextureFormat.R32Float;
          case 7:
            return TextureFormat.RG32Float;
          case 4:
            throw "TEXTUREFORMAT_RGB format not supported in WebGPU";
          case 5:
            return TextureFormat.RGBA32Float;
          default:
            return TextureFormat.RGBA32Float;
        }
      case 2:
        switch (format) {
          case 6:
            return TextureFormat.R16Float;
          case 7:
            return TextureFormat.RG16Float;
          case 4:
            throw "TEXTUREFORMAT_RGB format not supported in WebGPU";
          case 5:
            return TextureFormat.RGBA16Float;
          default:
            return TextureFormat.RGBA16Float;
        }
      case 10:
        throw "TEXTURETYPE_UNSIGNED_SHORT_5_6_5 format not supported in WebGPU";
      case 13:
        throw "TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV format not supported in WebGPU";
      case 14:
        throw "TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV format not supported in WebGPU";
      case 8:
        throw "TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 format not supported in WebGPU";
      case 9:
        throw "TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 format not supported in WebGPU";
      case 11:
        switch (format) {
          case 5:
            return TextureFormat.RGB10A2Unorm;
          case 11:
            throw "TEXTUREFORMAT_RGBA_INTEGER format not supported in WebGPU when type is TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV";
          default:
            return TextureFormat.RGB10A2Unorm;
        }
    }
    return useSRGBBuffer ? TextureFormat.RGBA8UnormSRGB : TextureFormat.RGBA8Unorm;
  }
  static GetNumChannelsFromWebGPUTextureFormat(format) {
    switch (format) {
      case TextureFormat.R8Unorm:
      case TextureFormat.R8Snorm:
      case TextureFormat.R8Uint:
      case TextureFormat.R8Sint:
      case TextureFormat.BC4RUnorm:
      case TextureFormat.BC4RSnorm:
      case TextureFormat.R16Uint:
      case TextureFormat.R16Sint:
      case TextureFormat.Depth16Unorm:
      case TextureFormat.R16Float:
      case TextureFormat.R32Uint:
      case TextureFormat.R32Sint:
      case TextureFormat.R32Float:
      case TextureFormat.Depth32Float:
      case TextureFormat.Stencil8:
      case TextureFormat.Depth24Plus:
      case TextureFormat.EACR11Unorm:
      case TextureFormat.EACR11Snorm:
        return 1;
      case TextureFormat.RG8Unorm:
      case TextureFormat.RG8Snorm:
      case TextureFormat.RG8Uint:
      case TextureFormat.RG8Sint:
      case TextureFormat.Depth24UnormStencil8:
      case TextureFormat.Depth32FloatStencil8:
      case TextureFormat.BC5RGUnorm:
      case TextureFormat.BC5RGSnorm:
      case TextureFormat.RG16Uint:
      case TextureFormat.RG16Sint:
      case TextureFormat.RG16Float:
      case TextureFormat.RG32Uint:
      case TextureFormat.RG32Sint:
      case TextureFormat.RG32Float:
      case TextureFormat.Depth24PlusStencil8:
      case TextureFormat.EACRG11Unorm:
      case TextureFormat.EACRG11Snorm:
        return 2;
      case TextureFormat.RGB9E5UFloat:
      case TextureFormat.RG11B10UFloat:
      case TextureFormat.BC6HRGBUFloat:
      case TextureFormat.BC6HRGBFloat:
      case TextureFormat.ETC2RGB8Unorm:
      case TextureFormat.ETC2RGB8UnormSRGB:
        return 3;
      case TextureFormat.RGBA8Unorm:
      case TextureFormat.RGBA8UnormSRGB:
      case TextureFormat.RGBA8Snorm:
      case TextureFormat.RGBA8Uint:
      case TextureFormat.RGBA8Sint:
      case TextureFormat.BGRA8Unorm:
      case TextureFormat.BGRA8UnormSRGB:
      case TextureFormat.RGB10A2Unorm:
      case TextureFormat.BC7RGBAUnorm:
      case TextureFormat.BC7RGBAUnormSRGB:
      case TextureFormat.BC3RGBAUnorm:
      case TextureFormat.BC3RGBAUnormSRGB:
      case TextureFormat.BC2RGBAUnorm:
      case TextureFormat.BC2RGBAUnormSRGB:
      case TextureFormat.BC1RGBAUnorm:
      case TextureFormat.BC1RGBAUnormSRGB:
      case TextureFormat.RGBA16Uint:
      case TextureFormat.RGBA16Sint:
      case TextureFormat.RGBA16Float:
      case TextureFormat.RGBA32Uint:
      case TextureFormat.RGBA32Sint:
      case TextureFormat.RGBA32Float:
      case TextureFormat.ETC2RGB8A1Unorm:
      case TextureFormat.ETC2RGB8A1UnormSRGB:
      case TextureFormat.ETC2RGBA8Unorm:
      case TextureFormat.ETC2RGBA8UnormSRGB:
      case TextureFormat.ASTC4x4Unorm:
      case TextureFormat.ASTC4x4UnormSRGB:
      case TextureFormat.ASTC5x4Unorm:
      case TextureFormat.ASTC5x4UnormSRGB:
      case TextureFormat.ASTC5x5Unorm:
      case TextureFormat.ASTC5x5UnormSRGB:
      case TextureFormat.ASTC6x5Unorm:
      case TextureFormat.ASTC6x5UnormSRGB:
      case TextureFormat.ASTC6x6Unorm:
      case TextureFormat.ASTC6x6UnormSRGB:
      case TextureFormat.ASTC8x5Unorm:
      case TextureFormat.ASTC8x5UnormSRGB:
      case TextureFormat.ASTC8x6Unorm:
      case TextureFormat.ASTC8x6UnormSRGB:
      case TextureFormat.ASTC8x8Unorm:
      case TextureFormat.ASTC8x8UnormSRGB:
      case TextureFormat.ASTC10x5Unorm:
      case TextureFormat.ASTC10x5UnormSRGB:
      case TextureFormat.ASTC10x6Unorm:
      case TextureFormat.ASTC10x6UnormSRGB:
      case TextureFormat.ASTC10x8Unorm:
      case TextureFormat.ASTC10x8UnormSRGB:
      case TextureFormat.ASTC10x10Unorm:
      case TextureFormat.ASTC10x10UnormSRGB:
      case TextureFormat.ASTC12x10Unorm:
      case TextureFormat.ASTC12x10UnormSRGB:
      case TextureFormat.ASTC12x12Unorm:
      case TextureFormat.ASTC12x12UnormSRGB:
        return 4;
    }
    throw `Unknown format ${format}!`;
  }
  static HasStencilAspect(format) {
    switch (format) {
      case TextureFormat.Stencil8:
      case TextureFormat.Depth24UnormStencil8:
      case TextureFormat.Depth32FloatStencil8:
      case TextureFormat.Depth24PlusStencil8:
        return true;
    }
    return false;
  }
  static HasDepthAndStencilAspects(format) {
    switch (format) {
      case TextureFormat.Depth24UnormStencil8:
      case TextureFormat.Depth32FloatStencil8:
      case TextureFormat.Depth24PlusStencil8:
        return true;
    }
    return false;
  }
  copyVideoToTexture(video, texture, format, invertY = false, commandEncoder) {
    var _a, _b, _c, _d;
    const useOwnCommandEncoder = commandEncoder === void 0;
    const [pipeline, bindGroupLayout] = this._getVideoPipeline(format, invertY ? VideoPipelineType.InvertY : VideoPipelineType.DontInvertY);
    if (useOwnCommandEncoder) {
      commandEncoder = this._device.createCommandEncoder({});
    }
    (_b = (_a = commandEncoder).pushDebugGroup) === null || _b === void 0 ? void 0 : _b.call(_a, `copy video to texture - invertY=${invertY}`);
    const webgpuHardwareTexture = texture._hardwareTexture;
    const renderPassDescriptor = {
      colorAttachments: [
        {
          view: webgpuHardwareTexture.underlyingResource.createView({
            format,
            dimension: TextureViewDimension.E2d,
            mipLevelCount: 1,
            baseArrayLayer: 0,
            baseMipLevel: 0,
            arrayLayerCount: 1,
            aspect: TextureAspect.All
          }),
          loadOp: LoadOp.Load,
          storeOp: StoreOp.Store
        }
      ]
    };
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    const descriptor = {
      layout: bindGroupLayout,
      entries: [
        {
          binding: 0,
          resource: this._videoSampler
        },
        {
          binding: 1,
          resource: this._device.importExternalTexture({
            source: video.underlyingResource
          })
        }
      ]
    };
    const bindGroup = this._device.createBindGroup(descriptor);
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(0, bindGroup);
    passEncoder.draw(4, 1, 0, 0);
    passEncoder.end();
    (_d = (_c = commandEncoder).popDebugGroup) === null || _d === void 0 ? void 0 : _d.call(_c);
    if (useOwnCommandEncoder) {
      this._device.queue.submit([commandEncoder.finish()]);
      commandEncoder = null;
    }
  }
  invertYPreMultiplyAlpha(gpuOrHdwTexture, width, height, format, invertY = false, premultiplyAlpha = false, faceIndex = 0, mipLevel = 0, layers = 1, ofstX = 0, ofstY = 0, rectWidth = 0, rectHeight = 0, commandEncoder, allowGPUOptimization) {
    var _a, _b, _c, _d, _e, _f;
    const useRect = rectWidth !== 0;
    const useOwnCommandEncoder = commandEncoder === void 0;
    const [pipeline, bindGroupLayout] = this._getPipeline(format, useRect ? PipelineType.InvertYPremultiplyAlphaWithOfst : PipelineType.InvertYPremultiplyAlpha, {
      invertY,
      premultiplyAlpha
    });
    faceIndex = Math.max(faceIndex, 0);
    if (useOwnCommandEncoder) {
      commandEncoder = this._device.createCommandEncoder({});
    }
    (_b = (_a = commandEncoder).pushDebugGroup) === null || _b === void 0 ? void 0 : _b.call(_a, `internal process texture - invertY=${invertY} premultiplyAlpha=${premultiplyAlpha}`);
    let gpuTexture;
    if (WebGPUTextureHelper._IsHardwareTexture(gpuOrHdwTexture)) {
      gpuTexture = gpuOrHdwTexture.underlyingResource;
      if (!(invertY && !premultiplyAlpha && layers === 1 && faceIndex === 0)) {
        gpuOrHdwTexture = void 0;
      }
    } else {
      gpuTexture = gpuOrHdwTexture;
      gpuOrHdwTexture = void 0;
    }
    if (!gpuTexture) {
      return;
    }
    if (useRect) {
      this._bufferManager.setRawData(this._ubCopyWithOfst, 0, new Float32Array([ofstX, ofstY, rectWidth, rectHeight]), 0, 4 * 4);
    }
    const webgpuHardwareTexture = gpuOrHdwTexture;
    const outputTexture = (_c = webgpuHardwareTexture === null || webgpuHardwareTexture === void 0 ? void 0 : webgpuHardwareTexture._copyInvertYTempTexture) !== null && _c !== void 0 ? _c : this.createTexture({ width, height, layers: 1 }, false, false, false, false, false, format, 1, commandEncoder, TextureUsage.CopySrc | TextureUsage.RenderAttachment | TextureUsage.TextureBinding);
    const renderPassDescriptor = (_d = webgpuHardwareTexture === null || webgpuHardwareTexture === void 0 ? void 0 : webgpuHardwareTexture._copyInvertYRenderPassDescr) !== null && _d !== void 0 ? _d : {
      colorAttachments: [
        {
          view: outputTexture.createView({
            format,
            dimension: TextureViewDimension.E2d,
            baseMipLevel: 0,
            mipLevelCount: 1,
            arrayLayerCount: 1,
            baseArrayLayer: 0
          }),
          loadOp: LoadOp.Load,
          storeOp: StoreOp.Store
        }
      ]
    };
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    let bindGroup = useRect ? webgpuHardwareTexture === null || webgpuHardwareTexture === void 0 ? void 0 : webgpuHardwareTexture._copyInvertYBindGroupWithOfst : webgpuHardwareTexture === null || webgpuHardwareTexture === void 0 ? void 0 : webgpuHardwareTexture._copyInvertYBindGroup;
    if (!bindGroup) {
      const descriptor = {
        layout: bindGroupLayout,
        entries: [
          {
            binding: 0,
            resource: gpuTexture.createView({
              format,
              dimension: TextureViewDimension.E2d,
              baseMipLevel: mipLevel,
              mipLevelCount: 1,
              arrayLayerCount: layers,
              baseArrayLayer: faceIndex
            })
          }
        ]
      };
      if (useRect) {
        descriptor.entries.push({
          binding: 1,
          resource: {
            buffer: this._ubCopyWithOfst
          }
        });
      }
      bindGroup = this._device.createBindGroup(descriptor);
    }
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(0, bindGroup);
    passEncoder.draw(4, 1, 0, 0);
    passEncoder.end();
    commandEncoder.copyTextureToTexture({
      texture: outputTexture
    }, {
      texture: gpuTexture,
      mipLevel,
      origin: {
        x: 0,
        y: 0,
        z: faceIndex
      }
    }, {
      width,
      height,
      depthOrArrayLayers: 1
    });
    if (webgpuHardwareTexture) {
      webgpuHardwareTexture._copyInvertYTempTexture = outputTexture;
      webgpuHardwareTexture._copyInvertYRenderPassDescr = renderPassDescriptor;
      if (useRect) {
        webgpuHardwareTexture._copyInvertYBindGroupWithOfst = bindGroup;
      } else {
        webgpuHardwareTexture._copyInvertYBindGroup = bindGroup;
      }
    } else {
      this._deferredReleaseTextures.push([outputTexture, null]);
    }
    (_f = (_e = commandEncoder).popDebugGroup) === null || _f === void 0 ? void 0 : _f.call(_e);
    if (useOwnCommandEncoder) {
      this._device.queue.submit([commandEncoder.finish()]);
      commandEncoder = null;
    }
  }
  copyWithInvertY(srcTextureView, format, renderPassDescriptor, commandEncoder) {
    var _a, _b, _c, _d;
    const useOwnCommandEncoder = commandEncoder === void 0;
    const [pipeline, bindGroupLayout] = this._getPipeline(format, PipelineType.InvertYPremultiplyAlpha, { invertY: true, premultiplyAlpha: false });
    if (useOwnCommandEncoder) {
      commandEncoder = this._device.createCommandEncoder({});
    }
    (_b = (_a = commandEncoder).pushDebugGroup) === null || _b === void 0 ? void 0 : _b.call(_a, `internal copy texture with invertY`);
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    const bindGroup = this._device.createBindGroup({
      layout: bindGroupLayout,
      entries: [
        {
          binding: 0,
          resource: srcTextureView
        }
      ]
    });
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(0, bindGroup);
    passEncoder.draw(4, 1, 0, 0);
    passEncoder.end();
    (_d = (_c = commandEncoder).popDebugGroup) === null || _d === void 0 ? void 0 : _d.call(_c);
    if (useOwnCommandEncoder) {
      this._device.queue.submit([commandEncoder.finish()]);
      commandEncoder = null;
    }
  }
  createTexture(imageBitmap, hasMipmaps = false, generateMipmaps = false, invertY = false, premultiplyAlpha = false, is3D = false, format = TextureFormat.RGBA8Unorm, sampleCount = 1, commandEncoder, usage = -1, additionalUsages = 0) {
    if (sampleCount > 1) {
      sampleCount = 4;
    }
    const layerCount = imageBitmap.layers || 1;
    const textureSize = {
      width: imageBitmap.width,
      height: imageBitmap.height,
      depthOrArrayLayers: layerCount
    };
    const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);
    const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(imageBitmap.width, imageBitmap.height) : 1;
    const usages = usage >= 0 ? usage : TextureUsage.CopySrc | TextureUsage.CopyDst | TextureUsage.TextureBinding;
    additionalUsages |= hasMipmaps && !isCompressedFormat ? TextureUsage.CopySrc | TextureUsage.RenderAttachment : 0;
    if (!isCompressedFormat && !is3D) {
      additionalUsages |= TextureUsage.RenderAttachment | TextureUsage.CopyDst;
    }
    const gpuTexture = this._device.createTexture({
      label: `Texture_${textureSize.width}x${textureSize.height}x${textureSize.depthOrArrayLayers}_${hasMipmaps ? "wmips" : "womips"}_${format}_samples${sampleCount}`,
      size: textureSize,
      dimension: is3D ? TextureDimension.E3d : TextureDimension.E2d,
      format,
      usage: usages | additionalUsages,
      sampleCount,
      mipLevelCount
    });
    if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {
      this.updateTexture(imageBitmap, gpuTexture, imageBitmap.width, imageBitmap.height, layerCount, format, 0, 0, invertY, premultiplyAlpha, 0, 0);
      if (hasMipmaps && generateMipmaps) {
        this.generateMipmaps(gpuTexture, format, mipLevelCount, 0, commandEncoder);
      }
    }
    return gpuTexture;
  }
  createCubeTexture(imageBitmaps, hasMipmaps = false, generateMipmaps = false, invertY = false, premultiplyAlpha = false, format = TextureFormat.RGBA8Unorm, sampleCount = 1, commandEncoder, usage = -1, additionalUsages = 0) {
    if (sampleCount > 1) {
      sampleCount = 4;
    }
    const width = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].width : imageBitmaps.width;
    const height = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].height : imageBitmaps.height;
    const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);
    const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width, height) : 1;
    const usages = usage >= 0 ? usage : TextureUsage.CopySrc | TextureUsage.CopyDst | TextureUsage.TextureBinding;
    additionalUsages |= hasMipmaps && !isCompressedFormat ? TextureUsage.CopySrc | TextureUsage.RenderAttachment : 0;
    if (!isCompressedFormat) {
      additionalUsages |= TextureUsage.RenderAttachment | TextureUsage.CopyDst;
    }
    const gpuTexture = this._device.createTexture({
      label: `TextureCube_${width}x${height}x6_${hasMipmaps ? "wmips" : "womips"}_${format}_samples${sampleCount}`,
      size: {
        width,
        height,
        depthOrArrayLayers: 6
      },
      dimension: TextureDimension.E2d,
      format,
      usage: usages | additionalUsages,
      sampleCount,
      mipLevelCount
    });
    if (WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps)) {
      this.updateCubeTextures(imageBitmaps, gpuTexture, width, height, format, invertY, premultiplyAlpha, 0, 0);
      if (hasMipmaps && generateMipmaps) {
        this.generateCubeMipmaps(gpuTexture, format, mipLevelCount, commandEncoder);
      }
    }
    return gpuTexture;
  }
  generateCubeMipmaps(gpuTexture, format, mipLevelCount, commandEncoder) {
    var _a, _b, _c, _d;
    const useOwnCommandEncoder = commandEncoder === void 0;
    if (useOwnCommandEncoder) {
      commandEncoder = this._device.createCommandEncoder({});
    }
    (_b = (_a = commandEncoder).pushDebugGroup) === null || _b === void 0 ? void 0 : _b.call(_a, `create cube mipmaps - ${mipLevelCount} levels`);
    for (let f = 0; f < 6; ++f) {
      this.generateMipmaps(gpuTexture, format, mipLevelCount, f, commandEncoder);
    }
    (_d = (_c = commandEncoder).popDebugGroup) === null || _d === void 0 ? void 0 : _d.call(_c);
    if (useOwnCommandEncoder) {
      this._device.queue.submit([commandEncoder.finish()]);
      commandEncoder = null;
    }
  }
  generateMipmaps(gpuOrHdwTexture, format, mipLevelCount, faceIndex = 0, commandEncoder) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const useOwnCommandEncoder = commandEncoder === void 0;
    const [pipeline, bindGroupLayout] = this._getPipeline(format);
    faceIndex = Math.max(faceIndex, 0);
    if (useOwnCommandEncoder) {
      commandEncoder = this._device.createCommandEncoder({});
    }
    (_b = (_a = commandEncoder).pushDebugGroup) === null || _b === void 0 ? void 0 : _b.call(_a, `create mipmaps for face #${faceIndex} - ${mipLevelCount} levels`);
    let gpuTexture;
    if (WebGPUTextureHelper._IsHardwareTexture(gpuOrHdwTexture)) {
      gpuTexture = gpuOrHdwTexture.underlyingResource;
      gpuOrHdwTexture._mipmapGenRenderPassDescr = gpuOrHdwTexture._mipmapGenRenderPassDescr || [];
      gpuOrHdwTexture._mipmapGenBindGroup = gpuOrHdwTexture._mipmapGenBindGroup || [];
    } else {
      gpuTexture = gpuOrHdwTexture;
      gpuOrHdwTexture = void 0;
    }
    if (!gpuTexture) {
      return;
    }
    const webgpuHardwareTexture = gpuOrHdwTexture;
    for (let i = 1; i < mipLevelCount; ++i) {
      const renderPassDescriptor = (_d = (_c = webgpuHardwareTexture === null || webgpuHardwareTexture === void 0 ? void 0 : webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex]) === null || _c === void 0 ? void 0 : _c[i - 1]) !== null && _d !== void 0 ? _d : {
        colorAttachments: [
          {
            view: gpuTexture.createView({
              format,
              dimension: TextureViewDimension.E2d,
              baseMipLevel: i,
              mipLevelCount: 1,
              arrayLayerCount: 1,
              baseArrayLayer: faceIndex
            }),
            loadOp: LoadOp.Load,
            storeOp: StoreOp.Store
          }
        ]
      };
      if (webgpuHardwareTexture) {
        webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] = webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] || [];
        webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex][i - 1] = renderPassDescriptor;
      }
      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      const bindGroup = (_f = (_e = webgpuHardwareTexture === null || webgpuHardwareTexture === void 0 ? void 0 : webgpuHardwareTexture._mipmapGenBindGroup[faceIndex]) === null || _e === void 0 ? void 0 : _e[i - 1]) !== null && _f !== void 0 ? _f : this._device.createBindGroup({
        layout: bindGroupLayout,
        entries: [
          {
            binding: 0,
            resource: this._mipmapSampler
          },
          {
            binding: 1,
            resource: gpuTexture.createView({
              format,
              dimension: TextureViewDimension.E2d,
              baseMipLevel: i - 1,
              mipLevelCount: 1,
              arrayLayerCount: 1,
              baseArrayLayer: faceIndex
            })
          }
        ]
      });
      if (webgpuHardwareTexture) {
        webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] = webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] || [];
        webgpuHardwareTexture._mipmapGenBindGroup[faceIndex][i - 1] = bindGroup;
      }
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(4, 1, 0, 0);
      passEncoder.end();
    }
    (_h = (_g = commandEncoder).popDebugGroup) === null || _h === void 0 ? void 0 : _h.call(_g);
    if (useOwnCommandEncoder) {
      this._device.queue.submit([commandEncoder.finish()]);
      commandEncoder = null;
    }
  }
  createGPUTextureForInternalTexture(texture, width, height, depth, creationFlags) {
    if (!texture._hardwareTexture) {
      texture._hardwareTexture = new WebGPUHardwareTexture();
    }
    if (width === void 0) {
      width = texture.width;
    }
    if (height === void 0) {
      height = texture.height;
    }
    if (depth === void 0) {
      depth = texture.depth;
    }
    const gpuTextureWrapper = texture._hardwareTexture;
    const isStorageTexture = ((creationFlags !== null && creationFlags !== void 0 ? creationFlags : 0) & 1) !== 0;
    gpuTextureWrapper.format = WebGPUTextureHelper.GetWebGPUTextureFormat(texture.type, texture.format, texture._useSRGBBuffer);
    gpuTextureWrapper.textureUsages = texture._source === InternalTextureSource.RenderTarget || texture.source === InternalTextureSource.MultiRenderTarget ? TextureUsage.TextureBinding | TextureUsage.CopySrc | TextureUsage.RenderAttachment : texture._source === InternalTextureSource.DepthStencil ? TextureUsage.TextureBinding | TextureUsage.RenderAttachment : -1;
    gpuTextureWrapper.textureAdditionalUsages = isStorageTexture ? TextureUsage.StorageBinding : 0;
    const hasMipMaps = texture.generateMipMaps;
    const layerCount = depth || 1;
    let mipmapCount;
    if (texture._maxLodLevel !== null) {
      mipmapCount = texture._maxLodLevel;
    } else {
      mipmapCount = hasMipMaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width, height) : 1;
    }
    if (texture.isCube) {
      const gpuTexture = this.createCubeTexture({ width, height }, texture.generateMipMaps, texture.generateMipMaps, texture.invertY, false, gpuTextureWrapper.format, 1, this._commandEncoderForCreation, gpuTextureWrapper.textureUsages, gpuTextureWrapper.textureAdditionalUsages);
      gpuTextureWrapper.set(gpuTexture);
      gpuTextureWrapper.createView({
        format: gpuTextureWrapper.format,
        dimension: TextureViewDimension.Cube,
        mipLevelCount: mipmapCount,
        baseArrayLayer: 0,
        baseMipLevel: 0,
        arrayLayerCount: 6,
        aspect: WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? TextureAspect.DepthOnly : TextureAspect.All
      }, isStorageTexture);
    } else {
      const gpuTexture = this.createTexture({ width, height, layers: layerCount }, texture.generateMipMaps, texture.generateMipMaps, texture.invertY, false, texture.is3D, gpuTextureWrapper.format, 1, this._commandEncoderForCreation, gpuTextureWrapper.textureUsages, gpuTextureWrapper.textureAdditionalUsages);
      gpuTextureWrapper.set(gpuTexture);
      gpuTextureWrapper.createView({
        format: gpuTextureWrapper.format,
        dimension: texture.is2DArray ? TextureViewDimension.E2dArray : texture.is3D ? TextureDimension.E3d : TextureViewDimension.E2d,
        mipLevelCount: mipmapCount,
        baseArrayLayer: 0,
        baseMipLevel: 0,
        arrayLayerCount: texture.is3D ? 1 : layerCount,
        aspect: WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? TextureAspect.DepthOnly : TextureAspect.All
      }, isStorageTexture);
    }
    texture.width = texture.baseWidth = width;
    texture.height = texture.baseHeight = height;
    texture.depth = texture.baseDepth = depth;
    this.createMSAATexture(texture, texture.samples);
    return gpuTextureWrapper;
  }
  createMSAATexture(texture, samples) {
    const gpuTextureWrapper = texture._hardwareTexture;
    if (gpuTextureWrapper === null || gpuTextureWrapper === void 0 ? void 0 : gpuTextureWrapper.msaaTexture) {
      this.releaseTexture(gpuTextureWrapper.msaaTexture);
      gpuTextureWrapper.msaaTexture = null;
    }
    if (!gpuTextureWrapper || (samples !== null && samples !== void 0 ? samples : 1) <= 1) {
      return;
    }
    const width = texture.width;
    const height = texture.height;
    const layerCount = texture.depth || 1;
    if (texture.isCube) {
      const gpuMSAATexture = this.createCubeTexture({ width, height }, false, false, texture.invertY, false, gpuTextureWrapper.format, samples, this._commandEncoderForCreation, gpuTextureWrapper.textureUsages, gpuTextureWrapper.textureAdditionalUsages);
      gpuTextureWrapper.msaaTexture = gpuMSAATexture;
    } else {
      const gpuMSAATexture = this.createTexture({ width, height, layers: layerCount }, false, false, texture.invertY, false, texture.is3D, gpuTextureWrapper.format, samples, this._commandEncoderForCreation, gpuTextureWrapper.textureUsages, gpuTextureWrapper.textureAdditionalUsages);
      gpuTextureWrapper.msaaTexture = gpuMSAATexture;
    }
  }
  updateCubeTextures(imageBitmaps, gpuTexture, width, height, format, invertY = false, premultiplyAlpha = false, offsetX = 0, offsetY = 0) {
    const faces = [0, 3, 1, 4, 2, 5];
    for (let f = 0; f < faces.length; ++f) {
      const imageBitmap = imageBitmaps[faces[f]];
      this.updateTexture(imageBitmap, gpuTexture, width, height, 1, format, f, 0, invertY, premultiplyAlpha, offsetX, offsetY);
    }
  }
  updateTexture(imageBitmap, texture, width, height, layers, format, faceIndex = 0, mipLevel = 0, invertY = false, premultiplyAlpha = false, offsetX = 0, offsetY = 0, allowGPUOptimization) {
    const gpuTexture = WebGPUTextureHelper._IsInternalTexture(texture) ? texture._hardwareTexture.underlyingResource : texture;
    const blockInformation = WebGPUTextureHelper._GetBlockInformationFromFormat(format);
    const gpuOrHdwTexture = WebGPUTextureHelper._IsInternalTexture(texture) ? texture._hardwareTexture : texture;
    const textureCopyView = {
      texture: gpuTexture,
      origin: {
        x: offsetX,
        y: offsetY,
        z: Math.max(faceIndex, 0)
      },
      mipLevel,
      premultipliedAlpha: premultiplyAlpha
    };
    const textureExtent = {
      width: Math.ceil(width / blockInformation.width) * blockInformation.width,
      height: Math.ceil(height / blockInformation.height) * blockInformation.height,
      depthOrArrayLayers: layers || 1
    };
    if (imageBitmap.byteLength !== void 0) {
      imageBitmap = imageBitmap;
      const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;
      const aligned = Math.ceil(bytesPerRow / 256) * 256 === bytesPerRow;
      if (aligned) {
        const commandEncoder = this._device.createCommandEncoder({});
        const buffer = this._bufferManager.createRawBuffer(imageBitmap.byteLength, BufferUsage.MapWrite | BufferUsage.CopySrc, true);
        const arrayBuffer = buffer.getMappedRange();
        new Uint8Array(arrayBuffer).set(imageBitmap);
        buffer.unmap();
        commandEncoder.copyBufferToTexture({
          buffer,
          offset: 0,
          bytesPerRow,
          rowsPerImage: height
        }, textureCopyView, textureExtent);
        this._device.queue.submit([commandEncoder.finish()]);
        this._bufferManager.releaseBuffer(buffer);
      } else {
        this._device.queue.writeTexture(textureCopyView, imageBitmap, {
          offset: 0,
          bytesPerRow,
          rowsPerImage: height
        }, textureExtent);
      }
      if (invertY || premultiplyAlpha) {
        if (WebGPUTextureHelper._IsInternalTexture(texture)) {
          const dontUseRect = offsetX === 0 && offsetY === 0 && width === texture.width && height === texture.height;
          this.invertYPreMultiplyAlpha(gpuOrHdwTexture, texture.width, texture.height, format, invertY, premultiplyAlpha, faceIndex, mipLevel, layers || 1, offsetX, offsetY, dontUseRect ? 0 : width, dontUseRect ? 0 : height, void 0, allowGPUOptimization);
        } else {
          throw "updateTexture: Can't process the texture data because a GPUTexture was provided instead of an InternalTexture!";
        }
      }
    } else {
      imageBitmap = imageBitmap;
      if (invertY) {
        textureCopyView.premultipliedAlpha = false;
        if (WebGPUTextureHelper._IsInternalTexture(texture) && offsetX === 0 && offsetY === 0 && width === texture.width && height === texture.height) {
          this._device.queue.copyExternalImageToTexture({ source: imageBitmap }, textureCopyView, textureExtent);
          this.invertYPreMultiplyAlpha(gpuOrHdwTexture, width, height, format, invertY, premultiplyAlpha, faceIndex, mipLevel, layers || 1, 0, 0, 0, 0, void 0, allowGPUOptimization);
        } else {
          const commandEncoder = this._device.createCommandEncoder({});
          const srcTexture = this.createTexture({ width, height, layers: 1 }, false, false, false, false, false, format, 1, commandEncoder, TextureUsage.CopySrc | TextureUsage.TextureBinding);
          this._deferredReleaseTextures.push([srcTexture, null]);
          textureExtent.depthOrArrayLayers = 1;
          this._device.queue.copyExternalImageToTexture({ source: imageBitmap }, { texture: srcTexture }, textureExtent);
          textureExtent.depthOrArrayLayers = layers || 1;
          this.invertYPreMultiplyAlpha(srcTexture, width, height, format, invertY, premultiplyAlpha, faceIndex, mipLevel, layers || 1, 0, 0, 0, 0, commandEncoder, allowGPUOptimization);
          commandEncoder.copyTextureToTexture({ texture: srcTexture }, textureCopyView, textureExtent);
          this._device.queue.submit([commandEncoder.finish()]);
        }
      } else {
        this._device.queue.copyExternalImageToTexture({ source: imageBitmap }, textureCopyView, textureExtent);
      }
    }
  }
  readPixels(texture, x, y, width, height, format, faceIndex = 0, mipLevel = 0, buffer = null, noDataConversion = false) {
    const blockInformation = WebGPUTextureHelper._GetBlockInformationFromFormat(format);
    const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;
    const bytesPerRowAligned = Math.ceil(bytesPerRow / 256) * 256;
    const size = bytesPerRowAligned * height;
    const gpuBuffer = this._bufferManager.createRawBuffer(size, BufferUsage.MapRead | BufferUsage.CopyDst);
    const commandEncoder = this._device.createCommandEncoder({});
    commandEncoder.copyTextureToBuffer({
      texture,
      mipLevel,
      origin: {
        x,
        y,
        z: Math.max(faceIndex, 0)
      }
    }, {
      buffer: gpuBuffer,
      offset: 0,
      bytesPerRow: bytesPerRowAligned
    }, {
      width,
      height,
      depthOrArrayLayers: 1
    });
    this._device.queue.submit([commandEncoder.finish()]);
    return this._bufferManager.readDataFromBuffer(gpuBuffer, size, width, height, bytesPerRow, bytesPerRowAligned, WebGPUTextureHelper._GetTextureTypeFromFormat(format), 0, buffer, true, noDataConversion);
  }
  releaseTexture(texture) {
    if (WebGPUTextureHelper._IsInternalTexture(texture)) {
      const hardwareTexture = texture._hardwareTexture;
      const irradianceTexture = texture._irradianceTexture;
      this._deferredReleaseTextures.push([hardwareTexture, irradianceTexture]);
    } else {
      this._deferredReleaseTextures.push([texture, null]);
    }
  }
  destroyDeferredTextures() {
    for (let i = 0; i < this._deferredReleaseTextures.length; ++i) {
      const [hardwareTexture, irradianceTexture] = this._deferredReleaseTextures[i];
      if (hardwareTexture) {
        if (WebGPUTextureHelper._IsHardwareTexture(hardwareTexture)) {
          hardwareTexture.release();
        } else {
          hardwareTexture.destroy();
        }
      }
      irradianceTexture === null || irradianceTexture === void 0 ? void 0 : irradianceTexture.dispose();
    }
    this._deferredReleaseTextures.length = 0;
  }
};

// node_modules/@babylonjs/core/Meshes/WebGPU/webgpuDataBuffer.js
var WebGPUDataBuffer = class extends DataBuffer {
  constructor(resource) {
    super();
    this._buffer = resource;
  }
  get underlyingResource() {
    return this._buffer;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuBufferManager.js
var WebGPUBufferManager = class {
  constructor(device) {
    this._deferredReleaseBuffers = [];
    this._device = device;
  }
  static _IsGPUBuffer(buffer) {
    return buffer.underlyingResource === void 0;
  }
  createRawBuffer(viewOrSize, flags, mappedAtCreation = false) {
    const alignedLength = viewOrSize.byteLength !== void 0 ? viewOrSize.byteLength + 3 & ~3 : viewOrSize + 3 & ~3;
    const verticesBufferDescriptor = {
      mappedAtCreation,
      size: alignedLength,
      usage: flags
    };
    return this._device.createBuffer(verticesBufferDescriptor);
  }
  createBuffer(viewOrSize, flags) {
    const isView = viewOrSize.byteLength !== void 0;
    const buffer = this.createRawBuffer(viewOrSize, flags);
    const dataBuffer = new WebGPUDataBuffer(buffer);
    dataBuffer.references = 1;
    dataBuffer.capacity = isView ? viewOrSize.byteLength : viewOrSize;
    if (isView) {
      this.setSubData(dataBuffer, 0, viewOrSize);
    }
    return dataBuffer;
  }
  setRawData(buffer, dstByteOffset, src, srcByteOffset, byteLength) {
    this._device.queue.writeBuffer(buffer, dstByteOffset, src.buffer, srcByteOffset, byteLength);
  }
  setSubData(dataBuffer, dstByteOffset, src, srcByteOffset = 0, byteLength = 0) {
    const buffer = dataBuffer.underlyingResource;
    byteLength = byteLength || src.byteLength;
    byteLength = Math.min(byteLength, dataBuffer.capacity - dstByteOffset);
    let chunkStart = src.byteOffset + srcByteOffset;
    let chunkEnd = chunkStart + byteLength;
    const alignedLength = byteLength + 3 & ~3;
    if (alignedLength !== byteLength) {
      const tempView = new Uint8Array(src.buffer.slice(chunkStart, chunkEnd));
      src = new Uint8Array(alignedLength);
      src.set(tempView);
      srcByteOffset = 0;
      chunkStart = 0;
      chunkEnd = alignedLength;
      byteLength = alignedLength;
    }
    const maxChunk = 1024 * 1024 * 15;
    let offset = 0;
    while (chunkEnd - (chunkStart + offset) > maxChunk) {
      this._device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, maxChunk);
      offset += maxChunk;
    }
    this._device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, byteLength - offset);
  }
  _getHalfFloatAsFloatRGBAArrayBuffer(dataLength, arrayBuffer, destArray) {
    if (!destArray) {
      destArray = new Float32Array(dataLength);
    }
    const srcData = new Uint16Array(arrayBuffer);
    while (dataLength--) {
      destArray[dataLength] = FromHalfFloat(srcData[dataLength]);
    }
    return destArray;
  }
  readDataFromBuffer(gpuBuffer, size, width, height, bytesPerRow, bytesPerRowAligned, type = 0, offset = 0, buffer = null, destroyBuffer = true, noDataConversion = false) {
    const floatFormat = type === 1 ? 2 : type === 2 ? 1 : 0;
    return new Promise((resolve, reject) => {
      gpuBuffer.mapAsync(MapMode.Read, offset, size).then(() => {
        const copyArrayBuffer = gpuBuffer.getMappedRange(offset, size);
        let data = buffer;
        if (noDataConversion) {
          if (data === null) {
            data = allocateAndCopyTypedBuffer(type, size, true, copyArrayBuffer);
          } else {
            data = allocateAndCopyTypedBuffer(type, data.buffer, void 0, copyArrayBuffer);
          }
        } else {
          if (data === null) {
            switch (floatFormat) {
              case 0:
                data = new Uint8Array(size);
                data.set(new Uint8Array(copyArrayBuffer));
                break;
              case 1:
                data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer);
                break;
              case 2:
                data = new Float32Array(size / 4);
                data.set(new Float32Array(copyArrayBuffer));
                break;
            }
          } else {
            switch (floatFormat) {
              case 0:
                data = new Uint8Array(data.buffer);
                data.set(new Uint8Array(copyArrayBuffer));
                break;
              case 1:
                data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer, buffer);
                break;
              case 2:
                data = new Float32Array(data.buffer);
                data.set(new Float32Array(copyArrayBuffer));
                break;
            }
          }
        }
        if (bytesPerRow !== bytesPerRowAligned) {
          if (floatFormat === 1 && !noDataConversion) {
            bytesPerRow *= 2;
            bytesPerRowAligned *= 2;
          }
          const data2 = new Uint8Array(data.buffer);
          let offset2 = bytesPerRow, offset22 = 0;
          for (let y = 1; y < height; ++y) {
            offset22 = y * bytesPerRowAligned;
            for (let x = 0; x < bytesPerRow; ++x) {
              data2[offset2++] = data2[offset22++];
            }
          }
          if (floatFormat !== 0 && !noDataConversion) {
            data = new Float32Array(data2.buffer, 0, offset2 / 4);
          } else {
            data = new Uint8Array(data2.buffer, 0, offset2);
          }
        }
        gpuBuffer.unmap();
        if (destroyBuffer) {
          this.releaseBuffer(gpuBuffer);
        }
        resolve(data);
      }, (reason) => reject(reason));
    });
  }
  releaseBuffer(buffer) {
    if (WebGPUBufferManager._IsGPUBuffer(buffer)) {
      this._deferredReleaseBuffers.push(buffer);
      return true;
    }
    buffer.references--;
    if (buffer.references === 0) {
      this._deferredReleaseBuffers.push(buffer.underlyingResource);
      return true;
    }
    return false;
  }
  destroyDeferredBuffers() {
    for (let i = 0; i < this._deferredReleaseBuffers.length; ++i) {
      this._deferredReleaseBuffers[i].destroy();
    }
    this._deferredReleaseBuffers.length = 0;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuRenderPassWrapper.js
var WebGPURenderPassWrapper = class {
  constructor() {
    this.colorAttachmentGPUTextures = [];
    this.reset();
  }
  reset(fullReset = false) {
    this.renderPass = null;
    if (fullReset) {
      this.renderPassDescriptor = null;
      this.colorAttachmentViewDescriptor = null;
      this.depthAttachmentViewDescriptor = null;
      this.colorAttachmentGPUTextures = [];
      this.depthTextureFormat = void 0;
    }
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuCacheSampler.js
var filterToBits = [
  0 | 0 << 1 | 0 << 2,
  0 | 0 << 1 | 0 << 2,
  1 | 1 << 1 | 0 << 2,
  1 | 1 << 1 | 1 << 2,
  0 | 0 << 1 | 0 << 2,
  0 | 1 << 1 | 0 << 2,
  0 | 1 << 1 | 1 << 2,
  0 | 1 << 1 | 0 << 2,
  0 | 0 << 1 | 1 << 2,
  1 | 0 << 1 | 0 << 2,
  1 | 0 << 1 | 1 << 2,
  1 | 1 << 1 | 0 << 2,
  1 | 0 << 1 | 0 << 2
];
var comparisonFunctionToBits = [
  0 << 3 | 0 << 4 | 0 << 5 | 0 << 6,
  0 << 3 | 0 << 4 | 0 << 5 | 1 << 6,
  0 << 3 | 0 << 4 | 1 << 5 | 0 << 6,
  0 << 3 | 0 << 4 | 1 << 5 | 1 << 6,
  0 << 3 | 1 << 4 | 0 << 5 | 0 << 6,
  0 << 3 | 1 << 4 | 0 << 5 | 1 << 6,
  0 << 3 | 1 << 4 | 1 << 5 | 0 << 6,
  0 << 3 | 1 << 4 | 1 << 5 | 1 << 6,
  1 << 3 | 0 << 4 | 0 << 5 | 0 << 6
];
var filterNoMipToBits = [
  0 << 7,
  1 << 7,
  1 << 7,
  0 << 7,
  0 << 7,
  0 << 7,
  0 << 7,
  1 << 7,
  0 << 7,
  0 << 7,
  0 << 7,
  0 << 7,
  1 << 7
];
var WebGPUCacheSampler = class {
  constructor(device) {
    this._samplers = {};
    this._device = device;
    this.disabled = false;
  }
  static GetSamplerHashCode(sampler) {
    var _a, _b, _c;
    const anisotropy = sampler._cachedAnisotropicFilteringLevel && sampler._cachedAnisotropicFilteringLevel > 1 ? 4 : 1;
    const code = filterToBits[sampler.samplingMode] + comparisonFunctionToBits[(sampler._comparisonFunction || 514) - 512 + 1] + filterNoMipToBits[sampler.samplingMode] + (((_a = sampler._cachedWrapU) !== null && _a !== void 0 ? _a : 1) << 8) + (((_b = sampler._cachedWrapV) !== null && _b !== void 0 ? _b : 1) << 10) + (((_c = sampler._cachedWrapR) !== null && _c !== void 0 ? _c : 1) << 12) + ((sampler.useMipMaps ? 1 : 0) << 14) + (anisotropy << 15);
    return code;
  }
  static _GetSamplerFilterDescriptor(sampler, anisotropy) {
    let magFilter, minFilter, mipmapFilter, lodMinClamp, lodMaxClamp;
    const useMipMaps = sampler.useMipMaps;
    switch (sampler.samplingMode) {
      case 11:
        magFilter = FilterMode.Linear;
        minFilter = FilterMode.Linear;
        mipmapFilter = FilterMode.Nearest;
        if (!useMipMaps) {
          lodMinClamp = lodMaxClamp = 0;
        }
        break;
      case 3:
      case 3:
        magFilter = FilterMode.Linear;
        minFilter = FilterMode.Linear;
        if (!useMipMaps) {
          mipmapFilter = FilterMode.Nearest;
          lodMinClamp = lodMaxClamp = 0;
        } else {
          mipmapFilter = FilterMode.Linear;
        }
        break;
      case 8:
        magFilter = FilterMode.Nearest;
        minFilter = FilterMode.Nearest;
        if (!useMipMaps) {
          mipmapFilter = FilterMode.Nearest;
          lodMinClamp = lodMaxClamp = 0;
        } else {
          mipmapFilter = FilterMode.Linear;
        }
        break;
      case 4:
        magFilter = FilterMode.Nearest;
        minFilter = FilterMode.Nearest;
        mipmapFilter = FilterMode.Nearest;
        if (!useMipMaps) {
          lodMinClamp = lodMaxClamp = 0;
        }
        break;
      case 5:
        magFilter = FilterMode.Nearest;
        minFilter = FilterMode.Linear;
        mipmapFilter = FilterMode.Nearest;
        if (!useMipMaps) {
          lodMinClamp = lodMaxClamp = 0;
        }
        break;
      case 6:
        magFilter = FilterMode.Nearest;
        minFilter = FilterMode.Linear;
        if (!useMipMaps) {
          mipmapFilter = FilterMode.Nearest;
          lodMinClamp = lodMaxClamp = 0;
        } else {
          mipmapFilter = FilterMode.Linear;
        }
        break;
      case 7:
        magFilter = FilterMode.Nearest;
        minFilter = FilterMode.Linear;
        mipmapFilter = FilterMode.Nearest;
        lodMinClamp = lodMaxClamp = 0;
        break;
      case 1:
      case 1:
        magFilter = FilterMode.Nearest;
        minFilter = FilterMode.Nearest;
        mipmapFilter = FilterMode.Nearest;
        lodMinClamp = lodMaxClamp = 0;
        break;
      case 9:
        magFilter = FilterMode.Linear;
        minFilter = FilterMode.Nearest;
        mipmapFilter = FilterMode.Nearest;
        if (!useMipMaps) {
          lodMinClamp = lodMaxClamp = 0;
        }
        break;
      case 10:
        magFilter = FilterMode.Linear;
        minFilter = FilterMode.Nearest;
        if (!useMipMaps) {
          mipmapFilter = FilterMode.Nearest;
          lodMinClamp = lodMaxClamp = 0;
        } else {
          mipmapFilter = FilterMode.Linear;
        }
        break;
      case 2:
      case 2:
        magFilter = FilterMode.Linear;
        minFilter = FilterMode.Linear;
        mipmapFilter = FilterMode.Nearest;
        lodMinClamp = lodMaxClamp = 0;
        break;
      case 12:
        magFilter = FilterMode.Linear;
        minFilter = FilterMode.Nearest;
        mipmapFilter = FilterMode.Nearest;
        lodMinClamp = lodMaxClamp = 0;
        break;
      default:
        magFilter = FilterMode.Nearest;
        minFilter = FilterMode.Nearest;
        mipmapFilter = FilterMode.Nearest;
        lodMinClamp = lodMaxClamp = 0;
        break;
    }
    if (anisotropy > 1 && (lodMinClamp !== 0 || lodMaxClamp !== 0)) {
      return {
        magFilter: FilterMode.Linear,
        minFilter: FilterMode.Linear,
        mipmapFilter: FilterMode.Linear,
        anisotropyEnabled: true
      };
    }
    return {
      magFilter,
      minFilter,
      mipmapFilter,
      lodMinClamp,
      lodMaxClamp
    };
  }
  static _GetWrappingMode(mode) {
    switch (mode) {
      case 1:
        return AddressMode.Repeat;
      case 0:
        return AddressMode.ClampToEdge;
      case 2:
        return AddressMode.MirrorRepeat;
    }
    return AddressMode.Repeat;
  }
  static _GetSamplerWrappingDescriptor(sampler) {
    return {
      addressModeU: this._GetWrappingMode(sampler._cachedWrapU),
      addressModeV: this._GetWrappingMode(sampler._cachedWrapV),
      addressModeW: this._GetWrappingMode(sampler._cachedWrapR)
    };
  }
  static _GetSamplerDescriptor(sampler) {
    const anisotropy = sampler.useMipMaps && sampler._cachedAnisotropicFilteringLevel && sampler._cachedAnisotropicFilteringLevel > 1 ? 4 : 1;
    const filterDescriptor = this._GetSamplerFilterDescriptor(sampler, anisotropy);
    return {
      ...filterDescriptor,
      ...this._GetSamplerWrappingDescriptor(sampler),
      compare: sampler._comparisonFunction ? WebGPUCacheSampler.GetCompareFunction(sampler._comparisonFunction) : void 0,
      maxAnisotropy: filterDescriptor.anisotropyEnabled ? anisotropy : 1
    };
  }
  static GetCompareFunction(compareFunction) {
    switch (compareFunction) {
      case 519:
        return CompareFunction.Always;
      case 514:
        return CompareFunction.Equal;
      case 516:
        return CompareFunction.Greater;
      case 518:
        return CompareFunction.GreaterEqual;
      case 513:
        return CompareFunction.Less;
      case 515:
        return CompareFunction.LessEqual;
      case 512:
        return CompareFunction.Never;
      case 517:
        return CompareFunction.NotEqual;
      default:
        return CompareFunction.Less;
    }
  }
  getSampler(sampler, bypassCache = false, hash = 0) {
    if (this.disabled) {
      return this._device.createSampler(WebGPUCacheSampler._GetSamplerDescriptor(sampler));
    }
    if (bypassCache) {
      hash = 0;
    } else if (hash === 0) {
      hash = WebGPUCacheSampler.GetSamplerHashCode(sampler);
    }
    let gpuSampler = bypassCache ? void 0 : this._samplers[hash];
    if (!gpuSampler) {
      gpuSampler = this._device.createSampler(WebGPUCacheSampler._GetSamplerDescriptor(sampler));
      if (!bypassCache) {
        this._samplers[hash] = gpuSampler;
      }
    }
    return gpuSampler;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuCacheRenderPipeline.js
var StatePosition;
(function(StatePosition2) {
  StatePosition2[StatePosition2["StencilReadMask"] = 0] = "StencilReadMask";
  StatePosition2[StatePosition2["StencilWriteMask"] = 1] = "StencilWriteMask";
  StatePosition2[StatePosition2["DepthBias"] = 2] = "DepthBias";
  StatePosition2[StatePosition2["DepthBiasSlopeScale"] = 3] = "DepthBiasSlopeScale";
  StatePosition2[StatePosition2["DepthStencilState"] = 4] = "DepthStencilState";
  StatePosition2[StatePosition2["MRTAttachments1"] = 5] = "MRTAttachments1";
  StatePosition2[StatePosition2["MRTAttachments2"] = 6] = "MRTAttachments2";
  StatePosition2[StatePosition2["RasterizationState"] = 7] = "RasterizationState";
  StatePosition2[StatePosition2["ColorStates"] = 8] = "ColorStates";
  StatePosition2[StatePosition2["ShaderStage"] = 9] = "ShaderStage";
  StatePosition2[StatePosition2["TextureStage"] = 10] = "TextureStage";
  StatePosition2[StatePosition2["VertexState"] = 11] = "VertexState";
  StatePosition2[StatePosition2["NumStates"] = 12] = "NumStates";
})(StatePosition || (StatePosition = {}));
var alphaBlendFactorToIndex = {
  0: 1,
  1: 2,
  768: 3,
  769: 4,
  770: 5,
  771: 6,
  772: 7,
  773: 8,
  774: 9,
  775: 10,
  776: 11,
  32769: 12,
  32770: 13,
  32771: 12,
  32772: 13
};
var stencilOpToIndex = {
  0: 0,
  7680: 1,
  7681: 2,
  7682: 3,
  7683: 4,
  5386: 5,
  34055: 6,
  34056: 7
};
var WebGPUCacheRenderPipeline = class {
  constructor(device, emptyVertexBuffer, useTextureStage) {
    this.mrtTextureCount = 0;
    this._device = device;
    this._useTextureStage = useTextureStage;
    this._states = new Array(30);
    this._statesLength = 0;
    this._stateDirtyLowestIndex = 0;
    this._emptyVertexBuffer = emptyVertexBuffer;
    this._mrtFormats = [];
    this._parameter = { token: void 0, pipeline: null };
    this.disabled = false;
    this.vertexBuffers = [];
    this._kMaxVertexBufferStride = device.limits.maxVertexBufferArrayStride || 2048;
    this.reset();
  }
  reset() {
    this._isDirty = true;
    this.vertexBuffers.length = 0;
    this.setAlphaToCoverage(false);
    this.resetDepthCullingState();
    this.setClampDepth(false);
    this.setDepthBias(0);
    this._webgpuColorFormat = [TextureFormat.BGRA8Unorm];
    this.setColorFormat(TextureFormat.BGRA8Unorm);
    this.setMRT([]);
    this.setAlphaBlendEnabled(false);
    this.setAlphaBlendFactors([null, null, null, null], [null, null]);
    this.setWriteMask(15);
    this.setDepthStencilFormat(TextureFormat.Depth24PlusStencil8);
    this.setStencilEnabled(false);
    this.resetStencilState();
    this.setBuffers(null, null, null);
    this._setTextureState(0);
  }
  get colorFormats() {
    return this._mrtAttachments1 > 0 ? this._mrtFormats : this._webgpuColorFormat;
  }
  getRenderPipeline(fillMode, effect, sampleCount, textureState = 0) {
    if (sampleCount > 1) {
      sampleCount = 4;
    }
    if (this.disabled) {
      const topology2 = WebGPUCacheRenderPipeline._GetTopology(fillMode);
      this._setVertexState(effect);
      this._parameter.pipeline = this._createRenderPipeline(effect, topology2, sampleCount);
      WebGPUCacheRenderPipeline.NumCacheMiss++;
      WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;
      return this._parameter.pipeline;
    }
    this._setShaderStage(effect.uniqueId);
    this._setRasterizationState(fillMode, sampleCount);
    this._setColorStates();
    this._setDepthStencilState();
    this._setVertexState(effect);
    this._setTextureState(textureState);
    this.lastStateDirtyLowestIndex = this._stateDirtyLowestIndex;
    if (!this._isDirty && this._parameter.pipeline) {
      this._stateDirtyLowestIndex = this._statesLength;
      WebGPUCacheRenderPipeline.NumCacheHitWithoutHash++;
      return this._parameter.pipeline;
    }
    this._getRenderPipeline(this._parameter);
    this._isDirty = false;
    this._stateDirtyLowestIndex = this._statesLength;
    if (this._parameter.pipeline) {
      WebGPUCacheRenderPipeline.NumCacheHitWithHash++;
      return this._parameter.pipeline;
    }
    const topology = WebGPUCacheRenderPipeline._GetTopology(fillMode);
    this._parameter.pipeline = this._createRenderPipeline(effect, topology, sampleCount);
    this._setRenderPipeline(this._parameter);
    WebGPUCacheRenderPipeline.NumCacheMiss++;
    WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;
    return this._parameter.pipeline;
  }
  endFrame() {
    WebGPUCacheRenderPipeline.NumPipelineCreationLastFrame = WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame;
    WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame = 0;
  }
  setAlphaToCoverage(enabled) {
    this._alphaToCoverageEnabled = enabled;
  }
  setFrontFace(frontFace) {
    this._frontFace = frontFace;
  }
  setCullEnabled(enabled) {
    this._cullEnabled = enabled;
  }
  setCullFace(cullFace) {
    this._cullFace = cullFace;
  }
  setClampDepth(clampDepth) {
    this._clampDepth = clampDepth;
  }
  resetDepthCullingState() {
    this.setDepthCullingState(false, 2, 1, 0, 0, true, true, 519);
  }
  setDepthCullingState(cullEnabled, frontFace, cullFace, zOffset, zOffsetUnits, depthTestEnabled, depthWriteEnabled, depthCompare) {
    this._depthWriteEnabled = depthWriteEnabled;
    this._depthTestEnabled = depthTestEnabled;
    this._depthCompare = (depthCompare !== null && depthCompare !== void 0 ? depthCompare : 519) - 512;
    this._cullFace = cullFace;
    this._cullEnabled = cullEnabled;
    this._frontFace = frontFace;
    this.setDepthBiasSlopeScale(zOffset);
    this.setDepthBias(zOffsetUnits);
  }
  setDepthBias(depthBias) {
    if (this._depthBias !== depthBias) {
      this._depthBias = depthBias;
      this._states[StatePosition.DepthBias] = depthBias;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBias);
    }
  }
  setDepthBiasSlopeScale(depthBiasSlopeScale) {
    if (this._depthBiasSlopeScale !== depthBiasSlopeScale) {
      this._depthBiasSlopeScale = depthBiasSlopeScale;
      this._states[StatePosition.DepthBiasSlopeScale] = depthBiasSlopeScale;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBiasSlopeScale);
    }
  }
  setColorFormat(format) {
    this._webgpuColorFormat[0] = format;
    this._colorFormat = renderableTextureFormatToIndex[format !== null && format !== void 0 ? format : ""];
  }
  setMRTAttachments(attachments) {
    this.mrtAttachments = attachments;
    let mask = 0;
    for (let i = 0; i < attachments.length; ++i) {
      if (attachments[i] !== 0) {
        mask += 1 << i;
      }
    }
    if (this._mrtEnabledMask !== mask) {
      this._mrtEnabledMask = mask;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments1);
    }
  }
  setMRT(textureArray, textureCount) {
    var _a, _b;
    textureCount = textureCount !== null && textureCount !== void 0 ? textureCount : textureArray.length;
    if (textureCount > 10) {
      throw "Can't handle more than 10 attachments for a MRT in cache render pipeline!";
    }
    this.mrtTextureArray = textureArray;
    this.mrtTextureCount = textureCount;
    this._mrtEnabledMask = 65535;
    const bits = [0, 0];
    let indexBits = 0, mask = 0, numRT = 0;
    for (let i = 0; i < textureCount; ++i) {
      const texture = textureArray[i];
      const gpuWrapper = texture === null || texture === void 0 ? void 0 : texture._hardwareTexture;
      this._mrtFormats[numRT] = (_a = gpuWrapper === null || gpuWrapper === void 0 ? void 0 : gpuWrapper.format) !== null && _a !== void 0 ? _a : this._webgpuColorFormat[0];
      bits[indexBits] += renderableTextureFormatToIndex[(_b = this._mrtFormats[numRT]) !== null && _b !== void 0 ? _b : ""] << mask;
      mask += 6;
      numRT++;
      if (mask >= 32) {
        mask = 0;
        indexBits++;
      }
    }
    this._mrtFormats.length = numRT;
    if (this._mrtAttachments1 !== bits[0] || this._mrtAttachments2 !== bits[1]) {
      this._mrtAttachments1 = bits[0];
      this._mrtAttachments2 = bits[1];
      this._states[StatePosition.MRTAttachments1] = bits[0];
      this._states[StatePosition.MRTAttachments2] = bits[1];
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments1);
    }
  }
  setAlphaBlendEnabled(enabled) {
    this._alphaBlendEnabled = enabled;
  }
  setAlphaBlendFactors(factors, operations) {
    this._alphaBlendFuncParams = factors;
    this._alphaBlendEqParams = operations;
  }
  setWriteMask(mask) {
    this._writeMask = mask;
  }
  setDepthStencilFormat(format) {
    this._webgpuDepthStencilFormat = format;
    this._depthStencilFormat = format === void 0 ? 0 : renderableTextureFormatToIndex[format];
  }
  setDepthTestEnabled(enabled) {
    this._depthTestEnabled = enabled;
  }
  setDepthWriteEnabled(enabled) {
    this._depthWriteEnabled = enabled;
  }
  setDepthCompare(func) {
    this._depthCompare = (func !== null && func !== void 0 ? func : 519) - 512;
  }
  setStencilEnabled(enabled) {
    this._stencilEnabled = enabled;
  }
  setStencilCompare(func) {
    this._stencilFrontCompare = (func !== null && func !== void 0 ? func : 519) - 512;
  }
  setStencilDepthFailOp(op) {
    this._stencilFrontDepthFailOp = op === null ? 1 : stencilOpToIndex[op];
  }
  setStencilPassOp(op) {
    this._stencilFrontPassOp = op === null ? 2 : stencilOpToIndex[op];
  }
  setStencilFailOp(op) {
    this._stencilFrontFailOp = op === null ? 1 : stencilOpToIndex[op];
  }
  setStencilReadMask(mask) {
    if (this._stencilReadMask !== mask) {
      this._stencilReadMask = mask;
      this._states[StatePosition.StencilReadMask] = mask;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilReadMask);
    }
  }
  setStencilWriteMask(mask) {
    if (this._stencilWriteMask !== mask) {
      this._stencilWriteMask = mask;
      this._states[StatePosition.StencilWriteMask] = mask;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilWriteMask);
    }
  }
  resetStencilState() {
    this.setStencilState(false, 519, 7680, 7681, 7680, 255, 255);
  }
  setStencilState(stencilEnabled, compare, depthFailOp, passOp, failOp, readMask, writeMask) {
    this._stencilEnabled = stencilEnabled;
    this._stencilFrontCompare = (compare !== null && compare !== void 0 ? compare : 519) - 512;
    this._stencilFrontDepthFailOp = depthFailOp === null ? 1 : stencilOpToIndex[depthFailOp];
    this._stencilFrontPassOp = passOp === null ? 2 : stencilOpToIndex[passOp];
    this._stencilFrontFailOp = failOp === null ? 1 : stencilOpToIndex[failOp];
    this.setStencilReadMask(readMask);
    this.setStencilWriteMask(writeMask);
  }
  setBuffers(vertexBuffers, indexBuffer, overrideVertexBuffers) {
    this._vertexBuffers = vertexBuffers;
    this._overrideVertexBuffers = overrideVertexBuffers;
    this._indexBuffer = indexBuffer;
  }
  static _GetTopology(fillMode) {
    switch (fillMode) {
      case 0:
        return PrimitiveTopology.TriangleList;
      case 2:
        return PrimitiveTopology.PointList;
      case 1:
        return PrimitiveTopology.LineList;
      case 3:
        return PrimitiveTopology.PointList;
      case 4:
        return PrimitiveTopology.LineList;
      case 5:
        throw "LineLoop is an unsupported fillmode in WebGPU";
      case 6:
        return PrimitiveTopology.LineStrip;
      case 7:
        return PrimitiveTopology.TriangleStrip;
      case 8:
        throw "TriangleFan is an unsupported fillmode in WebGPU";
      default:
        return PrimitiveTopology.TriangleList;
    }
  }
  static _GetAphaBlendOperation(operation) {
    switch (operation) {
      case 32774:
        return BlendOperation.Add;
      case 32778:
        return BlendOperation.Subtract;
      case 32779:
        return BlendOperation.ReverseSubtract;
      case 32775:
        return BlendOperation.Min;
      case 32776:
        return BlendOperation.Max;
      default:
        return BlendOperation.Add;
    }
  }
  static _GetAphaBlendFactor(factor) {
    switch (factor) {
      case 0:
        return BlendFactor.Zero;
      case 1:
        return BlendFactor.One;
      case 768:
        return BlendFactor.Src;
      case 769:
        return BlendFactor.OneMinusSrc;
      case 770:
        return BlendFactor.SrcAlpha;
      case 771:
        return BlendFactor.OneMinusSrcAlpha;
      case 772:
        return BlendFactor.DstAlpha;
      case 773:
        return BlendFactor.OneMinusDstAlpha;
      case 774:
        return BlendFactor.Dst;
      case 775:
        return BlendFactor.OneMinusDst;
      case 776:
        return BlendFactor.SrcAlphaSaturated;
      case 32769:
        return BlendFactor.Constant;
      case 32770:
        return BlendFactor.OneMinusConstant;
      case 32771:
        return BlendFactor.Constant;
      case 32772:
        return BlendFactor.OneMinusConstant;
      default:
        return BlendFactor.One;
    }
  }
  static _GetCompareFunction(compareFunction) {
    switch (compareFunction) {
      case 0:
        return CompareFunction.Never;
      case 1:
        return CompareFunction.Less;
      case 2:
        return CompareFunction.Equal;
      case 3:
        return CompareFunction.LessEqual;
      case 4:
        return CompareFunction.Greater;
      case 5:
        return CompareFunction.NotEqual;
      case 6:
        return CompareFunction.GreaterEqual;
      case 7:
        return CompareFunction.Always;
    }
    return CompareFunction.Never;
  }
  static _GetStencilOpFunction(operation) {
    switch (operation) {
      case 0:
        return StencilOperation.Zero;
      case 1:
        return StencilOperation.Keep;
      case 2:
        return StencilOperation.Replace;
      case 3:
        return StencilOperation.IncrementClamp;
      case 4:
        return StencilOperation.DecrementClamp;
      case 5:
        return StencilOperation.Invert;
      case 6:
        return StencilOperation.IncrementWrap;
      case 7:
        return StencilOperation.DecrementWrap;
    }
    return StencilOperation.Keep;
  }
  static _GetVertexInputDescriptorFormat(vertexBuffer) {
    const type = vertexBuffer.type;
    const normalized = vertexBuffer.normalized;
    const size = vertexBuffer.getSize();
    switch (type) {
      case VertexBuffer.BYTE:
        switch (size) {
          case 1:
          case 2:
            return normalized ? VertexFormat.Snorm8x2 : VertexFormat.Sint8x2;
          case 3:
          case 4:
            return normalized ? VertexFormat.Snorm8x4 : VertexFormat.Sint8x4;
        }
        break;
      case VertexBuffer.UNSIGNED_BYTE:
        switch (size) {
          case 1:
          case 2:
            return normalized ? VertexFormat.Unorm8x2 : VertexFormat.Uint8x2;
          case 3:
          case 4:
            return normalized ? VertexFormat.Unorm8x4 : VertexFormat.Uint8x4;
        }
        break;
      case VertexBuffer.SHORT:
        switch (size) {
          case 1:
          case 2:
            return normalized ? VertexFormat.Snorm16x2 : VertexFormat.Sint16x2;
          case 3:
          case 4:
            return normalized ? VertexFormat.Snorm16x4 : VertexFormat.Sint16x4;
        }
        break;
      case VertexBuffer.UNSIGNED_SHORT:
        switch (size) {
          case 1:
          case 2:
            return normalized ? VertexFormat.Unorm16x2 : VertexFormat.Uint16x2;
          case 3:
          case 4:
            return normalized ? VertexFormat.Unorm16x4 : VertexFormat.Uint16x4;
        }
        break;
      case VertexBuffer.INT:
        switch (size) {
          case 1:
            return VertexFormat.Sint32;
          case 2:
            return VertexFormat.Sint32x2;
          case 3:
            return VertexFormat.Sint32x3;
          case 4:
            return VertexFormat.Sint32x4;
        }
        break;
      case VertexBuffer.UNSIGNED_INT:
        switch (size) {
          case 1:
            return VertexFormat.Uint32;
          case 2:
            return VertexFormat.Uint32x2;
          case 3:
            return VertexFormat.Uint32x3;
          case 4:
            return VertexFormat.Uint32x4;
        }
        break;
      case VertexBuffer.FLOAT:
        switch (size) {
          case 1:
            return VertexFormat.Float32;
          case 2:
            return VertexFormat.Float32x2;
          case 3:
            return VertexFormat.Float32x3;
          case 4:
            return VertexFormat.Float32x4;
        }
        break;
    }
    throw new Error(`Invalid Format '${vertexBuffer.getKind()}' - type=${type}, normalized=${normalized}, size=${size}`);
  }
  _getAphaBlendState() {
    if (!this._alphaBlendEnabled) {
      return null;
    }
    return {
      srcFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[2]),
      dstFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[3]),
      operation: WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[1])
    };
  }
  _getColorBlendState() {
    if (!this._alphaBlendEnabled) {
      return null;
    }
    return {
      srcFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[0]),
      dstFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[1]),
      operation: WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[0])
    };
  }
  _setShaderStage(id) {
    if (this._shaderId !== id) {
      this._shaderId = id;
      this._states[StatePosition.ShaderStage] = id;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ShaderStage);
    }
  }
  _setRasterizationState(topology, sampleCount) {
    const frontFace = this._frontFace;
    const cullMode = this._cullEnabled ? this._cullFace : 0;
    const clampDepth = this._clampDepth ? 1 : 0;
    const alphaToCoverage = this._alphaToCoverageEnabled ? 1 : 0;
    const rasterizationState = frontFace - 1 + (cullMode << 1) + (clampDepth << 3) + (alphaToCoverage << 4) + (topology << 5) + (sampleCount << 8);
    if (this._rasterizationState !== rasterizationState) {
      this._rasterizationState = rasterizationState;
      this._states[StatePosition.RasterizationState] = this._rasterizationState;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.RasterizationState);
    }
  }
  _setColorStates() {
    let colorStates = ((this._writeMask ? 1 : 0) << 22) + (this._colorFormat << 23) + ((this._depthWriteEnabled ? 1 : 0) << 29);
    if (this._alphaBlendEnabled) {
      colorStates += ((this._alphaBlendFuncParams[0] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[0]]) << 0) + ((this._alphaBlendFuncParams[1] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[1]]) << 4) + ((this._alphaBlendFuncParams[2] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[2]]) << 8) + ((this._alphaBlendFuncParams[3] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[3]]) << 12) + ((this._alphaBlendEqParams[0] === null ? 1 : this._alphaBlendEqParams[0] - 32773) << 16) + ((this._alphaBlendEqParams[1] === null ? 1 : this._alphaBlendEqParams[1] - 32773) << 19);
    }
    if (colorStates !== this._colorStates) {
      this._colorStates = colorStates;
      this._states[StatePosition.ColorStates] = this._colorStates;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ColorStates);
    }
  }
  _setDepthStencilState() {
    const stencilState = !this._stencilEnabled ? 7 + (1 << 3) + (1 << 6) + (1 << 9) : this._stencilFrontCompare + (this._stencilFrontDepthFailOp << 3) + (this._stencilFrontPassOp << 6) + (this._stencilFrontFailOp << 9);
    const depthStencilState = this._depthStencilFormat + ((this._depthTestEnabled ? this._depthCompare : 7) << 6) + (stencilState << 10);
    if (this._depthStencilState !== depthStencilState) {
      this._depthStencilState = depthStencilState;
      this._states[StatePosition.DepthStencilState] = this._depthStencilState;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthStencilState);
    }
  }
  _setVertexState(effect) {
    var _a, _b;
    const currStateLen = this._statesLength;
    let newNumStates = StatePosition.VertexState;
    const webgpuPipelineContext = effect._pipelineContext;
    const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;
    const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;
    let currentGPUBuffer;
    let numVertexBuffers = 0;
    for (let index = 0; index < attributes.length; index++) {
      const location = locations[index];
      let vertexBuffer = (_a = this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) !== null && _a !== void 0 ? _a : this._vertexBuffers[attributes[index]];
      if (!vertexBuffer) {
        vertexBuffer = this._emptyVertexBuffer;
      }
      const buffer = (_b = vertexBuffer.getBuffer()) === null || _b === void 0 ? void 0 : _b.underlyingResource;
      if (vertexBuffer._validOffsetRange === void 0) {
        const offset = vertexBuffer.byteOffset;
        const formatSize = vertexBuffer.getSize(true);
        const byteStride = vertexBuffer.byteStride;
        vertexBuffer._validOffsetRange = offset <= this._kMaxVertexBufferStride - formatSize && (byteStride === 0 || offset + formatSize <= byteStride);
      }
      if (!(currentGPUBuffer && currentGPUBuffer === buffer && vertexBuffer._validOffsetRange)) {
        this.vertexBuffers[numVertexBuffers++] = vertexBuffer;
        currentGPUBuffer = vertexBuffer._validOffsetRange ? buffer : null;
      }
      const vid = vertexBuffer.hashCode + (location << 7);
      this._isDirty = this._isDirty || this._states[newNumStates] !== vid;
      this._states[newNumStates++] = vid;
    }
    this.vertexBuffers.length = numVertexBuffers;
    this._statesLength = newNumStates;
    this._isDirty = this._isDirty || newNumStates !== currStateLen;
    if (this._isDirty) {
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.VertexState);
    }
  }
  _setTextureState(textureState) {
    if (this._textureState !== textureState) {
      this._textureState = textureState;
      this._states[StatePosition.TextureStage] = this._textureState;
      this._isDirty = true;
      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.TextureStage);
    }
  }
  _createPipelineLayout(webgpuPipelineContext) {
    if (this._useTextureStage) {
      return this._createPipelineLayoutWithTextureStage(webgpuPipelineContext);
    }
    const bindGroupLayouts = [];
    const bindGroupLayoutEntries = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries;
    for (let i = 0; i < bindGroupLayoutEntries.length; i++) {
      const setDefinition = bindGroupLayoutEntries[i];
      bindGroupLayouts[i] = this._device.createBindGroupLayout({
        entries: setDefinition
      });
    }
    webgpuPipelineContext.bindGroupLayouts = bindGroupLayouts;
    return this._device.createPipelineLayout({ bindGroupLayouts });
  }
  _createPipelineLayoutWithTextureStage(webgpuPipelineContext) {
    var _a;
    const shaderProcessingContext = webgpuPipelineContext.shaderProcessingContext;
    const bindGroupLayoutEntries = shaderProcessingContext.bindGroupLayoutEntries;
    let bitVal = 1;
    for (let i = 0; i < bindGroupLayoutEntries.length; i++) {
      const setDefinition = bindGroupLayoutEntries[i];
      for (let j = 0; j < setDefinition.length; j++) {
        const entry = bindGroupLayoutEntries[i][j];
        if (entry.texture) {
          const name137 = shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].name;
          const textureInfo = shaderProcessingContext.availableTextures[name137];
          const samplerInfo = textureInfo.autoBindSampler ? shaderProcessingContext.availableSamplers[name137 + WebGPUShaderProcessor.AutoSamplerSuffix] : null;
          let sampleType = textureInfo.sampleType;
          let samplerType = (_a = samplerInfo === null || samplerInfo === void 0 ? void 0 : samplerInfo.type) !== null && _a !== void 0 ? _a : SamplerBindingType.Filtering;
          if (this._textureState & bitVal && sampleType !== TextureSampleType.Depth) {
            if (textureInfo.autoBindSampler) {
              samplerType = SamplerBindingType.NonFiltering;
            }
            sampleType = TextureSampleType.UnfilterableFloat;
          }
          entry.texture.sampleType = sampleType;
          if (samplerInfo) {
            const binding = shaderProcessingContext.bindGroupLayoutEntryInfo[samplerInfo.binding.groupIndex][samplerInfo.binding.bindingIndex].index;
            bindGroupLayoutEntries[samplerInfo.binding.groupIndex][binding].sampler.type = samplerType;
          }
          bitVal = bitVal << 1;
        }
      }
    }
    const bindGroupLayouts = [];
    for (let i = 0; i < bindGroupLayoutEntries.length; ++i) {
      bindGroupLayouts[i] = this._device.createBindGroupLayout({
        entries: bindGroupLayoutEntries[i]
      });
    }
    webgpuPipelineContext.bindGroupLayouts = bindGroupLayouts;
    return this._device.createPipelineLayout({ bindGroupLayouts });
  }
  _getVertexInputDescriptor(effect) {
    var _a, _b;
    const descriptors = [];
    const webgpuPipelineContext = effect._pipelineContext;
    const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;
    const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;
    let currentGPUBuffer;
    let currentGPUAttributes;
    for (let index = 0; index < attributes.length; index++) {
      const location = locations[index];
      let vertexBuffer = (_a = this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) !== null && _a !== void 0 ? _a : this._vertexBuffers[attributes[index]];
      if (!vertexBuffer) {
        vertexBuffer = this._emptyVertexBuffer;
      }
      let buffer = (_b = vertexBuffer.getBuffer()) === null || _b === void 0 ? void 0 : _b.underlyingResource;
      let offset = vertexBuffer.byteOffset;
      const invalidOffsetRange = !vertexBuffer._validOffsetRange;
      if (!(currentGPUBuffer && currentGPUAttributes && currentGPUBuffer === buffer) || invalidOffsetRange) {
        const vertexBufferDescriptor = {
          arrayStride: vertexBuffer.byteStride,
          stepMode: vertexBuffer.getIsInstanced() ? InputStepMode.Instance : InputStepMode.Vertex,
          attributes: []
        };
        descriptors.push(vertexBufferDescriptor);
        currentGPUAttributes = vertexBufferDescriptor.attributes;
        if (invalidOffsetRange) {
          offset = 0;
          buffer = null;
        }
      }
      currentGPUAttributes.push({
        shaderLocation: location,
        offset,
        format: WebGPUCacheRenderPipeline._GetVertexInputDescriptorFormat(vertexBuffer)
      });
      currentGPUBuffer = buffer;
    }
    return descriptors;
  }
  _createRenderPipeline(effect, topology, sampleCount) {
    var _a, _b, _c;
    const webgpuPipelineContext = effect._pipelineContext;
    const inputStateDescriptor = this._getVertexInputDescriptor(effect);
    const pipelineLayout = this._createPipelineLayout(webgpuPipelineContext);
    const colorStates = [];
    const alphaBlend = this._getAphaBlendState();
    const colorBlend = this._getColorBlendState();
    if (this._mrtAttachments1 > 0) {
      for (let i = 0; i < this._mrtFormats.length; ++i) {
        const format = this._mrtFormats[i];
        if (format) {
          const descr = {
            format,
            writeMask: (this._mrtEnabledMask & 1 << i) !== 0 ? this._writeMask : 0
          };
          if (alphaBlend && colorBlend) {
            descr.blend = {
              alpha: alphaBlend,
              color: colorBlend
            };
          }
          colorStates.push(descr);
        } else {
          colorStates.push(null);
        }
      }
    } else {
      if (this._webgpuColorFormat[0]) {
        const descr = {
          format: this._webgpuColorFormat[0],
          writeMask: this._writeMask
        };
        if (alphaBlend && colorBlend) {
          descr.blend = {
            alpha: alphaBlend,
            color: colorBlend
          };
        }
        colorStates.push(descr);
      } else {
        colorStates.push(null);
      }
    }
    const stencilFrontBack = {
      compare: WebGPUCacheRenderPipeline._GetCompareFunction(this._stencilEnabled ? this._stencilFrontCompare : 7),
      depthFailOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontDepthFailOp : 1),
      failOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontFailOp : 1),
      passOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontPassOp : 1)
    };
    let stripIndexFormat = void 0;
    if (topology === PrimitiveTopology.LineStrip || topology === PrimitiveTopology.TriangleStrip) {
      stripIndexFormat = !this._indexBuffer || this._indexBuffer.is32Bits ? IndexFormat.Uint32 : IndexFormat.Uint16;
    }
    const depthStencilFormatHasStencil = this._webgpuDepthStencilFormat ? WebGPUTextureHelper.HasStencilAspect(this._webgpuDepthStencilFormat) : false;
    return this._device.createRenderPipeline({
      label: `RenderPipeline_${(_b = (_a = colorStates[0]) === null || _a === void 0 ? void 0 : _a.format) !== null && _b !== void 0 ? _b : "nooutput"}_${(_c = this._webgpuDepthStencilFormat) !== null && _c !== void 0 ? _c : "nodepth"}_samples${sampleCount}`,
      layout: pipelineLayout,
      vertex: {
        module: webgpuPipelineContext.stages.vertexStage.module,
        entryPoint: webgpuPipelineContext.stages.vertexStage.entryPoint,
        buffers: inputStateDescriptor
      },
      primitive: {
        topology,
        stripIndexFormat,
        frontFace: this._frontFace === 1 ? FrontFace.CCW : FrontFace.CW,
        cullMode: !this._cullEnabled ? CullMode.None : this._cullFace === 2 ? CullMode.Front : CullMode.Back
      },
      fragment: !webgpuPipelineContext.stages.fragmentStage ? void 0 : {
        module: webgpuPipelineContext.stages.fragmentStage.module,
        entryPoint: webgpuPipelineContext.stages.fragmentStage.entryPoint,
        targets: colorStates
      },
      multisample: {
        count: sampleCount
      },
      depthStencil: this._webgpuDepthStencilFormat === void 0 ? void 0 : {
        depthWriteEnabled: this._depthWriteEnabled,
        depthCompare: this._depthTestEnabled ? WebGPUCacheRenderPipeline._GetCompareFunction(this._depthCompare) : CompareFunction.Always,
        format: this._webgpuDepthStencilFormat,
        stencilFront: this._stencilEnabled && depthStencilFormatHasStencil ? stencilFrontBack : void 0,
        stencilBack: this._stencilEnabled && depthStencilFormatHasStencil ? stencilFrontBack : void 0,
        stencilReadMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilReadMask : void 0,
        stencilWriteMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilWriteMask : void 0,
        depthBias: this._depthBias,
        depthBiasClamp: this._depthBiasClamp,
        depthBiasSlopeScale: this._depthBiasSlopeScale
      }
    });
  }
};
WebGPUCacheRenderPipeline.NumCacheHitWithoutHash = 0;
WebGPUCacheRenderPipeline.NumCacheHitWithHash = 0;
WebGPUCacheRenderPipeline.NumCacheMiss = 0;
WebGPUCacheRenderPipeline.NumPipelineCreationLastFrame = 0;
WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame = 0;

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuCacheRenderPipelineTree.js
var NodeState = class {
  constructor() {
    this.values = {};
  }
  count() {
    let countNode = 0, countPipeline = this.pipeline ? 1 : 0;
    for (const value in this.values) {
      const node = this.values[value];
      const [childCountNodes, childCoundPipeline] = node.count();
      countNode += childCountNodes;
      countPipeline += childCoundPipeline;
      countNode++;
    }
    return [countNode, countPipeline];
  }
};
var WebGPUCacheRenderPipelineTree = class extends WebGPUCacheRenderPipeline {
  constructor(device, emptyVertexBuffer, useTextureStage) {
    super(device, emptyVertexBuffer, useTextureStage);
    this._nodeStack = [];
    this._nodeStack[0] = WebGPUCacheRenderPipelineTree._Cache;
  }
  static GetNodeCounts() {
    const counts = WebGPUCacheRenderPipelineTree._Cache.count();
    return { nodeCount: counts[0], pipelineCount: counts[1] };
  }
  static _GetPipelines(node, pipelines, curPath, curPathLen) {
    if (node.pipeline) {
      const path = curPath.slice();
      path.length = curPathLen;
      pipelines.push(path);
    }
    for (const value in node.values) {
      const nnode = node.values[value];
      curPath[curPathLen] = parseInt(value);
      WebGPUCacheRenderPipelineTree._GetPipelines(nnode, pipelines, curPath, curPathLen + 1);
    }
  }
  static GetPipelines() {
    const pipelines = [];
    WebGPUCacheRenderPipelineTree._GetPipelines(WebGPUCacheRenderPipelineTree._Cache, pipelines, [], 0);
    return pipelines;
  }
  _getRenderPipeline(param) {
    let node = this._nodeStack[this._stateDirtyLowestIndex];
    for (let i = this._stateDirtyLowestIndex; i < this._statesLength; ++i) {
      let nn = node.values[this._states[i]];
      if (!nn) {
        nn = new NodeState();
        node.values[this._states[i]] = nn;
      }
      node = nn;
      this._nodeStack[i + 1] = node;
    }
    param.token = node;
    param.pipeline = node.pipeline;
  }
  _setRenderPipeline(param) {
    param.token.pipeline = param.pipeline;
  }
};
WebGPUCacheRenderPipelineTree._Cache = new NodeState();

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuStencilStateComposer.js
var WebGPUStencilStateComposer = class extends StencilStateComposer {
  constructor(cache) {
    super(false);
    this._cache = cache;
    this.reset();
  }
  get func() {
    return this._func;
  }
  set func(value) {
    if (this._func === value) {
      return;
    }
    this._func = value;
    this._cache.setStencilCompare(value);
  }
  get funcMask() {
    return this._funcMask;
  }
  set funcMask(value) {
    if (this._funcMask === value) {
      return;
    }
    this._funcMask = value;
    this._cache.setStencilReadMask(value);
  }
  get opStencilFail() {
    return this._opStencilFail;
  }
  set opStencilFail(value) {
    if (this._opStencilFail === value) {
      return;
    }
    this._opStencilFail = value;
    this._cache.setStencilFailOp(value);
  }
  get opDepthFail() {
    return this._opDepthFail;
  }
  set opDepthFail(value) {
    if (this._opDepthFail === value) {
      return;
    }
    this._opDepthFail = value;
    this._cache.setStencilDepthFailOp(value);
  }
  get opStencilDepthPass() {
    return this._opStencilDepthPass;
  }
  set opStencilDepthPass(value) {
    if (this._opStencilDepthPass === value) {
      return;
    }
    this._opStencilDepthPass = value;
    this._cache.setStencilPassOp(value);
  }
  get mask() {
    return this._mask;
  }
  set mask(value) {
    if (this._mask === value) {
      return;
    }
    this._mask = value;
    this._cache.setStencilWriteMask(value);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled === value) {
      return;
    }
    this._enabled = value;
    this._cache.setStencilEnabled(value);
  }
  reset() {
    super.reset();
    this._cache.resetStencilState();
  }
  apply() {
    var _a;
    const stencilMaterialEnabled = (_a = this.stencilMaterial) === null || _a === void 0 ? void 0 : _a.enabled;
    this.enabled = stencilMaterialEnabled ? this.stencilMaterial.enabled : this.stencilGlobal.enabled;
    if (!this.enabled) {
      return;
    }
    this.func = stencilMaterialEnabled ? this.stencilMaterial.func : this.stencilGlobal.func;
    this.funcRef = stencilMaterialEnabled ? this.stencilMaterial.funcRef : this.stencilGlobal.funcRef;
    this.funcMask = stencilMaterialEnabled ? this.stencilMaterial.funcMask : this.stencilGlobal.funcMask;
    this.opStencilFail = stencilMaterialEnabled ? this.stencilMaterial.opStencilFail : this.stencilGlobal.opStencilFail;
    this.opDepthFail = stencilMaterialEnabled ? this.stencilMaterial.opDepthFail : this.stencilGlobal.opDepthFail;
    this.opStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass;
    this.mask = stencilMaterialEnabled ? this.stencilMaterial.mask : this.stencilGlobal.mask;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuDepthCullingState.js
var WebGPUDepthCullingState = class extends DepthCullingState {
  constructor(cache) {
    super(false);
    this._cache = cache;
    this.reset();
  }
  get zOffset() {
    return this._zOffset;
  }
  set zOffset(value) {
    if (this._zOffset === value) {
      return;
    }
    this._zOffset = value;
    this._isZOffsetDirty = true;
    this._cache.setDepthBiasSlopeScale(value);
  }
  get zOffsetUnits() {
    return this._zOffsetUnits;
  }
  set zOffsetUnits(value) {
    if (this._zOffsetUnits === value) {
      return;
    }
    this._zOffsetUnits = value;
    this._isZOffsetDirty = true;
    this._cache.setDepthBias(value);
  }
  get cullFace() {
    return this._cullFace;
  }
  set cullFace(value) {
    if (this._cullFace === value) {
      return;
    }
    this._cullFace = value;
    this._isCullFaceDirty = true;
    this._cache.setCullFace(value !== null && value !== void 0 ? value : 1);
  }
  get cull() {
    return this._cull;
  }
  set cull(value) {
    if (this._cull === value) {
      return;
    }
    this._cull = value;
    this._isCullDirty = true;
    this._cache.setCullEnabled(!!value);
  }
  get depthFunc() {
    return this._depthFunc;
  }
  set depthFunc(value) {
    if (this._depthFunc === value) {
      return;
    }
    this._depthFunc = value;
    this._isDepthFuncDirty = true;
    this._cache.setDepthCompare(value);
  }
  get depthMask() {
    return this._depthMask;
  }
  set depthMask(value) {
    if (this._depthMask === value) {
      return;
    }
    this._depthMask = value;
    this._isDepthMaskDirty = true;
    this._cache.setDepthWriteEnabled(value);
  }
  get depthTest() {
    return this._depthTest;
  }
  set depthTest(value) {
    if (this._depthTest === value) {
      return;
    }
    this._depthTest = value;
    this._isDepthTestDirty = true;
    this._cache.setDepthTestEnabled(value);
  }
  get frontFace() {
    return this._frontFace;
  }
  set frontFace(value) {
    if (this._frontFace === value) {
      return;
    }
    this._frontFace = value;
    this._isFrontFaceDirty = true;
    this._cache.setFrontFace(value !== null && value !== void 0 ? value : 2);
  }
  reset() {
    super.reset();
    this._cache.resetDepthCullingState();
  }
  apply() {
  }
};

// node_modules/@babylonjs/core/Materials/Textures/externalTexture.js
var ExternalTexture = class {
  constructor(video) {
    this.useMipMaps = false;
    this.type = 16;
    this._video = video;
    this.uniqueId = InternalTexture._Counter++;
  }
  static IsExternalTexture(texture) {
    return texture.underlyingResource !== void 0;
  }
  getClassName() {
    return "ExternalTexture";
  }
  get underlyingResource() {
    return this._video;
  }
  isReady() {
    return this._video.readyState >= this._video.HAVE_CURRENT_DATA;
  }
  dispose() {
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuMaterialContext.js
var WebGPUMaterialContext = class {
  constructor() {
    this.uniqueId = WebGPUMaterialContext._Counter++;
    this.updateId = 0;
    this.reset();
  }
  get forceBindGroupCreation() {
    return this._numExternalTextures > 0;
  }
  get hasFloatTextures() {
    return this._numFloatTextures > 0;
  }
  reset() {
    this.samplers = {};
    this.textures = {};
    this.isDirty = true;
    this._numFloatTextures = 0;
    this._numExternalTextures = 0;
  }
  setSampler(name137, sampler) {
    let samplerCache = this.samplers[name137];
    let currentHashCode = -1;
    if (!samplerCache) {
      this.samplers[name137] = samplerCache = { sampler, hashCode: 0 };
    } else {
      currentHashCode = samplerCache.hashCode;
    }
    samplerCache.sampler = sampler;
    samplerCache.hashCode = sampler ? WebGPUCacheSampler.GetSamplerHashCode(sampler) : 0;
    const isDirty = currentHashCode !== samplerCache.hashCode;
    if (isDirty) {
      this.updateId++;
    }
    this.isDirty || (this.isDirty = isDirty);
  }
  setTexture(name137, texture) {
    var _a, _b, _c;
    let textureCache = this.textures[name137];
    let currentTextureId = -1;
    if (!textureCache) {
      this.textures[name137] = textureCache = { texture, isFloatTexture: false, isExternalTexture: false };
    } else {
      currentTextureId = (_b = (_a = textureCache.texture) === null || _a === void 0 ? void 0 : _a.uniqueId) !== null && _b !== void 0 ? _b : -1;
    }
    if (textureCache.isExternalTexture) {
      this._numExternalTextures--;
    }
    if (textureCache.isFloatTexture) {
      this._numFloatTextures--;
    }
    if (texture) {
      textureCache.isFloatTexture = texture.type === 1;
      textureCache.isExternalTexture = ExternalTexture.IsExternalTexture(texture);
      if (textureCache.isFloatTexture) {
        this._numFloatTextures++;
      }
      if (textureCache.isExternalTexture) {
        this._numExternalTextures++;
      }
    } else {
      textureCache.isFloatTexture = false;
      textureCache.isExternalTexture = false;
    }
    textureCache.texture = texture;
    const isDirty = currentTextureId !== ((_c = texture === null || texture === void 0 ? void 0 : texture.uniqueId) !== null && _c !== void 0 ? _c : -1);
    if (isDirty) {
      this.updateId++;
    }
    this.isDirty || (this.isDirty = isDirty);
  }
};
WebGPUMaterialContext._Counter = 0;

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuDrawContext.js
var WebGPUDrawContext = class {
  constructor(bufferManager) {
    this._bufferManager = bufferManager;
    this.uniqueId = WebGPUDrawContext._Counter++;
    this._useInstancing = false;
    this._currentInstanceCount = 0;
    this.reset();
  }
  isDirty(materialContextUpdateId) {
    return this._isDirty || this._materialContextUpdateId !== materialContextUpdateId;
  }
  resetIsDirty(materialContextUpdateId) {
    this._isDirty = false;
    this._materialContextUpdateId = materialContextUpdateId;
  }
  get useInstancing() {
    return this._useInstancing;
  }
  set useInstancing(use) {
    if (this._useInstancing === use) {
      return;
    }
    if (!use) {
      if (this.indirectDrawBuffer) {
        this._bufferManager.releaseBuffer(this.indirectDrawBuffer);
      }
      this.indirectDrawBuffer = void 0;
      this._indirectDrawData = void 0;
    } else {
      this.indirectDrawBuffer = this._bufferManager.createRawBuffer(40, BufferUsage.CopyDst | BufferUsage.Indirect);
      this._indirectDrawData = new Uint32Array(5);
      this._indirectDrawData[3] = 0;
      this._indirectDrawData[4] = 0;
    }
    this._useInstancing = use;
    this._currentInstanceCount = -1;
  }
  reset() {
    this.buffers = {};
    this._isDirty = true;
    this._materialContextUpdateId = 0;
    this.fastBundle = void 0;
    this.bindGroups = void 0;
  }
  setBuffer(name137, buffer) {
    var _a;
    this._isDirty || (this._isDirty = (buffer === null || buffer === void 0 ? void 0 : buffer.uniqueId) !== ((_a = this.buffers[name137]) === null || _a === void 0 ? void 0 : _a.uniqueId));
    this.buffers[name137] = buffer;
  }
  setIndirectData(indexOrVertexCount, instanceCount, firstIndexOrVertex) {
    if (instanceCount === this._currentInstanceCount || !this.indirectDrawBuffer || !this._indirectDrawData) {
      return;
    }
    this._currentInstanceCount = instanceCount;
    this._indirectDrawData[0] = indexOrVertexCount;
    this._indirectDrawData[1] = instanceCount;
    this._indirectDrawData[2] = firstIndexOrVertex;
    this._bufferManager.setRawData(this.indirectDrawBuffer, 0, this._indirectDrawData, 0, 20);
  }
  dispose() {
    if (this.indirectDrawBuffer) {
      this._bufferManager.releaseBuffer(this.indirectDrawBuffer);
      this.indirectDrawBuffer = void 0;
      this._indirectDrawData = void 0;
    }
    this.fastBundle = void 0;
    this.bindGroups = void 0;
    this.buffers = void 0;
  }
};
WebGPUDrawContext._Counter = 0;

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuCacheBindGroups.js
var WebGPUBindGroupCacheNode = class {
  constructor() {
    this.values = {};
  }
};
var WebGPUCacheBindGroups = class {
  constructor(device, cacheSampler, engine) {
    this.disabled = false;
    this._device = device;
    this._cacheSampler = cacheSampler;
    this._engine = engine;
  }
  static get Statistics() {
    return {
      totalCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedTotal,
      lastFrameCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame,
      lookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame,
      noLookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame
    };
  }
  endFrame() {
    WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame;
    WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame;
    WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame;
    WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;
    WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;
    WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;
  }
  getBindGroups(webgpuPipelineContext, drawContext, materialContext) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    let bindGroups = void 0;
    let node = WebGPUCacheBindGroups._Cache;
    const cacheIsDisabled = this.disabled || materialContext.forceBindGroupCreation;
    if (!cacheIsDisabled) {
      if (!drawContext.isDirty(materialContext.updateId) && !materialContext.isDirty) {
        WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame++;
        return drawContext.bindGroups;
      }
      for (const bufferName of webgpuPipelineContext.shaderProcessingContext.bufferNames) {
        const uboId = (_b = (_a = drawContext.buffers[bufferName]) === null || _a === void 0 ? void 0 : _a.uniqueId) !== null && _b !== void 0 ? _b : 0;
        let nextNode = node.values[uboId];
        if (!nextNode) {
          nextNode = new WebGPUBindGroupCacheNode();
          node.values[uboId] = nextNode;
        }
        node = nextNode;
      }
      for (const samplerName of webgpuPipelineContext.shaderProcessingContext.samplerNames) {
        const samplerHashCode = (_d = (_c = materialContext.samplers[samplerName]) === null || _c === void 0 ? void 0 : _c.hashCode) !== null && _d !== void 0 ? _d : 0;
        let nextNode = node.values[samplerHashCode];
        if (!nextNode) {
          nextNode = new WebGPUBindGroupCacheNode();
          node.values[samplerHashCode] = nextNode;
        }
        node = nextNode;
      }
      for (const textureName of webgpuPipelineContext.shaderProcessingContext.textureNames) {
        const textureId = (_g = (_f = (_e = materialContext.textures[textureName]) === null || _e === void 0 ? void 0 : _e.texture) === null || _f === void 0 ? void 0 : _f.uniqueId) !== null && _g !== void 0 ? _g : 0;
        let nextNode = node.values[textureId];
        if (!nextNode) {
          nextNode = new WebGPUBindGroupCacheNode();
          node.values[textureId] = nextNode;
        }
        node = nextNode;
      }
      bindGroups = node.bindGroups;
    }
    drawContext.resetIsDirty(materialContext.updateId);
    materialContext.isDirty = false;
    if (bindGroups) {
      drawContext.bindGroups = bindGroups;
      WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame++;
      return bindGroups;
    }
    bindGroups = [];
    drawContext.bindGroups = bindGroups;
    if (!cacheIsDisabled) {
      node.bindGroups = bindGroups;
    }
    WebGPUCacheBindGroups.NumBindGroupsCreatedTotal++;
    WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame++;
    const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts;
    for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries.length; i++) {
      const setDefinition = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i];
      const entries = webgpuPipelineContext.shaderProcessingContext.bindGroupEntries[i];
      for (let j = 0; j < setDefinition.length; j++) {
        const entry = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i][j];
        const entryInfo = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding];
        const name137 = (_h = entryInfo.nameInArrayOfTexture) !== null && _h !== void 0 ? _h : entryInfo.name;
        if (entry.sampler) {
          const bindingInfo = materialContext.samplers[name137];
          if (bindingInfo) {
            const sampler = bindingInfo.sampler;
            if (!sampler) {
              if (this._engine.dbgSanityChecks) {
                Logger.Error(`Trying to bind a null sampler! entry=${JSON.stringify(entry)}, name=${name137}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === "texture" ? "<no dump>" : value)}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);
              }
              continue;
            }
            entries[j].resource = this._cacheSampler.getSampler(sampler, false, bindingInfo.hashCode);
          } else {
            Logger.Error(`Sampler "${name137}" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key, value) => key === "texture" || key === "sampler" ? "<no dump>" : value)}`, 50);
          }
        } else if (entry.texture || entry.storageTexture) {
          const bindingInfo = materialContext.textures[name137];
          if (bindingInfo) {
            if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {
              Logger.Error(`Trying to bind a null texture! entry=${JSON.stringify(entry)}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === "texture" ? "<no dump>" : value)}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);
              continue;
            }
            const hardwareTexture = bindingInfo.texture._hardwareTexture;
            if (this._engine.dbgSanityChecks && (!hardwareTexture || entry.texture && !hardwareTexture.view || entry.storageTexture && !hardwareTexture.viewForWriting)) {
              Logger.Error(`Trying to bind a null gpu texture or view! entry=${JSON.stringify(entry)}, name=${name137}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === "texture" ? "<no dump>" : value)}, isReady=${(_j = bindingInfo.texture) === null || _j === void 0 ? void 0 : _j.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);
              continue;
            }
            entries[j].resource = entry.storageTexture ? hardwareTexture.viewForWriting : hardwareTexture.view;
          } else {
            Logger.Error(`Texture "${name137}" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key, value) => key === "texture" || key === "sampler" ? "<no dump>" : value)}`, 50);
          }
        } else if (entry.externalTexture) {
          const bindingInfo = materialContext.textures[name137];
          if (bindingInfo) {
            if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {
              Logger.Error(`Trying to bind a null external texture! entry=${JSON.stringify(entry)}, name=${name137}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === "texture" ? "<no dump>" : value)}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);
              continue;
            }
            const externalTexture = bindingInfo.texture.underlyingResource;
            if (this._engine.dbgSanityChecks && !externalTexture) {
              Logger.Error(`Trying to bind a null gpu external texture! entry=${JSON.stringify(entry)}, name=${name137}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === "texture" ? "<no dump>" : value)}, isReady=${(_k = bindingInfo.texture) === null || _k === void 0 ? void 0 : _k.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);
              continue;
            }
            entries[j].resource = this._device.importExternalTexture({ source: externalTexture });
          } else {
            Logger.Error(`Texture "${name137}" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key, value) => key === "texture" || key === "sampler" ? "<no dump>" : value)}`, 50);
          }
        } else if (entry.buffer) {
          const dataBuffer = drawContext.buffers[name137];
          if (dataBuffer) {
            const webgpuBuffer = dataBuffer.underlyingResource;
            entries[j].resource.buffer = webgpuBuffer;
            entries[j].resource.size = dataBuffer.capacity;
          } else {
            Logger.Error(`Can't find buffer "${name137}". entry=${JSON.stringify(entry)}, buffers=${JSON.stringify(drawContext.buffers)}, drawContext.uniqueId=${drawContext.uniqueId}`, 50);
          }
        }
      }
      const groupLayout = bindGroupLayouts[i];
      bindGroups[i] = this._device.createBindGroup({
        layout: groupLayout,
        entries
      });
    }
    return bindGroups;
  }
};
WebGPUCacheBindGroups.NumBindGroupsCreatedTotal = 0;
WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = 0;
WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = 0;
WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = 0;
WebGPUCacheBindGroups._Cache = new WebGPUBindGroupCacheNode();
WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;
WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;
WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;

// node_modules/@babylonjs/core/Shaders/clearQuad.vertex.js
var name24 = "clearQuadVertexShader";
var shader24 = `uniform float depthValue;
const vec2 pos[4]={
vec2(-1.0,1.0),
vec2(1.0,1.0),
vec2(-1.0,-1.0),
vec2(1.0,-1.0)
};
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
gl_Position=vec4(pos[gl_VertexID],depthValue,1.0);
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name24] = shader24;

// node_modules/@babylonjs/core/Shaders/clearQuad.fragment.js
var name25 = "clearQuadPixelShader";
var shader25 = `uniform vec4 color;
void main() {
gl_FragColor=color;
}
`;
ShaderStore.ShadersStore[name25] = shader25;

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuClearQuad.js
var WebGPUClearQuad = class {
  constructor(device, engine, emptyVertexBuffer) {
    this._bindGroups = {};
    this._bundleCache = {};
    this._keyTemp = [];
    this._device = device;
    this._engine = engine;
    this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, emptyVertexBuffer, !engine._caps.textureFloatLinearFiltering);
    this._cacheRenderPipeline.setDepthTestEnabled(false);
    this._cacheRenderPipeline.setStencilReadMask(255);
    this._effect = engine.createEffect("clearQuad", [], ["color", "depthValue"]);
  }
  setDepthStencilFormat(format) {
    this._depthTextureFormat = format;
    this._cacheRenderPipeline.setDepthStencilFormat(format);
  }
  setColorFormat(format) {
    this._cacheRenderPipeline.setColorFormat(format);
  }
  setMRTAttachments(attachments, textureArray, textureCount) {
    this._cacheRenderPipeline.setMRT(textureArray, textureCount);
    this._cacheRenderPipeline.setMRTAttachments(attachments);
  }
  clear(renderPass, clearColor, clearDepth, clearStencil, sampleCount = 1) {
    var _a, _b;
    let renderPass2;
    let bundle = null;
    let bundleKey;
    const isRTTPass = !!this._engine._currentRenderTarget;
    if (renderPass) {
      renderPass2 = renderPass;
    } else {
      let idx = 0;
      this._keyTemp.length = 0;
      for (let i = 0; i < this._cacheRenderPipeline.colorFormats.length; ++i) {
        this._keyTemp[idx++] = renderableTextureFormatToIndex[(_a = this._cacheRenderPipeline.colorFormats[i]) !== null && _a !== void 0 ? _a : ""];
      }
      const depthStencilFormatIndex = renderableTextureFormatToIndex[(_b = this._depthTextureFormat) !== null && _b !== void 0 ? _b : 0];
      this._keyTemp[idx] = (clearColor ? clearColor.r + clearColor.g * 256 + clearColor.b * 256 * 256 + clearColor.a * 256 * 256 * 256 : 0) + (clearDepth ? 2 ** 32 : 0) + (clearStencil ? 2 ** 33 : 0) + (this._engine.useReverseDepthBuffer ? 2 ** 34 : 0) + (isRTTPass ? 2 ** 35 : 0) + (sampleCount > 1 ? 2 ** 36 : 0) + depthStencilFormatIndex * 2 ** 37;
      bundleKey = this._keyTemp.join("_");
      bundle = this._bundleCache[bundleKey];
      if (bundle) {
        return bundle;
      }
      renderPass2 = this._device.createRenderBundleEncoder({
        colorFormats: this._cacheRenderPipeline.colorFormats,
        depthStencilFormat: this._depthTextureFormat,
        sampleCount
      });
    }
    this._cacheRenderPipeline.setDepthWriteEnabled(!!clearDepth);
    this._cacheRenderPipeline.setStencilEnabled(!!clearStencil && !!this._depthTextureFormat && WebGPUTextureHelper.HasStencilAspect(this._depthTextureFormat));
    this._cacheRenderPipeline.setStencilWriteMask(clearStencil ? 255 : 0);
    this._cacheRenderPipeline.setStencilCompare(clearStencil ? 519 : 512);
    this._cacheRenderPipeline.setStencilPassOp(clearStencil ? 7681 : 7680);
    this._cacheRenderPipeline.setWriteMask(clearColor ? 15 : 0);
    const pipeline = this._cacheRenderPipeline.getRenderPipeline(7, this._effect, sampleCount);
    const webgpuPipelineContext = this._effect._pipelineContext;
    if (clearColor) {
      this._effect.setDirectColor4("color", clearColor);
    }
    this._effect.setFloat("depthValue", this._engine.useReverseDepthBuffer ? this._engine._clearReverseDepthValue : this._engine._clearDepthValue);
    webgpuPipelineContext.uniformBuffer.update();
    const bufferInternals = isRTTPass ? this._engine._ubInvertY : this._engine._ubDontInvertY;
    const bufferLeftOver = webgpuPipelineContext.uniformBuffer.getBuffer();
    const key = bufferLeftOver.uniqueId + "-" + bufferInternals.uniqueId;
    let bindGroups = this._bindGroups[key];
    if (!bindGroups) {
      const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts;
      bindGroups = this._bindGroups[key] = [];
      bindGroups.push(this._device.createBindGroup({
        layout: bindGroupLayouts[0],
        entries: []
      }));
      if (!WebGPUShaderProcessingContext._SimplifiedKnownBindings) {
        bindGroups.push(this._device.createBindGroup({
          layout: bindGroupLayouts[1],
          entries: []
        }));
      }
      bindGroups.push(this._device.createBindGroup({
        layout: bindGroupLayouts[WebGPUShaderProcessingContext._SimplifiedKnownBindings ? 1 : 2],
        entries: [
          {
            binding: 0,
            resource: {
              buffer: bufferInternals.underlyingResource,
              size: bufferInternals.capacity
            }
          },
          {
            binding: 1,
            resource: {
              buffer: bufferLeftOver.underlyingResource,
              size: bufferLeftOver.capacity
            }
          }
        ]
      }));
    }
    renderPass2.setPipeline(pipeline);
    for (let i = 0; i < bindGroups.length; ++i) {
      renderPass2.setBindGroup(i, bindGroups[i]);
    }
    renderPass2.draw(4, 1, 0, 0);
    if (!renderPass) {
      bundle = renderPass2.finish();
      this._bundleCache[bundleKey] = bundle;
    }
    return bundle;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuBundleList.js
var WebGPURenderItemViewport = class {
  constructor(x, y, w, h) {
    this.x = Math.floor(x);
    this.y = Math.floor(y);
    this.w = Math.floor(w);
    this.h = Math.floor(h);
  }
  run(renderPass) {
    renderPass.setViewport(this.x, this.y, this.w, this.h, 0, 1);
  }
  clone() {
    return new WebGPURenderItemViewport(this.x, this.y, this.w, this.h);
  }
};
var WebGPURenderItemScissor = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
  run(renderPass) {
    renderPass.setScissorRect(this.x, this.y, this.w, this.h);
  }
  clone() {
    return new WebGPURenderItemScissor(this.x, this.y, this.w, this.h);
  }
};
var WebGPURenderItemStencilRef = class {
  constructor(ref) {
    this.ref = ref;
  }
  run(renderPass) {
    renderPass.setStencilReference(this.ref);
  }
  clone() {
    return new WebGPURenderItemStencilRef(this.ref);
  }
};
var WebGPURenderItemBlendColor = class {
  constructor(color) {
    this.color = color;
  }
  run(renderPass) {
    renderPass.setBlendConstant(this.color);
  }
  clone() {
    return new WebGPURenderItemBlendColor(this.color);
  }
};
var WebGPURenderItemBeginOcclusionQuery = class {
  constructor(query) {
    this.query = query;
  }
  run(renderPass) {
    renderPass.beginOcclusionQuery(this.query);
  }
  clone() {
    return new WebGPURenderItemBeginOcclusionQuery(this.query);
  }
};
var WebGPURenderItemEndOcclusionQuery = class {
  constructor() {
  }
  run(renderPass) {
    renderPass.endOcclusionQuery();
  }
  clone() {
    return new WebGPURenderItemEndOcclusionQuery();
  }
};
var WebGPURenderItemBundles = class {
  constructor() {
    this.bundles = [];
  }
  run(renderPass) {
    renderPass.executeBundles(this.bundles);
  }
  clone() {
    const cloned = new WebGPURenderItemBundles();
    cloned.bundles = this.bundles;
    return cloned;
  }
};
var WebGPUBundleList = class {
  constructor(device) {
    this.numDrawCalls = 0;
    this._device = device;
    this._list = new Array(10);
    this._listLength = 0;
  }
  addBundle(bundle) {
    if (!this._currentItemIsBundle) {
      const item = new WebGPURenderItemBundles();
      this._list[this._listLength++] = item;
      this._currentBundleList = item.bundles;
      this._currentItemIsBundle = true;
    }
    if (bundle) {
      this._currentBundleList.push(bundle);
    }
  }
  _finishBundle() {
    if (this._currentItemIsBundle && this._bundleEncoder) {
      this._currentBundleList.push(this._bundleEncoder.finish());
      this._bundleEncoder = void 0;
      this._currentItemIsBundle = false;
    }
  }
  addItem(item) {
    this._finishBundle();
    this._list[this._listLength++] = item;
    this._currentItemIsBundle = false;
  }
  getBundleEncoder(colorFormats, depthStencilFormat, sampleCount) {
    if (!this._currentItemIsBundle) {
      this.addBundle();
      this._bundleEncoder = this._device.createRenderBundleEncoder({
        colorFormats,
        depthStencilFormat,
        sampleCount
      });
    }
    return this._bundleEncoder;
  }
  close() {
    this._finishBundle();
  }
  run(renderPass) {
    this.close();
    for (let i = 0; i < this._listLength; ++i) {
      this._list[i].run(renderPass);
    }
  }
  reset() {
    this._listLength = 0;
    this._currentItemIsBundle = false;
    this.numDrawCalls = 0;
  }
  clone() {
    this.close();
    const cloned = new WebGPUBundleList(this._device);
    cloned._list = new Array(this._listLength);
    cloned._listLength = this._listLength;
    cloned.numDrawCalls = this.numDrawCalls;
    for (let i = 0; i < this._listLength; ++i) {
      cloned._list[i] = this._list[i].clone();
    }
    return cloned;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuQuerySet.js
var WebGPUQuerySet = class {
  constructor(count, type, device, bufferManager, canUseMultipleBuffers = true) {
    this._dstBuffers = [];
    this._device = device;
    this._bufferManager = bufferManager;
    this._count = count;
    this._canUseMultipleBuffers = canUseMultipleBuffers;
    this._querySet = device.createQuerySet({
      type,
      count
    });
    this._queryBuffer = bufferManager.createRawBuffer(8 * count, BufferUsage.QueryResolve | BufferUsage.CopySrc);
    if (!canUseMultipleBuffers) {
      this._dstBuffers.push(this._bufferManager.createRawBuffer(8 * this._count, BufferUsage.MapRead | BufferUsage.CopyDst));
    }
  }
  get querySet() {
    return this._querySet;
  }
  _getBuffer(firstQuery, queryCount) {
    if (!this._canUseMultipleBuffers && this._dstBuffers.length === 0) {
      return null;
    }
    const encoderResult = this._device.createCommandEncoder();
    let buffer;
    if (this._dstBuffers.length === 0) {
      buffer = this._bufferManager.createRawBuffer(8 * this._count, BufferUsage.MapRead | BufferUsage.CopyDst);
    } else {
      buffer = this._dstBuffers[this._dstBuffers.length - 1];
      this._dstBuffers.length--;
    }
    encoderResult.resolveQuerySet(this._querySet, firstQuery, queryCount, this._queryBuffer, 0);
    encoderResult.copyBufferToBuffer(this._queryBuffer, 0, buffer, 0, 8 * queryCount);
    this._device.queue.submit([encoderResult.finish()]);
    return buffer;
  }
  async readValues(firstQuery = 0, queryCount = 1) {
    const buffer = this._getBuffer(firstQuery, queryCount);
    if (buffer === null) {
      return null;
    }
    await buffer.mapAsync(MapMode.Read);
    const arrayBuf = new BigUint64Array(buffer.getMappedRange()).slice();
    buffer.unmap();
    this._dstBuffers[this._dstBuffers.length] = buffer;
    return arrayBuf;
  }
  async readValue(firstQuery = 0) {
    const buffer = this._getBuffer(firstQuery, 1);
    if (buffer === null) {
      return null;
    }
    await buffer.mapAsync(MapMode.Read);
    const arrayBuf = new BigUint64Array(buffer.getMappedRange());
    const value = Number(arrayBuf[0]);
    buffer.unmap();
    this._dstBuffers[this._dstBuffers.length] = buffer;
    return value;
  }
  async readTwoValuesAndSubtract(firstQuery = 0) {
    const buffer = this._getBuffer(firstQuery, 2);
    if (buffer === null) {
      return null;
    }
    await buffer.mapAsync(MapMode.Read);
    const arrayBuf = new BigUint64Array(buffer.getMappedRange());
    const value = Number(arrayBuf[1] - arrayBuf[0]);
    buffer.unmap();
    this._dstBuffers[this._dstBuffers.length] = buffer;
    return value;
  }
  dispose() {
    this._querySet.destroy();
    this._bufferManager.releaseBuffer(this._queryBuffer);
    for (let i = 0; i < this._dstBuffers.length; ++i) {
      this._bufferManager.releaseBuffer(this._dstBuffers[i]);
    }
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuTimestampQuery.js
var WebGPUTimestampQuery = class {
  constructor(device, bufferManager) {
    this._enabled = false;
    this._gpuFrameTimeCounter = new PerfCounter();
    this._measureDurationState = 0;
    this._device = device;
    this._bufferManager = bufferManager;
  }
  get gpuFrameTimeCounter() {
    return this._gpuFrameTimeCounter;
  }
  get enable() {
    return this._enabled;
  }
  set enable(value) {
    if (this._enabled === value) {
      return;
    }
    this._enabled = value;
    this._measureDurationState = 0;
    if (value) {
      this._measureDuration = new WebGPUDurationMeasure(this._device, this._bufferManager);
    } else {
      this._measureDuration.dispose();
    }
  }
  startFrame(commandEncoder) {
    if (this._enabled && this._measureDurationState === 0) {
      this._measureDuration.start(commandEncoder);
      this._measureDurationState = 1;
    }
  }
  endFrame(commandEncoder) {
    if (this._measureDurationState === 1) {
      this._measureDurationState = 2;
      this._measureDuration.stop(commandEncoder).then((duration) => {
        if (duration !== null && duration >= 0) {
          this._gpuFrameTimeCounter.fetchNewFrame();
          this._gpuFrameTimeCounter.addCount(duration, true);
        }
        this._measureDurationState = 0;
      });
    }
  }
};
var WebGPUDurationMeasure = class {
  constructor(device, bufferManager) {
    this._querySet = new WebGPUQuerySet(2, QueryType.Timestamp, device, bufferManager);
  }
  start(encoder) {
    encoder.writeTimestamp(this._querySet.querySet, 0);
  }
  async stop(encoder) {
    encoder.writeTimestamp(this._querySet.querySet, 1);
    return this._querySet.readTwoValuesAndSubtract(0);
  }
  dispose() {
    this._querySet.dispose();
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuOcclusionQuery.js
var WebGPUOcclusionQuery = class {
  constructor(engine, device, bufferManager, startCount = 50, incrementCount = 100) {
    this._availableIndices = [];
    this._engine = engine;
    this._device = device;
    this._bufferManager = bufferManager;
    this._frameLastBuffer = -1;
    this._currentTotalIndices = 0;
    this._countIncrement = incrementCount;
    this._allocateNewIndices(startCount);
  }
  get querySet() {
    return this._querySet.querySet;
  }
  get hasQueries() {
    return this._currentTotalIndices !== this._availableIndices.length;
  }
  get canBeginQuery() {
    const passIndex = this._engine._getCurrentRenderPassIndex();
    switch (passIndex) {
      case 0: {
        return this._engine._mainRenderPassWrapper.renderPassDescriptor.occlusionQuerySet !== void 0;
      }
      case 1: {
        return this._engine._rttRenderPassWrapper.renderPassDescriptor.occlusionQuerySet !== void 0;
      }
    }
    return false;
  }
  createQuery() {
    if (this._availableIndices.length === 0) {
      this._allocateNewIndices();
    }
    const index = this._availableIndices[this._availableIndices.length - 1];
    this._availableIndices.length--;
    return index;
  }
  deleteQuery(index) {
    this._availableIndices[this._availableIndices.length - 1] = index;
  }
  isQueryResultAvailable(index) {
    this._retrieveQueryBuffer();
    return !!this._lastBuffer && index < this._lastBuffer.length;
  }
  getQueryResult(index) {
    var _a, _b;
    return Number((_b = (_a = this._lastBuffer) === null || _a === void 0 ? void 0 : _a[index]) !== null && _b !== void 0 ? _b : -1);
  }
  _retrieveQueryBuffer() {
    if (this._lastBuffer && this._frameLastBuffer === this._engine.frameId) {
      return;
    }
    if (this._frameLastBuffer !== this._engine.frameId) {
      this._frameLastBuffer = this._engine.frameId;
      this._querySet.readValues(0, this._currentTotalIndices).then((arrayBuffer) => {
        this._lastBuffer = arrayBuffer;
      });
    }
  }
  _allocateNewIndices(numIndices) {
    numIndices = numIndices !== null && numIndices !== void 0 ? numIndices : this._countIncrement;
    this._delayQuerySetDispose();
    for (let i = 0; i < numIndices; ++i) {
      this._availableIndices.push(this._currentTotalIndices + i);
    }
    this._currentTotalIndices += numIndices;
    this._querySet = new WebGPUQuerySet(this._currentTotalIndices, QueryType.Occlusion, this._device, this._bufferManager, false);
  }
  _delayQuerySetDispose() {
    const querySet = this._querySet;
    if (querySet) {
      setTimeout(() => querySet.dispose, 1e3);
    }
  }
  dispose() {
    var _a;
    (_a = this._querySet) === null || _a === void 0 ? void 0 : _a.dispose();
    this._availableIndices.length = 0;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuTintWASM.js
var WebGPUTintWASM = class {
  constructor() {
    this._twgsl = null;
  }
  async initTwgsl(twgslOptions) {
    twgslOptions = twgslOptions || {};
    twgslOptions = {
      ...WebGPUTintWASM._TWgslDefaultOptions,
      ...twgslOptions
    };
    if (twgslOptions.twgsl) {
      this._twgsl = twgslOptions.twgsl;
      return Promise.resolve();
    }
    if (twgslOptions.jsPath && twgslOptions.wasmPath) {
      if (IsWindowObjectExist()) {
        await Tools.LoadScriptAsync(twgslOptions.jsPath);
      } else {
        importScripts(twgslOptions.jsPath);
      }
    }
    if (self.twgsl) {
      this._twgsl = await self.twgsl(twgslOptions.wasmPath);
      return Promise.resolve();
    }
    return Promise.reject("twgsl is not available.");
  }
  convertSpirV2WGSL(code) {
    const ccode = this._twgsl.convertSpirV2WGSL(code);
    if (WebGPUTintWASM.ShowWGSLShaderCode) {
      console.log(ccode);
      console.log("***********************************************");
    }
    return ccode;
  }
};
WebGPUTintWASM._TWgslDefaultOptions = {
  jsPath: "https://preview.babylonjs.com/twgsl/twgsl.js",
  wasmPath: "https://preview.babylonjs.com/twgsl/twgsl.wasm"
};
WebGPUTintWASM.ShowWGSLShaderCode = false;

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuSnapshotRendering.js
var WebGPUSnapshotRendering = class {
  constructor(engine, renderingMode, bundleList, bundleListRenderTarget) {
    this._record = false;
    this._play = false;
    this._mainPassBundleList = [];
    this._enabled = false;
    this._engine = engine;
    this._mode = renderingMode;
    this._bundleList = bundleList;
    this._bundleListRenderTarget = bundleListRenderTarget;
  }
  get enabled() {
    return this._enabled;
  }
  get play() {
    return this._play;
  }
  get record() {
    return this._record;
  }
  set enabled(activate) {
    this._mainPassBundleList.length = 0;
    this._record = this._enabled = activate;
    this._play = false;
    if (activate) {
      this._modeSaved = this._mode;
      this._mode = 0;
    }
  }
  get mode() {
    return this._mode;
  }
  set mode(mode) {
    if (this._record) {
      this._modeSaved = mode;
    } else {
      this._mode = mode;
    }
  }
  endMainRenderPass() {
    if (this._record) {
      this._mainPassBundleList.push(this._bundleList.clone());
    }
  }
  endRenderTargetPass(currentRenderPass, gpuWrapper) {
    var _a, _b, _c, _d;
    if (this._play) {
      (_b = (_a = gpuWrapper._bundleLists) === null || _a === void 0 ? void 0 : _a[gpuWrapper._currentLayer]) === null || _b === void 0 ? void 0 : _b.run(currentRenderPass);
      if (this._mode === 1) {
        this._engine._reportDrawCall((_d = (_c = gpuWrapper._bundleLists) === null || _c === void 0 ? void 0 : _c[gpuWrapper._currentLayer]) === null || _d === void 0 ? void 0 : _d.numDrawCalls);
      }
    } else if (this._record) {
      if (!gpuWrapper._bundleLists) {
        gpuWrapper._bundleLists = [];
      }
      gpuWrapper._bundleLists[gpuWrapper._currentLayer] = this._bundleListRenderTarget.clone();
      gpuWrapper._bundleLists[gpuWrapper._currentLayer].run(currentRenderPass);
      this._bundleListRenderTarget.reset();
    } else {
      return false;
    }
    return true;
  }
  endFrame(mainRenderPass) {
    if (this._record) {
      this._mainPassBundleList.push(this._bundleList.clone());
      this._record = false;
      this._play = true;
      this._mode = this._modeSaved;
    }
    if (mainRenderPass !== null && this._play) {
      for (let i = 0; i < this._mainPassBundleList.length; ++i) {
        this._mainPassBundleList[i].run(mainRenderPass);
        if (this._mode === 1) {
          this._engine._reportDrawCall(this._mainPassBundleList[i].numDrawCalls);
        }
      }
    }
  }
  reset() {
    this.enabled = false;
    this.enabled = true;
  }
};

// node_modules/@babylonjs/core/Engines/webgpuEngine.js
var WebGPUEngine = class extends Engine {
  constructor(canvas, options = {}) {
    var _a, _b, _c, _d;
    super(null);
    this._uploadEncoderDescriptor = { label: "upload" };
    this._renderEncoderDescriptor = { label: "render" };
    this._renderTargetEncoderDescriptor = { label: "renderTarget" };
    this._clearDepthValue = 1;
    this._clearReverseDepthValue = 0;
    this._clearStencilValue = 0;
    this._defaultSampleCount = 4;
    this._glslang = null;
    this._tintWASM = null;
    this._compiledComputeEffects = {};
    this._counters = {
      numEnableEffects: 0,
      numEnableDrawWrapper: 0,
      numBundleCreationNonCompatMode: 0,
      numBundleReuseNonCompatMode: 0
    };
    this.countersLastFrame = {
      numEnableEffects: 0,
      numEnableDrawWrapper: 0,
      numBundleCreationNonCompatMode: 0,
      numBundleReuseNonCompatMode: 0
    };
    this.numMaxUncapturedErrors = 20;
    this._commandBuffers = [null, null, null];
    this._currentRenderPass = null;
    this._mainRenderPassWrapper = new WebGPURenderPassWrapper();
    this._rttRenderPassWrapper = new WebGPURenderPassWrapper();
    this._pendingDebugCommands = [];
    this._onAfterUnbindFrameBufferObservable = new Observable();
    this._currentOverrideVertexBuffers = null;
    this._currentIndexBuffer = null;
    this._colorWriteLocal = true;
    this._forceEnableEffect = false;
    this.dbgShowShaderCode = false;
    this.dbgSanityChecks = true;
    this.dbgVerboseLogsForFirstFrames = false;
    this.dbgVerboseLogsNumFrames = 10;
    this.dbgLogIfNotDrawWrapper = true;
    this.dbgShowEmptyEnableEffectCalls = true;
    this._viewportsCurrent = [
      { x: 0, y: 0, w: 0, h: 0 },
      { x: 0, y: 0, w: 0, h: 0 }
    ];
    this._scissorsCurrent = [
      { x: 0, y: 0, w: 0, h: 0 },
      { x: 0, y: 0, w: 0, h: 0 }
    ];
    this._scissorCached = { x: 0, y: 0, z: 0, w: 0 };
    this._stencilRefsCurrent = [-1, -1];
    this._blendColorsCurrent = [
      [null, null, null, null],
      [null, null, null, null]
    ];
    this._name = "WebGPU";
    this.isNDCHalfZRange = true;
    this.hasOriginBottomLeft = false;
    options.deviceDescriptor = options.deviceDescriptor || {};
    options.antialiasing = options.antialiasing === void 0 ? true : options.antialiasing;
    options.stencil = (_a = options.stencil) !== null && _a !== void 0 ? _a : true;
    options.enableGPUDebugMarkers = (_b = options.enableGPUDebugMarkers) !== null && _b !== void 0 ? _b : false;
    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);
    Logger.Log(`Babylon.js v${Engine.Version} - ${this.description} engine`);
    if (!navigator.gpu) {
      Logger.Error("WebGPU is not supported by your browser.");
      return;
    }
    options.swapChainFormat = options.swapChainFormat || navigator.gpu.getPreferredCanvasFormat();
    this._isWebGPU = true;
    this._shaderPlatformName = "WEBGPU";
    if (options.deterministicLockstep === void 0) {
      options.deterministicLockstep = false;
    }
    if (options.lockstepMaxSteps === void 0) {
      options.lockstepMaxSteps = 4;
    }
    if (options.audioEngine === void 0) {
      options.audioEngine = true;
    }
    this._deterministicLockstep = options.deterministicLockstep;
    this._lockstepMaxSteps = options.lockstepMaxSteps;
    this._timeStep = options.timeStep || 1 / 60;
    this._doNotHandleContextLost = !!options.doNotHandleContextLost;
    this._canvas = canvas;
    this._options = options;
    this.premultipliedAlpha = (_c = options.premultipliedAlpha) !== null && _c !== void 0 ? _c : true;
    const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1 : 1;
    const limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;
    const adaptToDeviceRatio = (_d = options.adaptToDeviceRatio) !== null && _d !== void 0 ? _d : false;
    this._hardwareScalingLevel = adaptToDeviceRatio ? 1 / Math.min(limitDeviceRatio, devicePixelRatio) : 1;
    this._mainPassSampleCount = options.antialiasing ? this._defaultSampleCount : 1;
    this._isStencilEnable = options.stencil;
    this._sharedInit(canvas, !!options.doNotHandleTouchAction, options.audioEngine);
    this._shaderProcessor = new WebGPUShaderProcessorGLSL();
    this._shaderProcessorWGSL = new WebGPUShaderProcessorWGSL();
  }
  get snapshotRenderingMode() {
    return this._snapshotRendering.mode;
  }
  set snapshotRenderingMode(mode) {
    this._snapshotRendering.mode = mode;
  }
  snapshotRenderingReset() {
    this._snapshotRendering.reset();
  }
  get snapshotRendering() {
    return this._snapshotRendering.enabled;
  }
  set snapshotRendering(activate) {
    this._snapshotRendering.enabled = activate;
  }
  get disableCacheSamplers() {
    return this._cacheSampler ? this._cacheSampler.disabled : false;
  }
  set disableCacheSamplers(disable) {
    if (this._cacheSampler) {
      this._cacheSampler.disabled = disable;
    }
  }
  get disableCacheRenderPipelines() {
    return this._cacheRenderPipeline ? this._cacheRenderPipeline.disabled : false;
  }
  set disableCacheRenderPipelines(disable) {
    if (this._cacheRenderPipeline) {
      this._cacheRenderPipeline.disabled = disable;
    }
  }
  get disableCacheBindGroups() {
    return this._cacheBindGroups ? this._cacheBindGroups.disabled : false;
  }
  set disableCacheBindGroups(disable) {
    if (this._cacheBindGroups) {
      this._cacheBindGroups.disabled = disable;
    }
  }
  static get IsSupportedAsync() {
    return !navigator.gpu ? Promise.resolve(false) : navigator.gpu.requestAdapter().then((adapter) => !!adapter, () => false).catch(() => false);
  }
  static get IsSupported() {
    Logger.Warn("You must call IsSupportedAsync for WebGPU!");
    return false;
  }
  get supportsUniformBuffers() {
    return true;
  }
  get supportedExtensions() {
    return this._adapterSupportedExtensions;
  }
  get enabledExtensions() {
    return this._deviceEnabledExtensions;
  }
  get description() {
    const description = this.name + this.version;
    return description;
  }
  get version() {
    return 1;
  }
  getInfo() {
    return {
      vendor: "unknown vendor",
      renderer: "unknown renderer",
      version: "unknown version"
    };
  }
  get compatibilityMode() {
    return this._compatibilityMode;
  }
  set compatibilityMode(mode) {
    this._compatibilityMode = mode;
  }
  get currentSampleCount() {
    return this._currentRenderTarget ? this._currentRenderTarget.samples : this._mainPassSampleCount;
  }
  static CreateAsync(canvas, options = {}) {
    const engine = new WebGPUEngine(canvas, options);
    return new Promise((resolve) => {
      engine.initAsync(options.glslangOptions, options.twgslOptions).then(() => resolve(engine));
    });
  }
  initAsync(glslangOptions, twgslOptions) {
    var _a;
    return this._initGlslang(glslangOptions !== null && glslangOptions !== void 0 ? glslangOptions : (_a = this._options) === null || _a === void 0 ? void 0 : _a.glslangOptions).then((glslang) => {
      var _a2;
      this._glslang = glslang;
      this._tintWASM = WebGPUEngine.UseTWGSL ? new WebGPUTintWASM() : null;
      return this._tintWASM ? this._tintWASM.initTwgsl(twgslOptions !== null && twgslOptions !== void 0 ? twgslOptions : (_a2 = this._options) === null || _a2 === void 0 ? void 0 : _a2.twgslOptions).then(() => {
        return navigator.gpu.requestAdapter(this._options);
      }, (msg) => {
        Logger.Error("Can not initialize twgsl!");
        Logger.Error(msg);
        throw Error("WebGPU initializations stopped.");
      }) : navigator.gpu.requestAdapter(this._options);
    }, (msg) => {
      Logger.Error("Can not initialize glslang!");
      Logger.Error(msg);
      throw Error("WebGPU initializations stopped.");
    }).then((adapter) => {
      var _a2;
      if (!adapter) {
        throw "Could not retrieve a WebGPU adapter (adapter is null).";
      } else {
        this._adapter = adapter;
        this._adapterSupportedExtensions = [];
        (_a2 = this._adapter.features) === null || _a2 === void 0 ? void 0 : _a2.forEach((feature) => this._adapterSupportedExtensions.push(feature));
        const deviceDescriptor = this._options.deviceDescriptor;
        if (deviceDescriptor === null || deviceDescriptor === void 0 ? void 0 : deviceDescriptor.requiredFeatures) {
          const requestedExtensions = deviceDescriptor.requiredFeatures;
          const validExtensions = [];
          for (const extension of requestedExtensions) {
            if (this._adapterSupportedExtensions.indexOf(extension) !== -1) {
              validExtensions.push(extension);
            }
          }
          deviceDescriptor.requiredFeatures = validExtensions;
        }
        return this._adapter.requestDevice(this._options.deviceDescriptor);
      }
    }).then((device) => {
      var _a2, _b;
      this._device = device;
      this._deviceEnabledExtensions = [];
      (_a2 = this._device.features) === null || _a2 === void 0 ? void 0 : _a2.forEach((feature) => this._deviceEnabledExtensions.push(feature));
      let numUncapturedErrors = -1;
      this._device.addEventListener("uncapturederror", (event) => {
        if (++numUncapturedErrors < this.numMaxUncapturedErrors) {
          Logger.Warn(`WebGPU uncaptured error (${numUncapturedErrors + 1}): ${event.error} - ${event.error.message}`);
        } else if (numUncapturedErrors++ === this.numMaxUncapturedErrors) {
          Logger.Warn(`WebGPU uncaptured error: too many warnings (${this.numMaxUncapturedErrors}), no more warnings will be reported to the console for this engine.`);
        }
      });
      if (!this._doNotHandleContextLost) {
        (_b = this._device.lost) === null || _b === void 0 ? void 0 : _b.then((info) => {
          this._contextWasLost = true;
          Logger.Warn("WebGPU context lost. " + info);
          this.onContextLostObservable.notifyObservers(this);
          this._restoreEngineAfterContextLost(this.initAsync.bind(this));
        });
      }
    }, (e) => {
      Logger.Error("Could not retrieve a WebGPU device.");
      Logger.Error(e);
    }).then(() => {
      this._bufferManager = new WebGPUBufferManager(this._device);
      this._textureHelper = new WebGPUTextureHelper(this._device, this._glslang, this._tintWASM, this._bufferManager);
      this._cacheSampler = new WebGPUCacheSampler(this._device);
      this._cacheBindGroups = new WebGPUCacheBindGroups(this._device, this._cacheSampler, this);
      this._timestampQuery = new WebGPUTimestampQuery(this._device, this._bufferManager);
      this._occlusionQuery = this._device.createQuerySet ? new WebGPUOcclusionQuery(this, this._device, this._bufferManager) : void 0;
      this._bundleList = new WebGPUBundleList(this._device);
      this._bundleListRenderTarget = new WebGPUBundleList(this._device);
      this._snapshotRendering = new WebGPUSnapshotRendering(this, this._snapshotRenderingMode, this._bundleList, this._bundleListRenderTarget);
      this._ubInvertY = this._bufferManager.createBuffer(new Float32Array([-1, 0]), BufferUsage.Uniform | BufferUsage.CopyDst);
      this._ubDontInvertY = this._bufferManager.createBuffer(new Float32Array([1, 0]), BufferUsage.Uniform | BufferUsage.CopyDst);
      if (this.dbgVerboseLogsForFirstFrames) {
        if (this._count === void 0) {
          this._count = 0;
          console.log("%c frame #" + this._count + " - begin", "background: #ffff00");
        }
      }
      this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);
      this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);
      this._renderTargetEncoder = this._device.createCommandEncoder(this._renderTargetEncoderDescriptor);
      this._emptyVertexBuffer = new VertexBuffer(this, [0], "", false, false, 1, false, 0, 1);
      this._initializeLimits();
      this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, this._emptyVertexBuffer, !this._caps.textureFloatLinearFiltering);
      this._depthCullingState = new WebGPUDepthCullingState(this._cacheRenderPipeline);
      this._stencilStateComposer = new WebGPUStencilStateComposer(this._cacheRenderPipeline);
      this._stencilStateComposer.stencilGlobal = this._stencilState;
      this._depthCullingState.depthTest = true;
      this._depthCullingState.depthFunc = 515;
      this._depthCullingState.depthMask = true;
      this._textureHelper.setCommandEncoder(this._uploadEncoder);
      this._clearQuad = new WebGPUClearQuad(this._device, this, this._emptyVertexBuffer);
      this._defaultDrawContext = this.createDrawContext();
      this._currentDrawContext = this._defaultDrawContext;
      this._defaultMaterialContext = this.createMaterialContext();
      this._currentMaterialContext = this._defaultMaterialContext;
      this._initializeContextAndSwapChain();
      this._initializeMainAttachments();
      this.resize();
    }).catch((e) => {
      Logger.Error("Can not create WebGPU Device and/or context.");
      Logger.Error(e);
      if (console.trace) {
        console.trace();
      }
    });
  }
  _initGlslang(glslangOptions) {
    glslangOptions = glslangOptions || {};
    glslangOptions = {
      ...WebGPUEngine._GLSLslangDefaultOptions,
      ...glslangOptions
    };
    if (glslangOptions.glslang) {
      return Promise.resolve(glslangOptions.glslang);
    }
    if (self.glslang) {
      return self.glslang(glslangOptions.wasmPath);
    }
    if (glslangOptions.jsPath && glslangOptions.wasmPath) {
      if (IsWindowObjectExist()) {
        return Tools.LoadScriptAsync(glslangOptions.jsPath).then(() => {
          return self.glslang(glslangOptions.wasmPath);
        });
      } else {
        importScripts(glslangOptions.jsPath);
        return self.glslang(glslangOptions.wasmPath);
      }
    }
    return Promise.reject("gslang is not available.");
  }
  _initializeLimits() {
    this._caps = {
      maxTexturesImageUnits: 16,
      maxVertexTextureImageUnits: 16,
      maxCombinedTexturesImageUnits: 32,
      maxTextureSize: 8192,
      maxCubemapTextureSize: 2048,
      maxRenderTextureSize: 8192,
      maxVertexAttribs: 16,
      maxVaryingVectors: 15,
      maxFragmentUniformVectors: 1024,
      maxVertexUniformVectors: 1024,
      standardDerivatives: true,
      astc: this._deviceEnabledExtensions.indexOf(FeatureName.TextureCompressionASTC) >= 0 ? true : void 0,
      s3tc: this._deviceEnabledExtensions.indexOf(FeatureName.TextureCompressionBC) >= 0 ? true : void 0,
      pvrtc: null,
      etc1: null,
      etc2: this._deviceEnabledExtensions.indexOf(FeatureName.TextureCompressionETC2) >= 0 ? true : void 0,
      bptc: this._deviceEnabledExtensions.indexOf(FeatureName.TextureCompressionBC) >= 0 ? true : void 0,
      maxAnisotropy: 4,
      uintIndices: true,
      fragmentDepthSupported: true,
      highPrecisionShaderSupported: true,
      colorBufferFloat: true,
      textureFloat: true,
      textureFloatLinearFiltering: false,
      textureFloatRender: true,
      textureHalfFloat: true,
      textureHalfFloatLinearFiltering: true,
      textureHalfFloatRender: true,
      textureLOD: true,
      drawBuffersExtension: true,
      depthTextureExtension: true,
      vertexArrayObject: false,
      instancedArrays: true,
      timerQuery: typeof BigUint64Array !== "undefined" && this.enabledExtensions.indexOf(FeatureName.TimestampQuery) !== -1 ? true : void 0,
      supportOcclusionQuery: typeof BigUint64Array !== "undefined",
      canUseTimestampForTimerQuery: true,
      multiview: false,
      oculusMultiview: false,
      parallelShaderCompile: void 0,
      blendMinMax: true,
      maxMSAASamples: 4,
      canUseGLInstanceID: true,
      canUseGLVertexID: true,
      supportComputeShaders: true,
      supportSRGBBuffers: true,
      supportTransformFeedbacks: false,
      textureMaxLevel: true,
      texture2DArrayMaxLayerCount: 2048
    };
    this._caps.parallelShaderCompile = null;
    this._features = {
      forceBitmapOverHTMLImageElement: true,
      supportRenderAndCopyToLodForFloatTextures: true,
      supportDepthStencilTexture: true,
      supportShadowSamplers: true,
      uniformBufferHardCheckMatrix: false,
      allowTexturePrefiltering: true,
      trackUbosInFrame: true,
      checkUbosContentBeforeUpload: true,
      supportCSM: true,
      basisNeedsPOT: false,
      support3DTextures: true,
      needTypeSuffixInShaderConstants: true,
      supportMSAA: true,
      supportSSAO2: true,
      supportExtendedTextureFormats: true,
      supportSwitchCaseInShader: true,
      supportSyncTextureRead: false,
      needsInvertingBitmap: false,
      useUBOBindingCache: false,
      needShaderCodeInlining: true,
      needToAlwaysBindUniformBuffers: true,
      supportRenderPasses: true,
      supportSpriteInstancing: true,
      _collectUbosUpdatedInFrame: false
    };
  }
  _initializeContextAndSwapChain() {
    this._context = this._canvas.getContext("webgpu");
    this._configureContext();
    this._colorFormat = this._options.swapChainFormat;
    this._mainRenderPassWrapper.colorAttachmentGPUTextures = [new WebGPUHardwareTexture()];
    this._mainRenderPassWrapper.colorAttachmentGPUTextures[0].format = this._colorFormat;
  }
  _initializeMainAttachments() {
    if (!this._bufferManager) {
      return;
    }
    this.flushFramebuffer(false);
    this._mainTextureExtends = {
      width: this.getRenderWidth(),
      height: this.getRenderHeight(),
      depthOrArrayLayers: 1
    };
    const bufferDataUpdate = new Float32Array([this.getRenderHeight()]);
    this._bufferManager.setSubData(this._ubInvertY, 4, bufferDataUpdate);
    this._bufferManager.setSubData(this._ubDontInvertY, 4, bufferDataUpdate);
    let mainColorAttachments;
    if (this._options.antialiasing) {
      const mainTextureDescriptor = {
        label: "Texture_MainColor_antialiasing",
        size: this._mainTextureExtends,
        mipLevelCount: 1,
        sampleCount: this._mainPassSampleCount,
        dimension: TextureDimension.E2d,
        format: this._options.swapChainFormat,
        usage: TextureUsage.RenderAttachment
      };
      if (this._mainTexture) {
        this._textureHelper.releaseTexture(this._mainTexture);
      }
      this._mainTexture = this._device.createTexture(mainTextureDescriptor);
      mainColorAttachments = [
        {
          view: this._mainTexture.createView(),
          clearValue: new Color4(0, 0, 0, 1),
          loadOp: LoadOp.Clear,
          storeOp: StoreOp.Store
        }
      ];
    } else {
      mainColorAttachments = [
        {
          view: void 0,
          clearValue: new Color4(0, 0, 0, 1),
          loadOp: LoadOp.Clear,
          storeOp: StoreOp.Store
        }
      ];
    }
    this._mainRenderPassWrapper.depthTextureFormat = this.isStencilEnable ? TextureFormat.Depth24PlusStencil8 : TextureFormat.Depth32Float;
    this._setDepthTextureFormat(this._mainRenderPassWrapper);
    const depthTextureDescriptor = {
      label: "Texture_MainDepthStencil",
      size: this._mainTextureExtends,
      mipLevelCount: 1,
      sampleCount: this._mainPassSampleCount,
      dimension: TextureDimension.E2d,
      format: this._mainRenderPassWrapper.depthTextureFormat,
      usage: TextureUsage.RenderAttachment
    };
    if (this._depthTexture) {
      this._textureHelper.releaseTexture(this._depthTexture);
    }
    this._depthTexture = this._device.createTexture(depthTextureDescriptor);
    const mainDepthAttachment = {
      view: this._depthTexture.createView(),
      depthClearValue: this._clearDepthValue,
      depthLoadOp: LoadOp.Clear,
      depthStoreOp: StoreOp.Store,
      stencilClearValue: this._clearStencilValue,
      stencilLoadOp: !this.isStencilEnable ? void 0 : LoadOp.Clear,
      stencilStoreOp: !this.isStencilEnable ? void 0 : StoreOp.Store
    };
    this._mainRenderPassWrapper.renderPassDescriptor = {
      colorAttachments: mainColorAttachments,
      depthStencilAttachment: mainDepthAttachment
    };
  }
  _configureContext() {
    this._context.configure({
      device: this._device,
      format: this._options.swapChainFormat,
      usage: TextureUsage.RenderAttachment | TextureUsage.CopySrc,
      alphaMode: this.premultipliedAlpha ? CanvasAlphaMode.Premultiplied : CanvasAlphaMode.Opaque
    });
  }
  setSize(width, height, forceSetSize = false) {
    if (!super.setSize(width, height, forceSetSize)) {
      return false;
    }
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        console.log("frame #" + this._count + " - setSize called -", width, height);
      }
    }
    this._initializeMainAttachments();
    if (this.snapshotRendering) {
      this.snapshotRenderingReset();
    }
    return true;
  }
  _getShaderProcessor(shaderLanguage) {
    if (shaderLanguage === ShaderLanguage.WGSL) {
      return this._shaderProcessorWGSL;
    }
    return this._shaderProcessor;
  }
  _getShaderProcessingContext(shaderLanguage) {
    return new WebGPUShaderProcessingContext(shaderLanguage);
  }
  applyStates() {
    this._stencilStateComposer.apply();
    this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState.alphaBlend);
  }
  wipeCaches(bruteForce) {
    if (this.preventCacheWipeBetweenFrames && !bruteForce) {
      return;
    }
    this._forceEnableEffect = true;
    this._currentIndexBuffer = null;
    this._currentOverrideVertexBuffers = null;
    this._cacheRenderPipeline.setBuffers(null, null, null);
    if (bruteForce) {
      this._stencilStateComposer.reset();
      this._depthCullingState.reset();
      this._depthCullingState.depthFunc = 515;
      this._alphaState.reset();
      this._alphaMode = 1;
      this._alphaEquation = 0;
      this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);
      this._cacheRenderPipeline.setAlphaBlendEnabled(false);
      this.setColorWrite(true);
    }
    this._cachedVertexBuffers = null;
    this._cachedIndexBuffer = null;
    this._cachedEffectForVertexBuffers = null;
  }
  setColorWrite(enable) {
    this._colorWriteLocal = enable;
    this._cacheRenderPipeline.setWriteMask(enable ? 15 : 0);
  }
  getColorWrite() {
    return this._colorWriteLocal;
  }
  _resetCurrentViewport(index) {
    this._viewportsCurrent[index].x = 0;
    this._viewportsCurrent[index].y = 0;
    this._viewportsCurrent[index].w = 0;
    this._viewportsCurrent[index].h = 0;
    if (index === 1) {
      this._viewportCached.x = 0;
      this._viewportCached.y = 0;
      this._viewportCached.z = 0;
      this._viewportCached.w = 0;
    }
  }
  _mustUpdateViewport(renderPass) {
    const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;
    const x = this._viewportCached.x, y = this._viewportCached.y, w = this._viewportCached.z, h = this._viewportCached.w;
    const update = this._viewportsCurrent[index].x !== x || this._viewportsCurrent[index].y !== y || this._viewportsCurrent[index].w !== w || this._viewportsCurrent[index].h !== h;
    if (update) {
      this._viewportsCurrent[index].x = this._viewportCached.x;
      this._viewportsCurrent[index].y = this._viewportCached.y;
      this._viewportsCurrent[index].w = this._viewportCached.z;
      this._viewportsCurrent[index].h = this._viewportCached.w;
    }
    return update;
  }
  _applyViewport(renderPass) {
    let y = Math.floor(this._viewportCached.y);
    const h = Math.floor(this._viewportCached.w);
    if (!this._currentRenderTarget) {
      y = this.getRenderHeight() - y - h;
    }
    renderPass.setViewport(Math.floor(this._viewportCached.x), y, Math.floor(this._viewportCached.z), h, 0, 1);
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        console.log("frame #" + this._count + " - viewport applied - (", this._viewportCached.x, this._viewportCached.y, this._viewportCached.z, this._viewportCached.w, ") current pass is main pass=" + (renderPass === this._mainRenderPassWrapper.renderPass));
      }
    }
  }
  _viewport(x, y, width, height) {
    this._viewportCached.x = x;
    this._viewportCached.y = y;
    this._viewportCached.z = width;
    this._viewportCached.w = height;
  }
  _resetCurrentScissor(index) {
    this._scissorsCurrent[index].x = 0;
    this._scissorsCurrent[index].y = 0;
    this._scissorsCurrent[index].w = 0;
    this._scissorsCurrent[index].h = 0;
  }
  _mustUpdateScissor(renderPass) {
    const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;
    const x = this._scissorCached.x, y = this._scissorCached.y, w = this._scissorCached.z, h = this._scissorCached.w;
    const update = this._scissorsCurrent[index].x !== x || this._scissorsCurrent[index].y !== y || this._scissorsCurrent[index].w !== w || this._scissorsCurrent[index].h !== h;
    if (update) {
      this._scissorsCurrent[index].x = this._scissorCached.x;
      this._scissorsCurrent[index].y = this._scissorCached.y;
      this._scissorsCurrent[index].w = this._scissorCached.z;
      this._scissorsCurrent[index].h = this._scissorCached.w;
    }
    return update;
  }
  _applyScissor(renderPass) {
    renderPass.setScissorRect(this._scissorCached.x, this._currentRenderTarget ? this._scissorCached.y : this.getRenderHeight() - this._scissorCached.w - this._scissorCached.y, this._scissorCached.z, this._scissorCached.w);
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        console.log("frame #" + this._count + " - scissor applied - (", this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w, ") current pass is main pass=" + (renderPass === this._mainRenderPassWrapper.renderPass));
      }
    }
  }
  _scissorIsActive() {
    return this._scissorCached.x !== 0 || this._scissorCached.y !== 0 || this._scissorCached.z !== 0 || this._scissorCached.w !== 0;
  }
  enableScissor(x, y, width, height) {
    this._scissorCached.x = x;
    this._scissorCached.y = y;
    this._scissorCached.z = width;
    this._scissorCached.w = height;
  }
  disableScissor() {
    this._scissorCached.x = 0;
    this._scissorCached.y = 0;
    this._scissorCached.z = 0;
    this._scissorCached.w = 0;
    this._resetCurrentScissor(0);
    this._resetCurrentScissor(1);
  }
  _resetCurrentStencilRef(index) {
    this._stencilRefsCurrent[index] = -1;
  }
  _mustUpdateStencilRef(renderPass) {
    const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;
    const update = this._stencilStateComposer.funcRef !== this._stencilRefsCurrent[index];
    if (update) {
      this._stencilRefsCurrent[index] = this._stencilStateComposer.funcRef;
    }
    return update;
  }
  _applyStencilRef(renderPass) {
    var _a;
    renderPass.setStencilReference((_a = this._stencilStateComposer.funcRef) !== null && _a !== void 0 ? _a : 0);
  }
  _resetCurrentColorBlend(index) {
    this._blendColorsCurrent[index][0] = this._blendColorsCurrent[index][1] = this._blendColorsCurrent[index][2] = this._blendColorsCurrent[index][3] = null;
  }
  _mustUpdateBlendColor(renderPass) {
    const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;
    const colorBlend = this._alphaState._blendConstants;
    const update = colorBlend[0] !== this._blendColorsCurrent[index][0] || colorBlend[1] !== this._blendColorsCurrent[index][1] || colorBlend[2] !== this._blendColorsCurrent[index][2] || colorBlend[3] !== this._blendColorsCurrent[index][3];
    if (update) {
      this._blendColorsCurrent[index][0] = colorBlend[0];
      this._blendColorsCurrent[index][1] = colorBlend[1];
      this._blendColorsCurrent[index][2] = colorBlend[2];
      this._blendColorsCurrent[index][3] = colorBlend[3];
    }
    return update;
  }
  _applyBlendColor(renderPass) {
    renderPass.setBlendConstant(this._alphaState._blendConstants);
  }
  clear(color, backBuffer, depth, stencil = false) {
    if (color && color.a === void 0) {
      color.a = 1;
    }
    const hasScissor = this._scissorIsActive();
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        console.log("frame #" + this._count + " - clear called - backBuffer=", backBuffer, " depth=", depth, " stencil=", stencil, " scissor is active=", hasScissor);
      }
    }
    if (this._currentRenderTarget) {
      if (hasScissor) {
        if (!this._rttRenderPassWrapper.renderPass) {
          this._startRenderTargetRenderPass(this._currentRenderTarget, false, backBuffer ? color : null, depth, stencil);
        }
        if (!this.compatibilityMode) {
          this._bundleListRenderTarget.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));
        } else {
          this._applyScissor(this._currentRenderPass);
        }
        this._clearFullQuad(backBuffer ? color : null, depth, stencil);
      } else {
        if (this._currentRenderPass) {
          this._endRenderTargetRenderPass();
        }
        this._startRenderTargetRenderPass(this._currentRenderTarget, true, backBuffer ? color : null, depth, stencil);
      }
    } else {
      if (!this._mainRenderPassWrapper.renderPass || !hasScissor) {
        this._startMainRenderPass(!hasScissor, backBuffer ? color : null, depth, stencil);
      }
      if (hasScissor) {
        if (!this.compatibilityMode) {
          this._bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));
        } else {
          this._applyScissor(this._currentRenderPass);
        }
        this._clearFullQuad(backBuffer ? color : null, depth, stencil);
      }
    }
  }
  _clearFullQuad(clearColor, clearDepth, clearStencil) {
    var _a, _b, _c;
    const renderPass = !this.compatibilityMode ? null : this._getCurrentRenderPass();
    const renderPassIndex = this._getCurrentRenderPassIndex();
    const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;
    this._clearQuad.setColorFormat(this._colorFormat);
    this._clearQuad.setDepthStencilFormat(this._depthTextureFormat);
    this._clearQuad.setMRTAttachments((_a = this._cacheRenderPipeline.mrtAttachments) !== null && _a !== void 0 ? _a : [], (_b = this._cacheRenderPipeline.mrtTextureArray) !== null && _b !== void 0 ? _b : [], this._cacheRenderPipeline.mrtTextureCount);
    if (!this.compatibilityMode) {
      bundleList.addItem(new WebGPURenderItemStencilRef(this._clearStencilValue));
    } else {
      renderPass.setStencilReference(this._clearStencilValue);
    }
    const bundle = this._clearQuad.clear(renderPass, clearColor, clearDepth, clearStencil, this.currentSampleCount);
    if (!this.compatibilityMode) {
      bundleList.addBundle(bundle);
      bundleList.addItem(new WebGPURenderItemStencilRef((_c = this._stencilStateComposer.funcRef) !== null && _c !== void 0 ? _c : 0));
      this._reportDrawCall();
    } else {
      this._applyStencilRef(renderPass);
    }
  }
  createVertexBuffer(data) {
    let view;
    if (data instanceof Array) {
      view = new Float32Array(data);
    } else if (data instanceof ArrayBuffer) {
      view = new Uint8Array(data);
    } else {
      view = data;
    }
    const dataBuffer = this._bufferManager.createBuffer(view, BufferUsage.Vertex | BufferUsage.CopyDst);
    return dataBuffer;
  }
  createDynamicVertexBuffer(data) {
    return this.createVertexBuffer(data);
  }
  createIndexBuffer(indices) {
    let is32Bits = true;
    let view;
    if (indices instanceof Uint32Array || indices instanceof Int32Array) {
      view = indices;
    } else if (indices instanceof Uint16Array) {
      view = indices;
      is32Bits = false;
    } else {
      if (indices.length > 65535) {
        view = new Uint32Array(indices);
      } else {
        view = new Uint16Array(indices);
        is32Bits = false;
      }
    }
    const dataBuffer = this._bufferManager.createBuffer(view, BufferUsage.Index | BufferUsage.CopyDst);
    dataBuffer.is32Bits = is32Bits;
    return dataBuffer;
  }
  _createBuffer(data, creationFlags) {
    let view;
    if (data instanceof Array) {
      view = new Float32Array(data);
    } else if (data instanceof ArrayBuffer) {
      view = new Uint8Array(data);
    } else {
      view = data;
    }
    let flags = 0;
    if (creationFlags & 1) {
      flags |= BufferUsage.CopySrc;
    }
    if (creationFlags & 2) {
      flags |= BufferUsage.CopyDst;
    }
    if (creationFlags & 4) {
      flags |= BufferUsage.Uniform;
    }
    if (creationFlags & 8) {
      flags |= BufferUsage.Vertex;
    }
    if (creationFlags & 16) {
      flags |= BufferUsage.Index;
    }
    if (creationFlags & 32) {
      flags |= BufferUsage.Storage;
    }
    return this._bufferManager.createBuffer(view, flags);
  }
  bindBuffersDirectly() {
    throw "Not implemented on WebGPU";
  }
  updateAndBindInstancesBuffer() {
    throw "Not implemented on WebGPU";
  }
  bindBuffers(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
    this._currentIndexBuffer = indexBuffer;
    this._currentOverrideVertexBuffers = overrideVertexBuffers !== null && overrideVertexBuffers !== void 0 ? overrideVertexBuffers : null;
    this._cacheRenderPipeline.setBuffers(vertexBuffers, indexBuffer, this._currentOverrideVertexBuffers);
  }
  _releaseBuffer(buffer) {
    return this._bufferManager.releaseBuffer(buffer);
  }
  createEffect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters, shaderLanguage = ShaderLanguage.GLSL) {
    var _a;
    const vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;
    const fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;
    const globalDefines = this._getGlobalDefines();
    let fullDefines = (_a = defines !== null && defines !== void 0 ? defines : attributesNamesOrOptions.defines) !== null && _a !== void 0 ? _a : "";
    if (globalDefines) {
      fullDefines += "\n" + globalDefines;
    }
    const name137 = vertex + "+" + fragment + "@" + fullDefines;
    if (this._compiledEffects[name137]) {
      const compiledEffect = this._compiledEffects[name137];
      if (onCompiled && compiledEffect.isReady()) {
        onCompiled(compiledEffect);
      }
      return compiledEffect;
    }
    const effect = new Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters, name137, shaderLanguage);
    this._compiledEffects[name137] = effect;
    return effect;
  }
  _compileRawShaderToSpirV(source, type) {
    return this._glslang.compileGLSL(source, type);
  }
  _compileShaderToSpirV(source, type, defines, shaderVersion) {
    return this._compileRawShaderToSpirV(shaderVersion + (defines ? defines + "\n" : "") + source, type);
  }
  _getWGSLShader(source, type, defines) {
    if (defines) {
      defines = "//" + defines.split("\n").join("\n//") + "\n";
    } else {
      defines = "";
    }
    return defines + source;
  }
  _createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage) {
    if (this._tintWASM && shaderLanguage === ShaderLanguage.GLSL) {
      vertexShader = this._tintWASM.convertSpirV2WGSL(vertexShader);
      fragmentShader = this._tintWASM.convertSpirV2WGSL(fragmentShader);
    }
    return {
      vertexStage: {
        module: this._device.createShaderModule({
          code: vertexShader
        }),
        entryPoint: "main"
      },
      fragmentStage: {
        module: this._device.createShaderModule({
          code: fragmentShader
        }),
        entryPoint: "main"
      }
    };
  }
  _compileRawPipelineStageDescriptor(vertexCode, fragmentCode, shaderLanguage) {
    const vertexShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(vertexCode, "vertex") : vertexCode;
    const fragmentShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(fragmentCode, "fragment") : fragmentCode;
    return this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage);
  }
  _compilePipelineStageDescriptor(vertexCode, fragmentCode, defines, shaderLanguage) {
    this.onBeforeShaderCompilationObservable.notifyObservers(this);
    const shaderVersion = "#version 450\n";
    const vertexShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileShaderToSpirV(vertexCode, "vertex", defines, shaderVersion) : this._getWGSLShader(vertexCode, "vertex", defines);
    const fragmentShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileShaderToSpirV(fragmentCode, "fragment", defines, shaderVersion) : this._getWGSLShader(fragmentCode, "fragment", defines);
    const program = this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage);
    this.onAfterShaderCompilationObservable.notifyObservers(this);
    return program;
  }
  createRawShaderProgram() {
    throw "Not available on WebGPU";
  }
  createShaderProgram() {
    throw "Not available on WebGPU";
  }
  inlineShaderCode(code) {
    const sci = new ShaderCodeInliner(code);
    sci.debug = false;
    sci.processCode();
    return sci.code;
  }
  createPipelineContext(shaderProcessingContext) {
    return new WebGPUPipelineContext(shaderProcessingContext, this);
  }
  createMaterialContext() {
    return new WebGPUMaterialContext();
  }
  createDrawContext() {
    return new WebGPUDrawContext(this._bufferManager);
  }
  _preparePipelineContext(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rawVertexSourceCode, rawFragmentSourceCode, rebuildRebind, defines) {
    const webGpuContext = pipelineContext;
    const shaderLanguage = webGpuContext.shaderProcessingContext.shaderLanguage;
    if (this.dbgShowShaderCode) {
      console.log(defines);
      console.log(vertexSourceCode);
      console.log(fragmentSourceCode);
      console.log("***********************************************");
    }
    webGpuContext.sources = {
      fragment: fragmentSourceCode,
      vertex: vertexSourceCode,
      rawVertex: rawVertexSourceCode,
      rawFragment: rawFragmentSourceCode
    };
    if (createAsRaw) {
      webGpuContext.stages = this._compileRawPipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, shaderLanguage);
    } else {
      webGpuContext.stages = this._compilePipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, defines, shaderLanguage);
    }
  }
  getAttributes(pipelineContext, attributesNames) {
    const results = new Array(attributesNames.length);
    const gpuPipelineContext = pipelineContext;
    for (let i = 0; i < attributesNames.length; i++) {
      const attributeName = attributesNames[i];
      const attributeLocation = gpuPipelineContext.shaderProcessingContext.availableAttributes[attributeName];
      if (attributeLocation === void 0) {
        continue;
      }
      results[i] = attributeLocation;
    }
    return results;
  }
  enableEffect(effect) {
    if (!effect) {
      return;
    }
    let isNewEffect = true;
    if (!DrawWrapper.IsWrapper(effect)) {
      isNewEffect = effect !== this._currentEffect;
      this._currentEffect = effect;
      this._currentMaterialContext = this._defaultMaterialContext;
      this._currentDrawContext = this._defaultDrawContext;
      this._counters.numEnableEffects++;
      if (this.dbgLogIfNotDrawWrapper) {
        Logger.Warn(`enableEffect has been called with an Effect and not a Wrapper! effect.uniqueId=${effect.uniqueId}, effect.name=${effect.name}, effect.name.vertex=${effect.name.vertex}, effect.name.fragment=${effect.name.fragment}`, 10);
      }
    } else if (!effect.effect || effect.effect === this._currentEffect && effect.materialContext === this._currentMaterialContext && effect.drawContext === this._currentDrawContext && !this._forceEnableEffect) {
      if (!effect.effect && this.dbgShowEmptyEnableEffectCalls) {
        console.error("drawWrapper=", effect);
        throw "Invalid call to enableEffect: the effect property is empty!";
      }
      return;
    } else {
      isNewEffect = effect.effect !== this._currentEffect;
      this._currentEffect = effect.effect;
      this._currentMaterialContext = effect.materialContext;
      this._currentDrawContext = effect.drawContext;
      this._counters.numEnableDrawWrapper++;
      if (!this._currentMaterialContext) {
        console.error("drawWrapper=", effect);
        throw `Invalid call to enableEffect: the materialContext property is empty!`;
      }
    }
    this._stencilStateComposer.stencilMaterial = void 0;
    this._forceEnableEffect = isNewEffect || this._forceEnableEffect ? false : this._forceEnableEffect;
    if (isNewEffect) {
      if (this._currentEffect.onBind) {
        this._currentEffect.onBind(this._currentEffect);
      }
      if (this._currentEffect._onBindObservable) {
        this._currentEffect._onBindObservable.notifyObservers(this._currentEffect);
      }
    }
  }
  _releaseEffect(effect) {
    if (this._compiledEffects[effect._key]) {
      delete this._compiledEffects[effect._key];
      this._deletePipelineContext(effect.getPipelineContext());
    }
  }
  releaseEffects() {
    for (const name137 in this._compiledEffects) {
      const webGPUPipelineContext = this._compiledEffects[name137].getPipelineContext();
      this._deletePipelineContext(webGPUPipelineContext);
    }
    this._compiledEffects = {};
  }
  _deletePipelineContext(pipelineContext) {
    const webgpuPipelineContext = pipelineContext;
    if (webgpuPipelineContext) {
      pipelineContext.dispose();
    }
  }
  get needPOTTextures() {
    return false;
  }
  _createHardwareTexture() {
    return new WebGPUHardwareTexture();
  }
  _releaseTexture(texture) {
    const index = this._internalTexturesCache.indexOf(texture);
    if (index !== -1) {
      this._internalTexturesCache.splice(index, 1);
    }
    this._textureHelper.releaseTexture(texture);
  }
  _getRGBABufferInternalSizedFormat() {
    return 5;
  }
  updateTextureComparisonFunction(texture, comparisonFunction) {
    texture._comparisonFunction = comparisonFunction;
  }
  _createInternalTexture(size, options, delayGPUTextureCreation = true, source = InternalTextureSource.Unknown) {
    var _a, _b, _c;
    const fullOptions = {};
    if (options !== void 0 && typeof options === "object") {
      fullOptions.generateMipMaps = options.generateMipMaps;
      fullOptions.type = options.type === void 0 ? 0 : options.type;
      fullOptions.samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
      fullOptions.format = options.format === void 0 ? 5 : options.format;
      fullOptions.samples = (_a = options.samples) !== null && _a !== void 0 ? _a : 1;
      fullOptions.creationFlags = (_b = options.creationFlags) !== null && _b !== void 0 ? _b : 0;
      fullOptions.useSRGBBuffer = (_c = options.useSRGBBuffer) !== null && _c !== void 0 ? _c : false;
    } else {
      fullOptions.generateMipMaps = options;
      fullOptions.type = 0;
      fullOptions.samplingMode = 3;
      fullOptions.format = 5;
      fullOptions.samples = 1;
      fullOptions.creationFlags = 0;
      fullOptions.useSRGBBuffer = false;
    }
    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
      fullOptions.samplingMode = 1;
    } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
      fullOptions.samplingMode = 1;
    }
    if (fullOptions.type === 1 && !this._caps.textureFloat) {
      fullOptions.type = 0;
      Logger.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE");
    }
    const texture = new InternalTexture(this, source);
    const width = size.width || size;
    const height = size.height || size;
    const layers = size.layers || 0;
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.depth = layers;
    texture.isReady = true;
    texture.samples = fullOptions.samples;
    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;
    texture.samplingMode = fullOptions.samplingMode;
    texture.type = fullOptions.type;
    texture.format = fullOptions.format;
    texture.is2DArray = layers > 0;
    texture._cachedWrapU = 0;
    texture._cachedWrapV = 0;
    texture._useSRGBBuffer = fullOptions.useSRGBBuffer;
    this._internalTexturesCache.push(texture);
    if (!delayGPUTextureCreation) {
      this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, layers || 1, fullOptions.creationFlags);
    }
    return texture;
  }
  createTexture(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, creationFlags, useSRGBBuffer) {
    return this._createTextureBase(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, (texture, extension, scene2, img, invertY2, noMipmap2, isCompressed, processFunction) => {
      var _a;
      const imageBitmap = img;
      texture.baseWidth = imageBitmap.width;
      texture.baseHeight = imageBitmap.height;
      texture.width = imageBitmap.width;
      texture.height = imageBitmap.height;
      texture.format = format !== null && format !== void 0 ? format : -1;
      processFunction(texture.width, texture.height, imageBitmap, extension, texture, () => {
      });
      if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {
        const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, imageBitmap.width, imageBitmap.height, void 0, creationFlags);
        if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {
          this._textureHelper.updateTexture(imageBitmap, texture, imageBitmap.width, imageBitmap.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY2, false, 0, 0);
          if (!noMipmap2 && !isCompressed) {
            this._generateMipmaps(texture, this._uploadEncoder);
          }
        }
      } else if (!noMipmap2 && !isCompressed) {
        this._generateMipmaps(texture, this._uploadEncoder);
      }
      if (scene2) {
        scene2.removePendingData(texture);
      }
      texture.isReady = true;
      texture.onLoadedObservable.notifyObservers(texture);
      texture.onLoadedObservable.clear();
    }, () => false, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);
  }
  wrapWebGPUTexture(texture) {
    const hardwareTexture = new WebGPUHardwareTexture(texture);
    const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);
    internalTexture._hardwareTexture = hardwareTexture;
    internalTexture.isReady = true;
    return internalTexture;
  }
  wrapWebGLTexture() {
    throw new Error("wrapWebGLTexture is not supported, use wrapWebGPUTexture instead.");
  }
  generateMipMapsForCubemap(texture) {
    var _a;
    if (texture.generateMipMaps) {
      const gpuTexture = (_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource;
      if (!gpuTexture) {
        this._textureHelper.createGPUTextureForInternalTexture(texture);
      }
      this._generateMipmaps(texture, texture.source === InternalTextureSource.RenderTarget || texture.source === InternalTextureSource.MultiRenderTarget ? this._renderTargetEncoder : void 0);
    }
  }
  updateTextureSamplingMode(samplingMode, texture, generateMipMaps = false) {
    if (generateMipMaps) {
      texture.generateMipMaps = true;
      this._generateMipmaps(texture);
    }
    texture.samplingMode = samplingMode;
  }
  updateTextureWrappingMode(texture, wrapU, wrapV = null, wrapR = null) {
    if (wrapU !== null) {
      texture._cachedWrapU = wrapU;
    }
    if (wrapV !== null) {
      texture._cachedWrapV = wrapV;
    }
    if ((texture.is2DArray || texture.is3D) && wrapR !== null) {
      texture._cachedWrapR = wrapR;
    }
  }
  updateTextureDimensions(texture, width, height, depth = 1) {
    if (!texture._hardwareTexture) {
      return;
    }
    if (texture.width === width && texture.height === height && texture.depth === depth) {
      return;
    }
    const additionalUsages = texture._hardwareTexture.textureAdditionalUsages;
    texture._hardwareTexture.release();
    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, additionalUsages);
  }
  _setInternalTexture(name137, texture, baseName) {
    baseName = baseName !== null && baseName !== void 0 ? baseName : name137;
    if (this._currentEffect) {
      const webgpuPipelineContext = this._currentEffect._pipelineContext;
      const availableTexture = webgpuPipelineContext.shaderProcessingContext.availableTextures[baseName];
      this._currentMaterialContext.setTexture(name137, texture);
      if (availableTexture && availableTexture.autoBindSampler) {
        const samplerName = baseName + WebGPUShaderProcessor.AutoSamplerSuffix;
        this._currentMaterialContext.setSampler(samplerName, texture);
      }
    }
  }
  setTexture(channel, unused, texture, name137) {
    this._setTexture(channel, texture, false, false, name137, name137);
  }
  setTextureArray(channel, unused, textures, name137) {
    for (let index = 0; index < textures.length; index++) {
      this._setTexture(-1, textures[index], true, false, name137 + index.toString(), name137);
    }
  }
  _setTexture(channel, texture, isPartOfTextureArray = false, depthStencilTexture = false, name137 = "", baseName) {
    baseName = baseName !== null && baseName !== void 0 ? baseName : name137;
    if (this._currentEffect) {
      if (!texture) {
        this._currentMaterialContext.setTexture(name137, null);
        return false;
      }
      if (texture.video) {
        texture.update();
      } else if (texture.delayLoadState === 4) {
        texture.delayLoad();
        return false;
      }
      let internalTexture = null;
      if (depthStencilTexture) {
        internalTexture = texture.depthStencilTexture;
      } else if (texture.isReady()) {
        internalTexture = texture.getInternalTexture();
      } else if (texture.isCube) {
        internalTexture = this.emptyCubeTexture;
      } else if (texture.is3D) {
        internalTexture = this.emptyTexture3D;
      } else if (texture.is2DArray) {
        internalTexture = this.emptyTexture2DArray;
      } else {
        internalTexture = this.emptyTexture;
      }
      if (internalTexture && !internalTexture.isMultiview) {
        if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {
          internalTexture._cachedCoordinatesMode = texture.coordinatesMode;
          const textureWrapMode = texture.coordinatesMode !== 3 && texture.coordinatesMode !== 5 ? 1 : 0;
          texture.wrapU = textureWrapMode;
          texture.wrapV = textureWrapMode;
        }
        internalTexture._cachedWrapU = texture.wrapU;
        internalTexture._cachedWrapV = texture.wrapV;
        if (internalTexture.is3D) {
          internalTexture._cachedWrapR = texture.wrapR;
        }
        this._setAnisotropicLevel(0, internalTexture, texture.anisotropicFilteringLevel);
      }
      this._setInternalTexture(name137, internalTexture, baseName);
    } else {
      if (this.dbgVerboseLogsForFirstFrames) {
        if (this._count === void 0) {
          this._count = 0;
        }
        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
          console.log("frame #" + this._count + " - _setTexture called with a null _currentEffect! texture=", texture);
        }
      }
    }
    return true;
  }
  _setAnisotropicLevel(target, internalTexture, anisotropicFilteringLevel) {
    if (internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {
      internalTexture._cachedAnisotropicFilteringLevel = Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy);
    }
  }
  _bindTexture(channel, texture, name137) {
    if (channel === void 0) {
      return;
    }
    this._setInternalTexture(name137, texture);
  }
  generateMipmaps(texture) {
    this._generateMipmaps(texture, this._renderTargetEncoder);
  }
  _generateMipmaps(texture, commandEncoder) {
    const gpuHardwareTexture = texture._hardwareTexture;
    if (!gpuHardwareTexture) {
      return;
    }
    commandEncoder = commandEncoder !== null && commandEncoder !== void 0 ? commandEncoder : this._currentRenderTarget && !this._currentRenderPass ? this._renderTargetEncoder : !this._currentRenderPass ? this._renderEncoder : this._uploadEncoder;
    const format = texture._hardwareTexture.format;
    const mipmapCount = WebGPUTextureHelper.ComputeNumMipmapLevels(texture.width, texture.height);
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        console.log("frame #" + this._count + " - generate mipmaps called - width=", texture.width, "height=", texture.height, "isCube=", texture.isCube);
      }
    }
    if (texture.isCube) {
      this._textureHelper.generateCubeMipmaps(gpuHardwareTexture, format, mipmapCount, commandEncoder);
    } else {
      this._textureHelper.generateMipmaps(gpuHardwareTexture, format, mipmapCount, 0, commandEncoder);
    }
  }
  updateTextureData(texture, imageData, xOffset, yOffset, width, height, faceIndex = 0, lod = 0, generateMipMaps = false) {
    var _a;
    let gpuTextureWrapper = texture._hardwareTexture;
    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {
      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);
    }
    const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);
    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, xOffset, yOffset);
    if (generateMipMaps) {
      this._generateMipmaps(texture, this._renderTargetEncoder);
    }
  }
  _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, imageData, faceIndex = 0, lod = 0) {
    var _a;
    let gpuTextureWrapper = texture._hardwareTexture;
    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {
      texture.format = internalFormat;
      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);
    }
    const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);
    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, false, false, 0, 0);
  }
  _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0, babylonInternalFormat, useTextureWidthAndHeight = false) {
    var _a;
    const lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);
    const lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);
    const width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));
    const height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));
    let gpuTextureWrapper = texture._hardwareTexture;
    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {
      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);
    }
    const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);
    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);
  }
  _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {
    this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);
  }
  _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {
    var _a;
    let gpuTextureWrapper = texture._hardwareTexture;
    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {
      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);
    }
    if (image instanceof HTMLImageElement) {
      throw "WebGPU engine: HTMLImageElement not supported in _uploadImageToTexture!";
    }
    const bitmap = image;
    const width = Math.ceil(texture.width / (1 << lod));
    const height = Math.ceil(texture.height / (1 << lod));
    this._textureHelper.updateTexture(bitmap, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);
  }
  readPixels(x, y, width, height, hasAlpha = true, flushRenderer = true) {
    const renderPassWrapper = this._rttRenderPassWrapper.renderPass ? this._rttRenderPassWrapper : this._mainRenderPassWrapper;
    const hardwareTexture = renderPassWrapper.colorAttachmentGPUTextures[0];
    if (!hardwareTexture) {
      return Promise.resolve(new Uint8Array(0));
    }
    const gpuTexture = hardwareTexture.underlyingResource;
    const gpuTextureFormat = hardwareTexture.format;
    if (!gpuTexture) {
      return Promise.resolve(new Uint8Array(0));
    }
    if (flushRenderer) {
      this.flushFramebuffer();
    }
    return this._textureHelper.readPixels(gpuTexture, x, y, width, height, gpuTextureFormat);
  }
  beginFrame() {
    super.beginFrame();
  }
  endFrame() {
    this._snapshotRendering.endFrame(this._mainRenderPassWrapper.renderPass);
    this._endMainRenderPass();
    this._timestampQuery.endFrame(this._renderEncoder);
    this.flushFramebuffer(false);
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        console.log("frame #" + this._count + " - counters");
      }
    }
    this._textureHelper.destroyDeferredTextures();
    this._bufferManager.destroyDeferredBuffers();
    if (this._features._collectUbosUpdatedInFrame) {
      if (this.dbgVerboseLogsForFirstFrames) {
        if (this._count === void 0) {
          this._count = 0;
        }
        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
          const list = [];
          for (const name137 in UniformBuffer._UpdatedUbosInFrame) {
            list.push(name137 + ":" + UniformBuffer._UpdatedUbosInFrame[name137]);
          }
          console.log("frame #" + this._count + " - updated ubos -", list.join(", "));
        }
      }
      UniformBuffer._UpdatedUbosInFrame = {};
    }
    this.countersLastFrame.numEnableEffects = this._counters.numEnableEffects;
    this.countersLastFrame.numEnableDrawWrapper = this._counters.numEnableDrawWrapper;
    this.countersLastFrame.numBundleCreationNonCompatMode = this._counters.numBundleCreationNonCompatMode;
    this.countersLastFrame.numBundleReuseNonCompatMode = this._counters.numBundleReuseNonCompatMode;
    this._counters.numEnableEffects = 0;
    this._counters.numEnableDrawWrapper = 0;
    this._counters.numBundleCreationNonCompatMode = 0;
    this._counters.numBundleReuseNonCompatMode = 0;
    this._cacheRenderPipeline.endFrame();
    this._cacheBindGroups.endFrame();
    this._pendingDebugCommands.length = 0;
    super.endFrame();
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (this._count < this.dbgVerboseLogsNumFrames) {
        console.log("%c frame #" + this._count + " - end", "background: #ffff00");
      }
      if (this._count < this.dbgVerboseLogsNumFrames) {
        this._count++;
        if (this._count !== this.dbgVerboseLogsNumFrames) {
          console.log("%c frame #" + this._count + " - begin", "background: #ffff00");
        }
      }
    }
  }
  flushFramebuffer(reopenPass = true) {
    const currentRenderPassIsNULL = !this._currentRenderPass;
    let currentPasses = 0;
    if (this._currentRenderPass && this._currentRenderTarget) {
      currentPasses |= 1;
      this._endRenderTargetRenderPass();
    }
    if (this._mainRenderPassWrapper.renderPass) {
      currentPasses |= 2;
      this._endMainRenderPass();
    }
    this._commandBuffers[0] = this._uploadEncoder.finish();
    this._commandBuffers[1] = this._renderTargetEncoder.finish();
    this._commandBuffers[2] = this._renderEncoder.finish();
    this._device.queue.submit(this._commandBuffers);
    this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);
    this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);
    this._renderTargetEncoder = this._device.createCommandEncoder(this._renderTargetEncoderDescriptor);
    this._timestampQuery.startFrame(this._uploadEncoder);
    this._textureHelper.setCommandEncoder(this._uploadEncoder);
    this._bundleList.reset();
    this._bundleListRenderTarget.reset();
    if (reopenPass) {
      if (currentPasses & 2) {
        this._startMainRenderPass(false);
      }
      if (currentPasses & 1) {
        this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);
      }
      if (currentRenderPassIsNULL && this._currentRenderTarget) {
        this._currentRenderPass = null;
      }
    }
  }
  _currentFrameBufferIsDefaultFrameBuffer() {
    return this._currentRenderTarget === null;
  }
  _startRenderTargetRenderPass(renderTargetWrapper, setClearStates, clearColor, clearDepth, clearStencil) {
    var _a, _b, _c;
    const rtWrapper = renderTargetWrapper;
    const depthStencilTexture = rtWrapper._depthStencilTexture;
    const gpuDepthStencilWrapper = depthStencilTexture === null || depthStencilTexture === void 0 ? void 0 : depthStencilTexture._hardwareTexture;
    const gpuDepthStencilTexture = gpuDepthStencilWrapper === null || gpuDepthStencilWrapper === void 0 ? void 0 : gpuDepthStencilWrapper.underlyingResource;
    const gpuDepthStencilMSAATexture = gpuDepthStencilWrapper === null || gpuDepthStencilWrapper === void 0 ? void 0 : gpuDepthStencilWrapper.msaaTexture;
    const depthTextureView = gpuDepthStencilTexture === null || gpuDepthStencilTexture === void 0 ? void 0 : gpuDepthStencilTexture.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor);
    const depthMSAATextureView = gpuDepthStencilMSAATexture === null || gpuDepthStencilMSAATexture === void 0 ? void 0 : gpuDepthStencilMSAATexture.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor);
    const depthTextureHasStencil = gpuDepthStencilWrapper ? WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format) : false;
    const colorAttachments = [];
    if (this.useReverseDepthBuffer) {
      this.setDepthFunctionToGreaterOrEqual();
    }
    const mustClearColor = setClearStates && clearColor;
    const mustClearDepth = setClearStates && clearDepth;
    const mustClearStencil = setClearStates && clearStencil;
    if (rtWrapper._attachments && rtWrapper.isMulti) {
      if (!this._mrtAttachments || this._mrtAttachments.length === 0) {
        this._mrtAttachments = rtWrapper._defaultAttachments;
      }
      for (let i = 0; i < this._mrtAttachments.length; ++i) {
        const index = this._mrtAttachments[i];
        const mrtTexture = rtWrapper.textures[i];
        const gpuMRTWrapper = mrtTexture === null || mrtTexture === void 0 ? void 0 : mrtTexture._hardwareTexture;
        const gpuMRTTexture = gpuMRTWrapper === null || gpuMRTWrapper === void 0 ? void 0 : gpuMRTWrapper.underlyingResource;
        if (gpuMRTWrapper && gpuMRTTexture) {
          const viewDescriptor = {
            ...this._rttRenderPassWrapper.colorAttachmentViewDescriptor,
            format: gpuMRTWrapper.format
          };
          const gpuMSAATexture = gpuMRTWrapper.msaaTexture;
          const colorTextureView = gpuMRTTexture.createView(viewDescriptor);
          const colorMSAATextureView = gpuMSAATexture === null || gpuMSAATexture === void 0 ? void 0 : gpuMSAATexture.createView(viewDescriptor);
          colorAttachments.push({
            view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,
            resolveTarget: gpuMSAATexture ? colorTextureView : void 0,
            clearValue: index !== 0 && mustClearColor ? clearColor : void 0,
            loadOp: index !== 0 && mustClearColor ? LoadOp.Clear : LoadOp.Load,
            storeOp: StoreOp.Store
          });
        }
      }
      this._cacheRenderPipeline.setMRT(rtWrapper.textures, this._mrtAttachments.length);
      this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);
    } else {
      const internalTexture = rtWrapper.texture;
      if (internalTexture) {
        const gpuWrapper = internalTexture._hardwareTexture;
        const gpuTexture = gpuWrapper.underlyingResource;
        const gpuMSAATexture = gpuWrapper.msaaTexture;
        const colorTextureView = gpuTexture.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor);
        const colorMSAATextureView = gpuMSAATexture === null || gpuMSAATexture === void 0 ? void 0 : gpuMSAATexture.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor);
        colorAttachments.push({
          view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,
          resolveTarget: gpuMSAATexture ? colorTextureView : void 0,
          clearValue: mustClearColor ? clearColor : void 0,
          loadOp: mustClearColor ? LoadOp.Clear : LoadOp.Load,
          storeOp: StoreOp.Store
        });
      } else {
        colorAttachments.push(null);
      }
    }
    (_a = this._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(this, "render target pass", 1);
    this._rttRenderPassWrapper.renderPassDescriptor = {
      colorAttachments,
      depthStencilAttachment: depthStencilTexture && gpuDepthStencilTexture ? {
        view: depthMSAATextureView ? depthMSAATextureView : depthTextureView,
        depthClearValue: mustClearDepth ? this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue : void 0,
        depthLoadOp: mustClearDepth ? LoadOp.Clear : LoadOp.Load,
        depthStoreOp: StoreOp.Store,
        stencilClearValue: rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? this._clearStencilValue : void 0,
        stencilLoadOp: !depthTextureHasStencil ? void 0 : rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? LoadOp.Clear : LoadOp.Load,
        stencilStoreOp: !depthTextureHasStencil ? void 0 : StoreOp.Store
      } : void 0,
      occlusionQuerySet: ((_b = this._occlusionQuery) === null || _b === void 0 ? void 0 : _b.hasQueries) ? this._occlusionQuery.querySet : void 0
    };
    this._rttRenderPassWrapper.renderPass = this._renderTargetEncoder.beginRenderPass(this._rttRenderPassWrapper.renderPassDescriptor);
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        const internalTexture = rtWrapper.texture;
        console.log("frame #" + this._count + " - render target begin pass - internalTexture.uniqueId=", internalTexture.uniqueId, "width=", internalTexture.width, "height=", internalTexture.height, this._rttRenderPassWrapper.renderPassDescriptor);
      }
    }
    this._currentRenderPass = this._rttRenderPassWrapper.renderPass;
    (_c = this._debugFlushPendingCommands) === null || _c === void 0 ? void 0 : _c.call(this);
    this._resetCurrentViewport(1);
    this._resetCurrentScissor(1);
    this._resetCurrentStencilRef(1);
    this._resetCurrentColorBlend(1);
    if (!gpuDepthStencilWrapper || !WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format)) {
      this._stencilStateComposer.enabled = false;
    }
  }
  _endRenderTargetRenderPass() {
    var _a, _b, _c, _d;
    if (this._currentRenderPass) {
      const gpuWrapper = (_a = this._currentRenderTarget.texture) === null || _a === void 0 ? void 0 : _a._hardwareTexture;
      if (gpuWrapper && !this._snapshotRendering.endRenderTargetPass(this._currentRenderPass, gpuWrapper) && !this.compatibilityMode) {
        this._bundleListRenderTarget.run(this._currentRenderPass);
        this._bundleListRenderTarget.reset();
      }
      this._currentRenderPass.end();
      if (this.dbgVerboseLogsForFirstFrames) {
        if (this._count === void 0) {
          this._count = 0;
        }
        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
          console.log("frame #" + this._count + " - render target end pass - internalTexture.uniqueId=", (_c = (_b = this._currentRenderTarget) === null || _b === void 0 ? void 0 : _b.texture) === null || _c === void 0 ? void 0 : _c.uniqueId);
        }
      }
      (_d = this._debugPopGroup) === null || _d === void 0 ? void 0 : _d.call(this, 1);
      this._resetCurrentViewport(1);
      this._resetCurrentScissor(1);
      this._resetCurrentStencilRef(1);
      this._resetCurrentColorBlend(1);
      this._currentRenderPass = null;
      this._rttRenderPassWrapper.reset();
    }
  }
  _getCurrentRenderPass() {
    if (this._currentRenderTarget && !this._currentRenderPass) {
      this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);
    } else if (!this._currentRenderPass) {
      this._startMainRenderPass(false);
    }
    return this._currentRenderPass;
  }
  _getCurrentRenderPassIndex() {
    return this._currentRenderPass === null ? -1 : this._currentRenderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;
  }
  _startMainRenderPass(setClearStates, clearColor, clearDepth, clearStencil) {
    var _a, _b, _c;
    if (this._mainRenderPassWrapper.renderPass) {
      this.flushFramebuffer(false);
    }
    if (this.useReverseDepthBuffer) {
      this.setDepthFunctionToGreaterOrEqual();
    }
    const mustClearColor = setClearStates && clearColor;
    const mustClearDepth = setClearStates && clearDepth;
    const mustClearStencil = setClearStates && clearStencil;
    this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].clearValue = mustClearColor ? clearColor : void 0;
    this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].loadOp = mustClearColor ? LoadOp.Clear : LoadOp.Load;
    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.depthClearValue = mustClearDepth ? this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue : void 0;
    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.depthLoadOp = mustClearDepth ? LoadOp.Clear : LoadOp.Load;
    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.stencilClearValue = mustClearStencil ? this._clearStencilValue : void 0;
    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.stencilLoadOp = !this.isStencilEnable ? void 0 : mustClearStencil ? LoadOp.Clear : LoadOp.Load;
    this._mainRenderPassWrapper.renderPassDescriptor.occlusionQuerySet = ((_a = this._occlusionQuery) === null || _a === void 0 ? void 0 : _a.hasQueries) ? this._occlusionQuery.querySet : void 0;
    const swapChainTexture = this._context.getCurrentTexture();
    this._mainRenderPassWrapper.colorAttachmentGPUTextures[0].set(swapChainTexture);
    if (this._options.antialiasing) {
      this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].resolveTarget = swapChainTexture.createView();
    } else {
      this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].view = swapChainTexture.createView();
    }
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        console.log("frame #" + this._count + " - main begin pass - texture width=" + this._mainTextureExtends.width, " height=" + this._mainTextureExtends.height, this._mainRenderPassWrapper.renderPassDescriptor);
      }
    }
    (_b = this._debugPushGroup) === null || _b === void 0 ? void 0 : _b.call(this, "main pass", 0);
    this._currentRenderPass = this._renderEncoder.beginRenderPass(this._mainRenderPassWrapper.renderPassDescriptor);
    this._mainRenderPassWrapper.renderPass = this._currentRenderPass;
    (_c = this._debugFlushPendingCommands) === null || _c === void 0 ? void 0 : _c.call(this);
    this._resetCurrentViewport(0);
    this._resetCurrentScissor(0);
    this._resetCurrentStencilRef(0);
    this._resetCurrentColorBlend(0);
    if (!this._isStencilEnable) {
      this._stencilStateComposer.enabled = false;
    }
  }
  _endMainRenderPass() {
    var _a;
    if (this._mainRenderPassWrapper.renderPass !== null) {
      this._snapshotRendering.endMainRenderPass();
      if (!this.compatibilityMode && !this._snapshotRendering.play) {
        this._bundleList.run(this._mainRenderPassWrapper.renderPass);
        this._bundleList.reset();
      }
      this._mainRenderPassWrapper.renderPass.end();
      if (this.dbgVerboseLogsForFirstFrames) {
        if (this._count === void 0) {
          this._count = 0;
        }
        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
          console.log("frame #" + this._count + " - main end pass");
        }
      }
      (_a = this._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(this, 0);
      this._resetCurrentViewport(0);
      this._resetCurrentScissor(0);
      this._resetCurrentStencilRef(0);
      this._resetCurrentColorBlend(0);
      if (this._mainRenderPassWrapper.renderPass === this._currentRenderPass) {
        this._currentRenderPass = null;
      }
      this._mainRenderPassWrapper.reset(false);
    }
  }
  bindFramebuffer(texture, faceIndex = 0, requiredWidth, requiredHeight, forceFullscreenViewport, lodLevel = 0, layer = 0) {
    var _a, _b;
    const hardwareTexture = (_a = texture.texture) === null || _a === void 0 ? void 0 : _a._hardwareTexture;
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    }
    this._currentRenderTarget = texture;
    if (hardwareTexture) {
      hardwareTexture._currentLayer = texture.isCube ? layer * 6 + faceIndex : layer;
    }
    this._rttRenderPassWrapper.colorAttachmentGPUTextures[0] = hardwareTexture;
    this._rttRenderPassWrapper.depthTextureFormat = this._currentRenderTarget._depthStencilTexture ? WebGPUTextureHelper.GetWebGPUTextureFormat(-1, this._currentRenderTarget._depthStencilTexture.format) : void 0;
    this._setDepthTextureFormat(this._rttRenderPassWrapper);
    this._setColorFormat(this._rttRenderPassWrapper);
    this._rttRenderPassWrapper.colorAttachmentViewDescriptor = {
      format: this._colorFormat,
      dimension: TextureViewDimension.E2d,
      mipLevelCount: 1,
      baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,
      baseMipLevel: lodLevel,
      arrayLayerCount: 1,
      aspect: TextureAspect.All
    };
    this._rttRenderPassWrapper.depthAttachmentViewDescriptor = {
      format: this._depthTextureFormat,
      dimension: TextureViewDimension.E2d,
      mipLevelCount: 1,
      baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,
      baseMipLevel: 0,
      arrayLayerCount: 1,
      aspect: TextureAspect.All
    };
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        console.log("frame #" + this._count + " - bindFramebuffer called - internalTexture.uniqueId=", (_b = texture.texture) === null || _b === void 0 ? void 0 : _b.uniqueId, "face=", faceIndex, "lodLevel=", lodLevel, "layer=", layer, this._rttRenderPassWrapper.colorAttachmentViewDescriptor, this._rttRenderPassWrapper.depthAttachmentViewDescriptor);
      }
    }
    this._currentRenderPass = null;
    if (this.snapshotRendering && this.snapshotRenderingMode === 1) {
      this._getCurrentRenderPass();
    }
    if (this._cachedViewport && !forceFullscreenViewport) {
      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);
    } else {
      if (!requiredWidth) {
        requiredWidth = texture.width;
        if (lodLevel) {
          requiredWidth = requiredWidth / Math.pow(2, lodLevel);
        }
      }
      if (!requiredHeight) {
        requiredHeight = texture.height;
        if (lodLevel) {
          requiredHeight = requiredHeight / Math.pow(2, lodLevel);
        }
      }
      this._viewport(0, 0, requiredWidth, requiredHeight);
    }
    this.wipeCaches();
  }
  unBindFramebuffer(texture, disableGenerateMipMaps = false, onBeforeUnbind) {
    var _a, _b;
    const saveCRT = this._currentRenderTarget;
    this._currentRenderTarget = null;
    if (onBeforeUnbind) {
      onBeforeUnbind();
    }
    this._currentRenderTarget = saveCRT;
    if (this._currentRenderPass && this._currentRenderPass !== this._mainRenderPassWrapper.renderPass) {
      this._endRenderTargetRenderPass();
    }
    if (((_a = texture.texture) === null || _a === void 0 ? void 0 : _a.generateMipMaps) && !disableGenerateMipMaps && !texture.isCube) {
      this._generateMipmaps(texture.texture);
    }
    this._currentRenderTarget = null;
    this._onAfterUnbindFrameBufferObservable.notifyObservers(this);
    if (this.dbgVerboseLogsForFirstFrames) {
      if (this._count === void 0) {
        this._count = 0;
      }
      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
        console.log("frame #" + this._count + " - unBindFramebuffer called - internalTexture.uniqueId=", (_b = texture.texture) === null || _b === void 0 ? void 0 : _b.uniqueId);
      }
    }
    this._mrtAttachments = [];
    this._cacheRenderPipeline.setMRT([]);
    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);
    this._currentRenderPass = this._mainRenderPassWrapper.renderPass;
    this._setDepthTextureFormat(this._mainRenderPassWrapper);
    this._setColorFormat(this._mainRenderPassWrapper);
  }
  restoreDefaultFramebuffer() {
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    } else {
      this._currentRenderPass = this._mainRenderPassWrapper.renderPass;
      this._setDepthTextureFormat(this._mainRenderPassWrapper);
      this._setColorFormat(this._mainRenderPassWrapper);
    }
    if (this._currentRenderPass) {
      if (this._cachedViewport) {
        this.setViewport(this._cachedViewport);
      }
    }
    this.wipeCaches();
  }
  _setColorFormat(wrapper) {
    var _a, _b;
    const format = (_b = (_a = wrapper.colorAttachmentGPUTextures[0]) === null || _a === void 0 ? void 0 : _a.format) !== null && _b !== void 0 ? _b : null;
    this._cacheRenderPipeline.setColorFormat(format);
    if (this._colorFormat === format) {
      return;
    }
    this._colorFormat = format;
  }
  _setDepthTextureFormat(wrapper) {
    this._cacheRenderPipeline.setDepthStencilFormat(wrapper.depthTextureFormat);
    if (this._depthTextureFormat === wrapper.depthTextureFormat) {
      return;
    }
    this._depthTextureFormat = wrapper.depthTextureFormat;
  }
  setDitheringState() {
  }
  setRasterizerState() {
  }
  setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {
    var _a, _b;
    if (this._depthCullingState.cull !== culling || force) {
      this._depthCullingState.cull = culling;
    }
    const cullFace = ((_b = (_a = this.cullBackFaces) !== null && _a !== void 0 ? _a : cullBackFaces) !== null && _b !== void 0 ? _b : true) ? 1 : 2;
    if (this._depthCullingState.cullFace !== cullFace || force) {
      this._depthCullingState.cullFace = cullFace;
    }
    this.setZOffset(zOffset);
    this.setZOffsetUnits(zOffsetUnits);
    const frontFace = reverseSide ? this._currentRenderTarget ? 1 : 2 : this._currentRenderTarget ? 2 : 1;
    if (this._depthCullingState.frontFace !== frontFace || force) {
      this._depthCullingState.frontFace = frontFace;
    }
    this._stencilStateComposer.stencilMaterial = stencil;
  }
  _applyRenderPassChanges(renderPass, bundleList) {
    var _a;
    const mustUpdateViewport = this._mustUpdateViewport(renderPass);
    const mustUpdateScissor = this._mustUpdateScissor(renderPass);
    const mustUpdateStencilRef = !this._stencilStateComposer.enabled ? false : this._mustUpdateStencilRef(renderPass);
    const mustUpdateBlendColor = !this._alphaState.alphaBlend ? false : this._mustUpdateBlendColor(renderPass);
    if (bundleList) {
      if (mustUpdateViewport) {
        bundleList.addItem(new WebGPURenderItemViewport(this._viewportCached.x, this._viewportCached.y, this._viewportCached.z, this._viewportCached.w));
      }
      if (mustUpdateScissor) {
        bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));
      }
      if (mustUpdateStencilRef) {
        bundleList.addItem(new WebGPURenderItemStencilRef((_a = this._stencilStateComposer.funcRef) !== null && _a !== void 0 ? _a : 0));
      }
      if (mustUpdateBlendColor) {
        bundleList.addItem(new WebGPURenderItemBlendColor(this._alphaState._blendConstants.slice()));
      }
    } else {
      if (mustUpdateViewport) {
        this._applyViewport(renderPass);
      }
      if (mustUpdateScissor) {
        this._applyScissor(renderPass);
      }
      if (mustUpdateStencilRef) {
        this._applyStencilRef(renderPass);
      }
      if (mustUpdateBlendColor) {
        this._applyBlendColor(renderPass);
      }
    }
  }
  _draw(drawType, fillMode, start, count, instancesCount) {
    var _a;
    const renderPass = this._getCurrentRenderPass();
    const renderPassIndex = this._getCurrentRenderPassIndex();
    const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;
    this.applyStates();
    const webgpuPipelineContext = this._currentEffect._pipelineContext;
    this.bindUniformBufferBase(this._currentRenderTarget ? this._ubInvertY : this._ubDontInvertY, 0, WebGPUShaderProcessor.InternalsUBOName);
    if (webgpuPipelineContext.uniformBuffer) {
      webgpuPipelineContext.uniformBuffer.update();
      this.bindUniformBufferBase(webgpuPipelineContext.uniformBuffer.getBuffer(), 0, WebGPUShaderProcessor.LeftOvertUBOName);
    }
    if (this._snapshotRendering.play) {
      this._reportDrawCall();
      return;
    }
    if (!this.compatibilityMode && (this._currentDrawContext.isDirty(this._currentMaterialContext.updateId) || this._currentMaterialContext.isDirty || this._currentMaterialContext.forceBindGroupCreation)) {
      this._currentDrawContext.fastBundle = void 0;
    }
    const useFastPath = !this.compatibilityMode && this._currentDrawContext.fastBundle;
    let renderPass2 = renderPass;
    if (useFastPath || this._snapshotRendering.record) {
      this._applyRenderPassChanges(renderPass, bundleList);
      if (!this._snapshotRendering.record) {
        this._counters.numBundleReuseNonCompatMode++;
        if (this._currentDrawContext.indirectDrawBuffer) {
          this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);
        }
        bundleList.addBundle(this._currentDrawContext.fastBundle);
        this._reportDrawCall();
        return;
      }
      renderPass2 = bundleList.getBundleEncoder(this._cacheRenderPipeline.colorFormats, this._depthTextureFormat, this.currentSampleCount);
      bundleList.numDrawCalls++;
    }
    let textureState = 0;
    if (!this._caps.textureFloatLinearFiltering && this._currentMaterialContext.hasFloatTextures) {
      let bitVal = 1;
      for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.textureNames.length; ++i) {
        const textureName = webgpuPipelineContext.shaderProcessingContext.textureNames[i];
        const texture = (_a = this._currentMaterialContext.textures[textureName]) === null || _a === void 0 ? void 0 : _a.texture;
        if ((texture === null || texture === void 0 ? void 0 : texture.type) === 1) {
          textureState |= bitVal;
        }
        bitVal = bitVal << 1;
      }
    }
    const pipeline = this._cacheRenderPipeline.getRenderPipeline(fillMode, this._currentEffect, this.currentSampleCount, textureState);
    const bindGroups = this._cacheBindGroups.getBindGroups(webgpuPipelineContext, this._currentDrawContext, this._currentMaterialContext);
    if (!this._snapshotRendering.record) {
      this._applyRenderPassChanges(renderPass, !this.compatibilityMode ? bundleList : null);
      if (!this.compatibilityMode) {
        this._counters.numBundleCreationNonCompatMode++;
        renderPass2 = this._device.createRenderBundleEncoder({
          colorFormats: this._cacheRenderPipeline.colorFormats,
          depthStencilFormat: this._depthTextureFormat,
          sampleCount: this.currentSampleCount
        });
      }
    }
    renderPass2.setPipeline(pipeline);
    if (this._currentIndexBuffer) {
      renderPass2.setIndexBuffer(this._currentIndexBuffer.underlyingResource, this._currentIndexBuffer.is32Bits ? IndexFormat.Uint32 : IndexFormat.Uint16, 0);
    }
    const vertexBuffers = this._cacheRenderPipeline.vertexBuffers;
    for (let index = 0; index < vertexBuffers.length; index++) {
      const vertexBuffer = vertexBuffers[index];
      const buffer = vertexBuffer.getBuffer();
      if (buffer) {
        renderPass2.setVertexBuffer(index, buffer.underlyingResource, vertexBuffer._validOffsetRange ? 0 : vertexBuffer.byteOffset);
      }
    }
    for (let i = 0; i < bindGroups.length; i++) {
      renderPass2.setBindGroup(i, bindGroups[i]);
    }
    const nonCompatMode = !this.compatibilityMode && !this._snapshotRendering.record;
    if (nonCompatMode && this._currentDrawContext.indirectDrawBuffer) {
      this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);
      if (drawType === 0) {
        renderPass2.drawIndexedIndirect(this._currentDrawContext.indirectDrawBuffer, 0);
      } else {
        renderPass2.drawIndirect(this._currentDrawContext.indirectDrawBuffer, 0);
      }
    } else if (drawType === 0) {
      renderPass2.drawIndexed(count, instancesCount || 1, start, 0, 0);
    } else {
      renderPass2.draw(count, instancesCount || 1, start, 0);
    }
    if (nonCompatMode) {
      this._currentDrawContext.fastBundle = renderPass2.finish();
      bundleList.addBundle(this._currentDrawContext.fastBundle);
    }
    this._reportDrawCall();
  }
  drawElementsType(fillMode, indexStart, indexCount, instancesCount = 1) {
    this._draw(0, fillMode, indexStart, indexCount, instancesCount);
  }
  drawArraysType(fillMode, verticesStart, verticesCount, instancesCount = 1) {
    this._currentIndexBuffer = null;
    this._draw(1, fillMode, verticesStart, verticesCount, instancesCount);
  }
  dispose() {
    var _a, _b;
    (_a = this._mainTexture) === null || _a === void 0 ? void 0 : _a.destroy();
    (_b = this._depthTexture) === null || _b === void 0 ? void 0 : _b.destroy();
    super.dispose();
  }
  getRenderWidth(useScreen = false) {
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.width;
    }
    return this._canvas.width;
  }
  getRenderHeight(useScreen = false) {
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.height;
    }
    return this._canvas.height;
  }
  getRenderingCanvas() {
    return this._canvas;
  }
  getError() {
    return 0;
  }
  bindSamplers() {
  }
  _bindTextureDirectly() {
    return false;
  }
  areAllEffectsReady() {
    return true;
  }
  _executeWhenRenderingStateIsCompiled(pipelineContext, action) {
    action();
  }
  _isRenderingStateCompiled() {
    return true;
  }
  _getUnpackAlignement() {
    return 1;
  }
  _unpackFlipY() {
  }
  _bindUnboundFramebuffer() {
    throw "_bindUnboundFramebuffer is not implementedin WebGPU! You probably want to use restoreDefaultFramebuffer or unBindFramebuffer instead";
  }
  _getSamplingParameters() {
    throw "_getSamplingParameters is not available in WebGPU";
  }
  getUniforms() {
    return [];
  }
  setIntArray() {
    return false;
  }
  setIntArray2() {
    return false;
  }
  setIntArray3() {
    return false;
  }
  setIntArray4() {
    return false;
  }
  setArray() {
    return false;
  }
  setArray2() {
    return false;
  }
  setArray3() {
    return false;
  }
  setArray4() {
    return false;
  }
  setMatrices() {
    return false;
  }
  setMatrix3x3() {
    return false;
  }
  setMatrix2x2() {
    return false;
  }
  setFloat() {
    return false;
  }
  setFloat2() {
    return false;
  }
  setFloat3() {
    return false;
  }
  setFloat4() {
    return false;
  }
};
WebGPUEngine._GLSLslangDefaultOptions = {
  jsPath: "https://preview.babylonjs.com/glslang/glslang.js",
  wasmPath: "https://preview.babylonjs.com/glslang/glslang.wasm"
};
WebGPUEngine.UseTWGSL = true;

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.alpha.js
WebGPUEngine.prototype.setAlphaMode = function(mode, noDepthWriteChange = false) {
  if (this._alphaMode === mode && (mode === 0 && !this._alphaState.alphaBlend || mode !== 0 && this._alphaState.alphaBlend)) {
    return;
  }
  switch (mode) {
    case 0:
      this._alphaState.alphaBlend = false;
      break;
    case 7:
      this._alphaState.setAlphaBlendFunctionParameters(1, 771, 1, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 8:
      this._alphaState.setAlphaBlendFunctionParameters(1, 771, 1, 771);
      this._alphaState.alphaBlend = true;
      break;
    case 2:
      this._alphaState.setAlphaBlendFunctionParameters(770, 771, 1, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 6:
      this._alphaState.setAlphaBlendFunctionParameters(1, 1, 0, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 1:
      this._alphaState.setAlphaBlendFunctionParameters(770, 1, 0, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 3:
      this._alphaState.setAlphaBlendFunctionParameters(0, 769, 1, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 4:
      this._alphaState.setAlphaBlendFunctionParameters(774, 0, 1, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 5:
      this._alphaState.setAlphaBlendFunctionParameters(770, 769, 1, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 9:
      this._alphaState.setAlphaBlendFunctionParameters(32769, 32770, 32771, 32772);
      this._alphaState.alphaBlend = true;
      break;
    case 10:
      this._alphaState.setAlphaBlendFunctionParameters(1, 769, 1, 771);
      this._alphaState.alphaBlend = true;
      break;
    case 11:
      this._alphaState.setAlphaBlendFunctionParameters(1, 1, 1, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 12:
      this._alphaState.setAlphaBlendFunctionParameters(772, 1, 0, 0);
      this._alphaState.alphaBlend = true;
      break;
    case 13:
      this._alphaState.setAlphaBlendFunctionParameters(775, 769, 773, 771);
      this._alphaState.alphaBlend = true;
      break;
    case 14:
      this._alphaState.setAlphaBlendFunctionParameters(1, 771, 1, 771);
      this._alphaState.alphaBlend = true;
      break;
    case 15:
      this._alphaState.setAlphaBlendFunctionParameters(1, 1, 1, 0);
      this._alphaState.alphaBlend = true;
      break;
    case 16:
      this._alphaState.setAlphaBlendFunctionParameters(775, 769, 0, 1);
      this._alphaState.alphaBlend = true;
      break;
    case 17:
      this._alphaState.setAlphaBlendFunctionParameters(770, 771, 1, 771);
      this._alphaState.alphaBlend = true;
      break;
  }
  if (!noDepthWriteChange) {
    this.setDepthWrite(mode === Engine.ALPHA_DISABLE);
    this._cacheRenderPipeline.setDepthWriteEnabled(mode === Engine.ALPHA_DISABLE);
  }
  this._alphaMode = mode;
  this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState.alphaBlend);
  this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);
};
WebGPUEngine.prototype.setAlphaEquation = function(equation) {
  Engine.prototype.setAlphaEquation.call(this, equation);
  this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuComputeContext.js
var WebGPUComputeContext = class {
  constructor(device, cacheSampler) {
    this._device = device;
    this._cacheSampler = cacheSampler;
    this.uniqueId = WebGPUComputeContext._Counter++;
    this._bindGroupEntries = [];
    this.clear();
  }
  getBindGroups(bindings, computePipeline, bindingsMapping) {
    if (!bindingsMapping) {
      throw new Error("WebGPUComputeContext.getBindGroups: bindingsMapping is required until browsers support reflection for wgsl shaders!");
    }
    if (this._bindGroups.length === 0) {
      const bindGroupEntriesExist = this._bindGroupEntries.length > 0;
      for (const key in bindings) {
        const binding = bindings[key], location = bindingsMapping[key], group = location.group, index = location.binding, type = binding.type, object = binding.object;
        let indexInGroupEntries = binding.indexInGroupEntries;
        let entries = this._bindGroupEntries[group];
        if (!entries) {
          entries = this._bindGroupEntries[group] = [];
        }
        switch (type) {
          case ComputeBindingType.Sampler: {
            const sampler = object;
            if (indexInGroupEntries !== void 0 && bindGroupEntriesExist) {
              entries[indexInGroupEntries].resource = this._cacheSampler.getSampler(sampler);
            } else {
              binding.indexInGroupEntries = entries.length;
              entries.push({
                binding: index,
                resource: this._cacheSampler.getSampler(sampler)
              });
            }
            break;
          }
          case ComputeBindingType.Texture:
          case ComputeBindingType.TextureWithoutSampler: {
            const texture = object;
            const hardwareTexture = texture._texture._hardwareTexture;
            if (indexInGroupEntries !== void 0 && bindGroupEntriesExist) {
              if (type === ComputeBindingType.Texture) {
                entries[indexInGroupEntries++].resource = this._cacheSampler.getSampler(texture._texture);
              }
              entries[indexInGroupEntries].resource = hardwareTexture.view;
            } else {
              binding.indexInGroupEntries = entries.length;
              if (type === ComputeBindingType.Texture) {
                entries.push({
                  binding: index - 1,
                  resource: this._cacheSampler.getSampler(texture._texture)
                });
              }
              entries.push({
                binding: index,
                resource: hardwareTexture.view
              });
            }
            break;
          }
          case ComputeBindingType.StorageTexture: {
            const texture = object;
            const hardwareTexture = texture._texture._hardwareTexture;
            if ((hardwareTexture.textureAdditionalUsages & TextureUsage.StorageBinding) === 0) {
              Logger.Error(`computeDispatch: The texture (name=${texture.name}, uniqueId=${texture.uniqueId}) is not a storage texture!`, 50);
            }
            if (indexInGroupEntries !== void 0 && bindGroupEntriesExist) {
              entries[indexInGroupEntries].resource = hardwareTexture.viewForWriting;
            } else {
              binding.indexInGroupEntries = entries.length;
              entries.push({
                binding: index,
                resource: hardwareTexture.viewForWriting
              });
            }
            break;
          }
          case ComputeBindingType.UniformBuffer:
          case ComputeBindingType.StorageBuffer: {
            const buffer = type === ComputeBindingType.UniformBuffer ? object : object;
            const dataBuffer = buffer.getBuffer();
            const webgpuBuffer = dataBuffer.underlyingResource;
            if (indexInGroupEntries !== void 0 && bindGroupEntriesExist) {
              entries[indexInGroupEntries].resource.buffer = webgpuBuffer;
              entries[indexInGroupEntries].resource.size = dataBuffer.capacity;
            } else {
              binding.indexInGroupEntries = entries.length;
              entries.push({
                binding: index,
                resource: {
                  buffer: webgpuBuffer,
                  offset: 0,
                  size: dataBuffer.capacity
                }
              });
            }
            break;
          }
        }
      }
      for (let i = 0; i < this._bindGroupEntries.length; ++i) {
        const entries = this._bindGroupEntries[i];
        if (!entries) {
          this._bindGroups[i] = void 0;
          continue;
        }
        this._bindGroups[i] = this._device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(i),
          entries
        });
      }
      this._bindGroups.length = this._bindGroupEntries.length;
    }
    return this._bindGroups;
  }
  clear() {
    this._bindGroups = [];
  }
};
WebGPUComputeContext._Counter = 0;

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuComputePipelineContext.js
var WebGPUComputePipelineContext = class {
  constructor(engine) {
    this._name = "unnamed";
    this.engine = engine;
  }
  get isAsync() {
    return false;
  }
  get isReady() {
    if (this.stage) {
      return true;
    }
    return false;
  }
  _getComputeShaderCode() {
    var _a;
    return (_a = this.sources) === null || _a === void 0 ? void 0 : _a.compute;
  }
  dispose() {
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.computeShader.js
WebGPUEngine.prototype.createComputeContext = function() {
  return new WebGPUComputeContext(this._device, this._cacheSampler);
};
WebGPUEngine.prototype.createComputeEffect = function(baseName, options) {
  const compute = baseName.computeElement || baseName.compute || baseName.computeToken || baseName.computeSource || baseName;
  const name137 = compute + "@" + options.defines;
  if (this._compiledComputeEffects[name137]) {
    const compiledEffect = this._compiledComputeEffects[name137];
    if (options.onCompiled && compiledEffect.isReady()) {
      options.onCompiled(compiledEffect);
    }
    return compiledEffect;
  }
  const effect = new ComputeEffect(baseName, options, this, name137);
  this._compiledComputeEffects[name137] = effect;
  return effect;
};
WebGPUEngine.prototype.createComputePipelineContext = function() {
  return new WebGPUComputePipelineContext(this);
};
WebGPUEngine.prototype.areAllComputeEffectsReady = function() {
  for (const key in this._compiledComputeEffects) {
    const effect = this._compiledComputeEffects[key];
    if (!effect.isReady()) {
      return false;
    }
  }
  return true;
};
WebGPUEngine.prototype.computeDispatch = function(effect, context, bindings, x, y, z, bindingsMapping) {
  if (this._currentRenderTarget) {
    this._onAfterUnbindFrameBufferObservable.addOnce(() => {
      this.computeDispatch(effect, context, bindings, x, y, z, bindingsMapping);
    });
    return;
  }
  const contextPipeline = effect._pipelineContext;
  const computeContext = context;
  if (!contextPipeline.computePipeline) {
    contextPipeline.computePipeline = this._device.createComputePipeline({
      layout: AutoLayoutMode.Auto,
      compute: contextPipeline.stage
    });
  }
  const commandEncoder = this._renderTargetEncoder;
  const computePass = commandEncoder.beginComputePass();
  computePass.setPipeline(contextPipeline.computePipeline);
  const bindGroups = computeContext.getBindGroups(bindings, contextPipeline.computePipeline, bindingsMapping);
  for (let i = 0; i < bindGroups.length; ++i) {
    const bindGroup = bindGroups[i];
    if (!bindGroup) {
      continue;
    }
    computePass.setBindGroup(i, bindGroup);
  }
  computePass.dispatchWorkgroups(x, y, z);
  computePass.end();
};
WebGPUEngine.prototype.releaseComputeEffects = function() {
  for (const name137 in this._compiledComputeEffects) {
    const webGPUPipelineContextCompute = this._compiledComputeEffects[name137].getPipelineContext();
    this._deleteComputePipelineContext(webGPUPipelineContextCompute);
  }
  this._compiledComputeEffects = {};
};
WebGPUEngine.prototype._prepareComputePipelineContext = function(pipelineContext, computeSourceCode, rawComputeSourceCode, defines, entryPoint) {
  const webGpuContext = pipelineContext;
  if (this.dbgShowShaderCode) {
    console.log(defines);
    console.log(computeSourceCode);
  }
  webGpuContext.sources = {
    compute: computeSourceCode,
    rawCompute: rawComputeSourceCode
  };
  webGpuContext.stage = this._createComputePipelineStageDescriptor(computeSourceCode, defines, entryPoint);
};
WebGPUEngine.prototype._releaseComputeEffect = function(effect) {
  if (this._compiledComputeEffects[effect._key]) {
    delete this._compiledComputeEffects[effect._key];
    this._deleteComputePipelineContext(effect.getPipelineContext());
  }
};
WebGPUEngine.prototype._rebuildComputeEffects = function() {
  for (const key in this._compiledComputeEffects) {
    const effect = this._compiledComputeEffects[key];
    effect._pipelineContext = null;
    effect._wasPreviouslyReady = false;
    effect._prepareEffect();
  }
};
WebGPUEngine.prototype._deleteComputePipelineContext = function(pipelineContext) {
  const webgpuPipelineContext = pipelineContext;
  if (webgpuPipelineContext) {
    pipelineContext.dispose();
  }
};
WebGPUEngine.prototype._createComputePipelineStageDescriptor = function(computeShader, defines, entryPoint) {
  if (defines) {
    defines = "//" + defines.split("\n").join("\n//") + "\n";
  } else {
    defines = "";
  }
  return {
    module: this._device.createShaderModule({
      code: defines + computeShader
    }),
    entryPoint
  };
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.cubeTexture.js
WebGPUEngine.prototype._createDepthStencilCubeTexture = function(size, options) {
  const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);
  internalTexture.isCube = true;
  const internalOptions = {
    bilinearFiltering: false,
    comparisonFunction: 0,
    generateStencil: false,
    samples: 1,
    ...options
  };
  internalTexture.format = internalOptions.generateStencil ? 13 : 14;
  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);
  this._textureHelper.createGPUTextureForInternalTexture(internalTexture);
  this._internalTexturesCache.push(internalTexture);
  return internalTexture;
};
WebGPUEngine.prototype.createCubeTexture = function(rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, useSRGBBuffer = false) {
  return this.createCubeTextureBase(rootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, null, (texture, imgs) => {
    const imageBitmaps = imgs;
    const width = imageBitmaps[0].width;
    const height = width;
    this._setCubeMapTextureParams(texture, !noMipmap);
    texture.format = format !== null && format !== void 0 ? format : -1;
    const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);
    this._textureHelper.updateCubeTextures(imageBitmaps, gpuTextureWrapper.underlyingResource, width, height, gpuTextureWrapper.format, false, false, 0, 0);
    if (!noMipmap) {
      this._generateMipmaps(texture, this._uploadEncoder);
    }
    texture.isReady = true;
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
    if (onLoad) {
      onLoad();
    }
  }, !!useSRGBBuffer);
};
WebGPUEngine.prototype._setCubeMapTextureParams = function(texture, loadMipmap, maxLevel) {
  texture.samplingMode = loadMipmap ? 3 : 2;
  texture._cachedWrapU = 0;
  texture._cachedWrapV = 0;
  if (maxLevel) {
    texture._maxLodLevel = maxLevel;
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.debugging.js
WebGPUEngine.prototype._debugPushGroup = function(groupName, targetObject) {
  if (!this._options.enableGPUDebugMarkers) {
    return;
  }
  if (targetObject === 0 || targetObject === 1) {
    const encoder = targetObject === 0 ? this._renderEncoder : this._renderTargetEncoder;
    encoder.pushDebugGroup(groupName);
  } else if (this._currentRenderPass) {
    this._currentRenderPass.pushDebugGroup(groupName);
  } else {
    this._pendingDebugCommands.push(["push", groupName]);
  }
};
WebGPUEngine.prototype._debugPopGroup = function(targetObject) {
  if (!this._options.enableGPUDebugMarkers) {
    return;
  }
  if (targetObject === 0 || targetObject === 1) {
    const encoder = targetObject === 0 ? this._renderEncoder : this._renderTargetEncoder;
    encoder.popDebugGroup();
  } else if (this._currentRenderPass) {
    this._currentRenderPass.popDebugGroup();
  } else {
    this._pendingDebugCommands.push(["pop", null]);
  }
};
WebGPUEngine.prototype._debugInsertMarker = function(text, targetObject) {
  if (!this._options.enableGPUDebugMarkers) {
    return;
  }
  if (targetObject === 0 || targetObject === 1) {
    const encoder = targetObject === 0 ? this._renderEncoder : this._renderTargetEncoder;
    encoder.insertDebugMarker(text);
  } else if (this._currentRenderPass) {
    this._currentRenderPass.insertDebugMarker(text);
  } else {
    this._pendingDebugCommands.push(["insert", text]);
  }
};
WebGPUEngine.prototype._debugFlushPendingCommands = function() {
  for (let i = 0; i < this._pendingDebugCommands.length; ++i) {
    const [name137, param] = this._pendingDebugCommands[i];
    switch (name137) {
      case "push":
        this._debugPushGroup(param);
        break;
      case "pop":
        this._debugPopGroup();
        break;
      case "insert":
        this._debugInsertMarker(param);
        break;
    }
  }
  this._pendingDebugCommands.length = 0;
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.dynamicBuffer.js
WebGPUEngine.prototype.updateDynamicIndexBuffer = function(indexBuffer, indices, offset = 0) {
  const gpuBuffer = indexBuffer;
  let view;
  if (indexBuffer.is32Bits) {
    view = indices instanceof Uint32Array ? indices : new Uint32Array(indices);
  } else {
    view = indices instanceof Uint16Array ? indices : new Uint16Array(indices);
  }
  this._bufferManager.setSubData(gpuBuffer, offset, view);
};
WebGPUEngine.prototype.updateDynamicVertexBuffer = function(vertexBuffer, data, byteOffset, byteLength) {
  const dataBuffer = vertexBuffer;
  if (byteOffset === void 0) {
    byteOffset = 0;
  }
  let view;
  if (byteLength === void 0) {
    if (data instanceof Array) {
      view = new Float32Array(data);
    } else if (data instanceof ArrayBuffer) {
      view = new Uint8Array(data);
    } else {
      view = data;
    }
    byteLength = view.byteLength;
  } else {
    if (data instanceof Array) {
      view = new Float32Array(data);
    } else if (data instanceof ArrayBuffer) {
      view = new Uint8Array(data);
    } else {
      view = data;
    }
  }
  this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.dynamicTexture.js
WebGPUEngine.prototype.updateDynamicTexture = function(texture, canvas, invertY, premulAlpha = false, format, forceBindTexture, allowGPUOptimization) {
  var _a;
  if (!texture) {
    return;
  }
  const width = canvas.width, height = canvas.height;
  let gpuTextureWrapper = texture._hardwareTexture;
  if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {
    gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);
  }
  this._textureHelper.updateTexture(canvas, texture, width, height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, premulAlpha, 0, 0, allowGPUOptimization);
  if (texture.generateMipMaps) {
    this._generateMipmaps(texture, this._uploadEncoder);
  }
  texture.isReady = true;
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuExternalTexture.js
var WebGPUExternalTexture = class extends ExternalTexture {
  constructor(video) {
    super(video);
  }
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.externalTexture.js
Effect.prototype.setExternalTexture = function(name137, texture) {
  this._engine.setExternalTexture(name137, texture);
};
WebGPUEngine.prototype.createExternalTexture = function(video) {
  const texture = new WebGPUExternalTexture(video);
  return texture;
};
WebGPUEngine.prototype.setExternalTexture = function(name137, texture) {
  if (!texture) {
    this._currentMaterialContext.setTexture(name137, null);
    return;
  }
  this._setInternalTexture(name137, texture);
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.multiRender.js
WebGPUEngine.prototype.unBindMultiColorAttachmentFramebuffer = function(rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {
  if (onBeforeUnbind) {
    onBeforeUnbind();
  }
  const attachments = rtWrapper._attachments;
  const count = attachments.length;
  if (this._currentRenderPass && this._currentRenderPass !== this._mainRenderPassWrapper.renderPass) {
    this._endRenderTargetRenderPass();
  }
  for (let i = 0; i < count; i++) {
    const texture = rtWrapper.textures[i];
    if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {
      this._generateMipmaps(texture);
    }
  }
  this._currentRenderTarget = null;
  this._mrtAttachments = [];
  this._cacheRenderPipeline.setMRT([]);
  this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);
  this._currentRenderPass = this._mainRenderPassWrapper.renderPass;
  this._setDepthTextureFormat(this._mainRenderPassWrapper);
  this._setColorFormat(this._mainRenderPassWrapper);
};
WebGPUEngine.prototype.createMultipleRenderTarget = function(size, options, initializeBuffers) {
  var _a;
  let generateMipMaps = false;
  let generateDepthBuffer = true;
  let generateStencilBuffer = false;
  let generateDepthTexture = false;
  let depthTextureFormat = 15;
  let textureCount = 1;
  const defaultType = 0;
  const defaultSamplingMode = 3;
  const defaultUseSRGBBuffer = false;
  let types = new Array();
  let samplingModes = new Array();
  let useSRGBBuffers = new Array();
  const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size);
  if (options !== void 0) {
    generateMipMaps = options.generateMipMaps === void 0 ? false : options.generateMipMaps;
    generateDepthBuffer = options.generateDepthBuffer === void 0 ? true : options.generateDepthBuffer;
    generateStencilBuffer = options.generateStencilBuffer === void 0 ? false : options.generateStencilBuffer;
    generateDepthTexture = options.generateDepthTexture === void 0 ? false : options.generateDepthTexture;
    textureCount = options.textureCount || 1;
    depthTextureFormat = (_a = options.depthTextureFormat) !== null && _a !== void 0 ? _a : 15;
    if (options.types) {
      types = options.types;
    }
    if (options.samplingModes) {
      samplingModes = options.samplingModes;
    }
    if (options.useSRGBBuffers) {
      useSRGBBuffers = options.useSRGBBuffers;
    }
  }
  const width = size.width || size;
  const height = size.height || size;
  let depthStencilTexture = null;
  if (generateDepthBuffer || generateStencilBuffer || generateDepthTexture) {
    depthStencilTexture = rtWrapper.createDepthStencilTexture(0, false, generateStencilBuffer, 1, depthTextureFormat);
  }
  const textures = [];
  const attachments = [];
  const defaultAttachments = [];
  rtWrapper._generateDepthBuffer = generateDepthBuffer;
  rtWrapper._generateStencilBuffer = generateStencilBuffer;
  rtWrapper._attachments = attachments;
  rtWrapper._defaultAttachments = defaultAttachments;
  for (let i = 0; i < textureCount; i++) {
    let samplingMode = samplingModes[i] || defaultSamplingMode;
    let type = types[i] || defaultType;
    const useSRGBBuffer = useSRGBBuffers[i] || defaultUseSRGBBuffer;
    if (type === 1 && !this._caps.textureFloatLinearFiltering) {
      samplingMode = 1;
    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
      samplingMode = 1;
    }
    if (type === 1 && !this._caps.textureFloat) {
      type = 0;
      Logger.Warn("Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type");
    }
    const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);
    textures.push(texture);
    attachments.push(i + 1);
    defaultAttachments.push(initializeBuffers ? i + 1 : i === 0 ? 1 : 0);
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.isReady = true;
    texture.samples = 1;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    texture.type = type;
    texture._cachedWrapU = 0;
    texture._cachedWrapV = 0;
    texture._useSRGBBuffer = useSRGBBuffer;
    this._internalTexturesCache.push(texture);
    this._textureHelper.createGPUTextureForInternalTexture(texture);
  }
  if (depthStencilTexture) {
    depthStencilTexture.incrementReferences();
    textures.push(depthStencilTexture);
    this._internalTexturesCache.push(depthStencilTexture);
  }
  rtWrapper.setTextures(textures);
  return rtWrapper;
};
WebGPUEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function(rtWrapper, samples) {
  if (!rtWrapper || !rtWrapper.textures || rtWrapper.textures[0].samples === samples) {
    return samples;
  }
  const count = rtWrapper.textures.length;
  if (count === 0) {
    return 1;
  }
  samples = Math.min(samples, this.getCaps().maxMSAASamples);
  for (let i = 0; i < count; ++i) {
    const texture = rtWrapper.textures[i];
    this._textureHelper.createMSAATexture(texture, samples);
    texture.samples = samples;
  }
  if (rtWrapper._depthStencilTexture && rtWrapper._depthStencilTexture !== rtWrapper.textures[rtWrapper.textures.length - 1]) {
    this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);
    rtWrapper._depthStencilTexture.samples = samples;
  }
  return samples;
};
WebGPUEngine.prototype.bindAttachments = function(attachments) {
  if (attachments.length === 0 || !this._currentRenderTarget) {
    return;
  }
  this._mrtAttachments = attachments;
  if (this._currentRenderPass) {
    this._cacheRenderPipeline.setMRTAttachments(attachments);
  } else {
  }
};
WebGPUEngine.prototype.buildTextureLayout = function(textureStatus) {
  const result = [];
  for (let i = 0; i < textureStatus.length; i++) {
    if (textureStatus[i]) {
      result.push(i + 1);
    } else {
      result.push(0);
    }
  }
  return result;
};
WebGPUEngine.prototype.restoreSingleAttachment = function() {
};
WebGPUEngine.prototype.restoreSingleAttachmentForRenderTarget = function() {
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.query.js
WebGPUEngine.prototype.getGPUFrameTimeCounter = function() {
  return this._timestampQuery.gpuFrameTimeCounter;
};
WebGPUEngine.prototype.captureGPUFrameTime = function(value) {
  this._timestampQuery.enable = value && !!this._caps.timerQuery;
};
WebGPUEngine.prototype.createQuery = function() {
  return this._occlusionQuery.createQuery();
};
WebGPUEngine.prototype.deleteQuery = function(query) {
  this._occlusionQuery.deleteQuery(query);
  return this;
};
WebGPUEngine.prototype.isQueryResultAvailable = function(query) {
  return this._occlusionQuery.isQueryResultAvailable(query);
};
WebGPUEngine.prototype.getQueryResult = function(query) {
  return this._occlusionQuery.getQueryResult(query);
};
WebGPUEngine.prototype.beginOcclusionQuery = function(algorithmType, query) {
  var _a;
  if (this.compatibilityMode) {
    if (this._occlusionQuery.canBeginQuery) {
      (_a = this._currentRenderPass) === null || _a === void 0 ? void 0 : _a.beginOcclusionQuery(query);
      return true;
    }
  } else {
    const renderPassIndex = this._getCurrentRenderPassIndex();
    const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;
    bundleList.addItem(new WebGPURenderItemBeginOcclusionQuery(query));
    return true;
  }
  return false;
};
WebGPUEngine.prototype.endOcclusionQuery = function() {
  var _a;
  if (this.compatibilityMode) {
    (_a = this._currentRenderPass) === null || _a === void 0 ? void 0 : _a.endOcclusionQuery();
  } else {
    const renderPassIndex = this._getCurrentRenderPassIndex();
    const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;
    bundleList.addItem(new WebGPURenderItemEndOcclusionQuery());
  }
  return this;
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.rawTexture.js
WebGPUEngine.prototype.createRawTexture = function(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {
  const texture = new InternalTexture(this, InternalTextureSource.Raw);
  texture.baseWidth = width;
  texture.baseHeight = height;
  texture.width = width;
  texture.height = height;
  texture.format = format;
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  texture.invertY = invertY;
  texture._compression = compression;
  texture.type = type;
  texture._useSRGBBuffer = useSRGBBuffer;
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
  }
  this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, void 0, creationFlags);
  this.updateRawTexture(texture, data, format, invertY, compression, type, useSRGBBuffer);
  this._internalTexturesCache.push(texture);
  return texture;
};
WebGPUEngine.prototype.updateRawTexture = function(texture, bufferView, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {
  if (!texture) {
    return;
  }
  if (!this._doNotHandleContextLost) {
    texture._bufferView = bufferView;
    texture.invertY = invertY;
    texture._compression = compression;
    texture._useSRGBBuffer = useSRGBBuffer;
  }
  if (bufferView) {
    const gpuTextureWrapper = texture._hardwareTexture;
    const needConversion = format === 4;
    if (needConversion) {
      bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, type);
    }
    const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
    this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);
    if (texture.generateMipMaps) {
      this._generateMipmaps(texture, this._uploadEncoder);
    }
  }
  texture.isReady = true;
};
WebGPUEngine.prototype.createRawCubeTexture = function(data, size, format, type, generateMipMaps, invertY, samplingMode, compression = null) {
  const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);
  if (type === 1 && !this._caps.textureFloatLinearFiltering) {
    generateMipMaps = false;
    samplingMode = 1;
    Logger.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
  } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
    generateMipMaps = false;
    samplingMode = 1;
    Logger.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
  } else if (type === 1 && !this._caps.textureFloatRender) {
    generateMipMaps = false;
    Logger.Warn("Render to float textures is not supported. Mipmap generation forced to false.");
  } else if (type === 2 && !this._caps.colorBufferFloat) {
    generateMipMaps = false;
    Logger.Warn("Render to half float textures is not supported. Mipmap generation forced to false.");
  }
  texture.isCube = true;
  texture.format = format === 4 ? 5 : format;
  texture.type = type;
  texture.generateMipMaps = generateMipMaps;
  texture.width = size;
  texture.height = size;
  texture.samplingMode = samplingMode;
  if (!this._doNotHandleContextLost) {
    texture._bufferViewArray = data;
  }
  texture.invertY = invertY;
  texture._compression = compression;
  texture._cachedWrapU = 0;
  texture._cachedWrapV = 0;
  this._textureHelper.createGPUTextureForInternalTexture(texture);
  if (data) {
    this.updateRawCubeTexture(texture, data, format, type, invertY, compression);
  }
  texture.isReady = true;
  return texture;
};
WebGPUEngine.prototype.updateRawCubeTexture = function(texture, bufferView, format, type, invertY, compression = null) {
  texture._bufferViewArray = bufferView;
  texture.invertY = invertY;
  texture._compression = compression;
  const gpuTextureWrapper = texture._hardwareTexture;
  const needConversion = format === 4;
  const data = [];
  for (let i = 0; i < bufferView.length; ++i) {
    let faceData = bufferView[i];
    if (needConversion) {
      faceData = _convertRGBtoRGBATextureData(bufferView[i], texture.width, texture.height, type);
    }
    data.push(new Uint8Array(faceData.buffer, faceData.byteOffset, faceData.byteLength));
  }
  this._textureHelper.updateCubeTextures(data, gpuTextureWrapper.underlyingResource, texture.width, texture.height, gpuTextureWrapper.format, invertY, false, 0, 0);
  if (texture.generateMipMaps) {
    this._generateMipmaps(texture, this._uploadEncoder);
  }
  texture.isReady = true;
};
WebGPUEngine.prototype.createRawCubeTextureFromUrl = function(url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad = null, onError = null, samplingMode = 3, invertY = false) {
  const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);
  scene === null || scene === void 0 ? void 0 : scene.addPendingData(texture);
  texture.url = url;
  this._internalTexturesCache.push(texture);
  const onerror = (request, exception) => {
    scene === null || scene === void 0 ? void 0 : scene.removePendingData(texture);
    if (onError && request) {
      onError(request.status + " " + request.statusText, exception);
    }
  };
  const internalCallback = (data) => {
    const width = texture.width;
    const faceDataArrays = callback(data);
    if (!faceDataArrays) {
      return;
    }
    const faces = [0, 2, 4, 1, 3, 5];
    if (mipmapGenerator) {
      const needConversion = format === 4;
      const mipData = mipmapGenerator(faceDataArrays);
      const gpuTextureWrapper = texture._hardwareTexture;
      const faces2 = [0, 1, 2, 3, 4, 5];
      for (let level = 0; level < mipData.length; level++) {
        const mipSize = width >> level;
        const allFaces = [];
        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
          let mipFaceData = mipData[level][faces2[faceIndex]];
          if (needConversion) {
            mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);
          }
          allFaces.push(new Uint8Array(mipFaceData.buffer, mipFaceData.byteOffset, mipFaceData.byteLength));
        }
        this._textureHelper.updateCubeTextures(allFaces, gpuTextureWrapper.underlyingResource, mipSize, mipSize, gpuTextureWrapper.format, invertY, false, 0, 0);
      }
    } else {
      const allFaces = [];
      for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
        allFaces.push(faceDataArrays[faces[faceIndex]]);
      }
      this.updateRawCubeTexture(texture, allFaces, format, type, invertY);
    }
    texture.isReady = true;
    scene === null || scene === void 0 ? void 0 : scene.removePendingData(texture);
    if (onLoad) {
      onLoad();
    }
  };
  this._loadFile(url, (data) => {
    internalCallback(data);
  }, void 0, scene === null || scene === void 0 ? void 0 : scene.offlineProvider, true, onerror);
  return texture;
};
WebGPUEngine.prototype.createRawTexture3D = function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0, creationFlags = 0) {
  const source = InternalTextureSource.Raw3D;
  const texture = new InternalTexture(this, source);
  texture.baseWidth = width;
  texture.baseHeight = height;
  texture.baseDepth = depth;
  texture.width = width;
  texture.height = height;
  texture.depth = depth;
  texture.format = format;
  texture.type = textureType;
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  texture.is3D = true;
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
  }
  this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, void 0, creationFlags);
  this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);
  this._internalTexturesCache.push(texture);
  return texture;
};
WebGPUEngine.prototype.updateRawTexture3D = function(texture, bufferView, format, invertY, compression = null, textureType = 0) {
  if (!this._doNotHandleContextLost) {
    texture._bufferView = bufferView;
    texture.format = format;
    texture.invertY = invertY;
    texture._compression = compression;
  }
  if (bufferView) {
    const gpuTextureWrapper = texture._hardwareTexture;
    const needConversion = format === 4;
    if (needConversion) {
      bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);
    }
    const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
    this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);
    if (texture.generateMipMaps) {
      this._generateMipmaps(texture, this._uploadEncoder);
    }
  }
  texture.isReady = true;
};
WebGPUEngine.prototype.createRawTexture2DArray = function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0, creationFlags = 0) {
  const source = InternalTextureSource.Raw2DArray;
  const texture = new InternalTexture(this, source);
  texture.baseWidth = width;
  texture.baseHeight = height;
  texture.baseDepth = depth;
  texture.width = width;
  texture.height = height;
  texture.depth = depth;
  texture.format = format;
  texture.type = textureType;
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  texture.is2DArray = true;
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
  }
  this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, creationFlags);
  this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);
  this._internalTexturesCache.push(texture);
  return texture;
};
WebGPUEngine.prototype.updateRawTexture2DArray = function(texture, bufferView, format, invertY, compression = null, textureType = 0) {
  if (!this._doNotHandleContextLost) {
    texture._bufferView = bufferView;
    texture.format = format;
    texture.invertY = invertY;
    texture._compression = compression;
  }
  if (bufferView) {
    const gpuTextureWrapper = texture._hardwareTexture;
    const needConversion = format === 4;
    if (needConversion) {
      bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);
    }
    const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
    this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);
    if (texture.generateMipMaps) {
      this._generateMipmaps(texture, this._uploadEncoder);
    }
  }
  texture.isReady = true;
};
function _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {
  let rgbaData;
  let val1 = 1;
  if (textureType === 1) {
    rgbaData = new Float32Array(width * height * 4);
  } else if (textureType === 2) {
    rgbaData = new Uint16Array(width * height * 4);
    val1 = 15360;
  } else if (textureType === 7) {
    rgbaData = new Uint32Array(width * height * 4);
  } else {
    rgbaData = new Uint8Array(width * height * 4);
  }
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      const index = (y * width + x) * 3;
      const newIndex = (y * width + x) * 4;
      rgbaData[newIndex + 0] = rgbData[index + 0];
      rgbaData[newIndex + 1] = rgbData[index + 1];
      rgbaData[newIndex + 2] = rgbData[index + 2];
      rgbaData[newIndex + 3] = val1;
    }
  }
  return rgbaData;
}

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.readTexture.js
WebGPUEngine.prototype._readTexturePixels = function(texture, width, height, faceIndex = -1, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0) {
  const gpuTextureWrapper = texture._hardwareTexture;
  if (flushRenderer) {
    this.flushFramebuffer();
  }
  return this._textureHelper.readPixels(gpuTextureWrapper.underlyingResource, x, y, width, height, gpuTextureWrapper.format, faceIndex, level, buffer, noDataConversion);
};
WebGPUEngine.prototype._readTexturePixelsSync = function() {
  throw "_readTexturePixelsSync is unsupported in WebGPU!";
};

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuRenderTargetWrapper.js
var WebGPURenderTargetWrapper = class extends RenderTargetWrapper {
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.renderTarget.js
WebGPUEngine.prototype._createHardwareRenderTargetWrapper = function(isMulti, isCube, size) {
  const rtWrapper = new WebGPURenderTargetWrapper(isMulti, isCube, size, this);
  this._renderTargetWrapperCache.push(rtWrapper);
  return rtWrapper;
};
WebGPUEngine.prototype.createRenderTargetTexture = function(size, options) {
  var _a, _b;
  const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);
  const fullOptions = {};
  if (options !== void 0 && typeof options === "object") {
    fullOptions.generateMipMaps = options.generateMipMaps;
    fullOptions.generateDepthBuffer = options.generateDepthBuffer === void 0 ? true : options.generateDepthBuffer;
    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;
    fullOptions.samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
    fullOptions.creationFlags = (_a = options.creationFlags) !== null && _a !== void 0 ? _a : 0;
    fullOptions.noColorAttachment = !!options.noColorAttachment;
    fullOptions.samples = options.samples;
  } else {
    fullOptions.generateMipMaps = options;
    fullOptions.generateDepthBuffer = true;
    fullOptions.generateStencilBuffer = false;
    fullOptions.samplingMode = 3;
    fullOptions.creationFlags = 0;
    fullOptions.noColorAttachment = false;
  }
  const texture = fullOptions.noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget);
  rtWrapper._samples = (_b = fullOptions.samples) !== null && _b !== void 0 ? _b : 1;
  rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
  rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;
  rtWrapper.setTextures(texture);
  if (rtWrapper._generateDepthBuffer || rtWrapper._generateStencilBuffer) {
    rtWrapper.createDepthStencilTexture(0, fullOptions.samplingMode === void 0 || fullOptions.samplingMode === 2 || fullOptions.samplingMode === 2 || fullOptions.samplingMode === 3 || fullOptions.samplingMode === 3 || fullOptions.samplingMode === 5 || fullOptions.samplingMode === 6 || fullOptions.samplingMode === 7 || fullOptions.samplingMode === 11, rtWrapper._generateStencilBuffer, rtWrapper.samples);
  }
  if (texture) {
    if (options !== void 0 && typeof options === "object" && options.createMipMaps && !fullOptions.generateMipMaps) {
      texture.generateMipMaps = true;
    }
    this._textureHelper.createGPUTextureForInternalTexture(texture, void 0, void 0, void 0, fullOptions.creationFlags);
    if (options !== void 0 && typeof options === "object" && options.createMipMaps && !fullOptions.generateMipMaps) {
      texture.generateMipMaps = false;
    }
  }
  return rtWrapper;
};
WebGPUEngine.prototype._createDepthStencilTexture = function(size, options) {
  const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);
  const internalOptions = {
    bilinearFiltering: false,
    comparisonFunction: 0,
    generateStencil: false,
    samples: 1,
    depthTextureFormat: options.generateStencil ? 13 : 14,
    ...options
  };
  internalTexture.format = internalOptions.depthTextureFormat;
  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);
  this._textureHelper.createGPUTextureForInternalTexture(internalTexture);
  this._internalTexturesCache.push(internalTexture);
  return internalTexture;
};
WebGPUEngine.prototype._setupDepthStencilTexture = function(internalTexture, size, generateStencil, bilinearFiltering, comparisonFunction, samples = 1) {
  const width = size.width || size;
  const height = size.height || size;
  const layers = size.layers || 0;
  internalTexture.baseWidth = width;
  internalTexture.baseHeight = height;
  internalTexture.width = width;
  internalTexture.height = height;
  internalTexture.is2DArray = layers > 0;
  internalTexture.depth = layers;
  internalTexture.isReady = true;
  internalTexture.samples = samples;
  internalTexture.generateMipMaps = false;
  internalTexture.samplingMode = bilinearFiltering ? 2 : 1;
  internalTexture.type = 1;
  internalTexture._comparisonFunction = comparisonFunction;
  internalTexture._cachedWrapU = 0;
  internalTexture._cachedWrapV = 0;
};
WebGPUEngine.prototype.updateRenderTargetTextureSampleCount = function(rtWrapper, samples) {
  if (!rtWrapper || !rtWrapper.texture || rtWrapper.samples === samples) {
    return samples;
  }
  samples = Math.min(samples, this.getCaps().maxMSAASamples);
  this._textureHelper.createMSAATexture(rtWrapper.texture, samples);
  if (rtWrapper._depthStencilTexture) {
    this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);
    rtWrapper._depthStencilTexture.samples = samples;
  }
  rtWrapper._samples = samples;
  rtWrapper.texture.samples = samples;
  return samples;
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.renderTargetCube.js
WebGPUEngine.prototype.createRenderTargetCubeTexture = function(size, options) {
  const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);
  const fullOptions = {
    generateMipMaps: true,
    generateDepthBuffer: true,
    generateStencilBuffer: false,
    type: 0,
    samplingMode: 3,
    format: 5,
    samples: 1,
    ...options
  };
  fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;
  rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
  rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer;
  const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);
  texture.width = size;
  texture.height = size;
  texture.depth = 0;
  texture.isReady = true;
  texture.isCube = true;
  texture.samples = fullOptions.samples;
  texture.generateMipMaps = fullOptions.generateMipMaps;
  texture.samplingMode = fullOptions.samplingMode;
  texture.type = fullOptions.type;
  texture.format = fullOptions.format;
  this._internalTexturesCache.push(texture);
  rtWrapper.setTextures(texture);
  if (rtWrapper._generateDepthBuffer || rtWrapper._generateStencilBuffer) {
    rtWrapper.createDepthStencilTexture(0, fullOptions.samplingMode === void 0 || fullOptions.samplingMode === 2 || fullOptions.samplingMode === 2 || fullOptions.samplingMode === 3 || fullOptions.samplingMode === 3 || fullOptions.samplingMode === 5 || fullOptions.samplingMode === 6 || fullOptions.samplingMode === 7 || fullOptions.samplingMode === 11, rtWrapper._generateStencilBuffer, rtWrapper.samples);
  }
  if (options && options.createMipMaps && !fullOptions.generateMipMaps) {
    texture.generateMipMaps = true;
  }
  this._textureHelper.createGPUTextureForInternalTexture(texture);
  if (options && options.createMipMaps && !fullOptions.generateMipMaps) {
    texture.generateMipMaps = false;
  }
  return rtWrapper;
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.textureSampler.js
Effect.prototype.setTextureSampler = function(name137, sampler) {
  this._engine.setTextureSampler(name137, sampler);
};
WebGPUEngine.prototype.setTextureSampler = function(name137, sampler) {
  var _a;
  (_a = this._currentMaterialContext) === null || _a === void 0 ? void 0 : _a.setSampler(name137, sampler);
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.storageBuffer.js
Effect.prototype.setStorageBuffer = function(name137, buffer) {
  this._engine.setStorageBuffer(name137, buffer);
};
WebGPUEngine.prototype.createStorageBuffer = function(data, creationFlags) {
  return this._createBuffer(data, creationFlags | 32);
};
WebGPUEngine.prototype.updateStorageBuffer = function(buffer, data, byteOffset, byteLength) {
  const dataBuffer = buffer;
  if (byteOffset === void 0) {
    byteOffset = 0;
  }
  let view;
  if (byteLength === void 0) {
    if (data instanceof Array) {
      view = new Float32Array(data);
    } else if (data instanceof ArrayBuffer) {
      view = new Uint8Array(data);
    } else {
      view = data;
    }
    byteLength = view.byteLength;
  } else {
    if (data instanceof Array) {
      view = new Float32Array(data);
    } else if (data instanceof ArrayBuffer) {
      view = new Uint8Array(data);
    } else {
      view = data;
    }
  }
  this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);
};
WebGPUEngine.prototype.readFromStorageBuffer = function(storageBuffer, offset, size, buffer) {
  size = size || storageBuffer.capacity;
  const gpuBuffer = this._bufferManager.createRawBuffer(size, BufferUsage.MapRead | BufferUsage.CopyDst);
  this._renderTargetEncoder.copyBufferToBuffer(storageBuffer.underlyingResource, offset !== null && offset !== void 0 ? offset : 0, gpuBuffer, 0, size);
  return new Promise((resolve, reject) => {
    this.onEndFrameObservable.addOnce(() => {
      gpuBuffer.mapAsync(MapMode.Read, 0, size).then(() => {
        const copyArrayBuffer = gpuBuffer.getMappedRange(0, size);
        let data = buffer;
        if (data === void 0) {
          data = new Uint8Array(size);
          data.set(new Uint8Array(copyArrayBuffer));
        } else {
          const ctor = data.constructor;
          data = new ctor(data.buffer);
          data.set(new ctor(copyArrayBuffer));
        }
        gpuBuffer.unmap();
        this._bufferManager.releaseBuffer(gpuBuffer);
        resolve(data);
      }, (reason) => reject(reason));
    });
  });
};
WebGPUEngine.prototype.setStorageBuffer = function(name137, buffer) {
  var _a, _b;
  (_a = this._currentDrawContext) === null || _a === void 0 ? void 0 : _a.setBuffer(name137, (_b = buffer === null || buffer === void 0 ? void 0 : buffer.getBuffer()) !== null && _b !== void 0 ? _b : null);
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.uniformBuffer.js
WebGPUEngine.prototype.createUniformBuffer = function(elements) {
  let view;
  if (elements instanceof Array) {
    view = new Float32Array(elements);
  } else {
    view = elements;
  }
  const dataBuffer = this._bufferManager.createBuffer(view, BufferUsage.Uniform | BufferUsage.CopyDst);
  return dataBuffer;
};
WebGPUEngine.prototype.createDynamicUniformBuffer = function(elements) {
  return this.createUniformBuffer(elements);
};
WebGPUEngine.prototype.updateUniformBuffer = function(uniformBuffer, elements, offset, count) {
  if (offset === void 0) {
    offset = 0;
  }
  const dataBuffer = uniformBuffer;
  let view;
  if (count === void 0) {
    if (elements instanceof Float32Array) {
      view = elements;
    } else {
      view = new Float32Array(elements);
    }
    count = view.byteLength;
  } else {
    if (elements instanceof Float32Array) {
      view = elements;
    } else {
      view = new Float32Array(elements);
    }
  }
  this._bufferManager.setSubData(dataBuffer, offset, view, 0, count);
};
WebGPUEngine.prototype.bindUniformBufferBase = function(buffer, location, name137) {
  this._currentDrawContext.setBuffer(name137, buffer);
};
WebGPUEngine.prototype.bindUniformBlock = function() {
};

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.videoTexture.js
function IsExternalTexture(texture) {
  return texture && texture.underlyingResource !== void 0 ? true : false;
}
WebGPUEngine.prototype.updateVideoTexture = function(texture, video, invertY) {
  var _a;
  if (!texture || texture._isDisabled) {
    return;
  }
  if (this._videoTextureSupported === void 0) {
    this._videoTextureSupported = true;
  }
  let gpuTextureWrapper = texture._hardwareTexture;
  if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {
    gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);
  }
  if (IsExternalTexture(video)) {
    this._textureHelper.copyVideoToTexture(video, texture, gpuTextureWrapper.format, !invertY);
    if (texture.generateMipMaps) {
      this._generateMipmaps(texture, this._uploadEncoder);
    }
    texture.isReady = true;
  } else if (video) {
    this.createImageBitmap(video).then((bitmap) => {
      this._textureHelper.updateTexture(bitmap, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, !invertY, false, 0, 0);
      if (texture.generateMipMaps) {
        this._generateMipmaps(texture, this._uploadEncoder);
      }
      texture.isReady = true;
    }).catch(() => {
      texture.isReady = true;
    });
  }
};

// node_modules/@babylonjs/core/Engines/engineFactory.js
var EngineFactory = class {
  static CreateAsync(canvas, options) {
    return WebGPUEngine.IsSupportedAsync.then((supported) => {
      if (supported) {
        return WebGPUEngine.CreateAsync(canvas, options);
      } else if (Engine.IsSupported) {
        return new Promise((resolve) => {
          resolve(new Engine(canvas, void 0, options));
        });
      }
      return new Promise((resolve) => {
        resolve(new NullEngine(options));
      });
    });
  }
};

// node_modules/@babylonjs/core/Gamepads/Controllers/daydreamController.js
var DaydreamController = class extends WebVRController {
  constructor(vrGamepad) {
    super(vrGamepad);
    this.controllerType = PoseEnabledControllerType.DAYDREAM;
  }
  initControllerMesh(scene, meshLoaded) {
    SceneLoader.ImportMesh("", DaydreamController.MODEL_BASE_URL, DaydreamController.MODEL_FILENAME, scene, (newMeshes) => {
      this._defaultModel = newMeshes[1];
      this.attachToMesh(this._defaultModel);
      if (meshLoaded) {
        meshLoaded(this._defaultModel);
      }
    });
  }
  _handleButtonChange(buttonIdx, state) {
    if (buttonIdx === 0) {
      const observable = this.onTriggerStateChangedObservable;
      if (observable) {
        observable.notifyObservers(state);
      }
    } else {
      Logger.Warn(`Unrecognized Daydream button index: ${buttonIdx}`);
    }
  }
};
DaydreamController.MODEL_BASE_URL = "https://controllers.babylonjs.com/generic/";
DaydreamController.MODEL_FILENAME = "generic.babylon";
DaydreamController.GAMEPAD_ID_PREFIX = "Daydream";
PoseEnabledControllerHelper._ControllerFactories.push({
  canCreate: (gamepadInfo) => {
    return gamepadInfo.id.indexOf(DaydreamController.GAMEPAD_ID_PREFIX) === 0;
  },
  create: (gamepadInfo) => {
    return new DaydreamController(gamepadInfo);
  }
});

// node_modules/@babylonjs/core/Gamepads/Controllers/gearVRController.js
var GearVRController = class extends WebVRController {
  constructor(vrGamepad) {
    super(vrGamepad);
    this._buttonIndexToObservableNameMap = [
      "onPadStateChangedObservable",
      "onTriggerStateChangedObservable"
    ];
    this.controllerType = PoseEnabledControllerType.GEAR_VR;
    this._calculatedPosition = new Vector3(this.hand == "left" ? -0.15 : 0.15, -0.5, 0.25);
    this._disableTrackPosition(this._calculatedPosition);
  }
  initControllerMesh(scene, meshLoaded) {
    SceneLoader.ImportMesh("", GearVRController.MODEL_BASE_URL, GearVRController.MODEL_FILENAME, scene, (newMeshes) => {
      const mesh = new Mesh("", scene);
      newMeshes[1].parent = mesh;
      newMeshes[1].position.z = -0.15;
      this._defaultModel = mesh;
      this.attachToMesh(this._defaultModel);
      if (meshLoaded) {
        meshLoaded(this._defaultModel);
      }
    });
  }
  _handleButtonChange(buttonIdx, state) {
    if (buttonIdx < this._buttonIndexToObservableNameMap.length) {
      const observableName = this._buttonIndexToObservableNameMap[buttonIdx];
      const observable = this[observableName];
      if (observable) {
        observable.notifyObservers(state);
      }
    }
  }
};
GearVRController.MODEL_BASE_URL = "https://controllers.babylonjs.com/generic/";
GearVRController.MODEL_FILENAME = "generic.babylon";
GearVRController.GAMEPAD_ID_PREFIX = "Gear VR";
PoseEnabledControllerHelper._ControllerFactories.push({
  canCreate: (gamepadInfo) => {
    return gamepadInfo.id.indexOf(GearVRController.GAMEPAD_ID_PREFIX) === 0 || gamepadInfo.id.indexOf("Oculus Go") !== -1 || gamepadInfo.id.indexOf("Vive Focus") !== -1;
  },
  create: (gamepadInfo) => {
    return new GearVRController(gamepadInfo);
  }
});

// node_modules/@babylonjs/core/Gamepads/Controllers/genericController.js
var GenericController = class extends WebVRController {
  constructor(vrGamepad) {
    super(vrGamepad);
  }
  initControllerMesh(scene, meshLoaded) {
    SceneLoader.ImportMesh("", GenericController.MODEL_BASE_URL, GenericController.MODEL_FILENAME, scene, (newMeshes) => {
      this._defaultModel = newMeshes[1];
      this.attachToMesh(this._defaultModel);
      if (meshLoaded) {
        meshLoaded(this._defaultModel);
      }
    });
  }
  _handleButtonChange(buttonIdx, state) {
    console.log("Button id: " + buttonIdx + "state: ");
    console.dir(state);
  }
};
GenericController.MODEL_BASE_URL = "https://controllers.babylonjs.com/generic/";
GenericController.MODEL_FILENAME = "generic.babylon";
PoseEnabledControllerHelper._DefaultControllerFactory = (gamepadInfo) => new GenericController(gamepadInfo);

// node_modules/@babylonjs/core/Gamepads/Controllers/oculusTouchController.js
var OculusTouchController = class extends WebVRController {
  constructor(vrGamepad) {
    super(vrGamepad);
    this.onSecondaryTriggerStateChangedObservable = new Observable();
    this.onThumbRestChangedObservable = new Observable();
    this.controllerType = PoseEnabledControllerType.OCULUS;
  }
  initControllerMesh(scene, meshLoaded) {
    let meshName;
    if (this.hand === "left") {
      meshName = OculusTouchController.MODEL_LEFT_FILENAME;
    } else {
      meshName = OculusTouchController.MODEL_RIGHT_FILENAME;
    }
    SceneLoader.ImportMesh("", OculusTouchController._IsQuest ? OculusTouchController.QUEST_MODEL_BASE_URL : OculusTouchController.MODEL_BASE_URL, meshName, scene, (newMeshes) => {
      this._defaultModel = OculusTouchController._IsQuest ? newMeshes[0] : newMeshes[1];
      this.attachToMesh(this._defaultModel);
      if (meshLoaded) {
        meshLoaded(this._defaultModel);
      }
    });
  }
  get onAButtonStateChangedObservable() {
    if (this.hand === "right") {
      return this.onMainButtonStateChangedObservable;
    } else {
      throw new Error("No A button on left hand");
    }
  }
  get onBButtonStateChangedObservable() {
    if (this.hand === "right") {
      return this.onSecondaryButtonStateChangedObservable;
    } else {
      throw new Error("No B button on left hand");
    }
  }
  get onXButtonStateChangedObservable() {
    if (this.hand === "left") {
      return this.onMainButtonStateChangedObservable;
    } else {
      throw new Error("No X button on right hand");
    }
  }
  get onYButtonStateChangedObservable() {
    if (this.hand === "left") {
      return this.onSecondaryButtonStateChangedObservable;
    } else {
      throw new Error("No Y button on right hand");
    }
  }
  _handleButtonChange(buttonIdx, state) {
    const notifyObject = state;
    const triggerDirection = this.hand === "right" ? -1 : 1;
    switch (buttonIdx) {
      case 0:
        this.onPadStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 1:
        if (!OculusTouchController._IsQuest && this._defaultModel) {
          this._defaultModel.getChildren()[3].rotation.x = -notifyObject.value * 0.2;
          this._defaultModel.getChildren()[3].position.y = -notifyObject.value * 5e-3;
          this._defaultModel.getChildren()[3].position.z = -notifyObject.value * 5e-3;
        }
        this.onTriggerStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 2:
        if (!OculusTouchController._IsQuest && this._defaultModel) {
          this._defaultModel.getChildren()[4].position.x = triggerDirection * notifyObject.value * 35e-4;
        }
        this.onSecondaryTriggerStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 3:
        if (!OculusTouchController._IsQuest && this._defaultModel) {
          if (notifyObject.pressed) {
            this._defaultModel.getChildren()[1].position.y = -1e-3;
          } else {
            this._defaultModel.getChildren()[1].position.y = 0;
          }
        }
        this.onMainButtonStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 4:
        if (!OculusTouchController._IsQuest && this._defaultModel) {
          if (notifyObject.pressed) {
            this._defaultModel.getChildren()[2].position.y = -1e-3;
          } else {
            this._defaultModel.getChildren()[2].position.y = 0;
          }
        }
        this.onSecondaryButtonStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 5:
        this.onThumbRestChangedObservable.notifyObservers(notifyObject);
        return;
    }
  }
};
OculusTouchController.MODEL_BASE_URL = "https://controllers.babylonjs.com/oculus/";
OculusTouchController.MODEL_LEFT_FILENAME = "left.babylon";
OculusTouchController.MODEL_RIGHT_FILENAME = "right.babylon";
OculusTouchController.QUEST_MODEL_BASE_URL = "https://controllers.babylonjs.com/oculusQuest/";
OculusTouchController._IsQuest = false;
PoseEnabledControllerHelper._ControllerFactories.push({
  canCreate: (gamepadInfo) => {
    if (EngineStore.LastCreatedEngine && EngineStore.LastCreatedEngine._vrDisplay && EngineStore.LastCreatedEngine._vrDisplay.displayName === "Oculus Quest") {
      OculusTouchController._IsQuest = true;
    }
    return gamepadInfo.id.indexOf("Oculus Touch") !== -1;
  },
  create: (gamepadInfo) => {
    return new OculusTouchController(gamepadInfo);
  }
});

// node_modules/@babylonjs/core/Gamepads/Controllers/viveController.js
var ViveController = class extends WebVRController {
  constructor(vrGamepad) {
    super(vrGamepad);
    this.controllerType = PoseEnabledControllerType.VIVE;
    this._invertLeftStickY = true;
  }
  initControllerMesh(scene, meshLoaded) {
    SceneLoader.ImportMesh("", ViveController.MODEL_BASE_URL, ViveController.MODEL_FILENAME, scene, (newMeshes) => {
      this._defaultModel = newMeshes[1];
      this.attachToMesh(this._defaultModel);
      if (meshLoaded) {
        meshLoaded(this._defaultModel);
      }
    });
  }
  get onLeftButtonStateChangedObservable() {
    return this.onMainButtonStateChangedObservable;
  }
  get onRightButtonStateChangedObservable() {
    return this.onMainButtonStateChangedObservable;
  }
  get onMenuButtonStateChangedObservable() {
    return this.onSecondaryButtonStateChangedObservable;
  }
  _handleButtonChange(buttonIdx, state) {
    const notifyObject = state;
    switch (buttonIdx) {
      case 0:
        this.onPadStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 1:
        if (this._defaultModel) {
          this._defaultModel.getChildren()[6].rotation.x = -notifyObject.value * 0.15;
        }
        this.onTriggerStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 2:
        this.onMainButtonStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 3:
        if (this._defaultModel) {
          if (notifyObject.pressed) {
            this._defaultModel.getChildren()[2].position.y = -1e-3;
          } else {
            this._defaultModel.getChildren()[2].position.y = 0;
          }
        }
        this.onSecondaryButtonStateChangedObservable.notifyObservers(notifyObject);
        return;
    }
  }
};
ViveController.MODEL_BASE_URL = "https://controllers.babylonjs.com/vive/";
ViveController.MODEL_FILENAME = "wand.babylon";
PoseEnabledControllerHelper._ControllerFactories.push({
  canCreate: (gamepadInfo) => {
    return gamepadInfo.id.toLowerCase().indexOf("openvr") !== -1;
  },
  create: (gamepadInfo) => {
    return new ViveController(gamepadInfo);
  }
});

// node_modules/@babylonjs/core/Gamepads/Controllers/windowsMotionController.js
var LoadedMeshInfo = class {
  constructor() {
    this.buttonMeshes = {};
    this.axisMeshes = {};
  }
};
var WindowsMotionController = class extends WebVRController {
  constructor(vrGamepad) {
    super(vrGamepad);
    this._mapping = {
      buttons: ["thumbstick", "trigger", "grip", "menu", "trackpad"],
      buttonMeshNames: {
        trigger: "SELECT",
        menu: "MENU",
        grip: "GRASP",
        thumbstick: "THUMBSTICK_PRESS",
        trackpad: "TOUCHPAD_PRESS"
      },
      buttonObservableNames: {
        trigger: "onTriggerStateChangedObservable",
        menu: "onSecondaryButtonStateChangedObservable",
        grip: "onMainButtonStateChangedObservable",
        thumbstick: "onPadStateChangedObservable",
        trackpad: "onTrackpadChangedObservable"
      },
      axisMeshNames: ["THUMBSTICK_X", "THUMBSTICK_Y", "TOUCHPAD_TOUCH_X", "TOUCHPAD_TOUCH_Y"],
      pointingPoseMeshName: PoseEnabledController.POINTING_POSE
    };
    this.onTrackpadChangedObservable = new Observable();
    this.onTrackpadValuesChangedObservable = new Observable();
    this.trackpad = { x: 0, y: 0 };
    this.controllerType = PoseEnabledControllerType.WINDOWS;
    this._loadedMeshInfo = null;
  }
  get onTriggerButtonStateChangedObservable() {
    return this.onTriggerStateChangedObservable;
  }
  get onMenuButtonStateChangedObservable() {
    return this.onSecondaryButtonStateChangedObservable;
  }
  get onGripButtonStateChangedObservable() {
    return this.onMainButtonStateChangedObservable;
  }
  get onThumbstickButtonStateChangedObservable() {
    return this.onPadStateChangedObservable;
  }
  get onTouchpadButtonStateChangedObservable() {
    return this.onTrackpadChangedObservable;
  }
  get onTouchpadValuesChangedObservable() {
    return this.onTrackpadValuesChangedObservable;
  }
  _updateTrackpad() {
    if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.trackpad.x || this.browserGamepad.axes[3] != this.trackpad.y)) {
      this.trackpad.x = this.browserGamepad["axes"][this._mapping.axisMeshNames.indexOf("TOUCHPAD_TOUCH_X")];
      this.trackpad.y = this.browserGamepad["axes"][this._mapping.axisMeshNames.indexOf("TOUCHPAD_TOUCH_Y")];
      this.onTrackpadValuesChangedObservable.notifyObservers(this.trackpad);
    }
  }
  update() {
    super.update();
    if (this.browserGamepad.axes) {
      this._updateTrackpad();
      if (this._loadedMeshInfo) {
        for (let axis = 0; axis < this._mapping.axisMeshNames.length; axis++) {
          this._lerpAxisTransform(axis, this.browserGamepad.axes[axis]);
        }
      }
    }
  }
  _handleButtonChange(buttonIdx, state) {
    const buttonName = this._mapping.buttons[buttonIdx];
    if (!buttonName) {
      return;
    }
    this._updateTrackpad();
    const observable = this[this._mapping.buttonObservableNames[buttonName]];
    if (observable) {
      observable.notifyObservers(state);
    }
    this._lerpButtonTransform(buttonName, state.value);
  }
  _lerpButtonTransform(buttonName, buttonValue) {
    if (!this._loadedMeshInfo) {
      return;
    }
    const meshInfo = this._loadedMeshInfo.buttonMeshes[buttonName];
    if (!meshInfo || !meshInfo.unpressed.rotationQuaternion || !meshInfo.pressed.rotationQuaternion || !meshInfo.value.rotationQuaternion) {
      return;
    }
    Quaternion.SlerpToRef(meshInfo.unpressed.rotationQuaternion, meshInfo.pressed.rotationQuaternion, buttonValue, meshInfo.value.rotationQuaternion);
    Vector3.LerpToRef(meshInfo.unpressed.position, meshInfo.pressed.position, buttonValue, meshInfo.value.position);
  }
  _lerpAxisTransform(axis, axisValue) {
    if (!this._loadedMeshInfo) {
      return;
    }
    const meshInfo = this._loadedMeshInfo.axisMeshes[axis];
    if (!meshInfo) {
      return;
    }
    if (!meshInfo.min.rotationQuaternion || !meshInfo.max.rotationQuaternion || !meshInfo.value.rotationQuaternion) {
      return;
    }
    const lerpValue = axisValue * 0.5 + 0.5;
    Quaternion.SlerpToRef(meshInfo.min.rotationQuaternion, meshInfo.max.rotationQuaternion, lerpValue, meshInfo.value.rotationQuaternion);
    Vector3.LerpToRef(meshInfo.min.position, meshInfo.max.position, lerpValue, meshInfo.value.position);
  }
  initControllerMesh(scene, meshLoaded, forceDefault = false) {
    let path;
    let filename;
    if (SceneLoader.IsPluginForExtensionAvailable(".glb")) {
      let device = "default";
      if (this.id && !forceDefault) {
        const match = this.id.match(WindowsMotionController.GAMEPAD_ID_PATTERN);
        device = match && match[0] || device;
      }
      if (this.hand === "left") {
        filename = WindowsMotionController.MODEL_LEFT_FILENAME;
      } else {
        filename = WindowsMotionController.MODEL_RIGHT_FILENAME;
      }
      path = WindowsMotionController.MODEL_BASE_URL + device + "/";
    } else {
      Logger.Warn("You need to reference GLTF loader to load Windows Motion Controllers model. Falling back to generic models");
      path = GenericController.MODEL_BASE_URL;
      filename = GenericController.MODEL_FILENAME;
    }
    SceneLoader.ImportMesh("", path, filename, scene, (meshes) => {
      this._loadedMeshInfo = this._processModel(scene, meshes);
      if (!this._loadedMeshInfo) {
        return;
      }
      this._defaultModel = this._loadedMeshInfo.rootNode;
      this.attachToMesh(this._defaultModel);
      if (meshLoaded) {
        meshLoaded(this._defaultModel);
      }
    }, null, (scene2, message) => {
      Logger.Log(message);
      Logger.Warn("Failed to retrieve controller model from the remote server: " + path + filename);
      if (!forceDefault) {
        this.initControllerMesh(scene2, meshLoaded, true);
      }
    });
  }
  _processModel(scene, meshes) {
    let loadedMeshInfo = null;
    const parentMesh = new Mesh(this.id + " " + this.hand, scene);
    let childMesh = null;
    for (let i = 0; i < meshes.length; i++) {
      const mesh = meshes[i];
      if (!mesh.parent) {
        mesh.isPickable = false;
        childMesh = mesh;
        break;
      }
    }
    if (childMesh) {
      childMesh.setParent(parentMesh);
      loadedMeshInfo = this._createMeshInfo(parentMesh);
    } else {
      Logger.Warn("Could not find root node in model file.");
    }
    return loadedMeshInfo;
  }
  _createMeshInfo(rootNode) {
    const loadedMeshInfo = new LoadedMeshInfo();
    let i;
    loadedMeshInfo.rootNode = rootNode;
    loadedMeshInfo.buttonMeshes = {};
    loadedMeshInfo.axisMeshes = {};
    for (i = 0; i < this._mapping.buttons.length; i++) {
      const buttonMeshName = this._mapping.buttonMeshNames[this._mapping.buttons[i]];
      if (!buttonMeshName) {
        Logger.Log("Skipping unknown button at index: " + i + " with mapped name: " + this._mapping.buttons[i]);
        continue;
      }
      const buttonMesh = getChildByName(rootNode, buttonMeshName);
      if (!buttonMesh) {
        Logger.Warn("Missing button mesh with name: " + buttonMeshName);
        continue;
      }
      const buttonMeshInfo = {
        index: i,
        value: getImmediateChildByName(buttonMesh, "VALUE"),
        pressed: getImmediateChildByName(buttonMesh, "PRESSED"),
        unpressed: getImmediateChildByName(buttonMesh, "UNPRESSED")
      };
      if (buttonMeshInfo.value && buttonMeshInfo.pressed && buttonMeshInfo.unpressed) {
        loadedMeshInfo.buttonMeshes[this._mapping.buttons[i]] = buttonMeshInfo;
      } else {
        Logger.Warn("Missing button submesh under mesh with name: " + buttonMeshName + "(VALUE: " + !!buttonMeshInfo.value + ", PRESSED: " + !!buttonMeshInfo.pressed + ", UNPRESSED:" + !!buttonMeshInfo.unpressed + ")");
      }
    }
    for (i = 0; i < this._mapping.axisMeshNames.length; i++) {
      const axisMeshName = this._mapping.axisMeshNames[i];
      if (!axisMeshName) {
        Logger.Log("Skipping unknown axis at index: " + i);
        continue;
      }
      const axisMesh = getChildByName(rootNode, axisMeshName);
      if (!axisMesh) {
        Logger.Warn("Missing axis mesh with name: " + axisMeshName);
        continue;
      }
      const axisMeshInfo = {
        index: i,
        value: getImmediateChildByName(axisMesh, "VALUE"),
        min: getImmediateChildByName(axisMesh, "MIN"),
        max: getImmediateChildByName(axisMesh, "MAX")
      };
      if (axisMeshInfo.value && axisMeshInfo.min && axisMeshInfo.max) {
        loadedMeshInfo.axisMeshes[i] = axisMeshInfo;
      } else {
        Logger.Warn("Missing axis submesh under mesh with name: " + axisMeshName + "(VALUE: " + !!axisMeshInfo.value + ", MIN: " + !!axisMeshInfo.min + ", MAX:" + !!axisMeshInfo.max + ")");
      }
    }
    loadedMeshInfo.pointingPoseNode = getChildByName(rootNode, this._mapping.pointingPoseMeshName);
    if (!loadedMeshInfo.pointingPoseNode) {
      Logger.Warn("Missing pointing pose mesh with name: " + this._mapping.pointingPoseMeshName);
    } else {
      this._pointingPoseNode = loadedMeshInfo.pointingPoseNode;
    }
    return loadedMeshInfo;
    function getChildByName(node, name137) {
      return node.getChildren((n) => n.name === name137, false)[0];
    }
    function getImmediateChildByName(node, name137) {
      return node.getChildren((n) => n.name == name137, true)[0];
    }
  }
  getForwardRay(length = 100) {
    if (!(this._loadedMeshInfo && this._loadedMeshInfo.pointingPoseNode)) {
      return super.getForwardRay(length);
    }
    const m = this._loadedMeshInfo.pointingPoseNode.getWorldMatrix();
    const origin = m.getTranslation();
    const forward = new Vector3(0, 0, -1);
    const forwardWorld = Vector3.TransformNormal(forward, m);
    const direction = Vector3.Normalize(forwardWorld);
    return new Ray(origin, direction, length);
  }
  dispose() {
    super.dispose();
    this.onTrackpadChangedObservable.clear();
    this.onTrackpadValuesChangedObservable.clear();
  }
};
WindowsMotionController.MODEL_BASE_URL = "https://controllers.babylonjs.com/microsoft/";
WindowsMotionController.MODEL_LEFT_FILENAME = "left.glb";
WindowsMotionController.MODEL_RIGHT_FILENAME = "right.glb";
WindowsMotionController.GAMEPAD_ID_PREFIX = "Spatial Controller (Spatial Interaction Source) ";
WindowsMotionController.GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/;
var XRWindowsMotionController = class extends WindowsMotionController {
  constructor(gamepadInfo) {
    super(gamepadInfo);
    this._mapping = {
      buttons: ["trigger", "grip", "trackpad", "thumbstick", "menu"],
      buttonMeshNames: {
        trigger: "SELECT",
        menu: "MENU",
        grip: "GRASP",
        thumbstick: "THUMBSTICK_PRESS",
        trackpad: "TOUCHPAD_PRESS"
      },
      buttonObservableNames: {
        trigger: "onTriggerStateChangedObservable",
        menu: "onSecondaryButtonStateChangedObservable",
        grip: "onMainButtonStateChangedObservable",
        thumbstick: "onThumbstickStateChangedObservable",
        trackpad: "onTrackpadChangedObservable"
      },
      axisMeshNames: ["TOUCHPAD_TOUCH_X", "TOUCHPAD_TOUCH_Y", "THUMBSTICK_X", "THUMBSTICK_Y"],
      pointingPoseMeshName: PoseEnabledController.POINTING_POSE
    };
    this.thumbstickValues = { x: 0, y: 0 };
    this.onThumbstickStateChangedObservable = new Observable();
    this.onThumbstickValuesChangedObservable = new Observable();
    this.onTrackpadChangedObservable = this.onPadStateChangedObservable;
    this.onTrackpadValuesChangedObservable = this.onPadValuesChangedObservable;
  }
  get onThumbstickButtonStateChangedObservable() {
    return this.onThumbstickStateChangedObservable;
  }
  _updateTrackpad() {
    if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.thumbstickValues.x || this.browserGamepad.axes[3] != this.thumbstickValues.y)) {
      this.trackpad.x = this.browserGamepad["axes"][2];
      this.trackpad.y = this.browserGamepad["axes"][3];
      this.onThumbstickValuesChangedObservable.notifyObservers(this.trackpad);
    }
  }
  dispose() {
    super.dispose();
    this.onThumbstickStateChangedObservable.clear();
    this.onThumbstickValuesChangedObservable.clear();
  }
};
PoseEnabledControllerHelper._ControllerFactories.push({
  canCreate: (gamepadInfo) => {
    return gamepadInfo.id.indexOf(WindowsMotionController.GAMEPAD_ID_PREFIX) === 0;
  },
  create: (gamepadInfo) => {
    return new WindowsMotionController(gamepadInfo);
  }
});

// node_modules/@babylonjs/core/Gizmos/axisScaleGizmo.js
var AxisScaleGizmo = class extends Gizmo {
  constructor(dragAxis, color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, parent = null, thickness = 1) {
    var _a, _b, _c, _d, _e, _f, _g;
    super(gizmoLayer);
    this._pointerObserver = null;
    this.snapDistance = 0;
    this.onSnapObservable = new Observable();
    this.uniformScaling = false;
    this.sensitivity = 1;
    this.dragScale = 1;
    this._isEnabled = true;
    this._parent = null;
    this._dragging = false;
    this._tmpVector = new Vector3(0, 0, 0);
    this._parent = parent;
    this._coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    this._coloredMaterial.diffuseColor = color;
    this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));
    this._hoverMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    this._hoverMaterial.diffuseColor = Color3.Yellow();
    this._disableMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    this._disableMaterial.diffuseColor = Color3.Gray();
    this._disableMaterial.alpha = 0.4;
    this._gizmoMesh = new Mesh("axis", gizmoLayer.utilityLayerScene);
    const { arrowMesh, arrowTail } = this._createGizmoMesh(this._gizmoMesh, thickness);
    const collider = this._createGizmoMesh(this._gizmoMesh, thickness + 4, true);
    this._gizmoMesh.lookAt(this._rootMesh.position.add(dragAxis));
    this._rootMesh.addChild(this._gizmoMesh, Gizmo.PreserveScaling);
    this._gizmoMesh.scaling.scaleInPlace(1 / 3);
    const nodePosition = arrowMesh.position.clone();
    const linePosition = arrowTail.position.clone();
    const lineScale = arrowTail.scaling.clone();
    const increaseGizmoMesh = (dragDistance) => {
      const dragStrength = dragDistance * (3 / this._rootMesh.scaling.length()) * 6;
      arrowMesh.position.z += dragStrength / 3.5;
      arrowTail.scaling.y += dragStrength;
      this.dragScale = arrowTail.scaling.y;
      arrowTail.position.z = arrowMesh.position.z / 2;
    };
    const resetGizmoMesh = () => {
      arrowMesh.position.set(nodePosition.x, nodePosition.y, nodePosition.z);
      arrowTail.position.set(linePosition.x, linePosition.y, linePosition.z);
      arrowTail.scaling.set(lineScale.x, lineScale.y, lineScale.z);
      this.dragScale = arrowTail.scaling.y;
      this._dragging = false;
    };
    this.dragBehavior = new PointerDragBehavior({ dragAxis });
    this.dragBehavior.moveAttached = false;
    this.dragBehavior.updateDragPlane = false;
    this._rootMesh.addBehavior(this.dragBehavior);
    let currentSnapDragDistance = 0;
    const tmpSnapEvent = { snapDistance: 0 };
    this.dragBehavior.onDragObservable.add((event) => {
      if (this.attachedNode) {
        this._handlePivot();
        const dragStrength = this.sensitivity * event.dragDistance * (this.scaleRatio * 3 / this._rootMesh.scaling.length());
        const tmpVector = this._tmpVector;
        let snapped = false;
        let dragSteps = 0;
        if (this.uniformScaling) {
          tmpVector.setAll(0.57735);
        } else {
          tmpVector.copyFrom(dragAxis);
        }
        if (this.snapDistance == 0) {
          tmpVector.scaleToRef(dragStrength, tmpVector);
        } else {
          currentSnapDragDistance += dragStrength;
          if (Math.abs(currentSnapDragDistance) > this.snapDistance) {
            dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);
            if (currentSnapDragDistance < 0) {
              dragSteps *= -1;
            }
            currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;
            tmpVector.scaleToRef(this.snapDistance * dragSteps, tmpVector);
            snapped = true;
          } else {
            tmpVector.scaleInPlace(0);
          }
        }
        Matrix.ScalingToRef(1 + tmpVector.x, 1 + tmpVector.y, 1 + tmpVector.z, TmpVectors.Matrix[2]);
        TmpVectors.Matrix[2].multiplyToRef(this.attachedNode.getWorldMatrix(), TmpVectors.Matrix[1]);
        const transformNode = this.attachedNode._isMesh ? this.attachedNode : void 0;
        TmpVectors.Matrix[1].decompose(TmpVectors.Vector3[1], void 0, void 0, Gizmo.PreserveScaling ? transformNode : void 0);
        const maxScale = 1e5;
        if (Math.abs(TmpVectors.Vector3[1].x) < maxScale && Math.abs(TmpVectors.Vector3[1].y) < maxScale && Math.abs(TmpVectors.Vector3[1].z) < maxScale) {
          this.attachedNode.getWorldMatrix().copyFrom(TmpVectors.Matrix[1]);
        }
        if (snapped) {
          tmpSnapEvent.snapDistance = this.snapDistance * dragSteps;
          this.onSnapObservable.notifyObservers(tmpSnapEvent);
        }
        this._matrixChanged();
      }
    });
    this.dragBehavior.onDragStartObservable.add(() => {
      this._dragging = true;
    });
    this.dragBehavior.onDragObservable.add((e) => increaseGizmoMesh(e.dragDistance));
    this.dragBehavior.onDragEndObservable.add(resetGizmoMesh);
    (_c = (_b = (_a = parent === null || parent === void 0 ? void 0 : parent.uniformScaleGizmo) === null || _a === void 0 ? void 0 : _a.dragBehavior) === null || _b === void 0 ? void 0 : _b.onDragObservable) === null || _c === void 0 ? void 0 : _c.add((e) => increaseGizmoMesh(e.delta.y));
    (_f = (_e = (_d = parent === null || parent === void 0 ? void 0 : parent.uniformScaleGizmo) === null || _d === void 0 ? void 0 : _d.dragBehavior) === null || _e === void 0 ? void 0 : _e.onDragEndObservable) === null || _f === void 0 ? void 0 : _f.add(resetGizmoMesh);
    const cache = {
      gizmoMeshes: [arrowMesh, arrowTail],
      colliderMeshes: [collider.arrowMesh, collider.arrowTail],
      material: this._coloredMaterial,
      hoverMaterial: this._hoverMaterial,
      disableMaterial: this._disableMaterial,
      active: false,
      dragBehavior: this.dragBehavior
    };
    (_g = this._parent) === null || _g === void 0 ? void 0 : _g.addToAxisCache(this._gizmoMesh, cache);
    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
      var _a2;
      if (this._customMeshSet) {
        return;
      }
      this._isHovered = !!(cache.colliderMeshes.indexOf((_a2 = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _a2 === void 0 ? void 0 : _a2.pickedMesh) != -1);
      if (!this._parent) {
        const material = this.dragBehavior.enabled ? this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial : this._disableMaterial;
        this._setGizmoMeshMaterial(cache.gizmoMeshes, material);
      }
    });
    this.dragBehavior.onEnabledObservable.add((newState) => {
      this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? this._coloredMaterial : this._disableMaterial);
    });
    const light = gizmoLayer._getSharedGizmoLight();
    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes());
  }
  get coloredMaterial() {
    return this._coloredMaterial;
  }
  get hoverMaterial() {
    return this._hoverMaterial;
  }
  get disableMaterial() {
    return this._disableMaterial;
  }
  _createGizmoMesh(parentMesh, thickness, isCollider = false) {
    const arrowMesh = CreateBox("yPosMesh", { size: 0.4 * (1 + (thickness - 1) / 4) }, this.gizmoLayer.utilityLayerScene);
    const arrowTail = CreateCylinder("cylinder", { diameterTop: 5e-3 * thickness, height: 0.275, diameterBottom: 5e-3 * thickness, tessellation: 96 }, this.gizmoLayer.utilityLayerScene);
    arrowMesh.scaling.scaleInPlace(0.1);
    arrowMesh.material = this._coloredMaterial;
    arrowMesh.rotation.x = Math.PI / 2;
    arrowMesh.position.z += 0.3;
    arrowTail.material = this._coloredMaterial;
    arrowTail.position.z += 0.275 / 2;
    arrowTail.rotation.x = Math.PI / 2;
    if (isCollider) {
      arrowMesh.visibility = 0;
      arrowTail.visibility = 0;
    }
    parentMesh.addChild(arrowMesh);
    parentMesh.addChild(arrowTail);
    return { arrowMesh, arrowTail };
  }
  _attachedNodeChanged(value) {
    if (this.dragBehavior) {
      this.dragBehavior.enabled = value ? true : false;
    }
  }
  set isEnabled(value) {
    this._isEnabled = value;
    if (!value) {
      this.attachedMesh = null;
      this.attachedNode = null;
    } else {
      if (this._parent) {
        this.attachedMesh = this._parent.attachedMesh;
        this.attachedNode = this._parent.attachedNode;
      }
    }
  }
  get isEnabled() {
    return this._isEnabled;
  }
  dispose() {
    this.onSnapObservable.clear();
    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
    this.dragBehavior.detach();
    if (this._gizmoMesh) {
      this._gizmoMesh.dispose();
    }
    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach((matl) => {
      if (matl) {
        matl.dispose();
      }
    });
    super.dispose();
  }
  setCustomMesh(mesh, useGizmoMaterial = false) {
    super.setCustomMesh(mesh);
    if (useGizmoMaterial) {
      this._rootMesh.getChildMeshes().forEach((m) => {
        m.material = this._coloredMaterial;
        if (m.color) {
          m.color = this._coloredMaterial.diffuseColor;
        }
      });
      this._customMeshSet = false;
    }
  }
};

// node_modules/@babylonjs/core/Gizmos/boundingBoxGizmo.js
var BoundingBoxGizmo = class extends Gizmo {
  constructor(color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {
    super(gizmoLayer);
    this._boundingDimensions = new Vector3(1, 1, 1);
    this._renderObserver = null;
    this._pointerObserver = null;
    this._scaleDragSpeed = 0.2;
    this._tmpQuaternion = new Quaternion();
    this._tmpVector = new Vector3(0, 0, 0);
    this._tmpRotationMatrix = new Matrix();
    this.ignoreChildren = false;
    this.includeChildPredicate = null;
    this.rotationSphereSize = 0.1;
    this.scaleBoxSize = 0.1;
    this.fixedDragMeshScreenSize = false;
    this.fixedDragMeshBoundsSize = false;
    this.fixedDragMeshScreenSizeDistanceFactor = 10;
    this.onDragStartObservable = new Observable();
    this.onScaleBoxDragObservable = new Observable();
    this.onScaleBoxDragEndObservable = new Observable();
    this.onRotationSphereDragObservable = new Observable();
    this.onRotationSphereDragEndObservable = new Observable();
    this.scalePivot = null;
    this._axisFactor = new Vector3(1, 1, 1);
    this._existingMeshScale = new Vector3();
    this._dragMesh = null;
    this._pointerDragBehavior = new PointerDragBehavior();
    this.updateScale = false;
    this._anchorMesh = new AbstractMesh("anchor", gizmoLayer.utilityLayerScene);
    this._coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    this._coloredMaterial.disableLighting = true;
    this._hoverColoredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    this._hoverColoredMaterial.disableLighting = true;
    this._lineBoundingBox = new AbstractMesh("", gizmoLayer.utilityLayerScene);
    this._lineBoundingBox.rotationQuaternion = new Quaternion();
    const lines = [];
    lines.push(CreateLines("lines", { points: [new Vector3(0, 0, 0), new Vector3(this._boundingDimensions.x, 0, 0)] }, gizmoLayer.utilityLayerScene));
    lines.push(CreateLines("lines", { points: [new Vector3(0, 0, 0), new Vector3(0, this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));
    lines.push(CreateLines("lines", { points: [new Vector3(0, 0, 0), new Vector3(0, 0, this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
    lines.push(CreateLines("lines", { points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));
    lines.push(CreateLines("lines", { points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
    lines.push(CreateLines("lines", { points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));
    lines.push(CreateLines("lines", { points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
    lines.push(CreateLines("lines", { points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
    lines.push(CreateLines("lines", { points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
    lines.push(CreateLines("lines", {
      points: [
        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z),
        new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)
      ]
    }, gizmoLayer.utilityLayerScene));
    lines.push(CreateLines("lines", {
      points: [
        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z),
        new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)
      ]
    }, gizmoLayer.utilityLayerScene));
    lines.push(CreateLines("lines", {
      points: [
        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z),
        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)
      ]
    }, gizmoLayer.utilityLayerScene));
    lines.forEach((l) => {
      l.color = color;
      l.position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));
      l.isPickable = false;
      this._lineBoundingBox.addChild(l);
    });
    this._rootMesh.addChild(this._lineBoundingBox);
    this.setColor(color);
    this._rotateSpheresParent = new AbstractMesh("", gizmoLayer.utilityLayerScene);
    this._rotateSpheresParent.rotationQuaternion = new Quaternion();
    for (let i = 0; i < 12; i++) {
      const sphere = CreateSphere("", { diameter: 1 }, gizmoLayer.utilityLayerScene);
      sphere.rotationQuaternion = new Quaternion();
      sphere.material = this._coloredMaterial;
      sphere.isNearGrabbable = true;
      const _dragBehavior = new PointerDragBehavior({});
      _dragBehavior.moveAttached = false;
      _dragBehavior.updateDragPlane = false;
      sphere.addBehavior(_dragBehavior);
      const startingTurnDirection = new Vector3(1, 0, 0);
      let totalTurnAmountOfDrag = 0;
      _dragBehavior.onDragStartObservable.add(() => {
        startingTurnDirection.copyFrom(sphere.forward);
        totalTurnAmountOfDrag = 0;
      });
      _dragBehavior.onDragObservable.add((event) => {
        this.onRotationSphereDragObservable.notifyObservers({});
        if (this.attachedMesh) {
          const originalParent = this.attachedMesh.parent;
          if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(1e-3)) {
            Logger.Warn("BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling");
            return;
          }
          PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);
          const worldDragDirection = startingTurnDirection;
          const toSub = event.dragPlaneNormal.scale(Vector3.Dot(event.dragPlaneNormal, worldDragDirection));
          const dragAxis = worldDragDirection.subtract(toSub).normalizeToNew();
          let projectDist = Vector3.Dot(dragAxis, event.delta) < 0 ? Math.abs(event.delta.length()) : -Math.abs(event.delta.length());
          projectDist = projectDist / this._boundingDimensions.length() * this._anchorMesh.scaling.length();
          if (!this.attachedMesh.rotationQuaternion) {
            this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);
          }
          if (!this._anchorMesh.rotationQuaternion) {
            this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);
          }
          totalTurnAmountOfDrag += projectDist;
          if (Math.abs(totalTurnAmountOfDrag) <= 2 * Math.PI) {
            if (i >= 8) {
              Quaternion.RotationYawPitchRollToRef(0, 0, projectDist, this._tmpQuaternion);
            } else if (i >= 4) {
              Quaternion.RotationYawPitchRollToRef(projectDist, 0, 0, this._tmpQuaternion);
            } else {
              Quaternion.RotationYawPitchRollToRef(0, projectDist, 0, this._tmpQuaternion);
            }
            this._anchorMesh.addChild(this.attachedMesh, Gizmo.PreserveScaling);
            if (this._anchorMesh.getScene().useRightHandedSystem) {
              this._tmpQuaternion.conjugateInPlace();
            }
            this._anchorMesh.rotationQuaternion.multiplyToRef(this._tmpQuaternion, this._anchorMesh.rotationQuaternion);
            this._anchorMesh.removeChild(this.attachedMesh, Gizmo.PreserveScaling);
            this.attachedMesh.setParent(originalParent, Gizmo.PreserveScaling);
          }
          this.updateBoundingBox();
          PivotTools._RestorePivotPoint(this.attachedMesh);
        }
        this._updateDummy();
      });
      _dragBehavior.onDragStartObservable.add(() => {
        this.onDragStartObservable.notifyObservers({});
        this._selectNode(sphere);
      });
      _dragBehavior.onDragEndObservable.add(() => {
        this.onRotationSphereDragEndObservable.notifyObservers({});
        this._selectNode(null);
        this._updateDummy();
      });
      this._rotateSpheresParent.addChild(sphere);
    }
    this._rootMesh.addChild(this._rotateSpheresParent);
    this._scaleBoxesParent = new AbstractMesh("", gizmoLayer.utilityLayerScene);
    this._scaleBoxesParent.rotationQuaternion = new Quaternion();
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        for (let k = 0; k < 3; k++) {
          const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);
          if (zeroAxisCount === 1 || zeroAxisCount === 3) {
            continue;
          }
          const box = CreateBox("", { size: 1 }, gizmoLayer.utilityLayerScene);
          box.material = this._coloredMaterial;
          box._internalMetadata = zeroAxisCount === 2;
          box.isNearGrabbable = true;
          const dragAxis = new Vector3(i - 1, j - 1, k - 1).normalize();
          const _dragBehavior = new PointerDragBehavior({ dragAxis });
          _dragBehavior.updateDragPlane = false;
          _dragBehavior.moveAttached = false;
          box.addBehavior(_dragBehavior);
          _dragBehavior.onDragObservable.add((event) => {
            this.onScaleBoxDragObservable.notifyObservers({});
            if (this.attachedMesh) {
              const originalParent = this.attachedMesh.parent;
              if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(1e-3)) {
                Logger.Warn("BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling");
                return;
              }
              PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);
              const relativeDragDistance = event.dragDistance / this._boundingDimensions.length() * this._anchorMesh.scaling.length();
              const deltaScale = new Vector3(relativeDragDistance, relativeDragDistance, relativeDragDistance);
              if (zeroAxisCount === 2) {
                deltaScale.x *= Math.abs(dragAxis.x);
                deltaScale.y *= Math.abs(dragAxis.y);
                deltaScale.z *= Math.abs(dragAxis.z);
              }
              deltaScale.scaleInPlace(this._scaleDragSpeed);
              deltaScale.multiplyInPlace(this._axisFactor);
              this.updateBoundingBox();
              if (this.scalePivot) {
                this.attachedMesh.getWorldMatrix().getRotationMatrixToRef(this._tmpRotationMatrix);
                this._boundingDimensions.scaleToRef(0.5, this._tmpVector);
                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);
                this._anchorMesh.position.subtractInPlace(this._tmpVector);
                this._boundingDimensions.multiplyToRef(this.scalePivot, this._tmpVector);
                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);
                this._anchorMesh.position.addInPlace(this._tmpVector);
              } else {
                box.absolutePosition.subtractToRef(this._anchorMesh.position, this._tmpVector);
                this._anchorMesh.position.subtractInPlace(this._tmpVector);
              }
              this._anchorMesh.addChild(this.attachedMesh, Gizmo.PreserveScaling);
              this._anchorMesh.scaling.addInPlace(deltaScale);
              if (this._anchorMesh.scaling.x < 0 || this._anchorMesh.scaling.y < 0 || this._anchorMesh.scaling.z < 0) {
                this._anchorMesh.scaling.subtractInPlace(deltaScale);
              }
              this._anchorMesh.removeChild(this.attachedMesh, Gizmo.PreserveScaling);
              this.attachedMesh.setParent(originalParent, Gizmo.PreserveScaling);
              PivotTools._RestorePivotPoint(this.attachedMesh);
            }
            this._updateDummy();
          });
          _dragBehavior.onDragStartObservable.add(() => {
            this.onDragStartObservable.notifyObservers({});
            this._selectNode(box);
          });
          _dragBehavior.onDragEndObservable.add(() => {
            this.onScaleBoxDragEndObservable.notifyObservers({});
            this._selectNode(null);
            this._updateDummy();
          });
          this._scaleBoxesParent.addChild(box);
        }
      }
    }
    this._rootMesh.addChild(this._scaleBoxesParent);
    const pointerIds = new Array();
    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
      if (!pointerIds[pointerInfo.event.pointerId]) {
        this._rotateSpheresParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach((mesh) => {
          if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh == mesh) {
            pointerIds[pointerInfo.event.pointerId] = mesh;
            mesh.material = this._hoverColoredMaterial;
          }
        });
      } else {
        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh != pointerIds[pointerInfo.event.pointerId]) {
          pointerIds[pointerInfo.event.pointerId].material = this._coloredMaterial;
          delete pointerIds[pointerInfo.event.pointerId];
        }
      }
    });
    this._renderObserver = this.gizmoLayer.originalScene.onBeforeRenderObservable.add(() => {
      if (this.attachedMesh && !this._existingMeshScale.equals(this.attachedMesh.scaling)) {
        this.updateBoundingBox();
      } else if (this.fixedDragMeshScreenSize || this.fixedDragMeshBoundsSize) {
        this._updateRotationSpheres();
        this._updateScaleBoxes();
      }
      if (this._dragMesh && this.attachedMesh && this._pointerDragBehavior.dragging) {
        this._lineBoundingBox.position.rotateByQuaternionToRef(this._rootMesh.rotationQuaternion, this._tmpVector);
        this.attachedMesh.setAbsolutePosition(this._dragMesh.position.add(this._tmpVector.scale(-1)));
      }
    });
    this.updateBoundingBox();
  }
  set axisFactor(factor) {
    this._axisFactor = factor;
    const scaleBoxes = this._scaleBoxesParent.getChildMeshes();
    let index = 0;
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        for (let k = 0; k < 3; k++) {
          const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);
          if (zeroAxisCount === 1 || zeroAxisCount === 3) {
            continue;
          }
          if (scaleBoxes[index]) {
            const dragAxis = new Vector3(i - 1, j - 1, k - 1);
            dragAxis.multiplyInPlace(this._axisFactor);
            scaleBoxes[index].setEnabled(dragAxis.lengthSquared() > Epsilon);
          }
          index++;
        }
      }
    }
  }
  get axisFactor() {
    return this._axisFactor;
  }
  set scaleDragSpeed(value) {
    this._scaleDragSpeed = value;
  }
  get scaleDragSpeed() {
    return this._scaleDragSpeed;
  }
  get coloredMaterial() {
    return this._coloredMaterial;
  }
  get hoverMaterial() {
    return this._hoverColoredMaterial;
  }
  get pointerDragBehavior() {
    return this._pointerDragBehavior;
  }
  setColor(color) {
    this._coloredMaterial.emissiveColor = color;
    this._hoverColoredMaterial.emissiveColor = color.clone().add(new Color3(0.3, 0.3, 0.3));
    this._lineBoundingBox.getChildren().forEach((l) => {
      if (l.color) {
        l.color = color;
      }
    });
  }
  _attachedNodeChanged(value) {
    if (value) {
      this._anchorMesh.scaling.setAll(1);
      PivotTools._RemoveAndStorePivotPoint(value);
      const originalParent = value.parent;
      this._anchorMesh.addChild(value, Gizmo.PreserveScaling);
      this._anchorMesh.removeChild(value, Gizmo.PreserveScaling);
      value.setParent(originalParent, Gizmo.PreserveScaling);
      PivotTools._RestorePivotPoint(value);
      this.updateBoundingBox();
      value.getChildMeshes(false).forEach((m) => {
        m.markAsDirty("scaling");
      });
      this.gizmoLayer.utilityLayerScene.onAfterRenderObservable.addOnce(() => {
        this._updateDummy();
      });
    }
  }
  _selectNode(selectedMesh) {
    this._rotateSpheresParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach((m) => {
      m.isVisible = !selectedMesh || m == selectedMesh;
    });
  }
  getScaleBoxes() {
    return this._scaleBoxesParent.getChildMeshes();
  }
  updateBoundingBox() {
    if (this.attachedMesh) {
      PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);
      const originalParent = this.attachedMesh.parent;
      this.attachedMesh.setParent(null, Gizmo.PreserveScaling);
      this._update();
      if (!this.attachedMesh.rotationQuaternion) {
        this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);
      }
      if (!this._anchorMesh.rotationQuaternion) {
        this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);
      }
      this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);
      this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);
      this._tmpVector.copyFrom(this.attachedMesh.position);
      this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);
      this.attachedMesh.position.set(0, 0, 0);
      const boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren, this.includeChildPredicate);
      boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);
      this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions);
      this._lineBoundingBox.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);
      this._rotateSpheresParent.position.copyFrom(this._lineBoundingBox.position);
      this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position);
      this._lineBoundingBox.computeWorldMatrix();
      this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition);
      this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);
      this.attachedMesh.position.copyFrom(this._tmpVector);
      this.attachedMesh.setParent(originalParent, Gizmo.PreserveScaling);
    }
    this._updateRotationSpheres();
    this._updateScaleBoxes();
    if (this.attachedMesh) {
      this._existingMeshScale.copyFrom(this.attachedMesh.scaling);
      PivotTools._RestorePivotPoint(this.attachedMesh);
    }
  }
  _updateRotationSpheres() {
    const rotateSpheres = this._rotateSpheresParent.getChildMeshes();
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 2; j++) {
        for (let k = 0; k < 2; k++) {
          const index = i * 4 + j * 2 + k;
          if (i == 0) {
            rotateSpheres[index].position.set(this._boundingDimensions.x / 2, this._boundingDimensions.y * j, this._boundingDimensions.z * k);
            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));
            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Right()).normalizeToNew().add(rotateSpheres[index].position));
          }
          if (i == 1) {
            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y / 2, this._boundingDimensions.z * k);
            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));
            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Up()).normalizeToNew().add(rotateSpheres[index].position));
          }
          if (i == 2) {
            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y * k, this._boundingDimensions.z / 2);
            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));
            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Forward()).normalizeToNew().add(rotateSpheres[index].position));
          }
          if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {
            rotateSpheres[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);
            const distanceFromCamera = this.rotationSphereSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;
            rotateSpheres[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);
          } else if (this.fixedDragMeshBoundsSize) {
            rotateSpheres[index].scaling.set(this.rotationSphereSize * this._boundingDimensions.x, this.rotationSphereSize * this._boundingDimensions.y, this.rotationSphereSize * this._boundingDimensions.z);
          } else {
            rotateSpheres[index].scaling.set(this.rotationSphereSize, this.rotationSphereSize, this.rotationSphereSize);
          }
        }
      }
    }
  }
  _updateScaleBoxes() {
    const scaleBoxes = this._scaleBoxesParent.getChildMeshes();
    let index = 0;
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        for (let k = 0; k < 3; k++) {
          const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);
          if (zeroAxisCount === 1 || zeroAxisCount === 3) {
            continue;
          }
          if (scaleBoxes[index]) {
            scaleBoxes[index].position.set(this._boundingDimensions.x * (i / 2), this._boundingDimensions.y * (j / 2), this._boundingDimensions.z * (k / 2));
            scaleBoxes[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));
            if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {
              scaleBoxes[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);
              const distanceFromCamera = this.scaleBoxSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;
              scaleBoxes[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);
            } else if (this.fixedDragMeshBoundsSize) {
              scaleBoxes[index].scaling.set(this.scaleBoxSize * this._boundingDimensions.x, this.scaleBoxSize * this._boundingDimensions.y, this.scaleBoxSize * this._boundingDimensions.z);
            } else {
              scaleBoxes[index].scaling.set(this.scaleBoxSize, this.scaleBoxSize, this.scaleBoxSize);
            }
          }
          index++;
        }
      }
    }
  }
  setEnabledRotationAxis(axis) {
    this._rotateSpheresParent.getChildMeshes().forEach((m, i) => {
      if (i < 4) {
        m.setEnabled(axis.indexOf("x") != -1);
      } else if (i < 8) {
        m.setEnabled(axis.indexOf("y") != -1);
      } else {
        m.setEnabled(axis.indexOf("z") != -1);
      }
    });
  }
  setEnabledScaling(enable, homogeneousScaling = false) {
    this._scaleBoxesParent.getChildMeshes().forEach((m) => {
      let enableMesh = enable;
      if (homogeneousScaling && m._internalMetadata === true) {
        enableMesh = false;
      }
      m.setEnabled(enableMesh);
    });
  }
  _updateDummy() {
    if (this._dragMesh) {
      this._dragMesh.position.copyFrom(this._lineBoundingBox.getAbsolutePosition());
      this._dragMesh.scaling.copyFrom(this._lineBoundingBox.scaling);
      this._dragMesh.rotationQuaternion.copyFrom(this._rootMesh.rotationQuaternion);
    }
  }
  enableDragBehavior() {
    this._dragMesh = CreateBox("dummy", { size: 1 }, this.gizmoLayer.utilityLayerScene);
    this._dragMesh.visibility = 0;
    this._dragMesh.rotationQuaternion = new Quaternion();
    this._pointerDragBehavior.useObjectOrientationForDragging = false;
    this._dragMesh.addBehavior(this._pointerDragBehavior);
  }
  dispose() {
    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
    this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);
    this._lineBoundingBox.dispose();
    this._rotateSpheresParent.dispose();
    this._scaleBoxesParent.dispose();
    if (this._dragMesh) {
      this._dragMesh.dispose();
    }
    super.dispose();
  }
  static MakeNotPickableAndWrapInBoundingBox(mesh) {
    const makeNotPickable = (root) => {
      root.isPickable = false;
      root.getChildMeshes().forEach((c) => {
        makeNotPickable(c);
      });
    };
    makeNotPickable(mesh);
    if (!mesh.rotationQuaternion) {
      mesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z);
    }
    const oldPos = mesh.position.clone();
    const oldRot = mesh.rotationQuaternion.clone();
    mesh.rotationQuaternion.set(0, 0, 0, 1);
    mesh.position.set(0, 0, 0);
    const box = CreateBox("box", { size: 1 }, mesh.getScene());
    const boundingMinMax = mesh.getHierarchyBoundingVectors();
    boundingMinMax.max.subtractToRef(boundingMinMax.min, box.scaling);
    if (box.scaling.y === 0) {
      box.scaling.y = Epsilon;
    }
    if (box.scaling.x === 0) {
      box.scaling.x = Epsilon;
    }
    if (box.scaling.z === 0) {
      box.scaling.z = Epsilon;
    }
    box.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);
    mesh.addChild(box);
    mesh.rotationQuaternion.copyFrom(oldRot);
    mesh.position.copyFrom(oldPos);
    mesh.removeChild(box);
    box.addChild(mesh);
    box.visibility = 0;
    return box;
  }
  setCustomMesh() {
    Logger.Error("Custom meshes are not supported on this gizmo");
  }
};

// node_modules/@babylonjs/core/Gizmos/planeRotationGizmo.js
var PlaneRotationGizmo = class extends Gizmo {
  constructor(planeNormal, color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, tessellation = 32, parent = null, useEulerRotation = false, thickness = 1) {
    var _a;
    super(gizmoLayer);
    this._pointerObserver = null;
    this.snapDistance = 0;
    this.onSnapObservable = new Observable();
    this.angle = 0;
    this._isEnabled = true;
    this._parent = null;
    this._dragging = false;
    this._angles = new Vector3();
    this._parent = parent;
    this._coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    this._coloredMaterial.diffuseColor = color;
    this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));
    this._hoverMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    this._hoverMaterial.diffuseColor = Color3.Yellow();
    this._disableMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    this._disableMaterial.diffuseColor = Color3.Gray();
    this._disableMaterial.alpha = 0.4;
    this._gizmoMesh = new Mesh("", gizmoLayer.utilityLayerScene);
    const { rotationMesh, collider } = this._createGizmoMesh(this._gizmoMesh, thickness, tessellation);
    this._rotationDisplayPlane = CreatePlane("rotationDisplay", { size: 0.6, updatable: false }, this.gizmoLayer.utilityLayerScene);
    this._rotationDisplayPlane.rotation.z = Math.PI * 0.5;
    this._rotationDisplayPlane.parent = this._gizmoMesh;
    this._rotationDisplayPlane.setEnabled(false);
    Effect.ShadersStore["rotationGizmoVertexShader"] = PlaneRotationGizmo._RotationGizmoVertexShader;
    Effect.ShadersStore["rotationGizmoFragmentShader"] = PlaneRotationGizmo._RotationGizmoFragmentShader;
    this._rotationShaderMaterial = new ShaderMaterial("shader", this.gizmoLayer.utilityLayerScene, {
      vertex: "rotationGizmo",
      fragment: "rotationGizmo"
    }, {
      attributes: ["position", "uv"],
      uniforms: ["worldViewProjection", "angles"]
    });
    this._rotationShaderMaterial.backFaceCulling = false;
    this._rotationDisplayPlane.material = this._rotationShaderMaterial;
    this._rotationDisplayPlane.visibility = 0.999;
    this._gizmoMesh.lookAt(this._rootMesh.position.add(planeNormal));
    this._rootMesh.addChild(this._gizmoMesh, Gizmo.PreserveScaling);
    this._gizmoMesh.scaling.scaleInPlace(1 / 3);
    this.dragBehavior = new PointerDragBehavior({ dragPlaneNormal: planeNormal });
    this.dragBehavior.moveAttached = false;
    this.dragBehavior.maxDragAngle = PlaneRotationGizmo.MaxDragAngle;
    this.dragBehavior._useAlternatePickedPointAboveMaxDragAngle = true;
    this._rootMesh.addBehavior(this.dragBehavior);
    const lastDragPosition = new Vector3();
    const rotationMatrix = new Matrix();
    const planeNormalTowardsCamera = new Vector3();
    let localPlaneNormalTowardsCamera = new Vector3();
    this.dragBehavior.onDragStartObservable.add((e) => {
      if (this.attachedNode) {
        lastDragPosition.copyFrom(e.dragPlanePoint);
        this._rotationDisplayPlane.setEnabled(true);
        this._rotationDisplayPlane.getWorldMatrix().invertToRef(rotationMatrix);
        Vector3.TransformCoordinatesToRef(e.dragPlanePoint, rotationMatrix, lastDragPosition);
        this._angles.x = Math.atan2(lastDragPosition.y, lastDragPosition.x) + Math.PI;
        this._angles.y = 0;
        this._angles.z = this.updateGizmoRotationToMatchAttachedMesh ? 1 : 0;
        this._dragging = true;
        lastDragPosition.copyFrom(e.dragPlanePoint);
        this._rotationShaderMaterial.setVector3("angles", this._angles);
        this.angle = 0;
      }
    });
    this.dragBehavior.onDragEndObservable.add(() => {
      this._dragging = false;
      this._rotationDisplayPlane.setEnabled(false);
    });
    const tmpSnapEvent = { snapDistance: 0 };
    let currentSnapDragDistance = 0;
    const tmpMatrix2 = new Matrix();
    const amountToRotate = new Quaternion();
    this.dragBehavior.onDragObservable.add((event) => {
      if (this.attachedNode) {
        const nodeScale = new Vector3(1, 1, 1);
        const nodeQuaternion = new Quaternion(0, 0, 0, 1);
        const nodeTranslation = new Vector3(0, 0, 0);
        this._handlePivot();
        this.attachedNode.getWorldMatrix().decompose(nodeScale, nodeQuaternion, nodeTranslation);
        const uniformScaling = Math.abs(Math.abs(nodeScale.x) - Math.abs(nodeScale.y)) <= Epsilon && Math.abs(Math.abs(nodeScale.x) - Math.abs(nodeScale.z)) <= Epsilon;
        if (!uniformScaling && this.updateGizmoRotationToMatchAttachedMesh) {
          Logger.Warn("Unable to use a rotation gizmo matching mesh rotation with non uniform scaling. Use uniform scaling or set updateGizmoRotationToMatchAttachedMesh to false.");
          return;
        }
        nodeQuaternion.normalize();
        const nodeTranslationForOperation = this.updateGizmoPositionToMatchAttachedMesh ? nodeTranslation : this._rootMesh.absolutePosition;
        const newVector = event.dragPlanePoint.subtract(nodeTranslationForOperation).normalize();
        const originalVector = lastDragPosition.subtract(nodeTranslationForOperation).normalize();
        const cross = Vector3.Cross(newVector, originalVector);
        const dot = Vector3.Dot(newVector, originalVector);
        let angle = Math.atan2(cross.length(), dot);
        planeNormalTowardsCamera.copyFrom(planeNormal);
        localPlaneNormalTowardsCamera.copyFrom(planeNormal);
        if (this.updateGizmoRotationToMatchAttachedMesh) {
          nodeQuaternion.toRotationMatrix(rotationMatrix);
          localPlaneNormalTowardsCamera = Vector3.TransformCoordinates(planeNormalTowardsCamera, rotationMatrix);
        }
        let cameraFlipped = false;
        if (gizmoLayer.utilityLayerScene.activeCamera) {
          const camVec = gizmoLayer.utilityLayerScene.activeCamera.position.subtract(nodeTranslationForOperation).normalize();
          if (Vector3.Dot(camVec, localPlaneNormalTowardsCamera) > 0) {
            planeNormalTowardsCamera.scaleInPlace(-1);
            localPlaneNormalTowardsCamera.scaleInPlace(-1);
            cameraFlipped = true;
          }
        }
        const halfCircleSide = Vector3.Dot(localPlaneNormalTowardsCamera, cross) > 0;
        if (halfCircleSide) {
          angle = -angle;
        }
        let snapped = false;
        if (this.snapDistance != 0) {
          currentSnapDragDistance += angle;
          if (Math.abs(currentSnapDragDistance) > this.snapDistance) {
            let dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);
            if (currentSnapDragDistance < 0) {
              dragSteps *= -1;
            }
            currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;
            angle = this.snapDistance * dragSteps;
            snapped = true;
          } else {
            angle = 0;
          }
        }
        const quaternionCoefficient = Math.sin(angle / 2);
        amountToRotate.set(planeNormalTowardsCamera.x * quaternionCoefficient, planeNormalTowardsCamera.y * quaternionCoefficient, planeNormalTowardsCamera.z * quaternionCoefficient, Math.cos(angle / 2));
        if (tmpMatrix2.determinant() > 0) {
          const tmpVector = new Vector3();
          amountToRotate.toEulerAnglesToRef(tmpVector);
          Quaternion.RotationYawPitchRollToRef(tmpVector.y, -tmpVector.x, -tmpVector.z, amountToRotate);
        }
        if (this.updateGizmoRotationToMatchAttachedMesh) {
          nodeQuaternion.multiplyToRef(amountToRotate, nodeQuaternion);
          Matrix.ComposeToRef(nodeScale, nodeQuaternion, nodeTranslation, this.attachedNode.getWorldMatrix());
        } else {
          amountToRotate.toRotationMatrix(TmpVectors.Matrix[0]);
          TmpVectors.Matrix[0].multiplyToRef(this.attachedNode.getWorldMatrix(), this.attachedNode.getWorldMatrix());
        }
        lastDragPosition.copyFrom(event.dragPlanePoint);
        if (snapped) {
          tmpSnapEvent.snapDistance = angle;
          this.onSnapObservable.notifyObservers(tmpSnapEvent);
        }
        this._angles.y += angle;
        this.angle += cameraFlipped ? -angle : angle;
        this._rotationShaderMaterial.setVector3("angles", this._angles);
        this._matrixChanged();
      }
    });
    const light = gizmoLayer._getSharedGizmoLight();
    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));
    const cache = {
      colliderMeshes: [collider],
      gizmoMeshes: [rotationMesh],
      material: this._coloredMaterial,
      hoverMaterial: this._hoverMaterial,
      disableMaterial: this._disableMaterial,
      active: false,
      dragBehavior: this.dragBehavior
    };
    (_a = this._parent) === null || _a === void 0 ? void 0 : _a.addToAxisCache(this._gizmoMesh, cache);
    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
      var _a2;
      if (this._customMeshSet) {
        return;
      }
      this.dragBehavior.maxDragAngle = PlaneRotationGizmo.MaxDragAngle;
      this._isHovered = !!(cache.colliderMeshes.indexOf((_a2 = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _a2 === void 0 ? void 0 : _a2.pickedMesh) != -1);
      if (!this._parent) {
        const material = cache.dragBehavior.enabled ? this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial : this._disableMaterial;
        this._setGizmoMeshMaterial(cache.gizmoMeshes, material);
      }
    });
    this.dragBehavior.onEnabledObservable.add((newState) => {
      this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? this._coloredMaterial : this._disableMaterial);
    });
  }
  get coloredMaterial() {
    return this._coloredMaterial;
  }
  get hoverMaterial() {
    return this._hoverMaterial;
  }
  get disableMaterial() {
    return this._disableMaterial;
  }
  _createGizmoMesh(parentMesh, thickness, tessellation) {
    const collider = CreateTorus("ignore", {
      diameter: 0.6,
      thickness: 0.03 * thickness,
      tessellation
    }, this.gizmoLayer.utilityLayerScene);
    collider.visibility = 0;
    const rotationMesh = CreateTorus("", {
      diameter: 0.6,
      thickness: 5e-3 * thickness,
      tessellation
    }, this.gizmoLayer.utilityLayerScene);
    rotationMesh.material = this._coloredMaterial;
    rotationMesh.rotation.x = Math.PI / 2;
    collider.rotation.x = Math.PI / 2;
    parentMesh.addChild(rotationMesh, Gizmo.PreserveScaling);
    parentMesh.addChild(collider, Gizmo.PreserveScaling);
    return { rotationMesh, collider };
  }
  _attachedNodeChanged(value) {
    if (this.dragBehavior) {
      this.dragBehavior.enabled = value ? true : false;
    }
  }
  set isEnabled(value) {
    this._isEnabled = value;
    if (!value) {
      this.attachedMesh = null;
    } else {
      if (this._parent) {
        this.attachedMesh = this._parent.attachedMesh;
      }
    }
  }
  get isEnabled() {
    return this._isEnabled;
  }
  dispose() {
    this.onSnapObservable.clear();
    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
    this.dragBehavior.detach();
    if (this._gizmoMesh) {
      this._gizmoMesh.dispose();
    }
    if (this._rotationDisplayPlane) {
      this._rotationDisplayPlane.dispose();
    }
    if (this._rotationShaderMaterial) {
      this._rotationShaderMaterial.dispose();
    }
    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach((matl) => {
      if (matl) {
        matl.dispose();
      }
    });
    super.dispose();
  }
};
PlaneRotationGizmo.MaxDragAngle = Math.PI * 9 / 20;
PlaneRotationGizmo._RotationGizmoVertexShader = `
        precision highp float;
        attribute vec3 position;
        attribute vec2 uv;
        uniform mat4 worldViewProjection;
        varying vec3 vPosition;
        varying vec2 vUV;
        void main(void) {
            gl_Position = worldViewProjection * vec4(position, 1.0);
            vUV = uv;
        }`;
PlaneRotationGizmo._RotationGizmoFragmentShader = `
        precision highp float;
        varying vec2 vUV;
        varying vec3 vPosition;
        uniform vec3 angles;
        #define twopi 6.283185307
        void main(void) {
            vec2 uv = vUV - vec2(0.5);
            float angle = atan(uv.y, uv.x) + 3.141592;
            float delta = gl_FrontFacing ? angles.y : -angles.y;
            float begin = angles.x - delta * angles.z;
            float start = (begin < (begin + delta)) ? begin : (begin + delta);
            float end = (begin > (begin + delta)) ? begin : (begin + delta);
            float len = sqrt(dot(uv,uv));
            float opacity = 1. - step(0.5, len);

            float base = abs(floor(start / twopi)) * twopi;
            start += base;
            end += base;

            float intensity = 0.;
            for (int i = 0; i < 5; i++)
            {
                intensity += max(step(start, angle) - step(end, angle), 0.);
                angle += twopi;
            }
            gl_FragColor = vec4(1.,1.,0., min(intensity * 0.25, 0.8)) * opacity;
        }`;

// node_modules/@babylonjs/core/Gizmos/rotationGizmo.js
var RotationGizmo = class extends Gizmo {
  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, tessellation = 32, useEulerRotation = false, thickness = 1, gizmoManager, options) {
    super(gizmoLayer);
    this.onDragStartObservable = new Observable();
    this.onDragEndObservable = new Observable();
    this._observables = [];
    this._gizmoAxisCache = /* @__PURE__ */ new Map();
    const xColor = options && options.xOptions && options.xOptions.color ? options.xOptions.color : Color3.Red().scale(0.5);
    const yColor = options && options.yOptions && options.yOptions.color ? options.yOptions.color : Color3.Green().scale(0.5);
    const zColor = options && options.zOptions && options.zOptions.color ? options.zOptions.color : Color3.Blue().scale(0.5);
    this.xGizmo = new PlaneRotationGizmo(new Vector3(1, 0, 0), xColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);
    this.yGizmo = new PlaneRotationGizmo(new Vector3(0, 1, 0), yColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);
    this.zGizmo = new PlaneRotationGizmo(new Vector3(0, 0, 1), zColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);
    [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {
      if (options && options.updateScale != void 0) {
        gizmo.updateScale = options.updateScale;
      }
      gizmo.dragBehavior.onDragStartObservable.add(() => {
        this.onDragStartObservable.notifyObservers({});
      });
      gizmo.dragBehavior.onDragEndObservable.add(() => {
        this.onDragEndObservable.notifyObservers({});
      });
    });
    this.attachedMesh = null;
    this.attachedNode = null;
    if (gizmoManager) {
      gizmoManager.addToAxisCache(this._gizmoAxisCache);
    } else {
      Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);
    }
  }
  get attachedMesh() {
    return this._meshAttached;
  }
  set attachedMesh(mesh) {
    this._meshAttached = mesh;
    this._nodeAttached = mesh;
    this._checkBillboardTransform();
    [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {
      if (gizmo.isEnabled) {
        gizmo.attachedMesh = mesh;
      } else {
        gizmo.attachedMesh = null;
      }
    });
  }
  get attachedNode() {
    return this._nodeAttached;
  }
  set attachedNode(node) {
    this._meshAttached = null;
    this._nodeAttached = node;
    this._checkBillboardTransform();
    [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {
      if (gizmo.isEnabled) {
        gizmo.attachedNode = node;
      } else {
        gizmo.attachedNode = null;
      }
    });
  }
  _checkBillboardTransform() {
    if (this._nodeAttached && this._nodeAttached.billboardMode) {
      console.log("Rotation Gizmo will not work with transforms in billboard mode.");
    }
  }
  get isHovered() {
    let hovered = false;
    [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {
      hovered = hovered || gizmo.isHovered;
    });
    return hovered;
  }
  set updateGizmoRotationToMatchAttachedMesh(value) {
    if (this.xGizmo) {
      this.xGizmo.updateGizmoRotationToMatchAttachedMesh = value;
      this.yGizmo.updateGizmoRotationToMatchAttachedMesh = value;
      this.zGizmo.updateGizmoRotationToMatchAttachedMesh = value;
    }
  }
  get updateGizmoRotationToMatchAttachedMesh() {
    return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;
  }
  set updateGizmoPositionToMatchAttachedMesh(value) {
    if (this.xGizmo) {
      this.xGizmo.updateGizmoPositionToMatchAttachedMesh = value;
      this.yGizmo.updateGizmoPositionToMatchAttachedMesh = value;
      this.zGizmo.updateGizmoPositionToMatchAttachedMesh = value;
    }
  }
  get updateGizmoPositionToMatchAttachedMesh() {
    return this.xGizmo.updateGizmoPositionToMatchAttachedMesh;
  }
  set updateScale(value) {
    if (this.xGizmo) {
      this.xGizmo.updateScale = value;
      this.yGizmo.updateScale = value;
      this.zGizmo.updateScale = value;
    }
  }
  get updateScale() {
    return this.xGizmo.updateScale;
  }
  set snapDistance(value) {
    if (this.xGizmo) {
      this.xGizmo.snapDistance = value;
      this.yGizmo.snapDistance = value;
      this.zGizmo.snapDistance = value;
    }
  }
  get snapDistance() {
    return this.xGizmo.snapDistance;
  }
  set scaleRatio(value) {
    if (this.xGizmo) {
      this.xGizmo.scaleRatio = value;
      this.yGizmo.scaleRatio = value;
      this.zGizmo.scaleRatio = value;
    }
  }
  get scaleRatio() {
    return this.xGizmo.scaleRatio;
  }
  addToAxisCache(mesh, cache) {
    this._gizmoAxisCache.set(mesh, cache);
  }
  dispose() {
    this.xGizmo.dispose();
    this.yGizmo.dispose();
    this.zGizmo.dispose();
    this.onDragStartObservable.clear();
    this.onDragEndObservable.clear();
    this._observables.forEach((obs) => {
      this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);
    });
  }
  setCustomMesh() {
    Logger.Error("Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)");
  }
};

// node_modules/@babylonjs/core/Gizmos/planeDragGizmo.js
var PlaneDragGizmo = class extends Gizmo {
  constructor(dragPlaneNormal, color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, parent = null) {
    var _a;
    super(gizmoLayer);
    this._pointerObserver = null;
    this.snapDistance = 0;
    this.onSnapObservable = new Observable();
    this._isEnabled = false;
    this._parent = null;
    this._dragging = false;
    this._parent = parent;
    this._coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    this._coloredMaterial.diffuseColor = color;
    this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));
    this._hoverMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    this._hoverMaterial.diffuseColor = Color3.Yellow();
    this._disableMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    this._disableMaterial.diffuseColor = Color3.Gray();
    this._disableMaterial.alpha = 0.4;
    this._gizmoMesh = PlaneDragGizmo._CreatePlane(gizmoLayer.utilityLayerScene, this._coloredMaterial);
    this._gizmoMesh.lookAt(this._rootMesh.position.add(dragPlaneNormal));
    this._gizmoMesh.scaling.scaleInPlace(1 / 3);
    this._gizmoMesh.parent = this._rootMesh;
    let currentSnapDragDistance = 0;
    const tmpVector = new Vector3();
    const tmpSnapEvent = { snapDistance: 0 };
    this.dragBehavior = new PointerDragBehavior({ dragPlaneNormal });
    this.dragBehavior.moveAttached = false;
    this._rootMesh.addBehavior(this.dragBehavior);
    this.dragBehavior.onDragObservable.add((event) => {
      if (this.attachedNode) {
        this._handlePivot();
        if (this.snapDistance == 0) {
          this.attachedNode.getWorldMatrix().addTranslationFromFloats(event.delta.x, event.delta.y, event.delta.z);
        } else {
          currentSnapDragDistance += event.dragDistance;
          if (Math.abs(currentSnapDragDistance) > this.snapDistance) {
            const dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);
            currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;
            event.delta.normalizeToRef(tmpVector);
            tmpVector.scaleInPlace(this.snapDistance * dragSteps);
            this.attachedNode.getWorldMatrix().addTranslationFromFloats(tmpVector.x, tmpVector.y, tmpVector.z);
            tmpSnapEvent.snapDistance = this.snapDistance * dragSteps;
            this.onSnapObservable.notifyObservers(tmpSnapEvent);
          }
        }
        this._matrixChanged();
      }
    });
    this.dragBehavior.onDragStartObservable.add(() => {
      this._dragging = true;
    });
    this.dragBehavior.onDragEndObservable.add(() => {
      this._dragging = false;
    });
    const light = gizmoLayer._getSharedGizmoLight();
    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));
    const cache = {
      gizmoMeshes: this._gizmoMesh.getChildMeshes(),
      colliderMeshes: this._gizmoMesh.getChildMeshes(),
      material: this._coloredMaterial,
      hoverMaterial: this._hoverMaterial,
      disableMaterial: this._disableMaterial,
      active: false,
      dragBehavior: this.dragBehavior
    };
    (_a = this._parent) === null || _a === void 0 ? void 0 : _a.addToAxisCache(this._gizmoMesh, cache);
    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
      var _a2;
      if (this._customMeshSet) {
        return;
      }
      this._isHovered = !!(cache.colliderMeshes.indexOf((_a2 = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _a2 === void 0 ? void 0 : _a2.pickedMesh) != -1);
      if (!this._parent) {
        const material = cache.dragBehavior.enabled ? this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial : this._disableMaterial;
        this._setGizmoMeshMaterial(cache.gizmoMeshes, material);
      }
    });
    this.dragBehavior.onEnabledObservable.add((newState) => {
      this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? this._coloredMaterial : this._disableMaterial);
    });
  }
  get coloredMaterial() {
    return this._coloredMaterial;
  }
  get hoverMaterial() {
    return this._hoverMaterial;
  }
  get disableMaterial() {
    return this._disableMaterial;
  }
  static _CreatePlane(scene, material) {
    const plane = new TransformNode("plane", scene);
    const dragPlane = CreatePlane("dragPlane", { width: 0.1375, height: 0.1375, sideOrientation: 2 }, scene);
    dragPlane.material = material;
    dragPlane.parent = plane;
    return plane;
  }
  _attachedNodeChanged(value) {
    if (this.dragBehavior) {
      this.dragBehavior.enabled = value ? true : false;
    }
  }
  set isEnabled(value) {
    this._isEnabled = value;
    if (!value) {
      this.attachedNode = null;
    } else {
      if (this._parent) {
        this.attachedNode = this._parent.attachedNode;
      }
    }
  }
  get isEnabled() {
    return this._isEnabled;
  }
  dispose() {
    this.onSnapObservable.clear();
    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
    this.dragBehavior.detach();
    super.dispose();
    if (this._gizmoMesh) {
      this._gizmoMesh.dispose();
    }
    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach((matl) => {
      if (matl) {
        matl.dispose();
      }
    });
  }
};

// node_modules/@babylonjs/core/Gizmos/positionGizmo.js
var PositionGizmo = class extends Gizmo {
  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, thickness = 1, gizmoManager) {
    super(gizmoLayer);
    this._meshAttached = null;
    this._nodeAttached = null;
    this._observables = [];
    this._gizmoAxisCache = /* @__PURE__ */ new Map();
    this.onDragStartObservable = new Observable();
    this.onDragEndObservable = new Observable();
    this._planarGizmoEnabled = false;
    this.xGizmo = new AxisDragGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, this, thickness);
    this.yGizmo = new AxisDragGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, this, thickness);
    this.zGizmo = new AxisDragGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, this, thickness);
    this.xPlaneGizmo = new PlaneDragGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), this.gizmoLayer, this);
    this.yPlaneGizmo = new PlaneDragGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), this.gizmoLayer, this);
    this.zPlaneGizmo = new PlaneDragGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), this.gizmoLayer, this);
    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {
      gizmo.dragBehavior.onDragStartObservable.add(() => {
        this.onDragStartObservable.notifyObservers({});
      });
      gizmo.dragBehavior.onDragEndObservable.add(() => {
        this.onDragEndObservable.notifyObservers({});
      });
    });
    this.attachedMesh = null;
    if (gizmoManager) {
      gizmoManager.addToAxisCache(this._gizmoAxisCache);
    } else {
      Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);
    }
  }
  get attachedMesh() {
    return this._meshAttached;
  }
  set attachedMesh(mesh) {
    this._meshAttached = mesh;
    this._nodeAttached = mesh;
    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {
      if (gizmo.isEnabled) {
        gizmo.attachedMesh = mesh;
      } else {
        gizmo.attachedMesh = null;
      }
    });
  }
  get attachedNode() {
    return this._nodeAttached;
  }
  set attachedNode(node) {
    this._meshAttached = null;
    this._nodeAttached = node;
    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {
      if (gizmo.isEnabled) {
        gizmo.attachedNode = node;
      } else {
        gizmo.attachedNode = null;
      }
    });
  }
  get isHovered() {
    let hovered = false;
    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {
      hovered = hovered || gizmo.isHovered;
    });
    return hovered;
  }
  set planarGizmoEnabled(value) {
    this._planarGizmoEnabled = value;
    [this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {
      if (gizmo) {
        gizmo.isEnabled = value;
        if (value) {
          if (gizmo.attachedMesh) {
            gizmo.attachedMesh = this.attachedMesh;
          } else {
            gizmo.attachedNode = this.attachedNode;
          }
        }
      }
    }, this);
  }
  get planarGizmoEnabled() {
    return this._planarGizmoEnabled;
  }
  set updateGizmoRotationToMatchAttachedMesh(value) {
    this._updateGizmoRotationToMatchAttachedMesh = value;
    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {
      if (gizmo) {
        gizmo.updateGizmoRotationToMatchAttachedMesh = value;
      }
    });
  }
  get updateGizmoRotationToMatchAttachedMesh() {
    return this._updateGizmoRotationToMatchAttachedMesh;
  }
  set updateGizmoPositionToMatchAttachedMesh(value) {
    this._updateGizmoPositionToMatchAttachedMesh = value;
    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {
      if (gizmo) {
        gizmo.updateGizmoPositionToMatchAttachedMesh = value;
      }
    });
  }
  get updateGizmoPositionToMatchAttachedMesh() {
    return this._updateGizmoPositionToMatchAttachedMesh;
  }
  set updateScale(value) {
    if (this.xGizmo) {
      this.xGizmo.updateScale = value;
      this.yGizmo.updateScale = value;
      this.zGizmo.updateScale = value;
    }
  }
  get updateScale() {
    return this.xGizmo.updateScale;
  }
  set snapDistance(value) {
    this._snapDistance = value;
    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {
      if (gizmo) {
        gizmo.snapDistance = value;
      }
    });
  }
  get snapDistance() {
    return this._snapDistance;
  }
  set scaleRatio(value) {
    this._scaleRatio = value;
    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {
      if (gizmo) {
        gizmo.scaleRatio = value;
      }
    });
  }
  get scaleRatio() {
    return this._scaleRatio;
  }
  addToAxisCache(mesh, cache) {
    this._gizmoAxisCache.set(mesh, cache);
  }
  dispose() {
    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {
      if (gizmo) {
        gizmo.dispose();
      }
    });
    this._observables.forEach((obs) => {
      this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);
    });
    this.onDragStartObservable.clear();
    this.onDragEndObservable.clear();
  }
  setCustomMesh() {
    Logger.Error("Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo,gizmo.xPlaneGizmo, gizmo.yPlaneGizmo, gizmo.zPlaneGizmo)");
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/polyhedronBuilder.js
function CreatePolyhedronVertexData(options) {
  const polyhedra = [];
  polyhedra[0] = {
    vertex: [
      [0, 0, 1.732051],
      [1.632993, 0, -0.5773503],
      [-0.8164966, 1.414214, -0.5773503],
      [-0.8164966, -1.414214, -0.5773503]
    ],
    face: [
      [0, 1, 2],
      [0, 2, 3],
      [0, 3, 1],
      [1, 3, 2]
    ]
  };
  polyhedra[1] = {
    vertex: [
      [0, 0, 1.414214],
      [1.414214, 0, 0],
      [0, 1.414214, 0],
      [-1.414214, 0, 0],
      [0, -1.414214, 0],
      [0, 0, -1.414214]
    ],
    face: [
      [0, 1, 2],
      [0, 2, 3],
      [0, 3, 4],
      [0, 4, 1],
      [1, 4, 5],
      [1, 5, 2],
      [2, 5, 3],
      [3, 5, 4]
    ]
  };
  polyhedra[2] = {
    vertex: [
      [0, 0, 1.070466],
      [0.7136442, 0, 0.7978784],
      [-0.3568221, 0.618034, 0.7978784],
      [-0.3568221, -0.618034, 0.7978784],
      [0.7978784, 0.618034, 0.3568221],
      [0.7978784, -0.618034, 0.3568221],
      [-0.9341724, 0.381966, 0.3568221],
      [0.1362939, 1, 0.3568221],
      [0.1362939, -1, 0.3568221],
      [-0.9341724, -0.381966, 0.3568221],
      [0.9341724, 0.381966, -0.3568221],
      [0.9341724, -0.381966, -0.3568221],
      [-0.7978784, 0.618034, -0.3568221],
      [-0.1362939, 1, -0.3568221],
      [-0.1362939, -1, -0.3568221],
      [-0.7978784, -0.618034, -0.3568221],
      [0.3568221, 0.618034, -0.7978784],
      [0.3568221, -0.618034, -0.7978784],
      [-0.7136442, 0, -0.7978784],
      [0, 0, -1.070466]
    ],
    face: [
      [0, 1, 4, 7, 2],
      [0, 2, 6, 9, 3],
      [0, 3, 8, 5, 1],
      [1, 5, 11, 10, 4],
      [2, 7, 13, 12, 6],
      [3, 9, 15, 14, 8],
      [4, 10, 16, 13, 7],
      [5, 8, 14, 17, 11],
      [6, 12, 18, 15, 9],
      [10, 11, 17, 19, 16],
      [12, 13, 16, 19, 18],
      [14, 15, 18, 19, 17]
    ]
  };
  polyhedra[3] = {
    vertex: [
      [0, 0, 1.175571],
      [1.051462, 0, 0.5257311],
      [0.3249197, 1, 0.5257311],
      [-0.8506508, 0.618034, 0.5257311],
      [-0.8506508, -0.618034, 0.5257311],
      [0.3249197, -1, 0.5257311],
      [0.8506508, 0.618034, -0.5257311],
      [0.8506508, -0.618034, -0.5257311],
      [-0.3249197, 1, -0.5257311],
      [-1.051462, 0, -0.5257311],
      [-0.3249197, -1, -0.5257311],
      [0, 0, -1.175571]
    ],
    face: [
      [0, 1, 2],
      [0, 2, 3],
      [0, 3, 4],
      [0, 4, 5],
      [0, 5, 1],
      [1, 5, 7],
      [1, 7, 6],
      [1, 6, 2],
      [2, 6, 8],
      [2, 8, 3],
      [3, 8, 9],
      [3, 9, 4],
      [4, 9, 10],
      [4, 10, 5],
      [5, 10, 7],
      [6, 7, 11],
      [6, 11, 8],
      [7, 10, 11],
      [8, 11, 9],
      [9, 11, 10]
    ]
  };
  polyhedra[4] = {
    vertex: [
      [0, 0, 1.070722],
      [0.7148135, 0, 0.7971752],
      [-0.104682, 0.7071068, 0.7971752],
      [-0.6841528, 0.2071068, 0.7971752],
      [-0.104682, -0.7071068, 0.7971752],
      [0.6101315, 0.7071068, 0.5236279],
      [1.04156, 0.2071068, 0.1367736],
      [0.6101315, -0.7071068, 0.5236279],
      [-0.3574067, 1, 0.1367736],
      [-0.7888348, -0.5, 0.5236279],
      [-0.9368776, 0.5, 0.1367736],
      [-0.3574067, -1, 0.1367736],
      [0.3574067, 1, -0.1367736],
      [0.9368776, -0.5, -0.1367736],
      [0.7888348, 0.5, -0.5236279],
      [0.3574067, -1, -0.1367736],
      [-0.6101315, 0.7071068, -0.5236279],
      [-1.04156, -0.2071068, -0.1367736],
      [-0.6101315, -0.7071068, -0.5236279],
      [0.104682, 0.7071068, -0.7971752],
      [0.6841528, -0.2071068, -0.7971752],
      [0.104682, -0.7071068, -0.7971752],
      [-0.7148135, 0, -0.7971752],
      [0, 0, -1.070722]
    ],
    face: [
      [0, 2, 3],
      [1, 6, 5],
      [4, 9, 11],
      [7, 15, 13],
      [8, 16, 10],
      [12, 14, 19],
      [17, 22, 18],
      [20, 21, 23],
      [0, 1, 5, 2],
      [0, 3, 9, 4],
      [0, 4, 7, 1],
      [1, 7, 13, 6],
      [2, 5, 12, 8],
      [2, 8, 10, 3],
      [3, 10, 17, 9],
      [4, 11, 15, 7],
      [5, 6, 14, 12],
      [6, 13, 20, 14],
      [8, 12, 19, 16],
      [9, 17, 18, 11],
      [10, 16, 22, 17],
      [11, 18, 21, 15],
      [13, 15, 21, 20],
      [14, 20, 23, 19],
      [16, 19, 23, 22],
      [18, 22, 23, 21]
    ]
  };
  polyhedra[5] = {
    vertex: [
      [0, 0, 1.322876],
      [1.309307, 0, 0.1889822],
      [-0.9819805, 0.8660254, 0.1889822],
      [0.1636634, -1.299038, 0.1889822],
      [0.3273268, 0.8660254, -0.9449112],
      [-0.8183171, -0.4330127, -0.9449112]
    ],
    face: [
      [0, 3, 1],
      [2, 4, 5],
      [0, 1, 4, 2],
      [0, 2, 5, 3],
      [1, 3, 5, 4]
    ]
  };
  polyhedra[6] = {
    vertex: [
      [0, 0, 1.159953],
      [1.013464, 0, 0.5642542],
      [-0.3501431, 0.9510565, 0.5642542],
      [-0.7715208, -0.6571639, 0.5642542],
      [0.6633206, 0.9510565, -0.03144481],
      [0.8682979, -0.6571639, -0.3996071],
      [-1.121664, 0.2938926, -0.03144481],
      [-0.2348831, -1.063314, -0.3996071],
      [0.5181548, 0.2938926, -0.9953061],
      [-0.5850262, -0.112257, -0.9953061]
    ],
    face: [
      [0, 1, 4, 2],
      [0, 2, 6, 3],
      [1, 5, 8, 4],
      [3, 6, 9, 7],
      [5, 7, 9, 8],
      [0, 3, 7, 5, 1],
      [2, 4, 8, 9, 6]
    ]
  };
  polyhedra[7] = {
    vertex: [
      [0, 0, 1.118034],
      [0.8944272, 0, 0.6708204],
      [-0.2236068, 0.8660254, 0.6708204],
      [-0.7826238, -0.4330127, 0.6708204],
      [0.6708204, 0.8660254, 0.2236068],
      [1.006231, -0.4330127, -0.2236068],
      [-1.006231, 0.4330127, 0.2236068],
      [-0.6708204, -0.8660254, -0.2236068],
      [0.7826238, 0.4330127, -0.6708204],
      [0.2236068, -0.8660254, -0.6708204],
      [-0.8944272, 0, -0.6708204],
      [0, 0, -1.118034]
    ],
    face: [
      [0, 1, 4, 2],
      [0, 2, 6, 3],
      [1, 5, 8, 4],
      [3, 6, 10, 7],
      [5, 9, 11, 8],
      [7, 10, 11, 9],
      [0, 3, 7, 9, 5, 1],
      [2, 4, 8, 11, 10, 6]
    ]
  };
  polyhedra[8] = {
    vertex: [
      [-0.729665, 0.670121, 0.319155],
      [-0.655235, -0.29213, -0.754096],
      [-0.093922, -0.607123, 0.537818],
      [0.702196, 0.595691, 0.485187],
      [0.776626, -0.36656, -0.588064]
    ],
    face: [
      [1, 4, 2],
      [0, 1, 2],
      [3, 0, 2],
      [4, 3, 2],
      [4, 1, 0, 3]
    ]
  };
  polyhedra[9] = {
    vertex: [
      [-0.868849, -0.100041, 0.61257],
      [-0.329458, 0.976099, 0.28078],
      [-0.26629, -0.013796, -0.477654],
      [-0.13392, -1.034115, 0.229829],
      [0.738834, 0.707117, -0.307018],
      [0.859683, -0.535264, -0.338508]
    ],
    face: [
      [3, 0, 2],
      [5, 3, 2],
      [4, 5, 2],
      [1, 4, 2],
      [0, 1, 2],
      [0, 3, 5, 4, 1]
    ]
  };
  polyhedra[10] = {
    vertex: [
      [-0.610389, 0.243975, 0.531213],
      [-0.187812, -0.48795, -0.664016],
      [-0.187812, 0.9759, -0.664016],
      [0.187812, -0.9759, 0.664016],
      [0.798201, 0.243975, 0.132803]
    ],
    face: [
      [1, 3, 0],
      [3, 4, 0],
      [3, 1, 4],
      [0, 2, 1],
      [0, 4, 2],
      [2, 4, 1]
    ]
  };
  polyhedra[11] = {
    vertex: [
      [-1.028778, 0.392027, -0.048786],
      [-0.640503, -0.646161, 0.621837],
      [-0.125162, -0.395663, -0.540059],
      [4683e-6, 0.888447, -0.651988],
      [0.125161, 0.395663, 0.540059],
      [0.632925, -0.791376, 0.433102],
      [1.031672, 0.157063, -0.354165]
    ],
    face: [
      [3, 2, 0],
      [2, 1, 0],
      [2, 5, 1],
      [0, 4, 3],
      [0, 1, 4],
      [4, 1, 5],
      [2, 3, 6],
      [3, 4, 6],
      [5, 2, 6],
      [4, 5, 6]
    ]
  };
  polyhedra[12] = {
    vertex: [
      [-0.669867, 0.334933, -0.529576],
      [-0.669867, 0.334933, 0.529577],
      [-0.4043, 1.212901, 0],
      [-0.334933, -0.669867, -0.529576],
      [-0.334933, -0.669867, 0.529577],
      [0.334933, 0.669867, -0.529576],
      [0.334933, 0.669867, 0.529577],
      [0.4043, -1.212901, 0],
      [0.669867, -0.334933, -0.529576],
      [0.669867, -0.334933, 0.529577]
    ],
    face: [
      [8, 9, 7],
      [6, 5, 2],
      [3, 8, 7],
      [5, 0, 2],
      [4, 3, 7],
      [0, 1, 2],
      [9, 4, 7],
      [1, 6, 2],
      [9, 8, 5, 6],
      [8, 3, 0, 5],
      [3, 4, 1, 0],
      [4, 9, 6, 1]
    ]
  };
  polyhedra[13] = {
    vertex: [
      [-0.931836, 0.219976, -0.264632],
      [-0.636706, 0.318353, 0.692816],
      [-0.613483, -0.735083, -0.264632],
      [-0.326545, 0.979634, 0],
      [-0.318353, -0.636706, 0.692816],
      [-0.159176, 0.477529, -0.856368],
      [0.159176, -0.477529, -0.856368],
      [0.318353, 0.636706, 0.692816],
      [0.326545, -0.979634, 0],
      [0.613482, 0.735082, -0.264632],
      [0.636706, -0.318353, 0.692816],
      [0.931835, -0.219977, -0.264632]
    ],
    face: [
      [11, 10, 8],
      [7, 9, 3],
      [6, 11, 8],
      [9, 5, 3],
      [2, 6, 8],
      [5, 0, 3],
      [4, 2, 8],
      [0, 1, 3],
      [10, 4, 8],
      [1, 7, 3],
      [10, 11, 9, 7],
      [11, 6, 5, 9],
      [6, 2, 0, 5],
      [2, 4, 1, 0],
      [4, 10, 7, 1]
    ]
  };
  polyhedra[14] = {
    vertex: [
      [-0.93465, 0.300459, -0.271185],
      [-0.838689, -0.260219, -0.516017],
      [-0.711319, 0.717591, 0.128359],
      [-0.710334, -0.156922, 0.080946],
      [-0.599799, 0.556003, -0.725148],
      [-0.503838, -4675e-6, -0.969981],
      [-0.487004, 0.26021, 0.48049],
      [-0.460089, -0.750282, -0.512622],
      [-0.376468, 0.973135, -0.325605],
      [-0.331735, -0.646985, 0.084342],
      [-0.254001, 0.831847, 0.530001],
      [-0.125239, -0.494738, -0.966586],
      [0.029622, 0.027949, 0.730817],
      [0.056536, -0.982543, -0.262295],
      [0.08085, 1.087391, 0.076037],
      [0.125583, -0.532729, 0.485984],
      [0.262625, 0.599586, 0.780328],
      [0.391387, -0.726999, -0.716259],
      [0.513854, -0.868287, 0.139347],
      [0.597475, 0.85513, 0.326364],
      [0.641224, 0.109523, 0.783723],
      [0.737185, -0.451155, 0.538891],
      [0.848705, -0.612742, -0.314616],
      [0.976075, 0.365067, 0.32976],
      [1.072036, -0.19561, 0.084927]
    ],
    face: [
      [15, 18, 21],
      [12, 20, 16],
      [6, 10, 2],
      [3, 0, 1],
      [9, 7, 13],
      [2, 8, 4, 0],
      [0, 4, 5, 1],
      [1, 5, 11, 7],
      [7, 11, 17, 13],
      [13, 17, 22, 18],
      [18, 22, 24, 21],
      [21, 24, 23, 20],
      [20, 23, 19, 16],
      [16, 19, 14, 10],
      [10, 14, 8, 2],
      [15, 9, 13, 18],
      [12, 15, 21, 20],
      [6, 12, 16, 10],
      [3, 6, 2, 0],
      [9, 3, 1, 7],
      [9, 15, 12, 6, 3],
      [22, 17, 11, 5, 4, 8, 14, 19, 23, 24]
    ]
  };
  const type = options.type && (options.type < 0 || options.type >= polyhedra.length) ? 0 : options.type || 0;
  const size = options.size;
  const sizeX = options.sizeX || size || 1;
  const sizeY = options.sizeY || size || 1;
  const sizeZ = options.sizeZ || size || 1;
  const data = options.custom || polyhedra[type];
  const nbfaces = data.face.length;
  const faceUV = options.faceUV || new Array(nbfaces);
  const faceColors = options.faceColors;
  const flat = options.flat === void 0 ? true : options.flat;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const positions = new Array();
  const indices = new Array();
  const normals = new Array();
  const uvs = new Array();
  const colors = new Array();
  let index = 0;
  let faceIdx = 0;
  const indexes = new Array();
  let i = 0;
  let f = 0;
  let u, v, ang, x, y, tmp;
  if (flat) {
    for (f = 0; f < nbfaces; f++) {
      if (faceColors && faceColors[f] === void 0) {
        faceColors[f] = new Color4(1, 1, 1, 1);
      }
      if (faceUV && faceUV[f] === void 0) {
        faceUV[f] = new Vector4(0, 0, 1, 1);
      }
    }
  }
  if (!flat) {
    for (i = 0; i < data.vertex.length; i++) {
      positions.push(data.vertex[i][0] * sizeX, data.vertex[i][1] * sizeY, data.vertex[i][2] * sizeZ);
      uvs.push(0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 : 0);
    }
    for (f = 0; f < nbfaces; f++) {
      for (i = 0; i < data.face[f].length - 2; i++) {
        indices.push(data.face[f][0], data.face[f][i + 2], data.face[f][i + 1]);
      }
    }
  } else {
    for (f = 0; f < nbfaces; f++) {
      const fl = data.face[f].length;
      ang = 2 * Math.PI / fl;
      x = 0.5 * Math.tan(ang / 2);
      y = 0.5;
      for (i = 0; i < fl; i++) {
        positions.push(data.vertex[data.face[f][i]][0] * sizeX, data.vertex[data.face[f][i]][1] * sizeY, data.vertex[data.face[f][i]][2] * sizeZ);
        indexes.push(index);
        index++;
        u = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * (0.5 + x);
        v = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * (y - 0.5);
        uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
        tmp = x * Math.cos(ang) - y * Math.sin(ang);
        y = x * Math.sin(ang) + y * Math.cos(ang);
        x = tmp;
        if (faceColors) {
          colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);
        }
      }
      for (i = 0; i < fl - 2; i++) {
        indices.push(indexes[0 + faceIdx], indexes[i + 2 + faceIdx], indexes[i + 1 + faceIdx]);
      }
      faceIdx += fl;
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.positions = positions;
  vertexData.indices = indices;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors && flat) {
    vertexData.colors = colors;
  }
  return vertexData;
}
function CreatePolyhedron(name137, options = {}, scene = null) {
  const polyhedron = new Mesh(name137, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  polyhedron._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreatePolyhedronVertexData(options);
  vertexData.applyToMesh(polyhedron, options.updatable);
  return polyhedron;
}
var PolyhedronBuilder = {
  CreatePolyhedron
};
VertexData.CreatePolyhedron = CreatePolyhedronVertexData;
Mesh.CreatePolyhedron = (name137, options, scene) => {
  return CreatePolyhedron(name137, options, scene);
};

// node_modules/@babylonjs/core/Gizmos/scaleGizmo.js
var ScaleGizmo = class extends Gizmo {
  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, thickness = 1, gizmoManager) {
    super(gizmoLayer);
    this._meshAttached = null;
    this._nodeAttached = null;
    this._sensitivity = 1;
    this._observables = [];
    this._gizmoAxisCache = /* @__PURE__ */ new Map();
    this.onDragStartObservable = new Observable();
    this.onDragEndObservable = new Observable();
    this.uniformScaleGizmo = this._createUniformScaleMesh();
    this.xGizmo = new AxisScaleGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, this, thickness);
    this.yGizmo = new AxisScaleGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, this, thickness);
    this.zGizmo = new AxisScaleGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, this, thickness);
    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {
      gizmo.dragBehavior.onDragStartObservable.add(() => {
        this.onDragStartObservable.notifyObservers({});
      });
      gizmo.dragBehavior.onDragEndObservable.add(() => {
        this.onDragEndObservable.notifyObservers({});
      });
    });
    this.attachedMesh = null;
    this.attachedNode = null;
    if (gizmoManager) {
      gizmoManager.addToAxisCache(this._gizmoAxisCache);
    } else {
      Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);
    }
  }
  get coloredMaterial() {
    return this._coloredMaterial;
  }
  get hoverMaterial() {
    return this._hoverMaterial;
  }
  get disableMaterial() {
    return this._disableMaterial;
  }
  get attachedMesh() {
    return this._meshAttached;
  }
  set attachedMesh(mesh) {
    this._meshAttached = mesh;
    this._nodeAttached = mesh;
    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {
      if (gizmo.isEnabled) {
        gizmo.attachedMesh = mesh;
      } else {
        gizmo.attachedMesh = null;
      }
    });
  }
  get attachedNode() {
    return this._nodeAttached;
  }
  set attachedNode(node) {
    this._meshAttached = null;
    this._nodeAttached = node;
    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {
      if (gizmo.isEnabled) {
        gizmo.attachedNode = node;
      } else {
        gizmo.attachedNode = null;
      }
    });
  }
  set updateScale(value) {
    if (this.xGizmo) {
      this.xGizmo.updateScale = value;
      this.yGizmo.updateScale = value;
      this.zGizmo.updateScale = value;
    }
  }
  get updateScale() {
    return this.xGizmo.updateScale;
  }
  get isHovered() {
    let hovered = false;
    [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {
      hovered = hovered || gizmo.isHovered;
    });
    return hovered;
  }
  _createUniformScaleMesh() {
    this._coloredMaterial = new StandardMaterial("", this.gizmoLayer.utilityLayerScene);
    this._coloredMaterial.diffuseColor = Color3.Gray();
    this._hoverMaterial = new StandardMaterial("", this.gizmoLayer.utilityLayerScene);
    this._hoverMaterial.diffuseColor = Color3.Yellow();
    this._disableMaterial = new StandardMaterial("", this.gizmoLayer.utilityLayerScene);
    this._disableMaterial.diffuseColor = Color3.Gray();
    this._disableMaterial.alpha = 0.4;
    const uniformScaleGizmo = new AxisScaleGizmo(new Vector3(0, 1, 0), Color3.Gray().scale(0.5), this.gizmoLayer, this);
    uniformScaleGizmo.updateGizmoRotationToMatchAttachedMesh = false;
    uniformScaleGizmo.uniformScaling = true;
    this._uniformScalingMesh = CreatePolyhedron("uniform", { type: 1 }, uniformScaleGizmo.gizmoLayer.utilityLayerScene);
    this._uniformScalingMesh.scaling.scaleInPlace(0.01);
    this._uniformScalingMesh.visibility = 0;
    this._octahedron = CreatePolyhedron("", { type: 1 }, uniformScaleGizmo.gizmoLayer.utilityLayerScene);
    this._octahedron.scaling.scaleInPlace(7e-3);
    this._uniformScalingMesh.addChild(this._octahedron);
    uniformScaleGizmo.setCustomMesh(this._uniformScalingMesh, true);
    const light = this.gizmoLayer._getSharedGizmoLight();
    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._octahedron);
    const cache = {
      gizmoMeshes: [this._octahedron, this._uniformScalingMesh],
      colliderMeshes: [this._uniformScalingMesh],
      material: this._coloredMaterial,
      hoverMaterial: this._hoverMaterial,
      disableMaterial: this._disableMaterial,
      active: false,
      dragBehavior: uniformScaleGizmo.dragBehavior
    };
    this.addToAxisCache(uniformScaleGizmo._rootMesh, cache);
    return uniformScaleGizmo;
  }
  set updateGizmoRotationToMatchAttachedMesh(value) {
    if (!value) {
      Logger.Warn("Setting updateGizmoRotationToMatchAttachedMesh = false on scaling gizmo is not supported.");
    } else {
      this._updateGizmoRotationToMatchAttachedMesh = value;
      [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {
        if (gizmo) {
          gizmo.updateGizmoRotationToMatchAttachedMesh = value;
        }
      });
    }
  }
  get updateGizmoRotationToMatchAttachedMesh() {
    return this._updateGizmoRotationToMatchAttachedMesh;
  }
  set snapDistance(value) {
    this._snapDistance = value;
    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {
      if (gizmo) {
        gizmo.snapDistance = value;
      }
    });
  }
  get snapDistance() {
    return this._snapDistance;
  }
  set scaleRatio(value) {
    this._scaleRatio = value;
    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {
      if (gizmo) {
        gizmo.scaleRatio = value;
      }
    });
  }
  get scaleRatio() {
    return this._scaleRatio;
  }
  set sensitivity(value) {
    this._sensitivity = value;
    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {
      if (gizmo) {
        gizmo.sensitivity = value;
      }
    });
  }
  get sensitivity() {
    return this._sensitivity;
  }
  addToAxisCache(mesh, cache) {
    this._gizmoAxisCache.set(mesh, cache);
  }
  dispose() {
    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {
      if (gizmo) {
        gizmo.dispose();
      }
    });
    this._observables.forEach((obs) => {
      this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);
    });
    this.onDragStartObservable.clear();
    this.onDragEndObservable.clear();
    [this._uniformScalingMesh, this._octahedron].forEach((msh) => {
      if (msh) {
        msh.dispose();
      }
    });
    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach((matl) => {
      if (matl) {
        matl.dispose();
      }
    });
  }
};

// node_modules/@babylonjs/core/Gizmos/gizmoManager.js
var GizmoManager = class {
  constructor(_scene, thickness = 1, utilityLayer = UtilityLayerRenderer.DefaultUtilityLayer, keepDepthUtilityLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {
    this._scene = _scene;
    this.clearGizmoOnEmptyPointerEvent = false;
    this.enableAutoPicking = true;
    this.onAttachedToMeshObservable = new Observable();
    this.onAttachedToNodeObservable = new Observable();
    this._gizmosEnabled = { positionGizmo: false, rotationGizmo: false, scaleGizmo: false, boundingBoxGizmo: false };
    this._pointerObservers = [];
    this._attachedMesh = null;
    this._attachedNode = null;
    this._boundingBoxColor = Color3.FromHexString("#0984e3");
    this._thickness = 1;
    this._scaleRatio = 1;
    this._gizmoAxisCache = /* @__PURE__ */ new Map();
    this.boundingBoxDragBehavior = new SixDofDragBehavior();
    this.attachableMeshes = null;
    this.attachableNodes = null;
    this.usePointerToAttachGizmos = true;
    this._defaultUtilityLayer = utilityLayer;
    this._defaultKeepDepthUtilityLayer = keepDepthUtilityLayer;
    this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;
    this._thickness = thickness;
    this.gizmos = { positionGizmo: null, rotationGizmo: null, scaleGizmo: null, boundingBoxGizmo: null };
    const attachToMeshPointerObserver = this._attachToMeshPointerObserver(_scene);
    const gizmoAxisPointerObserver = Gizmo.GizmoAxisPointerObserver(this._defaultUtilityLayer, this._gizmoAxisCache);
    this._pointerObservers = [attachToMeshPointerObserver, gizmoAxisPointerObserver];
  }
  get keepDepthUtilityLayer() {
    return this._defaultKeepDepthUtilityLayer;
  }
  get utilityLayer() {
    return this._defaultUtilityLayer;
  }
  get isHovered() {
    let hovered = false;
    for (const key in this.gizmos) {
      const gizmo = this.gizmos[key];
      if (gizmo && gizmo.isHovered) {
        hovered = true;
        break;
      }
    }
    return hovered;
  }
  set scaleRatio(value) {
    this._scaleRatio = value;
    [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo].forEach((gizmo) => {
      if (gizmo) {
        gizmo.scaleRatio = value;
      }
    });
  }
  get scaleRatio() {
    return this._scaleRatio;
  }
  _attachToMeshPointerObserver(scene) {
    const pointerObserver = scene.onPointerObservable.add((pointerInfo) => {
      if (!this.usePointerToAttachGizmos) {
        return;
      }
      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {
          if (this.enableAutoPicking) {
            let node = pointerInfo.pickInfo.pickedMesh;
            if (this.attachableMeshes == null) {
              while (node && node.parent != null) {
                node = node.parent;
              }
            } else {
              let found = false;
              this.attachableMeshes.forEach((mesh) => {
                if (node && (node == mesh || node.isDescendantOf(mesh))) {
                  node = mesh;
                  found = true;
                }
              });
              if (!found) {
                node = null;
              }
            }
            if (node instanceof AbstractMesh) {
              if (this._attachedMesh != node) {
                this.attachToMesh(node);
              }
            } else {
              if (this.clearGizmoOnEmptyPointerEvent) {
                this.attachToMesh(null);
              }
            }
          }
        } else {
          if (this.clearGizmoOnEmptyPointerEvent) {
            this.attachToMesh(null);
          }
        }
      }
    });
    return pointerObserver;
  }
  attachToMesh(mesh) {
    if (this._attachedMesh) {
      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);
    }
    if (this._attachedNode) {
      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);
    }
    this._attachedMesh = mesh;
    this._attachedNode = null;
    for (const key in this.gizmos) {
      const gizmo = this.gizmos[key];
      if (gizmo && this._gizmosEnabled[key]) {
        gizmo.attachedMesh = mesh;
      }
    }
    if (this.boundingBoxGizmoEnabled && this._attachedMesh) {
      this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);
    }
    this.onAttachedToMeshObservable.notifyObservers(mesh);
  }
  attachToNode(node) {
    if (this._attachedMesh) {
      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);
    }
    if (this._attachedNode) {
      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);
    }
    this._attachedMesh = null;
    this._attachedNode = node;
    for (const key in this.gizmos) {
      const gizmo = this.gizmos[key];
      if (gizmo && this._gizmosEnabled[key]) {
        gizmo.attachedNode = node;
      }
    }
    if (this.boundingBoxGizmoEnabled && this._attachedNode) {
      this._attachedNode.addBehavior(this.boundingBoxDragBehavior);
    }
    this.onAttachedToNodeObservable.notifyObservers(node);
  }
  set positionGizmoEnabled(value) {
    if (value) {
      if (!this.gizmos.positionGizmo) {
        this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer, this._thickness, this);
      }
      if (this._attachedNode) {
        this.gizmos.positionGizmo.attachedNode = this._attachedNode;
      } else {
        this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;
      }
    } else if (this.gizmos.positionGizmo) {
      this.gizmos.positionGizmo.attachedNode = null;
    }
    this._gizmosEnabled.positionGizmo = value;
  }
  get positionGizmoEnabled() {
    return this._gizmosEnabled.positionGizmo;
  }
  set rotationGizmoEnabled(value) {
    if (value) {
      if (!this.gizmos.rotationGizmo) {
        this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer, 32, false, this._thickness, this);
      }
      if (this._attachedNode) {
        this.gizmos.rotationGizmo.attachedNode = this._attachedNode;
      } else {
        this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;
      }
    } else if (this.gizmos.rotationGizmo) {
      this.gizmos.rotationGizmo.attachedNode = null;
    }
    this._gizmosEnabled.rotationGizmo = value;
  }
  get rotationGizmoEnabled() {
    return this._gizmosEnabled.rotationGizmo;
  }
  set scaleGizmoEnabled(value) {
    if (value) {
      this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer, this._thickness, this);
      if (this._attachedNode) {
        this.gizmos.scaleGizmo.attachedNode = this._attachedNode;
      } else {
        this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;
      }
    } else if (this.gizmos.scaleGizmo) {
      this.gizmos.scaleGizmo.attachedNode = null;
    }
    this._gizmosEnabled.scaleGizmo = value;
  }
  get scaleGizmoEnabled() {
    return this._gizmosEnabled.scaleGizmo;
  }
  set boundingBoxGizmoEnabled(value) {
    if (value) {
      this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);
      if (this._attachedMesh) {
        this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;
      } else {
        this.gizmos.boundingBoxGizmo.attachedNode = this._attachedNode;
      }
      if (this._attachedMesh) {
        this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);
        this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);
      } else if (this._attachedNode) {
        this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);
        this._attachedNode.addBehavior(this.boundingBoxDragBehavior);
      }
    } else if (this.gizmos.boundingBoxGizmo) {
      if (this._attachedMesh) {
        this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);
      } else if (this._attachedNode) {
        this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);
      }
      this.gizmos.boundingBoxGizmo.attachedNode = null;
    }
    this._gizmosEnabled.boundingBoxGizmo = value;
  }
  get boundingBoxGizmoEnabled() {
    return this._gizmosEnabled.boundingBoxGizmo;
  }
  addToAxisCache(gizmoAxisCache) {
    if (gizmoAxisCache.size > 0) {
      gizmoAxisCache.forEach((v, k) => {
        this._gizmoAxisCache.set(k, v);
      });
    }
  }
  dispose() {
    var _a, _b;
    this._pointerObservers.forEach((observer) => {
      this._scene.onPointerObservable.remove(observer);
    });
    for (const key in this.gizmos) {
      const gizmo = this.gizmos[key];
      if (gizmo) {
        gizmo.dispose();
      }
    }
    if (this._defaultKeepDepthUtilityLayer !== UtilityLayerRenderer._DefaultKeepDepthUtilityLayer) {
      (_a = this._defaultKeepDepthUtilityLayer) === null || _a === void 0 ? void 0 : _a.dispose();
    }
    if (this._defaultUtilityLayer !== UtilityLayerRenderer._DefaultUtilityLayer) {
      (_b = this._defaultUtilityLayer) === null || _b === void 0 ? void 0 : _b.dispose();
    }
    this.boundingBoxDragBehavior.detach();
    this.onAttachedToMeshObservable.clear();
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/discBuilder.js
function CreateDiscVertexData(options) {
  const positions = new Array();
  const indices = new Array();
  const normals = new Array();
  const uvs = new Array();
  const radius = options.radius || 0.5;
  const tessellation = options.tessellation || 64;
  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  positions.push(0, 0, 0);
  uvs.push(0.5, 0.5);
  const theta = Math.PI * 2 * arc;
  const step = arc === 1 ? theta / tessellation : theta / (tessellation - 1);
  let a = 0;
  for (let t = 0; t < tessellation; t++) {
    const x = Math.cos(a);
    const y = Math.sin(a);
    const u = (x + 1) / 2;
    const v = (1 - y) / 2;
    positions.push(radius * x, radius * y, 0);
    uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
    a += step;
  }
  if (arc === 1) {
    positions.push(positions[3], positions[4], positions[5]);
    uvs.push(uvs[2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - uvs[3] : uvs[3]);
  }
  const vertexNb = positions.length / 3;
  for (let i = 1; i < vertexNb - 1; i++) {
    indices.push(i + 1, 0, i);
  }
  VertexData.ComputeNormals(positions, indices, normals);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateDisc(name137, options = {}, scene = null) {
  const disc = new Mesh(name137, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  disc._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateDiscVertexData(options);
  vertexData.applyToMesh(disc, options.updatable);
  return disc;
}
var DiscBuilder = {
  CreateDisc
};
VertexData.CreateDisc = CreateDiscVertexData;
Mesh.CreateDisc = (name137, radius, tessellation, scene = null, updatable, sideOrientation) => {
  const options = {
    radius,
    tessellation,
    sideOrientation,
    updatable
  };
  return CreateDisc(name137, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/hemisphereBuilder.js
function CreateHemisphere(name137, options = {}, scene) {
  if (!options.diameter) {
    options.diameter = 1;
  }
  if (!options.segments) {
    options.segments = 16;
  }
  const halfSphere = CreateSphere("", { slice: 0.5, diameter: options.diameter, segments: options.segments }, scene);
  const disc = CreateDisc("", { radius: options.diameter / 2, tessellation: options.segments * 3 + (4 - options.segments) }, scene);
  disc.rotation.x = -Math.PI / 2;
  disc.parent = halfSphere;
  const merged = Mesh.MergeMeshes([disc, halfSphere], true);
  merged.name = name137;
  return merged;
}
var HemisphereBuilder = {
  CreateHemisphere
};
Mesh.CreateHemisphere = (name137, segments, diameter, scene) => {
  const options = {
    segments,
    diameter
  };
  return CreateHemisphere(name137, options, scene);
};

// node_modules/@babylonjs/core/Gizmos/lightGizmo.js
var LightGizmo = class extends Gizmo {
  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer) {
    super(gizmoLayer);
    this._cachedPosition = new Vector3();
    this._cachedForward = new Vector3(0, 0, 1);
    this._pointerObserver = null;
    this.onClickedObservable = new Observable();
    this._light = null;
    this.attachedMesh = new AbstractMesh("", this.gizmoLayer.utilityLayerScene);
    this._attachedMeshParent = new TransformNode("parent", this.gizmoLayer.utilityLayerScene);
    this.attachedMesh.parent = this._attachedMeshParent;
    this._material = new StandardMaterial("light", this.gizmoLayer.utilityLayerScene);
    this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);
    this._material.specularColor = new Color3(0.1, 0.1, 0.1);
    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
      if (!this._light) {
        return;
      }
      this._isHovered = !!(pointerInfo.pickInfo && this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);
      if (this._isHovered && pointerInfo.event.button === 0) {
        this.onClickedObservable.notifyObservers(this._light);
      }
    }, PointerEventTypes.POINTERDOWN);
  }
  get attachedNode() {
    return this.attachedMesh;
  }
  set attachedNode(value) {
    console.warn("Nodes cannot be attached to LightGizmo. Attach to a mesh instead.");
  }
  set light(light) {
    this._light = light;
    if (light) {
      if (this._lightMesh) {
        this._lightMesh.dispose();
      }
      if (light instanceof HemisphericLight) {
        this._lightMesh = LightGizmo._CreateHemisphericLightMesh(this.gizmoLayer.utilityLayerScene);
      } else if (light instanceof DirectionalLight) {
        this._lightMesh = LightGizmo._CreateDirectionalLightMesh(this.gizmoLayer.utilityLayerScene);
      } else if (light instanceof SpotLight) {
        this._lightMesh = LightGizmo._CreateSpotLightMesh(this.gizmoLayer.utilityLayerScene);
      } else {
        this._lightMesh = LightGizmo._CreatePointLightMesh(this.gizmoLayer.utilityLayerScene);
      }
      this._lightMesh.getChildMeshes(false).forEach((m) => {
        m.material = this._material;
      });
      this._lightMesh.parent = this._rootMesh;
      const gizmoLight = this.gizmoLayer._getSharedGizmoLight();
      gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._lightMesh.getChildMeshes(false));
      this._lightMesh.rotationQuaternion = new Quaternion();
      if (!this.attachedMesh.reservedDataStore) {
        this.attachedMesh.reservedDataStore = {};
      }
      this.attachedMesh.reservedDataStore.lightGizmo = this;
      if (light.parent) {
        this._attachedMeshParent.freezeWorldMatrix(light.parent.getWorldMatrix());
      }
      if (light.position) {
        this.attachedMesh.position.copyFrom(light.position);
        this.attachedMesh.computeWorldMatrix(true);
        this._cachedPosition.copyFrom(this.attachedMesh.position);
      }
      if (light.direction) {
        this.attachedMesh.setDirection(light.direction);
        this.attachedMesh.computeWorldMatrix(true);
        this._cachedForward.copyFrom(this.attachedMesh.forward);
      }
      this._update();
    }
  }
  get light() {
    return this._light;
  }
  get material() {
    return this._material;
  }
  _update() {
    super._update();
    if (!this._light) {
      return;
    }
    if (this._light.parent) {
      this._attachedMeshParent.freezeWorldMatrix(this._light.parent.getWorldMatrix());
    }
    if (this._light.position) {
      if (!this.attachedMesh.position.equals(this._cachedPosition)) {
        const position = this.attachedMesh.position;
        this._light.position = new Vector3(position.x, position.y, position.z);
        this._cachedPosition.copyFrom(this.attachedMesh.position);
      } else {
        this.attachedMesh.position.copyFrom(this._light.position);
        this.attachedMesh.computeWorldMatrix(true);
        this._cachedPosition.copyFrom(this.attachedMesh.position);
      }
    }
    if (this._light.direction) {
      if (Vector3.DistanceSquared(this.attachedMesh.forward, this._cachedForward) > 1e-4) {
        const direction = this.attachedMesh.forward;
        this._light.direction = new Vector3(direction.x, direction.y, direction.z);
        this._cachedForward.copyFrom(this.attachedMesh.forward);
      } else if (Vector3.DistanceSquared(this.attachedMesh.forward, this._light.direction) > 1e-4) {
        this.attachedMesh.setDirection(this._light.direction);
        this.attachedMesh.computeWorldMatrix(true);
        this._cachedForward.copyFrom(this.attachedMesh.forward);
      }
    }
  }
  dispose() {
    this.onClickedObservable.clear();
    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
    this._material.dispose();
    super.dispose();
    this._attachedMeshParent.dispose();
  }
  static _CreateHemisphericLightMesh(scene) {
    const root = new Mesh("hemisphereLight", scene);
    const hemisphere = CreateHemisphere(root.name, { segments: 10, diameter: 1 }, scene);
    hemisphere.position.z = -0.15;
    hemisphere.rotation.x = Math.PI / 2;
    hemisphere.parent = root;
    const lines = this._CreateLightLines(3, scene);
    lines.parent = root;
    root.scaling.scaleInPlace(LightGizmo._Scale);
    root.rotation.x = Math.PI / 2;
    return root;
  }
  static _CreatePointLightMesh(scene) {
    const root = new Mesh("pointLight", scene);
    const sphere = CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);
    sphere.rotation.x = Math.PI / 2;
    sphere.parent = root;
    const lines = this._CreateLightLines(5, scene);
    lines.parent = root;
    root.scaling.scaleInPlace(LightGizmo._Scale);
    root.rotation.x = Math.PI / 2;
    return root;
  }
  static _CreateSpotLightMesh(scene) {
    const root = new Mesh("spotLight", scene);
    const sphere = CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);
    sphere.parent = root;
    const hemisphere = CreateHemisphere(root.name, { segments: 10, diameter: 2 }, scene);
    hemisphere.parent = root;
    hemisphere.rotation.x = -Math.PI / 2;
    const lines = this._CreateLightLines(2, scene);
    lines.parent = root;
    root.scaling.scaleInPlace(LightGizmo._Scale);
    root.rotation.x = Math.PI / 2;
    return root;
  }
  static _CreateDirectionalLightMesh(scene) {
    const root = new Mesh("directionalLight", scene);
    const mesh = new Mesh(root.name, scene);
    mesh.parent = root;
    const sphere = CreateSphere(root.name, { diameter: 1.2, segments: 10 }, scene);
    sphere.parent = mesh;
    const line = CreateCylinder(root.name, {
      updatable: false,
      height: 6,
      diameterTop: 0.3,
      diameterBottom: 0.3,
      tessellation: 6,
      subdivisions: 1
    }, scene);
    line.parent = mesh;
    let left = line.clone(root.name);
    left.scaling.y = 0.5;
    left.position.x += 1.25;
    let right = line.clone(root.name);
    right.scaling.y = 0.5;
    right.position.x += -1.25;
    const arrowHead = CreateCylinder(root.name, {
      updatable: false,
      height: 1,
      diameterTop: 0,
      diameterBottom: 0.6,
      tessellation: 6,
      subdivisions: 1
    }, scene);
    arrowHead.position.y += 3;
    arrowHead.parent = mesh;
    left = arrowHead.clone(root.name);
    left.position.y = 1.5;
    left.position.x += 1.25;
    right = arrowHead.clone(root.name);
    right.position.y = 1.5;
    right.position.x += -1.25;
    mesh.scaling.scaleInPlace(LightGizmo._Scale);
    mesh.rotation.z = Math.PI / 2;
    mesh.rotation.y = Math.PI / 2;
    return root;
  }
};
LightGizmo._Scale = 7e-3;
LightGizmo._CreateLightLines = (levels, scene) => {
  const distFromSphere = 1.2;
  const root = new Mesh("root", scene);
  root.rotation.x = Math.PI / 2;
  const linePivot = new Mesh("linePivot", scene);
  linePivot.parent = root;
  const line = CreateCylinder("line", {
    updatable: false,
    height: 2,
    diameterTop: 0.2,
    diameterBottom: 0.3,
    tessellation: 6,
    subdivisions: 1
  }, scene);
  line.position.y = line.scaling.y / 2 + distFromSphere;
  line.parent = linePivot;
  if (levels < 2) {
    return linePivot;
  }
  for (let i = 0; i < 4; i++) {
    const l2 = linePivot.clone("lineParentClone");
    l2.rotation.z = Math.PI / 4;
    l2.rotation.y = Math.PI / 2 + Math.PI / 2 * i;
    l2.getChildMeshes()[0].scaling.y = 0.5;
    l2.getChildMeshes()[0].scaling.x = l2.getChildMeshes()[0].scaling.z = 0.8;
    l2.getChildMeshes()[0].position.y = l2.getChildMeshes()[0].scaling.y / 2 + distFromSphere;
  }
  if (levels < 3) {
    return root;
  }
  for (let i = 0; i < 4; i++) {
    const l2 = linePivot.clone("linePivotClone");
    l2.rotation.z = Math.PI / 2;
    l2.rotation.y = Math.PI / 2 * i;
  }
  if (levels < 4) {
    return root;
  }
  for (let i = 0; i < 4; i++) {
    const l2 = linePivot.clone("linePivotClone");
    l2.rotation.z = Math.PI + Math.PI / 4;
    l2.rotation.y = Math.PI / 2 + Math.PI / 2 * i;
    l2.getChildMeshes()[0].scaling.y = 0.5;
    l2.getChildMeshes()[0].scaling.x = l2.getChildMeshes()[0].scaling.z = 0.8;
    l2.getChildMeshes()[0].position.y = l2.getChildMeshes()[0].scaling.y / 2 + distFromSphere;
  }
  if (levels < 5) {
    return root;
  }
  const l = linePivot.clone("linePivotClone");
  l.rotation.z = Math.PI;
  return root;
};

// node_modules/@babylonjs/core/Gizmos/cameraGizmo.js
var CameraGizmo = class extends Gizmo {
  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer) {
    super(gizmoLayer);
    this._pointerObserver = null;
    this.onClickedObservable = new Observable();
    this._camera = null;
    this._invProjection = new Matrix();
    this._material = new StandardMaterial("cameraGizmoMaterial", this.gizmoLayer.utilityLayerScene);
    this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);
    this._material.specularColor = new Color3(0.1, 0.1, 0.1);
    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
      if (!this._camera) {
        return;
      }
      this._isHovered = !!(pointerInfo.pickInfo && this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);
      if (this._isHovered && pointerInfo.event.button === 0) {
        this.onClickedObservable.notifyObservers(this._camera);
      }
    }, PointerEventTypes.POINTERDOWN);
  }
  get displayFrustum() {
    return this._cameraLinesMesh.isEnabled();
  }
  set displayFrustum(value) {
    this._cameraLinesMesh.setEnabled(value);
  }
  set camera(camera) {
    this._camera = camera;
    this.attachedNode = camera;
    if (camera) {
      if (this._cameraMesh) {
        this._cameraMesh.dispose();
      }
      if (this._cameraLinesMesh) {
        this._cameraLinesMesh.dispose();
      }
      this._cameraMesh = CameraGizmo._CreateCameraMesh(this.gizmoLayer.utilityLayerScene);
      this._cameraLinesMesh = CameraGizmo._CreateCameraFrustum(this.gizmoLayer.utilityLayerScene);
      this._cameraMesh.getChildMeshes(false).forEach((m) => {
        m.material = this._material;
      });
      this._cameraMesh.parent = this._rootMesh;
      this._cameraLinesMesh.parent = this._rootMesh;
      if (this.gizmoLayer.utilityLayerScene.activeCamera && this.gizmoLayer.utilityLayerScene.activeCamera.maxZ < camera.maxZ * 1.5) {
        this.gizmoLayer.utilityLayerScene.activeCamera.maxZ = camera.maxZ * 1.5;
      }
      if (!this.attachedNode.reservedDataStore) {
        this.attachedNode.reservedDataStore = {};
      }
      this.attachedNode.reservedDataStore.cameraGizmo = this;
      const gizmoLight = this.gizmoLayer._getSharedGizmoLight();
      gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._cameraMesh.getChildMeshes(false));
      this._update();
    }
  }
  get camera() {
    return this._camera;
  }
  get material() {
    return this._material;
  }
  _update() {
    super._update();
    if (!this._camera) {
      return;
    }
    this._camera.getProjectionMatrix().invertToRef(this._invProjection);
    this._cameraLinesMesh.setPivotMatrix(this._invProjection, false);
    this._cameraLinesMesh.scaling.x = 1 / this._rootMesh.scaling.x;
    this._cameraLinesMesh.scaling.y = 1 / this._rootMesh.scaling.y;
    this._cameraLinesMesh.scaling.z = 1 / this._rootMesh.scaling.z;
    this._cameraMesh.parent = null;
    this._cameraMesh.rotation.y = Math.PI * 0.5 * (this._camera.getScene().useRightHandedSystem ? 1 : -1);
    this._cameraMesh.parent = this._rootMesh;
  }
  dispose() {
    this.onClickedObservable.clear();
    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
    if (this._cameraMesh) {
      this._cameraMesh.dispose();
    }
    if (this._cameraLinesMesh) {
      this._cameraLinesMesh.dispose();
    }
    this._material.dispose();
    super.dispose();
  }
  static _CreateCameraMesh(scene) {
    const root = new Mesh("rootCameraGizmo", scene);
    const mesh = new Mesh(root.name, scene);
    mesh.parent = root;
    const box = CreateBox(root.name, { width: 1, height: 0.8, depth: 0.5 }, scene);
    box.parent = mesh;
    const cyl1 = CreateCylinder(root.name, { height: 0.5, diameterTop: 0.8, diameterBottom: 0.8 }, scene);
    cyl1.parent = mesh;
    cyl1.position.y = 0.3;
    cyl1.position.x = -0.6;
    cyl1.rotation.x = Math.PI * 0.5;
    const cyl2 = CreateCylinder(root.name, { height: 0.5, diameterTop: 0.6, diameterBottom: 0.6 }, scene);
    cyl2.parent = mesh;
    cyl2.position.y = 0.5;
    cyl2.position.x = 0.4;
    cyl2.rotation.x = Math.PI * 0.5;
    const cyl3 = CreateCylinder(root.name, { height: 0.5, diameterTop: 0.5, diameterBottom: 0.5 }, scene);
    cyl3.parent = mesh;
    cyl3.position.y = 0;
    cyl3.position.x = 0.6;
    cyl3.rotation.z = Math.PI * 0.5;
    root.scaling.scaleInPlace(CameraGizmo._Scale);
    mesh.position.x = -0.9;
    return root;
  }
  static _CreateCameraFrustum(scene) {
    const root = new Mesh("rootCameraGizmo", scene);
    const mesh = new Mesh(root.name, scene);
    mesh.parent = root;
    for (let y = 0; y < 4; y += 2) {
      for (let x = 0; x < 4; x += 2) {
        let line = CreateLines("lines", { points: [new Vector3(-1 + x, -1 + y, -1), new Vector3(-1 + x, -1 + y, 1)] }, scene);
        line.parent = mesh;
        line.alwaysSelectAsActiveMesh = true;
        line.isPickable = false;
        line = CreateLines("lines", { points: [new Vector3(-1, -1 + x, -1 + y), new Vector3(1, -1 + x, -1 + y)] }, scene);
        line.parent = mesh;
        line.alwaysSelectAsActiveMesh = true;
        line.isPickable = false;
        line = CreateLines("lines", { points: [new Vector3(-1 + x, -1, -1 + y), new Vector3(-1 + x, 1, -1 + y)] }, scene);
        line.parent = mesh;
        line.alwaysSelectAsActiveMesh = true;
        line.isPickable = false;
      }
    }
    return root;
  }
};
CameraGizmo._Scale = 0.05;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurVaryingDeclaration.js
var name26 = "kernelBlurVaryingDeclaration";
var shader26 = `varying vec2 sampleCoord{X};`;
ShaderStore.IncludesShadersStore[name26] = shader26;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/packingFunctions.js
var name27 = "packingFunctions";
var shader27 = `vec4 pack(float depth)
{
const vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);
const vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);
vec4 res=fract(depth*bit_shift);
res-=res.xxyz*bit_mask;
return res;
}
float unpack(vec4 color)
{
const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);
return dot(color,bit_shift);
}`;
ShaderStore.IncludesShadersStore[name27] = shader27;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurFragment.js
var name28 = "kernelBlurFragment";
var shader28 = `#ifdef DOF
factor=sampleCoC(sampleCoord{X}); 
computedWeight=KERNEL_WEIGHT{X}*factor;
sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;
#endif
`;
ShaderStore.IncludesShadersStore[name28] = shader28;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurFragment2.js
var name29 = "kernelBlurFragment2";
var shader29 = `#ifdef DOF
factor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});
computedWeight=KERNEL_DEP_WEIGHT{X}*factor;
sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_DEP_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;
#endif
`;
ShaderStore.IncludesShadersStore[name29] = shader29;

// node_modules/@babylonjs/core/Shaders/kernelBlur.fragment.js
var name30 = "kernelBlurPixelShader";
var shader30 = `uniform sampler2D textureSampler;
uniform vec2 delta;
varying vec2 sampleCenter;
#ifdef DOF
uniform sampler2D circleOfConfusionSampler;
float sampleCoC(in vec2 offset) {
float coc=texture2D(circleOfConfusionSampler,offset).r;
return coc; 
}
#endif
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
#ifdef PACKEDFLOAT
#include<packingFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
float computedWeight=0.0;
#ifdef PACKEDFLOAT
float blend=0.;
#else
vec4 blend=vec4(0.);
#endif
#ifdef DOF
float sumOfWeights=CENTER_WEIGHT; 
float factor=0.0;
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;
#else
blend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;
#endif
#endif
#include<kernelBlurFragment>[0..varyingCount]
#include<kernelBlurFragment2>[0..depCount]
#ifdef PACKEDFLOAT
gl_FragColor=pack(blend);
#else
gl_FragColor=blend;
#endif
#ifdef DOF
gl_FragColor/=sumOfWeights;
#endif
}`;
ShaderStore.ShadersStore[name30] = shader30;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurVertex.js
var name31 = "kernelBlurVertex";
var shader31 = `sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};`;
ShaderStore.IncludesShadersStore[name31] = shader31;

// node_modules/@babylonjs/core/Shaders/kernelBlur.vertex.js
var name32 = "kernelBlurVertexShader";
var shader32 = `attribute vec2 position;
uniform vec2 delta;
varying vec2 sampleCenter;
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
sampleCenter=(position*madd+madd);
#include<kernelBlurVertex>[0..varyingCount]
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name32] = shader32;

// node_modules/@babylonjs/core/PostProcesses/blurPostProcess.js
var BlurPostProcess = class extends PostProcess {
  constructor(name137, direction, kernel, options, camera, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable, textureType = 0, defines = "", _blockCompilation = false, textureFormat = 5) {
    super(name137, "kernelBlur", ["delta", "direction"], ["circleOfConfusionSampler"], options, camera, samplingMode, engine, reusable, null, textureType, "kernelBlur", { varyingCount: 0, depCount: 0 }, true, textureFormat);
    this._blockCompilation = _blockCompilation;
    this._packedFloat = false;
    this._staticDefines = "";
    this._staticDefines = defines;
    this.direction = direction;
    this.onApplyObservable.add((effect) => {
      if (this._outputTexture) {
        effect.setFloat2("delta", 1 / this._outputTexture.width * this.direction.x, 1 / this._outputTexture.height * this.direction.y);
      } else {
        effect.setFloat2("delta", 1 / this.width * this.direction.x, 1 / this.height * this.direction.y);
      }
    });
    this.kernel = kernel;
  }
  set kernel(v) {
    if (this._idealKernel === v) {
      return;
    }
    v = Math.max(v, 1);
    this._idealKernel = v;
    this._kernel = this._nearestBestKernel(v);
    if (!this._blockCompilation) {
      this._updateParameters();
    }
  }
  get kernel() {
    return this._idealKernel;
  }
  set packedFloat(v) {
    if (this._packedFloat === v) {
      return;
    }
    this._packedFloat = v;
    if (!this._blockCompilation) {
      this._updateParameters();
    }
  }
  get packedFloat() {
    return this._packedFloat;
  }
  getClassName() {
    return "BlurPostProcess";
  }
  updateEffect(defines = null, uniforms = null, samplers = null, indexParameters, onCompiled, onError) {
    this._updateParameters(onCompiled, onError);
  }
  _updateParameters(onCompiled, onError) {
    const N = this._kernel;
    const centerIndex = (N - 1) / 2;
    let offsets = [];
    let weights = [];
    let totalWeight = 0;
    for (let i = 0; i < N; i++) {
      const u = i / (N - 1);
      const w = this._gaussianWeight(u * 2 - 1);
      offsets[i] = i - centerIndex;
      weights[i] = w;
      totalWeight += w;
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] /= totalWeight;
    }
    const linearSamplingWeights = [];
    const linearSamplingOffsets = [];
    const linearSamplingMap = [];
    for (let i = 0; i <= centerIndex; i += 2) {
      const j = Math.min(i + 1, Math.floor(centerIndex));
      const singleCenterSample = i === j;
      if (singleCenterSample) {
        linearSamplingMap.push({ o: offsets[i], w: weights[i] });
      } else {
        const sharedCell = j === centerIndex;
        const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);
        const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);
        if (offsetLinear === 0) {
          linearSamplingMap.push({ o: offsets[i], w: weights[i] });
          linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });
        } else {
          linearSamplingMap.push({ o: offsetLinear, w: weightLinear });
          linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });
        }
      }
    }
    for (let i = 0; i < linearSamplingMap.length; i++) {
      linearSamplingOffsets[i] = linearSamplingMap[i].o;
      linearSamplingWeights[i] = linearSamplingMap[i].w;
    }
    offsets = linearSamplingOffsets;
    weights = linearSamplingWeights;
    const maxVaryingRows = this.getEngine().getCaps().maxVaryingVectors;
    const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1;
    let varyingCount = Math.min(offsets.length, freeVaryingVec2);
    let defines = "";
    defines += this._staticDefines;
    if (this._staticDefines.indexOf("DOF") != -1) {
      defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}\r
`;
      varyingCount--;
    }
    for (let i = 0; i < varyingCount; i++) {
      defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}\r
`;
      defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}\r
`;
    }
    let depCount = 0;
    for (let i = freeVaryingVec2; i < offsets.length; i++) {
      defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}\r
`;
      defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}\r
`;
      depCount++;
    }
    if (this.packedFloat) {
      defines += `#define PACKEDFLOAT 1`;
    }
    this._blockCompilation = false;
    super.updateEffect(defines, null, null, {
      varyingCount,
      depCount
    }, onCompiled, onError);
  }
  _nearestBestKernel(idealKernel) {
    const v = Math.round(idealKernel);
    for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {
      if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {
        return Math.max(k, 3);
      }
    }
    return Math.max(v, 3);
  }
  _gaussianWeight(x) {
    const sigma = 1 / 3;
    const denominator = Math.sqrt(2 * Math.PI) * sigma;
    const exponent = -(x * x / (2 * sigma * sigma));
    const weight = 1 / denominator * Math.exp(exponent);
    return weight;
  }
  _glslFloat(x, decimalFigures = 8) {
    return x.toFixed(decimalFigures).replace(/0+$/, "");
  }
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new BlurPostProcess(parsedPostProcess.name, parsedPostProcess.direction, parsedPostProcess.kernel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, void 0, false);
    }, parsedPostProcess, scene, rootUrl);
  }
};
__decorate([
  serialize("kernel")
], BlurPostProcess.prototype, "_kernel", void 0);
__decorate([
  serialize("packedFloat")
], BlurPostProcess.prototype, "_packedFloat", void 0);
__decorate([
  serializeAsVector2()
], BlurPostProcess.prototype, "direction", void 0);
RegisterClass("BABYLON.BlurPostProcess", BlurPostProcess);

// node_modules/@babylonjs/core/Materials/Textures/mirrorTexture.js
var MirrorTexture = class extends RenderTargetTexture {
  constructor(name137, size, scene, generateMipMaps, type = 0, samplingMode = Texture.BILINEAR_SAMPLINGMODE, generateDepthBuffer = true) {
    super(name137, size, scene, generateMipMaps, true, type, false, samplingMode, generateDepthBuffer);
    this.mirrorPlane = new Plane(0, 1, 0, 1);
    this._transformMatrix = Matrix.Zero();
    this._mirrorMatrix = Matrix.Zero();
    this._adaptiveBlurKernel = 0;
    this._blurKernelX = 0;
    this._blurKernelY = 0;
    this._blurRatio = 1;
    scene = this.getScene();
    if (!scene) {
      return this;
    }
    this.ignoreCameraViewport = true;
    this._updateGammaSpace();
    this._imageProcessingConfigChangeObserver = scene.imageProcessingConfiguration.onUpdateParameters.add(() => {
      this._updateGammaSpace();
    });
    const engine = scene.getEngine();
    if (engine.supportsUniformBuffers) {
      this._sceneUBO = scene.createSceneUniformBuffer(`Scene for Mirror Texture (name "${name137}")`);
    }
    this.onBeforeBindObservable.add(() => {
      var _a;
      (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `mirror generation for ${name137}`, 1);
    });
    this.onAfterUnbindObservable.add(() => {
      var _a;
      (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);
    });
    let saveClipPlane;
    this.onBeforeRenderObservable.add(() => {
      if (this._sceneUBO) {
        this._currentSceneUBO = scene.getSceneUniformBuffer();
        scene.setSceneUniformBuffer(this._sceneUBO);
        scene.getSceneUniformBuffer().unbindEffect();
      }
      Matrix.ReflectionToRef(this.mirrorPlane, this._mirrorMatrix);
      this._mirrorMatrix.multiplyToRef(scene.getViewMatrix(), this._transformMatrix);
      scene.setTransformMatrix(this._transformMatrix, scene.getProjectionMatrix());
      saveClipPlane = scene.clipPlane;
      scene.clipPlane = this.mirrorPlane;
      scene._mirroredCameraPosition = Vector3.TransformCoordinates(scene.activeCamera.globalPosition, this._mirrorMatrix);
    });
    this.onAfterRenderObservable.add(() => {
      if (this._sceneUBO) {
        scene.setSceneUniformBuffer(this._currentSceneUBO);
      }
      scene.updateTransformMatrix();
      scene._mirroredCameraPosition = null;
      scene.clipPlane = saveClipPlane;
    });
  }
  set blurRatio(value) {
    if (this._blurRatio === value) {
      return;
    }
    this._blurRatio = value;
    this._preparePostProcesses();
  }
  get blurRatio() {
    return this._blurRatio;
  }
  set adaptiveBlurKernel(value) {
    this._adaptiveBlurKernel = value;
    this._autoComputeBlurKernel();
  }
  set blurKernel(value) {
    this.blurKernelX = value;
    this.blurKernelY = value;
  }
  set blurKernelX(value) {
    if (this._blurKernelX === value) {
      return;
    }
    this._blurKernelX = value;
    this._preparePostProcesses();
  }
  get blurKernelX() {
    return this._blurKernelX;
  }
  set blurKernelY(value) {
    if (this._blurKernelY === value) {
      return;
    }
    this._blurKernelY = value;
    this._preparePostProcesses();
  }
  get blurKernelY() {
    return this._blurKernelY;
  }
  _autoComputeBlurKernel() {
    const engine = this.getScene().getEngine();
    const dw = this.getRenderWidth() / engine.getRenderWidth();
    const dh = this.getRenderHeight() / engine.getRenderHeight();
    this.blurKernelX = this._adaptiveBlurKernel * dw;
    this.blurKernelY = this._adaptiveBlurKernel * dh;
  }
  _onRatioRescale() {
    if (this._sizeRatio) {
      this.resize(this._initialSizeParameter);
      if (!this._adaptiveBlurKernel) {
        this._preparePostProcesses();
      }
    }
    if (this._adaptiveBlurKernel) {
      this._autoComputeBlurKernel();
    }
  }
  _updateGammaSpace() {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    this.gammaSpace = !scene.imageProcessingConfiguration.isEnabled || !scene.imageProcessingConfiguration.applyByPostProcess;
  }
  _preparePostProcesses() {
    this.clearPostProcesses(true);
    if (this._blurKernelX && this._blurKernelY) {
      const engine = this.getScene().getEngine();
      const textureType = engine.getCaps().textureFloatRender && engine.getCaps().textureFloatLinearFiltering ? 1 : 2;
      this._blurX = new BlurPostProcess("horizontal blur", new Vector2(1, 0), this._blurKernelX, this._blurRatio, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, textureType);
      this._blurX.autoClear = false;
      if (this._blurRatio === 1 && this.samples < 2 && this._texture) {
        this._blurX.inputTexture = this._renderTarget;
      } else {
        this._blurX.alwaysForcePOT = true;
      }
      this._blurY = new BlurPostProcess("vertical blur", new Vector2(0, 1), this._blurKernelY, this._blurRatio, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, textureType);
      this._blurY.autoClear = false;
      this._blurY.alwaysForcePOT = this._blurRatio !== 1;
      this.addPostProcess(this._blurX);
      this.addPostProcess(this._blurY);
    } else {
      if (this._blurY) {
        this.removePostProcess(this._blurY);
        this._blurY.dispose();
        this._blurY = null;
      }
      if (this._blurX) {
        this.removePostProcess(this._blurX);
        this._blurX.dispose();
        this._blurX = null;
      }
    }
  }
  clone() {
    const scene = this.getScene();
    if (!scene) {
      return this;
    }
    const textureSize = this.getSize();
    const newTexture = new MirrorTexture(this.name, textureSize.width, scene, this._renderTargetOptions.generateMipMaps, this._renderTargetOptions.type, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.mirrorPlane = this.mirrorPlane.clone();
    if (this.renderList) {
      newTexture.renderList = this.renderList.slice(0);
    }
    return newTexture;
  }
  serialize() {
    if (!this.name) {
      return null;
    }
    const serializationObject = super.serialize();
    serializationObject.mirrorPlane = this.mirrorPlane.asArray();
    return serializationObject;
  }
  dispose() {
    var _a;
    super.dispose();
    const scene = this.getScene();
    if (scene) {
      scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigChangeObserver);
    }
    (_a = this._sceneUBO) === null || _a === void 0 ? void 0 : _a.dispose();
  }
};
Texture._CreateMirror = (name137, renderTargetSize, scene, generateMipMaps) => {
  return new MirrorTexture(name137, renderTargetSize, scene, generateMipMaps);
};

// node_modules/@babylonjs/core/Shaders/ShadersInclude/backgroundFragmentDeclaration.js
var name33 = "backgroundFragmentDeclaration";
var shader33 = `uniform vec4 vEyePosition;
uniform vec4 vPrimaryColor;
#ifdef USEHIGHLIGHTANDSHADOWCOLORS
uniform vec4 vPrimaryColorShadow;
#endif
uniform float shadowLevel;
uniform float alpha;
#ifdef DIFFUSE
uniform vec2 vDiffuseInfos;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;
uniform mat4 reflectionMatrix;
uniform vec3 vReflectionMicrosurfaceInfos;
#endif
#if defined(REFLECTIONFRESNEL) || defined(OPACITYFRESNEL)
uniform vec3 vBackgroundCenter;
#endif
#ifdef REFLECTIONFRESNEL
uniform vec4 vReflectionControl;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)
uniform mat4 view;
#endif
`;
ShaderStore.IncludesShadersStore[name33] = shader33;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/backgroundUboDeclaration.js
var name34 = "backgroundUboDeclaration";
var shader34 = `layout(std140,column_major) uniform;
uniform Material
{
uniform vec4 vPrimaryColor;
uniform vec4 vPrimaryColorShadow;
uniform vec2 vDiffuseInfos;
uniform vec2 vReflectionInfos;
uniform mat4 diffuseMatrix;
uniform mat4 reflectionMatrix;
uniform vec3 vReflectionMicrosurfaceInfos;
uniform float fFovMultiplier;
uniform float pointSize;
uniform float shadowLevel;
uniform float alpha;
#if defined(REFLECTIONFRESNEL) || defined(OPACITYFRESNEL)
uniform vec3 vBackgroundCenter;
#endif
#ifdef REFLECTIONFRESNEL
uniform vec4 vReflectionControl;
#endif
};
#include<sceneUboDeclaration>
`;
ShaderStore.IncludesShadersStore[name34] = shader34;

// node_modules/@babylonjs/core/Shaders/background.fragment.js
var name35 = "backgroundPixelShader";
var shader35 = `#ifdef TEXTURELODSUPPORT
#extension GL_EXT_shader_texture_lod : enable
#endif
precision highp float;
#include<__decl__backgroundFragment>
#include<helperFunctions>
#define RECIPROCAL_PI2 0.15915494
varying vec3 vPositionW;
#ifdef MAINUV1
varying vec2 vMainUV1;
#endif 
#ifdef MAINUV2 
varying vec2 vMainUV2; 
#endif 
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef DIFFUSE
#if DIFFUSEDIRECTUV==1
#define vDiffuseUV vMainUV1
#elif DIFFUSEDIRECTUV==2
#define vDiffuseUV vMainUV2
#else
varying vec2 vDiffuseUV;
#endif
uniform sampler2D diffuseSampler;
#endif
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
#define sampleReflection(s,c) textureCube(s,c)
uniform samplerCube reflectionSampler;
#ifdef TEXTURELODSUPPORT
#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)
#else
uniform samplerCube reflectionSamplerLow;
uniform samplerCube reflectionSamplerHigh;
#endif
#else
#define sampleReflection(s,c) texture2D(s,c)
uniform sampler2D reflectionSampler;
#ifdef TEXTURELODSUPPORT
#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)
#else
uniform samplerCube reflectionSamplerLow;
uniform samplerCube reflectionSamplerHigh;
#endif
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#include<reflectionFunction>
#endif
#ifndef FROMLINEARSPACE
#define FROMLINEARSPACE;
#endif
#ifndef SHADOWONLY
#define SHADOWONLY;
#endif
#include<imageProcessingDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<imageProcessingFunctions>
#include<clipPlaneFragmentDeclaration>
#include<fogFragmentDeclaration>
#ifdef REFLECTIONFRESNEL
#define FRESNEL_MAXIMUM_ON_ROUGH 0.25
vec3 fresnelSchlickEnvironmentGGX(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)
{
float weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);
return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));
}
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(0.0,1.0,0.0);
#endif
float shadow=1.;
float globalShadow=0.;
float shadowLightCount=0.;
#include<lightFragment>[0..maxSimultaneousLights]
#ifdef SHADOWINUSE
globalShadow/=shadowLightCount;
#else
globalShadow=1.0;
#endif
#ifndef BACKMAT_SHADOWONLY
vec4 reflectionColor=vec4(1.,1.,1.,1.);
#ifdef REFLECTION
vec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
reflectionVector.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
vec3 reflectionCoords=reflectionVector;
#else
vec2 reflectionCoords=reflectionVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
reflectionCoords/=reflectionVector.z;
#endif
reflectionCoords.y=1.0-reflectionCoords.y;
#endif
#ifdef REFLECTIONBLUR
float reflectionLOD=vReflectionInfos.y;
#ifdef TEXTURELODSUPPORT
reflectionLOD=reflectionLOD*log2(vReflectionMicrosurfaceInfos.x)*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;
reflectionColor=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);
#else
float lodReflectionNormalized=saturate(reflectionLOD);
float lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;
vec4 reflectionSpecularMid=sampleReflection(reflectionSampler,reflectionCoords);
if(lodReflectionNormalizedDoubled<1.0){
reflectionColor=mix(
sampleReflection(reflectionSamplerHigh,reflectionCoords),
reflectionSpecularMid,
lodReflectionNormalizedDoubled
);
} else {
reflectionColor=mix(
reflectionSpecularMid,
sampleReflection(reflectionSamplerLow,reflectionCoords),
lodReflectionNormalizedDoubled-1.0
);
}
#endif
#else
vec4 reflectionSample=sampleReflection(reflectionSampler,reflectionCoords);
reflectionColor=reflectionSample;
#endif
#ifdef RGBDREFLECTION
reflectionColor.rgb=fromRGBD(reflectionColor);
#endif
#ifdef GAMMAREFLECTION
reflectionColor.rgb=toLinearSpace(reflectionColor.rgb);
#endif
#ifdef REFLECTIONBGR
reflectionColor.rgb=reflectionColor.bgr;
#endif
reflectionColor.rgb*=vReflectionInfos.x;
#endif
vec3 diffuseColor=vec3(1.,1.,1.);
float finalAlpha=alpha;
#ifdef DIFFUSE
vec4 diffuseMap=texture2D(diffuseSampler,vDiffuseUV);
#ifdef GAMMADIFFUSE
diffuseMap.rgb=toLinearSpace(diffuseMap.rgb);
#endif
diffuseMap.rgb*=vDiffuseInfos.y;
#ifdef DIFFUSEHASALPHA
finalAlpha*=diffuseMap.a;
#endif
diffuseColor=diffuseMap.rgb;
#endif
#ifdef REFLECTIONFRESNEL
vec3 colorBase=diffuseColor;
#else
vec3 colorBase=reflectionColor.rgb*diffuseColor;
#endif
colorBase=max(colorBase,0.0);
#ifdef USERGBCOLOR
vec3 finalColor=colorBase;
#else
#ifdef USEHIGHLIGHTANDSHADOWCOLORS
vec3 mainColor=mix(vPrimaryColorShadow.rgb,vPrimaryColor.rgb,colorBase);
#else
vec3 mainColor=vPrimaryColor.rgb;
#endif
vec3 finalColor=colorBase*mainColor;
#endif
#ifdef REFLECTIONFRESNEL
vec3 reflectionAmount=vReflectionControl.xxx;
vec3 reflectionReflectance0=vReflectionControl.yyy;
vec3 reflectionReflectance90=vReflectionControl.zzz;
float VdotN=dot(normalize(vEyePosition.xyz),normalW);
vec3 planarReflectionFresnel=fresnelSchlickEnvironmentGGX(saturate(VdotN),reflectionReflectance0,reflectionReflectance90,1.0);
reflectionAmount*=planarReflectionFresnel;
#ifdef REFLECTIONFALLOFF
float reflectionDistanceFalloff=1.0-saturate(length(vPositionW.xyz-vBackgroundCenter)*vReflectionControl.w);
reflectionDistanceFalloff*=reflectionDistanceFalloff;
reflectionAmount*=reflectionDistanceFalloff;
#endif
finalColor=mix(finalColor,reflectionColor.rgb,saturate(reflectionAmount));
#endif
#ifdef OPACITYFRESNEL
float viewAngleToFloor=dot(normalW,normalize(vEyePosition.xyz-vBackgroundCenter));
const float startAngle=0.1;
float fadeFactor=saturate(viewAngleToFloor/startAngle);
finalAlpha*=fadeFactor*fadeFactor;
#endif
#ifdef SHADOWINUSE
finalColor=mix(finalColor*shadowLevel,finalColor,globalShadow);
#endif
vec4 color=vec4(finalColor,finalAlpha);
#else
vec4 color=vec4(vPrimaryColor.rgb,(1.0-clamp(globalShadow,0.,1.))*alpha);
#endif
#include<fogFragment>
#ifdef IMAGEPROCESSINGPOSTPROCESS
#if !defined(SKIPFINALCOLORCLAMP)
color.rgb=clamp(color.rgb,0.,30.0);
#endif
#else
color=applyImageProcessing(color);
#endif
#ifdef PREMULTIPLYALPHA
color.rgb*=color.a;
#endif
#ifdef NOISE
color.rgb+=dither(vPositionW.xy,0.5);
color=max(color,0.0);
#endif
gl_FragColor=color;
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
ShaderStore.ShadersStore[name35] = shader35;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/backgroundVertexDeclaration.js
var name36 = "backgroundVertexDeclaration";
var shader36 = `uniform mat4 view;
uniform mat4 viewProjection;
uniform float shadowLevel;
#ifdef DIFFUSE
uniform mat4 diffuseMatrix;
uniform vec2 vDiffuseInfos;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;
uniform mat4 reflectionMatrix;
uniform vec3 vReflectionMicrosurfaceInfos;
uniform float fFovMultiplier;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
`;
ShaderStore.IncludesShadersStore[name36] = shader36;

// node_modules/@babylonjs/core/Shaders/background.vertex.js
var name37 = "backgroundVertexShader";
var shader37 = `precision highp float;
#include<__decl__backgroundVertex>
#include<helperFunctions>
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#ifdef MAINUV1
varying vec2 vMainUV1;
#endif
#ifdef MAINUV2
varying vec2 vMainUV2;
#endif
#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0
varying vec2 vDiffuseUV;
#endif
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=position;
#endif
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {
gl_Position=viewProjection*finalWorld*vec4(position,1.0);
} else {
gl_Position=viewProjectionR*finalWorld*vec4(position,1.0);
}
#else
gl_Position=viewProjection*finalWorld*vec4(position,1.0);
#endif
vec4 worldPos=finalWorld*vec4(position,1.0);
vPositionW=vec3(worldPos);
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normal);
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(position,0.0)));
#ifdef EQUIRECTANGULAR_RELFECTION_FOV
mat3 screenToWorld=inverseMat3(mat3(finalWorld*viewProjection));
vec3 segment=mix(vDirectionW,screenToWorld*vec3(0.0,0.0,1.0),abs(fFovMultiplier-1.0));
if (fFovMultiplier<=1.0) {
vDirectionW=normalize(segment);
} else {
vDirectionW=normalize(vDirectionW+(vDirectionW-segment));
}
#endif
#endif
#ifndef UV1
vec2 uv=vec2(0.,0.);
#endif
#ifndef UV2
vec2 uv2=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uv;
#endif
#ifdef MAINUV2
vMainUV2=uv2;
#endif
#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0
if (vDiffuseInfos.x==0.)
{
vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));
}
else
{
vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
}
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#ifdef VERTEXCOLOR
vColor=color;
#endif
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name37] = shader37;

// node_modules/@babylonjs/core/Materials/Background/backgroundMaterial.js
var BackgroundMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.DIFFUSE = false;
    this.DIFFUSEDIRECTUV = 0;
    this.GAMMADIFFUSE = false;
    this.DIFFUSEHASALPHA = false;
    this.OPACITYFRESNEL = false;
    this.REFLECTIONBLUR = false;
    this.REFLECTIONFRESNEL = false;
    this.REFLECTIONFALLOFF = false;
    this.TEXTURELODSUPPORT = false;
    this.PREMULTIPLYALPHA = false;
    this.USERGBCOLOR = false;
    this.USEHIGHLIGHTANDSHADOWCOLORS = false;
    this.BACKMAT_SHADOWONLY = false;
    this.NOISE = false;
    this.REFLECTIONBGR = false;
    this.IMAGEPROCESSING = false;
    this.VIGNETTE = false;
    this.VIGNETTEBLENDMODEMULTIPLY = false;
    this.VIGNETTEBLENDMODEOPAQUE = false;
    this.TONEMAPPING = false;
    this.TONEMAPPING_ACES = false;
    this.CONTRAST = false;
    this.COLORCURVES = false;
    this.COLORGRADING = false;
    this.COLORGRADING3D = false;
    this.SAMPLER3DGREENDEPTH = false;
    this.SAMPLER3DBGRMAP = false;
    this.DITHER = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.EXPOSURE = false;
    this.MULTIVIEW = false;
    this.REFLECTION = false;
    this.REFLECTIONMAP_3D = false;
    this.REFLECTIONMAP_SPHERICAL = false;
    this.REFLECTIONMAP_PLANAR = false;
    this.REFLECTIONMAP_CUBIC = false;
    this.REFLECTIONMAP_PROJECTION = false;
    this.REFLECTIONMAP_SKYBOX = false;
    this.REFLECTIONMAP_EXPLICIT = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
    this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
    this.INVERTCUBICMAP = false;
    this.REFLECTIONMAP_OPPOSITEZ = false;
    this.LODINREFLECTIONALPHA = false;
    this.GAMMAREFLECTION = false;
    this.RGBDREFLECTION = false;
    this.EQUIRECTANGULAR_RELFECTION_FOV = false;
    this.MAINUV1 = false;
    this.MAINUV2 = false;
    this.UV1 = false;
    this.UV2 = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.NORMAL = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.INSTANCES = false;
    this.SHADOWFLOAT = false;
    this.LOGARITHMICDEPTH = false;
    this.NONUNIFORMSCALING = false;
    this.ALPHATEST = false;
    this.rebuild();
  }
};
var BackgroundMaterial = class extends PushMaterial {
  constructor(name137, scene) {
    super(name137, scene);
    this.primaryColor = Color3.White();
    this._primaryColorShadowLevel = 0;
    this._primaryColorHighlightLevel = 0;
    this.reflectionTexture = null;
    this.reflectionBlur = 0;
    this.diffuseTexture = null;
    this._shadowLights = null;
    this.shadowLights = null;
    this.shadowLevel = 0;
    this.sceneCenter = Vector3.Zero();
    this.opacityFresnel = true;
    this.reflectionFresnel = false;
    this.reflectionFalloffDistance = 0;
    this.reflectionAmount = 1;
    this.reflectionReflectance0 = 0.05;
    this.reflectionReflectance90 = 0.5;
    this.useRGBColor = true;
    this.enableNoise = false;
    this._fovMultiplier = 1;
    this.useEquirectangularFOV = false;
    this._maxSimultaneousLights = 4;
    this.maxSimultaneousLights = 4;
    this._shadowOnly = false;
    this.shadowOnly = false;
    this._imageProcessingObserver = null;
    this.switchToBGR = false;
    this._renderTargets = new SmartArray(16);
    this._reflectionControls = Vector4.Zero();
    this._white = Color3.White();
    this._primaryShadowColor = Color3.Black();
    this._primaryHighlightColor = Color3.Black();
    this._attachImageProcessingConfiguration(null);
    this.getRenderTargetTextures = () => {
      this._renderTargets.reset();
      if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {
        this._renderTargets.push(this._diffuseTexture);
      }
      if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
        this._renderTargets.push(this._reflectionTexture);
      }
      return this._renderTargets;
    };
  }
  get _perceptualColor() {
    return this.__perceptualColor;
  }
  set _perceptualColor(value) {
    this.__perceptualColor = value;
    this._computePrimaryColorFromPerceptualColor();
    this._markAllSubMeshesAsLightsDirty();
  }
  get primaryColorShadowLevel() {
    return this._primaryColorShadowLevel;
  }
  set primaryColorShadowLevel(value) {
    this._primaryColorShadowLevel = value;
    this._computePrimaryColors();
    this._markAllSubMeshesAsLightsDirty();
  }
  get primaryColorHighlightLevel() {
    return this._primaryColorHighlightLevel;
  }
  set primaryColorHighlightLevel(value) {
    this._primaryColorHighlightLevel = value;
    this._computePrimaryColors();
    this._markAllSubMeshesAsLightsDirty();
  }
  set reflectionStandardFresnelWeight(value) {
    let reflectionWeight = value;
    if (reflectionWeight < 0.5) {
      reflectionWeight = reflectionWeight * 2;
      this.reflectionReflectance0 = BackgroundMaterial.StandardReflectance0 * reflectionWeight;
      this.reflectionReflectance90 = BackgroundMaterial.StandardReflectance90 * reflectionWeight;
    } else {
      reflectionWeight = reflectionWeight * 2 - 1;
      this.reflectionReflectance0 = BackgroundMaterial.StandardReflectance0 + (1 - BackgroundMaterial.StandardReflectance0) * reflectionWeight;
      this.reflectionReflectance90 = BackgroundMaterial.StandardReflectance90 + (1 - BackgroundMaterial.StandardReflectance90) * reflectionWeight;
    }
  }
  get fovMultiplier() {
    return this._fovMultiplier;
  }
  set fovMultiplier(value) {
    if (isNaN(value)) {
      value = 1;
    }
    this._fovMultiplier = Math.max(0, Math.min(2, value));
  }
  _attachImageProcessingConfiguration(configuration) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (!configuration) {
      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
        this._computePrimaryColorFromPerceptualColor();
        this._markAllSubMeshesAsImageProcessingDirty();
      });
    }
  }
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  set imageProcessingConfiguration(value) {
    this._attachImageProcessingConfiguration(value);
    this._markAllSubMeshesAsTexturesDirty();
  }
  get cameraColorCurvesEnabled() {
    return this.imageProcessingConfiguration.colorCurvesEnabled;
  }
  set cameraColorCurvesEnabled(value) {
    this.imageProcessingConfiguration.colorCurvesEnabled = value;
  }
  get cameraColorGradingEnabled() {
    return this.imageProcessingConfiguration.colorGradingEnabled;
  }
  set cameraColorGradingEnabled(value) {
    this.imageProcessingConfiguration.colorGradingEnabled = value;
  }
  get cameraToneMappingEnabled() {
    return this._imageProcessingConfiguration.toneMappingEnabled;
  }
  set cameraToneMappingEnabled(value) {
    this._imageProcessingConfiguration.toneMappingEnabled = value;
  }
  get cameraExposure() {
    return this._imageProcessingConfiguration.exposure;
  }
  set cameraExposure(value) {
    this._imageProcessingConfiguration.exposure = value;
  }
  get cameraContrast() {
    return this._imageProcessingConfiguration.contrast;
  }
  set cameraContrast(value) {
    this._imageProcessingConfiguration.contrast = value;
  }
  get cameraColorGradingTexture() {
    return this._imageProcessingConfiguration.colorGradingTexture;
  }
  set cameraColorGradingTexture(value) {
    this.imageProcessingConfiguration.colorGradingTexture = value;
  }
  get cameraColorCurves() {
    return this.imageProcessingConfiguration.colorCurves;
  }
  set cameraColorCurves(value) {
    this.imageProcessingConfiguration.colorCurves = value;
  }
  get hasRenderTargetTextures() {
    if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {
      return true;
    }
    if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
      return true;
    }
    return false;
  }
  needAlphaTesting() {
    return true;
  }
  needAlphaBlending() {
    return this.alpha < 1 || this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._shadowOnly;
  }
  isReadyForSubMesh(mesh, subMesh, useInstances = false) {
    if (subMesh.effect && this.isFrozen) {
      if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new BackgroundMaterialDefines();
    }
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights);
    defines._needNormals = true;
    MaterialHelper.PrepareDefinesForMultiview(scene, defines);
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      if (scene.texturesEnabled) {
        if (scene.getEngine().getCaps().textureLOD) {
          defines.TEXTURELODSUPPORT = true;
        }
        if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
          if (!this._diffuseTexture.isReadyOrNotBlocking()) {
            return false;
          }
          MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, "DIFFUSE");
          defines.DIFFUSEHASALPHA = this._diffuseTexture.hasAlpha;
          defines.GAMMADIFFUSE = this._diffuseTexture.gammaSpace;
          defines.OPACITYFRESNEL = this._opacityFresnel;
        } else {
          defines.DIFFUSE = false;
          defines.DIFFUSEDIRECTUV = 0;
          defines.DIFFUSEHASALPHA = false;
          defines.GAMMADIFFUSE = false;
          defines.OPACITYFRESNEL = false;
        }
        const reflectionTexture = this._reflectionTexture;
        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (!reflectionTexture.isReadyOrNotBlocking()) {
            return false;
          }
          defines.REFLECTION = true;
          defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;
          defines.RGBDREFLECTION = reflectionTexture.isRGBD;
          defines.REFLECTIONBLUR = this._reflectionBlur > 0;
          defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;
          defines.EQUIRECTANGULAR_RELFECTION_FOV = this.useEquirectangularFOV;
          defines.REFLECTIONBGR = this.switchToBGR;
          if (reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE) {
            defines.INVERTCUBICMAP = true;
          }
          defines.REFLECTIONMAP_3D = reflectionTexture.isCube;
          defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;
          switch (reflectionTexture.coordinatesMode) {
            case Texture.EXPLICIT_MODE:
              defines.REFLECTIONMAP_EXPLICIT = true;
              break;
            case Texture.PLANAR_MODE:
              defines.REFLECTIONMAP_PLANAR = true;
              break;
            case Texture.PROJECTION_MODE:
              defines.REFLECTIONMAP_PROJECTION = true;
              break;
            case Texture.SKYBOX_MODE:
              defines.REFLECTIONMAP_SKYBOX = true;
              break;
            case Texture.SPHERICAL_MODE:
              defines.REFLECTIONMAP_SPHERICAL = true;
              break;
            case Texture.EQUIRECTANGULAR_MODE:
              defines.REFLECTIONMAP_EQUIRECTANGULAR = true;
              break;
            case Texture.FIXED_EQUIRECTANGULAR_MODE:
              defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;
              break;
            case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
              defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;
              break;
            case Texture.CUBIC_MODE:
            case Texture.INVCUBIC_MODE:
            default:
              defines.REFLECTIONMAP_CUBIC = true;
              break;
          }
          if (this.reflectionFresnel) {
            defines.REFLECTIONFRESNEL = true;
            defines.REFLECTIONFALLOFF = this.reflectionFalloffDistance > 0;
            this._reflectionControls.x = this.reflectionAmount;
            this._reflectionControls.y = this.reflectionReflectance0;
            this._reflectionControls.z = this.reflectionReflectance90;
            this._reflectionControls.w = 1 / this.reflectionFalloffDistance;
          } else {
            defines.REFLECTIONFRESNEL = false;
            defines.REFLECTIONFALLOFF = false;
          }
        } else {
          defines.REFLECTION = false;
          defines.REFLECTIONFRESNEL = false;
          defines.REFLECTIONFALLOFF = false;
          defines.REFLECTIONBLUR = false;
          defines.REFLECTIONMAP_3D = false;
          defines.REFLECTIONMAP_SPHERICAL = false;
          defines.REFLECTIONMAP_PLANAR = false;
          defines.REFLECTIONMAP_CUBIC = false;
          defines.REFLECTIONMAP_PROJECTION = false;
          defines.REFLECTIONMAP_SKYBOX = false;
          defines.REFLECTIONMAP_EXPLICIT = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
          defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
          defines.INVERTCUBICMAP = false;
          defines.REFLECTIONMAP_OPPOSITEZ = false;
          defines.LODINREFLECTIONALPHA = false;
          defines.GAMMAREFLECTION = false;
          defines.RGBDREFLECTION = false;
        }
      }
      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
      defines.USERGBCOLOR = this._useRGBColor;
      defines.NOISE = this._enableNoise;
    }
    if (defines._areLightsDirty) {
      defines.USEHIGHLIGHTANDSHADOWCOLORS = !this._useRGBColor && (this._primaryColorShadowLevel !== 0 || this._primaryColorHighlightLevel !== 0);
      defines.BACKMAT_SHADOWONLY = this._shadowOnly;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady()) {
        return false;
      }
      this._imageProcessingConfiguration.prepareDefines(defines);
    }
    MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
    MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
    if (MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, true, false)) {
      if (mesh) {
        if (!scene.getEngine().getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          mesh.createNormals(true);
          Logger.Warn("BackgroundMaterial: Normals have been created for the mesh: " + mesh.name);
        }
      }
    }
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(0, "FOG");
      }
      if (defines.POINTSIZE) {
        fallbacks.addFallback(1, "POINTSIZE");
      }
      if (defines.MULTIVIEW) {
        fallbacks.addFallback(0, "MULTIVIEW");
      }
      MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      MaterialHelper.PrepareAttributesForInstances(attribs, defines);
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "mBones",
        "vPrimaryColor",
        "vPrimaryColorShadow",
        "vReflectionInfos",
        "reflectionMatrix",
        "vReflectionMicrosurfaceInfos",
        "fFovMultiplier",
        "shadowLevel",
        "alpha",
        "vBackgroundCenter",
        "vReflectionControl",
        "vDiffuseInfos",
        "diffuseMatrix"
      ];
      addClipPlaneUniforms(uniforms);
      const samplers = ["diffuseSampler", "reflectionSampler", "reflectionSamplerLow", "reflectionSamplerHigh"];
      const uniformBuffers = ["Material", "Scene"];
      if (ImageProcessingConfiguration) {
        ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
        ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
      }
      MaterialHelper.PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: this._maxSimultaneousLights
      });
      const join = defines.toString();
      const effect = scene.getEngine().createEffect("background", {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights }
      }, engine);
      subMesh.setEffect(effect, defines, this._materialContext);
      this.buildUniformLayout();
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    subMesh.effect._wasPreviouslyReady = true;
    subMesh.effect._wasPreviouslyUsingInstances = useInstances;
    if (scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {
      this.checkReadyOnlyOnce = true;
    }
    return true;
  }
  _computePrimaryColorFromPerceptualColor() {
    if (!this.__perceptualColor) {
      return;
    }
    this._primaryColor.copyFrom(this.__perceptualColor);
    this._primaryColor.toLinearSpaceToRef(this._primaryColor);
    if (this._imageProcessingConfiguration) {
      this._primaryColor.scaleToRef(1 / this._imageProcessingConfiguration.exposure, this._primaryColor);
    }
    this._computePrimaryColors();
  }
  _computePrimaryColors() {
    if (this._primaryColorShadowLevel === 0 && this._primaryColorHighlightLevel === 0) {
      return;
    }
    this._primaryColor.scaleToRef(this._primaryColorShadowLevel, this._primaryShadowColor);
    this._primaryColor.subtractToRef(this._primaryShadowColor, this._primaryShadowColor);
    this._white.subtractToRef(this._primaryColor, this._primaryHighlightColor);
    this._primaryHighlightColor.scaleToRef(this._primaryColorHighlightLevel, this._primaryHighlightColor);
    this._primaryColor.addToRef(this._primaryHighlightColor, this._primaryHighlightColor);
  }
  buildUniformLayout() {
    this._uniformBuffer.addUniform("vPrimaryColor", 4);
    this._uniformBuffer.addUniform("vPrimaryColorShadow", 4);
    this._uniformBuffer.addUniform("vDiffuseInfos", 2);
    this._uniformBuffer.addUniform("vReflectionInfos", 2);
    this._uniformBuffer.addUniform("diffuseMatrix", 16);
    this._uniformBuffer.addUniform("reflectionMatrix", 16);
    this._uniformBuffer.addUniform("vReflectionMicrosurfaceInfos", 3);
    this._uniformBuffer.addUniform("fFovMultiplier", 1);
    this._uniformBuffer.addUniform("pointSize", 1);
    this._uniformBuffer.addUniform("shadowLevel", 1);
    this._uniformBuffer.addUniform("alpha", 1);
    this._uniformBuffer.addUniform("vBackgroundCenter", 3);
    this._uniformBuffer.addUniform("vReflectionControl", 4);
    this._uniformBuffer.create();
  }
  unbind() {
    if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {
      this._uniformBuffer.setTexture("diffuseSampler", null);
    }
    if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
      this._uniformBuffer.setTexture("reflectionSampler", null);
    }
    super.unbind();
  }
  bindOnlyWorldMatrix(world) {
    this._activeEffect.setMatrix("world", world);
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    MaterialHelper.BindBonesParameters(mesh, this._activeEffect);
    const mustRebind = this._mustRebind(scene, effect, mesh.visibility);
    if (mustRebind) {
      this._uniformBuffer.bindToEffect(effect, "Material");
      this.bindViewProjection(effect);
      const reflectionTexture = this._reflectionTexture;
      if (!this._uniformBuffer.useUbo || !this.isFrozen || !this._uniformBuffer.isSync) {
        if (scene.texturesEnabled) {
          if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
            this._uniformBuffer.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);
            MaterialHelper.BindTextureMatrix(this._diffuseTexture, this._uniformBuffer, "diffuse");
          }
          if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
            this._uniformBuffer.updateMatrix("reflectionMatrix", reflectionTexture.getReflectionTextureMatrix());
            this._uniformBuffer.updateFloat2("vReflectionInfos", reflectionTexture.level, this._reflectionBlur);
            this._uniformBuffer.updateFloat3("vReflectionMicrosurfaceInfos", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);
          }
        }
        if (this.shadowLevel > 0) {
          this._uniformBuffer.updateFloat("shadowLevel", this.shadowLevel);
        }
        this._uniformBuffer.updateFloat("alpha", this.alpha);
        if (this.pointsCloud) {
          this._uniformBuffer.updateFloat("pointSize", this.pointSize);
        }
        if (defines.USEHIGHLIGHTANDSHADOWCOLORS) {
          this._uniformBuffer.updateColor4("vPrimaryColor", this._primaryHighlightColor, 1);
          this._uniformBuffer.updateColor4("vPrimaryColorShadow", this._primaryShadowColor, 1);
        } else {
          this._uniformBuffer.updateColor4("vPrimaryColor", this._primaryColor, 1);
        }
      }
      this._uniformBuffer.updateFloat("fFovMultiplier", this._fovMultiplier);
      if (scene.texturesEnabled) {
        if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
          this._uniformBuffer.setTexture("diffuseSampler", this._diffuseTexture);
        }
        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (defines.REFLECTIONBLUR && defines.TEXTURELODSUPPORT) {
            this._uniformBuffer.setTexture("reflectionSampler", reflectionTexture);
          } else if (!defines.REFLECTIONBLUR) {
            this._uniformBuffer.setTexture("reflectionSampler", reflectionTexture);
          } else {
            this._uniformBuffer.setTexture("reflectionSampler", reflectionTexture._lodTextureMid || reflectionTexture);
            this._uniformBuffer.setTexture("reflectionSamplerLow", reflectionTexture._lodTextureLow || reflectionTexture);
            this._uniformBuffer.setTexture("reflectionSamplerHigh", reflectionTexture._lodTextureHigh || reflectionTexture);
          }
          if (defines.REFLECTIONFRESNEL) {
            this._uniformBuffer.updateFloat3("vBackgroundCenter", this.sceneCenter.x, this.sceneCenter.y, this.sceneCenter.z);
            this._uniformBuffer.updateFloat4("vReflectionControl", this._reflectionControls.x, this._reflectionControls.y, this._reflectionControls.z, this._reflectionControls.w);
          }
        }
      }
      bindClipPlane(this._activeEffect, this, scene);
      scene.bindEyePosition(effect);
    } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
      this._uniformBuffer.bindToEffect(effect, "Material");
      this._needToBindSceneUbo = true;
    }
    if (mustRebind || !this.isFrozen) {
      if (scene.lightsEnabled) {
        MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);
      }
      this.bindView(effect);
      MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect, true);
      if (this._imageProcessingConfiguration) {
        this._imageProcessingConfiguration.bind(this._activeEffect);
      }
    }
    this._afterBind(mesh, this._activeEffect);
    this._uniformBuffer.update();
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this._reflectionTexture === texture) {
      return true;
    }
    if (this._diffuseTexture === texture) {
      return true;
    }
    return false;
  }
  dispose(forceDisposeEffect = false, forceDisposeTextures = false) {
    if (forceDisposeTextures) {
      if (this.diffuseTexture) {
        this.diffuseTexture.dispose();
      }
      if (this.reflectionTexture) {
        this.reflectionTexture.dispose();
      }
    }
    this._renderTargets.dispose();
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    super.dispose(forceDisposeEffect);
  }
  clone(name137) {
    return SerializationHelper.Clone(() => new BackgroundMaterial(name137, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.BackgroundMaterial";
    return serializationObject;
  }
  getClassName() {
    return "BackgroundMaterial";
  }
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new BackgroundMaterial(source.name, scene), source, scene, rootUrl);
  }
};
BackgroundMaterial.StandardReflectance0 = 0.05;
BackgroundMaterial.StandardReflectance90 = 0.5;
__decorate([
  serializeAsColor3()
], BackgroundMaterial.prototype, "_primaryColor", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], BackgroundMaterial.prototype, "primaryColor", void 0);
__decorate([
  serializeAsColor3()
], BackgroundMaterial.prototype, "__perceptualColor", void 0);
__decorate([
  serialize()
], BackgroundMaterial.prototype, "_primaryColorShadowLevel", void 0);
__decorate([
  serialize()
], BackgroundMaterial.prototype, "_primaryColorHighlightLevel", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], BackgroundMaterial.prototype, "primaryColorHighlightLevel", null);
__decorate([
  serializeAsTexture()
], BackgroundMaterial.prototype, "_reflectionTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], BackgroundMaterial.prototype, "reflectionTexture", void 0);
__decorate([
  serialize()
], BackgroundMaterial.prototype, "_reflectionBlur", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], BackgroundMaterial.prototype, "reflectionBlur", void 0);
__decorate([
  serializeAsTexture()
], BackgroundMaterial.prototype, "_diffuseTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], BackgroundMaterial.prototype, "diffuseTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], BackgroundMaterial.prototype, "shadowLights", void 0);
__decorate([
  serialize()
], BackgroundMaterial.prototype, "_shadowLevel", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], BackgroundMaterial.prototype, "shadowLevel", void 0);
__decorate([
  serializeAsVector3()
], BackgroundMaterial.prototype, "_sceneCenter", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], BackgroundMaterial.prototype, "sceneCenter", void 0);
__decorate([
  serialize()
], BackgroundMaterial.prototype, "_opacityFresnel", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], BackgroundMaterial.prototype, "opacityFresnel", void 0);
__decorate([
  serialize()
], BackgroundMaterial.prototype, "_reflectionFresnel", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], BackgroundMaterial.prototype, "reflectionFresnel", void 0);
__decorate([
  serialize()
], BackgroundMaterial.prototype, "_reflectionFalloffDistance", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], BackgroundMaterial.prototype, "reflectionFalloffDistance", void 0);
__decorate([
  serialize()
], BackgroundMaterial.prototype, "_reflectionAmount", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], BackgroundMaterial.prototype, "reflectionAmount", void 0);
__decorate([
  serialize()
], BackgroundMaterial.prototype, "_reflectionReflectance0", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], BackgroundMaterial.prototype, "reflectionReflectance0", void 0);
__decorate([
  serialize()
], BackgroundMaterial.prototype, "_reflectionReflectance90", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], BackgroundMaterial.prototype, "reflectionReflectance90", void 0);
__decorate([
  serialize()
], BackgroundMaterial.prototype, "_useRGBColor", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], BackgroundMaterial.prototype, "useRGBColor", void 0);
__decorate([
  serialize()
], BackgroundMaterial.prototype, "_enableNoise", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], BackgroundMaterial.prototype, "enableNoise", void 0);
__decorate([
  serialize()
], BackgroundMaterial.prototype, "_maxSimultaneousLights", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], BackgroundMaterial.prototype, "maxSimultaneousLights", void 0);
__decorate([
  serialize()
], BackgroundMaterial.prototype, "_shadowOnly", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], BackgroundMaterial.prototype, "shadowOnly", void 0);
__decorate([
  serializeAsImageProcessingConfiguration()
], BackgroundMaterial.prototype, "_imageProcessingConfiguration", void 0);
RegisterClass("BABYLON.BackgroundMaterial", BackgroundMaterial);

// node_modules/@babylonjs/core/Helpers/environmentHelper.js
var EnvironmentHelper = class {
  constructor(options, scene) {
    this._errorHandler = (message, exception) => {
      this.onErrorObservable.notifyObservers({ message, exception });
    };
    this._options = {
      ...EnvironmentHelper._GetDefaultOptions(),
      ...options
    };
    this._scene = scene;
    this.onErrorObservable = new Observable();
    this._setupBackground();
    this._setupImageProcessing();
  }
  static _GetDefaultOptions() {
    return {
      createGround: true,
      groundSize: 15,
      groundTexture: this._GroundTextureCDNUrl,
      groundColor: new Color3(0.2, 0.2, 0.3).toLinearSpace().scale(3),
      groundOpacity: 0.9,
      enableGroundShadow: true,
      groundShadowLevel: 0.5,
      enableGroundMirror: false,
      groundMirrorSizeRatio: 0.3,
      groundMirrorBlurKernel: 64,
      groundMirrorAmount: 1,
      groundMirrorFresnelWeight: 1,
      groundMirrorFallOffDistance: 0,
      groundMirrorTextureType: 0,
      groundYBias: 1e-5,
      createSkybox: true,
      skyboxSize: 20,
      skyboxTexture: this._SkyboxTextureCDNUrl,
      skyboxColor: new Color3(0.2, 0.2, 0.3).toLinearSpace().scale(3),
      backgroundYRotation: 0,
      sizeAuto: true,
      rootPosition: Vector3.Zero(),
      setupImageProcessing: true,
      environmentTexture: this._EnvironmentTextureCDNUrl,
      cameraExposure: 0.8,
      cameraContrast: 1.2,
      toneMappingEnabled: true
    };
  }
  get rootMesh() {
    return this._rootMesh;
  }
  get skybox() {
    return this._skybox;
  }
  get skyboxTexture() {
    return this._skyboxTexture;
  }
  get skyboxMaterial() {
    return this._skyboxMaterial;
  }
  get ground() {
    return this._ground;
  }
  get groundTexture() {
    return this._groundTexture;
  }
  get groundMirror() {
    return this._groundMirror;
  }
  get groundMirrorRenderList() {
    if (this._groundMirror) {
      return this._groundMirror.renderList;
    }
    return null;
  }
  get groundMaterial() {
    return this._groundMaterial;
  }
  updateOptions(options) {
    const newOptions = {
      ...this._options,
      ...options
    };
    if (this._ground && !newOptions.createGround) {
      this._ground.dispose();
      this._ground = null;
    }
    if (this._groundMaterial && !newOptions.createGround) {
      this._groundMaterial.dispose();
      this._groundMaterial = null;
    }
    if (this._groundTexture) {
      if (this._options.groundTexture != newOptions.groundTexture) {
        this._groundTexture.dispose();
        this._groundTexture = null;
      }
    }
    if (this._skybox && !newOptions.createSkybox) {
      this._skybox.dispose();
      this._skybox = null;
    }
    if (this._skyboxMaterial && !newOptions.createSkybox) {
      this._skyboxMaterial.dispose();
      this._skyboxMaterial = null;
    }
    if (this._skyboxTexture) {
      if (this._options.skyboxTexture != newOptions.skyboxTexture) {
        this._skyboxTexture.dispose();
        this._skyboxTexture = null;
      }
    }
    if (this._groundMirror && !newOptions.enableGroundMirror) {
      this._groundMirror.dispose();
      this._groundMirror = null;
    }
    if (this._scene.environmentTexture) {
      if (this._options.environmentTexture != newOptions.environmentTexture) {
        this._scene.environmentTexture.dispose();
      }
    }
    this._options = newOptions;
    this._setupBackground();
    this._setupImageProcessing();
  }
  setMainColor(color) {
    if (this.groundMaterial) {
      this.groundMaterial.primaryColor = color;
    }
    if (this.skyboxMaterial) {
      this.skyboxMaterial.primaryColor = color;
    }
    if (this.groundMirror) {
      this.groundMirror.clearColor = new Color4(color.r, color.g, color.b, 1);
    }
  }
  _setupImageProcessing() {
    if (this._options.setupImageProcessing) {
      this._scene.imageProcessingConfiguration.contrast = this._options.cameraContrast;
      this._scene.imageProcessingConfiguration.exposure = this._options.cameraExposure;
      this._scene.imageProcessingConfiguration.toneMappingEnabled = this._options.toneMappingEnabled;
      this._setupEnvironmentTexture();
    }
  }
  _setupEnvironmentTexture() {
    if (this._scene.environmentTexture) {
      return;
    }
    if (this._options.environmentTexture instanceof BaseTexture) {
      this._scene.environmentTexture = this._options.environmentTexture;
      return;
    }
    const environmentTexture = CubeTexture.CreateFromPrefilteredData(this._options.environmentTexture, this._scene);
    this._scene.environmentTexture = environmentTexture;
  }
  _setupBackground() {
    if (!this._rootMesh) {
      this._rootMesh = new Mesh("BackgroundHelper", this._scene);
    }
    this._rootMesh.rotation.y = this._options.backgroundYRotation;
    const sceneSize = this._getSceneSize();
    if (this._options.createGround) {
      this._setupGround(sceneSize);
      this._setupGroundMaterial();
      this._setupGroundDiffuseTexture();
      if (this._options.enableGroundMirror) {
        this._setupGroundMirrorTexture(sceneSize);
      }
      this._setupMirrorInGroundMaterial();
    }
    if (this._options.createSkybox) {
      this._setupSkybox(sceneSize);
      this._setupSkyboxMaterial();
      this._setupSkyboxReflectionTexture();
    }
    this._rootMesh.position.x = sceneSize.rootPosition.x;
    this._rootMesh.position.z = sceneSize.rootPosition.z;
    this._rootMesh.position.y = sceneSize.rootPosition.y;
  }
  _getSceneSize() {
    let groundSize = this._options.groundSize;
    let skyboxSize = this._options.skyboxSize;
    let rootPosition = this._options.rootPosition;
    if (!this._scene.meshes || this._scene.meshes.length === 1) {
      return { groundSize, skyboxSize, rootPosition };
    }
    const sceneExtends = this._scene.getWorldExtends((mesh) => {
      return mesh !== this._ground && mesh !== this._rootMesh && mesh !== this._skybox;
    });
    const sceneDiagonal = sceneExtends.max.subtract(sceneExtends.min);
    if (this._options.sizeAuto) {
      if (this._scene.activeCamera instanceof ArcRotateCamera && this._scene.activeCamera.upperRadiusLimit) {
        groundSize = this._scene.activeCamera.upperRadiusLimit * 2;
        skyboxSize = groundSize;
      }
      const sceneDiagonalLenght = sceneDiagonal.length();
      if (sceneDiagonalLenght > groundSize) {
        groundSize = sceneDiagonalLenght * 2;
        skyboxSize = groundSize;
      }
      groundSize *= 1.1;
      skyboxSize *= 1.5;
      rootPosition = sceneExtends.min.add(sceneDiagonal.scale(0.5));
      rootPosition.y = sceneExtends.min.y - this._options.groundYBias;
    }
    return { groundSize, skyboxSize, rootPosition };
  }
  _setupGround(sceneSize) {
    if (!this._ground || this._ground.isDisposed()) {
      this._ground = CreatePlane("BackgroundPlane", { size: sceneSize.groundSize }, this._scene);
      this._ground.rotation.x = Math.PI / 2;
      this._ground.parent = this._rootMesh;
      this._ground.onDisposeObservable.add(() => {
        this._ground = null;
      });
    }
    this._ground.receiveShadows = this._options.enableGroundShadow;
  }
  _setupGroundMaterial() {
    if (!this._groundMaterial) {
      this._groundMaterial = new BackgroundMaterial("BackgroundPlaneMaterial", this._scene);
    }
    this._groundMaterial.alpha = this._options.groundOpacity;
    this._groundMaterial.alphaMode = 8;
    this._groundMaterial.shadowLevel = this._options.groundShadowLevel;
    this._groundMaterial.primaryColor = this._options.groundColor;
    this._groundMaterial.useRGBColor = false;
    this._groundMaterial.enableNoise = true;
    if (this._ground) {
      this._ground.material = this._groundMaterial;
    }
  }
  _setupGroundDiffuseTexture() {
    if (!this._groundMaterial) {
      return;
    }
    if (this._groundTexture) {
      return;
    }
    if (this._options.groundTexture instanceof BaseTexture) {
      this._groundMaterial.diffuseTexture = this._options.groundTexture;
      return;
    }
    this._groundTexture = new Texture(this._options.groundTexture, this._scene, void 0, void 0, void 0, void 0, this._errorHandler);
    this._groundTexture.gammaSpace = false;
    this._groundTexture.hasAlpha = true;
    this._groundMaterial.diffuseTexture = this._groundTexture;
  }
  _setupGroundMirrorTexture(sceneSize) {
    const wrapping = Texture.CLAMP_ADDRESSMODE;
    if (!this._groundMirror) {
      this._groundMirror = new MirrorTexture("BackgroundPlaneMirrorTexture", { ratio: this._options.groundMirrorSizeRatio }, this._scene, false, this._options.groundMirrorTextureType, Texture.BILINEAR_SAMPLINGMODE, true);
      this._groundMirror.mirrorPlane = new Plane(0, -1, 0, sceneSize.rootPosition.y);
      this._groundMirror.anisotropicFilteringLevel = 1;
      this._groundMirror.wrapU = wrapping;
      this._groundMirror.wrapV = wrapping;
      if (this._groundMirror.renderList) {
        for (let i = 0; i < this._scene.meshes.length; i++) {
          const mesh = this._scene.meshes[i];
          if (mesh !== this._ground && mesh !== this._skybox && mesh !== this._rootMesh) {
            this._groundMirror.renderList.push(mesh);
          }
        }
      }
    }
    const gammaGround = this._options.groundColor.toGammaSpace();
    this._groundMirror.clearColor = new Color4(gammaGround.r, gammaGround.g, gammaGround.b, 1);
    this._groundMirror.adaptiveBlurKernel = this._options.groundMirrorBlurKernel;
  }
  _setupMirrorInGroundMaterial() {
    if (this._groundMaterial) {
      this._groundMaterial.reflectionTexture = this._groundMirror;
      this._groundMaterial.reflectionFresnel = true;
      this._groundMaterial.reflectionAmount = this._options.groundMirrorAmount;
      this._groundMaterial.reflectionStandardFresnelWeight = this._options.groundMirrorFresnelWeight;
      this._groundMaterial.reflectionFalloffDistance = this._options.groundMirrorFallOffDistance;
    }
  }
  _setupSkybox(sceneSize) {
    if (!this._skybox || this._skybox.isDisposed()) {
      this._skybox = CreateBox("BackgroundSkybox", { size: sceneSize.skyboxSize, sideOrientation: Mesh.BACKSIDE }, this._scene);
      this._skybox.onDisposeObservable.add(() => {
        this._skybox = null;
      });
    }
    this._skybox.parent = this._rootMesh;
  }
  _setupSkyboxMaterial() {
    if (!this._skybox) {
      return;
    }
    if (!this._skyboxMaterial) {
      this._skyboxMaterial = new BackgroundMaterial("BackgroundSkyboxMaterial", this._scene);
    }
    this._skyboxMaterial.useRGBColor = false;
    this._skyboxMaterial.primaryColor = this._options.skyboxColor;
    this._skyboxMaterial.enableNoise = true;
    this._skybox.material = this._skyboxMaterial;
  }
  _setupSkyboxReflectionTexture() {
    if (!this._skyboxMaterial) {
      return;
    }
    if (this._skyboxTexture) {
      return;
    }
    if (this._options.skyboxTexture instanceof BaseTexture) {
      this._skyboxMaterial.reflectionTexture = this._options.skyboxTexture;
      return;
    }
    this._skyboxTexture = new CubeTexture(this._options.skyboxTexture, this._scene, void 0, void 0, void 0, void 0, this._errorHandler);
    this._skyboxTexture.coordinatesMode = Texture.SKYBOX_MODE;
    this._skyboxTexture.gammaSpace = false;
    this._skyboxMaterial.reflectionTexture = this._skyboxTexture;
  }
  dispose() {
    if (this._groundMaterial) {
      this._groundMaterial.dispose(true, true);
    }
    if (this._skyboxMaterial) {
      this._skyboxMaterial.dispose(true, true);
    }
    this._rootMesh.dispose(false);
  }
};
EnvironmentHelper._GroundTextureCDNUrl = "https://assets.babylonjs.com/environments/backgroundGround.png";
EnvironmentHelper._SkyboxTextureCDNUrl = "https://assets.babylonjs.com/environments/backgroundSkybox.dds";
EnvironmentHelper._EnvironmentTextureCDNUrl = "https://assets.babylonjs.com/environments/environmentSpecular.env";

// node_modules/@babylonjs/core/Helpers/textureDome.js
var TextureDome = class extends TransformNode {
  constructor(name137, textureUrlOrElement, options, scene, onError = null) {
    super(name137, scene);
    this.onError = onError;
    this._halfDome = false;
    this._crossEye = false;
    this._useDirectMapping = false;
    this._textureMode = TextureDome.MODE_MONOSCOPIC;
    this._onBeforeCameraRenderObserver = null;
    this.onLoadErrorObservable = new Observable();
    this.onLoadObservable = new Observable();
    scene = this.getScene();
    name137 = name137 || "textureDome";
    options.resolution = Math.abs(options.resolution) | 0 || 32;
    options.clickToPlay = Boolean(options.clickToPlay);
    options.autoPlay = options.autoPlay === void 0 ? true : Boolean(options.autoPlay);
    options.loop = options.loop === void 0 ? true : Boolean(options.loop);
    options.size = Math.abs(options.size) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1e3);
    if (options.useDirectMapping === void 0) {
      this._useDirectMapping = true;
    } else {
      this._useDirectMapping = options.useDirectMapping;
    }
    if (options.faceForward === void 0) {
      options.faceForward = true;
    }
    this._setReady(false);
    if (!options.mesh) {
      this._mesh = CreateSphere(name137 + "_mesh", { segments: options.resolution, diameter: options.size, updatable: false, sideOrientation: Mesh.BACKSIDE }, scene);
    } else {
      this._mesh = options.mesh;
    }
    const material = this._material = new BackgroundMaterial(name137 + "_material", scene);
    material.useEquirectangularFOV = true;
    material.fovMultiplier = 1;
    material.opacityFresnel = false;
    const texture = this._initTexture(textureUrlOrElement, scene, options);
    this.texture = texture;
    this._mesh.material = material;
    this._mesh.parent = this;
    this._halfDomeMask = CreateSphere("", { slice: 0.5, diameter: options.size * 0.98, segments: options.resolution * 2, sideOrientation: Mesh.BACKSIDE }, scene);
    this._halfDomeMask.rotate(Axis.X, -Math.PI / 2);
    this._halfDomeMask.parent = this._mesh;
    this._halfDome = !!options.halfDomeMode;
    this._halfDomeMask.setEnabled(this._halfDome);
    this._crossEye = !!options.crossEyeMode;
    this._texture.anisotropicFilteringLevel = 1;
    this._texture.onLoadObservable.addOnce(() => {
      this._setReady(true);
    });
    if (options.faceForward && scene.activeCamera) {
      const camera = scene.activeCamera;
      const forward = Vector3.Forward();
      const direction = Vector3.TransformNormal(forward, camera.getViewMatrix());
      direction.normalize();
      this.rotation.y = Math.acos(Vector3.Dot(forward, direction));
    }
    this._changeTextureMode(this._textureMode);
  }
  get texture() {
    return this._texture;
  }
  set texture(newTexture) {
    if (this._texture === newTexture) {
      return;
    }
    this._texture = newTexture;
    if (this._useDirectMapping) {
      this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;
      this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;
      this._material.diffuseTexture = this._texture;
    } else {
      this._texture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE;
      this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;
      this._material.reflectionTexture = this._texture;
    }
    this._changeTextureMode(this._textureMode);
  }
  get mesh() {
    return this._mesh;
  }
  get fovMultiplier() {
    return this._material.fovMultiplier;
  }
  set fovMultiplier(value) {
    this._material.fovMultiplier = value;
  }
  get textureMode() {
    return this._textureMode;
  }
  set textureMode(value) {
    if (this._textureMode === value) {
      return;
    }
    this._changeTextureMode(value);
  }
  get halfDome() {
    return this._halfDome;
  }
  set halfDome(enabled) {
    this._halfDome = enabled;
    this._halfDomeMask.setEnabled(enabled);
    this._changeTextureMode(this._textureMode);
  }
  set crossEye(enabled) {
    this._crossEye = enabled;
    this._changeTextureMode(this._textureMode);
  }
  get crossEye() {
    return this._crossEye;
  }
  get material() {
    return this._material;
  }
  _changeTextureMode(value) {
    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
    this._textureMode = value;
    this._texture.uScale = 1;
    this._texture.vScale = 1;
    this._texture.uOffset = 0;
    this._texture.vOffset = 0;
    this._texture.vAng = 0;
    switch (value) {
      case TextureDome.MODE_MONOSCOPIC:
        if (this._halfDome) {
          this._texture.uScale = 2;
          this._texture.uOffset = -1;
        }
        break;
      case TextureDome.MODE_SIDEBYSIDE: {
        this._texture.uScale = this._halfDome ? 0.99999 : 0.5;
        const rightOffset = this._halfDome ? 0 : 0.5;
        const leftOffset = this._halfDome ? -0.5 : 0;
        this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add((camera) => {
          let isRightCamera = camera.isRightCamera;
          if (this._crossEye) {
            isRightCamera = !isRightCamera;
          }
          if (isRightCamera) {
            this._texture.uOffset = rightOffset;
          } else {
            this._texture.uOffset = leftOffset;
          }
        });
        break;
      }
      case TextureDome.MODE_TOPBOTTOM:
        this._texture.vScale = this._halfDome ? 0.99999 : 0.5;
        this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add((camera) => {
          let isRightCamera = camera.isRightCamera;
          if (this._crossEye) {
            isRightCamera = !isRightCamera;
          }
          this._texture.vOffset = isRightCamera ? 0.5 : 0;
        });
        break;
    }
  }
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this._texture.dispose();
    this._mesh.dispose();
    this._material.dispose();
    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
    this.onLoadErrorObservable.clear();
    this.onLoadObservable.clear();
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
};
TextureDome.MODE_MONOSCOPIC = 0;
TextureDome.MODE_TOPBOTTOM = 1;
TextureDome.MODE_SIDEBYSIDE = 2;

// node_modules/@babylonjs/core/Helpers/photoDome.js
var PhotoDome = class extends TextureDome {
  get photoTexture() {
    return this.texture;
  }
  set photoTexture(value) {
    this.texture = value;
  }
  get imageMode() {
    return this.textureMode;
  }
  set imageMode(value) {
    this.textureMode = value;
  }
  _initTexture(urlsOrElement, scene, options) {
    return new Texture(urlsOrElement, scene, !options.generateMipMaps, !this._useDirectMapping, void 0, () => {
      this.onLoadObservable.notifyObservers();
    }, (message, exception) => {
      this.onLoadErrorObservable.notifyObservers(message || "Unknown error occured");
      if (this.onError) {
        this.onError(message, exception);
      }
    });
  }
};
PhotoDome.MODE_MONOSCOPIC = TextureDome.MODE_MONOSCOPIC;
PhotoDome.MODE_TOPBOTTOM = TextureDome.MODE_TOPBOTTOM;
PhotoDome.MODE_SIDEBYSIDE = TextureDome.MODE_SIDEBYSIDE;

// node_modules/@babylonjs/core/Misc/dds.js
var DDS_MAGIC = 542327876;
var DDSD_MIPMAPCOUNT = 131072;
var DDSCAPS2_CUBEMAP = 512;
var DDPF_FOURCC = 4;
var DDPF_RGB = 64;
var DDPF_LUMINANCE = 131072;
function FourCCToInt32(value) {
  return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
}
function Int32ToFourCC(value) {
  return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);
}
var FOURCC_DXT1 = FourCCToInt32("DXT1");
var FOURCC_DXT3 = FourCCToInt32("DXT3");
var FOURCC_DXT5 = FourCCToInt32("DXT5");
var FOURCC_DX10 = FourCCToInt32("DX10");
var FOURCC_D3DFMT_R16G16B16A16F = 113;
var FOURCC_D3DFMT_R32G32B32A32F = 116;
var DXGI_FORMAT_R32G32B32A32_FLOAT = 2;
var DXGI_FORMAT_R16G16B16A16_FLOAT = 10;
var DXGI_FORMAT_B8G8R8X8_UNORM = 88;
var headerLengthInt = 31;
var off_magic = 0;
var off_size = 1;
var off_flags = 2;
var off_height = 3;
var off_width = 4;
var off_mipmapCount = 7;
var off_pfFlags = 20;
var off_pfFourCC = 21;
var off_RGBbpp = 22;
var off_RMask = 23;
var off_GMask = 24;
var off_BMask = 25;
var off_AMask = 26;
var off_caps2 = 28;
var off_dxgiFormat = 32;
var DDSTools = class {
  static GetDDSInfo(data) {
    const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);
    const extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);
    let mipmapCount = 1;
    if (header[off_flags] & DDSD_MIPMAPCOUNT) {
      mipmapCount = Math.max(1, header[off_mipmapCount]);
    }
    const fourCC = header[off_pfFourCC];
    const dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;
    let textureType = 0;
    switch (fourCC) {
      case FOURCC_D3DFMT_R16G16B16A16F:
        textureType = 2;
        break;
      case FOURCC_D3DFMT_R32G32B32A32F:
        textureType = 1;
        break;
      case FOURCC_DX10:
        if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {
          textureType = 2;
          break;
        }
        if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {
          textureType = 1;
          break;
        }
    }
    return {
      width: header[off_width],
      height: header[off_height],
      mipmapCount,
      isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,
      isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,
      isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,
      isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,
      isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,
      dxgiFormat,
      textureType
    };
  }
  static _GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    const destArray = new Float32Array(dataLength);
    const srcData = new Uint16Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = (x + y * width) * 4;
        destArray[index] = FromHalfFloat(srcData[srcPos]);
        destArray[index + 1] = FromHalfFloat(srcData[srcPos + 1]);
        destArray[index + 2] = FromHalfFloat(srcData[srcPos + 2]);
        if (DDSTools.StoreLODInAlphaChannel) {
          destArray[index + 3] = lod;
        } else {
          destArray[index + 3] = FromHalfFloat(srcData[srcPos + 3]);
        }
        index += 4;
      }
    }
    return destArray;
  }
  static _GetHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    if (DDSTools.StoreLODInAlphaChannel) {
      const destArray = new Uint16Array(dataLength);
      const srcData = new Uint16Array(arrayBuffer, dataOffset);
      let index = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const srcPos = (x + y * width) * 4;
          destArray[index] = srcData[srcPos];
          destArray[index + 1] = srcData[srcPos + 1];
          destArray[index + 2] = srcData[srcPos + 2];
          destArray[index + 3] = ToHalfFloat(lod);
          index += 4;
        }
      }
      return destArray;
    }
    return new Uint16Array(arrayBuffer, dataOffset, dataLength);
  }
  static _GetFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    if (DDSTools.StoreLODInAlphaChannel) {
      const destArray = new Float32Array(dataLength);
      const srcData = new Float32Array(arrayBuffer, dataOffset);
      let index = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const srcPos = (x + y * width) * 4;
          destArray[index] = srcData[srcPos];
          destArray[index + 1] = srcData[srcPos + 1];
          destArray[index + 2] = srcData[srcPos + 2];
          destArray[index + 3] = lod;
          index += 4;
        }
      }
      return destArray;
    }
    return new Float32Array(arrayBuffer, dataOffset, dataLength);
  }
  static _GetFloatAsHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    const destArray = new Uint16Array(dataLength);
    const srcData = new Float32Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        destArray[index] = ToHalfFloat(srcData[index]);
        destArray[index + 1] = ToHalfFloat(srcData[index + 1]);
        destArray[index + 2] = ToHalfFloat(srcData[index + 2]);
        if (DDSTools.StoreLODInAlphaChannel) {
          destArray[index + 3] = ToHalfFloat(lod);
        } else {
          destArray[index + 3] = ToHalfFloat(srcData[index + 3]);
        }
        index += 4;
      }
    }
    return destArray;
  }
  static _GetFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    const destArray = new Uint8Array(dataLength);
    const srcData = new Float32Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = (x + y * width) * 4;
        destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;
        destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;
        destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;
        if (DDSTools.StoreLODInAlphaChannel) {
          destArray[index + 3] = lod;
        } else {
          destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;
        }
        index += 4;
      }
    }
    return destArray;
  }
  static _GetHalfFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    const destArray = new Uint8Array(dataLength);
    const srcData = new Uint16Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = (x + y * width) * 4;
        destArray[index] = Scalar.Clamp(FromHalfFloat(srcData[srcPos])) * 255;
        destArray[index + 1] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 1])) * 255;
        destArray[index + 2] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 2])) * 255;
        if (DDSTools.StoreLODInAlphaChannel) {
          destArray[index + 3] = lod;
        } else {
          destArray[index + 3] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 3])) * 255;
        }
        index += 4;
      }
    }
    return destArray;
  }
  static _GetRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset) {
    const byteArray = new Uint8Array(dataLength);
    const srcData = new Uint8Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = (x + y * width) * 4;
        byteArray[index] = srcData[srcPos + rOffset];
        byteArray[index + 1] = srcData[srcPos + gOffset];
        byteArray[index + 2] = srcData[srcPos + bOffset];
        byteArray[index + 3] = srcData[srcPos + aOffset];
        index += 4;
      }
    }
    return byteArray;
  }
  static _ExtractLongWordOrder(value) {
    if (value === 0 || value === 255 || value === -16777216) {
      return 0;
    }
    return 1 + DDSTools._ExtractLongWordOrder(value >> 8);
  }
  static _GetRGBArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset) {
    const byteArray = new Uint8Array(dataLength);
    const srcData = new Uint8Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = (x + y * width) * 3;
        byteArray[index] = srcData[srcPos + rOffset];
        byteArray[index + 1] = srcData[srcPos + gOffset];
        byteArray[index + 2] = srcData[srcPos + bOffset];
        index += 3;
      }
    }
    return byteArray;
  }
  static _GetLuminanceArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer) {
    const byteArray = new Uint8Array(dataLength);
    const srcData = new Uint8Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = x + y * width;
        byteArray[index] = srcData[srcPos];
        index++;
      }
    }
    return byteArray;
  }
  static UploadDDSLevels(engine, texture, data, info, loadMipmaps, faces, lodIndex = -1, currentFace, destTypeMustBeFilterable = true) {
    let sphericalPolynomialFaces = null;
    if (info.sphericalPolynomial) {
      sphericalPolynomialFaces = new Array();
    }
    const ext = !!engine.getCaps().s3tc;
    texture.generateMipMaps = loadMipmaps;
    const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);
    let fourCC, width, height, dataLength = 0, dataOffset;
    let byteArray, mipmapCount, mip;
    let internalCompressedFormat = 0;
    let blockBytes = 1;
    if (header[off_magic] !== DDS_MAGIC) {
      Logger.Error("Invalid magic number in DDS header");
      return;
    }
    if (!info.isFourCC && !info.isRGB && !info.isLuminance) {
      Logger.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");
      return;
    }
    if (info.isCompressed && !ext) {
      Logger.Error("Compressed textures are not supported on this platform.");
      return;
    }
    let bpp = header[off_RGBbpp];
    dataOffset = header[off_size] + 4;
    let computeFormats = false;
    if (info.isFourCC) {
      fourCC = header[off_pfFourCC];
      switch (fourCC) {
        case FOURCC_DXT1:
          blockBytes = 8;
          internalCompressedFormat = 33777;
          break;
        case FOURCC_DXT3:
          blockBytes = 16;
          internalCompressedFormat = 33778;
          break;
        case FOURCC_DXT5:
          blockBytes = 16;
          internalCompressedFormat = 33779;
          break;
        case FOURCC_D3DFMT_R16G16B16A16F:
          computeFormats = true;
          bpp = 64;
          break;
        case FOURCC_D3DFMT_R32G32B32A32F:
          computeFormats = true;
          bpp = 128;
          break;
        case FOURCC_DX10: {
          dataOffset += 5 * 4;
          let supported = false;
          switch (info.dxgiFormat) {
            case DXGI_FORMAT_R16G16B16A16_FLOAT:
              computeFormats = true;
              bpp = 64;
              supported = true;
              break;
            case DXGI_FORMAT_R32G32B32A32_FLOAT:
              computeFormats = true;
              bpp = 128;
              supported = true;
              break;
            case DXGI_FORMAT_B8G8R8X8_UNORM:
              info.isRGB = true;
              info.isFourCC = false;
              bpp = 32;
              supported = true;
              break;
          }
          if (supported) {
            break;
          }
        }
        default:
          console.error("Unsupported FourCC code:", Int32ToFourCC(fourCC));
          return;
      }
    }
    const rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);
    const gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);
    const bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);
    const aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);
    if (computeFormats) {
      internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);
    }
    mipmapCount = 1;
    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
      mipmapCount = Math.max(1, header[off_mipmapCount]);
    }
    const startFace = currentFace || 0;
    const caps = engine.getCaps();
    for (let face = startFace; face < faces; face++) {
      width = header[off_width];
      height = header[off_height];
      for (mip = 0; mip < mipmapCount; ++mip) {
        if (lodIndex === -1 || lodIndex === mip) {
          const i = lodIndex === -1 ? mip : 0;
          if (!info.isCompressed && info.isFourCC) {
            texture.format = 5;
            dataLength = width * height * 4;
            let floatArray = null;
            if (engine._badOS || engine._badDesktopOS || !caps.textureHalfFloat && !caps.textureFloat) {
              if (bpp === 128) {
                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                if (sphericalPolynomialFaces && i == 0) {
                  sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));
                }
              } else if (bpp === 64) {
                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                if (sphericalPolynomialFaces && i == 0) {
                  sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));
                }
              }
              texture.type = 0;
            } else {
              const floatAvailable = caps.textureFloat && (destTypeMustBeFilterable && caps.textureFloatLinearFiltering || !destTypeMustBeFilterable);
              const halfFloatAvailable = caps.textureHalfFloat && (destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering || !destTypeMustBeFilterable);
              const destType = (bpp === 128 || bpp === 64 && !halfFloatAvailable) && floatAvailable ? 1 : (bpp === 64 || bpp === 128 && !floatAvailable) && halfFloatAvailable ? 2 : 0;
              let dataGetter;
              let dataGetterPolynomial = null;
              switch (bpp) {
                case 128: {
                  switch (destType) {
                    case 1:
                      dataGetter = DDSTools._GetFloatRGBAArrayBuffer;
                      dataGetterPolynomial = null;
                      break;
                    case 2:
                      dataGetter = DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;
                      dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;
                      break;
                    case 0:
                      dataGetter = DDSTools._GetFloatAsUIntRGBAArrayBuffer;
                      dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;
                      break;
                  }
                  break;
                }
                default: {
                  switch (destType) {
                    case 1:
                      dataGetter = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;
                      dataGetterPolynomial = null;
                      break;
                    case 2:
                      dataGetter = DDSTools._GetHalfFloatRGBAArrayBuffer;
                      dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;
                      break;
                    case 0:
                      dataGetter = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;
                      dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;
                      break;
                  }
                  break;
                }
              }
              texture.type = destType;
              floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
              if (sphericalPolynomialFaces && i == 0) {
                sphericalPolynomialFaces.push(dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray);
              }
            }
            if (floatArray) {
              engine._uploadDataToTextureDirectly(texture, floatArray, face, i);
            }
          } else if (info.isRGB) {
            texture.type = 0;
            if (bpp === 24) {
              texture.format = 4;
              dataLength = width * height * 3;
              byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);
              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
            } else {
              texture.format = 5;
              dataLength = width * height * 4;
              byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);
              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
            }
          } else if (info.isLuminance) {
            const unpackAlignment = engine._getUnpackAlignement();
            const unpaddedRowSize = width;
            const paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;
            dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;
            byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);
            texture.format = 1;
            texture.type = 0;
            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
          } else {
            dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
            byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);
            texture.type = 0;
            engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);
          }
        }
        dataOffset += bpp ? width * height * (bpp / 8) : dataLength;
        width *= 0.5;
        height *= 0.5;
        width = Math.max(1, width);
        height = Math.max(1, height);
      }
      if (currentFace !== void 0) {
        break;
      }
    }
    if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {
      info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({
        size: header[off_width],
        right: sphericalPolynomialFaces[0],
        left: sphericalPolynomialFaces[1],
        up: sphericalPolynomialFaces[2],
        down: sphericalPolynomialFaces[3],
        front: sphericalPolynomialFaces[4],
        back: sphericalPolynomialFaces[5],
        format: 5,
        type: 1,
        gammaSpace: false
      });
    } else {
      info.sphericalPolynomial = void 0;
    }
  }
};
DDSTools.StoreLODInAlphaChannel = false;
ThinEngine.prototype.createPrefilteredCubeTexture = function(rootUrl, scene, lodScale, lodOffset, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = true) {
  const callback = (loadData) => {
    if (!loadData) {
      if (onLoad) {
        onLoad(null);
      }
      return;
    }
    const texture = loadData.texture;
    if (!createPolynomials) {
      texture._sphericalPolynomial = new SphericalPolynomial();
    } else if (loadData.info.sphericalPolynomial) {
      texture._sphericalPolynomial = loadData.info.sphericalPolynomial;
    }
    texture._source = InternalTextureSource.CubePrefiltered;
    if (this.getCaps().textureLOD) {
      if (onLoad) {
        onLoad(texture);
      }
      return;
    }
    const mipSlices = 3;
    const gl = this._gl;
    const width = loadData.width;
    if (!width) {
      return;
    }
    const textures = [];
    for (let i = 0; i < mipSlices; i++) {
      const smoothness = i / (mipSlices - 1);
      const roughness = 1 - smoothness;
      const minLODIndex = lodOffset;
      const maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset;
      const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;
      const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));
      const glTextureFromLod = new InternalTexture(this, InternalTextureSource.Temp);
      glTextureFromLod.type = texture.type;
      glTextureFromLod.format = texture.format;
      glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));
      glTextureFromLod.height = glTextureFromLod.width;
      glTextureFromLod.isCube = true;
      glTextureFromLod._cachedWrapU = 0;
      glTextureFromLod._cachedWrapV = 0;
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);
      glTextureFromLod.samplingMode = 2;
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      if (loadData.isDDS) {
        const info = loadData.info;
        const data = loadData.data;
        this._unpackFlipY(info.isCompressed);
        DDSTools.UploadDDSLevels(this, glTextureFromLod, data, info, true, 6, mipmapIndex);
      } else {
        Logger.Warn("DDS is the only prefiltered cube map supported so far.");
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
      const lodTexture = new BaseTexture(scene);
      lodTexture._isCube = true;
      lodTexture._texture = glTextureFromLod;
      glTextureFromLod.isReady = true;
      textures.push(lodTexture);
    }
    texture._lodTextureHigh = textures[2];
    texture._lodTextureMid = textures[1];
    texture._lodTextureLow = textures[0];
    if (onLoad) {
      onLoad(texture);
    }
  };
  return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);
};

// node_modules/@babylonjs/core/Materials/Textures/Loaders/ddsTextureLoader.js
var _DDSTextureLoader = class {
  constructor() {
    this.supportCascades = true;
  }
  canLoad(extension) {
    return extension.endsWith(".dds");
  }
  loadCubeData(imgs, texture, createPolynomials, onLoad) {
    const engine = texture.getEngine();
    let info;
    let loadMipmap = false;
    let maxLevel = 1e3;
    if (Array.isArray(imgs)) {
      for (let index = 0; index < imgs.length; index++) {
        const data = imgs[index];
        info = DDSTools.GetDDSInfo(data);
        texture.width = info.width;
        texture.height = info.height;
        loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;
        engine._unpackFlipY(info.isCompressed);
        DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6, -1, index);
        if (!info.isFourCC && info.mipmapCount === 1) {
          engine.generateMipMapsForCubemap(texture);
        } else {
          maxLevel = info.mipmapCount - 1;
        }
      }
    } else {
      const data = imgs;
      info = DDSTools.GetDDSInfo(data);
      texture.width = info.width;
      texture.height = info.height;
      if (createPolynomials) {
        info.sphericalPolynomial = new SphericalPolynomial();
      }
      loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;
      engine._unpackFlipY(info.isCompressed);
      DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6);
      if (!info.isFourCC && info.mipmapCount === 1) {
        engine.generateMipMapsForCubemap(texture, false);
      } else {
        maxLevel = info.mipmapCount - 1;
      }
    }
    engine._setCubeMapTextureParams(texture, loadMipmap, maxLevel);
    texture.isReady = true;
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
    if (onLoad) {
      onLoad({ isDDS: true, width: texture.width, info, data: imgs, texture });
    }
  }
  loadData(data, texture, callback) {
    const info = DDSTools.GetDDSInfo(data);
    const loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps && info.width >> info.mipmapCount - 1 === 1;
    callback(info.width, info.height, loadMipmap, info.isFourCC, () => {
      DDSTools.UploadDDSLevels(texture.getEngine(), texture, data, info, loadMipmap, 1);
    });
  }
};
Engine._TextureLoaders.push(new _DDSTextureLoader());

// node_modules/@babylonjs/core/Materials/Textures/Loaders/envTextureLoader.js
var _ENVTextureLoader = class {
  constructor() {
    this.supportCascades = false;
  }
  canLoad(extension) {
    return extension.endsWith(".env");
  }
  loadCubeData(data, texture, createPolynomials, onLoad, onError) {
    if (Array.isArray(data)) {
      return;
    }
    const info = GetEnvInfo(data);
    if (info) {
      texture.width = info.width;
      texture.height = info.width;
      try {
        UploadEnvSpherical(texture, info);
        UploadEnvLevelsAsync(texture, data, info).then(() => {
          texture.isReady = true;
          texture.onLoadedObservable.notifyObservers(texture);
          texture.onLoadedObservable.clear();
          if (onLoad) {
            onLoad();
          }
        }, (reason) => {
          onError === null || onError === void 0 ? void 0 : onError("Can not upload environment levels", reason);
        });
      } catch (e) {
        onError === null || onError === void 0 ? void 0 : onError("Can not upload environment file", e);
      }
    } else if (onError) {
      onError("Can not parse the environment file", null);
    }
  }
  loadData() {
    throw ".env not supported in 2d.";
  }
};
Engine._TextureLoaders.push(new _ENVTextureLoader());

// node_modules/@babylonjs/core/Misc/khronosTextureContainer.js
var KhronosTextureContainer = class {
  constructor(data, facesExpected) {
    this.data = data;
    this.isInvalid = false;
    if (!KhronosTextureContainer.IsValid(data)) {
      this.isInvalid = true;
      Logger.Error("texture missing KTX identifier");
      return;
    }
    const dataSize = Uint32Array.BYTES_PER_ELEMENT;
    const headerDataView = new DataView(this.data.buffer, this.data.byteOffset + 12, 13 * dataSize);
    const endianness = headerDataView.getUint32(0, true);
    const littleEndian = endianness === 67305985;
    this.glType = headerDataView.getUint32(1 * dataSize, littleEndian);
    this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian);
    this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian);
    this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian);
    this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian);
    this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian);
    this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian);
    this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian);
    this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian);
    this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian);
    this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian);
    this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian);
    if (this.glType !== 0) {
      Logger.Error("only compressed formats currently supported");
      return;
    } else {
      this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);
    }
    if (this.pixelHeight === 0 || this.pixelDepth !== 0) {
      Logger.Error("only 2D textures currently supported");
      return;
    }
    if (this.numberOfArrayElements !== 0) {
      Logger.Error("texture arrays not currently supported");
      return;
    }
    if (this.numberOfFaces !== facesExpected) {
      Logger.Error("number of faces expected" + facesExpected + ", but found " + this.numberOfFaces);
      return;
    }
    this.loadType = KhronosTextureContainer.COMPRESSED_2D;
  }
  uploadLevels(texture, loadMipmaps) {
    switch (this.loadType) {
      case KhronosTextureContainer.COMPRESSED_2D:
        this._upload2DCompressedLevels(texture, loadMipmaps);
        break;
      case KhronosTextureContainer.TEX_2D:
      case KhronosTextureContainer.COMPRESSED_3D:
      case KhronosTextureContainer.TEX_3D:
    }
  }
  _upload2DCompressedLevels(texture, loadMipmaps) {
    let dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;
    let width = this.pixelWidth;
    let height = this.pixelHeight;
    const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;
    for (let level = 0; level < mipmapCount; level++) {
      const imageSize = new Int32Array(this.data.buffer, this.data.byteOffset + dataOffset, 1)[0];
      dataOffset += 4;
      for (let face = 0; face < this.numberOfFaces; face++) {
        const byteArray = new Uint8Array(this.data.buffer, this.data.byteOffset + dataOffset, imageSize);
        const engine = texture.getEngine();
        engine._uploadCompressedDataToTextureDirectly(texture, texture.format, width, height, byteArray, face, level);
        dataOffset += imageSize;
        dataOffset += 3 - (imageSize + 3) % 4;
      }
      width = Math.max(1, width * 0.5);
      height = Math.max(1, height * 0.5);
    }
  }
  static IsValid(data) {
    if (data.byteLength >= 12) {
      const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);
      if (identifier[0] === 171 && identifier[1] === 75 && identifier[2] === 84 && identifier[3] === 88 && identifier[4] === 32 && identifier[5] === 49 && identifier[6] === 49 && identifier[7] === 187 && identifier[8] === 13 && identifier[9] === 10 && identifier[10] === 26 && identifier[11] === 10) {
        return true;
      }
    }
    return false;
  }
};
KhronosTextureContainer.HEADER_LEN = 12 + 13 * 4;
KhronosTextureContainer.COMPRESSED_2D = 0;
KhronosTextureContainer.COMPRESSED_3D = 1;
KhronosTextureContainer.TEX_2D = 2;
KhronosTextureContainer.TEX_3D = 3;

// node_modules/@babylonjs/core/Misc/khronosTextureContainer2.js
function getAbsoluteUrlOrNull(url) {
  return url ? Tools.GetAbsoluteUrl(url) : null;
}
function applyConfig(urls) {
  if (urls.wasmUASTCToASTC !== null) {
    KTX2DECODER.LiteTranscoder_UASTC_ASTC.WasmModuleURL = urls.wasmUASTCToASTC;
  }
  if (urls.wasmUASTCToBC7 !== null) {
    KTX2DECODER.LiteTranscoder_UASTC_BC7.WasmModuleURL = urls.wasmUASTCToBC7;
  }
  if (urls.wasmUASTCToRGBA_UNORM !== null) {
    KTX2DECODER.LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL = urls.wasmUASTCToRGBA_UNORM;
  }
  if (urls.wasmUASTCToRGBA_SRGB !== null) {
    KTX2DECODER.LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL = urls.wasmUASTCToRGBA_SRGB;
  }
  if (urls.wasmUASTCToR8_UNORM !== null) {
    KTX2DECODER.LiteTranscoder_UASTC_R8_UNORM.WasmModuleURL = urls.wasmUASTCToR8_UNORM;
  }
  if (urls.wasmUASTCToRG8_UNORM !== null) {
    KTX2DECODER.LiteTranscoder_UASTC_RG8_UNORM.WasmModuleURL = urls.wasmUASTCToRG8_UNORM;
  }
  if (urls.jsMSCTranscoder !== null) {
    KTX2DECODER.MSCTranscoder.JSModuleURL = urls.jsMSCTranscoder;
  }
  if (urls.wasmMSCTranscoder !== null) {
    KTX2DECODER.MSCTranscoder.WasmModuleURL = urls.wasmMSCTranscoder;
  }
  if (urls.wasmZSTDDecoder !== null) {
    KTX2DECODER.ZSTDDecoder.WasmModuleURL = urls.wasmZSTDDecoder;
  }
}
var KhronosTextureContainer2 = class {
  constructor(engine, numWorkers = KhronosTextureContainer2.DefaultNumWorkers) {
    this._engine = engine;
    KhronosTextureContainer2._Initialize(numWorkers);
  }
  static GetDefaultNumWorkers() {
    if (typeof navigator !== "object" || !navigator.hardwareConcurrency) {
      return 1;
    }
    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);
  }
  static _Initialize(numWorkers) {
    if (KhronosTextureContainer2._WorkerPoolPromise || KhronosTextureContainer2._DecoderModulePromise) {
      return;
    }
    const urls = {
      jsDecoderModule: Tools.GetAbsoluteUrl(this.URLConfig.jsDecoderModule),
      wasmUASTCToASTC: getAbsoluteUrlOrNull(this.URLConfig.wasmUASTCToASTC),
      wasmUASTCToBC7: getAbsoluteUrlOrNull(this.URLConfig.wasmUASTCToBC7),
      wasmUASTCToRGBA_UNORM: getAbsoluteUrlOrNull(this.URLConfig.wasmUASTCToRGBA_UNORM),
      wasmUASTCToRGBA_SRGB: getAbsoluteUrlOrNull(this.URLConfig.wasmUASTCToRGBA_SRGB),
      wasmUASTCToR8_UNORM: getAbsoluteUrlOrNull(this.URLConfig.wasmUASTCToR8_UNORM),
      wasmUASTCToRG8_UNORM: getAbsoluteUrlOrNull(this.URLConfig.wasmUASTCToRG8_UNORM),
      jsMSCTranscoder: getAbsoluteUrlOrNull(this.URLConfig.jsMSCTranscoder),
      wasmMSCTranscoder: getAbsoluteUrlOrNull(this.URLConfig.wasmMSCTranscoder),
      wasmZSTDDecoder: getAbsoluteUrlOrNull(this.URLConfig.wasmZSTDDecoder)
    };
    if (numWorkers && typeof Worker === "function" && typeof URL !== "undefined") {
      KhronosTextureContainer2._WorkerPoolPromise = new Promise((resolve) => {
        const workerContent = `${applyConfig}(${workerFunc})()`;
        const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
        resolve(new AutoReleaseWorkerPool(numWorkers, () => new Promise((resolve2, reject) => {
          const worker = new Worker(workerBlobUrl);
          const onError = (error) => {
            worker.removeEventListener("error", onError);
            worker.removeEventListener("message", onMessage);
            reject(error);
          };
          const onMessage = (message) => {
            if (message.data.action === "init") {
              worker.removeEventListener("error", onError);
              worker.removeEventListener("message", onMessage);
              resolve2(worker);
            }
          };
          worker.addEventListener("error", onError);
          worker.addEventListener("message", onMessage);
          worker.postMessage({
            action: "init",
            urls
          });
        })));
      });
    } else if (typeof KTX2DECODER === "undefined") {
      KhronosTextureContainer2._DecoderModulePromise = Tools.LoadScriptAsync(urls.jsDecoderModule).then(() => {
        KTX2DECODER.MSCTranscoder.UseFromWorkerThread = false;
        KTX2DECODER.WASMMemoryManager.LoadBinariesFromCurrentThread = true;
        applyConfig(urls);
        return new KTX2DECODER.KTX2Decoder();
      });
    } else {
      KTX2DECODER.MSCTranscoder.UseFromWorkerThread = false;
      KTX2DECODER.WASMMemoryManager.LoadBinariesFromCurrentThread = true;
      KhronosTextureContainer2._DecoderModulePromise = Promise.resolve(new KTX2DECODER.KTX2Decoder());
    }
  }
  uploadAsync(data, internalTexture, options) {
    const caps = this._engine.getCaps();
    const compressedTexturesCaps = {
      astc: !!caps.astc,
      bptc: !!caps.bptc,
      s3tc: !!caps.s3tc,
      pvrtc: !!caps.pvrtc,
      etc2: !!caps.etc2,
      etc1: !!caps.etc1
    };
    if (KhronosTextureContainer2._WorkerPoolPromise) {
      return KhronosTextureContainer2._WorkerPoolPromise.then((workerPool) => {
        return new Promise((resolve, reject) => {
          workerPool.push((worker, onComplete) => {
            const onError = (error) => {
              worker.removeEventListener("error", onError);
              worker.removeEventListener("message", onMessage);
              reject(error);
              onComplete();
            };
            const onMessage = (message) => {
              if (message.data.action === "decoded") {
                worker.removeEventListener("error", onError);
                worker.removeEventListener("message", onMessage);
                if (!message.data.success) {
                  reject({ message: message.data.msg });
                } else {
                  try {
                    this._createTexture(message.data.decodedData, internalTexture, options);
                    resolve();
                  } catch (err) {
                    reject({ message: err });
                  }
                }
                onComplete();
              }
            };
            worker.addEventListener("error", onError);
            worker.addEventListener("message", onMessage);
            const dataCopy = new Uint8Array(data.byteLength);
            dataCopy.set(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
            worker.postMessage({ action: "decode", data: dataCopy, caps: compressedTexturesCaps, options }, [dataCopy.buffer]);
          });
        });
      });
    } else if (KhronosTextureContainer2._DecoderModulePromise) {
      return KhronosTextureContainer2._DecoderModulePromise.then((decoder) => {
        return new Promise((resolve, reject) => {
          decoder.decode(data, caps).then((data2) => {
            this._createTexture(data2, internalTexture);
            resolve();
          }).catch((reason) => {
            reject({ message: reason });
          });
        });
      });
    }
    throw new Error("KTX2 decoder module is not available");
  }
  _createTexture(data, internalTexture, options) {
    const oglTexture2D = 3553;
    this._engine._bindTextureDirectly(oglTexture2D, internalTexture);
    if (options) {
      options.transcodedFormat = data.transcodedFormat;
      options.isInGammaSpace = data.isInGammaSpace;
      options.hasAlpha = data.hasAlpha;
      options.transcoderName = data.transcoderName;
    }
    let isUncompressedFormat = true;
    switch (data.transcodedFormat) {
      case 32856:
        internalTexture.type = 0;
        internalTexture.format = 5;
        break;
      case 33321:
        internalTexture.type = 0;
        internalTexture.format = 6;
        break;
      case 33323:
        internalTexture.type = 0;
        internalTexture.format = 7;
        break;
      default:
        internalTexture.format = data.transcodedFormat;
        isUncompressedFormat = false;
        break;
    }
    internalTexture._gammaSpace = data.isInGammaSpace;
    internalTexture.generateMipMaps = data.mipmaps.length > 1;
    if (data.errors) {
      throw new Error("KTX2 container - could not transcode the data. " + data.errors);
    }
    for (let t = 0; t < data.mipmaps.length; ++t) {
      const mipmap = data.mipmaps[t];
      if (!mipmap || !mipmap.data) {
        throw new Error("KTX2 container - could not transcode one of the image");
      }
      if (isUncompressedFormat) {
        internalTexture.width = mipmap.width;
        internalTexture.height = mipmap.height;
        this._engine._uploadDataToTextureDirectly(internalTexture, mipmap.data, 0, t, void 0, true);
      } else {
        this._engine._uploadCompressedDataToTextureDirectly(internalTexture, data.transcodedFormat, mipmap.width, mipmap.height, mipmap.data, 0, t);
      }
    }
    internalTexture._extension = ".ktx2";
    internalTexture.width = data.mipmaps[0].width;
    internalTexture.height = data.mipmaps[0].height;
    internalTexture.isReady = true;
    this._engine._bindTextureDirectly(oglTexture2D, null);
  }
  static IsValid(data) {
    if (data.byteLength >= 12) {
      const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);
      if (identifier[0] === 171 && identifier[1] === 75 && identifier[2] === 84 && identifier[3] === 88 && identifier[4] === 32 && identifier[5] === 50 && identifier[6] === 48 && identifier[7] === 187 && identifier[8] === 13 && identifier[9] === 10 && identifier[10] === 26 && identifier[11] === 10) {
        return true;
      }
    }
    return false;
  }
};
KhronosTextureContainer2.URLConfig = {
  jsDecoderModule: "https://preview.babylonjs.com/babylon.ktx2Decoder.js",
  wasmUASTCToASTC: null,
  wasmUASTCToBC7: null,
  wasmUASTCToRGBA_UNORM: null,
  wasmUASTCToRGBA_SRGB: null,
  wasmUASTCToR8_UNORM: null,
  wasmUASTCToRG8_UNORM: null,
  jsMSCTranscoder: null,
  wasmMSCTranscoder: null,
  wasmZSTDDecoder: null
};
KhronosTextureContainer2.DefaultNumWorkers = KhronosTextureContainer2.GetDefaultNumWorkers();
function workerFunc() {
  let ktx2Decoder;
  onmessage = (event) => {
    if (!event.data) {
      return;
    }
    switch (event.data.action) {
      case "init": {
        const urls = event.data.urls;
        importScripts(urls.jsDecoderModule);
        applyConfig(urls);
        ktx2Decoder = new KTX2DECODER.KTX2Decoder();
        postMessage({ action: "init" });
        break;
      }
      case "decode":
        ktx2Decoder.decode(event.data.data, event.data.caps, event.data.options).then((data) => {
          const buffers = [];
          for (let mip = 0; mip < data.mipmaps.length; ++mip) {
            const mipmap = data.mipmaps[mip];
            if (mipmap && mipmap.data) {
              buffers.push(mipmap.data.buffer);
            }
          }
          postMessage({ action: "decoded", success: true, decodedData: data }, buffers);
        }).catch((reason) => {
          postMessage({ action: "decoded", success: false, msg: reason });
        });
        break;
    }
  };
}

// node_modules/@babylonjs/core/Materials/Textures/Loaders/ktxTextureLoader.js
function mapSRGBToLinear(format) {
  switch (format) {
    case 35916:
      return 33776;
    case 35918:
      return 33778;
    case 35919:
      return 33779;
    case 37493:
      return 37492;
    case 37497:
      return 37496;
    case 37495:
      return 37494;
    case 37840:
      return 37808;
    case 36493:
      return 36492;
  }
  return null;
}
var _KTXTextureLoader = class {
  constructor() {
    this.supportCascades = false;
  }
  canLoad(extension, mimeType) {
    return extension.endsWith(".ktx") || extension.endsWith(".ktx2") || mimeType === "image/ktx" || mimeType === "image/ktx2";
  }
  loadCubeData(data, texture, createPolynomials, onLoad) {
    if (Array.isArray(data)) {
      return;
    }
    texture._invertVScale = !texture.invertY;
    const engine = texture.getEngine();
    const ktx = new KhronosTextureContainer(data, 6);
    const loadMipmap = ktx.numberOfMipmapLevels > 1 && texture.generateMipMaps;
    engine._unpackFlipY(true);
    ktx.uploadLevels(texture, texture.generateMipMaps);
    texture.width = ktx.pixelWidth;
    texture.height = ktx.pixelHeight;
    engine._setCubeMapTextureParams(texture, loadMipmap, ktx.numberOfMipmapLevels - 1);
    texture.isReady = true;
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
    if (onLoad) {
      onLoad();
    }
  }
  loadData(data, texture, callback, options) {
    if (KhronosTextureContainer.IsValid(data)) {
      texture._invertVScale = !texture.invertY;
      const ktx = new KhronosTextureContainer(data, 1);
      const mappedFormat = mapSRGBToLinear(ktx.glInternalFormat);
      if (mappedFormat) {
        texture.format = mappedFormat;
        texture._useSRGBBuffer = texture.getEngine()._getUseSRGBBuffer(true, texture.generateMipMaps);
        texture._gammaSpace = true;
      } else {
        texture.format = ktx.glInternalFormat;
      }
      callback(ktx.pixelWidth, ktx.pixelHeight, texture.generateMipMaps, true, () => {
        ktx.uploadLevels(texture, texture.generateMipMaps);
      }, ktx.isInvalid);
    } else if (KhronosTextureContainer2.IsValid(data)) {
      const ktx2 = new KhronosTextureContainer2(texture.getEngine());
      ktx2.uploadAsync(data, texture, options).then(() => {
        callback(texture.width, texture.height, texture.generateMipMaps, true, () => {
        }, false);
      }, (error) => {
        Logger.Warn(`Failed to load KTX2 texture data: ${error.message}`);
        callback(0, 0, false, false, () => {
        }, true);
      });
    } else {
      Logger.Error("texture missing KTX identifier");
      callback(0, 0, false, false, () => {
      }, true);
    }
  }
};
Engine._TextureLoaders.unshift(new _KTXTextureLoader());

// node_modules/@babylonjs/core/XR/webXRCamera.js
var WebXRCamera = class extends FreeCamera {
  constructor(name137, scene, _xrSessionManager) {
    super(name137, Vector3.Zero(), scene);
    this._xrSessionManager = _xrSessionManager;
    this._firstFrame = false;
    this._referenceQuaternion = Quaternion.Identity();
    this._referencedPosition = new Vector3();
    this._trackingState = WebXRTrackingState.NOT_TRACKING;
    this.onBeforeCameraTeleport = new Observable();
    this.onAfterCameraTeleport = new Observable();
    this.onTrackingStateChanged = new Observable();
    this.compensateOnFirstFrame = true;
    this._rotate180 = new Quaternion(0, 1, 0, 0);
    this.minZ = 0.1;
    this.rotationQuaternion = new Quaternion();
    this.cameraRigMode = Camera.RIG_MODE_CUSTOM;
    this.updateUpVectorFromRotation = true;
    this._updateNumberOfRigCameras(1);
    this.freezeProjectionMatrix();
    this._xrSessionManager.onXRSessionInit.add(() => {
      this._referencedPosition.copyFromFloats(0, 0, 0);
      this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);
      this._firstFrame = this.compensateOnFirstFrame;
    });
    this._xrSessionManager.onXRFrameObservable.add(() => {
      if (this._firstFrame) {
        this._updateFromXRSession();
      }
      this._updateReferenceSpace();
      this._updateFromXRSession();
    }, void 0, true);
  }
  get trackingState() {
    return this._trackingState;
  }
  _setTrackingState(newState) {
    if (this._trackingState !== newState) {
      this._trackingState = newState;
      this.onTrackingStateChanged.notifyObservers(newState);
    }
  }
  get realWorldHeight() {
    const basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);
    if (basePose && basePose.transform) {
      return basePose.transform.position.y;
    } else {
      return 0;
    }
  }
  _updateForDualEyeDebugging() {
    this._updateNumberOfRigCameras(2);
    this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1);
    this.rigCameras[0].outputRenderTarget = null;
    this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1);
    this.rigCameras[1].outputRenderTarget = null;
  }
  setTransformationFromNonVRCamera(otherCamera = this.getScene().activeCamera, resetToBaseReferenceSpace = true) {
    if (!otherCamera || otherCamera === this) {
      return;
    }
    const mat = otherCamera.computeWorldMatrix();
    mat.decompose(void 0, this.rotationQuaternion, this.position);
    this.position.y = 0;
    Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);
    this._firstFrame = true;
    if (resetToBaseReferenceSpace) {
      this._xrSessionManager.resetReferenceSpace();
    }
  }
  getClassName() {
    return "WebXRCamera";
  }
  dispose() {
    super.dispose();
    this._lastXRViewerPose = void 0;
  }
  _updateFromXRSession() {
    const pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);
    this._lastXRViewerPose = pose || void 0;
    if (!pose) {
      this._setTrackingState(WebXRTrackingState.NOT_TRACKING);
      return;
    }
    const trackingState = pose.emulatedPosition ? WebXRTrackingState.TRACKING_LOST : WebXRTrackingState.TRACKING;
    this._setTrackingState(trackingState);
    if (this.minZ !== this._cache.minZ || this.maxZ !== this._cache.maxZ) {
      const xrRenderState = {
        depthFar: this.maxZ || 1e4,
        depthNear: this.minZ
      };
      this._xrSessionManager.updateRenderState(xrRenderState);
      this._cache.minZ = this.minZ;
      this._cache.maxZ = this.maxZ;
    }
    if (pose.transform) {
      const orientation = pose.transform.orientation;
      if (pose.transform.orientation.x === void 0) {
        return;
      }
      const pos = pose.transform.position;
      this._referencedPosition.set(pos.x, pos.y, pos.z);
      this._referenceQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);
      if (!this._scene.useRightHandedSystem) {
        this._referencedPosition.z *= -1;
        this._referenceQuaternion.z *= -1;
        this._referenceQuaternion.w *= -1;
      }
      if (this._firstFrame) {
        this._firstFrame = false;
        this.position.y += this._referencedPosition.y;
        this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);
      } else {
        this.rotationQuaternion.copyFrom(this._referenceQuaternion);
        this.position.copyFrom(this._referencedPosition);
      }
    }
    if (this.rigCameras.length !== pose.views.length) {
      this._updateNumberOfRigCameras(pose.views.length);
    }
    pose.views.forEach((view, i) => {
      var _a;
      const currentRig = this.rigCameras[i];
      if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {
        if (view.eye === "right") {
          currentRig._isRightCamera = true;
        } else if (view.eye === "left") {
          currentRig._isLeftCamera = true;
        }
      }
      const pos = view.transform.position;
      const orientation = view.transform.orientation;
      currentRig.parent = this.parent;
      currentRig.position.set(pos.x, pos.y, pos.z);
      currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);
      if (!this._scene.useRightHandedSystem) {
        currentRig.position.z *= -1;
        currentRig.rotationQuaternion.z *= -1;
        currentRig.rotationQuaternion.w *= -1;
      } else {
        currentRig.rotationQuaternion.multiplyInPlace(this._rotate180);
      }
      Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);
      if (!this._scene.useRightHandedSystem) {
        currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();
      }
      if (i === 0) {
        this._projectionMatrix.copyFrom(currentRig._projectionMatrix);
      }
      const renderTargetTexture = this._xrSessionManager.getRenderTargetTextureForView(view);
      this._renderingMultiview = ((_a = renderTargetTexture === null || renderTargetTexture === void 0 ? void 0 : renderTargetTexture._texture) === null || _a === void 0 ? void 0 : _a.isMultiview) || false;
      if (this._renderingMultiview) {
        if (i == 0) {
          this._xrSessionManager.trySetViewportForView(this.viewport, view);
          this.outputRenderTarget = renderTargetTexture;
        }
      } else {
        this._xrSessionManager.trySetViewportForView(currentRig.viewport, view);
        currentRig.outputRenderTarget = renderTargetTexture || this._xrSessionManager.getRenderTargetTextureForView(view);
      }
      currentRig.layerMask = this.layerMask;
    });
  }
  _updateNumberOfRigCameras(viewCount = 1) {
    while (this.rigCameras.length < viewCount) {
      const newCamera = new TargetCamera("XR-RigCamera: " + this.rigCameras.length, Vector3.Zero(), this.getScene());
      newCamera.minZ = 0.1;
      newCamera.rotationQuaternion = new Quaternion();
      newCamera.updateUpVectorFromRotation = true;
      newCamera.isRigCamera = true;
      newCamera.rigParent = this;
      newCamera.freezeProjectionMatrix();
      this.rigCameras.push(newCamera);
    }
    while (this.rigCameras.length > viewCount) {
      const removedCamera = this.rigCameras.pop();
      if (removedCamera) {
        removedCamera.dispose();
      }
    }
  }
  _updateReferenceSpace() {
    if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {
      const referencedMat = TmpVectors.Matrix[0];
      const poseMat = TmpVectors.Matrix[1];
      const transformMat = TmpVectors.Matrix[2];
      Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this._referenceQuaternion, this._referencedPosition, referencedMat);
      Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this.rotationQuaternion, this.position, poseMat);
      referencedMat.invert().multiplyToRef(poseMat, transformMat);
      transformMat.invert();
      if (!this._scene.useRightHandedSystem) {
        transformMat.toggleModelMatrixHandInPlace();
      }
      transformMat.decompose(void 0, this._referenceQuaternion, this._referencedPosition);
      const transform = new XRRigidTransform({
        x: this._referencedPosition.x,
        y: this._referencedPosition.y,
        z: this._referencedPosition.z
      }, {
        x: this._referenceQuaternion.x,
        y: this._referenceQuaternion.y,
        z: this._referenceQuaternion.z,
        w: this._referenceQuaternion.w
      });
      this._xrSessionManager.referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);
    }
  }
};
WebXRCamera._ScaleReadOnly = Vector3.One();

// node_modules/@babylonjs/core/XR/webXRExperienceHelper.js
var WebXRExperienceHelper = class {
  constructor(_scene) {
    this._scene = _scene;
    this._nonVRCamera = null;
    this._attachedToElement = false;
    this._spectatorCamera = null;
    this._originalSceneAutoClear = true;
    this._supported = false;
    this._spectatorMode = false;
    this._lastTimestamp = 0;
    this.onInitialXRPoseSetObservable = new Observable();
    this.onStateChangedObservable = new Observable();
    this.state = WebXRState.NOT_IN_XR;
    this.sessionManager = new WebXRSessionManager(_scene);
    this.camera = new WebXRCamera("webxr", _scene, this.sessionManager);
    this.featuresManager = new WebXRFeaturesManager(this.sessionManager);
    _scene.onDisposeObservable.addOnce(() => {
      this.dispose();
    });
  }
  static CreateAsync(scene) {
    const helper = new WebXRExperienceHelper(scene);
    return helper.sessionManager.initializeAsync().then(() => {
      helper._supported = true;
      return helper;
    }).catch((e) => {
      helper._setState(WebXRState.NOT_IN_XR);
      helper.dispose();
      throw e;
    });
  }
  dispose() {
    var _a;
    this.exitXRAsync();
    this.camera.dispose();
    this.onStateChangedObservable.clear();
    this.onInitialXRPoseSetObservable.clear();
    this.sessionManager.dispose();
    (_a = this._spectatorCamera) === null || _a === void 0 ? void 0 : _a.dispose();
    if (this._nonVRCamera) {
      this._scene.activeCamera = this._nonVRCamera;
    }
  }
  async enterXRAsync(sessionMode, referenceSpaceType, renderTarget = this.sessionManager.getWebXRRenderTarget(), sessionCreationOptions = {}) {
    var _a, _b, _c;
    if (!this._supported) {
      throw "WebXR not supported in this browser or environment";
    }
    this._setState(WebXRState.ENTERING_XR);
    if (referenceSpaceType !== "viewer" && referenceSpaceType !== "local") {
      sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];
      sessionCreationOptions.optionalFeatures.push(referenceSpaceType);
    }
    sessionCreationOptions = await this.featuresManager._extendXRSessionInitObject(sessionCreationOptions);
    if (sessionMode === "immersive-ar" && referenceSpaceType !== "unbounded") {
      Logger.Warn("We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode");
    }
    try {
      await this.sessionManager.initializeSessionAsync(sessionMode, sessionCreationOptions);
      await this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);
      const baseLayer = await renderTarget.initializeXRLayerAsync(this.sessionManager.session);
      const xrRenderState = {
        depthFar: this.camera.maxZ || 1e4,
        depthNear: this.camera.minZ
      };
      if (!this.featuresManager.getEnabledFeature(WebXRFeatureName.LAYERS)) {
        xrRenderState.baseLayer = baseLayer;
      }
      this.sessionManager.updateRenderState(xrRenderState);
      this.sessionManager.runXRRenderLoop();
      this._originalSceneAutoClear = this._scene.autoClear;
      this._nonVRCamera = this._scene.activeCamera;
      this._attachedToElement = !!((_b = (_a = this._nonVRCamera) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b.attachedToElement);
      (_c = this._nonVRCamera) === null || _c === void 0 ? void 0 : _c.detachControl();
      this._scene.activeCamera = this.camera;
      if (sessionMode !== "immersive-ar") {
        this._nonXRToXRCamera();
      } else {
        this._scene.autoClear = false;
        this.camera.compensateOnFirstFrame = false;
        this.camera.position.set(0, 0, 0);
        this.camera.rotationQuaternion.set(0, 0, 0, 1);
      }
      this.sessionManager.onXRSessionEnded.addOnce(() => {
        if (this.state !== WebXRState.EXITING_XR) {
          this._setState(WebXRState.EXITING_XR);
        }
        this.camera.rigCameras.forEach((c) => {
          c.outputRenderTarget = null;
        });
        this._scene.autoClear = this._originalSceneAutoClear;
        this._scene.activeCamera = this._nonVRCamera;
        if (this._attachedToElement && this._nonVRCamera) {
          this._nonVRCamera.attachControl(!!this._nonVRCamera.inputs.noPreventDefault);
        }
        if (sessionMode !== "immersive-ar" && this.camera.compensateOnFirstFrame) {
          if (this._nonVRCamera.setPosition) {
            this._nonVRCamera.setPosition(this.camera.position);
          } else {
            this._nonVRCamera.position.copyFrom(this.camera.position);
          }
        }
        this._setState(WebXRState.NOT_IN_XR);
      });
      this.sessionManager.onXRFrameObservable.addOnce(() => {
        this._setState(WebXRState.IN_XR);
      });
      return this.sessionManager;
    } catch (e) {
      console.log(e);
      console.log(e.message);
      this._setState(WebXRState.NOT_IN_XR);
      throw e;
    }
  }
  exitXRAsync() {
    if (this.state !== WebXRState.IN_XR) {
      return Promise.resolve();
    }
    this._setState(WebXRState.EXITING_XR);
    return this.sessionManager.exitXRAsync();
  }
  enableSpectatorMode(options) {
    if (!this._spectatorMode) {
      this._spectatorMode = true;
      this._switchSpectatorMode(options);
    }
  }
  disableSpecatatorMode() {
    if (this._spectatorMode) {
      this._spectatorMode = false;
      this._switchSpectatorMode();
    }
  }
  _switchSpectatorMode(options) {
    const fps = (options === null || options === void 0 ? void 0 : options.fps) ? options.fps : 1e3;
    const refreshRate = 1 / fps * 1e3;
    const cameraIndex = (options === null || options === void 0 ? void 0 : options.preferredCameraIndex) ? options === null || options === void 0 ? void 0 : options.preferredCameraIndex : 0;
    const updateSpectatorCamera = () => {
      if (this._spectatorCamera) {
        const delta = this.sessionManager.currentTimestamp - this._lastTimestamp;
        if (delta >= refreshRate) {
          this._lastTimestamp = this.sessionManager.currentTimestamp;
          this._spectatorCamera.position.copyFrom(this.camera.rigCameras[cameraIndex].globalPosition);
          this._spectatorCamera.rotationQuaternion.copyFrom(this.camera.rigCameras[cameraIndex].absoluteRotation);
        }
      }
    };
    if (this._spectatorMode) {
      if (cameraIndex >= this.camera.rigCameras.length) {
        throw new Error("the preferred camera index is beyond the length of rig camera array.");
      }
      const onStateChanged = () => {
        if (this.state === WebXRState.IN_XR) {
          this._spectatorCamera = new UniversalCamera("webxr-spectator", Vector3.Zero(), this._scene);
          this._spectatorCamera.rotationQuaternion = new Quaternion();
          this._scene.activeCameras = [this.camera, this._spectatorCamera];
          this.sessionManager.onXRFrameObservable.add(updateSpectatorCamera);
          this._scene.onAfterRenderCameraObservable.add((camera) => {
            if (camera === this.camera) {
              this._scene.getEngine().framebufferDimensionsObject = null;
            }
          });
        } else if (this.state === WebXRState.EXITING_XR) {
          this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);
          this._scene.activeCameras = null;
        }
      };
      this.onStateChangedObservable.add(onStateChanged);
      onStateChanged();
    } else {
      this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);
      this._scene.activeCameras = [this.camera];
    }
  }
  _nonXRToXRCamera() {
    this.camera.setTransformationFromNonVRCamera(this._nonVRCamera);
    this.onInitialXRPoseSetObservable.notifyObservers(this.camera);
  }
  _setState(val) {
    if (this.state === val) {
      return;
    }
    this.state = val;
    this.onStateChangedObservable.notifyObservers(this.state);
  }
};

// node_modules/@babylonjs/core/XR/motionController/webXRControllerComponent.js
var WebXRControllerComponent = class {
  constructor(id, type, _buttonIndex = -1, _axesIndices = []) {
    this.id = id;
    this.type = type;
    this._buttonIndex = _buttonIndex;
    this._axesIndices = _axesIndices;
    this._axes = {
      x: 0,
      y: 0
    };
    this._changes = {};
    this._currentValue = 0;
    this._hasChanges = false;
    this._pressed = false;
    this._touched = false;
    this.onAxisValueChangedObservable = new Observable();
    this.onButtonStateChangedObservable = new Observable();
  }
  get axes() {
    return this._axes;
  }
  get changes() {
    return this._changes;
  }
  get hasChanges() {
    return this._hasChanges;
  }
  get pressed() {
    return this._pressed;
  }
  get touched() {
    return this._touched;
  }
  get value() {
    return this._currentValue;
  }
  dispose() {
    this.onAxisValueChangedObservable.clear();
    this.onButtonStateChangedObservable.clear();
  }
  isAxes() {
    return this._axesIndices.length !== 0;
  }
  isButton() {
    return this._buttonIndex !== -1;
  }
  update(nativeController) {
    let buttonUpdated = false;
    let axesUpdate = false;
    this._hasChanges = false;
    this._changes = {};
    if (this.isButton()) {
      const button = nativeController.buttons[this._buttonIndex];
      if (!button) {
        return;
      }
      if (this._currentValue !== button.value) {
        this.changes.value = {
          current: button.value,
          previous: this._currentValue
        };
        buttonUpdated = true;
        this._currentValue = button.value;
      }
      if (this._touched !== button.touched) {
        this.changes.touched = {
          current: button.touched,
          previous: this._touched
        };
        buttonUpdated = true;
        this._touched = button.touched;
      }
      if (this._pressed !== button.pressed) {
        this.changes.pressed = {
          current: button.pressed,
          previous: this._pressed
        };
        buttonUpdated = true;
        this._pressed = button.pressed;
      }
    }
    if (this.isAxes()) {
      if (this._axes.x !== nativeController.axes[this._axesIndices[0]]) {
        this.changes.axes = {
          current: {
            x: nativeController.axes[this._axesIndices[0]],
            y: this._axes.y
          },
          previous: {
            x: this._axes.x,
            y: this._axes.y
          }
        };
        this._axes.x = nativeController.axes[this._axesIndices[0]];
        axesUpdate = true;
      }
      if (this._axes.y !== nativeController.axes[this._axesIndices[1]]) {
        if (this.changes.axes) {
          this.changes.axes.current.y = nativeController.axes[this._axesIndices[1]];
        } else {
          this.changes.axes = {
            current: {
              x: this._axes.x,
              y: nativeController.axes[this._axesIndices[1]]
            },
            previous: {
              x: this._axes.x,
              y: this._axes.y
            }
          };
        }
        this._axes.y = nativeController.axes[this._axesIndices[1]];
        axesUpdate = true;
      }
    }
    if (buttonUpdated) {
      this._hasChanges = true;
      this.onButtonStateChangedObservable.notifyObservers(this);
    }
    if (axesUpdate) {
      this._hasChanges = true;
      this.onAxisValueChangedObservable.notifyObservers(this._axes);
    }
  }
};
WebXRControllerComponent.BUTTON_TYPE = "button";
WebXRControllerComponent.SQUEEZE_TYPE = "squeeze";
WebXRControllerComponent.THUMBSTICK_TYPE = "thumbstick";
WebXRControllerComponent.TOUCHPAD_TYPE = "touchpad";
WebXRControllerComponent.TRIGGER_TYPE = "trigger";

// node_modules/@babylonjs/core/XR/motionController/webXRAbstractMotionController.js
var WebXRAbstractMotionController = class {
  constructor(scene, layout, gamepadObject, handedness, _doNotLoadControllerMesh = false, _controllerCache) {
    this.scene = scene;
    this.layout = layout;
    this.gamepadObject = gamepadObject;
    this.handedness = handedness;
    this._doNotLoadControllerMesh = _doNotLoadControllerMesh;
    this._controllerCache = _controllerCache;
    this._initComponent = (id) => {
      if (!id) {
        return;
      }
      const componentDef = this.layout.components[id];
      const type = componentDef.type;
      const buttonIndex = componentDef.gamepadIndices.button;
      const axes = [];
      if (componentDef.gamepadIndices.xAxis !== void 0 && componentDef.gamepadIndices.yAxis !== void 0) {
        axes.push(componentDef.gamepadIndices.xAxis, componentDef.gamepadIndices.yAxis);
      }
      this.components[id] = new WebXRControllerComponent(id, type, buttonIndex, axes);
    };
    this._modelReady = false;
    this.components = {};
    this.disableAnimation = false;
    this.onModelLoadedObservable = new Observable();
    if (layout.components) {
      Object.keys(layout.components).forEach(this._initComponent);
    }
  }
  dispose() {
    this.getComponentIds().forEach((id) => this.getComponent(id).dispose());
    if (this.rootMesh) {
      this.rootMesh.getChildren(void 0, true).forEach((node) => {
        node.setEnabled(false);
      });
      this.rootMesh.dispose(!!this._controllerCache, !this._controllerCache);
    }
  }
  getAllComponentsOfType(type) {
    return this.getComponentIds().map((id) => this.components[id]).filter((component) => component.type === type);
  }
  getComponent(id) {
    return this.components[id];
  }
  getComponentIds() {
    return Object.keys(this.components);
  }
  getComponentOfType(type) {
    return this.getAllComponentsOfType(type)[0] || null;
  }
  getMainComponent() {
    return this.getComponent(this.layout.selectComponentId);
  }
  async loadModel() {
    const useGeneric = !this._getModelLoadingConstraints();
    let loadingParams = this._getGenericFilenameAndPath();
    if (useGeneric) {
      Logger.Warn("Falling back to generic models");
    } else {
      loadingParams = this._getFilenameAndPath();
    }
    return new Promise((resolve, reject) => {
      const meshesLoaded = (meshes) => {
        if (useGeneric) {
          this._getGenericParentMesh(meshes);
        } else {
          this._setRootMesh(meshes);
        }
        this._processLoadedModel(meshes);
        this._modelReady = true;
        this.onModelLoadedObservable.notifyObservers(this);
        resolve(true);
      };
      if (this._controllerCache) {
        const found = this._controllerCache.filter((c) => {
          return c.filename === loadingParams.filename && c.path === loadingParams.path;
        });
        if (found[0]) {
          found[0].meshes.forEach((mesh) => mesh.setEnabled(true));
          meshesLoaded(found[0].meshes);
          return;
        }
      }
      SceneLoader.ImportMesh("", loadingParams.path, loadingParams.filename, this.scene, (meshes) => {
        if (this._controllerCache) {
          this._controllerCache.push({
            ...loadingParams,
            meshes
          });
        }
        meshesLoaded(meshes);
      }, null, (_scene, message) => {
        Logger.Log(message);
        Logger.Warn(`Failed to retrieve controller model of type ${this.profileId} from the remote server: ${loadingParams.path}${loadingParams.filename}`);
        reject(message);
      });
    });
  }
  updateFromXRFrame(xrFrame) {
    this.getComponentIds().forEach((id) => this.getComponent(id).update(this.gamepadObject));
    this.updateModel(xrFrame);
  }
  get handness() {
    return this.handedness;
  }
  pulse(value, duration, hapticActuatorIndex = 0) {
    if (this.gamepadObject.hapticActuators && this.gamepadObject.hapticActuators[hapticActuatorIndex]) {
      return this.gamepadObject.hapticActuators[hapticActuatorIndex].pulse(value, duration);
    } else {
      return Promise.resolve(false);
    }
  }
  _getChildByName(node, name137) {
    return node.getChildren((n) => n.name === name137, false)[0];
  }
  _getImmediateChildByName(node, name137) {
    return node.getChildren((n) => n.name == name137, true)[0];
  }
  _lerpTransform(axisMap, axisValue, fixValueCoordinates) {
    if (!axisMap.minMesh || !axisMap.maxMesh || !axisMap.valueMesh) {
      return;
    }
    if (!axisMap.minMesh.rotationQuaternion || !axisMap.maxMesh.rotationQuaternion || !axisMap.valueMesh.rotationQuaternion) {
      return;
    }
    const lerpValue = fixValueCoordinates ? axisValue * 0.5 + 0.5 : axisValue;
    Quaternion.SlerpToRef(axisMap.minMesh.rotationQuaternion, axisMap.maxMesh.rotationQuaternion, lerpValue, axisMap.valueMesh.rotationQuaternion);
    Vector3.LerpToRef(axisMap.minMesh.position, axisMap.maxMesh.position, lerpValue, axisMap.valueMesh.position);
  }
  updateModel(xrFrame) {
    if (!this._modelReady) {
      return;
    }
    this._updateModel(xrFrame);
  }
  _getGenericFilenameAndPath() {
    return {
      filename: "generic.babylon",
      path: "https://controllers.babylonjs.com/generic/"
    };
  }
  _getGenericParentMesh(meshes) {
    this.rootMesh = new Mesh(this.profileId + " " + this.handedness, this.scene);
    meshes.forEach((mesh) => {
      if (!mesh.parent) {
        mesh.isPickable = false;
        mesh.setParent(this.rootMesh);
      }
    });
    this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);
  }
};

// node_modules/@babylonjs/core/XR/motionController/webXRGenericMotionController.js
var WebXRGenericTriggerMotionController = class extends WebXRAbstractMotionController {
  constructor(scene, gamepadObject, handedness) {
    super(scene, GenericTriggerLayout[handedness], gamepadObject, handedness);
    this.profileId = WebXRGenericTriggerMotionController.ProfileId;
  }
  _getFilenameAndPath() {
    return {
      filename: "generic.babylon",
      path: "https://controllers.babylonjs.com/generic/"
    };
  }
  _getModelLoadingConstraints() {
    return true;
  }
  _processLoadedModel(meshes) {
  }
  _setRootMesh(meshes) {
    this.rootMesh = new Mesh(this.profileId + " " + this.handedness, this.scene);
    meshes.forEach((mesh) => {
      mesh.isPickable = false;
      if (!mesh.parent) {
        mesh.setParent(this.rootMesh);
      }
    });
    this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);
  }
  _updateModel() {
  }
};
WebXRGenericTriggerMotionController.ProfileId = "generic-trigger";
var GenericTriggerLayout = {
  left: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "generic-trigger-left",
    assetPath: "left.glb"
  },
  right: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "generic-trigger-right",
    assetPath: "right.glb"
  },
  none: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "generic-trigger-none",
    assetPath: "none.glb"
  }
};

// node_modules/@babylonjs/core/XR/motionController/webXRProfiledMotionController.js
var WebXRProfiledMotionController = class extends WebXRAbstractMotionController {
  constructor(scene, xrInput, _profile, _repositoryUrl, controllerCache2) {
    super(scene, _profile.layouts[xrInput.handedness || "none"], xrInput.gamepad, xrInput.handedness, void 0, controllerCache2);
    this._repositoryUrl = _repositoryUrl;
    this.controllerCache = controllerCache2;
    this._buttonMeshMapping = {};
    this._touchDots = {};
    this.profileId = _profile.profileId;
  }
  dispose() {
    super.dispose();
    if (!this.controllerCache) {
      Object.keys(this._touchDots).forEach((visResKey) => {
        this._touchDots[visResKey].dispose();
      });
    }
  }
  _getFilenameAndPath() {
    return {
      filename: this.layout.assetPath,
      path: `${this._repositoryUrl}/profiles/${this.profileId}/`
    };
  }
  _getModelLoadingConstraints() {
    const glbLoaded = SceneLoader.IsPluginForExtensionAvailable(".glb");
    if (!glbLoaded) {
      Logger.Warn("glTF / glb loader was not registered, using generic controller instead");
    }
    return glbLoaded;
  }
  _processLoadedModel(_meshes) {
    this.getComponentIds().forEach((type) => {
      const componentInLayout = this.layout.components[type];
      this._buttonMeshMapping[type] = {
        mainMesh: this._getChildByName(this.rootMesh, componentInLayout.rootNodeName),
        states: {}
      };
      Object.keys(componentInLayout.visualResponses).forEach((visualResponseKey) => {
        const visResponse = componentInLayout.visualResponses[visualResponseKey];
        if (visResponse.valueNodeProperty === "transform") {
          this._buttonMeshMapping[type].states[visualResponseKey] = {
            valueMesh: this._getChildByName(this.rootMesh, visResponse.valueNodeName),
            minMesh: this._getChildByName(this.rootMesh, visResponse.minNodeName),
            maxMesh: this._getChildByName(this.rootMesh, visResponse.maxNodeName)
          };
        } else {
          const nameOfMesh = componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && componentInLayout.touchPointNodeName ? componentInLayout.touchPointNodeName : visResponse.valueNodeName;
          this._buttonMeshMapping[type].states[visualResponseKey] = {
            valueMesh: this._getChildByName(this.rootMesh, nameOfMesh)
          };
          if (componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && !this._touchDots[visualResponseKey]) {
            const dot = CreateSphere(visualResponseKey + "dot", {
              diameter: 15e-4,
              segments: 8
            }, this.scene);
            dot.material = new StandardMaterial(visualResponseKey + "mat", this.scene);
            dot.material.diffuseColor = Color3.Red();
            dot.parent = this._buttonMeshMapping[type].states[visualResponseKey].valueMesh || null;
            dot.isVisible = false;
            this._touchDots[visualResponseKey] = dot;
          }
        }
      });
    });
  }
  _setRootMesh(meshes) {
    this.rootMesh = new Mesh(this.profileId + "-" + this.handedness, this.scene);
    this.rootMesh.isPickable = false;
    let rootMesh;
    for (let i = 0; i < meshes.length; i++) {
      const mesh = meshes[i];
      mesh.isPickable = false;
      if (!mesh.parent) {
        rootMesh = mesh;
      }
    }
    if (rootMesh) {
      rootMesh.setParent(this.rootMesh);
    }
    if (!this.scene.useRightHandedSystem) {
      this.rootMesh.rotate(Axis.Y, Math.PI, Space.WORLD);
    }
  }
  _updateModel(_xrFrame) {
    if (this.disableAnimation) {
      return;
    }
    this.getComponentIds().forEach((id) => {
      const component = this.getComponent(id);
      if (!component.hasChanges) {
        return;
      }
      const meshes = this._buttonMeshMapping[id];
      const componentInLayout = this.layout.components[id];
      Object.keys(componentInLayout.visualResponses).forEach((visualResponseKey) => {
        const visResponse = componentInLayout.visualResponses[visualResponseKey];
        let value = component.value;
        if (visResponse.componentProperty === "xAxis") {
          value = component.axes.x;
        } else if (visResponse.componentProperty === "yAxis") {
          value = component.axes.y;
        }
        if (visResponse.valueNodeProperty === "transform") {
          this._lerpTransform(meshes.states[visualResponseKey], value, visResponse.componentProperty !== "button");
        } else {
          const valueMesh = meshes.states[visualResponseKey].valueMesh;
          if (valueMesh) {
            valueMesh.isVisible = component.touched || component.pressed;
          }
          if (this._touchDots[visualResponseKey]) {
            this._touchDots[visualResponseKey].isVisible = component.touched || component.pressed;
          }
        }
      });
    });
  }
};

// node_modules/@babylonjs/core/XR/motionController/webXRMotionControllerManager.js
var controllerCache = [];
var WebXRMotionControllerManager = class {
  static ClearProfilesCache() {
    this._ProfilesList = null;
    this._ProfileLoadingPromises = {};
  }
  static DefaultFallbacks() {
    this.RegisterFallbacksForProfileId("google-daydream", ["generic-touchpad"]);
    this.RegisterFallbacksForProfileId("htc-vive-focus", ["generic-trigger-touchpad"]);
    this.RegisterFallbacksForProfileId("htc-vive", ["generic-trigger-squeeze-touchpad"]);
    this.RegisterFallbacksForProfileId("magicleap-one", ["generic-trigger-squeeze-touchpad"]);
    this.RegisterFallbacksForProfileId("windows-mixed-reality", ["generic-trigger-squeeze-touchpad-thumbstick"]);
    this.RegisterFallbacksForProfileId("microsoft-mixed-reality", ["windows-mixed-reality", "generic-trigger-squeeze-touchpad-thumbstick"]);
    this.RegisterFallbacksForProfileId("oculus-go", ["generic-trigger-touchpad"]);
    this.RegisterFallbacksForProfileId("oculus-touch-v2", ["oculus-touch", "generic-trigger-squeeze-thumbstick"]);
    this.RegisterFallbacksForProfileId("oculus-touch", ["generic-trigger-squeeze-thumbstick"]);
    this.RegisterFallbacksForProfileId("samsung-gearvr", ["windows-mixed-reality", "generic-trigger-squeeze-touchpad-thumbstick"]);
    this.RegisterFallbacksForProfileId("samsung-odyssey", ["generic-touchpad"]);
    this.RegisterFallbacksForProfileId("valve-index", ["generic-trigger-squeeze-touchpad-thumbstick"]);
    this.RegisterFallbacksForProfileId("generic-hand-select", ["generic-trigger"]);
  }
  static FindFallbackWithProfileId(profileId) {
    const returnArray = this._Fallbacks[profileId] || [];
    returnArray.unshift(profileId);
    return returnArray;
  }
  static GetMotionControllerWithXRInput(xrInput, scene, forceProfile) {
    const profileArray = [];
    if (forceProfile) {
      profileArray.push(forceProfile);
    }
    profileArray.push(...xrInput.profiles || []);
    if (profileArray.length && !profileArray[0]) {
      profileArray.pop();
    }
    if (xrInput.gamepad && xrInput.gamepad.id) {
      switch (xrInput.gamepad.id) {
        case (xrInput.gamepad.id.match(/oculus touch/gi) ? xrInput.gamepad.id : void 0):
          profileArray.push("oculus-touch-v2");
          break;
      }
    }
    const windowsMRIdx = profileArray.indexOf("windows-mixed-reality");
    if (windowsMRIdx !== -1) {
      profileArray.splice(windowsMRIdx, 0, "microsoft-mixed-reality");
    }
    if (!profileArray.length) {
      profileArray.push("generic-trigger");
    }
    if (this.UseOnlineRepository) {
      const firstFunction = this.PrioritizeOnlineRepository ? this._LoadProfileFromRepository : this._LoadProfilesFromAvailableControllers;
      const secondFunction = this.PrioritizeOnlineRepository ? this._LoadProfilesFromAvailableControllers : this._LoadProfileFromRepository;
      return firstFunction.call(this, profileArray, xrInput, scene).catch(() => {
        return secondFunction.call(this, profileArray, xrInput, scene);
      });
    } else {
      return this._LoadProfilesFromAvailableControllers(profileArray, xrInput, scene);
    }
  }
  static RegisterController(type, constructFunction) {
    this._AvailableControllers[type] = constructFunction;
  }
  static RegisterFallbacksForProfileId(profileId, fallbacks) {
    if (this._Fallbacks[profileId]) {
      this._Fallbacks[profileId].push(...fallbacks);
    } else {
      this._Fallbacks[profileId] = fallbacks;
    }
  }
  static UpdateProfilesList() {
    this._ProfilesList = Tools.LoadFileAsync(this.BaseRepositoryUrl + "/profiles/profilesList.json", false).then((data) => {
      return JSON.parse(data.toString());
    });
    return this._ProfilesList;
  }
  static ClearControllerCache() {
    controllerCache.forEach((cacheItem) => {
      cacheItem.meshes.forEach((mesh) => {
        mesh.dispose(false, true);
      });
    });
    controllerCache.length = 0;
  }
  static _LoadProfileFromRepository(profileArray, xrInput, scene) {
    return Promise.resolve().then(() => {
      if (!this._ProfilesList) {
        return this.UpdateProfilesList();
      } else {
        return this._ProfilesList;
      }
    }).then((profilesList) => {
      for (let i = 0; i < profileArray.length; ++i) {
        if (!profileArray[i]) {
          continue;
        }
        if (profilesList[profileArray[i]]) {
          return profileArray[i];
        }
      }
      throw new Error(`neither controller ${profileArray[0]} nor all fallbacks were found in the repository,`);
    }).then((profileToLoad) => {
      if (!this._ProfileLoadingPromises[profileToLoad]) {
        this._ProfileLoadingPromises[profileToLoad] = Tools.LoadFileAsync(`${this.BaseRepositoryUrl}/profiles/${profileToLoad}/profile.json`, false).then((data) => JSON.parse(data));
      }
      return this._ProfileLoadingPromises[profileToLoad];
    }).then((profile) => {
      return new WebXRProfiledMotionController(scene, xrInput, profile, this.BaseRepositoryUrl, this.DisableControllerCache ? void 0 : controllerCache);
    });
  }
  static _LoadProfilesFromAvailableControllers(profileArray, xrInput, scene) {
    for (let i = 0; i < profileArray.length; ++i) {
      if (!profileArray[i]) {
        continue;
      }
      const fallbacks = this.FindFallbackWithProfileId(profileArray[i]);
      for (let j = 0; j < fallbacks.length; ++j) {
        const constructionFunction = this._AvailableControllers[fallbacks[j]];
        if (constructionFunction) {
          return Promise.resolve(constructionFunction(xrInput, scene));
        }
      }
    }
    throw new Error(`no controller requested was found in the available controllers list`);
  }
};
WebXRMotionControllerManager._AvailableControllers = {};
WebXRMotionControllerManager._Fallbacks = {};
WebXRMotionControllerManager._ProfileLoadingPromises = {};
WebXRMotionControllerManager.BaseRepositoryUrl = "https://immersive-web.github.io/webxr-input-profiles/packages/viewer/dist";
WebXRMotionControllerManager.PrioritizeOnlineRepository = true;
WebXRMotionControllerManager.UseOnlineRepository = true;
WebXRMotionControllerManager.DisableControllerCache = true;
WebXRMotionControllerManager.RegisterController(WebXRGenericTriggerMotionController.ProfileId, (xrInput, scene) => {
  return new WebXRGenericTriggerMotionController(scene, xrInput.gamepad, xrInput.handedness);
});
WebXRMotionControllerManager.DefaultFallbacks();

// node_modules/@babylonjs/core/XR/webXRInputSource.js
var idCount = 0;
var WebXRInputSource = class {
  constructor(_scene, inputSource, _options = {}) {
    this._scene = _scene;
    this.inputSource = inputSource;
    this._options = _options;
    this._tmpVector = new Vector3();
    this._disposed = false;
    this.onDisposeObservable = new Observable();
    this.onMeshLoadedObservable = new Observable();
    this.onMotionControllerInitObservable = new Observable();
    this._uniqueId = `controller-${idCount++}-${inputSource.targetRayMode}-${inputSource.handedness}`;
    this.pointer = new AbstractMesh(`${this._uniqueId}-pointer`, _scene);
    this.pointer.rotationQuaternion = new Quaternion();
    if (this.inputSource.gripSpace) {
      this.grip = new AbstractMesh(`${this._uniqueId}-grip`, this._scene);
      this.grip.rotationQuaternion = new Quaternion();
    }
    this._tmpVector.set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
    if (this.inputSource.gamepad && this.inputSource.targetRayMode === "tracked-pointer") {
      WebXRMotionControllerManager.GetMotionControllerWithXRInput(inputSource, _scene, this._options.forceControllerProfile).then((motionController) => {
        this.motionController = motionController;
        this.onMotionControllerInitObservable.notifyObservers(motionController);
        if (!this._options.doNotLoadControllerMesh && !this.motionController._doNotLoadControllerMesh) {
          this.motionController.loadModel().then((success) => {
            var _a;
            if (success && this.motionController && this.motionController.rootMesh) {
              if (this._options.renderingGroupId) {
                this.motionController.rootMesh.renderingGroupId = this._options.renderingGroupId;
                this.motionController.rootMesh.getChildMeshes(false).forEach((mesh) => mesh.renderingGroupId = this._options.renderingGroupId);
              }
              this.onMeshLoadedObservable.notifyObservers(this.motionController.rootMesh);
              this.motionController.rootMesh.parent = this.grip || this.pointer;
              this.motionController.disableAnimation = !!this._options.disableMotionControllerAnimation;
            }
            if (this._disposed) {
              (_a = this.motionController) === null || _a === void 0 ? void 0 : _a.dispose();
            }
          });
        }
      }, () => {
        Tools.Warn(`Could not find a matching motion controller for the registered input source`);
      });
    }
  }
  get uniqueId() {
    return this._uniqueId;
  }
  dispose() {
    if (this.grip) {
      this.grip.dispose(true);
    }
    if (this.motionController) {
      this.motionController.dispose();
    }
    this.pointer.dispose(true);
    this.onMotionControllerInitObservable.clear();
    this.onMeshLoadedObservable.clear();
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this._disposed = true;
  }
  getWorldPointerRayToRef(result, gripIfAvailable = false) {
    const object = gripIfAvailable && this.grip ? this.grip : this.pointer;
    Vector3.TransformNormalToRef(this._tmpVector, object.getWorldMatrix(), result.direction);
    result.direction.normalize();
    result.origin.copyFrom(object.absolutePosition);
    result.length = 1e3;
  }
  updateFromXRFrame(xrFrame, referenceSpace, xrCamera) {
    const pose = xrFrame.getPose(this.inputSource.targetRaySpace, referenceSpace);
    this._lastXRPose = pose;
    if (pose) {
      const pos = pose.transform.position;
      this.pointer.position.set(pos.x, pos.y, pos.z);
      const orientation = pose.transform.orientation;
      this.pointer.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);
      if (!this._scene.useRightHandedSystem) {
        this.pointer.position.z *= -1;
        this.pointer.rotationQuaternion.z *= -1;
        this.pointer.rotationQuaternion.w *= -1;
      }
      this.pointer.parent = xrCamera.parent;
    }
    if (this.inputSource.gripSpace && this.grip) {
      const pose2 = xrFrame.getPose(this.inputSource.gripSpace, referenceSpace);
      if (pose2) {
        const pos = pose2.transform.position;
        const orientation = pose2.transform.orientation;
        this.grip.position.set(pos.x, pos.y, pos.z);
        this.grip.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);
        if (!this._scene.useRightHandedSystem) {
          this.grip.position.z *= -1;
          this.grip.rotationQuaternion.z *= -1;
          this.grip.rotationQuaternion.w *= -1;
        }
      }
      this.grip.parent = xrCamera.parent;
    }
    if (this.motionController) {
      this.motionController.updateFromXRFrame(xrFrame);
    }
  }
};

// node_modules/@babylonjs/core/XR/webXRInput.js
var WebXRInput = class {
  constructor(xrSessionManager, xrCamera, _options = {}) {
    this.xrSessionManager = xrSessionManager;
    this.xrCamera = xrCamera;
    this._options = _options;
    this.controllers = [];
    this.onControllerAddedObservable = new Observable();
    this.onControllerRemovedObservable = new Observable();
    this._onInputSourcesChange = (event) => {
      this._addAndRemoveControllers(event.added, event.removed);
    };
    this._sessionEndedObserver = this.xrSessionManager.onXRSessionEnded.add(() => {
      this._addAndRemoveControllers([], this.controllers.map((c) => {
        return c.inputSource;
      }));
    });
    this._sessionInitObserver = this.xrSessionManager.onXRSessionInit.add((session) => {
      session.addEventListener("inputsourceschange", this._onInputSourcesChange);
    });
    this._frameObserver = this.xrSessionManager.onXRFrameObservable.add((frame) => {
      this.controllers.forEach((controller) => {
        controller.updateFromXRFrame(frame, this.xrSessionManager.referenceSpace, this.xrCamera);
      });
    });
    if (this._options.customControllersRepositoryURL) {
      WebXRMotionControllerManager.BaseRepositoryUrl = this._options.customControllersRepositoryURL;
    }
    WebXRMotionControllerManager.UseOnlineRepository = !this._options.disableOnlineControllerRepository;
    if (WebXRMotionControllerManager.UseOnlineRepository) {
      try {
        WebXRMotionControllerManager.UpdateProfilesList().catch(() => {
          WebXRMotionControllerManager.UseOnlineRepository = false;
        });
      } catch (e) {
        WebXRMotionControllerManager.UseOnlineRepository = false;
      }
    }
  }
  _addAndRemoveControllers(addInputs, removeInputs) {
    const sources = this.controllers.map((c) => {
      return c.inputSource;
    });
    for (const input of addInputs) {
      if (sources.indexOf(input) === -1) {
        const controller = new WebXRInputSource(this.xrSessionManager.scene, input, {
          ...this._options.controllerOptions || {},
          forceControllerProfile: this._options.forceInputProfile,
          doNotLoadControllerMesh: this._options.doNotLoadControllerMeshes,
          disableMotionControllerAnimation: this._options.disableControllerAnimation
        });
        this.controllers.push(controller);
        this.onControllerAddedObservable.notifyObservers(controller);
      }
    }
    const keepControllers = [];
    const removedControllers = [];
    this.controllers.forEach((c) => {
      if (removeInputs.indexOf(c.inputSource) === -1) {
        keepControllers.push(c);
      } else {
        removedControllers.push(c);
      }
    });
    this.controllers = keepControllers;
    removedControllers.forEach((c) => {
      this.onControllerRemovedObservable.notifyObservers(c);
      c.dispose();
    });
  }
  dispose() {
    this.controllers.forEach((c) => {
      c.dispose();
    });
    this.xrSessionManager.onXRFrameObservable.remove(this._frameObserver);
    this.xrSessionManager.onXRSessionInit.remove(this._sessionInitObserver);
    this.xrSessionManager.onXRSessionEnded.remove(this._sessionEndedObserver);
    this.onControllerAddedObservable.clear();
    this.onControllerRemovedObservable.clear();
    WebXRMotionControllerManager.ClearControllerCache();
  }
};

// node_modules/@babylonjs/core/XR/features/WebXRControllerPointerSelection.js
var WebXRControllerPointerSelection = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, _options) {
    super(_xrSessionManager);
    this._options = _options;
    this._attachController = (xrController) => {
      if (this._controllers[xrController.uniqueId]) {
        return;
      }
      const { laserPointer, selectionMesh } = this._generateNewMeshPair(xrController.pointer);
      this._controllers[xrController.uniqueId] = {
        xrController,
        laserPointer,
        selectionMesh,
        meshUnderPointer: null,
        pick: null,
        tmpRay: new Ray(new Vector3(), new Vector3()),
        disabledByNearInteraction: false,
        id: WebXRControllerPointerSelection._IdCounter++
      };
      if (this._attachedController) {
        if (!this._options.enablePointerSelectionOnAllControllers && this._options.preferredHandedness && xrController.inputSource.handedness === this._options.preferredHandedness) {
          this._attachedController = xrController.uniqueId;
        }
      } else {
        if (!this._options.enablePointerSelectionOnAllControllers) {
          this._attachedController = xrController.uniqueId;
        }
      }
      switch (xrController.inputSource.targetRayMode) {
        case "tracked-pointer":
          return this._attachTrackedPointerRayMode(xrController);
        case "gaze":
          return this._attachGazeMode(xrController);
        case "screen":
          return this._attachScreenRayMode(xrController);
      }
    };
    this._controllers = {};
    this._tmpVectorForPickCompare = new Vector3();
    this.disablePointerLighting = true;
    this.disableSelectionMeshLighting = true;
    this.displayLaserPointer = true;
    this.displaySelectionMesh = true;
    this.laserPointerPickedColor = new Color3(0.9, 0.9, 0.9);
    this.laserPointerDefaultColor = new Color3(0.7, 0.7, 0.7);
    this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);
    this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1);
    this._identityMatrix = Matrix.Identity();
    this._screenCoordinatesRef = Vector3.Zero();
    this._viewportRef = new Viewport(0, 0, 0, 0);
    this._scene = this._xrSessionManager.scene;
  }
  attach() {
    if (!super.attach()) {
      return false;
    }
    this._options.xrInput.controllers.forEach(this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {
      this._detachController(controller.uniqueId);
    });
    this._scene.constantlyUpdateMeshUnderPointer = true;
    if (this._options.gazeCamera) {
      const webXRCamera = this._options.gazeCamera;
      const { laserPointer, selectionMesh } = this._generateNewMeshPair(webXRCamera);
      this._controllers["camera"] = {
        webXRCamera,
        laserPointer,
        selectionMesh,
        meshUnderPointer: null,
        pick: null,
        tmpRay: new Ray(new Vector3(), new Vector3()),
        disabledByNearInteraction: false,
        id: WebXRControllerPointerSelection._IdCounter++
      };
      this._attachGazeMode();
    }
    return true;
  }
  detach() {
    if (!super.detach()) {
      return false;
    }
    Object.keys(this._controllers).forEach((controllerId) => {
      this._detachController(controllerId);
    });
    return true;
  }
  getMeshUnderPointer(controllerId) {
    if (this._controllers[controllerId]) {
      return this._controllers[controllerId].meshUnderPointer;
    } else {
      return null;
    }
  }
  getXRControllerByPointerId(id) {
    const keys = Object.keys(this._controllers);
    for (let i = 0; i < keys.length; ++i) {
      if (this._controllers[keys[i]].id === id) {
        return this._controllers[keys[i]].xrController || null;
      }
    }
    return null;
  }
  _getPointerSelectionDisabledByPointerId(id) {
    const keys = Object.keys(this._controllers);
    for (let i = 0; i < keys.length; ++i) {
      if (this._controllers[keys[i]].id === id) {
        return this._controllers[keys[i]].disabledByNearInteraction;
      }
    }
    return true;
  }
  _setPointerSelectionDisabledByPointerId(id, state) {
    const keys = Object.keys(this._controllers);
    for (let i = 0; i < keys.length; ++i) {
      if (this._controllers[keys[i]].id === id) {
        this._controllers[keys[i]].disabledByNearInteraction = state;
        return;
      }
    }
  }
  _onXRFrame(_xrFrame) {
    Object.keys(this._controllers).forEach((id) => {
      const controllerData = this._controllers[id];
      if (!this._options.enablePointerSelectionOnAllControllers && id !== this._attachedController || controllerData.disabledByNearInteraction) {
        controllerData.selectionMesh.isVisible = false;
        controllerData.laserPointer.isVisible = false;
        controllerData.pick = null;
        return;
      }
      controllerData.laserPointer.isVisible = this.displayLaserPointer;
      let controllerGlobalPosition;
      if (controllerData.xrController) {
        controllerGlobalPosition = controllerData.xrController.pointer.position;
        controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay);
      } else if (controllerData.webXRCamera) {
        controllerGlobalPosition = controllerData.webXRCamera.position;
        controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);
      } else {
        return;
      }
      if (this._options.maxPointerDistance) {
        controllerData.tmpRay.length = this._options.maxPointerDistance;
      }
      if (!this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {
        const scene = this._xrSessionManager.scene;
        const camera = this._options.xrInput.xrCamera;
        if (camera) {
          camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth(), scene.getEngine().getRenderHeight(), this._viewportRef);
          Vector3.ProjectToRef(controllerGlobalPosition, this._identityMatrix, scene.getTransformMatrix(), this._viewportRef, this._screenCoordinatesRef);
          if (typeof this._screenCoordinatesRef.x === "number" && typeof this._screenCoordinatesRef.y === "number" && !isNaN(this._screenCoordinatesRef.x) && !isNaN(this._screenCoordinatesRef.y)) {
            scene.pointerX = this._screenCoordinatesRef.x;
            scene.pointerY = this._screenCoordinatesRef.y;
            controllerData.screenCoordinates = {
              x: this._screenCoordinatesRef.x,
              y: this._screenCoordinatesRef.y
            };
          }
        }
      }
      let utilityScenePick = null;
      if (this._utilityLayerScene) {
        utilityScenePick = this._utilityLayerScene.pickWithRay(controllerData.tmpRay, this._utilityLayerScene.pointerMovePredicate || this.raySelectionPredicate);
      }
      const originalScenePick = this._scene.pickWithRay(controllerData.tmpRay, this._scene.pointerMovePredicate || this.raySelectionPredicate);
      if (!utilityScenePick || !utilityScenePick.hit) {
        controllerData.pick = originalScenePick;
      } else if (!originalScenePick || !originalScenePick.hit) {
        controllerData.pick = utilityScenePick;
      } else if (utilityScenePick.distance < originalScenePick.distance) {
        controllerData.pick = utilityScenePick;
      } else {
        controllerData.pick = originalScenePick;
      }
      if (controllerData.pick && controllerData.xrController) {
        controllerData.pick.aimTransform = controllerData.xrController.pointer;
        controllerData.pick.gripTransform = controllerData.xrController.grip || null;
      }
      const pick = controllerData.pick;
      if (pick && pick.pickedPoint && pick.hit) {
        this._updatePointerDistance(controllerData.laserPointer, pick.distance);
        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);
        controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);
        controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);
        controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance);
        const pickNormal = this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);
        const deltaFighting = 1e-3;
        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);
        if (pickNormal) {
          const axis1 = Vector3.Cross(Axis.Y, pickNormal);
          const axis2 = Vector3.Cross(pickNormal, axis1);
          Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);
          controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));
        }
        controllerData.selectionMesh.isVisible = this.displaySelectionMesh;
        controllerData.meshUnderPointer = pick.pickedMesh;
      } else {
        controllerData.selectionMesh.isVisible = false;
        this._updatePointerDistance(controllerData.laserPointer, 1);
        controllerData.meshUnderPointer = null;
      }
    });
  }
  get _utilityLayerScene() {
    return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;
  }
  _attachGazeMode(xrController) {
    const controllerData = this._controllers[xrController && xrController.uniqueId || "camera"];
    const timeToSelect = this._options.timeToSelect || 3e3;
    const sceneToRenderTo = this._options.useUtilityLayer ? this._utilityLayerScene : this._scene;
    let oldPick = new PickingInfo();
    const discMesh = CreateTorus("selection", {
      diameter: 35e-4 * 15,
      thickness: 25e-4 * 6,
      tessellation: 20
    }, sceneToRenderTo);
    discMesh.isVisible = false;
    discMesh.isPickable = false;
    discMesh.parent = controllerData.selectionMesh;
    let timer = 0;
    let downTriggered = false;
    const pointerEventInit = {
      pointerId: controllerData.id,
      pointerType: "xr"
    };
    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {
      if (!controllerData.pick) {
        return;
      }
      this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
      controllerData.laserPointer.material.alpha = 0;
      discMesh.isVisible = false;
      if (controllerData.pick.hit) {
        if (!this._pickingMoved(oldPick, controllerData.pick)) {
          if (timer > timeToSelect / 10) {
            discMesh.isVisible = true;
          }
          timer += this._scene.getEngine().getDeltaTime();
          if (timer >= timeToSelect) {
            this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);
            downTriggered = true;
            if (this._options.disablePointerUpOnTouchOut) {
              this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
            }
            discMesh.isVisible = false;
          } else {
            const scaleFactor = 1 - timer / timeToSelect;
            discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);
          }
        } else {
          if (downTriggered) {
            if (!this._options.disablePointerUpOnTouchOut) {
              this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
            }
          }
          downTriggered = false;
          timer = 0;
        }
      } else {
        downTriggered = false;
        timer = 0;
      }
      this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);
      oldPick = controllerData.pick;
    });
    if (this._options.renderingGroupId !== void 0) {
      discMesh.renderingGroupId = this._options.renderingGroupId;
    }
    if (xrController) {
      xrController.onDisposeObservable.addOnce(() => {
        if (controllerData.pick && !this._options.disablePointerUpOnTouchOut && downTriggered) {
          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
          controllerData.finalPointerUpTriggered = true;
        }
        discMesh.dispose();
      });
    }
  }
  _attachScreenRayMode(xrController) {
    const controllerData = this._controllers[xrController.uniqueId];
    let downTriggered = false;
    const pointerEventInit = {
      pointerId: controllerData.id,
      pointerType: "xr"
    };
    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {
      this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
      if (!controllerData.pick || this._options.disablePointerUpOnTouchOut && downTriggered) {
        return;
      }
      if (!downTriggered) {
        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);
        controllerData.pointerDownTriggered = true;
        downTriggered = true;
        if (this._options.disablePointerUpOnTouchOut) {
          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
        }
      } else {
        this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);
      }
    });
    xrController.onDisposeObservable.addOnce(() => {
      this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
      this._xrSessionManager.runInXRFrame(() => {
        if (controllerData.pick && !controllerData.finalPointerUpTriggered && downTriggered && !this._options.disablePointerUpOnTouchOut) {
          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
          controllerData.finalPointerUpTriggered = true;
        }
      });
    });
  }
  _attachTrackedPointerRayMode(xrController) {
    const controllerData = this._controllers[xrController.uniqueId];
    if (this._options.forceGazeMode) {
      return this._attachGazeMode(xrController);
    }
    const pointerEventInit = {
      pointerId: controllerData.id,
      pointerType: "xr"
    };
    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {
      controllerData.laserPointer.material.disableLighting = this.disablePointerLighting;
      controllerData.selectionMesh.material.disableLighting = this.disableSelectionMeshLighting;
      if (controllerData.pick) {
        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
        this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);
      }
    });
    if (xrController.inputSource.gamepad) {
      const init = (motionController) => {
        if (this._options.overrideButtonId) {
          controllerData.selectionComponent = motionController.getComponent(this._options.overrideButtonId);
        }
        if (!controllerData.selectionComponent) {
          controllerData.selectionComponent = motionController.getMainComponent();
        }
        controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {
          if (component.changes.pressed) {
            const pressed = component.changes.pressed.current;
            if (controllerData.pick) {
              if (this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === this._attachedController) {
                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
                if (pressed) {
                  this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);
                  controllerData.pointerDownTriggered = true;
                  controllerData.selectionMesh.material.emissiveColor = this.selectionMeshPickedColor;
                  controllerData.laserPointer.material.emissiveColor = this.laserPointerPickedColor;
                } else {
                  this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
                  controllerData.selectionMesh.material.emissiveColor = this.selectionMeshDefaultColor;
                  controllerData.laserPointer.material.emissiveColor = this.laserPointerDefaultColor;
                }
              }
            } else {
              if (pressed && !this._options.enablePointerSelectionOnAllControllers && !this._options.disableSwitchOnClick) {
                this._attachedController = xrController.uniqueId;
              }
            }
          }
        });
      };
      if (xrController.motionController) {
        init(xrController.motionController);
      } else {
        xrController.onMotionControllerInitObservable.add(init);
      }
    } else {
      const selectStartListener = (event) => {
        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {
          this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);
          controllerData.pointerDownTriggered = true;
          controllerData.selectionMesh.material.emissiveColor = this.selectionMeshPickedColor;
          controllerData.laserPointer.material.emissiveColor = this.laserPointerPickedColor;
        }
      };
      const selectEndListener = (event) => {
        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {
          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
          controllerData.selectionMesh.material.emissiveColor = this.selectionMeshDefaultColor;
          controllerData.laserPointer.material.emissiveColor = this.laserPointerDefaultColor;
        }
      };
      controllerData.eventListeners = {
        selectend: selectEndListener,
        selectstart: selectStartListener
      };
      this._xrSessionManager.session.addEventListener("selectstart", selectStartListener);
      this._xrSessionManager.session.addEventListener("selectend", selectEndListener);
    }
  }
  _convertNormalToDirectionOfRay(normal, ray) {
    if (normal) {
      const angle = Math.acos(Vector3.Dot(normal, ray.direction));
      if (angle < Math.PI / 2) {
        normal.scaleInPlace(-1);
      }
    }
    return normal;
  }
  _detachController(xrControllerUniqueId) {
    const controllerData = this._controllers[xrControllerUniqueId];
    if (!controllerData) {
      return;
    }
    if (controllerData.selectionComponent) {
      if (controllerData.onButtonChangedObserver) {
        controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);
      }
    }
    if (controllerData.onFrameObserver) {
      this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);
    }
    if (controllerData.eventListeners) {
      Object.keys(controllerData.eventListeners).forEach((eventName) => {
        const func = controllerData.eventListeners && controllerData.eventListeners[eventName];
        if (func) {
          this._xrSessionManager.session.removeEventListener(eventName, func);
        }
      });
    }
    if (!controllerData.finalPointerUpTriggered && controllerData.pointerDownTriggered) {
      const pointerEventInit = {
        pointerId: controllerData.id,
        pointerType: "xr"
      };
      this._xrSessionManager.runInXRFrame(() => {
        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
        this._scene.simulatePointerUp(controllerData.pick || new PickingInfo(), pointerEventInit);
        controllerData.finalPointerUpTriggered = true;
      });
    }
    this._xrSessionManager.scene.onBeforeRenderObservable.addOnce(() => {
      try {
        controllerData.selectionMesh.dispose();
        controllerData.laserPointer.dispose();
        delete this._controllers[xrControllerUniqueId];
        if (this._attachedController === xrControllerUniqueId) {
          const keys = Object.keys(this._controllers);
          if (keys.length) {
            this._attachedController = keys[0];
          } else {
            this._attachedController = "";
          }
        }
      } catch (e) {
        Tools.Warn("controller already detached.");
      }
    });
  }
  _generateNewMeshPair(meshParent) {
    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;
    const laserPointer = this._options.customLasterPointerMeshGenerator ? this._options.customLasterPointerMeshGenerator() : CreateCylinder("laserPointer", {
      height: 1,
      diameterTop: 2e-4,
      diameterBottom: 4e-3,
      tessellation: 20,
      subdivisions: 1
    }, sceneToRenderTo);
    laserPointer.parent = meshParent;
    const laserPointerMaterial = new StandardMaterial("laserPointerMat", sceneToRenderTo);
    laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;
    laserPointerMaterial.alpha = 0.7;
    laserPointer.material = laserPointerMaterial;
    laserPointer.rotation.x = Math.PI / 2;
    this._updatePointerDistance(laserPointer, 1);
    laserPointer.isPickable = false;
    laserPointer.isVisible = false;
    const selectionMesh = this._options.customSelectionMeshGenerator ? this._options.customSelectionMeshGenerator() : CreateTorus("gazeTracker", {
      diameter: 35e-4 * 3,
      thickness: 25e-4 * 3,
      tessellation: 20
    }, sceneToRenderTo);
    selectionMesh.bakeCurrentTransformIntoVertices();
    selectionMesh.isPickable = false;
    selectionMesh.isVisible = false;
    const targetMat = new StandardMaterial("targetMat", sceneToRenderTo);
    targetMat.specularColor = Color3.Black();
    targetMat.emissiveColor = this.selectionMeshDefaultColor;
    targetMat.backFaceCulling = false;
    selectionMesh.material = targetMat;
    if (this._options.renderingGroupId !== void 0) {
      laserPointer.renderingGroupId = this._options.renderingGroupId;
      selectionMesh.renderingGroupId = this._options.renderingGroupId;
    }
    return {
      laserPointer,
      selectionMesh
    };
  }
  _pickingMoved(oldPick, newPick) {
    var _a;
    if (!oldPick.hit || !newPick.hit) {
      return true;
    }
    if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {
      return true;
    }
    if (oldPick.pickedMesh !== newPick.pickedMesh) {
      return true;
    }
    (_a = oldPick.pickedPoint) === null || _a === void 0 ? void 0 : _a.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);
    this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));
    const delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;
    const length = this._tmpVectorForPickCompare.length();
    if (length > delta) {
      return true;
    }
    return false;
  }
  _updatePointerDistance(_laserPointer, distance = 100) {
    _laserPointer.scaling.y = distance;
    if (this._scene.useRightHandedSystem) {
      distance *= -1;
    }
    _laserPointer.position.z = distance / 2 + 0.05;
  }
  _augmentPointerInit(pointerEventInit, id, screenCoordinates) {
    pointerEventInit.pointerId = id;
    pointerEventInit.pointerType = "xr";
    if (screenCoordinates) {
      pointerEventInit.screenX = screenCoordinates.x;
      pointerEventInit.screenY = screenCoordinates.y;
    }
  }
  get lasterPointerDefaultColor() {
    return this.laserPointerDefaultColor;
  }
};
WebXRControllerPointerSelection._IdCounter = 200;
WebXRControllerPointerSelection.Name = WebXRFeatureName.POINTER_SELECTION;
WebXRControllerPointerSelection.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRControllerPointerSelection.Name, (xrSessionManager, options) => {
  return () => new WebXRControllerPointerSelection(xrSessionManager, options);
}, WebXRControllerPointerSelection.Version, true);

// node_modules/@babylonjs/core/Meshes/subMesh.project.js
SubMesh.prototype._projectOnTrianglesToRef = function(vector, positions, indices, step, checkStopper, ref) {
  const proj = TmpVectors.Vector3[0];
  const tmp = TmpVectors.Vector3[1];
  let distance = Infinity;
  for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {
    const indexA = indices[index];
    const indexB = indices[index + 1];
    const indexC = indices[index + 2];
    if (checkStopper && indexC === 4294967295) {
      index += 2;
      continue;
    }
    const p0 = positions[indexA];
    const p1 = positions[indexB];
    const p2 = positions[indexC];
    if (!p0 || !p1 || !p2) {
      continue;
    }
    const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);
    if (tmpDist < distance) {
      proj.copyFrom(tmp);
      distance = tmpDist;
    }
  }
  ref.copyFrom(proj);
  return distance;
};
SubMesh.prototype._projectOnUnIndexedTrianglesToRef = function(vector, positions, indices, ref) {
  const proj = TmpVectors.Vector3[0];
  const tmp = TmpVectors.Vector3[1];
  let distance = Infinity;
  for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {
    const p0 = positions[index];
    const p1 = positions[index + 1];
    const p2 = positions[index + 2];
    const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);
    if (tmpDist < distance) {
      proj.copyFrom(tmp);
      distance = tmpDist;
    }
  }
  ref.copyFrom(proj);
  return distance;
};
SubMesh.prototype.projectToRef = function(vector, positions, indices, ref) {
  const material = this.getMaterial();
  if (!material) {
    return -1;
  }
  let step = 3;
  let checkStopper = false;
  switch (material.fillMode) {
    case 3:
    case 5:
    case 6:
    case 8:
      return -1;
    case 7:
      step = 1;
      checkStopper = true;
      break;
    default:
      break;
  }
  if (material.fillMode === 4) {
    return -1;
  } else {
    if (!indices.length && this._mesh._unIndexed) {
      return this._projectOnUnIndexedTrianglesToRef(vector, positions, indices, ref);
    }
    return this._projectOnTrianglesToRef(vector, positions, indices, step, checkStopper, ref);
  }
};

// node_modules/@babylonjs/core/XR/features/WebXRNearInteraction.js
var ControllerOrbAnimationState;
(function(ControllerOrbAnimationState2) {
  ControllerOrbAnimationState2[ControllerOrbAnimationState2["DEHYDRATED"] = 0] = "DEHYDRATED";
  ControllerOrbAnimationState2[ControllerOrbAnimationState2["HOVER"] = 1] = "HOVER";
  ControllerOrbAnimationState2[ControllerOrbAnimationState2["TOUCH"] = 2] = "TOUCH";
})(ControllerOrbAnimationState || (ControllerOrbAnimationState = {}));
var WebXRNearControllerMode;
(function(WebXRNearControllerMode2) {
  WebXRNearControllerMode2[WebXRNearControllerMode2["DISABLED"] = 0] = "DISABLED";
  WebXRNearControllerMode2[WebXRNearControllerMode2["CENTERED_ON_CONTROLLER"] = 1] = "CENTERED_ON_CONTROLLER";
  WebXRNearControllerMode2[WebXRNearControllerMode2["CENTERED_IN_FRONT"] = 2] = "CENTERED_IN_FRONT";
})(WebXRNearControllerMode || (WebXRNearControllerMode = {}));
var WebXRNearInteraction = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, _options) {
    super(_xrSessionManager);
    this._options = _options;
    this._tmpRay = new Ray(new Vector3(), new Vector3());
    this._attachController = (xrController) => {
      if (this._controllers[xrController.uniqueId]) {
        return;
      }
      const { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction } = this._generateNewTouchPointMesh();
      const selectionMesh = this._generateVisualCue();
      this._controllers[xrController.uniqueId] = {
        xrController,
        meshUnderPointer: null,
        nearInteractionTargetMesh: null,
        pick: null,
        stalePick: null,
        touchCollisionMesh,
        touchCollisionMeshFunction,
        hydrateCollisionMeshFunction,
        currentAnimationState: ControllerOrbAnimationState.DEHYDRATED,
        grabRay: new Ray(new Vector3(), new Vector3()),
        hoverInteraction: false,
        nearInteraction: false,
        grabInteraction: false,
        id: WebXRNearInteraction._IdCounter++,
        pickedPointVisualCue: selectionMesh
      };
      if (this._attachedController) {
        if (!this._options.enableNearInteractionOnAllControllers && this._options.preferredHandedness && xrController.inputSource.handedness === this._options.preferredHandedness) {
          this._attachedController = xrController.uniqueId;
        }
      } else {
        if (!this._options.enableNearInteractionOnAllControllers) {
          this._attachedController = xrController.uniqueId;
        }
      }
      switch (xrController.inputSource.targetRayMode) {
        case "tracked-pointer":
          return this._attachNearInteractionMode(xrController);
        case "gaze":
          return null;
        case "screen":
          return null;
      }
    };
    this._controllers = {};
    this._farInteractionFeature = null;
    this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);
    this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1);
    this._hoverRadius = 0.1;
    this._pickRadius = 0.02;
    this._controllerPickRadius = 0.03;
    this._nearGrabLengthScale = 5;
    this._scene = this._xrSessionManager.scene;
    if (this._options.nearInteractionControllerMode === void 0) {
      this._options.nearInteractionControllerMode = WebXRNearControllerMode.CENTERED_IN_FRONT;
    }
    if (this._options.farInteractionFeature) {
      this._farInteractionFeature = this._options.farInteractionFeature;
    }
  }
  attach() {
    if (!super.attach()) {
      return false;
    }
    this._options.xrInput.controllers.forEach(this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {
      this._detachController(controller.uniqueId);
    });
    this._scene.constantlyUpdateMeshUnderPointer = true;
    return true;
  }
  detach() {
    if (!super.detach()) {
      return false;
    }
    Object.keys(this._controllers).forEach((controllerId) => {
      this._detachController(controllerId);
    });
    return true;
  }
  getMeshUnderPointer(controllerId) {
    if (this._controllers[controllerId]) {
      return this._controllers[controllerId].meshUnderPointer;
    } else {
      return null;
    }
  }
  getXRControllerByPointerId(id) {
    const keys = Object.keys(this._controllers);
    for (let i = 0; i < keys.length; ++i) {
      if (this._controllers[keys[i]].id === id) {
        return this._controllers[keys[i]].xrController || null;
      }
    }
    return null;
  }
  setFarInteractionFeature(farInteractionFeature) {
    this._farInteractionFeature = farInteractionFeature;
  }
  _nearPickPredicate(mesh) {
    return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearPickable;
  }
  _nearGrabPredicate(mesh) {
    return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearGrabbable;
  }
  _nearInteractionPredicate(mesh) {
    return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && (mesh.isNearPickable || mesh.isNearGrabbable);
  }
  _controllerAvailablePredicate(mesh, controllerId) {
    let parent = mesh;
    while (parent) {
      if (parent.reservedDataStore && parent.reservedDataStore.nearInteraction && parent.reservedDataStore.nearInteraction.excludedControllerId === controllerId) {
        return false;
      }
      parent = parent.parent;
    }
    return true;
  }
  _handleTransitionAnimation(controllerData, newState) {
    var _a;
    if (controllerData.currentAnimationState === newState || this._options.nearInteractionControllerMode !== WebXRNearControllerMode.CENTERED_IN_FRONT || !!((_a = controllerData.xrController) === null || _a === void 0 ? void 0 : _a.inputSource.hand)) {
      return;
    }
    if (newState > controllerData.currentAnimationState) {
      switch (controllerData.currentAnimationState) {
        case ControllerOrbAnimationState.DEHYDRATED: {
          controllerData.hydrateCollisionMeshFunction(true);
          if (newState === ControllerOrbAnimationState.HOVER) {
            break;
          }
        }
        case ControllerOrbAnimationState.HOVER: {
          controllerData.touchCollisionMeshFunction(true);
          if (newState === ControllerOrbAnimationState.TOUCH) {
            break;
          }
        }
      }
    } else {
      switch (controllerData.currentAnimationState) {
        case ControllerOrbAnimationState.TOUCH: {
          controllerData.touchCollisionMeshFunction(false);
          if (newState === ControllerOrbAnimationState.HOVER) {
            break;
          }
        }
        case ControllerOrbAnimationState.HOVER: {
          controllerData.hydrateCollisionMeshFunction(false);
          if (newState === ControllerOrbAnimationState.DEHYDRATED) {
            break;
          }
        }
      }
    }
    controllerData.currentAnimationState = newState;
  }
  _processTouchPoint(id, position, orientation) {
    var _a;
    const controllerData = this._controllers[id];
    controllerData.grabRay.origin.copyFrom(position);
    orientation.toEulerAnglesToRef(TmpVectors.Vector3[0]);
    controllerData.grabRay.direction.copyFrom(TmpVectors.Vector3[0]);
    if (this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_IN_FRONT && !((_a = controllerData.xrController) === null || _a === void 0 ? void 0 : _a.inputSource.hand)) {
      controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);
      controllerData.grabRay.origin.addInPlace(this._tmpRay.direction.scale(0.05));
    }
    controllerData.grabRay.length = this._nearGrabLengthScale * this._hoverRadius;
    controllerData.touchCollisionMesh.position.copyFrom(controllerData.grabRay.origin);
  }
  _onXRFrame(_xrFrame) {
    Object.keys(this._controllers).forEach((id) => {
      var _a;
      const controllerData = this._controllers[id];
      const handData = (_a = controllerData.xrController) === null || _a === void 0 ? void 0 : _a.inputSource.hand;
      if (!this._options.enableNearInteractionOnAllControllers && id !== this._attachedController || !controllerData.xrController || !handData && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad)) {
        controllerData.pick = null;
        return;
      }
      controllerData.hoverInteraction = false;
      controllerData.nearInteraction = false;
      if (controllerData.xrController) {
        if (handData) {
          const xrIndexTip = handData.get("index-finger-tip");
          if (xrIndexTip) {
            const indexTipPose = _xrFrame.getJointPose(xrIndexTip, this._xrSessionManager.referenceSpace);
            if (indexTipPose && indexTipPose.transform) {
              const axisRHSMultiplier = this._scene.useRightHandedSystem ? 1 : -1;
              TmpVectors.Vector3[0].set(indexTipPose.transform.position.x, indexTipPose.transform.position.y, indexTipPose.transform.position.z * axisRHSMultiplier);
              TmpVectors.Quaternion[0].set(indexTipPose.transform.orientation.x, indexTipPose.transform.orientation.y, indexTipPose.transform.orientation.z * axisRHSMultiplier, indexTipPose.transform.orientation.w * axisRHSMultiplier);
              this._processTouchPoint(id, TmpVectors.Vector3[0], TmpVectors.Quaternion[0]);
            }
          }
        } else if (controllerData.xrController.inputSource.gamepad && this._options.nearInteractionControllerMode !== WebXRNearControllerMode.DISABLED) {
          let controllerPose = controllerData.xrController.pointer;
          if (controllerData.xrController.grip && this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_ON_CONTROLLER) {
            controllerPose = controllerData.xrController.grip;
          }
          this._processTouchPoint(id, controllerPose.position, controllerPose.rotationQuaternion);
        }
      } else {
        return;
      }
      const accuratePickInfo = (originalScenePick, utilityScenePick) => {
        let pick = null;
        if (!utilityScenePick || !utilityScenePick.hit) {
          pick = originalScenePick;
        } else if (!originalScenePick || !originalScenePick.hit) {
          pick = utilityScenePick;
        } else if (utilityScenePick.distance < originalScenePick.distance) {
          pick = utilityScenePick;
        } else {
          pick = originalScenePick;
        }
        return pick;
      };
      const populateNearInteractionInfo = (nearInteractionInfo) => {
        let result = new PickingInfo();
        let nearInteractionAtOrigin = false;
        const nearInteraction = nearInteractionInfo && nearInteractionInfo.pickedPoint && nearInteractionInfo.hit;
        if (nearInteractionInfo === null || nearInteractionInfo === void 0 ? void 0 : nearInteractionInfo.pickedPoint) {
          nearInteractionAtOrigin = nearInteractionInfo.pickedPoint.x === 0 && nearInteractionInfo.pickedPoint.y === 0 && nearInteractionInfo.pickedPoint.z === 0;
        }
        if (nearInteraction && !nearInteractionAtOrigin) {
          result = nearInteractionInfo;
        }
        return result;
      };
      if (!controllerData.grabInteraction) {
        let pick = null;
        let utilitySceneHoverPick = null;
        if (this._options.useUtilityLayer && this._utilityLayerScene) {
          utilitySceneHoverPick = this._pickWithSphere(controllerData, this._hoverRadius, this._utilityLayerScene, (mesh) => this._nearInteractionPredicate(mesh));
        }
        const originalSceneHoverPick = this._pickWithSphere(controllerData, this._hoverRadius, this._scene, (mesh) => this._nearInteractionPredicate(mesh));
        const hoverPickInfo = accuratePickInfo(originalSceneHoverPick, utilitySceneHoverPick);
        if (hoverPickInfo && hoverPickInfo.hit) {
          pick = populateNearInteractionInfo(hoverPickInfo);
          if (pick.hit) {
            controllerData.hoverInteraction = true;
          }
        }
        if (controllerData.hoverInteraction) {
          let utilitySceneNearPick = null;
          const radius = handData ? this._pickRadius : this._controllerPickRadius;
          if (this._options.useUtilityLayer && this._utilityLayerScene) {
            utilitySceneNearPick = this._pickWithSphere(controllerData, radius, this._utilityLayerScene, (mesh) => this._nearPickPredicate(mesh));
          }
          const originalSceneNearPick = this._pickWithSphere(controllerData, radius, this._scene, (mesh) => this._nearPickPredicate(mesh));
          const pickInfo = accuratePickInfo(originalSceneNearPick, utilitySceneNearPick);
          const nearPick = populateNearInteractionInfo(pickInfo);
          if (nearPick.hit) {
            pick = nearPick;
            controllerData.nearInteraction = true;
          }
        }
        controllerData.stalePick = controllerData.pick;
        controllerData.pick = pick;
        if (controllerData.pick && controllerData.pick.pickedPoint && controllerData.pick.hit) {
          controllerData.meshUnderPointer = controllerData.pick.pickedMesh;
          controllerData.pickedPointVisualCue.position.copyFrom(controllerData.pick.pickedPoint);
          controllerData.pickedPointVisualCue.isVisible = true;
          if (this._farInteractionFeature && this._farInteractionFeature.attached) {
            this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, true);
          }
        } else {
          controllerData.meshUnderPointer = null;
          controllerData.pickedPointVisualCue.isVisible = false;
          if (this._farInteractionFeature && this._farInteractionFeature.attached) {
            this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, false);
          }
        }
      }
      let state = ControllerOrbAnimationState.DEHYDRATED;
      if (controllerData.grabInteraction || controllerData.nearInteraction) {
        state = ControllerOrbAnimationState.TOUCH;
      } else if (controllerData.hoverInteraction) {
        state = ControllerOrbAnimationState.HOVER;
      }
      this._handleTransitionAnimation(controllerData, state);
    });
  }
  get _utilityLayerScene() {
    return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;
  }
  _generateVisualCue() {
    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;
    const selectionMesh = CreateSphere("nearInteraction", {
      diameter: 35e-4 * 3
    }, sceneToRenderTo);
    selectionMesh.bakeCurrentTransformIntoVertices();
    selectionMesh.isPickable = false;
    selectionMesh.isVisible = false;
    selectionMesh.rotationQuaternion = Quaternion.Identity();
    const targetMat = new StandardMaterial("targetMat", sceneToRenderTo);
    targetMat.specularColor = Color3.Black();
    targetMat.emissiveColor = this.selectionMeshDefaultColor;
    targetMat.backFaceCulling = false;
    selectionMesh.material = targetMat;
    return selectionMesh;
  }
  _isControllerReadyForNearInteraction(id) {
    if (this._farInteractionFeature) {
      return this._farInteractionFeature._getPointerSelectionDisabledByPointerId(id);
    }
    return true;
  }
  _attachNearInteractionMode(xrController) {
    const controllerData = this._controllers[xrController.uniqueId];
    const pointerEventInit = {
      pointerId: controllerData.id,
      pointerType: "xr-near"
    };
    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {
      if (!this._options.enableNearInteractionOnAllControllers && xrController.uniqueId !== this._attachedController || !controllerData.xrController || !controllerData.xrController.inputSource.hand && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad)) {
        return;
      }
      if (controllerData.pick) {
        controllerData.pick.ray = controllerData.grabRay;
      }
      if (controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id)) {
        this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);
      }
      if (controllerData.nearInteraction && controllerData.pick && controllerData.pick.hit) {
        if (!controllerData.nearInteractionTargetMesh) {
          this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);
          controllerData.nearInteractionTargetMesh = controllerData.meshUnderPointer;
        }
      } else if (controllerData.nearInteractionTargetMesh && controllerData.stalePick) {
        this._scene.simulatePointerUp(controllerData.stalePick, pointerEventInit);
        controllerData.nearInteractionTargetMesh = null;
      }
    });
    const grabCheck = (pressed) => {
      if (this._options.enableNearInteractionOnAllControllers || xrController.uniqueId === this._attachedController && this._isControllerReadyForNearInteraction(controllerData.id)) {
        if (controllerData.pick) {
          controllerData.pick.ray = controllerData.grabRay;
        }
        if (pressed && controllerData.pick && controllerData.meshUnderPointer && this._nearGrabPredicate(controllerData.meshUnderPointer)) {
          controllerData.grabInteraction = true;
          controllerData.pickedPointVisualCue.isVisible = false;
          this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);
        } else if (!pressed && controllerData.pick && controllerData.grabInteraction) {
          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
          controllerData.grabInteraction = false;
          controllerData.pickedPointVisualCue.isVisible = true;
        }
      } else {
        if (pressed && !this._options.enableNearInteractionOnAllControllers && !this._options.disableSwitchOnClick) {
          this._attachedController = xrController.uniqueId;
        }
      }
    };
    if (xrController.inputSource.gamepad) {
      const init = (motionController) => {
        controllerData.squeezeComponent = motionController.getComponent("grasp");
        if (controllerData.squeezeComponent) {
          controllerData.onSqueezeButtonChangedObserver = controllerData.squeezeComponent.onButtonStateChangedObservable.add((component) => {
            if (component.changes.pressed) {
              const pressed = component.changes.pressed.current;
              grabCheck(pressed);
            }
          });
        } else {
          controllerData.selectionComponent = motionController.getMainComponent();
          controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {
            if (component.changes.pressed) {
              const pressed = component.changes.pressed.current;
              grabCheck(pressed);
            }
          });
        }
      };
      if (xrController.motionController) {
        init(xrController.motionController);
      } else {
        xrController.onMotionControllerInitObservable.add(init);
      }
    } else {
      const selectStartListener = (event) => {
        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id) && controllerData.meshUnderPointer && this._nearGrabPredicate(controllerData.meshUnderPointer)) {
          controllerData.grabInteraction = true;
          controllerData.pickedPointVisualCue.isVisible = false;
          this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);
        }
      };
      const selectEndListener = (event) => {
        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id)) {
          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
          controllerData.grabInteraction = false;
          controllerData.pickedPointVisualCue.isVisible = true;
        }
      };
      controllerData.eventListeners = {
        selectend: selectEndListener,
        selectstart: selectStartListener
      };
      this._xrSessionManager.session.addEventListener("selectstart", selectStartListener);
      this._xrSessionManager.session.addEventListener("selectend", selectEndListener);
    }
  }
  _detachController(xrControllerUniqueId) {
    const controllerData = this._controllers[xrControllerUniqueId];
    if (!controllerData) {
      return;
    }
    if (controllerData.squeezeComponent) {
      if (controllerData.onSqueezeButtonChangedObserver) {
        controllerData.squeezeComponent.onButtonStateChangedObservable.remove(controllerData.onSqueezeButtonChangedObserver);
      }
    }
    if (controllerData.selectionComponent) {
      if (controllerData.onButtonChangedObserver) {
        controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);
      }
    }
    if (controllerData.onFrameObserver) {
      this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);
    }
    if (controllerData.eventListeners) {
      Object.keys(controllerData.eventListeners).forEach((eventName) => {
        const func = controllerData.eventListeners && controllerData.eventListeners[eventName];
        if (func) {
          this._xrSessionManager.session.removeEventListener(eventName, func);
        }
      });
    }
    controllerData.touchCollisionMesh.dispose();
    controllerData.pickedPointVisualCue.dispose();
    this._xrSessionManager.runInXRFrame(() => {
      const pointerEventInit = {
        pointerId: controllerData.id,
        pointerType: "xr-near"
      };
      this._scene.simulatePointerUp(new PickingInfo(), pointerEventInit);
    });
    delete this._controllers[xrControllerUniqueId];
    if (this._attachedController === xrControllerUniqueId) {
      const keys = Object.keys(this._controllers);
      if (keys.length) {
        this._attachedController = keys[0];
      } else {
        this._attachedController = "";
      }
    }
  }
  _generateNewTouchPointMesh() {
    const meshCreationScene = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;
    const touchCollisionMesh = CreateSphere("PickSphere", { diameter: 1 }, meshCreationScene);
    touchCollisionMesh.isVisible = false;
    if (this._options.motionControllerOrbMaterial) {
      touchCollisionMesh.material = this._options.motionControllerOrbMaterial;
    } else {
      NodeMaterial.ParseFromSnippetAsync("8RUNKL#3", meshCreationScene).then((nodeMaterial) => {
        touchCollisionMesh.material = nodeMaterial;
      });
    }
    const easingFunction = new QuadraticEase();
    easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);
    const hoverSizeVec = new Vector3(this._controllerPickRadius, this._controllerPickRadius, this._controllerPickRadius);
    const touchSize = this._controllerPickRadius * (4 / 3);
    const touchSizeVec = new Vector3(touchSize, touchSize, touchSize);
    const hydrateTransitionSize = this._controllerPickRadius * (7 / 6);
    const hydrateTransitionSizeVec = new Vector3(hydrateTransitionSize, hydrateTransitionSize, hydrateTransitionSize);
    const touchHoverTransitionSize = this._controllerPickRadius * (4 / 5);
    const touchHoverTransitionSizeVec = new Vector3(touchHoverTransitionSize, touchHoverTransitionSize, touchHoverTransitionSize);
    const hoverTouchTransitionSize = this._controllerPickRadius * (3 / 2);
    const hoverTouchTransitionSizeVec = new Vector3(hoverTouchTransitionSize, hoverTouchTransitionSize, hoverTouchTransitionSize);
    const touchKeys = [
      { frame: 0, value: hoverSizeVec },
      { frame: 10, value: hoverTouchTransitionSizeVec },
      { frame: 18, value: touchSizeVec }
    ];
    const releaseKeys = [
      { frame: 0, value: touchSizeVec },
      { frame: 10, value: touchHoverTransitionSizeVec },
      { frame: 18, value: hoverSizeVec }
    ];
    const hydrateKeys = [
      { frame: 0, value: Vector3.ZeroReadOnly },
      { frame: 12, value: hydrateTransitionSizeVec },
      { frame: 15, value: hoverSizeVec }
    ];
    const dehydrateKeys = [
      { frame: 0, value: hoverSizeVec },
      { frame: 10, value: Vector3.ZeroReadOnly },
      { frame: 15, value: Vector3.ZeroReadOnly }
    ];
    const touchAction = new Animation("touch", "scaling", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
    const releaseAction = new Animation("release", "scaling", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
    const hydrateAction = new Animation("hydrate", "scaling", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
    const dehydrateAction = new Animation("dehydrate", "scaling", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
    touchAction.setEasingFunction(easingFunction);
    releaseAction.setEasingFunction(easingFunction);
    hydrateAction.setEasingFunction(easingFunction);
    dehydrateAction.setEasingFunction(easingFunction);
    touchAction.setKeys(touchKeys);
    releaseAction.setKeys(releaseKeys);
    hydrateAction.setKeys(hydrateKeys);
    dehydrateAction.setKeys(dehydrateKeys);
    const touchCollisionMeshFunction = (isTouch) => {
      const action = isTouch ? touchAction : releaseAction;
      meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 18, false, 1);
    };
    const hydrateCollisionMeshFunction = (isHydration) => {
      const action = isHydration ? hydrateAction : dehydrateAction;
      if (isHydration) {
        touchCollisionMesh.isVisible = true;
      }
      meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 15, false, 1, () => {
        if (!isHydration) {
          touchCollisionMesh.isVisible = false;
        }
      });
    };
    return { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction };
  }
  _pickWithSphere(controllerData, radius, sceneToUse, predicate) {
    const pickingInfo = new PickingInfo();
    pickingInfo.distance = Infinity;
    if (controllerData.touchCollisionMesh && controllerData.xrController) {
      const position = controllerData.touchCollisionMesh.position;
      const sphere = BoundingSphere.CreateFromCenterAndRadius(position, radius);
      for (let meshIndex = 0; meshIndex < sceneToUse.meshes.length; meshIndex++) {
        const mesh = sceneToUse.meshes[meshIndex];
        if (!predicate(mesh) || !this._controllerAvailablePredicate(mesh, controllerData.xrController.uniqueId)) {
          continue;
        }
        const result = WebXRNearInteraction.PickMeshWithSphere(mesh, sphere);
        if (result && result.hit && result.distance < pickingInfo.distance) {
          pickingInfo.hit = result.hit;
          pickingInfo.pickedMesh = mesh;
          pickingInfo.pickedPoint = result.pickedPoint;
          pickingInfo.aimTransform = controllerData.xrController.pointer;
          pickingInfo.gripTransform = controllerData.xrController.grip || null;
          pickingInfo.originMesh = controllerData.touchCollisionMesh;
          pickingInfo.distance = result.distance;
        }
      }
    }
    return pickingInfo;
  }
  static PickMeshWithSphere(mesh, sphere, skipBoundingInfo = false) {
    const subMeshes = mesh.subMeshes;
    const pi = new PickingInfo();
    const boundingInfo = mesh.getBoundingInfo();
    if (!mesh._generatePointsArray()) {
      return pi;
    }
    if (!mesh.subMeshes || !boundingInfo) {
      return pi;
    }
    if (!skipBoundingInfo && !BoundingSphere.Intersects(boundingInfo.boundingSphere, sphere)) {
      return pi;
    }
    const result = TmpVectors.Vector3[0];
    const tmpVec = TmpVectors.Vector3[1];
    let distance = Infinity;
    let tmp, tmpDistanceSphereToCenter, tmpDistanceSurfaceToCenter;
    const center = TmpVectors.Vector3[2];
    const worldToMesh = TmpVectors.Matrix[0];
    worldToMesh.copyFrom(mesh.getWorldMatrix());
    worldToMesh.invert();
    Vector3.TransformCoordinatesToRef(sphere.center, worldToMesh, center);
    for (let index = 0; index < subMeshes.length; index++) {
      const subMesh = subMeshes[index];
      subMesh.projectToRef(center, mesh._positions, mesh.getIndices(), tmpVec);
      Vector3.TransformCoordinatesToRef(tmpVec, mesh.getWorldMatrix(), tmpVec);
      tmp = Vector3.Distance(tmpVec, sphere.center);
      tmpDistanceSurfaceToCenter = Vector3.Distance(tmpVec, mesh.getAbsolutePosition());
      tmpDistanceSphereToCenter = Vector3.Distance(sphere.center, mesh.getAbsolutePosition());
      if (tmpDistanceSphereToCenter !== -1 && tmpDistanceSurfaceToCenter !== -1 && tmpDistanceSurfaceToCenter > tmpDistanceSphereToCenter) {
        tmp = 0;
        tmpVec.copyFrom(sphere.center);
      }
      if (tmp !== -1 && tmp < distance) {
        distance = tmp;
        result.copyFrom(tmpVec);
      }
    }
    if (distance < sphere.radius) {
      pi.hit = true;
      pi.distance = distance;
      pi.pickedMesh = mesh;
      pi.pickedPoint = result.clone();
    }
    return pi;
  }
};
WebXRNearInteraction._IdCounter = 200;
WebXRNearInteraction.Name = WebXRFeatureName.NEAR_INTERACTION;
WebXRNearInteraction.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRNearInteraction.Name, (xrSessionManager, options) => {
  return () => new WebXRNearInteraction(xrSessionManager, options);
}, WebXRNearInteraction.Version, true);

// node_modules/@babylonjs/core/XR/webXREnterExitUI.js
var WebXREnterExitUIButton = class {
  constructor(element, sessionMode, referenceSpaceType) {
    this.element = element;
    this.sessionMode = sessionMode;
    this.referenceSpaceType = referenceSpaceType;
  }
  update(activeButton) {
  }
};
var WebXREnterExitUIOptions = class {
};
var WebXREnterExitUI = class {
  constructor(_scene, options) {
    this._scene = _scene;
    this.options = options;
    this._activeButton = null;
    this._buttons = [];
    this.activeButtonChangedObservable = new Observable();
    this._onSessionGranted = (evt) => {
      if (this._helper) {
        this._enterXRWithButtonIndex(0);
      }
    };
    this.overlay = document.createElement("div");
    this.overlay.classList.add("xr-button-overlay");
    if (!options.ignoreSessionGrantedEvent && navigator.xr) {
      navigator.xr.addEventListener("sessiongranted", this._onSessionGranted);
    }
    if (typeof window !== "undefined") {
      if (window.location && window.location.protocol === "http:" && window.location.hostname !== "localhost") {
        Tools.Warn("WebXR can only be served over HTTPS");
        throw new Error("WebXR can only be served over HTTPS");
      }
    }
    if (options.customButtons) {
      this._buttons = options.customButtons;
    } else {
      this.overlay.style.cssText = "z-index:11;position: absolute; right: 20px;bottom: 50px;";
      const sessionMode = options.sessionMode || "immersive-vr";
      const referenceSpaceType = options.referenceSpaceType || "local-floor";
      const url = typeof SVGSVGElement === "undefined" ? "https://cdn.babylonjs.com/Assets/vrButton.png" : "data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A";
      let css = ".babylonVRicon { color: #868686; border-color: #868686; border-style: solid; margin-left: 10px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(" + url + "); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }";
      css += '.babylonVRicon.vrdisplaypresenting { background-image: none;} .vrdisplaypresenting::after { content: "EXIT"} .xr-error::after { content: "ERROR"}';
      const style = document.createElement("style");
      style.appendChild(document.createTextNode(css));
      document.getElementsByTagName("head")[0].appendChild(style);
      const hmdBtn = document.createElement("button");
      hmdBtn.className = "babylonVRicon";
      hmdBtn.title = `${sessionMode} - ${referenceSpaceType}`;
      this._buttons.push(new WebXREnterExitUIButton(hmdBtn, sessionMode, referenceSpaceType));
      this._buttons[this._buttons.length - 1].update = function(activeButton) {
        this.element.style.display = activeButton === null || activeButton === this ? "" : "none";
        hmdBtn.className = "babylonVRicon" + (activeButton === this ? " vrdisplaypresenting" : "");
      };
      this._updateButtons(null);
    }
    const renderCanvas = _scene.getEngine().getInputElement();
    if (renderCanvas && renderCanvas.parentNode) {
      renderCanvas.parentNode.appendChild(this.overlay);
      _scene.onDisposeObservable.addOnce(() => {
        this.dispose();
      });
    }
  }
  async setHelperAsync(helper, renderTarget) {
    this._helper = helper;
    this._renderTarget = renderTarget;
    const supportedPromises = this._buttons.map((btn) => {
      return helper.sessionManager.isSessionSupportedAsync(btn.sessionMode);
    });
    helper.onStateChangedObservable.add((state) => {
      if (state == WebXRState.NOT_IN_XR) {
        this._updateButtons(null);
      }
    });
    const results = await Promise.all(supportedPromises);
    results.forEach((supported, i) => {
      if (supported) {
        this.overlay.appendChild(this._buttons[i].element);
        this._buttons[i].element.onclick = this._enterXRWithButtonIndex.bind(this, i);
      } else {
        Tools.Warn(`Session mode "${this._buttons[i].sessionMode}" not supported in browser`);
      }
    });
  }
  static async CreateAsync(scene, helper, options) {
    const ui = new WebXREnterExitUI(scene, options);
    await ui.setHelperAsync(helper, options.renderTarget || void 0);
    return ui;
  }
  async _enterXRWithButtonIndex(idx = 0) {
    if (this._helper.state == WebXRState.IN_XR) {
      await this._helper.exitXRAsync();
      this._updateButtons(null);
    } else if (this._helper.state == WebXRState.NOT_IN_XR) {
      try {
        await this._helper.enterXRAsync(this._buttons[idx].sessionMode, this._buttons[idx].referenceSpaceType, this._renderTarget, {
          optionalFeatures: this.options.optionalFeatures,
          requiredFeatures: this.options.requiredFeatures
        });
        this._updateButtons(this._buttons[idx]);
      } catch (e) {
        this._updateButtons(null);
        const element = this._buttons[idx].element;
        const prevTitle = element.title;
        element.title = "Error entering XR session : " + prevTitle;
        element.classList.add("xr-error");
        if (this.options.onError) {
          this.options.onError(e);
        }
      }
    }
  }
  dispose() {
    const renderCanvas = this._scene.getEngine().getInputElement();
    if (renderCanvas && renderCanvas.parentNode && renderCanvas.parentNode.contains(this.overlay)) {
      renderCanvas.parentNode.removeChild(this.overlay);
    }
    this.activeButtonChangedObservable.clear();
    navigator.xr.removeEventListener("sessiongranted", this._onSessionGranted);
  }
  _updateButtons(activeButton) {
    this._activeButton = activeButton;
    this._buttons.forEach((b) => {
      b.update(this._activeButton);
    });
    this.activeButtonChangedObservable.notifyObservers(this._activeButton);
  }
};

// node_modules/@babylonjs/core/Misc/timer.js
var TimerState;
(function(TimerState2) {
  TimerState2[TimerState2["INIT"] = 0] = "INIT";
  TimerState2[TimerState2["STARTED"] = 1] = "STARTED";
  TimerState2[TimerState2["ENDED"] = 2] = "ENDED";
})(TimerState || (TimerState = {}));
function setAndStartTimer(options) {
  var _a;
  let timer = 0;
  const startTime = Date.now();
  options.observableParameters = (_a = options.observableParameters) !== null && _a !== void 0 ? _a : {};
  const observer = options.contextObservable.add((payload) => {
    const now = Date.now();
    timer = now - startTime;
    const data = {
      startTime,
      currentTime: now,
      deltaTime: timer,
      completeRate: timer / options.timeout,
      payload
    };
    options.onTick && options.onTick(data);
    if (options.breakCondition && options.breakCondition()) {
      options.contextObservable.remove(observer);
      options.onAborted && options.onAborted(data);
    }
    if (timer >= options.timeout) {
      options.contextObservable.remove(observer);
      options.onEnded && options.onEnded(data);
    }
  }, options.observableParameters.mask, options.observableParameters.insertFirst, options.observableParameters.scope);
  return observer;
}
var AdvancedTimer = class {
  constructor(options) {
    var _a, _b;
    this.onEachCountObservable = new Observable();
    this.onTimerAbortedObservable = new Observable();
    this.onTimerEndedObservable = new Observable();
    this.onStateChangedObservable = new Observable();
    this._observer = null;
    this._breakOnNextTick = false;
    this._tick = (payload) => {
      const now = Date.now();
      this._timer = now - this._startTime;
      const data = {
        startTime: this._startTime,
        currentTime: now,
        deltaTime: this._timer,
        completeRate: this._timer / this._timeToEnd,
        payload
      };
      const shouldBreak = this._breakOnNextTick || this._breakCondition(data);
      if (shouldBreak || this._timer >= this._timeToEnd) {
        this._stop(data, shouldBreak);
      } else {
        this.onEachCountObservable.notifyObservers(data);
      }
    };
    this._setState(TimerState.INIT);
    this._contextObservable = options.contextObservable;
    this._observableParameters = (_a = options.observableParameters) !== null && _a !== void 0 ? _a : {};
    this._breakCondition = (_b = options.breakCondition) !== null && _b !== void 0 ? _b : () => false;
    this._timeToEnd = options.timeout;
    if (options.onEnded) {
      this.onTimerEndedObservable.add(options.onEnded);
    }
    if (options.onTick) {
      this.onEachCountObservable.add(options.onTick);
    }
    if (options.onAborted) {
      this.onTimerAbortedObservable.add(options.onAborted);
    }
  }
  set breakCondition(predicate) {
    this._breakCondition = predicate;
  }
  clearObservables() {
    this.onEachCountObservable.clear();
    this.onTimerAbortedObservable.clear();
    this.onTimerEndedObservable.clear();
    this.onStateChangedObservable.clear();
  }
  start(timeToEnd = this._timeToEnd) {
    if (this._state === TimerState.STARTED) {
      throw new Error("Timer already started. Please stop it before starting again");
    }
    this._timeToEnd = timeToEnd;
    this._startTime = Date.now();
    this._timer = 0;
    this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope);
    this._setState(TimerState.STARTED);
  }
  stop() {
    if (this._state !== TimerState.STARTED) {
      return;
    }
    this._breakOnNextTick = true;
  }
  dispose() {
    if (this._observer) {
      this._contextObservable.remove(this._observer);
    }
    this.clearObservables();
  }
  _setState(newState) {
    this._state = newState;
    this.onStateChangedObservable.notifyObservers(this._state);
  }
  _stop(data, aborted = false) {
    this._contextObservable.remove(this._observer);
    this._setState(TimerState.ENDED);
    if (aborted) {
      this.onTimerAbortedObservable.notifyObservers(data);
    } else {
      this.onTimerEndedObservable.notifyObservers(data);
    }
  }
};

// node_modules/@babylonjs/core/XR/features/WebXRControllerTeleportation.js
var WebXRMotionControllerTeleportation = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, _options) {
    super(_xrSessionManager);
    this._options = _options;
    this._controllers = {};
    this._snappedToPoint = false;
    this._tmpRay = new Ray(new Vector3(), new Vector3());
    this._tmpVector = new Vector3();
    this._tmpQuaternion = new Quaternion();
    this.skipNextTeleportation = false;
    this.backwardsMovementEnabled = true;
    this.backwardsTeleportationDistance = 0.7;
    this.parabolicCheckRadius = 5;
    this.parabolicRayEnabled = true;
    this.straightRayEnabled = true;
    this.rotationAngle = Math.PI / 8;
    this.onTargetMeshPositionUpdatedObservable = new Observable();
    this.teleportationEnabled = true;
    this._rotationEnabled = true;
    this._attachController = (xrController) => {
      if (this._controllers[xrController.uniqueId] || this._options.forceHandedness && xrController.inputSource.handedness !== this._options.forceHandedness) {
        return;
      }
      this._controllers[xrController.uniqueId] = {
        xrController,
        teleportationState: {
          forward: false,
          backwards: false,
          rotating: false,
          currentRotation: 0,
          baseRotation: 0
        }
      };
      const controllerData = this._controllers[xrController.uniqueId];
      if (controllerData.xrController.inputSource.targetRayMode === "tracked-pointer" && controllerData.xrController.inputSource.gamepad) {
        const initMotionController = () => {
          if (xrController.motionController) {
            const movementController = xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) || xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);
            if (!movementController || this._options.useMainComponentOnly) {
              const mainComponent = xrController.motionController.getMainComponent();
              if (!mainComponent) {
                return;
              }
              controllerData.teleportationComponent = mainComponent;
              controllerData.onButtonChangedObserver = mainComponent.onButtonStateChangedObservable.add(() => {
                if (!this.teleportationEnabled) {
                  return;
                }
                if (mainComponent.changes.pressed) {
                  if (mainComponent.changes.pressed.current) {
                    controllerData.teleportationState.forward = true;
                    this._currentTeleportationControllerId = controllerData.xrController.uniqueId;
                    controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;
                    controllerData.teleportationState.currentRotation = 0;
                    const timeToSelect = this._options.timeToTeleport || 3e3;
                    setAndStartTimer({
                      timeout: timeToSelect,
                      contextObservable: this._xrSessionManager.onXRFrameObservable,
                      breakCondition: () => !mainComponent.pressed,
                      onEnded: () => {
                        if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {
                          this._teleportForward(xrController.uniqueId);
                        }
                      }
                    });
                  } else {
                    controllerData.teleportationState.forward = false;
                    this._currentTeleportationControllerId = "";
                  }
                }
              });
            } else {
              controllerData.teleportationComponent = movementController;
              controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add((axesData) => {
                if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {
                  controllerData.teleportationState.backwards = false;
                }
                if (axesData.y > 0.7 && !controllerData.teleportationState.forward && this.backwardsMovementEnabled && !this.snapPointsOnly) {
                  if (!controllerData.teleportationState.backwards) {
                    controllerData.teleportationState.backwards = true;
                    this._tmpQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion);
                    this._tmpQuaternion.toEulerAnglesToRef(this._tmpVector);
                    this._tmpVector.x = 0;
                    this._tmpVector.z = 0;
                    Quaternion.FromEulerVectorToRef(this._tmpVector, this._tmpQuaternion);
                    this._tmpVector.set(0, 0, this.backwardsTeleportationDistance * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1));
                    this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);
                    this._tmpVector.addInPlace(this._options.xrInput.xrCamera.position);
                    this._tmpRay.origin.copyFrom(this._tmpVector);
                    this._tmpRay.length = this._options.xrInput.xrCamera.realWorldHeight + 0.1;
                    this._tmpRay.direction.set(0, -1, 0);
                    const pick = this._xrSessionManager.scene.pickWithRay(this._tmpRay, (o) => {
                      return this._floorMeshes.indexOf(o) !== -1;
                    });
                    if (pick && pick.pickedPoint) {
                      this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;
                      this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;
                    }
                  }
                }
                if (axesData.y < -0.7 && !this._currentTeleportationControllerId && !controllerData.teleportationState.rotating && this.teleportationEnabled) {
                  controllerData.teleportationState.forward = true;
                  this._currentTeleportationControllerId = controllerData.xrController.uniqueId;
                  controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;
                }
                if (axesData.x) {
                  if (!controllerData.teleportationState.forward) {
                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {
                      controllerData.teleportationState.rotating = true;
                      const rotation = this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);
                      Quaternion.FromEulerAngles(0, rotation, 0).multiplyToRef(this._options.xrInput.xrCamera.rotationQuaternion, this._options.xrInput.xrCamera.rotationQuaternion);
                    }
                  } else {
                    if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {
                      if (this.rotationEnabled) {
                        setTimeout(() => {
                          controllerData.teleportationState.currentRotation = Math.atan2(axesData.x, axesData.y * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1));
                        });
                      } else {
                        controllerData.teleportationState.currentRotation = 0;
                      }
                    }
                  }
                } else {
                  controllerData.teleportationState.rotating = false;
                }
                if (axesData.x === 0 && axesData.y === 0) {
                  if (controllerData.teleportationState.forward) {
                    this._teleportForward(xrController.uniqueId);
                  }
                }
              });
            }
          }
        };
        if (xrController.motionController) {
          initMotionController();
        } else {
          xrController.onMotionControllerInitObservable.addOnce(() => {
            initMotionController();
          });
        }
      } else {
        this._xrSessionManager.scene.onPointerObservable.add((pointerInfo) => {
          if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {
            controllerData.teleportationState.forward = true;
            this._currentTeleportationControllerId = controllerData.xrController.uniqueId;
            controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;
            controllerData.teleportationState.currentRotation = 0;
            const timeToSelect = this._options.timeToTeleport || 3e3;
            setAndStartTimer({
              timeout: timeToSelect,
              contextObservable: this._xrSessionManager.onXRFrameObservable,
              onEnded: () => {
                if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {
                  this._teleportForward(xrController.uniqueId);
                }
              }
            });
          } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {
            controllerData.teleportationState.forward = false;
            this._currentTeleportationControllerId = "";
          }
        });
      }
    };
    if (!this._options.teleportationTargetMesh) {
      this._createDefaultTargetMesh();
    }
    this._floorMeshes = this._options.floorMeshes || [];
    this._snapToPositions = this._options.snapPositions || [];
    this._setTargetMeshVisibility(false);
  }
  get rotationEnabled() {
    return this._rotationEnabled;
  }
  set rotationEnabled(enabled) {
    this._rotationEnabled = enabled;
    if (this._options.teleportationTargetMesh) {
      const children = this._options.teleportationTargetMesh.getChildMeshes(false, (node) => node.name === "rotationCone");
      if (children[0]) {
        children[0].setEnabled(enabled);
      }
    }
  }
  get teleportationTargetMesh() {
    return this._options.teleportationTargetMesh || null;
  }
  get snapPointsOnly() {
    return !!this._options.snapPointsOnly;
  }
  set snapPointsOnly(snapToPoints) {
    this._options.snapPointsOnly = snapToPoints;
  }
  addFloorMesh(mesh) {
    this._floorMeshes.push(mesh);
  }
  addBlockerMesh(mesh) {
    this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];
    this._options.pickBlockerMeshes.push(mesh);
  }
  addSnapPoint(newSnapPoint) {
    this._snapToPositions.push(newSnapPoint);
  }
  attach() {
    if (!super.attach()) {
      return false;
    }
    this._currentTeleportationControllerId = "";
    this._options.xrInput.controllers.forEach(this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {
      this._detachController(controller.uniqueId);
    });
    return true;
  }
  detach() {
    if (!super.detach()) {
      return false;
    }
    Object.keys(this._controllers).forEach((controllerId) => {
      this._detachController(controllerId);
    });
    this._setTargetMeshVisibility(false);
    this._currentTeleportationControllerId = "";
    this._controllers = {};
    return true;
  }
  dispose() {
    super.dispose();
    this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);
  }
  removeFloorMesh(mesh) {
    const index = this._floorMeshes.indexOf(mesh);
    if (index !== -1) {
      this._floorMeshes.splice(index, 1);
    }
  }
  removeBlockerMesh(mesh) {
    this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];
    const index = this._options.pickBlockerMeshes.indexOf(mesh);
    if (index !== -1) {
      this._options.pickBlockerMeshes.splice(index, 1);
    }
  }
  removeFloorMeshByName(name137) {
    const mesh = this._xrSessionManager.scene.getMeshByName(name137);
    if (mesh) {
      this.removeFloorMesh(mesh);
    }
  }
  removeSnapPoint(snapPointToRemove) {
    let index = this._snapToPositions.indexOf(snapPointToRemove);
    if (index === -1) {
      for (let i = 0; i < this._snapToPositions.length; ++i) {
        if (this._snapToPositions[i].equals(snapPointToRemove)) {
          index = i;
          break;
        }
      }
    }
    if (index !== -1) {
      this._snapToPositions.splice(index, 1);
      return true;
    }
    return false;
  }
  setSelectionFeature(selectionFeature) {
    this._selectionFeature = selectionFeature;
  }
  _onXRFrame(_xrFrame) {
    const frame = this._xrSessionManager.currentFrame;
    const scene = this._xrSessionManager.scene;
    if (!this.attach || !frame) {
      return;
    }
    const targetMesh = this._options.teleportationTargetMesh;
    if (this._currentTeleportationControllerId) {
      if (!targetMesh) {
        return;
      }
      targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();
      const controllerData = this._controllers[this._currentTeleportationControllerId];
      if (controllerData && controllerData.teleportationState.forward) {
        Quaternion.RotationYawPitchRollToRef(controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation, 0, 0, targetMesh.rotationQuaternion);
        let hitPossible = false;
        controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);
        if (this.straightRayEnabled) {
          const pick = scene.pickWithRay(this._tmpRay, (o) => {
            if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {
              return true;
            }
            const index = this._floorMeshes.indexOf(o);
            if (index === -1) {
              return false;
            }
            return this._floorMeshes[index].absolutePosition.y < this._options.xrInput.xrCamera.globalPosition.y;
          });
          if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {
            return;
          } else if (pick && pick.pickedPoint) {
            hitPossible = true;
            this._setTargetMeshPosition(pick);
            this._setTargetMeshVisibility(true);
            this._showParabolicPath(pick);
          }
        }
        if (this.parabolicRayEnabled && !hitPossible) {
          const xRotation = controllerData.xrController.pointer.rotationQuaternion.toEulerAngles().x;
          const compensation = 1 + (Math.PI / 2 - Math.abs(xRotation));
          const radius = this.parabolicCheckRadius * compensation;
          this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);
          this._tmpVector.y = this._tmpRay.origin.y;
          this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));
          this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);
          this._tmpRay.direction.normalize();
          const pick = scene.pickWithRay(this._tmpRay, (o) => {
            if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {
              return true;
            }
            return this._floorMeshes.indexOf(o) !== -1;
          });
          if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {
            return;
          } else if (pick && pick.pickedPoint) {
            hitPossible = true;
            this._setTargetMeshPosition(pick);
            this._setTargetMeshVisibility(true);
            this._showParabolicPath(pick);
          }
        }
        this._setTargetMeshVisibility(hitPossible);
      } else {
        this._setTargetMeshVisibility(false);
      }
    } else {
      this._setTargetMeshVisibility(false);
    }
  }
  _createDefaultTargetMesh() {
    this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};
    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;
    const teleportationTarget = CreateGround("teleportationTarget", { width: 2, height: 2, subdivisions: 2 }, sceneToRenderTo);
    teleportationTarget.isPickable = false;
    if (this._options.defaultTargetMeshOptions.teleportationCircleMaterial) {
      teleportationTarget.material = this._options.defaultTargetMeshOptions.teleportationCircleMaterial;
    } else {
      const length = 512;
      const dynamicTexture = new DynamicTexture("teleportationPlaneDynamicTexture", length, sceneToRenderTo, true);
      dynamicTexture.hasAlpha = true;
      const context = dynamicTexture.getContext();
      const centerX = length / 2;
      const centerY = length / 2;
      const radius = 200;
      context.beginPath();
      context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
      context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || "#444444";
      context.fill();
      context.lineWidth = 10;
      context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || "#FFFFFF";
      context.stroke();
      context.closePath();
      dynamicTexture.update();
      const teleportationCircleMaterial = new StandardMaterial("teleportationPlaneMaterial", sceneToRenderTo);
      teleportationCircleMaterial.diffuseTexture = dynamicTexture;
      teleportationTarget.material = teleportationCircleMaterial;
    }
    const torus = CreateTorus("torusTeleportation", {
      diameter: 0.75,
      thickness: 0.1,
      tessellation: 20
    }, sceneToRenderTo);
    torus.isPickable = false;
    torus.parent = teleportationTarget;
    if (!this._options.defaultTargetMeshOptions.disableAnimation) {
      const animationInnerCircle = new Animation("animationInnerCircle", "position.y", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);
      const keys = [];
      keys.push({
        frame: 0,
        value: 0
      });
      keys.push({
        frame: 30,
        value: 0.4
      });
      keys.push({
        frame: 60,
        value: 0
      });
      animationInnerCircle.setKeys(keys);
      const easingFunction = new SineEase();
      easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);
      animationInnerCircle.setEasingFunction(easingFunction);
      torus.animations = [];
      torus.animations.push(animationInnerCircle);
      sceneToRenderTo.beginAnimation(torus, 0, 60, true);
    }
    const cone = CreateCylinder("rotationCone", { diameterTop: 0, tessellation: 4 }, sceneToRenderTo);
    cone.isPickable = false;
    cone.scaling.set(0.5, 0.12, 0.2);
    cone.rotate(Axis.X, Math.PI / 2);
    cone.position.z = 0.6;
    cone.parent = torus;
    if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {
      torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;
      cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;
    } else {
      const torusConeMaterial = new StandardMaterial("torusConsMat", sceneToRenderTo);
      torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;
      if (torusConeMaterial.disableLighting) {
        torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1);
      } else {
        torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1);
      }
      torusConeMaterial.alpha = 0.9;
      torus.material = torusConeMaterial;
      cone.material = torusConeMaterial;
      this._teleportationRingMaterial = torusConeMaterial;
    }
    if (this._options.renderingGroupId !== void 0) {
      teleportationTarget.renderingGroupId = this._options.renderingGroupId;
      torus.renderingGroupId = this._options.renderingGroupId;
      cone.renderingGroupId = this._options.renderingGroupId;
    }
    this._options.teleportationTargetMesh = teleportationTarget;
    this._setTargetMeshVisibility(false);
  }
  _detachController(xrControllerUniqueId) {
    const controllerData = this._controllers[xrControllerUniqueId];
    if (!controllerData) {
      return;
    }
    if (controllerData.teleportationComponent) {
      if (controllerData.onAxisChangedObserver) {
        controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);
      }
      if (controllerData.onButtonChangedObserver) {
        controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);
      }
    }
    delete this._controllers[xrControllerUniqueId];
  }
  _findClosestSnapPointWithRadius(realPosition, radius = this._options.snapToPositionRadius || 0.8) {
    let closestPoint = null;
    let closestDistance = Number.MAX_VALUE;
    if (this._snapToPositions.length) {
      const radiusSquared = radius * radius;
      this._snapToPositions.forEach((position) => {
        const dist = Vector3.DistanceSquared(position, realPosition);
        if (dist <= radiusSquared && dist < closestDistance) {
          closestDistance = dist;
          closestPoint = position;
        }
      });
    }
    return closestPoint;
  }
  _setTargetMeshPosition(pickInfo) {
    const newPosition = pickInfo.pickedPoint;
    if (!this._options.teleportationTargetMesh || !newPosition) {
      return;
    }
    const snapPosition = this._findClosestSnapPointWithRadius(newPosition);
    this._snappedToPoint = !!snapPosition;
    if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {
      this._teleportationRingMaterial.diffuseColor.set(1, 0.3, 0.3);
    } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {
      this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1);
    }
    this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);
    this._options.teleportationTargetMesh.position.y += 0.01;
    this.onTargetMeshPositionUpdatedObservable.notifyObservers(pickInfo);
  }
  _setTargetMeshVisibility(visible) {
    if (!this._options.teleportationTargetMesh) {
      return;
    }
    if (this._options.teleportationTargetMesh.isVisible === visible) {
      return;
    }
    this._options.teleportationTargetMesh.isVisible = visible;
    this._options.teleportationTargetMesh.getChildren(void 0, false).forEach((m) => {
      m.isVisible = visible;
    });
    if (!visible) {
      if (this._quadraticBezierCurve) {
        this._quadraticBezierCurve.dispose();
        this._quadraticBezierCurve = null;
      }
      if (this._selectionFeature) {
        this._selectionFeature.attach();
      }
    } else {
      if (this._selectionFeature) {
        this._selectionFeature.detach();
      }
    }
  }
  _showParabolicPath(pickInfo) {
    if (!pickInfo.pickedPoint || !this._currentTeleportationControllerId) {
      return;
    }
    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;
    const controllerData = this._controllers[this._currentTeleportationControllerId];
    const quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray.origin, pickInfo.pickedPoint, 25);
    if (!this._options.generateRayPathMesh) {
      this._quadraticBezierCurve = CreateLines("teleportation path line", { points: quadraticBezierVectors.getPoints(), instance: this._quadraticBezierCurve, updatable: true }, sceneToRenderTo);
    } else {
      this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints(), pickInfo);
    }
    this._quadraticBezierCurve.isPickable = false;
    if (this._options.renderingGroupId !== void 0) {
      this._quadraticBezierCurve.renderingGroupId = this._options.renderingGroupId;
    }
  }
  _teleportForward(controllerId) {
    const controllerData = this._controllers[controllerId];
    if (!controllerData || !controllerData.teleportationState.forward || !this.teleportationEnabled) {
      return;
    }
    controllerData.teleportationState.forward = false;
    this._currentTeleportationControllerId = "";
    if (this.snapPointsOnly && !this._snappedToPoint) {
      return;
    }
    if (this.skipNextTeleportation) {
      this.skipNextTeleportation = false;
      return;
    }
    if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {
      const height = this._options.xrInput.xrCamera.realWorldHeight;
      this._options.xrInput.xrCamera.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);
      this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);
      this._options.xrInput.xrCamera.position.y += height;
      Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0).multiplyToRef(this._options.xrInput.xrCamera.rotationQuaternion, this._options.xrInput.xrCamera.rotationQuaternion);
      this._options.xrInput.xrCamera.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);
    }
  }
};
WebXRMotionControllerTeleportation.Name = WebXRFeatureName.TELEPORTATION;
WebXRMotionControllerTeleportation.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRMotionControllerTeleportation.Name, (xrSessionManager, options) => {
  return () => new WebXRMotionControllerTeleportation(xrSessionManager, options);
}, WebXRMotionControllerTeleportation.Version, true);

// node_modules/@babylonjs/core/XR/webXRDefaultExperience.js
var WebXRDefaultExperienceOptions = class {
};
var WebXRDefaultExperience = class {
  constructor() {
  }
  static CreateAsync(scene, options = {}) {
    const result = new WebXRDefaultExperience();
    scene.onDisposeObservable.addOnce(() => {
      result.dispose();
    });
    if (!options.disableDefaultUI) {
      const uiOptions = {
        renderTarget: result.renderTarget,
        ...options.uiOptions || {}
      };
      if (options.optionalFeatures) {
        if (typeof options.optionalFeatures === "boolean") {
          uiOptions.optionalFeatures = ["hit-test", "anchors", "plane-detection", "hand-tracking"];
        } else {
          uiOptions.optionalFeatures = options.optionalFeatures;
        }
      }
      result.enterExitUI = new WebXREnterExitUI(scene, uiOptions);
    }
    return WebXRExperienceHelper.CreateAsync(scene).then((xrHelper) => {
      result.baseExperience = xrHelper;
      if (options.ignoreNativeCameraTransformation) {
        result.baseExperience.camera.compensateOnFirstFrame = false;
      }
      result.input = new WebXRInput(xrHelper.sessionManager, xrHelper.camera, {
        controllerOptions: {
          renderingGroupId: options.renderingGroupId
        },
        ...options.inputOptions || {}
      });
      if (!options.disablePointerSelection) {
        const pointerSelectionOptions = {
          ...options.pointerSelectionOptions,
          xrInput: result.input,
          renderingGroupId: options.renderingGroupId
        };
        result.pointerSelection = result.baseExperience.featuresManager.enableFeature(WebXRControllerPointerSelection.Name, options.useStablePlugins ? "stable" : "latest", pointerSelectionOptions);
        if (!options.disableTeleportation) {
          result.teleportation = result.baseExperience.featuresManager.enableFeature(WebXRMotionControllerTeleportation.Name, options.useStablePlugins ? "stable" : "latest", {
            floorMeshes: options.floorMeshes,
            xrInput: result.input,
            renderingGroupId: options.renderingGroupId,
            ...options.teleportationOptions
          });
          result.teleportation.setSelectionFeature(result.pointerSelection);
        }
      }
      if (!options.disableNearInteraction) {
        result.nearInteraction = result.baseExperience.featuresManager.enableFeature(WebXRNearInteraction.Name, options.useStablePlugins ? "stable" : "latest", {
          xrInput: result.input,
          farInteractionFeature: result.pointerSelection,
          renderingGroupId: options.renderingGroupId,
          useUtilityLayer: true,
          enableNearInteractionOnAllControllers: true,
          ...options.nearInteractionOptions
        });
      }
      result.renderTarget = result.baseExperience.sessionManager.getWebXRRenderTarget(options.outputCanvasOptions);
      if (!options.disableDefaultUI) {
        return result.enterExitUI.setHelperAsync(result.baseExperience, result.renderTarget);
      } else {
        return;
      }
    }).then(() => {
      return result;
    }).catch((error) => {
      Logger.Error("Error initializing XR");
      Logger.Error(error);
      return result;
    });
  }
  dispose() {
    if (this.baseExperience) {
      this.baseExperience.dispose();
    }
    if (this.input) {
      this.input.dispose();
    }
    if (this.enterExitUI) {
      this.enterExitUI.dispose();
    }
    if (this.renderTarget) {
      this.renderTarget.dispose();
    }
  }
};

// node_modules/@babylonjs/core/Helpers/sceneHelpers.js
var _forceSceneHelpersToBundle = true;
Scene.prototype.createDefaultLight = function(replace = false) {
  if (replace) {
    if (this.lights) {
      for (let i = 0; i < this.lights.length; i++) {
        this.lights[i].dispose();
      }
    }
  }
  if (this.lights.length === 0) {
    new HemisphericLight("default light", Vector3.Up(), this);
  }
};
Scene.prototype.createDefaultCamera = function(createArcRotateCamera = false, replace = false, attachCameraControls = false) {
  if (replace) {
    if (this.activeCamera) {
      this.activeCamera.dispose();
      this.activeCamera = null;
    }
  }
  if (!this.activeCamera) {
    const worldExtends = this.getWorldExtends((mesh) => mesh.isVisible && mesh.isEnabled());
    const worldSize = worldExtends.max.subtract(worldExtends.min);
    const worldCenter = worldExtends.min.add(worldSize.scale(0.5));
    let camera;
    let radius = worldSize.length() * 1.5;
    if (!isFinite(radius)) {
      radius = 1;
      worldCenter.copyFromFloats(0, 0, 0);
    }
    if (createArcRotateCamera) {
      const arcRotateCamera = new ArcRotateCamera("default camera", -(Math.PI / 2), Math.PI / 2, radius, worldCenter, this);
      arcRotateCamera.lowerRadiusLimit = radius * 0.01;
      arcRotateCamera.wheelPrecision = 100 / radius;
      camera = arcRotateCamera;
    } else {
      const freeCamera = new FreeCamera("default camera", new Vector3(worldCenter.x, worldCenter.y, -radius), this);
      freeCamera.setTarget(worldCenter);
      camera = freeCamera;
    }
    camera.minZ = radius * 0.01;
    camera.maxZ = radius * 1e3;
    camera.speed = radius * 0.2;
    this.activeCamera = camera;
    if (attachCameraControls) {
      camera.attachControl();
    }
  }
};
Scene.prototype.createDefaultCameraOrLight = function(createArcRotateCamera = false, replace = false, attachCameraControls = false) {
  this.createDefaultLight(replace);
  this.createDefaultCamera(createArcRotateCamera, replace, attachCameraControls);
};
Scene.prototype.createDefaultSkybox = function(environmentTexture, pbr = false, scale = 1e3, blur = 0, setGlobalEnvTexture = true) {
  if (!environmentTexture) {
    Logger.Warn("Can not create default skybox without environment texture.");
    return null;
  }
  if (setGlobalEnvTexture) {
    if (environmentTexture) {
      this.environmentTexture = environmentTexture;
    }
  }
  const hdrSkybox = CreateBox("hdrSkyBox", { size: scale }, this);
  if (pbr) {
    const hdrSkyboxMaterial = new PBRMaterial("skyBox", this);
    hdrSkyboxMaterial.backFaceCulling = false;
    hdrSkyboxMaterial.reflectionTexture = environmentTexture.clone();
    if (hdrSkyboxMaterial.reflectionTexture) {
      hdrSkyboxMaterial.reflectionTexture.coordinatesMode = Texture.SKYBOX_MODE;
    }
    hdrSkyboxMaterial.microSurface = 1 - blur;
    hdrSkyboxMaterial.disableLighting = true;
    hdrSkyboxMaterial.twoSidedLighting = true;
    hdrSkybox.material = hdrSkyboxMaterial;
  } else {
    const skyboxMaterial = new StandardMaterial("skyBox", this);
    skyboxMaterial.backFaceCulling = false;
    skyboxMaterial.reflectionTexture = environmentTexture.clone();
    if (skyboxMaterial.reflectionTexture) {
      skyboxMaterial.reflectionTexture.coordinatesMode = Texture.SKYBOX_MODE;
    }
    skyboxMaterial.disableLighting = true;
    hdrSkybox.material = skyboxMaterial;
  }
  hdrSkybox.isPickable = false;
  hdrSkybox.infiniteDistance = true;
  hdrSkybox.ignoreCameraMaxZ = true;
  return hdrSkybox;
};
Scene.prototype.createDefaultEnvironment = function(options) {
  if (EnvironmentHelper) {
    return new EnvironmentHelper(options, this);
  }
  return null;
};
Scene.prototype.createDefaultVRExperience = function(webVROptions = {}) {
  return new VRExperienceHelper(this, webVROptions);
};
Scene.prototype.createDefaultXRExperienceAsync = function(options = {}) {
  return WebXRDefaultExperience.CreateAsync(this, options).then((helper) => {
    return helper;
  });
};

// node_modules/@babylonjs/core/Materials/Textures/videoTexture.js
function removeSource(video) {
  while (video.firstChild) {
    video.removeChild(video.firstChild);
  }
  video.srcObject = null;
  video.src = "";
  video.removeAttribute("src");
}
var VideoTexture = class extends Texture {
  constructor(name137, src, scene, generateMipMaps = false, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, settings = {}, onError, format = 5) {
    var _a, _b;
    super(null, scene, !generateMipMaps, invertY);
    this._onUserActionRequestedObservable = null;
    this._stillImageCaptured = false;
    this._displayingPosterTexture = false;
    this._frameId = -1;
    this._currentSrc = null;
    this._errorFound = false;
    this._createInternalTexture = () => {
      var _a2;
      if (this._texture != null) {
        if (this._displayingPosterTexture) {
          this._texture.dispose();
          this._displayingPosterTexture = false;
        } else {
          return;
        }
      }
      if (!this._getEngine().needPOTTextures || Tools.IsExponentOfTwo(this.video.videoWidth) && Tools.IsExponentOfTwo(this.video.videoHeight)) {
        this.wrapU = Texture.WRAP_ADDRESSMODE;
        this.wrapV = Texture.WRAP_ADDRESSMODE;
      } else {
        this.wrapU = Texture.CLAMP_ADDRESSMODE;
        this.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._generateMipMaps = false;
      }
      this._texture = this._getEngine().createDynamicTexture(this.video.videoWidth, this.video.videoHeight, this._generateMipMaps, this.samplingMode);
      this._texture.format = (_a2 = this._format) !== null && _a2 !== void 0 ? _a2 : 5;
      if (!this.video.autoplay && !this._settings.poster && !this._settings.independentVideoSource) {
        const oldHandler = this.video.onplaying;
        const oldMuted = this.video.muted;
        this.video.muted = true;
        this.video.onplaying = () => {
          this.video.muted = oldMuted;
          this.video.onplaying = oldHandler;
          this._updateInternalTexture();
          if (!this._errorFound) {
            this.video.pause();
          }
          if (this.onLoadObservable.hasObservers()) {
            this.onLoadObservable.notifyObservers(this);
          }
        };
        this._handlePlay();
      } else {
        this._updateInternalTexture();
        if (this.onLoadObservable.hasObservers()) {
          this.onLoadObservable.notifyObservers(this);
        }
      }
    };
    this._reset = () => {
      if (this._texture == null) {
        return;
      }
      if (!this._displayingPosterTexture) {
        this._texture.dispose();
        this._texture = null;
      }
    };
    this._updateInternalTexture = () => {
      if (this._texture == null) {
        return;
      }
      if (this.video.readyState < this.video.HAVE_CURRENT_DATA) {
        return;
      }
      if (this._displayingPosterTexture) {
        return;
      }
      const frameId = this.getScene().getFrameId();
      if (this._frameId === frameId) {
        return;
      }
      this._frameId = frameId;
      this._getEngine().updateVideoTexture(this._texture, this._externalTexture ? this._externalTexture : this.video, this._invertY);
    };
    this._settings = {
      autoPlay: true,
      loop: true,
      autoUpdateTexture: true,
      ...settings
    };
    this._onError = onError;
    this._generateMipMaps = generateMipMaps;
    this._initialSamplingMode = samplingMode;
    this.autoUpdateTexture = this._settings.autoUpdateTexture;
    this._currentSrc = src;
    this.name = name137 || this._getName(src);
    this.video = this._getVideo(src);
    this._externalTexture = (_b = (_a = this._engine) === null || _a === void 0 ? void 0 : _a.createExternalTexture(this.video)) !== null && _b !== void 0 ? _b : null;
    if (!this._settings.independentVideoSource) {
      if (this._settings.poster) {
        this.video.poster = this._settings.poster;
      }
      if (this._settings.autoPlay !== void 0) {
        this.video.autoplay = this._settings.autoPlay;
      }
      if (this._settings.loop !== void 0) {
        this.video.loop = this._settings.loop;
      }
      if (this._settings.muted !== void 0) {
        this.video.muted = this._settings.muted;
      }
      this.video.setAttribute("playsinline", "");
      this.video.addEventListener("paused", this._updateInternalTexture);
      this.video.addEventListener("seeked", this._updateInternalTexture);
      this.video.addEventListener("emptied", this._reset);
      if (this._settings.autoPlay) {
        this._handlePlay();
      }
    }
    this._createInternalTextureOnEvent = this._settings.poster && !this._settings.autoPlay ? "play" : "canplay";
    this.video.addEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);
    this._format = format;
    const videoHasEnoughData = this.video.readyState >= this.video.HAVE_CURRENT_DATA;
    if (this._settings.poster && (!this._settings.autoPlay || !videoHasEnoughData)) {
      this._texture = this._getEngine().createTexture(this._settings.poster, false, !this.invertY, scene);
      this._displayingPosterTexture = true;
    } else if (videoHasEnoughData) {
      this._createInternalTexture();
    }
  }
  get onUserActionRequestedObservable() {
    if (!this._onUserActionRequestedObservable) {
      this._onUserActionRequestedObservable = new Observable();
    }
    return this._onUserActionRequestedObservable;
  }
  _processError(reason) {
    this._errorFound = true;
    if (this._onError) {
      this._onError(reason === null || reason === void 0 ? void 0 : reason.message);
    } else {
      Logger.Error(reason === null || reason === void 0 ? void 0 : reason.message);
    }
  }
  _handlePlay() {
    this._errorFound = false;
    this.video.play().catch((reason) => {
      if ((reason === null || reason === void 0 ? void 0 : reason.name) === "NotAllowedError") {
        if (this._onUserActionRequestedObservable && this._onUserActionRequestedObservable.hasObservers()) {
          this._onUserActionRequestedObservable.notifyObservers(this);
          return;
        } else if (!this.video.muted) {
          Logger.Warn("Unable to autoplay a video with sound. Trying again with muted turned true");
          this.video.muted = true;
          this._errorFound = false;
          this.video.play().catch((otherReason) => {
            this._processError(otherReason);
          });
          return;
        }
      }
      this._processError(reason);
    });
  }
  getClassName() {
    return "VideoTexture";
  }
  _getName(src) {
    if (src instanceof HTMLVideoElement) {
      return src.currentSrc;
    }
    if (typeof src === "object") {
      return src.toString();
    }
    return src;
  }
  _getVideo(src) {
    if (src.isNative) {
      return src;
    }
    if (src instanceof HTMLVideoElement) {
      Tools.SetCorsBehavior(src.currentSrc, src);
      return src;
    }
    const video = document.createElement("video");
    if (typeof src === "string") {
      Tools.SetCorsBehavior(src, video);
      video.src = src;
    } else {
      Tools.SetCorsBehavior(src[0], video);
      src.forEach((url) => {
        const source = document.createElement("source");
        source.src = url;
        video.appendChild(source);
      });
    }
    this.onDisposeObservable.addOnce(() => {
      removeSource(video);
    });
    return video;
  }
  _rebuild() {
    this.update();
  }
  update() {
    if (!this.autoUpdateTexture) {
      return;
    }
    this.updateTexture(true);
  }
  updateTexture(isVisible) {
    if (!isVisible) {
      return;
    }
    if (this.video.paused && this._stillImageCaptured) {
      return;
    }
    this._stillImageCaptured = true;
    this._updateInternalTexture();
  }
  updateURL(url) {
    this.video.src = url;
    this._currentSrc = url;
  }
  clone() {
    return new VideoTexture(this.name, this._currentSrc, this.getScene(), this._generateMipMaps, this.invertY, this.samplingMode, this._settings);
  }
  dispose() {
    var _a;
    super.dispose();
    this._currentSrc = null;
    if (this._onUserActionRequestedObservable) {
      this._onUserActionRequestedObservable.clear();
      this._onUserActionRequestedObservable = null;
    }
    this.video.removeEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);
    if (!this._settings.independentVideoSource) {
      this.video.removeEventListener("paused", this._updateInternalTexture);
      this.video.removeEventListener("seeked", this._updateInternalTexture);
      this.video.removeEventListener("emptied", this._reset);
      this.video.pause();
    }
    (_a = this._externalTexture) === null || _a === void 0 ? void 0 : _a.dispose();
  }
  static CreateFromStreamAsync(scene, stream, constraints, invertY = true) {
    const video = scene.getEngine().createVideoElement(constraints);
    if (scene.getEngine()._badOS) {
      document.body.appendChild(video);
      video.style.transform = "scale(0.0001, 0.0001)";
      video.style.opacity = "0";
      video.style.position = "fixed";
      video.style.bottom = "0px";
      video.style.right = "0px";
    }
    video.setAttribute("autoplay", "");
    video.setAttribute("muted", "true");
    video.setAttribute("playsinline", "");
    video.muted = true;
    if (video.isNative) {
    } else if (video.mozSrcObject !== void 0) {
      video.mozSrcObject = stream;
    } else {
      if (typeof video.srcObject == "object") {
        video.srcObject = stream;
      } else {
        video.src = window.URL && window.URL.createObjectURL(stream);
      }
    }
    return new Promise((resolve) => {
      const onPlaying = () => {
        const videoTexture = new VideoTexture("video", video, scene, true, invertY, void 0, void 0, void 0, 4);
        if (scene.getEngine()._badOS) {
          videoTexture.onDisposeObservable.addOnce(() => {
            video.remove();
          });
        }
        videoTexture.onDisposeObservable.addOnce(() => {
          removeSource(video);
        });
        resolve(videoTexture);
        video.removeEventListener("playing", onPlaying);
      };
      video.addEventListener("playing", onPlaying);
      video.play();
    });
  }
  static async CreateFromWebCamAsync(scene, constraints, audioConstaints = false, invertY = true) {
    if (navigator.mediaDevices) {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: constraints,
        audio: audioConstaints
      });
      const videoTexture = await this.CreateFromStreamAsync(scene, stream, constraints, invertY);
      videoTexture.onDisposeObservable.addOnce(() => {
        stream.getTracks().forEach((track) => {
          track.stop();
        });
      });
      return videoTexture;
    }
    return Promise.reject("No support for userMedia on this device");
  }
  static CreateFromWebCam(scene, onReady, constraints, audioConstaints = false, invertY = true) {
    this.CreateFromWebCamAsync(scene, constraints, audioConstaints, invertY).then(function(videoTexture) {
      if (onReady) {
        onReady(videoTexture);
      }
    }).catch(function(err) {
      Logger.Error(err.name);
    });
  }
};

// node_modules/@babylonjs/core/Helpers/videoDome.js
var VideoDome = class extends TextureDome {
  get videoTexture() {
    return this._texture;
  }
  get videoMode() {
    return this.textureMode;
  }
  set videoMode(value) {
    this.textureMode = value;
  }
  _initTexture(urlsOrElement, scene, options) {
    const tempOptions = { loop: options.loop, autoPlay: options.autoPlay, autoUpdateTexture: true, poster: options.poster };
    const texture = new VideoTexture((this.name || "videoDome") + "_texture", urlsOrElement, scene, options.generateMipMaps, this._useDirectMapping, Texture.TRILINEAR_SAMPLINGMODE, tempOptions);
    if (options.clickToPlay) {
      this._pointerObserver = scene.onPointerObservable.add((data) => {
        var _a;
        ((_a = data.pickInfo) === null || _a === void 0 ? void 0 : _a.pickedMesh) === this.mesh && this._texture.video.play();
      }, PointerEventTypes.POINTERDOWN);
    }
    this._textureObserver = texture.onLoadObservable.add(() => {
      this.onLoadObservable.notifyObservers();
    });
    return texture;
  }
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this._texture.onLoadObservable.remove(this._textureObserver);
    this._scene.onPointerObservable.remove(this._pointerObserver);
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
};
VideoDome.MODE_MONOSCOPIC = TextureDome.MODE_MONOSCOPIC;
VideoDome.MODE_TOPBOTTOM = TextureDome.MODE_TOPBOTTOM;
VideoDome.MODE_SIDEBYSIDE = TextureDome.MODE_SIDEBYSIDE;

// node_modules/@babylonjs/core/Instrumentation/engineInstrumentation.js
var EngineInstrumentation = class {
  constructor(engine) {
    this.engine = engine;
    this._captureGPUFrameTime = false;
    this._captureShaderCompilationTime = false;
    this._shaderCompilationTime = new PerfCounter();
    this._onBeginFrameObserver = null;
    this._onEndFrameObserver = null;
    this._onBeforeShaderCompilationObserver = null;
    this._onAfterShaderCompilationObserver = null;
  }
  get gpuFrameTimeCounter() {
    return this.engine.getGPUFrameTimeCounter();
  }
  get captureGPUFrameTime() {
    return this._captureGPUFrameTime;
  }
  set captureGPUFrameTime(value) {
    if (value === this._captureGPUFrameTime) {
      return;
    }
    this._captureGPUFrameTime = value;
    this.engine.captureGPUFrameTime(value);
  }
  get shaderCompilationTimeCounter() {
    return this._shaderCompilationTime;
  }
  get captureShaderCompilationTime() {
    return this._captureShaderCompilationTime;
  }
  set captureShaderCompilationTime(value) {
    if (value === this._captureShaderCompilationTime) {
      return;
    }
    this._captureShaderCompilationTime = value;
    if (value) {
      this._onBeforeShaderCompilationObserver = this.engine.onBeforeShaderCompilationObservable.add(() => {
        this._shaderCompilationTime.fetchNewFrame();
        this._shaderCompilationTime.beginMonitoring();
      });
      this._onAfterShaderCompilationObserver = this.engine.onAfterShaderCompilationObservable.add(() => {
        this._shaderCompilationTime.endMonitoring();
      });
    } else {
      this.engine.onBeforeShaderCompilationObservable.remove(this._onBeforeShaderCompilationObserver);
      this._onBeforeShaderCompilationObserver = null;
      this.engine.onAfterShaderCompilationObservable.remove(this._onAfterShaderCompilationObserver);
      this._onAfterShaderCompilationObserver = null;
    }
  }
  dispose() {
    this.engine.onBeginFrameObservable.remove(this._onBeginFrameObserver);
    this._onBeginFrameObserver = null;
    this.engine.onEndFrameObservable.remove(this._onEndFrameObserver);
    this._onEndFrameObserver = null;
    this.engine.onBeforeShaderCompilationObservable.remove(this._onBeforeShaderCompilationObserver);
    this._onBeforeShaderCompilationObserver = null;
    this.engine.onAfterShaderCompilationObservable.remove(this._onAfterShaderCompilationObserver);
    this._onAfterShaderCompilationObserver = null;
    this.engine = null;
  }
};

// node_modules/@babylonjs/core/Instrumentation/sceneInstrumentation.js
var SceneInstrumentation = class {
  constructor(scene) {
    this.scene = scene;
    this._captureActiveMeshesEvaluationTime = false;
    this._activeMeshesEvaluationTime = new PerfCounter();
    this._captureRenderTargetsRenderTime = false;
    this._renderTargetsRenderTime = new PerfCounter();
    this._captureFrameTime = false;
    this._frameTime = new PerfCounter();
    this._captureRenderTime = false;
    this._renderTime = new PerfCounter();
    this._captureInterFrameTime = false;
    this._interFrameTime = new PerfCounter();
    this._captureParticlesRenderTime = false;
    this._particlesRenderTime = new PerfCounter();
    this._captureSpritesRenderTime = false;
    this._spritesRenderTime = new PerfCounter();
    this._capturePhysicsTime = false;
    this._physicsTime = new PerfCounter();
    this._captureAnimationsTime = false;
    this._animationsTime = new PerfCounter();
    this._captureCameraRenderTime = false;
    this._cameraRenderTime = new PerfCounter();
    this._onBeforeActiveMeshesEvaluationObserver = null;
    this._onAfterActiveMeshesEvaluationObserver = null;
    this._onBeforeRenderTargetsRenderObserver = null;
    this._onAfterRenderTargetsRenderObserver = null;
    this._onAfterRenderObserver = null;
    this._onBeforeDrawPhaseObserver = null;
    this._onAfterDrawPhaseObserver = null;
    this._onBeforeAnimationsObserver = null;
    this._onBeforeParticlesRenderingObserver = null;
    this._onAfterParticlesRenderingObserver = null;
    this._onBeforeSpritesRenderingObserver = null;
    this._onAfterSpritesRenderingObserver = null;
    this._onBeforePhysicsObserver = null;
    this._onAfterPhysicsObserver = null;
    this._onAfterAnimationsObserver = null;
    this._onBeforeCameraRenderObserver = null;
    this._onAfterCameraRenderObserver = null;
    this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {
      if (this._captureActiveMeshesEvaluationTime) {
        this._activeMeshesEvaluationTime.fetchNewFrame();
      }
      if (this._captureRenderTargetsRenderTime) {
        this._renderTargetsRenderTime.fetchNewFrame();
      }
      if (this._captureFrameTime) {
        Tools.StartPerformanceCounter("Scene rendering");
        this._frameTime.beginMonitoring();
      }
      if (this._captureInterFrameTime) {
        this._interFrameTime.endMonitoring();
      }
      if (this._captureParticlesRenderTime) {
        this._particlesRenderTime.fetchNewFrame();
      }
      if (this._captureSpritesRenderTime) {
        this._spritesRenderTime.fetchNewFrame();
      }
      if (this._captureAnimationsTime) {
        this._animationsTime.beginMonitoring();
      }
      this.scene.getEngine()._drawCalls.fetchNewFrame();
    });
    this._onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {
      if (this._captureFrameTime) {
        Tools.EndPerformanceCounter("Scene rendering");
        this._frameTime.endMonitoring();
      }
      if (this._captureRenderTime) {
        this._renderTime.endMonitoring(false);
      }
      if (this._captureInterFrameTime) {
        this._interFrameTime.beginMonitoring();
      }
    });
  }
  get activeMeshesEvaluationTimeCounter() {
    return this._activeMeshesEvaluationTime;
  }
  get captureActiveMeshesEvaluationTime() {
    return this._captureActiveMeshesEvaluationTime;
  }
  set captureActiveMeshesEvaluationTime(value) {
    if (value === this._captureActiveMeshesEvaluationTime) {
      return;
    }
    this._captureActiveMeshesEvaluationTime = value;
    if (value) {
      this._onBeforeActiveMeshesEvaluationObserver = this.scene.onBeforeActiveMeshesEvaluationObservable.add(() => {
        Tools.StartPerformanceCounter("Active meshes evaluation");
        this._activeMeshesEvaluationTime.beginMonitoring();
      });
      this._onAfterActiveMeshesEvaluationObserver = this.scene.onAfterActiveMeshesEvaluationObservable.add(() => {
        Tools.EndPerformanceCounter("Active meshes evaluation");
        this._activeMeshesEvaluationTime.endMonitoring();
      });
    } else {
      this.scene.onBeforeActiveMeshesEvaluationObservable.remove(this._onBeforeActiveMeshesEvaluationObserver);
      this._onBeforeActiveMeshesEvaluationObserver = null;
      this.scene.onAfterActiveMeshesEvaluationObservable.remove(this._onAfterActiveMeshesEvaluationObserver);
      this._onAfterActiveMeshesEvaluationObserver = null;
    }
  }
  get renderTargetsRenderTimeCounter() {
    return this._renderTargetsRenderTime;
  }
  get captureRenderTargetsRenderTime() {
    return this._captureRenderTargetsRenderTime;
  }
  set captureRenderTargetsRenderTime(value) {
    if (value === this._captureRenderTargetsRenderTime) {
      return;
    }
    this._captureRenderTargetsRenderTime = value;
    if (value) {
      this._onBeforeRenderTargetsRenderObserver = this.scene.onBeforeRenderTargetsRenderObservable.add(() => {
        Tools.StartPerformanceCounter("Render targets rendering");
        this._renderTargetsRenderTime.beginMonitoring();
      });
      this._onAfterRenderTargetsRenderObserver = this.scene.onAfterRenderTargetsRenderObservable.add(() => {
        Tools.EndPerformanceCounter("Render targets rendering");
        this._renderTargetsRenderTime.endMonitoring(false);
      });
    } else {
      this.scene.onBeforeRenderTargetsRenderObservable.remove(this._onBeforeRenderTargetsRenderObserver);
      this._onBeforeRenderTargetsRenderObserver = null;
      this.scene.onAfterRenderTargetsRenderObservable.remove(this._onAfterRenderTargetsRenderObserver);
      this._onAfterRenderTargetsRenderObserver = null;
    }
  }
  get particlesRenderTimeCounter() {
    return this._particlesRenderTime;
  }
  get captureParticlesRenderTime() {
    return this._captureParticlesRenderTime;
  }
  set captureParticlesRenderTime(value) {
    if (value === this._captureParticlesRenderTime) {
      return;
    }
    this._captureParticlesRenderTime = value;
    if (value) {
      this._onBeforeParticlesRenderingObserver = this.scene.onBeforeParticlesRenderingObservable.add(() => {
        Tools.StartPerformanceCounter("Particles");
        this._particlesRenderTime.beginMonitoring();
      });
      this._onAfterParticlesRenderingObserver = this.scene.onAfterParticlesRenderingObservable.add(() => {
        Tools.EndPerformanceCounter("Particles");
        this._particlesRenderTime.endMonitoring(false);
      });
    } else {
      this.scene.onBeforeParticlesRenderingObservable.remove(this._onBeforeParticlesRenderingObserver);
      this._onBeforeParticlesRenderingObserver = null;
      this.scene.onAfterParticlesRenderingObservable.remove(this._onAfterParticlesRenderingObserver);
      this._onAfterParticlesRenderingObserver = null;
    }
  }
  get spritesRenderTimeCounter() {
    return this._spritesRenderTime;
  }
  get captureSpritesRenderTime() {
    return this._captureSpritesRenderTime;
  }
  set captureSpritesRenderTime(value) {
    if (value === this._captureSpritesRenderTime) {
      return;
    }
    this._captureSpritesRenderTime = value;
    if (!this.scene.spriteManagers) {
      return;
    }
    if (value) {
      this._onBeforeSpritesRenderingObserver = this.scene.onBeforeSpritesRenderingObservable.add(() => {
        Tools.StartPerformanceCounter("Sprites");
        this._spritesRenderTime.beginMonitoring();
      });
      this._onAfterSpritesRenderingObserver = this.scene.onAfterSpritesRenderingObservable.add(() => {
        Tools.EndPerformanceCounter("Sprites");
        this._spritesRenderTime.endMonitoring(false);
      });
    } else {
      this.scene.onBeforeSpritesRenderingObservable.remove(this._onBeforeSpritesRenderingObserver);
      this._onBeforeSpritesRenderingObserver = null;
      this.scene.onAfterSpritesRenderingObservable.remove(this._onAfterSpritesRenderingObserver);
      this._onAfterSpritesRenderingObserver = null;
    }
  }
  get physicsTimeCounter() {
    return this._physicsTime;
  }
  get capturePhysicsTime() {
    return this._capturePhysicsTime;
  }
  set capturePhysicsTime(value) {
    if (value === this._capturePhysicsTime) {
      return;
    }
    if (!this.scene.onBeforePhysicsObservable) {
      return;
    }
    this._capturePhysicsTime = value;
    if (value) {
      this._onBeforePhysicsObserver = this.scene.onBeforePhysicsObservable.add(() => {
        Tools.StartPerformanceCounter("Physics");
        this._physicsTime.beginMonitoring();
      });
      this._onAfterPhysicsObserver = this.scene.onAfterPhysicsObservable.add(() => {
        Tools.EndPerformanceCounter("Physics");
        this._physicsTime.endMonitoring();
      });
    } else {
      this.scene.onBeforePhysicsObservable.remove(this._onBeforePhysicsObserver);
      this._onBeforePhysicsObserver = null;
      this.scene.onAfterPhysicsObservable.remove(this._onAfterPhysicsObserver);
      this._onAfterPhysicsObserver = null;
    }
  }
  get animationsTimeCounter() {
    return this._animationsTime;
  }
  get captureAnimationsTime() {
    return this._captureAnimationsTime;
  }
  set captureAnimationsTime(value) {
    if (value === this._captureAnimationsTime) {
      return;
    }
    this._captureAnimationsTime = value;
    if (value) {
      this._onAfterAnimationsObserver = this.scene.onAfterAnimationsObservable.add(() => {
        this._animationsTime.endMonitoring();
      });
    } else {
      this.scene.onAfterAnimationsObservable.remove(this._onAfterAnimationsObserver);
      this._onAfterAnimationsObserver = null;
    }
  }
  get frameTimeCounter() {
    return this._frameTime;
  }
  get captureFrameTime() {
    return this._captureFrameTime;
  }
  set captureFrameTime(value) {
    this._captureFrameTime = value;
  }
  get interFrameTimeCounter() {
    return this._interFrameTime;
  }
  get captureInterFrameTime() {
    return this._captureInterFrameTime;
  }
  set captureInterFrameTime(value) {
    this._captureInterFrameTime = value;
  }
  get renderTimeCounter() {
    return this._renderTime;
  }
  get captureRenderTime() {
    return this._captureRenderTime;
  }
  set captureRenderTime(value) {
    if (value === this._captureRenderTime) {
      return;
    }
    this._captureRenderTime = value;
    if (value) {
      this._onBeforeDrawPhaseObserver = this.scene.onBeforeDrawPhaseObservable.add(() => {
        this._renderTime.beginMonitoring();
        Tools.StartPerformanceCounter("Main render");
      });
      this._onAfterDrawPhaseObserver = this.scene.onAfterDrawPhaseObservable.add(() => {
        this._renderTime.endMonitoring(false);
        Tools.EndPerformanceCounter("Main render");
      });
    } else {
      this.scene.onBeforeDrawPhaseObservable.remove(this._onBeforeDrawPhaseObserver);
      this._onBeforeDrawPhaseObserver = null;
      this.scene.onAfterDrawPhaseObservable.remove(this._onAfterDrawPhaseObserver);
      this._onAfterDrawPhaseObserver = null;
    }
  }
  get cameraRenderTimeCounter() {
    return this._cameraRenderTime;
  }
  get captureCameraRenderTime() {
    return this._captureCameraRenderTime;
  }
  set captureCameraRenderTime(value) {
    if (value === this._captureCameraRenderTime) {
      return;
    }
    this._captureCameraRenderTime = value;
    if (value) {
      this._onBeforeCameraRenderObserver = this.scene.onBeforeCameraRenderObservable.add((camera) => {
        this._cameraRenderTime.beginMonitoring();
        Tools.StartPerformanceCounter(`Rendering camera ${camera.name}`);
      });
      this._onAfterCameraRenderObserver = this.scene.onAfterCameraRenderObservable.add((camera) => {
        this._cameraRenderTime.endMonitoring(false);
        Tools.EndPerformanceCounter(`Rendering camera ${camera.name}`);
      });
    } else {
      this.scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
      this._onBeforeCameraRenderObserver = null;
      this.scene.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
      this._onAfterCameraRenderObserver = null;
    }
  }
  get drawCallsCounter() {
    return this.scene.getEngine()._drawCalls;
  }
  dispose() {
    this.scene.onAfterRenderObservable.remove(this._onAfterRenderObserver);
    this._onAfterRenderObserver = null;
    this.scene.onBeforeActiveMeshesEvaluationObservable.remove(this._onBeforeActiveMeshesEvaluationObserver);
    this._onBeforeActiveMeshesEvaluationObserver = null;
    this.scene.onAfterActiveMeshesEvaluationObservable.remove(this._onAfterActiveMeshesEvaluationObserver);
    this._onAfterActiveMeshesEvaluationObserver = null;
    this.scene.onBeforeRenderTargetsRenderObservable.remove(this._onBeforeRenderTargetsRenderObserver);
    this._onBeforeRenderTargetsRenderObserver = null;
    this.scene.onAfterRenderTargetsRenderObservable.remove(this._onAfterRenderTargetsRenderObserver);
    this._onAfterRenderTargetsRenderObserver = null;
    this.scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);
    this._onBeforeAnimationsObserver = null;
    this.scene.onBeforeParticlesRenderingObservable.remove(this._onBeforeParticlesRenderingObserver);
    this._onBeforeParticlesRenderingObserver = null;
    this.scene.onAfterParticlesRenderingObservable.remove(this._onAfterParticlesRenderingObserver);
    this._onAfterParticlesRenderingObserver = null;
    if (this._onBeforeSpritesRenderingObserver) {
      this.scene.onBeforeSpritesRenderingObservable.remove(this._onBeforeSpritesRenderingObserver);
      this._onBeforeSpritesRenderingObserver = null;
    }
    if (this._onAfterSpritesRenderingObserver) {
      this.scene.onAfterSpritesRenderingObservable.remove(this._onAfterSpritesRenderingObserver);
      this._onAfterSpritesRenderingObserver = null;
    }
    this.scene.onBeforeDrawPhaseObservable.remove(this._onBeforeDrawPhaseObserver);
    this._onBeforeDrawPhaseObserver = null;
    this.scene.onAfterDrawPhaseObservable.remove(this._onAfterDrawPhaseObserver);
    this._onAfterDrawPhaseObserver = null;
    if (this._onBeforePhysicsObserver) {
      this.scene.onBeforePhysicsObservable.remove(this._onBeforePhysicsObserver);
      this._onBeforePhysicsObserver = null;
    }
    if (this._onAfterPhysicsObserver) {
      this.scene.onAfterPhysicsObservable.remove(this._onAfterPhysicsObserver);
      this._onAfterPhysicsObserver = null;
    }
    this.scene.onAfterAnimationsObservable.remove(this._onAfterAnimationsObserver);
    this._onAfterAnimationsObserver = null;
    this.scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
    this._onBeforeCameraRenderObserver = null;
    this.scene.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
    this._onAfterCameraRenderObserver = null;
    this.scene = null;
  }
};

// node_modules/@babylonjs/core/Shaders/glowMapGeneration.fragment.js
var name38 = "glowMapGenerationPixelShader";
var shader38 = `#if defined(DIFFUSE_ISLINEAR) || defined(EMISSIVE_ISLINEAR)
#include<helperFunctions>
#endif
#ifdef DIFFUSE
varying vec2 vUVDiffuse;
uniform sampler2D diffuseSampler;
#endif
#ifdef OPACITY
varying vec2 vUVOpacity;
uniform sampler2D opacitySampler;
uniform float opacityIntensity;
#endif
#ifdef EMISSIVE
varying vec2 vUVEmissive;
uniform sampler2D emissiveSampler;
#endif
#ifdef VERTEXALPHA
varying vec4 vColor;
#endif
uniform vec4 glowColor;
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
vec4 finalColor=glowColor;
#ifdef DIFFUSE
vec4 albedoTexture=texture2D(diffuseSampler,vUVDiffuse);
#ifdef DIFFUSE_ISLINEAR
albedoTexture=toGammaSpace(albedoTexture);
#endif
#ifdef GLOW
finalColor.a*=albedoTexture.a;
#endif
#ifdef HIGHLIGHT
finalColor.a=albedoTexture.a;
#endif
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vUVOpacity);
#ifdef OPACITYRGB
finalColor.a*=getLuminance(opacityMap.rgb);
#else
finalColor.a*=opacityMap.a;
#endif
finalColor.a*=opacityIntensity;
#endif
#ifdef VERTEXALPHA
finalColor.a*=vColor.a;
#endif
#ifdef ALPHATEST
if (finalColor.a<ALPHATESTVALUE)
discard;
#endif
#ifdef EMISSIVE
vec4 emissive=texture2D(emissiveSampler,vUVEmissive);
#ifdef EMISSIVE_ISLINEAR
emissive=toGammaSpace(emissive);
#endif
gl_FragColor=emissive*finalColor;
#else
gl_FragColor=finalColor;
#endif
#ifdef HIGHLIGHT
gl_FragColor.a=glowColor.a;
#endif
}`;
ShaderStore.ShadersStore[name38] = shader38;

// node_modules/@babylonjs/core/Shaders/glowMapGeneration.vertex.js
var name39 = "glowMapGenerationVertexShader";
var shader39 = `attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;
varying vec4 vPosition;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#ifdef DIFFUSE
varying vec2 vUVDiffuse;
uniform mat4 diffuseMatrix;
#endif
#ifdef OPACITY
varying vec2 vUVOpacity;
uniform mat4 opacityMatrix;
#endif
#ifdef EMISSIVE
varying vec2 vUVEmissive;
uniform mat4 emissiveMatrix;
#endif
#ifdef VERTEXALPHA
attribute vec4 color;
varying vec4 vColor;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{
vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef CUBEMAP
vPosition=worldPos;
gl_Position=viewProjection*finalWorld*vec4(position,1.0);
#else
vPosition=viewProjection*worldPos;
gl_Position=vPosition;
#endif
#ifdef DIFFUSE
#ifdef DIFFUSEUV1
vUVDiffuse=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef DIFFUSEUV2
vUVDiffuse=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
#ifdef OPACITY
#ifdef OPACITYUV1
vUVOpacity=vec2(opacityMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef OPACITYUV2
vUVOpacity=vec2(opacityMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
#ifdef EMISSIVE
#ifdef EMISSIVEUV1
vUVEmissive=vec2(emissiveMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef EMISSIVEUV2
vUVEmissive=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
#ifdef VERTEXALPHA
vColor=color;
#endif
#include<clipPlaneVertex>
}`;
ShaderStore.ShadersStore[name39] = shader39;

// node_modules/@babylonjs/core/Layers/effectLayer.js
var EffectLayer = class {
  constructor(name137, scene) {
    this._vertexBuffers = {};
    this._maxSize = 0;
    this._mainTextureDesiredSize = { width: 0, height: 0 };
    this._shouldRender = true;
    this._postProcesses = [];
    this._textures = [];
    this._emissiveTextureAndColor = { texture: null, color: new Color4() };
    this.neutralColor = new Color4();
    this.isEnabled = true;
    this.disableBoundingBoxesFromEffectLayer = false;
    this.onDisposeObservable = new Observable();
    this.onBeforeRenderMainTextureObservable = new Observable();
    this.onBeforeComposeObservable = new Observable();
    this.onBeforeRenderMeshToEffect = new Observable();
    this.onAfterRenderMeshToEffect = new Observable();
    this.onAfterComposeObservable = new Observable();
    this.onSizeChangedObservable = new Observable();
    this._materialForRendering = {};
    this.name = name137;
    this._scene = scene || EngineStore.LastCreatedScene;
    EffectLayer._SceneComponentInitialization(this._scene);
    this._engine = this._scene.getEngine();
    this._maxSize = this._engine.getCaps().maxTextureSize;
    this._scene.effectLayers.push(this);
    this._mergeDrawWrapper = [];
    this._generateIndexBuffer();
    this._generateVertexBuffer();
  }
  get camera() {
    return this._effectLayerOptions.camera;
  }
  get renderingGroupId() {
    return this._effectLayerOptions.renderingGroupId;
  }
  set renderingGroupId(renderingGroupId) {
    this._effectLayerOptions.renderingGroupId = renderingGroupId;
  }
  get mainTexture() {
    return this._mainTexture;
  }
  setMaterialForRendering(mesh, material) {
    this._mainTexture.setMaterialForRendering(mesh, material);
    if (Array.isArray(mesh)) {
      for (let i = 0; i < mesh.length; ++i) {
        const currentMesh = mesh[i];
        if (!material) {
          delete this._materialForRendering[currentMesh.uniqueId];
        } else {
          this._materialForRendering[currentMesh.uniqueId] = [currentMesh, material];
        }
      }
    } else {
      if (!material) {
        delete this._materialForRendering[mesh.uniqueId];
      } else {
        this._materialForRendering[mesh.uniqueId] = [mesh, material];
      }
    }
  }
  _numInternalDraws() {
    return 1;
  }
  _init(options) {
    this._effectLayerOptions = {
      mainTextureRatio: 0.5,
      alphaBlendingMode: 2,
      camera: null,
      renderingGroupId: -1,
      mainTextureType: 0,
      ...options
    };
    this._setMainTextureSize();
    this._createMainTexture();
    this._createTextureAndPostProcesses();
  }
  _generateIndexBuffer() {
    const indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = this._engine.createIndexBuffer(indices);
  }
  _generateVertexBuffer() {
    const vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    const vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);
    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;
  }
  _setMainTextureSize() {
    if (this._effectLayerOptions.mainTextureFixedSize) {
      this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;
      this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;
    } else {
      this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;
      this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;
      this._mainTextureDesiredSize.width = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize) : this._mainTextureDesiredSize.width;
      this._mainTextureDesiredSize.height = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize) : this._mainTextureDesiredSize.height;
    }
    this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);
    this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);
  }
  _createMainTexture() {
    this._mainTexture = new RenderTargetTexture("EffectLayerMainRTT", {
      width: this._mainTextureDesiredSize.width,
      height: this._mainTextureDesiredSize.height
    }, this._scene, false, true, this._effectLayerOptions.mainTextureType);
    this._mainTexture.activeCamera = this._effectLayerOptions.camera;
    this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._mainTexture.anisotropicFilteringLevel = 1;
    this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    this._mainTexture.renderParticles = false;
    this._mainTexture.renderList = null;
    this._mainTexture.ignoreCameraViewport = true;
    for (const id in this._materialForRendering) {
      const [mesh, material] = this._materialForRendering[id];
      this._mainTexture.setMaterialForRendering(mesh, material);
    }
    this._mainTexture.customIsReadyFunction = (mesh, refreshRate, preWarm) => {
      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {
        for (let i = 0; i < mesh.subMeshes.length; ++i) {
          const subMesh = mesh.subMeshes[i];
          const material = subMesh.getMaterial();
          const renderingMesh = subMesh.getRenderingMesh();
          if (!material) {
            continue;
          }
          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
          const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;
          this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);
          if (!this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {
            return false;
          }
        }
      }
      return true;
    };
    this._mainTexture.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {
      this.onBeforeRenderMainTextureObservable.notifyObservers(this);
      let index;
      const engine = this._scene.getEngine();
      if (depthOnlySubMeshes.length) {
        engine.setColorWrite(false);
        for (index = 0; index < depthOnlySubMeshes.length; index++) {
          this._renderSubMesh(depthOnlySubMeshes.data[index]);
        }
        engine.setColorWrite(true);
      }
      for (index = 0; index < opaqueSubMeshes.length; index++) {
        this._renderSubMesh(opaqueSubMeshes.data[index]);
      }
      for (index = 0; index < alphaTestSubMeshes.length; index++) {
        this._renderSubMesh(alphaTestSubMeshes.data[index]);
      }
      const previousAlphaMode = engine.getAlphaMode();
      for (index = 0; index < transparentSubMeshes.length; index++) {
        this._renderSubMesh(transparentSubMeshes.data[index], true);
      }
      engine.setAlphaMode(previousAlphaMode);
    };
    this._mainTexture.onClearObservable.add((engine) => {
      engine.clear(this.neutralColor, true, true, true);
    });
    if (this._scene.getBoundingBoxRenderer) {
      const boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;
      this._mainTexture.onBeforeBindObservable.add(() => {
        this._scene.getBoundingBoxRenderer().enabled = !this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;
      });
      this._mainTexture.onAfterUnbindObservable.add(() => {
        this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;
      });
    }
  }
  _addCustomEffectDefines(defines) {
  }
  _isReady(subMesh, useInstances, emissiveTexture) {
    var _a;
    const engine = this._scene.getEngine();
    const mesh = subMesh.getMesh();
    const renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[engine.currentRenderPassId];
    if (renderingMaterial) {
      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);
    }
    const material = subMesh.getMaterial();
    if (!material) {
      return false;
    }
    if (this._useMeshMaterial(subMesh.getRenderingMesh())) {
      return material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);
    }
    const defines = [];
    const attribs = [VertexBuffer.PositionKind];
    let uv1 = false;
    let uv2 = false;
    if (material) {
      const needAlphaTest = material.needAlphaTesting();
      const diffuseTexture = material.getAlphaTestTexture();
      const needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);
      if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {
        defines.push("#define DIFFUSE");
        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {
          defines.push("#define DIFFUSEUV2");
          uv2 = true;
        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
          defines.push("#define DIFFUSEUV1");
          uv1 = true;
        }
        if (needAlphaTest) {
          defines.push("#define ALPHATEST");
          defines.push("#define ALPHATESTVALUE 0.4");
        }
        if (!diffuseTexture.gammaSpace) {
          defines.push("#define DIFFUSE_ISLINEAR");
        }
      }
      const opacityTexture = material.opacityTexture;
      if (opacityTexture) {
        defines.push("#define OPACITY");
        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {
          defines.push("#define OPACITYUV2");
          uv2 = true;
        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
          defines.push("#define OPACITYUV1");
          uv1 = true;
        }
      }
    }
    if (emissiveTexture) {
      defines.push("#define EMISSIVE");
      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {
        defines.push("#define EMISSIVEUV2");
        uv2 = true;
      } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
        defines.push("#define EMISSIVEUV1");
        uv1 = true;
      }
      if (!emissiveTexture.gammaSpace) {
        defines.push("#define EMISSIVE_ISLINEAR");
      }
    }
    if (mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha && material.transparencyMode !== Material.MATERIAL_OPAQUE) {
      attribs.push(VertexBuffer.ColorKind);
      defines.push("#define VERTEXALPHA");
    }
    if (uv1) {
      attribs.push(VertexBuffer.UVKind);
      defines.push("#define UV1");
    }
    if (uv2) {
      attribs.push(VertexBuffer.UV2Kind);
      defines.push("#define UV2");
    }
    const fallbacks = new EffectFallbacks();
    if (mesh.useBones && mesh.computeBonesUsingShaders) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      const skeleton = mesh.skeleton;
      if (skeleton && skeleton.isUsingTextureForMatrices) {
        defines.push("#define BONETEXTURE");
      } else {
        defines.push("#define BonesPerMesh " + (skeleton ? skeleton.bones.length + 1 : 0));
      }
      if (mesh.numBoneInfluencers > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    const manager = mesh.morphTargetManager;
    let morphInfluencers = 0;
    if (manager) {
      if (manager.numInfluencers > 0) {
        defines.push("#define MORPHTARGETS");
        morphInfluencers = manager.numInfluencers;
        defines.push("#define NUM_MORPH_INFLUENCERS " + morphInfluencers);
        if (manager.isUsingTextureForTargets) {
          defines.push("#define MORPHTARGETS_TEXTURE");
        }
        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);
      }
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      MaterialHelper.PushAttributesForInstances(attribs);
      if (subMesh.getRenderingMesh().hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
      }
    }
    prepareDefinesForClipPlanes(material, this._scene, defines);
    this._addCustomEffectDefines(defines);
    const drawWrapper = subMesh._getDrawWrapper(void 0, true);
    const cachedDefines = drawWrapper.defines;
    const join = defines.join("\n");
    if (cachedDefines !== join) {
      const uniforms = [
        "world",
        "mBones",
        "viewProjection",
        "glowColor",
        "morphTargetInfluences",
        "boneTextureWidth",
        "diffuseMatrix",
        "emissiveMatrix",
        "opacityMatrix",
        "opacityIntensity",
        "morphTargetTextureInfo",
        "morphTargetTextureIndices"
      ];
      addClipPlaneUniforms(uniforms);
      drawWrapper.setEffect(this._engine.createEffect("glowMapGeneration", attribs, uniforms, ["diffuseSampler", "emissiveSampler", "opacitySampler", "boneSampler", "morphTargets"], join, fallbacks, void 0, void 0, { maxSimultaneousMorphTargets: morphInfluencers }), join);
    }
    return drawWrapper.effect.isReady();
  }
  render() {
    for (let i = 0; i < this._postProcesses.length; i++) {
      if (!this._postProcesses[i].isReady()) {
        return;
      }
    }
    const engine = this._scene.getEngine();
    const numDraws = this._numInternalDraws();
    let isReady = true;
    for (let i = 0; i < numDraws; ++i) {
      let currentEffect = this._mergeDrawWrapper[i];
      if (!currentEffect) {
        currentEffect = this._mergeDrawWrapper[i] = new DrawWrapper(this._engine);
        currentEffect.setEffect(this._createMergeEffect());
      }
      isReady = isReady && currentEffect.effect.isReady();
    }
    if (!isReady) {
      return;
    }
    this.onBeforeComposeObservable.notifyObservers(this);
    const previousAlphaMode = engine.getAlphaMode();
    for (let i = 0; i < numDraws; ++i) {
      const currentEffect = this._mergeDrawWrapper[i];
      engine.enableEffect(currentEffect);
      engine.setState(false);
      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect.effect);
      engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode);
      this._internalRender(currentEffect.effect, i);
    }
    engine.setAlphaMode(previousAlphaMode);
    this.onAfterComposeObservable.notifyObservers(this);
    const size = this._mainTexture.getSize();
    this._setMainTextureSize();
    if ((size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) && this._mainTextureDesiredSize.width !== 0 && this._mainTextureDesiredSize.height !== 0) {
      this.onSizeChangedObservable.notifyObservers(this);
      this._disposeTextureAndPostProcesses();
      this._createMainTexture();
      this._createTextureAndPostProcesses();
    }
  }
  hasMesh(mesh) {
    if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {
      return true;
    }
    return false;
  }
  shouldRender() {
    return this.isEnabled && this._shouldRender;
  }
  _shouldRenderMesh(mesh) {
    return true;
  }
  _canRenderMesh(mesh, material) {
    return !material.needAlphaBlendingForMesh(mesh);
  }
  _shouldRenderEmissiveTextureForMesh() {
    return true;
  }
  _renderSubMesh(subMesh, enableAlphaMode = false) {
    var _a, _b;
    if (!this.shouldRender()) {
      return;
    }
    const material = subMesh.getMaterial();
    const ownerMesh = subMesh.getMesh();
    const replacementMesh = subMesh.getReplacementMesh();
    const renderingMesh = subMesh.getRenderingMesh();
    const effectiveMesh = subMesh.getEffectiveMesh();
    const scene = this._scene;
    const engine = scene.getEngine();
    effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
    if (!material) {
      return;
    }
    if (!this._canRenderMesh(renderingMesh, material)) {
      return;
    }
    let sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;
    const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();
    if (mainDeterminant < 0) {
      sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
    }
    const reverse = sideOrientation === Material.ClockWiseSideOrientation;
    engine.setState(material.backFaceCulling, material.zOffset, void 0, reverse, material.cullBackFaces, void 0, material.zOffsetUnits);
    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);
    if (batch.mustReturn) {
      return;
    }
    if (!this._shouldRenderMesh(renderingMesh)) {
      return;
    }
    const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;
    this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);
    this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);
    if (this._useMeshMaterial(renderingMesh)) {
      renderingMesh.render(subMesh, enableAlphaMode, replacementMesh || void 0);
    } else if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {
      const renderingMaterial = (_b = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _b === void 0 ? void 0 : _b[engine.currentRenderPassId];
      let drawWrapper = subMesh._getDrawWrapper();
      if (!drawWrapper && renderingMaterial) {
        drawWrapper = renderingMaterial._getDrawWrapper();
      }
      if (!drawWrapper) {
        return;
      }
      const effect = drawWrapper.effect;
      engine.enableEffect(drawWrapper);
      if (!hardwareInstancedRendering) {
        const fillMode = scene.forcePointsCloud ? Material.PointFillMode : scene.forceWireframe ? Material.WireFrameFillMode : material.fillMode;
        renderingMesh._bind(subMesh, effect, fillMode);
      }
      if (!renderingMaterial) {
        effect.setMatrix("viewProjection", scene.getTransformMatrix());
        effect.setMatrix("world", effectiveMesh.getWorldMatrix());
        effect.setFloat4("glowColor", this._emissiveTextureAndColor.color.r, this._emissiveTextureAndColor.color.g, this._emissiveTextureAndColor.color.b, this._emissiveTextureAndColor.color.a);
      } else {
        renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);
      }
      if (!renderingMaterial) {
        const needAlphaTest = material.needAlphaTesting();
        const diffuseTexture = material.getAlphaTestTexture();
        const needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);
        if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {
          effect.setTexture("diffuseSampler", diffuseTexture);
          const textureMatrix = diffuseTexture.getTextureMatrix();
          if (textureMatrix) {
            effect.setMatrix("diffuseMatrix", textureMatrix);
          }
        }
        const opacityTexture = material.opacityTexture;
        if (opacityTexture) {
          effect.setTexture("opacitySampler", opacityTexture);
          effect.setFloat("opacityIntensity", opacityTexture.level);
          const textureMatrix = opacityTexture.getTextureMatrix();
          if (textureMatrix) {
            effect.setMatrix("opacityMatrix", textureMatrix);
          }
        }
        if (this._emissiveTextureAndColor.texture) {
          effect.setTexture("emissiveSampler", this._emissiveTextureAndColor.texture);
          effect.setMatrix("emissiveMatrix", this._emissiveTextureAndColor.texture.getTextureMatrix());
        }
        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
          const skeleton = renderingMesh.skeleton;
          if (skeleton.isUsingTextureForMatrices) {
            const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);
            if (!boneTexture) {
              return;
            }
            effect.setTexture("boneSampler", boneTexture);
            effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
          } else {
            effect.setMatrices("mBones", skeleton.getTransformMatrices(renderingMesh));
          }
        }
        MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);
        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
          renderingMesh.morphTargetManager._bind(effect);
        }
        if (enableAlphaMode) {
          engine.setAlphaMode(material.alphaMode);
        }
        bindClipPlane(effect, material, scene);
      }
      renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix("world", world));
    } else {
      this._mainTexture.resetRefreshCounter();
    }
    this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);
  }
  _useMeshMaterial(mesh) {
    return false;
  }
  _rebuild() {
    const vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vb) {
      vb._rebuild();
    }
    this._generateIndexBuffer();
  }
  _disposeTextureAndPostProcesses() {
    this._mainTexture.dispose();
    for (let i = 0; i < this._postProcesses.length; i++) {
      if (this._postProcesses[i]) {
        this._postProcesses[i].dispose();
      }
    }
    this._postProcesses = [];
    for (let i = 0; i < this._textures.length; i++) {
      if (this._textures[i]) {
        this._textures[i].dispose();
      }
    }
    this._textures = [];
  }
  dispose() {
    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer) {
      this._scene.getEngine()._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    for (const drawWrapper of this._mergeDrawWrapper) {
      drawWrapper.dispose();
    }
    this._mergeDrawWrapper = [];
    this._disposeTextureAndPostProcesses();
    const index = this._scene.effectLayers.indexOf(this, 0);
    if (index > -1) {
      this._scene.effectLayers.splice(index, 1);
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onBeforeRenderMainTextureObservable.clear();
    this.onBeforeComposeObservable.clear();
    this.onBeforeRenderMeshToEffect.clear();
    this.onAfterRenderMeshToEffect.clear();
    this.onAfterComposeObservable.clear();
    this.onSizeChangedObservable.clear();
  }
  getClassName() {
    return "EffectLayer";
  }
  static Parse(parsedEffectLayer, scene, rootUrl) {
    const effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);
    return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);
  }
};
EffectLayer._SceneComponentInitialization = (_) => {
  throw _WarnImport("EffectLayerSceneComponent");
};
__decorate([
  serialize()
], EffectLayer.prototype, "name", void 0);
__decorate([
  serializeAsColor4()
], EffectLayer.prototype, "neutralColor", void 0);
__decorate([
  serialize()
], EffectLayer.prototype, "isEnabled", void 0);
__decorate([
  serializeAsCameraReference()
], EffectLayer.prototype, "camera", null);
__decorate([
  serialize()
], EffectLayer.prototype, "renderingGroupId", null);
__decorate([
  serialize()
], EffectLayer.prototype, "disableBoundingBoxesFromEffectLayer", void 0);

// node_modules/@babylonjs/core/Layers/effectLayerSceneComponent.js
AbstractScene.AddParser(SceneComponentConstants.NAME_EFFECTLAYER, (parsedData, scene, container, rootUrl) => {
  if (parsedData.effectLayers) {
    if (!container.effectLayers) {
      container.effectLayers = new Array();
    }
    for (let index = 0; index < parsedData.effectLayers.length; index++) {
      const effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);
      container.effectLayers.push(effectLayer);
    }
  }
});
AbstractScene.prototype.removeEffectLayer = function(toRemove) {
  const index = this.effectLayers.indexOf(toRemove);
  if (index !== -1) {
    this.effectLayers.splice(index, 1);
  }
  return index;
};
AbstractScene.prototype.addEffectLayer = function(newEffectLayer) {
  this.effectLayers.push(newEffectLayer);
};
var EffectLayerSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_EFFECTLAYER;
    this._renderEffects = false;
    this._needStencil = false;
    this._previousStencilState = false;
    this.scene = scene || EngineStore.LastCreatedScene;
    if (!this.scene) {
      return;
    }
    this._engine = this.scene.getEngine();
    this.scene.effectLayers = new Array();
  }
  register() {
    this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);
    this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);
    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);
    this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);
    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);
    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);
  }
  rebuild() {
    const layers = this.scene.effectLayers;
    for (const effectLayer of layers) {
      effectLayer._rebuild();
    }
  }
  serialize(serializationObject) {
    serializationObject.effectLayers = [];
    const layers = this.scene.effectLayers;
    for (const effectLayer of layers) {
      if (effectLayer.serialize) {
        serializationObject.effectLayers.push(effectLayer.serialize());
      }
    }
  }
  addFromContainer(container) {
    if (!container.effectLayers) {
      return;
    }
    container.effectLayers.forEach((o) => {
      this.scene.addEffectLayer(o);
    });
  }
  removeFromContainer(container, dispose) {
    if (!container.effectLayers) {
      return;
    }
    container.effectLayers.forEach((o) => {
      this.scene.removeEffectLayer(o);
      if (dispose) {
        o.dispose();
      }
    });
  }
  dispose() {
    const layers = this.scene.effectLayers;
    while (layers.length) {
      layers[0].dispose();
    }
  }
  _isReadyForMesh(mesh, hardwareInstancedRendering) {
    const currentRenderPassId = this._engine.currentRenderPassId;
    const layers = this.scene.effectLayers;
    for (const layer of layers) {
      if (!layer.hasMesh(mesh)) {
        continue;
      }
      const renderTarget = layer._mainTexture;
      this._engine.currentRenderPassId = renderTarget.renderPassId;
      for (const subMesh of mesh.subMeshes) {
        if (!layer.isReady(subMesh, hardwareInstancedRendering)) {
          this._engine.currentRenderPassId = currentRenderPassId;
          return false;
        }
      }
    }
    this._engine.currentRenderPassId = currentRenderPassId;
    return true;
  }
  _renderMainTexture(camera) {
    this._renderEffects = false;
    this._needStencil = false;
    let needRebind = false;
    const layers = this.scene.effectLayers;
    if (layers && layers.length > 0) {
      this._previousStencilState = this._engine.getStencilBuffer();
      for (const effectLayer of layers) {
        if (effectLayer.shouldRender() && (!effectLayer.camera || effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera || effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1)) {
          this._renderEffects = true;
          this._needStencil = this._needStencil || effectLayer.needStencil();
          const renderTarget = effectLayer._mainTexture;
          if (renderTarget._shouldRender()) {
            this.scene.incrementRenderId();
            renderTarget.render(false, false);
            needRebind = true;
          }
        }
      }
      this.scene.incrementRenderId();
    }
    return needRebind;
  }
  _setStencil() {
    if (this._needStencil) {
      this._engine.setStencilBuffer(true);
    }
  }
  _setStencilBack() {
    if (this._needStencil) {
      this._engine.setStencilBuffer(this._previousStencilState);
    }
  }
  _draw(renderingGroupId) {
    if (this._renderEffects) {
      this._engine.setDepthBuffer(false);
      const layers = this.scene.effectLayers;
      for (let i = 0; i < layers.length; i++) {
        const effectLayer = layers[i];
        if (effectLayer.renderingGroupId === renderingGroupId) {
          if (effectLayer.shouldRender()) {
            effectLayer.render();
          }
        }
      }
      this._engine.setDepthBuffer(true);
    }
  }
  _drawCamera() {
    if (this._renderEffects) {
      this._draw(-1);
    }
  }
  _drawRenderingGroup(index) {
    if (!this.scene._isInIntermediateRendering() && this._renderEffects) {
      this._draw(index);
    }
  }
};
EffectLayer._SceneComponentInitialization = (scene) => {
  let component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER);
  if (!component) {
    component = new EffectLayerSceneComponent(scene);
    scene._addComponent(component);
  }
};

// node_modules/@babylonjs/core/Shaders/glowMapMerge.fragment.js
var name40 = "glowMapMergePixelShader";
var shader40 = `varying vec2 vUV;
uniform sampler2D textureSampler;
#ifdef EMISSIVE
uniform sampler2D textureSampler2;
#endif
uniform float offset;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec4 baseColor=texture2D(textureSampler,vUV);
#ifdef EMISSIVE
baseColor+=texture2D(textureSampler2,vUV);
baseColor*=offset;
#else
baseColor.a=abs(offset-baseColor.a);
#ifdef STROKE
float alpha=smoothstep(.0,.1,baseColor.a);
baseColor.a=alpha;
baseColor.rgb=baseColor.rgb*alpha;
#endif
#endif
#if LDR
baseColor=clamp(baseColor,0.,1.0);
#endif
gl_FragColor=baseColor;
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name40] = shader40;

// node_modules/@babylonjs/core/Shaders/glowMapMerge.vertex.js
var name41 = "glowMapMergeVertexShader";
var shader41 = `attribute vec2 position;
varying vec2 vUV;
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=position*madd+madd;
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name41] = shader41;

// node_modules/@babylonjs/core/Layers/glowLayer.js
AbstractScene.prototype.getGlowLayerByName = function(name137) {
  var _a;
  for (let index = 0; index < ((_a = this.effectLayers) === null || _a === void 0 ? void 0 : _a.length); index++) {
    if (this.effectLayers[index].name === name137 && this.effectLayers[index].getEffectName() === GlowLayer.EffectName) {
      return this.effectLayers[index];
    }
  }
  return null;
};
var GlowLayer = class extends EffectLayer {
  constructor(name137, scene, options) {
    super(name137, scene);
    this._intensity = 1;
    this._includedOnlyMeshes = [];
    this._excludedMeshes = [];
    this._meshesUsingTheirOwnMaterials = [];
    this.neutralColor = new Color4(0, 0, 0, 1);
    this._options = {
      mainTextureRatio: GlowLayer.DefaultTextureRatio,
      blurKernelSize: 32,
      mainTextureFixedSize: void 0,
      camera: null,
      mainTextureSamples: 1,
      renderingGroupId: -1,
      ldrMerge: false,
      alphaBlendingMode: 1,
      mainTextureType: 0,
      ...options
    };
    this._init({
      alphaBlendingMode: this._options.alphaBlendingMode,
      camera: this._options.camera,
      mainTextureFixedSize: this._options.mainTextureFixedSize,
      mainTextureRatio: this._options.mainTextureRatio,
      renderingGroupId: this._options.renderingGroupId,
      mainTextureType: this._options.mainTextureType
    });
  }
  set blurKernelSize(value) {
    if (value === this._options.blurKernelSize) {
      return;
    }
    this._options.blurKernelSize = value;
    const effectiveKernel = this._getEffectiveBlurKernelSize();
    this._horizontalBlurPostprocess1.kernel = effectiveKernel;
    this._verticalBlurPostprocess1.kernel = effectiveKernel;
    this._horizontalBlurPostprocess2.kernel = effectiveKernel;
    this._verticalBlurPostprocess2.kernel = effectiveKernel;
  }
  get blurKernelSize() {
    return this._options.blurKernelSize;
  }
  set intensity(value) {
    this._intensity = value;
  }
  get intensity() {
    return this._intensity;
  }
  getEffectName() {
    return GlowLayer.EffectName;
  }
  _createMergeEffect() {
    let defines = "#define EMISSIVE \n";
    if (this._options.ldrMerge) {
      defines += "#define LDR \n";
    }
    return this._engine.createEffect("glowMapMerge", [VertexBuffer.PositionKind], ["offset"], ["textureSampler", "textureSampler2"], defines);
  }
  _createTextureAndPostProcesses() {
    let blurTextureWidth = this._mainTextureDesiredSize.width;
    let blurTextureHeight = this._mainTextureDesiredSize.height;
    blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;
    blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;
    let textureType = 0;
    if (this._engine.getCaps().textureHalfFloatRender) {
      textureType = 2;
    } else {
      textureType = 0;
    }
    this._blurTexture1 = new RenderTargetTexture("GlowLayerBlurRTT", {
      width: blurTextureWidth,
      height: blurTextureHeight
    }, this._scene, false, true, textureType);
    this._blurTexture1.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._blurTexture1.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._blurTexture1.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    this._blurTexture1.renderParticles = false;
    this._blurTexture1.ignoreCameraViewport = true;
    const blurTextureWidth2 = Math.floor(blurTextureWidth / 2);
    const blurTextureHeight2 = Math.floor(blurTextureHeight / 2);
    this._blurTexture2 = new RenderTargetTexture("GlowLayerBlurRTT2", {
      width: blurTextureWidth2,
      height: blurTextureHeight2
    }, this._scene, false, true, textureType);
    this._blurTexture2.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._blurTexture2.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._blurTexture2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    this._blurTexture2.renderParticles = false;
    this._blurTexture2.ignoreCameraViewport = true;
    this._textures = [this._blurTexture1, this._blurTexture2];
    const effectiveKernel = this._getEffectiveBlurKernelSize();
    this._horizontalBlurPostprocess1 = new BlurPostProcess("GlowLayerHBP1", new Vector2(1, 0), effectiveKernel, {
      width: blurTextureWidth,
      height: blurTextureHeight
    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
    this._horizontalBlurPostprocess1.width = blurTextureWidth;
    this._horizontalBlurPostprocess1.height = blurTextureHeight;
    this._horizontalBlurPostprocess1.externalTextureSamplerBinding = true;
    this._horizontalBlurPostprocess1.onApplyObservable.add((effect) => {
      effect.setTexture("textureSampler", this._mainTexture);
    });
    this._verticalBlurPostprocess1 = new BlurPostProcess("GlowLayerVBP1", new Vector2(0, 1), effectiveKernel, {
      width: blurTextureWidth,
      height: blurTextureHeight
    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
    this._horizontalBlurPostprocess2 = new BlurPostProcess("GlowLayerHBP2", new Vector2(1, 0), effectiveKernel, {
      width: blurTextureWidth2,
      height: blurTextureHeight2
    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
    this._horizontalBlurPostprocess2.width = blurTextureWidth2;
    this._horizontalBlurPostprocess2.height = blurTextureHeight2;
    this._horizontalBlurPostprocess2.externalTextureSamplerBinding = true;
    this._horizontalBlurPostprocess2.onApplyObservable.add((effect) => {
      effect.setTexture("textureSampler", this._blurTexture1);
    });
    this._verticalBlurPostprocess2 = new BlurPostProcess("GlowLayerVBP2", new Vector2(0, 1), effectiveKernel, {
      width: blurTextureWidth2,
      height: blurTextureHeight2
    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
    this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];
    this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1];
    this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];
    this._mainTexture.samples = this._options.mainTextureSamples;
    this._mainTexture.onAfterUnbindObservable.add(() => {
      const internalTexture = this._blurTexture1.renderTarget;
      if (internalTexture) {
        this._scene.postProcessManager.directRender(this._postProcesses1, internalTexture, true);
        const internalTexture2 = this._blurTexture2.renderTarget;
        if (internalTexture2) {
          this._scene.postProcessManager.directRender(this._postProcesses2, internalTexture2, true);
        }
        this._engine.unBindFramebuffer(internalTexture2 !== null && internalTexture2 !== void 0 ? internalTexture2 : internalTexture, true);
      }
    });
    this._postProcesses.map((pp) => {
      pp.autoClear = false;
    });
  }
  _getEffectiveBlurKernelSize() {
    return this._options.blurKernelSize / 2;
  }
  isReady(subMesh, useInstances) {
    const material = subMesh.getMaterial();
    const mesh = subMesh.getRenderingMesh();
    if (!material || !mesh) {
      return false;
    }
    const emissiveTexture = material.emissiveTexture;
    return super._isReady(subMesh, useInstances, emissiveTexture);
  }
  needStencil() {
    return false;
  }
  _canRenderMesh(mesh, material) {
    return true;
  }
  _internalRender(effect) {
    effect.setTexture("textureSampler", this._blurTexture1);
    effect.setTexture("textureSampler2", this._blurTexture2);
    effect.setFloat("offset", this._intensity);
    const engine = this._engine;
    const previousStencilBuffer = engine.getStencilBuffer();
    engine.setStencilBuffer(false);
    engine.drawElementsType(Material.TriangleFillMode, 0, 6);
    engine.setStencilBuffer(previousStencilBuffer);
  }
  _setEmissiveTextureAndColor(mesh, subMesh, material) {
    var _a;
    let textureLevel = 1;
    if (this.customEmissiveTextureSelector) {
      this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(mesh, subMesh, material);
    } else {
      if (material) {
        this._emissiveTextureAndColor.texture = material.emissiveTexture;
        if (this._emissiveTextureAndColor.texture) {
          textureLevel = this._emissiveTextureAndColor.texture.level;
        }
      } else {
        this._emissiveTextureAndColor.texture = null;
      }
    }
    if (this.customEmissiveColorSelector) {
      this.customEmissiveColorSelector(mesh, subMesh, material, this._emissiveTextureAndColor.color);
    } else {
      if (material.emissiveColor) {
        const emissiveIntensity = (_a = material.emissiveIntensity) !== null && _a !== void 0 ? _a : 1;
        textureLevel *= emissiveIntensity;
        this._emissiveTextureAndColor.color.set(material.emissiveColor.r * textureLevel, material.emissiveColor.g * textureLevel, material.emissiveColor.b * textureLevel, material.alpha);
      } else {
        this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);
      }
    }
  }
  _shouldRenderMesh(mesh) {
    return this.hasMesh(mesh);
  }
  _addCustomEffectDefines(defines) {
    defines.push("#define GLOW");
  }
  addExcludedMesh(mesh) {
    if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {
      this._excludedMeshes.push(mesh.uniqueId);
    }
  }
  removeExcludedMesh(mesh) {
    const index = this._excludedMeshes.indexOf(mesh.uniqueId);
    if (index !== -1) {
      this._excludedMeshes.splice(index, 1);
    }
  }
  addIncludedOnlyMesh(mesh) {
    if (this._includedOnlyMeshes.indexOf(mesh.uniqueId) === -1) {
      this._includedOnlyMeshes.push(mesh.uniqueId);
    }
  }
  removeIncludedOnlyMesh(mesh) {
    const index = this._includedOnlyMeshes.indexOf(mesh.uniqueId);
    if (index !== -1) {
      this._includedOnlyMeshes.splice(index, 1);
    }
  }
  hasMesh(mesh) {
    if (!super.hasMesh(mesh)) {
      return false;
    }
    if (this._includedOnlyMeshes.length) {
      return this._includedOnlyMeshes.indexOf(mesh.uniqueId) !== -1;
    }
    if (this._excludedMeshes.length) {
      return this._excludedMeshes.indexOf(mesh.uniqueId) === -1;
    }
    return true;
  }
  _useMeshMaterial(mesh) {
    if (this._meshesUsingTheirOwnMaterials.length == 0) {
      return false;
    }
    return this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId) > -1;
  }
  referenceMeshToUseItsOwnMaterial(mesh) {
    mesh.resetDrawCache(this._mainTexture.renderPassId);
    this._meshesUsingTheirOwnMaterials.push(mesh.uniqueId);
    mesh.onDisposeObservable.add(() => {
      this._disposeMesh(mesh);
    });
  }
  unReferenceMeshFromUsingItsOwnMaterial(mesh) {
    let index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);
    while (index >= 0) {
      this._meshesUsingTheirOwnMaterials.splice(index, 1);
      index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);
    }
    mesh.resetDrawCache(this._mainTexture.renderPassId);
  }
  _disposeMesh(mesh) {
    this.removeIncludedOnlyMesh(mesh);
    this.removeExcludedMesh(mesh);
  }
  getClassName() {
    return "GlowLayer";
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.GlowLayer";
    let index;
    serializationObject.includedMeshes = [];
    if (this._includedOnlyMeshes.length) {
      for (index = 0; index < this._includedOnlyMeshes.length; index++) {
        const mesh = this._scene.getMeshByUniqueId(this._includedOnlyMeshes[index]);
        if (mesh) {
          serializationObject.includedMeshes.push(mesh.id);
        }
      }
    }
    serializationObject.excludedMeshes = [];
    if (this._excludedMeshes.length) {
      for (index = 0; index < this._excludedMeshes.length; index++) {
        const mesh = this._scene.getMeshByUniqueId(this._excludedMeshes[index]);
        if (mesh) {
          serializationObject.excludedMeshes.push(mesh.id);
        }
      }
    }
    return serializationObject;
  }
  static Parse(parsedGlowLayer, scene, rootUrl) {
    const gl = SerializationHelper.Parse(() => new GlowLayer(parsedGlowLayer.name, scene, parsedGlowLayer.options), parsedGlowLayer, scene, rootUrl);
    let index;
    for (index = 0; index < parsedGlowLayer.excludedMeshes.length; index++) {
      const mesh = scene.getMeshById(parsedGlowLayer.excludedMeshes[index]);
      if (mesh) {
        gl.addExcludedMesh(mesh);
      }
    }
    for (index = 0; index < parsedGlowLayer.includedMeshes.length; index++) {
      const mesh = scene.getMeshById(parsedGlowLayer.includedMeshes[index]);
      if (mesh) {
        gl.addIncludedOnlyMesh(mesh);
      }
    }
    return gl;
  }
};
GlowLayer.EffectName = "GlowLayer";
GlowLayer.DefaultBlurKernelSize = 32;
GlowLayer.DefaultTextureRatio = 0.5;
__decorate([
  serialize()
], GlowLayer.prototype, "blurKernelSize", null);
__decorate([
  serialize()
], GlowLayer.prototype, "intensity", null);
__decorate([
  serialize("options")
], GlowLayer.prototype, "_options", void 0);
RegisterClass("BABYLON.GlowLayer", GlowLayer);

// node_modules/@babylonjs/core/Shaders/glowBlurPostProcess.fragment.js
var name42 = "glowBlurPostProcessPixelShader";
var shader42 = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform vec2 screenSize;
uniform vec2 direction;
uniform float blurWidth;
float getLuminance(vec3 color)
{
return dot(color,vec3(0.2126,0.7152,0.0722));
}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
float weights[7];
weights[0]=0.05;
weights[1]=0.1;
weights[2]=0.2;
weights[3]=0.3;
weights[4]=0.2;
weights[5]=0.1;
weights[6]=0.05;
vec2 texelSize=vec2(1.0/screenSize.x,1.0/screenSize.y);
vec2 texelStep=texelSize*direction*blurWidth;
vec2 start=vUV-3.0*texelStep;
vec4 baseColor=vec4(0.,0.,0.,0.);
vec2 texelOffset=vec2(0.,0.);
for (int i=0; i<7; i++)
{
vec4 texel=texture2D(textureSampler,start+texelOffset);
baseColor.a+=texel.a*weights[i];
float luminance=getLuminance(baseColor.rgb);
float luminanceTexel=getLuminance(texel.rgb);
float choice=step(luminanceTexel,luminance);
baseColor.rgb=choice*baseColor.rgb+(1.0-choice)*texel.rgb;
texelOffset+=texelStep;
}
gl_FragColor=baseColor;
}`;
ShaderStore.ShadersStore[name42] = shader42;

// node_modules/@babylonjs/core/Layers/highlightLayer.js
AbstractScene.prototype.getHighlightLayerByName = function(name137) {
  var _a;
  for (let index = 0; index < ((_a = this.effectLayers) === null || _a === void 0 ? void 0 : _a.length); index++) {
    if (this.effectLayers[index].name === name137 && this.effectLayers[index].getEffectName() === HighlightLayer.EffectName) {
      return this.effectLayers[index];
    }
  }
  return null;
};
var GlowBlurPostProcess = class extends PostProcess {
  constructor(name137, direction, kernel, options, camera, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable) {
    super(name137, "glowBlurPostProcess", ["screenSize", "direction", "blurWidth"], null, options, camera, samplingMode, engine, reusable);
    this.direction = direction;
    this.kernel = kernel;
    this.onApplyObservable.add((effect) => {
      effect.setFloat2("screenSize", this.width, this.height);
      effect.setVector2("direction", this.direction);
      effect.setFloat("blurWidth", this.kernel);
    });
  }
};
var HighlightLayer = class extends EffectLayer {
  constructor(name137, scene, options) {
    super(name137, scene);
    this.name = name137;
    this.innerGlow = true;
    this.outerGlow = true;
    this.onBeforeBlurObservable = new Observable();
    this.onAfterBlurObservable = new Observable();
    this._instanceGlowingMeshStencilReference = HighlightLayer.GlowingMeshStencilReference++;
    this._meshes = {};
    this._excludedMeshes = {};
    this.neutralColor = HighlightLayer.NeutralColor;
    if (!this._engine.isStencilEnable) {
      Logger.Warn("Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new Engine(canvas, antialias, { stencil: true }");
    }
    this._options = {
      mainTextureRatio: 0.5,
      blurTextureSizeRatio: 0.5,
      blurHorizontalSize: 1,
      blurVerticalSize: 1,
      alphaBlendingMode: 2,
      camera: null,
      renderingGroupId: -1,
      mainTextureType: 0,
      ...options
    };
    this._init({
      alphaBlendingMode: this._options.alphaBlendingMode,
      camera: this._options.camera,
      mainTextureFixedSize: this._options.mainTextureFixedSize,
      mainTextureRatio: this._options.mainTextureRatio,
      renderingGroupId: this._options.renderingGroupId,
      mainTextureType: this._options.mainTextureType
    });
    this._shouldRender = false;
  }
  set blurHorizontalSize(value) {
    this._horizontalBlurPostprocess.kernel = value;
    this._options.blurHorizontalSize = value;
  }
  set blurVerticalSize(value) {
    this._verticalBlurPostprocess.kernel = value;
    this._options.blurVerticalSize = value;
  }
  get blurHorizontalSize() {
    return this._horizontalBlurPostprocess.kernel;
  }
  get blurVerticalSize() {
    return this._verticalBlurPostprocess.kernel;
  }
  getEffectName() {
    return HighlightLayer.EffectName;
  }
  _numInternalDraws() {
    return 2;
  }
  _createMergeEffect() {
    return this._engine.createEffect("glowMapMerge", [VertexBuffer.PositionKind], ["offset"], ["textureSampler"], this._options.isStroke ? "#define STROKE \n" : void 0);
  }
  _createTextureAndPostProcesses() {
    let blurTextureWidth = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio;
    let blurTextureHeight = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;
    blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;
    blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;
    let textureType = 0;
    if (this._engine.getCaps().textureHalfFloatRender) {
      textureType = 2;
    } else {
      textureType = 0;
    }
    this._blurTexture = new RenderTargetTexture("HighlightLayerBlurRTT", {
      width: blurTextureWidth,
      height: blurTextureHeight
    }, this._scene, false, true, textureType);
    this._blurTexture.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._blurTexture.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._blurTexture.anisotropicFilteringLevel = 16;
    this._blurTexture.updateSamplingMode(Texture.TRILINEAR_SAMPLINGMODE);
    this._blurTexture.renderParticles = false;
    this._blurTexture.ignoreCameraViewport = true;
    this._textures = [this._blurTexture];
    if (this._options.alphaBlendingMode === 2) {
      this._downSamplePostprocess = new PassPostProcess("HighlightLayerPPP", this._options.blurTextureSizeRatio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());
      this._downSamplePostprocess.externalTextureSamplerBinding = true;
      this._downSamplePostprocess.onApplyObservable.add((effect) => {
        effect.setTexture("textureSampler", this._mainTexture);
      });
      this._horizontalBlurPostprocess = new GlowBlurPostProcess("HighlightLayerHBP", new Vector2(1, 0), this._options.blurHorizontalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());
      this._horizontalBlurPostprocess.onApplyObservable.add((effect) => {
        effect.setFloat2("screenSize", blurTextureWidth, blurTextureHeight);
      });
      this._verticalBlurPostprocess = new GlowBlurPostProcess("HighlightLayerVBP", new Vector2(0, 1), this._options.blurVerticalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());
      this._verticalBlurPostprocess.onApplyObservable.add((effect) => {
        effect.setFloat2("screenSize", blurTextureWidth, blurTextureHeight);
      });
      this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess];
    } else {
      this._horizontalBlurPostprocess = new BlurPostProcess("HighlightLayerHBP", new Vector2(1, 0), this._options.blurHorizontalSize / 2, {
        width: blurTextureWidth,
        height: blurTextureHeight
      }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
      this._horizontalBlurPostprocess.width = blurTextureWidth;
      this._horizontalBlurPostprocess.height = blurTextureHeight;
      this._horizontalBlurPostprocess.externalTextureSamplerBinding = true;
      this._horizontalBlurPostprocess.onApplyObservable.add((effect) => {
        effect.setTexture("textureSampler", this._mainTexture);
      });
      this._verticalBlurPostprocess = new BlurPostProcess("HighlightLayerVBP", new Vector2(0, 1), this._options.blurVerticalSize / 2, {
        width: blurTextureWidth,
        height: blurTextureHeight
      }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
      this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess];
    }
    this._mainTexture.onAfterUnbindObservable.add(() => {
      this.onBeforeBlurObservable.notifyObservers(this);
      const internalTexture = this._blurTexture.renderTarget;
      if (internalTexture) {
        this._scene.postProcessManager.directRender(this._postProcesses, internalTexture, true);
        this._engine.unBindFramebuffer(internalTexture, true);
      }
      this.onAfterBlurObservable.notifyObservers(this);
    });
    this._postProcesses.map((pp) => {
      pp.autoClear = false;
    });
  }
  needStencil() {
    return true;
  }
  isReady(subMesh, useInstances) {
    const material = subMesh.getMaterial();
    const mesh = subMesh.getRenderingMesh();
    if (!material || !mesh || !this._meshes) {
      return false;
    }
    let emissiveTexture = null;
    const highlightLayerMesh = this._meshes[mesh.uniqueId];
    if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {
      emissiveTexture = material.emissiveTexture;
    }
    return super._isReady(subMesh, useInstances, emissiveTexture);
  }
  _internalRender(effect, renderIndex) {
    effect.setTexture("textureSampler", this._blurTexture);
    const engine = this._engine;
    engine.cacheStencilState();
    engine.setStencilOperationPass(7681);
    engine.setStencilOperationFail(7680);
    engine.setStencilOperationDepthFail(7680);
    engine.setStencilMask(0);
    engine.setStencilBuffer(true);
    engine.setStencilFunctionReference(this._instanceGlowingMeshStencilReference);
    if (this.outerGlow && renderIndex === 0) {
      effect.setFloat("offset", 0);
      engine.setStencilFunction(517);
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
    }
    if (this.innerGlow && renderIndex === 1) {
      effect.setFloat("offset", 1);
      engine.setStencilFunction(514);
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
    }
    engine.restoreStencilState();
  }
  shouldRender() {
    if (super.shouldRender()) {
      return this._meshes ? true : false;
    }
    return false;
  }
  _shouldRenderMesh(mesh) {
    if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {
      return false;
    }
    if (!super.hasMesh(mesh)) {
      return false;
    }
    return true;
  }
  _canRenderMesh(mesh, material) {
    return true;
  }
  _addCustomEffectDefines(defines) {
    defines.push("#define HIGHLIGHT");
  }
  _setEmissiveTextureAndColor(mesh, subMesh, material) {
    const highlightLayerMesh = this._meshes[mesh.uniqueId];
    if (highlightLayerMesh) {
      this._emissiveTextureAndColor.color.set(highlightLayerMesh.color.r, highlightLayerMesh.color.g, highlightLayerMesh.color.b, 1);
    } else {
      this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);
    }
    if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {
      this._emissiveTextureAndColor.texture = material.emissiveTexture;
      this._emissiveTextureAndColor.color.set(1, 1, 1, 1);
    } else {
      this._emissiveTextureAndColor.texture = null;
    }
  }
  addExcludedMesh(mesh) {
    if (!this._excludedMeshes) {
      return;
    }
    const meshExcluded = this._excludedMeshes[mesh.uniqueId];
    if (!meshExcluded) {
      this._excludedMeshes[mesh.uniqueId] = {
        mesh,
        beforeBind: mesh.onBeforeBindObservable.add((mesh2) => {
          mesh2.getEngine().setStencilBuffer(false);
        }),
        afterRender: mesh.onAfterRenderObservable.add((mesh2) => {
          mesh2.getEngine().setStencilBuffer(true);
        })
      };
    }
  }
  removeExcludedMesh(mesh) {
    if (!this._excludedMeshes) {
      return;
    }
    const meshExcluded = this._excludedMeshes[mesh.uniqueId];
    if (meshExcluded) {
      if (meshExcluded.beforeBind) {
        mesh.onBeforeBindObservable.remove(meshExcluded.beforeBind);
      }
      if (meshExcluded.afterRender) {
        mesh.onAfterRenderObservable.remove(meshExcluded.afterRender);
      }
    }
    this._excludedMeshes[mesh.uniqueId] = null;
  }
  hasMesh(mesh) {
    if (!this._meshes) {
      return false;
    }
    if (!super.hasMesh(mesh)) {
      return false;
    }
    return this._meshes[mesh.uniqueId] !== void 0 && this._meshes[mesh.uniqueId] !== null;
  }
  addMesh(mesh, color, glowEmissiveOnly = false) {
    if (!this._meshes) {
      return;
    }
    const meshHighlight = this._meshes[mesh.uniqueId];
    if (meshHighlight) {
      meshHighlight.color = color;
    } else {
      this._meshes[mesh.uniqueId] = {
        mesh,
        color,
        observerHighlight: mesh.onBeforeBindObservable.add((mesh2) => {
          if (this.isEnabled) {
            if (this._excludedMeshes && this._excludedMeshes[mesh2.uniqueId]) {
              this._defaultStencilReference(mesh2);
            } else {
              mesh2.getScene().getEngine().setStencilFunctionReference(this._instanceGlowingMeshStencilReference);
            }
          }
        }),
        observerDefault: mesh.onAfterRenderObservable.add((mesh2) => {
          if (this.isEnabled) {
            this._defaultStencilReference(mesh2);
          }
        }),
        glowEmissiveOnly
      };
      mesh.onDisposeObservable.add(() => {
        this._disposeMesh(mesh);
      });
    }
    this._shouldRender = true;
  }
  removeMesh(mesh) {
    if (!this._meshes) {
      return;
    }
    const meshHighlight = this._meshes[mesh.uniqueId];
    if (meshHighlight) {
      if (meshHighlight.observerHighlight) {
        mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);
      }
      if (meshHighlight.observerDefault) {
        mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);
      }
      delete this._meshes[mesh.uniqueId];
    }
    this._shouldRender = false;
    for (const meshHighlightToCheck in this._meshes) {
      if (this._meshes[meshHighlightToCheck]) {
        this._shouldRender = true;
        break;
      }
    }
  }
  removeAllMeshes() {
    if (!this._meshes) {
      return;
    }
    for (const uniqueId in this._meshes) {
      if (Object.prototype.hasOwnProperty.call(this._meshes, uniqueId)) {
        const mesh = this._meshes[uniqueId];
        if (mesh) {
          this.removeMesh(mesh.mesh);
        }
      }
    }
  }
  _defaultStencilReference(mesh) {
    mesh.getScene().getEngine().setStencilFunctionReference(HighlightLayer.NormalMeshStencilReference);
  }
  _disposeMesh(mesh) {
    this.removeMesh(mesh);
    this.removeExcludedMesh(mesh);
  }
  dispose() {
    if (this._meshes) {
      for (const id in this._meshes) {
        const meshHighlight = this._meshes[id];
        if (meshHighlight && meshHighlight.mesh) {
          if (meshHighlight.observerHighlight) {
            meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);
          }
          if (meshHighlight.observerDefault) {
            meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);
          }
        }
      }
      this._meshes = null;
    }
    if (this._excludedMeshes) {
      for (const id in this._excludedMeshes) {
        const meshHighlight = this._excludedMeshes[id];
        if (meshHighlight) {
          if (meshHighlight.beforeBind) {
            meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.beforeBind);
          }
          if (meshHighlight.afterRender) {
            meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.afterRender);
          }
        }
      }
      this._excludedMeshes = null;
    }
    super.dispose();
  }
  getClassName() {
    return "HighlightLayer";
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.HighlightLayer";
    serializationObject.meshes = [];
    if (this._meshes) {
      for (const m in this._meshes) {
        const mesh = this._meshes[m];
        if (mesh) {
          serializationObject.meshes.push({
            glowEmissiveOnly: mesh.glowEmissiveOnly,
            color: mesh.color.asArray(),
            meshId: mesh.mesh.id
          });
        }
      }
    }
    serializationObject.excludedMeshes = [];
    if (this._excludedMeshes) {
      for (const e in this._excludedMeshes) {
        const excludedMesh = this._excludedMeshes[e];
        if (excludedMesh) {
          serializationObject.excludedMeshes.push(excludedMesh.mesh.id);
        }
      }
    }
    return serializationObject;
  }
  static Parse(parsedHightlightLayer, scene, rootUrl) {
    const hl = SerializationHelper.Parse(() => new HighlightLayer(parsedHightlightLayer.name, scene, parsedHightlightLayer.options), parsedHightlightLayer, scene, rootUrl);
    let index;
    for (index = 0; index < parsedHightlightLayer.excludedMeshes.length; index++) {
      const mesh = scene.getMeshById(parsedHightlightLayer.excludedMeshes[index]);
      if (mesh) {
        hl.addExcludedMesh(mesh);
      }
    }
    for (index = 0; index < parsedHightlightLayer.meshes.length; index++) {
      const highlightedMesh = parsedHightlightLayer.meshes[index];
      const mesh = scene.getMeshById(highlightedMesh.meshId);
      if (mesh) {
        hl.addMesh(mesh, Color3.FromArray(highlightedMesh.color), highlightedMesh.glowEmissiveOnly);
      }
    }
    return hl;
  }
};
HighlightLayer.EffectName = "HighlightLayer";
HighlightLayer.NeutralColor = new Color4(0, 0, 0, 0);
HighlightLayer.GlowingMeshStencilReference = 2;
HighlightLayer.NormalMeshStencilReference = 1;
__decorate([
  serialize()
], HighlightLayer.prototype, "innerGlow", void 0);
__decorate([
  serialize()
], HighlightLayer.prototype, "outerGlow", void 0);
__decorate([
  serialize()
], HighlightLayer.prototype, "blurHorizontalSize", null);
__decorate([
  serialize()
], HighlightLayer.prototype, "blurVerticalSize", null);
__decorate([
  serialize("options")
], HighlightLayer.prototype, "_options", void 0);
RegisterClass("BABYLON.HighlightLayer", HighlightLayer);

// node_modules/@babylonjs/core/LensFlares/lensFlare.js
var LensFlare = class {
  constructor(size, position, color, imgUrl, system) {
    this.size = size;
    this.position = position;
    this.alphaMode = 6;
    this.color = color || new Color3(1, 1, 1);
    this.texture = imgUrl ? new Texture(imgUrl, system.getScene(), true) : null;
    this._system = system;
    const engine = system.scene.getEngine();
    this._drawWrapper = new DrawWrapper(engine);
    this._drawWrapper.effect = engine.createEffect("lensFlare", [VertexBuffer.PositionKind], ["color", "viewportMatrix"], ["textureSampler"], "");
    system.lensFlares.push(this);
  }
  static AddFlare(size, position, color, imgUrl, system) {
    return new LensFlare(size, position, color, imgUrl, system);
  }
  dispose() {
    if (this.texture) {
      this.texture.dispose();
    }
    const index = this._system.lensFlares.indexOf(this);
    this._system.lensFlares.splice(index, 1);
  }
};

// node_modules/@babylonjs/core/Shaders/lensFlare.fragment.js
var name43 = "lensFlarePixelShader";
var shader43 = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform vec4 color;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec4 baseColor=texture2D(textureSampler,vUV);
gl_FragColor=baseColor*color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name43] = shader43;

// node_modules/@babylonjs/core/Shaders/lensFlare.vertex.js
var name44 = "lensFlareVertexShader";
var shader44 = `attribute vec2 position;
uniform mat4 viewportMatrix;
varying vec2 vUV;
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=position*madd+madd;
gl_Position=viewportMatrix*vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name44] = shader44;

// node_modules/@babylonjs/core/LensFlares/lensFlareSystem.js
var LensFlareSystem = class {
  constructor(name137, emitter, scene) {
    this.name = name137;
    this.lensFlares = new Array();
    this.borderLimit = 300;
    this.viewportBorder = 0;
    this.layerMask = 268435455;
    this._vertexBuffers = {};
    this._isEnabled = true;
    this._scene = scene || EngineStore.LastCreatedScene;
    LensFlareSystem._SceneComponentInitialization(this._scene);
    this._emitter = emitter;
    this.id = name137;
    scene.lensFlareSystems.push(this);
    this.meshesSelectionPredicate = (m) => scene.activeCamera && m.material && m.isVisible && m.isEnabled() && m.isBlocker && (m.layerMask & scene.activeCamera.layerMask) != 0;
    const engine = scene.getEngine();
    const vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);
    this._createIndexBuffer();
  }
  get scene() {
    return this._scene;
  }
  _createIndexBuffer() {
    const indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);
  }
  get isEnabled() {
    return this._isEnabled;
  }
  set isEnabled(value) {
    this._isEnabled = value;
  }
  getScene() {
    return this._scene;
  }
  getEmitter() {
    return this._emitter;
  }
  setEmitter(newEmitter) {
    this._emitter = newEmitter;
  }
  getEmitterPosition() {
    return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;
  }
  computeEffectivePosition(globalViewport) {
    let position = this.getEmitterPosition();
    position = Vector3.Project(position, Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);
    this._positionX = position.x;
    this._positionY = position.y;
    position = Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());
    if (this.viewportBorder > 0) {
      globalViewport.x -= this.viewportBorder;
      globalViewport.y -= this.viewportBorder;
      globalViewport.width += this.viewportBorder * 2;
      globalViewport.height += this.viewportBorder * 2;
      position.x += this.viewportBorder;
      position.y += this.viewportBorder;
      this._positionX += this.viewportBorder;
      this._positionY += this.viewportBorder;
    }
    const rhs = this._scene.useRightHandedSystem;
    const okZ = position.z > 0 && !rhs || position.z < 0 && rhs;
    if (okZ) {
      if (this._positionX > globalViewport.x && this._positionX < globalViewport.x + globalViewport.width) {
        if (this._positionY > globalViewport.y && this._positionY < globalViewport.y + globalViewport.height) {
          return true;
        }
      }
      return true;
    }
    return false;
  }
  _isVisible() {
    if (!this._isEnabled || !this._scene.activeCamera) {
      return false;
    }
    const emitterPosition = this.getEmitterPosition();
    const direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);
    const distance = direction.length();
    direction.normalize();
    const ray = new Ray(this._scene.activeCamera.globalPosition, direction);
    const pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);
    return !pickInfo || !pickInfo.hit || pickInfo.distance > distance;
  }
  render() {
    if (!this._scene.activeCamera) {
      return false;
    }
    const engine = this._scene.getEngine();
    const viewport = this._scene.activeCamera.viewport;
    const globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true));
    if (!this.computeEffectivePosition(globalViewport)) {
      return false;
    }
    if (!this._isVisible()) {
      return false;
    }
    let awayX;
    let awayY;
    if (this._positionX < this.borderLimit + globalViewport.x) {
      awayX = this.borderLimit + globalViewport.x - this._positionX;
    } else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {
      awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;
    } else {
      awayX = 0;
    }
    if (this._positionY < this.borderLimit + globalViewport.y) {
      awayY = this.borderLimit + globalViewport.y - this._positionY;
    } else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {
      awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;
    } else {
      awayY = 0;
    }
    let away = awayX > awayY ? awayX : awayY;
    away -= this.viewportBorder;
    if (away > this.borderLimit) {
      away = this.borderLimit;
    }
    let intensity = 1 - Scalar.Clamp(away / this.borderLimit, 0, 1);
    if (intensity < 0) {
      return false;
    }
    if (intensity > 1) {
      intensity = 1;
    }
    if (this.viewportBorder > 0) {
      globalViewport.x += this.viewportBorder;
      globalViewport.y += this.viewportBorder;
      globalViewport.width -= this.viewportBorder * 2;
      globalViewport.height -= this.viewportBorder * 2;
      this._positionX -= this.viewportBorder;
      this._positionY -= this.viewportBorder;
    }
    const centerX = globalViewport.x + globalViewport.width / 2;
    const centerY = globalViewport.y + globalViewport.height / 2;
    const distX = centerX - this._positionX;
    const distY = centerY - this._positionY;
    engine.setState(false);
    engine.setDepthBuffer(false);
    for (let index = 0; index < this.lensFlares.length; index++) {
      const flare = this.lensFlares[index];
      if (!flare._drawWrapper.effect.isReady() || flare.texture && !flare.texture.isReady()) {
        continue;
      }
      engine.enableEffect(flare._drawWrapper);
      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, flare._drawWrapper.effect);
      engine.setAlphaMode(flare.alphaMode);
      const x = centerX - distX * flare.position;
      const y = centerY - distY * flare.position;
      const cw = flare.size;
      const ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);
      const cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1;
      const cy = 1 - 2 * (y / (globalViewport.height + globalViewport.y * 2));
      const viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, ch / 2, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1);
      flare._drawWrapper.effect.setMatrix("viewportMatrix", viewportMatrix);
      flare._drawWrapper.effect.setTexture("textureSampler", flare.texture);
      flare._drawWrapper.effect.setFloat4("color", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1);
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
    }
    engine.setDepthBuffer(true);
    engine.setAlphaMode(0);
    return true;
  }
  rebuild() {
    var _a;
    this._createIndexBuffer();
    for (const key in this._vertexBuffers) {
      (_a = this._vertexBuffers[key]) === null || _a === void 0 ? void 0 : _a._rebuild();
    }
  }
  dispose() {
    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer) {
      this._scene.getEngine()._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    while (this.lensFlares.length) {
      this.lensFlares[0].dispose();
    }
    const index = this._scene.lensFlareSystems.indexOf(this);
    this._scene.lensFlareSystems.splice(index, 1);
  }
  static Parse(parsedLensFlareSystem, scene, rootUrl) {
    const emitter = scene.getLastEntryById(parsedLensFlareSystem.emitterId);
    const name137 = parsedLensFlareSystem.name || "lensFlareSystem#" + parsedLensFlareSystem.emitterId;
    const lensFlareSystem = new LensFlareSystem(name137, emitter, scene);
    lensFlareSystem.id = parsedLensFlareSystem.id || name137;
    lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;
    for (let index = 0; index < parsedLensFlareSystem.flares.length; index++) {
      const parsedFlare = parsedLensFlareSystem.flares[index];
      LensFlare.AddFlare(parsedFlare.size, parsedFlare.position, Color3.FromArray(parsedFlare.color), parsedFlare.textureName ? rootUrl + parsedFlare.textureName : "", lensFlareSystem);
    }
    return lensFlareSystem;
  }
  serialize() {
    const serializationObject = {};
    serializationObject.id = this.id;
    serializationObject.name = this.name;
    serializationObject.emitterId = this.getEmitter().id;
    serializationObject.borderLimit = this.borderLimit;
    serializationObject.flares = [];
    for (let index = 0; index < this.lensFlares.length; index++) {
      const flare = this.lensFlares[index];
      serializationObject.flares.push({
        size: flare.size,
        position: flare.position,
        color: flare.color.asArray(),
        textureName: Tools.GetFilename(flare.texture ? flare.texture.name : "")
      });
    }
    return serializationObject;
  }
};
LensFlareSystem._SceneComponentInitialization = (_) => {
  throw _WarnImport("LensFlareSystemSceneComponent");
};

// node_modules/@babylonjs/core/LensFlares/lensFlareSystemSceneComponent.js
AbstractScene.AddParser(SceneComponentConstants.NAME_LENSFLARESYSTEM, (parsedData, scene, container, rootUrl) => {
  if (parsedData.lensFlareSystems !== void 0 && parsedData.lensFlareSystems !== null) {
    if (!container.lensFlareSystems) {
      container.lensFlareSystems = new Array();
    }
    for (let index = 0, cache = parsedData.lensFlareSystems.length; index < cache; index++) {
      const parsedLensFlareSystem = parsedData.lensFlareSystems[index];
      const lf = LensFlareSystem.Parse(parsedLensFlareSystem, scene, rootUrl);
      container.lensFlareSystems.push(lf);
    }
  }
});
AbstractScene.prototype.getLensFlareSystemByName = function(name137) {
  for (let index = 0; index < this.lensFlareSystems.length; index++) {
    if (this.lensFlareSystems[index].name === name137) {
      return this.lensFlareSystems[index];
    }
  }
  return null;
};
AbstractScene.prototype.getLensFlareSystemById = function(id) {
  for (let index = 0; index < this.lensFlareSystems.length; index++) {
    if (this.lensFlareSystems[index].id === id) {
      return this.lensFlareSystems[index];
    }
  }
  return null;
};
AbstractScene.prototype.getLensFlareSystemByID = function(id) {
  return this.getLensFlareSystemById(id);
};
AbstractScene.prototype.removeLensFlareSystem = function(toRemove) {
  const index = this.lensFlareSystems.indexOf(toRemove);
  if (index !== -1) {
    this.lensFlareSystems.splice(index, 1);
  }
  return index;
};
AbstractScene.prototype.addLensFlareSystem = function(newLensFlareSystem) {
  this.lensFlareSystems.push(newLensFlareSystem);
};
var LensFlareSystemSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_LENSFLARESYSTEM;
    this.scene = scene;
    scene.lensFlareSystems = new Array();
  }
  register() {
    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM, this, this._draw);
  }
  rebuild() {
    for (let index = 0; index < this.scene.lensFlareSystems.length; index++) {
      this.scene.lensFlareSystems[index].rebuild();
    }
  }
  addFromContainer(container) {
    if (!container.lensFlareSystems) {
      return;
    }
    container.lensFlareSystems.forEach((o) => {
      this.scene.addLensFlareSystem(o);
    });
  }
  removeFromContainer(container, dispose) {
    if (!container.lensFlareSystems) {
      return;
    }
    container.lensFlareSystems.forEach((o) => {
      this.scene.removeLensFlareSystem(o);
      if (dispose) {
        o.dispose();
      }
    });
  }
  serialize(serializationObject) {
    serializationObject.lensFlareSystems = [];
    const lensFlareSystems = this.scene.lensFlareSystems;
    for (const lensFlareSystem of lensFlareSystems) {
      serializationObject.lensFlareSystems.push(lensFlareSystem.serialize());
    }
  }
  dispose() {
    const lensFlareSystems = this.scene.lensFlareSystems;
    while (lensFlareSystems.length) {
      lensFlareSystems[0].dispose();
    }
  }
  _draw(camera) {
    if (this.scene.lensFlaresEnabled) {
      const lensFlareSystems = this.scene.lensFlareSystems;
      Tools.StartPerformanceCounter("Lens flares", lensFlareSystems.length > 0);
      for (const lensFlareSystem of lensFlareSystems) {
        if ((camera.layerMask & lensFlareSystem.layerMask) !== 0) {
          lensFlareSystem.render();
        }
      }
      Tools.EndPerformanceCounter("Lens flares", lensFlareSystems.length > 0);
    }
  }
};
LensFlareSystem._SceneComponentInitialization = (scene) => {
  let component = scene._getComponent(SceneComponentConstants.NAME_LENSFLARESYSTEM);
  if (!component) {
    component = new LensFlareSystemSceneComponent(scene);
    scene._addComponent(component);
  }
};

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bayerDitherFunctions.js
var name45 = "bayerDitherFunctions";
var shader45 = `float bayerDither2(vec2 _P) {
return mod(2.0*_P.y+_P.x+1.0,4.0);
}
float bayerDither4(vec2 _P) {
vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5*mod(_P,4.0)); 
return 4.0*bayerDither2(P1)+bayerDither2(P2);
}
float bayerDither8(vec2 _P) {
vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5 *mod(_P,4.0)); 
vec2 P4=floor(0.25*mod(_P,8.0)); 
return 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);
}
`;
ShaderStore.IncludesShadersStore[name45] = shader45;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragmentExtraDeclaration.js
var name46 = "shadowMapFragmentExtraDeclaration";
var shader46 = `#if SM_FLOAT==0
#include<packingFunctions>
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#include<bayerDitherFunctions>
uniform float softTransparentShadowSM;
#endif
varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
uniform vec3 lightDataSM;
varying vec3 vPositionWSM;
#endif
uniform vec3 biasAndScaleSM;
uniform vec2 depthValuesSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;
ShaderStore.IncludesShadersStore[name46] = shader46;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragment.js
var name47 = "shadowMapFragment";
var shader47 = `float depthSM=vDepthMetricSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
#if SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
depthSM=(-zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
depthSM=(zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
gl_FragDepth=clamp(1.0-depthSM,0.0,1.0);
#else
gl_FragDepth=clamp(depthSM,0.0,1.0); 
#endif
#elif SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#if SM_ESM==1
depthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);
#endif
#if SM_FLOAT==1
gl_FragColor=vec4(depthSM,1.0,1.0,1.0);
#else
gl_FragColor=pack(depthSM);
#endif
return;`;
ShaderStore.IncludesShadersStore[name47] = shader47;

// node_modules/@babylonjs/core/Shaders/shadowMap.fragment.js
var name48 = "shadowMapPixelShader";
var shader48 = `#include<shadowMapFragmentExtraDeclaration>
#ifdef ALPHATEXTURE
varying vec2 vUV;
uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEXTURE
float alphaFromAlphaTexture=texture2D(diffuseSampler,vUV).a;
#ifdef ALPHATESTVALUE
if (alphaFromAlphaTexture<ALPHATESTVALUE)
discard;
#endif
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#ifdef ALPHATEXTURE
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alphaFromAlphaTexture) discard;
#else
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM) discard;
#endif
#endif
#include<shadowMapFragment>
}`;
ShaderStore.ShadersStore[name48] = shader48;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/sceneVertexDeclaration.js
var name49 = "sceneVertexDeclaration";
var shader49 = `uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
uniform mat4 view;
uniform mat4 projection;
uniform vec4 vEyePosition;
`;
ShaderStore.IncludesShadersStore[name49] = shader49;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/meshVertexDeclaration.js
var name50 = "meshVertexDeclaration";
var shader50 = `uniform mat4 world;
uniform float visibility;
`;
ShaderStore.IncludesShadersStore[name50] = shader50;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexDeclaration.js
var name51 = "shadowMapVertexDeclaration";
var shader51 = `#include<sceneVertexDeclaration>
#include<meshVertexDeclaration>
`;
ShaderStore.IncludesShadersStore[name51] = shader51;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapUboDeclaration.js
var name52 = "shadowMapUboDeclaration";
var shader52 = `layout(std140,column_major) uniform;
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
ShaderStore.IncludesShadersStore[name52] = shader52;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexExtraDeclaration.js
var name53 = "shadowMapVertexExtraDeclaration";
var shader53 = `#if SM_NORMALBIAS==1
uniform vec3 lightDataSM;
#endif
uniform vec3 biasAndScaleSM;
uniform vec2 depthValuesSM;
varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
varying vec3 vPositionWSM;
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;
ShaderStore.IncludesShadersStore[name53] = shader53;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexNormalBias.js
var name54 = "shadowMapVertexNormalBias";
var shader54 = `#if SM_NORMALBIAS==1
#if SM_DIRECTIONINLIGHTDATA==1
vec3 worldLightDirSM=normalize(-lightDataSM.xyz);
#else
vec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;
vec3 worldLightDirSM=normalize(directionToLightSM);
#endif
float ndlSM=dot(vNormalW,worldLightDirSM);
float sinNLSM=sqrt(1.0-ndlSM*ndlSM);
float normalBiasSM=biasAndScaleSM.y*sinNLSM;
worldPos.xyz-=vNormalW*normalBiasSM;
#endif
`;
ShaderStore.IncludesShadersStore[name54] = shader54;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexMetric.js
var name55 = "shadowMapVertexMetric";
var shader55 = `#if SM_USEDISTANCE==1
vPositionWSM=worldPos.xyz;
#endif
#if SM_DEPTHTEXTURE==1
#ifdef IS_NDC_HALF_ZRANGE
#define BIASFACTOR 0.5
#else
#define BIASFACTOR 1.0
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
gl_Position.z-=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#else
gl_Position.z+=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#endif
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
zSM=gl_Position.z;
gl_Position.z=0.0;
#elif SM_USEDISTANCE==0
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetricSM=(-gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
vDepthMetricSM=(gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name55] = shader55;

// node_modules/@babylonjs/core/Shaders/shadowMap.vertex.js
var name56 = "shadowMapVertexShader";
var shader56 = `attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef INSTANCES
attribute vec4 world0;
attribute vec4 world1;
attribute vec4 world2;
attribute vec4 world3;
#endif
#include<helperFunctions>
#include<__decl__shadowMapVertex>
#ifdef ALPHATEXTURE
varying vec2 vUV;
uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#include<shadowMapVertexExtraDeclaration>
#include<clipPlaneVertexDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{
vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normWorldSM=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));
vNormalW=normalize(normWorldSM*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normWorldSM=transposeMat3(inverseMat3(normWorldSM));
#endif
vec3 vNormalW=normalize(normWorldSM*normalUpdated);
#endif
#endif
#include<shadowMapVertexNormalBias>
gl_Position=viewProjection*worldPos;
#include<shadowMapVertexMetric>
#ifdef ALPHATEXTURE
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
#include<clipPlaneVertex>
}`;
ShaderStore.ShadersStore[name56] = shader56;

// node_modules/@babylonjs/core/Shaders/depthBoxBlur.fragment.js
var name57 = "depthBoxBlurPixelShader";
var shader57 = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform vec2 screenSize;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
vec4 colorDepth=vec4(0.0);
for (int x=-OFFSET; x<=OFFSET; x++)
for (int y=-OFFSET; y<=OFFSET; y++)
colorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);
gl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));
}`;
ShaderStore.ShadersStore[name57] = shader57;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragmentSoftTransparentShadow.js
var name58 = "shadowMapFragmentSoftTransparentShadow";
var shader58 = `#if SM_SOFTTRANSPARENTSHADOW==1
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alpha) discard;
#endif
`;
ShaderStore.IncludesShadersStore[name58] = shader58;

// node_modules/@babylonjs/core/Lights/Shadows/shadowGenerator.js
var ShadowGenerator = class {
  constructor(mapSize, light, usefullFloatFirst, camera) {
    this.onBeforeShadowMapRenderObservable = new Observable();
    this.onAfterShadowMapRenderObservable = new Observable();
    this.onBeforeShadowMapRenderMeshObservable = new Observable();
    this.onAfterShadowMapRenderMeshObservable = new Observable();
    this._bias = 5e-5;
    this._normalBias = 0;
    this._blurBoxOffset = 1;
    this._blurScale = 2;
    this._blurKernel = 1;
    this._useKernelBlur = false;
    this._filter = ShadowGenerator.FILTER_NONE;
    this._filteringQuality = ShadowGenerator.QUALITY_HIGH;
    this._contactHardeningLightSizeUVRatio = 0.1;
    this._darkness = 0;
    this._transparencyShadow = false;
    this.enableSoftTransparentShadow = false;
    this.useOpacityTextureForTransparentShadow = false;
    this.frustumEdgeFalloff = 0;
    this.forceBackFacesOnly = false;
    this._lightDirection = Vector3.Zero();
    this._viewMatrix = Matrix.Zero();
    this._projectionMatrix = Matrix.Zero();
    this._transformMatrix = Matrix.Zero();
    this._cachedPosition = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cachedDirection = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._currentFaceIndex = 0;
    this._currentFaceIndexCache = 0;
    this._defaultTextureMatrix = Matrix.Identity();
    this._mapSize = mapSize;
    this._light = light;
    this._scene = light.getScene();
    this._camera = camera !== null && camera !== void 0 ? camera : null;
    let shadowGenerators = light._shadowGenerators;
    if (!shadowGenerators) {
      shadowGenerators = light._shadowGenerators = /* @__PURE__ */ new Map();
    }
    shadowGenerators.set(this._camera, this);
    this.id = light.id;
    this._useUBO = this._scene.getEngine().supportsUniformBuffers;
    if (this._useUBO) {
      this._sceneUBOs = [];
      this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light "${this._light.name}")`));
    }
    ShadowGenerator._SceneComponentInitialization(this._scene);
    const caps = this._scene.getEngine().getCaps();
    if (!usefullFloatFirst) {
      if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
        this._textureType = 2;
      } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
        this._textureType = 1;
      } else {
        this._textureType = 0;
      }
    } else {
      if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
        this._textureType = 1;
      } else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
        this._textureType = 2;
      } else {
        this._textureType = 0;
      }
    }
    this._initializeGenerator();
    this._applyFilterValues();
  }
  get bias() {
    return this._bias;
  }
  set bias(bias) {
    this._bias = bias;
  }
  get normalBias() {
    return this._normalBias;
  }
  set normalBias(normalBias) {
    this._normalBias = normalBias;
  }
  get blurBoxOffset() {
    return this._blurBoxOffset;
  }
  set blurBoxOffset(value) {
    if (this._blurBoxOffset === value) {
      return;
    }
    this._blurBoxOffset = value;
    this._disposeBlurPostProcesses();
  }
  get blurScale() {
    return this._blurScale;
  }
  set blurScale(value) {
    if (this._blurScale === value) {
      return;
    }
    this._blurScale = value;
    this._disposeBlurPostProcesses();
  }
  get blurKernel() {
    return this._blurKernel;
  }
  set blurKernel(value) {
    if (this._blurKernel === value) {
      return;
    }
    this._blurKernel = value;
    this._disposeBlurPostProcesses();
  }
  get useKernelBlur() {
    return this._useKernelBlur;
  }
  set useKernelBlur(value) {
    if (this._useKernelBlur === value) {
      return;
    }
    this._useKernelBlur = value;
    this._disposeBlurPostProcesses();
  }
  get depthScale() {
    return this._depthScale !== void 0 ? this._depthScale : this._light.getDepthScale();
  }
  set depthScale(value) {
    this._depthScale = value;
  }
  _validateFilter(filter) {
    return filter;
  }
  get filter() {
    return this._filter;
  }
  set filter(value) {
    value = this._validateFilter(value);
    if (this._light.needCube()) {
      if (value === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {
        this.useExponentialShadowMap = true;
        return;
      } else if (value === ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
        this.useCloseExponentialShadowMap = true;
        return;
      } else if (value === ShadowGenerator.FILTER_PCF || value === ShadowGenerator.FILTER_PCSS) {
        this.usePoissonSampling = true;
        return;
      }
    }
    if (value === ShadowGenerator.FILTER_PCF || value === ShadowGenerator.FILTER_PCSS) {
      if (!this._scene.getEngine()._features.supportShadowSamplers) {
        this.usePoissonSampling = true;
        return;
      }
    }
    if (this._filter === value) {
      return;
    }
    this._filter = value;
    this._disposeBlurPostProcesses();
    this._applyFilterValues();
    this._light._markMeshesAsLightDirty();
  }
  get usePoissonSampling() {
    return this.filter === ShadowGenerator.FILTER_POISSONSAMPLING;
  }
  set usePoissonSampling(value) {
    const filter = this._validateFilter(ShadowGenerator.FILTER_POISSONSAMPLING);
    if (!value && this.filter !== ShadowGenerator.FILTER_POISSONSAMPLING) {
      return;
    }
    this.filter = value ? filter : ShadowGenerator.FILTER_NONE;
  }
  get useExponentialShadowMap() {
    return this.filter === ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP;
  }
  set useExponentialShadowMap(value) {
    const filter = this._validateFilter(ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP);
    if (!value && this.filter !== ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP) {
      return;
    }
    this.filter = value ? filter : ShadowGenerator.FILTER_NONE;
  }
  get useBlurExponentialShadowMap() {
    return this.filter === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP;
  }
  set useBlurExponentialShadowMap(value) {
    const filter = this._validateFilter(ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP);
    if (!value && this.filter !== ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {
      return;
    }
    this.filter = value ? filter : ShadowGenerator.FILTER_NONE;
  }
  get useCloseExponentialShadowMap() {
    return this.filter === ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP;
  }
  set useCloseExponentialShadowMap(value) {
    const filter = this._validateFilter(ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP);
    if (!value && this.filter !== ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP) {
      return;
    }
    this.filter = value ? filter : ShadowGenerator.FILTER_NONE;
  }
  get useBlurCloseExponentialShadowMap() {
    return this.filter === ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;
  }
  set useBlurCloseExponentialShadowMap(value) {
    const filter = this._validateFilter(ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);
    if (!value && this.filter !== ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
      return;
    }
    this.filter = value ? filter : ShadowGenerator.FILTER_NONE;
  }
  get usePercentageCloserFiltering() {
    return this.filter === ShadowGenerator.FILTER_PCF;
  }
  set usePercentageCloserFiltering(value) {
    const filter = this._validateFilter(ShadowGenerator.FILTER_PCF);
    if (!value && this.filter !== ShadowGenerator.FILTER_PCF) {
      return;
    }
    this.filter = value ? filter : ShadowGenerator.FILTER_NONE;
  }
  get filteringQuality() {
    return this._filteringQuality;
  }
  set filteringQuality(filteringQuality) {
    if (this._filteringQuality === filteringQuality) {
      return;
    }
    this._filteringQuality = filteringQuality;
    this._disposeBlurPostProcesses();
    this._applyFilterValues();
    this._light._markMeshesAsLightDirty();
  }
  get useContactHardeningShadow() {
    return this.filter === ShadowGenerator.FILTER_PCSS;
  }
  set useContactHardeningShadow(value) {
    const filter = this._validateFilter(ShadowGenerator.FILTER_PCSS);
    if (!value && this.filter !== ShadowGenerator.FILTER_PCSS) {
      return;
    }
    this.filter = value ? filter : ShadowGenerator.FILTER_NONE;
  }
  get contactHardeningLightSizeUVRatio() {
    return this._contactHardeningLightSizeUVRatio;
  }
  set contactHardeningLightSizeUVRatio(contactHardeningLightSizeUVRatio) {
    this._contactHardeningLightSizeUVRatio = contactHardeningLightSizeUVRatio;
  }
  get darkness() {
    return this._darkness;
  }
  set darkness(value) {
    this.setDarkness(value);
  }
  getDarkness() {
    return this._darkness;
  }
  setDarkness(darkness) {
    if (darkness >= 1) {
      this._darkness = 1;
    } else if (darkness <= 0) {
      this._darkness = 0;
    } else {
      this._darkness = darkness;
    }
    return this;
  }
  get transparencyShadow() {
    return this._transparencyShadow;
  }
  set transparencyShadow(value) {
    this.setTransparencyShadow(value);
  }
  setTransparencyShadow(transparent) {
    this._transparencyShadow = transparent;
    return this;
  }
  getShadowMap() {
    return this._shadowMap;
  }
  getShadowMapForRendering() {
    if (this._shadowMap2) {
      return this._shadowMap2;
    }
    return this._shadowMap;
  }
  getClassName() {
    return ShadowGenerator.CLASSNAME;
  }
  addShadowCaster(mesh, includeDescendants = true) {
    if (!this._shadowMap) {
      return this;
    }
    if (!this._shadowMap.renderList) {
      this._shadowMap.renderList = [];
    }
    if (this._shadowMap.renderList.indexOf(mesh) === -1) {
      this._shadowMap.renderList.push(mesh);
    }
    if (includeDescendants) {
      for (const childMesh of mesh.getChildMeshes()) {
        if (this._shadowMap.renderList.indexOf(childMesh) === -1) {
          this._shadowMap.renderList.push(childMesh);
        }
      }
    }
    return this;
  }
  removeShadowCaster(mesh, includeDescendants = true) {
    if (!this._shadowMap || !this._shadowMap.renderList) {
      return this;
    }
    const index = this._shadowMap.renderList.indexOf(mesh);
    if (index !== -1) {
      this._shadowMap.renderList.splice(index, 1);
    }
    if (includeDescendants) {
      for (const child of mesh.getChildren()) {
        this.removeShadowCaster(child);
      }
    }
    return this;
  }
  getLight() {
    return this._light;
  }
  _getCamera() {
    var _a;
    return (_a = this._camera) !== null && _a !== void 0 ? _a : this._scene.activeCamera;
  }
  get mapSize() {
    return this._mapSize;
  }
  set mapSize(size) {
    this._mapSize = size;
    this._light._markMeshesAsLightDirty();
    this.recreateShadowMap();
  }
  _initializeGenerator() {
    this._light._markMeshesAsLightDirty();
    this._initializeShadowMap();
  }
  _createTargetRenderTexture() {
    const engine = this._scene.getEngine();
    if (engine._features.supportDepthStencilTexture) {
      this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube(), void 0, false, false);
      this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true);
    } else {
      this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube());
    }
  }
  _initializeShadowMap() {
    this._createTargetRenderTexture();
    if (this._shadowMap === null) {
      return;
    }
    this._shadowMap.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._shadowMap.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._shadowMap.anisotropicFilteringLevel = 1;
    this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    this._shadowMap.renderParticles = false;
    this._shadowMap.ignoreCameraViewport = true;
    if (this._storedUniqueId) {
      this._shadowMap.uniqueId = this._storedUniqueId;
    }
    this._shadowMap.customRenderFunction = this._renderForShadowMap.bind(this);
    this._shadowMap.customIsReadyFunction = () => {
      return true;
    };
    const engine = this._scene.getEngine();
    this._shadowMap.onBeforeBindObservable.add(() => {
      var _a;
      this._currentSceneUBO = this._scene.getSceneUniformBuffer();
      (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `shadow map generation for pass id ${engine.currentRenderPassId}`, 1);
    });
    this._shadowMap.onBeforeRenderObservable.add((faceIndex) => {
      if (this._sceneUBOs) {
        this._scene.setSceneUniformBuffer(this._sceneUBOs[0]);
      }
      this._currentFaceIndex = faceIndex;
      if (this._filter === ShadowGenerator.FILTER_PCF) {
        engine.setColorWrite(false);
      }
      this.getTransformMatrix();
      this._scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);
      if (this._useUBO) {
        this._scene.getSceneUniformBuffer().unbindEffect();
        this._scene.finalizeSceneUbo();
      }
    });
    this._shadowMap.onAfterUnbindObservable.add(() => {
      var _a, _b;
      if (this._sceneUBOs) {
        this._scene.setSceneUniformBuffer(this._currentSceneUBO);
      }
      this._scene.updateTransformMatrix();
      if (this._filter === ShadowGenerator.FILTER_PCF) {
        engine.setColorWrite(true);
      }
      if (!this.useBlurExponentialShadowMap && !this.useBlurCloseExponentialShadowMap) {
        (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);
        return;
      }
      const shadowMap = this.getShadowMapForRendering();
      if (shadowMap) {
        this._scene.postProcessManager.directRender(this._blurPostProcesses, shadowMap.renderTarget, true);
        engine.unBindFramebuffer(shadowMap.renderTarget, true);
        (_b = engine._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(engine, 1);
      }
    });
    const clearZero = new Color4(0, 0, 0, 0);
    const clearOne = new Color4(1, 1, 1, 1);
    this._shadowMap.onClearObservable.add((engine2) => {
      if (this._filter === ShadowGenerator.FILTER_PCF) {
        engine2.clear(clearOne, false, true, false);
      } else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {
        engine2.clear(clearZero, true, true, false);
      } else {
        engine2.clear(clearOne, true, true, false);
      }
    });
    this._shadowMap.onResizeObservable.add((rtt) => {
      this._storedUniqueId = this._shadowMap.uniqueId;
      this._mapSize = rtt.getRenderSize();
      this._light._markMeshesAsLightDirty();
      this.recreateShadowMap();
    });
    for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {
      this._shadowMap.setRenderingAutoClearDepthStencil(i, false);
    }
  }
  _initializeBlurRTTAndPostProcesses() {
    const engine = this._scene.getEngine();
    const targetSize = this._mapSize / this.blurScale;
    if (!this.useKernelBlur || this.blurScale !== 1) {
      this._shadowMap2 = new RenderTargetTexture(this._light.name + "_shadowMap2", targetSize, this._scene, false, true, this._textureType, void 0, void 0, false);
      this._shadowMap2.wrapU = Texture.CLAMP_ADDRESSMODE;
      this._shadowMap2.wrapV = Texture.CLAMP_ADDRESSMODE;
      this._shadowMap2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    }
    if (this.useKernelBlur) {
      this._kernelBlurXPostprocess = new BlurPostProcess(this._light.name + "KernelBlurX", new Vector2(1, 0), this.blurKernel, 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
      this._kernelBlurXPostprocess.width = targetSize;
      this._kernelBlurXPostprocess.height = targetSize;
      this._kernelBlurXPostprocess.externalTextureSamplerBinding = true;
      this._kernelBlurXPostprocess.onApplyObservable.add((effect) => {
        effect.setTexture("textureSampler", this._shadowMap);
      });
      this._kernelBlurYPostprocess = new BlurPostProcess(this._light.name + "KernelBlurY", new Vector2(0, 1), this.blurKernel, 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
      this._kernelBlurXPostprocess.autoClear = false;
      this._kernelBlurYPostprocess.autoClear = false;
      if (this._textureType === 0) {
        this._kernelBlurXPostprocess.packedFloat = true;
        this._kernelBlurYPostprocess.packedFloat = true;
      }
      this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess];
    } else {
      this._boxBlurPostprocess = new PostProcess(this._light.name + "DepthBoxBlur", "depthBoxBlur", ["screenSize", "boxOffset"], [], 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, "#define OFFSET " + this._blurBoxOffset, this._textureType);
      this._boxBlurPostprocess.externalTextureSamplerBinding = true;
      this._boxBlurPostprocess.onApplyObservable.add((effect) => {
        effect.setFloat2("screenSize", targetSize, targetSize);
        effect.setTexture("textureSampler", this._shadowMap);
      });
      this._boxBlurPostprocess.autoClear = false;
      this._blurPostProcesses = [this._boxBlurPostprocess];
    }
  }
  _renderForShadowMap(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
    let index;
    if (depthOnlySubMeshes.length) {
      for (index = 0; index < depthOnlySubMeshes.length; index++) {
        this._renderSubMeshForShadowMap(depthOnlySubMeshes.data[index]);
      }
    }
    for (index = 0; index < opaqueSubMeshes.length; index++) {
      this._renderSubMeshForShadowMap(opaqueSubMeshes.data[index]);
    }
    for (index = 0; index < alphaTestSubMeshes.length; index++) {
      this._renderSubMeshForShadowMap(alphaTestSubMeshes.data[index]);
    }
    if (this._transparencyShadow) {
      for (index = 0; index < transparentSubMeshes.length; index++) {
        this._renderSubMeshForShadowMap(transparentSubMeshes.data[index], true);
      }
    } else {
      for (index = 0; index < transparentSubMeshes.length; index++) {
        transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;
      }
    }
  }
  _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect, mesh) {
    effect.setMatrix("viewProjection", this.getTransformMatrix());
  }
  _renderSubMeshForShadowMap(subMesh, isTransparent = false) {
    var _a, _b;
    const renderingMesh = subMesh.getRenderingMesh();
    const effectiveMesh = subMesh.getEffectiveMesh();
    const scene = this._scene;
    const engine = scene.getEngine();
    const material = subMesh.getMaterial();
    effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
    if (!material || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {
      return;
    }
    const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;
    let sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;
    if (detNeg) {
      sideOrientation = sideOrientation === 0 ? 1 : 0;
    }
    const reverseSideOrientation = sideOrientation === 0;
    engine.setState(material.backFaceCulling, void 0, void 0, reverseSideOrientation, material.cullBackFaces);
    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
    if (batch.mustReturn) {
      return;
    }
    const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
    if (this.customAllowRendering && !this.customAllowRendering(subMesh)) {
      return;
    }
    if (this.isReady(subMesh, hardwareInstancedRendering, isTransparent)) {
      subMesh._renderId = scene.getRenderId();
      const shadowDepthWrapper = material.shadowDepthWrapper;
      const drawWrapper = (_b = shadowDepthWrapper === null || shadowDepthWrapper === void 0 ? void 0 : shadowDepthWrapper.getEffect(subMesh, this, engine.currentRenderPassId)) !== null && _b !== void 0 ? _b : subMesh._getDrawWrapper();
      const effect = DrawWrapper.GetEffect(drawWrapper);
      engine.enableEffect(drawWrapper);
      if (!hardwareInstancedRendering) {
        renderingMesh._bind(subMesh, effect, material.fillMode);
      }
      this.getTransformMatrix();
      effect.setFloat3("biasAndScaleSM", this.bias, this.normalBias, this.depthScale);
      if (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
        effect.setVector3("lightDataSM", this._cachedDirection);
      } else {
        effect.setVector3("lightDataSM", this._cachedPosition);
      }
      const camera = this._getCamera();
      if (camera) {
        effect.setFloat2("depthValuesSM", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera));
      }
      if (isTransparent && this.enableSoftTransparentShadow) {
        effect.setFloat("softTransparentShadowSM", effectiveMesh.visibility * material.alpha);
      }
      if (shadowDepthWrapper) {
        subMesh._setMainDrawWrapperOverride(drawWrapper);
        if (shadowDepthWrapper.standalone) {
          shadowDepthWrapper.baseMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
        } else {
          material.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
        }
        subMesh._setMainDrawWrapperOverride(null);
      } else {
        if (this.useOpacityTextureForTransparentShadow) {
          const opacityTexture = material.opacityTexture;
          if (opacityTexture) {
            effect.setTexture("diffuseSampler", opacityTexture);
            effect.setMatrix("diffuseMatrix", opacityTexture.getTextureMatrix() || this._defaultTextureMatrix);
          }
        } else if (material.needAlphaTesting() || material.needAlphaBlending()) {
          const alphaTexture = material.getAlphaTestTexture();
          if (alphaTexture) {
            effect.setTexture("diffuseSampler", alphaTexture);
            effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix() || this._defaultTextureMatrix);
          }
        }
        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
          const skeleton = renderingMesh.skeleton;
          if (skeleton.isUsingTextureForMatrices) {
            const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);
            if (!boneTexture) {
              return;
            }
            effect.setTexture("boneSampler", boneTexture);
            effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
          } else {
            effect.setMatrices("mBones", skeleton.getTransformMatrices(renderingMesh));
          }
        }
        MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);
        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
          renderingMesh.morphTargetManager._bind(effect);
        }
        bindClipPlane(effect, material, scene);
      }
      if (!this._useUBO && !shadowDepthWrapper) {
        this._bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect, effectiveMesh);
      }
      MaterialHelper.BindSceneUniformBuffer(effect, this._scene.getSceneUniformBuffer());
      this._scene.getSceneUniformBuffer().bindUniformBuffer();
      const world = effectiveMesh.getWorldMatrix();
      if (hardwareInstancedRendering) {
        effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
        effectiveMesh.transferToEffect(world);
      }
      if (this.forceBackFacesOnly) {
        engine.setState(true, 0, false, true, material.cullBackFaces);
      }
      this.onBeforeShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
      this.onBeforeShadowMapRenderObservable.notifyObservers(effect);
      renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, worldOverride) => {
        if (effectiveMesh !== renderingMesh && !isInstance) {
          renderingMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
          renderingMesh.transferToEffect(worldOverride);
        } else {
          effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
          effectiveMesh.transferToEffect(isInstance ? worldOverride : world);
        }
      });
      if (this.forceBackFacesOnly) {
        engine.setState(true, 0, false, false, material.cullBackFaces);
      }
      this.onAfterShadowMapRenderObservable.notifyObservers(effect);
      this.onAfterShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
    } else {
      if (this._shadowMap) {
        this._shadowMap.resetRefreshCounter();
      }
    }
  }
  _applyFilterValues() {
    if (!this._shadowMap) {
      return;
    }
    if (this.filter === ShadowGenerator.FILTER_NONE || this.filter === ShadowGenerator.FILTER_PCSS) {
      this._shadowMap.updateSamplingMode(Texture.NEAREST_SAMPLINGMODE);
    } else {
      this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    }
  }
  forceCompilation(onCompiled, options) {
    const localOptions = {
      useInstances: false,
      ...options
    };
    const shadowMap = this.getShadowMap();
    if (!shadowMap) {
      if (onCompiled) {
        onCompiled(this);
      }
      return;
    }
    const renderList = shadowMap.renderList;
    if (!renderList) {
      if (onCompiled) {
        onCompiled(this);
      }
      return;
    }
    const subMeshes = new Array();
    for (const mesh of renderList) {
      subMeshes.push(...mesh.subMeshes);
    }
    if (subMeshes.length === 0) {
      if (onCompiled) {
        onCompiled(this);
      }
      return;
    }
    let currentIndex = 0;
    const checkReady = () => {
      var _a, _b;
      if (!this._scene || !this._scene.getEngine()) {
        return;
      }
      while (this.isReady(subMeshes[currentIndex], localOptions.useInstances, (_b = (_a = subMeshes[currentIndex].getMaterial()) === null || _a === void 0 ? void 0 : _a.needAlphaBlendingForMesh(subMeshes[currentIndex].getMesh())) !== null && _b !== void 0 ? _b : false)) {
        currentIndex++;
        if (currentIndex >= subMeshes.length) {
          if (onCompiled) {
            onCompiled(this);
          }
          return;
        }
      }
      setTimeout(checkReady, 16);
    };
    checkReady();
  }
  forceCompilationAsync(options) {
    return new Promise((resolve) => {
      this.forceCompilation(() => {
        resolve();
      }, options);
    });
  }
  _isReadyCustomDefines(defines, subMesh, useInstances) {
  }
  _prepareShadowDefines(subMesh, useInstances, defines, isTransparent) {
    defines.push("#define SM_LIGHTTYPE_" + this._light.getClassName().toUpperCase());
    defines.push("#define SM_FLOAT " + (this._textureType !== 0 ? "1" : "0"));
    defines.push("#define SM_ESM " + (this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? "1" : "0"));
    defines.push("#define SM_DEPTHTEXTURE " + (this.usePercentageCloserFiltering || this.useContactHardeningShadow ? "1" : "0"));
    const mesh = subMesh.getMesh();
    defines.push("#define SM_NORMALBIAS " + (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind) ? "1" : "0"));
    defines.push("#define SM_DIRECTIONINLIGHTDATA " + (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT ? "1" : "0"));
    defines.push("#define SM_USEDISTANCE " + (this._light.needCube() ? "1" : "0"));
    defines.push("#define SM_SOFTTRANSPARENTSHADOW " + (this.enableSoftTransparentShadow && isTransparent ? "1" : "0"));
    this._isReadyCustomDefines(defines, subMesh, useInstances);
    return defines;
  }
  isReady(subMesh, useInstances, isTransparent) {
    var _a;
    const material = subMesh.getMaterial(), shadowDepthWrapper = material === null || material === void 0 ? void 0 : material.shadowDepthWrapper;
    if (!material) {
      return false;
    }
    const defines = [];
    this._prepareShadowDefines(subMesh, useInstances, defines, isTransparent);
    if (shadowDepthWrapper) {
      if (!shadowDepthWrapper.isReadyForSubMesh(subMesh, defines, this, useInstances, this._scene.getEngine().currentRenderPassId)) {
        return false;
      }
    } else {
      const subMeshEffect = subMesh._getDrawWrapper(void 0, true);
      let effect = subMeshEffect.effect;
      let cachedDefines = subMeshEffect.defines;
      const attribs = [VertexBuffer.PositionKind];
      const mesh = subMesh.getMesh();
      if (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
        attribs.push(VertexBuffer.NormalKind);
        defines.push("#define NORMAL");
        if (mesh.nonUniformScaling) {
          defines.push("#define NONUNIFORMSCALING");
        }
      }
      const needAlphaTesting = material === null || material === void 0 ? void 0 : material.needAlphaTesting();
      const needAlphaBlending = material === null || material === void 0 ? void 0 : material.needAlphaBlending();
      if (material && (needAlphaTesting || needAlphaBlending)) {
        let alphaTexture = null;
        if (this.useOpacityTextureForTransparentShadow) {
          alphaTexture = material.opacityTexture;
        } else {
          alphaTexture = material.getAlphaTestTexture();
        }
        if (alphaTexture) {
          if (!alphaTexture.isReady()) {
            return false;
          }
          const alphaCutOff = (_a = material.alphaCutOff) !== null && _a !== void 0 ? _a : ShadowGenerator.DEFAULT_ALPHA_CUTOFF;
          defines.push("#define ALPHATEXTURE");
          if (needAlphaTesting) {
            defines.push(`#define ALPHATESTVALUE ${alphaCutOff}${alphaCutOff % 1 === 0 ? "." : ""}`);
          }
          if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
            attribs.push(VertexBuffer.UVKind);
            defines.push("#define UV1");
          }
          if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
            if (alphaTexture.coordinatesIndex === 1) {
              attribs.push(VertexBuffer.UV2Kind);
              defines.push("#define UV2");
            }
          }
        }
      }
      const fallbacks = new EffectFallbacks();
      if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
        attribs.push(VertexBuffer.MatricesIndicesKind);
        attribs.push(VertexBuffer.MatricesWeightsKind);
        if (mesh.numBoneInfluencers > 4) {
          attribs.push(VertexBuffer.MatricesIndicesExtraKind);
          attribs.push(VertexBuffer.MatricesWeightsExtraKind);
        }
        const skeleton = mesh.skeleton;
        defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
        if (mesh.numBoneInfluencers > 0) {
          fallbacks.addCPUSkinningFallback(0, mesh);
        }
        if (skeleton.isUsingTextureForMatrices) {
          defines.push("#define BONETEXTURE");
        } else {
          defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
        }
      } else {
        defines.push("#define NUM_BONE_INFLUENCERS 0");
      }
      const manager = mesh.morphTargetManager;
      let morphInfluencers = 0;
      if (manager) {
        if (manager.numInfluencers > 0) {
          defines.push("#define MORPHTARGETS");
          morphInfluencers = manager.numInfluencers;
          defines.push("#define NUM_MORPH_INFLUENCERS " + morphInfluencers);
          if (manager.isUsingTextureForTargets) {
            defines.push("#define MORPHTARGETS_TEXTURE");
          }
          MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);
        }
      }
      prepareDefinesForClipPlanes(material, this._scene, defines);
      if (useInstances) {
        defines.push("#define INSTANCES");
        MaterialHelper.PushAttributesForInstances(attribs);
        if (subMesh.getRenderingMesh().hasThinInstances) {
          defines.push("#define THIN_INSTANCES");
        }
      }
      if (this.customShaderOptions) {
        if (this.customShaderOptions.defines) {
          for (const define of this.customShaderOptions.defines) {
            if (defines.indexOf(define) === -1) {
              defines.push(define);
            }
          }
        }
      }
      const join = defines.join("\n");
      if (cachedDefines !== join) {
        cachedDefines = join;
        let shaderName = "shadowMap";
        const uniforms = [
          "world",
          "mBones",
          "viewProjection",
          "diffuseMatrix",
          "lightDataSM",
          "depthValuesSM",
          "biasAndScaleSM",
          "morphTargetInfluences",
          "boneTextureWidth",
          "softTransparentShadowSM",
          "morphTargetTextureInfo",
          "morphTargetTextureIndices"
        ];
        const samplers = ["diffuseSampler", "boneSampler", "morphTargets"];
        const uniformBuffers = ["Scene", "Mesh"];
        addClipPlaneUniforms(uniforms);
        if (this.customShaderOptions) {
          shaderName = this.customShaderOptions.shaderName;
          if (this.customShaderOptions.attributes) {
            for (const attrib of this.customShaderOptions.attributes) {
              if (attribs.indexOf(attrib) === -1) {
                attribs.push(attrib);
              }
            }
          }
          if (this.customShaderOptions.uniforms) {
            for (const uniform of this.customShaderOptions.uniforms) {
              if (uniforms.indexOf(uniform) === -1) {
                uniforms.push(uniform);
              }
            }
          }
          if (this.customShaderOptions.samplers) {
            for (const sampler of this.customShaderOptions.samplers) {
              if (samplers.indexOf(sampler) === -1) {
                samplers.push(sampler);
              }
            }
          }
        }
        const engine = this._scene.getEngine();
        effect = engine.createEffect(shaderName, {
          attributes: attribs,
          uniformsNames: uniforms,
          uniformBuffersNames: uniformBuffers,
          samplers,
          defines: join,
          fallbacks,
          onCompiled: null,
          onError: null,
          indexParameters: { maxSimultaneousMorphTargets: morphInfluencers }
        }, engine);
        subMeshEffect.setEffect(effect, cachedDefines);
      }
      if (!effect.isReady()) {
        return false;
      }
    }
    if (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
      if (!this._blurPostProcesses || !this._blurPostProcesses.length) {
        this._initializeBlurRTTAndPostProcesses();
      }
    }
    if (this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady()) {
      return false;
    }
    if (this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady()) {
      return false;
    }
    if (this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady()) {
      return false;
    }
    return true;
  }
  prepareDefines(defines, lightIndex) {
    const scene = this._scene;
    const light = this._light;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    defines["SHADOW" + lightIndex] = true;
    if (this.useContactHardeningShadow) {
      defines["SHADOWPCSS" + lightIndex] = true;
      if (this._filteringQuality === ShadowGenerator.QUALITY_LOW) {
        defines["SHADOWLOWQUALITY" + lightIndex] = true;
      } else if (this._filteringQuality === ShadowGenerator.QUALITY_MEDIUM) {
        defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
      }
    } else if (this.usePercentageCloserFiltering) {
      defines["SHADOWPCF" + lightIndex] = true;
      if (this._filteringQuality === ShadowGenerator.QUALITY_LOW) {
        defines["SHADOWLOWQUALITY" + lightIndex] = true;
      } else if (this._filteringQuality === ShadowGenerator.QUALITY_MEDIUM) {
        defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
      }
    } else if (this.usePoissonSampling) {
      defines["SHADOWPOISSON" + lightIndex] = true;
    } else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {
      defines["SHADOWESM" + lightIndex] = true;
    } else if (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
      defines["SHADOWCLOSEESM" + lightIndex] = true;
    }
    if (light.needCube()) {
      defines["SHADOWCUBE" + lightIndex] = true;
    }
  }
  bindShadowLight(lightIndex, effect) {
    const light = this._light;
    const scene = this._scene;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    const shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return;
    }
    if (!light.needCube()) {
      effect.setMatrix("lightMatrix" + lightIndex, this.getTransformMatrix());
    }
    if (this._filter === ShadowGenerator.FILTER_PCF) {
      effect.setDepthStencilTexture("shadowSampler" + lightIndex, this.getShadowMapForRendering());
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), shadowMap.getSize().width, 1 / shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
    } else if (this._filter === ShadowGenerator.FILTER_PCSS) {
      effect.setDepthStencilTexture("shadowSampler" + lightIndex, this.getShadowMapForRendering());
      effect.setTexture("depthSampler" + lightIndex, this.getShadowMapForRendering());
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / shadowMap.getSize().width, this._contactHardeningLightSizeUVRatio * shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
    } else {
      effect.setTexture("shadowSampler" + lightIndex, this.getShadowMapForRendering());
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), this.blurScale / shadowMap.getSize().width, this.depthScale, this.frustumEdgeFalloff, lightIndex);
    }
    light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
  }
  getTransformMatrix() {
    const scene = this._scene;
    if (this._currentRenderId === scene.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) {
      return this._transformMatrix;
    }
    this._currentRenderId = scene.getRenderId();
    this._currentFaceIndexCache = this._currentFaceIndex;
    let lightPosition = this._light.position;
    if (this._light.computeTransformedInformation()) {
      lightPosition = this._light.transformedPosition;
    }
    Vector3.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection);
    if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1) {
      this._lightDirection.z = 1e-13;
    }
    if (this._light.needProjectionMatrixCompute() || !this._cachedPosition || !this._cachedDirection || !lightPosition.equals(this._cachedPosition) || !this._lightDirection.equals(this._cachedDirection)) {
      this._cachedPosition.copyFrom(lightPosition);
      this._cachedDirection.copyFrom(this._lightDirection);
      Matrix.LookAtLHToRef(lightPosition, lightPosition.add(this._lightDirection), Vector3.Up(), this._viewMatrix);
      const shadowMap = this.getShadowMap();
      if (shadowMap) {
        const renderList = shadowMap.renderList;
        if (renderList) {
          this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, renderList);
        }
      }
      this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    }
    return this._transformMatrix;
  }
  recreateShadowMap() {
    const shadowMap = this._shadowMap;
    if (!shadowMap) {
      return;
    }
    const renderList = shadowMap.renderList;
    this._disposeRTTandPostProcesses();
    this._initializeGenerator();
    this.filter = this._filter;
    this._applyFilterValues();
    if (renderList) {
      if (!this._shadowMap.renderList) {
        this._shadowMap.renderList = [];
      }
      for (const mesh of renderList) {
        this._shadowMap.renderList.push(mesh);
      }
    } else {
      this._shadowMap.renderList = null;
    }
  }
  _disposeBlurPostProcesses() {
    if (this._shadowMap2) {
      this._shadowMap2.dispose();
      this._shadowMap2 = null;
    }
    if (this._boxBlurPostprocess) {
      this._boxBlurPostprocess.dispose();
      this._boxBlurPostprocess = null;
    }
    if (this._kernelBlurXPostprocess) {
      this._kernelBlurXPostprocess.dispose();
      this._kernelBlurXPostprocess = null;
    }
    if (this._kernelBlurYPostprocess) {
      this._kernelBlurYPostprocess.dispose();
      this._kernelBlurYPostprocess = null;
    }
    this._blurPostProcesses = [];
  }
  _disposeRTTandPostProcesses() {
    if (this._shadowMap) {
      this._shadowMap.dispose();
      this._shadowMap = null;
    }
    this._disposeBlurPostProcesses();
  }
  _disposeSceneUBOs() {
    if (this._sceneUBOs) {
      for (const ubo of this._sceneUBOs) {
        ubo.dispose();
      }
      this._sceneUBOs = [];
    }
  }
  dispose() {
    this._disposeRTTandPostProcesses();
    this._disposeSceneUBOs();
    if (this._light) {
      if (this._light._shadowGenerators) {
        const iterator = this._light._shadowGenerators.entries();
        for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {
          const [camera, shadowGenerator] = entry.value;
          if (shadowGenerator === this) {
            this._light._shadowGenerators.delete(camera);
          }
        }
        if (this._light._shadowGenerators.size === 0) {
          this._light._shadowGenerators = null;
        }
      }
      this._light._markMeshesAsLightDirty();
    }
    this.onBeforeShadowMapRenderMeshObservable.clear();
    this.onBeforeShadowMapRenderObservable.clear();
    this.onAfterShadowMapRenderMeshObservable.clear();
    this.onAfterShadowMapRenderObservable.clear();
  }
  serialize() {
    var _a;
    const serializationObject = {};
    const shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return serializationObject;
    }
    serializationObject.className = this.getClassName();
    serializationObject.lightId = this._light.id;
    serializationObject.cameraId = (_a = this._camera) === null || _a === void 0 ? void 0 : _a.id;
    serializationObject.id = this.id;
    serializationObject.mapSize = shadowMap.getRenderSize();
    serializationObject.forceBackFacesOnly = this.forceBackFacesOnly;
    serializationObject.darkness = this.getDarkness();
    serializationObject.transparencyShadow = this._transparencyShadow;
    serializationObject.frustumEdgeFalloff = this.frustumEdgeFalloff;
    serializationObject.bias = this.bias;
    serializationObject.normalBias = this.normalBias;
    serializationObject.usePercentageCloserFiltering = this.usePercentageCloserFiltering;
    serializationObject.useContactHardeningShadow = this.useContactHardeningShadow;
    serializationObject.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio;
    serializationObject.filteringQuality = this.filteringQuality;
    serializationObject.useExponentialShadowMap = this.useExponentialShadowMap;
    serializationObject.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap;
    serializationObject.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
    serializationObject.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
    serializationObject.usePoissonSampling = this.usePoissonSampling;
    serializationObject.depthScale = this.depthScale;
    serializationObject.blurBoxOffset = this.blurBoxOffset;
    serializationObject.blurKernel = this.blurKernel;
    serializationObject.blurScale = this.blurScale;
    serializationObject.useKernelBlur = this.useKernelBlur;
    serializationObject.renderList = [];
    if (shadowMap.renderList) {
      for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
        const mesh = shadowMap.renderList[meshIndex];
        serializationObject.renderList.push(mesh.id);
      }
    }
    return serializationObject;
  }
  static Parse(parsedShadowGenerator, scene, constr) {
    const light = scene.getLightById(parsedShadowGenerator.lightId);
    const camera = parsedShadowGenerator.cameraId !== void 0 ? scene.getCameraById(parsedShadowGenerator.cameraId) : null;
    const shadowGenerator = constr ? constr(parsedShadowGenerator.mapSize, light, camera) : new ShadowGenerator(parsedShadowGenerator.mapSize, light, void 0, camera);
    const shadowMap = shadowGenerator.getShadowMap();
    for (let meshIndex = 0; meshIndex < parsedShadowGenerator.renderList.length; meshIndex++) {
      const meshes = scene.getMeshesById(parsedShadowGenerator.renderList[meshIndex]);
      meshes.forEach(function(mesh) {
        if (!shadowMap) {
          return;
        }
        if (!shadowMap.renderList) {
          shadowMap.renderList = [];
        }
        shadowMap.renderList.push(mesh);
      });
    }
    if (parsedShadowGenerator.id !== void 0) {
      shadowGenerator.id = parsedShadowGenerator.id;
    }
    shadowGenerator.forceBackFacesOnly = !!parsedShadowGenerator.forceBackFacesOnly;
    if (parsedShadowGenerator.darkness !== void 0) {
      shadowGenerator.setDarkness(parsedShadowGenerator.darkness);
    }
    if (parsedShadowGenerator.transparencyShadow) {
      shadowGenerator.setTransparencyShadow(true);
    }
    if (parsedShadowGenerator.frustumEdgeFalloff !== void 0) {
      shadowGenerator.frustumEdgeFalloff = parsedShadowGenerator.frustumEdgeFalloff;
    }
    if (parsedShadowGenerator.bias !== void 0) {
      shadowGenerator.bias = parsedShadowGenerator.bias;
    }
    if (parsedShadowGenerator.normalBias !== void 0) {
      shadowGenerator.normalBias = parsedShadowGenerator.normalBias;
    }
    if (parsedShadowGenerator.usePercentageCloserFiltering) {
      shadowGenerator.usePercentageCloserFiltering = true;
    } else if (parsedShadowGenerator.useContactHardeningShadow) {
      shadowGenerator.useContactHardeningShadow = true;
    } else if (parsedShadowGenerator.usePoissonSampling) {
      shadowGenerator.usePoissonSampling = true;
    } else if (parsedShadowGenerator.useExponentialShadowMap) {
      shadowGenerator.useExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useBlurExponentialShadowMap) {
      shadowGenerator.useBlurExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useCloseExponentialShadowMap) {
      shadowGenerator.useCloseExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useBlurCloseExponentialShadowMap) {
      shadowGenerator.useBlurCloseExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useVarianceShadowMap) {
      shadowGenerator.useExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useBlurVarianceShadowMap) {
      shadowGenerator.useBlurExponentialShadowMap = true;
    }
    if (parsedShadowGenerator.contactHardeningLightSizeUVRatio !== void 0) {
      shadowGenerator.contactHardeningLightSizeUVRatio = parsedShadowGenerator.contactHardeningLightSizeUVRatio;
    }
    if (parsedShadowGenerator.filteringQuality !== void 0) {
      shadowGenerator.filteringQuality = parsedShadowGenerator.filteringQuality;
    }
    if (parsedShadowGenerator.depthScale) {
      shadowGenerator.depthScale = parsedShadowGenerator.depthScale;
    }
    if (parsedShadowGenerator.blurScale) {
      shadowGenerator.blurScale = parsedShadowGenerator.blurScale;
    }
    if (parsedShadowGenerator.blurBoxOffset) {
      shadowGenerator.blurBoxOffset = parsedShadowGenerator.blurBoxOffset;
    }
    if (parsedShadowGenerator.useKernelBlur) {
      shadowGenerator.useKernelBlur = parsedShadowGenerator.useKernelBlur;
    }
    if (parsedShadowGenerator.blurKernel) {
      shadowGenerator.blurKernel = parsedShadowGenerator.blurKernel;
    }
    return shadowGenerator;
  }
};
ShadowGenerator.CLASSNAME = "ShadowGenerator";
ShadowGenerator.FILTER_NONE = 0;
ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP = 1;
ShadowGenerator.FILTER_POISSONSAMPLING = 2;
ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP = 3;
ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;
ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;
ShadowGenerator.FILTER_PCF = 6;
ShadowGenerator.FILTER_PCSS = 7;
ShadowGenerator.QUALITY_HIGH = 0;
ShadowGenerator.QUALITY_MEDIUM = 1;
ShadowGenerator.QUALITY_LOW = 2;
ShadowGenerator.DEFAULT_ALPHA_CUTOFF = 0.5;
ShadowGenerator._SceneComponentInitialization = (_) => {
  throw _WarnImport("ShadowGeneratorSceneComponent");
};

// node_modules/@babylonjs/core/Shaders/depth.fragment.js
var name59 = "depthPixelShader";
var shader59 = `#ifdef ALPHATEST
varying vec2 vUV;
uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
varying float vDepthMetric;
#ifdef PACKED
#include<packingFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEST
if (texture2D(diffuseSampler,vUV).a<0.4)
discard;
#endif
#ifdef NONLINEARDEPTH
#ifdef PACKED
gl_FragColor=pack(gl_FragCoord.z);
#else
gl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);
#endif
#else
#ifdef PACKED
gl_FragColor=pack(vDepthMetric);
#else
gl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);
#endif
#endif
}`;
ShaderStore.ShadersStore[name59] = shader59;

// node_modules/@babylonjs/core/Shaders/depth.vertex.js
var name60 = "depthVertexShader";
var shader60 = `attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;
uniform vec2 depthValues;
#if defined(ALPHATEST) || defined(NEED_UV)
varying vec2 vUV;
uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
varying float vDepthMetric;
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{
vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#include<clipPlaneVertex>
gl_Position=viewProjection*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));
#else
vDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));
#endif
#if defined(ALPHATEST) || defined(BASIC_RENDER)
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
}
`;
ShaderStore.ShadersStore[name60] = shader60;

// node_modules/@babylonjs/core/Rendering/depthRenderer.js
var DepthRenderer = class {
  constructor(scene, type = 1, camera = null, storeNonLinearDepth = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE) {
    this.enabled = true;
    this.forceDepthWriteTransparentMeshes = false;
    this.useOnlyInActiveCamera = false;
    this._scene = scene;
    this._storeNonLinearDepth = storeNonLinearDepth;
    this.isPacked = type === 0;
    if (this.isPacked) {
      this._clearColor = new Color4(1, 1, 1, 1);
    } else {
      this._clearColor = new Color4(1, 0, 0, 1);
    }
    DepthRenderer._SceneComponentInitialization(this._scene);
    const engine = scene.getEngine();
    this._camera = camera;
    if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {
      if (type === 1 && !engine._caps.textureFloatLinearFiltering) {
        samplingMode = Texture.NEAREST_SAMPLINGMODE;
      }
      if (type === 2 && !engine._caps.textureHalfFloatLinearFiltering) {
        samplingMode = Texture.NEAREST_SAMPLINGMODE;
      }
    }
    const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? 5 : 6;
    this._depthMap = new RenderTargetTexture("DepthRenderer", { width: engine.getRenderWidth(), height: engine.getRenderHeight() }, this._scene, false, true, type, false, samplingMode, void 0, void 0, void 0, format);
    this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._depthMap.refreshRate = 1;
    this._depthMap.renderParticles = false;
    this._depthMap.renderList = null;
    this._depthMap.activeCamera = this._camera;
    this._depthMap.ignoreCameraViewport = true;
    this._depthMap.useCameraPostProcesses = false;
    this._depthMap.onClearObservable.add((engine2) => {
      engine2.clear(this._clearColor, true, true, true);
    });
    this._depthMap.onBeforeBindObservable.add(() => {
      var _a;
      (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, "depth renderer", 1);
    });
    this._depthMap.onAfterUnbindObservable.add(() => {
      var _a;
      (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);
    });
    this._depthMap.customIsReadyFunction = (mesh, refreshRate, preWarm) => {
      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {
        for (let i = 0; i < mesh.subMeshes.length; ++i) {
          const subMesh = mesh.subMeshes[i];
          const renderingMesh = subMesh.getRenderingMesh();
          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
          const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
          if (!this.isReady(subMesh, hardwareInstancedRendering)) {
            return false;
          }
        }
      }
      return true;
    };
    const renderSubMesh = (subMesh) => {
      var _a, _b;
      const renderingMesh = subMesh.getRenderingMesh();
      const effectiveMesh = subMesh.getEffectiveMesh();
      const scene2 = this._scene;
      const engine2 = scene2.getEngine();
      const material = subMesh.getMaterial();
      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
      if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene2.getRenderId()) {
        return;
      }
      const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;
      let sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;
      if (detNeg) {
        sideOrientation = sideOrientation === 0 ? 1 : 0;
      }
      const reverseSideOrientation = sideOrientation === 0;
      engine2.setState(material.backFaceCulling, 0, false, reverseSideOrientation, material.cullBackFaces);
      const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
      if (batch.mustReturn) {
        return;
      }
      const hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
      const camera2 = this._camera || scene2.activeCamera;
      if (this.isReady(subMesh, hardwareInstancedRendering) && camera2) {
        subMesh._renderId = scene2.getRenderId();
        const renderingMaterial = (_b = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _b === void 0 ? void 0 : _b[engine2.currentRenderPassId];
        let drawWrapper = subMesh._getDrawWrapper();
        if (!drawWrapper && renderingMaterial) {
          drawWrapper = renderingMaterial._getDrawWrapper();
        }
        const cameraIsOrtho = camera2.mode === Camera.ORTHOGRAPHIC_CAMERA;
        if (!drawWrapper) {
          return;
        }
        const effect = drawWrapper.effect;
        engine2.enableEffect(drawWrapper);
        if (!hardwareInstancedRendering) {
          renderingMesh._bind(subMesh, effect, material.fillMode);
        }
        if (!renderingMaterial) {
          effect.setMatrix("viewProjection", scene2.getTransformMatrix());
          effect.setMatrix("world", effectiveMesh.getWorldMatrix());
        } else {
          renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);
        }
        let minZ, maxZ;
        if (cameraIsOrtho) {
          minZ = !engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : 1;
          maxZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : 1;
        } else {
          minZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? camera2.minZ : engine2.isNDCHalfZRange ? 0 : camera2.minZ;
          maxZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : camera2.maxZ;
        }
        effect.setFloat2("depthValues", minZ, minZ + maxZ);
        if (!renderingMaterial) {
          if (material.needAlphaTesting()) {
            const alphaTexture = material.getAlphaTestTexture();
            if (alphaTexture) {
              effect.setTexture("diffuseSampler", alphaTexture);
              effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
            }
          }
          if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
            const skeleton = renderingMesh.skeleton;
            if (skeleton.isUsingTextureForMatrices) {
              const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);
              if (!boneTexture) {
                return;
              }
              effect.setTexture("boneSampler", boneTexture);
              effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
            } else {
              effect.setMatrices("mBones", skeleton.getTransformMatrices(renderingMesh));
            }
          }
          bindClipPlane(effect, material, scene2);
          MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);
          if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
            renderingMesh.morphTargetManager._bind(effect);
          }
        }
        renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix("world", world));
      }
    };
    this._depthMap.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {
      let index;
      if (depthOnlySubMeshes.length) {
        for (index = 0; index < depthOnlySubMeshes.length; index++) {
          renderSubMesh(depthOnlySubMeshes.data[index]);
        }
      }
      for (index = 0; index < opaqueSubMeshes.length; index++) {
        renderSubMesh(opaqueSubMeshes.data[index]);
      }
      for (index = 0; index < alphaTestSubMeshes.length; index++) {
        renderSubMesh(alphaTestSubMeshes.data[index]);
      }
      if (this.forceDepthWriteTransparentMeshes) {
        for (index = 0; index < transparentSubMeshes.length; index++) {
          renderSubMesh(transparentSubMeshes.data[index]);
        }
      } else {
        for (index = 0; index < transparentSubMeshes.length; index++) {
          transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;
        }
      }
    };
  }
  setMaterialForRendering(mesh, material) {
    this._depthMap.setMaterialForRendering(mesh, material);
  }
  isReady(subMesh, useInstances) {
    var _a;
    const engine = this._scene.getEngine();
    const mesh = subMesh.getMesh();
    const scene = mesh.getScene();
    const renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[engine.currentRenderPassId];
    if (renderingMaterial) {
      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);
    }
    const material = subMesh.getMaterial();
    if (!material || material.disableDepthWrite) {
      return false;
    }
    const defines = [];
    const attribs = [VertexBuffer.PositionKind];
    if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {
      defines.push("#define ALPHATEST");
      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
        attribs.push(VertexBuffer.UVKind);
        defines.push("#define UV1");
      }
      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
        attribs.push(VertexBuffer.UV2Kind);
        defines.push("#define UV2");
      }
    }
    if (mesh.useBones && mesh.computeBonesUsingShaders) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      defines.push("#define BonesPerMesh " + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));
      const skeleton = subMesh.getRenderingMesh().skeleton;
      if (skeleton === null || skeleton === void 0 ? void 0 : skeleton.isUsingTextureForMatrices) {
        defines.push("#define BONETEXTURE");
      }
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    const morphTargetManager = mesh.morphTargetManager;
    let numMorphInfluencers = 0;
    if (morphTargetManager) {
      if (morphTargetManager.numInfluencers > 0) {
        numMorphInfluencers = morphTargetManager.numInfluencers;
        defines.push("#define MORPHTARGETS");
        defines.push("#define NUM_MORPH_INFLUENCERS " + numMorphInfluencers);
        if (morphTargetManager.isUsingTextureForTargets) {
          defines.push("#define MORPHTARGETS_TEXTURE");
        }
        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);
      }
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      MaterialHelper.PushAttributesForInstances(attribs);
      if (subMesh.getRenderingMesh().hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
      }
    }
    if (this._storeNonLinearDepth) {
      defines.push("#define NONLINEARDEPTH");
    }
    if (this.isPacked) {
      defines.push("#define PACKED");
    }
    prepareDefinesForClipPlanes(material, scene, defines);
    const drawWrapper = subMesh._getDrawWrapper(void 0, true);
    const cachedDefines = drawWrapper.defines;
    const join = defines.join("\n");
    if (cachedDefines !== join) {
      const uniforms = [
        "world",
        "mBones",
        "boneTextureWidth",
        "viewProjection",
        "diffuseMatrix",
        "depthValues",
        "morphTargetInfluences",
        "morphTargetTextureInfo",
        "morphTargetTextureIndices"
      ];
      addClipPlaneUniforms(uniforms);
      drawWrapper.setEffect(engine.createEffect("depth", attribs, uniforms, ["diffuseSampler", "morphTargets", "boneSampler"], join, void 0, void 0, void 0, {
        maxSimultaneousMorphTargets: numMorphInfluencers
      }), join);
    }
    return drawWrapper.effect.isReady();
  }
  getDepthMap() {
    return this._depthMap;
  }
  dispose() {
    const keysToDelete = [];
    for (const key in this._scene._depthRenderer) {
      const depthRenderer = this._scene._depthRenderer[key];
      if (depthRenderer === this) {
        keysToDelete.push(key);
      }
    }
    if (keysToDelete.length > 0) {
      this._depthMap.dispose();
      for (const key of keysToDelete) {
        delete this._scene._depthRenderer[key];
      }
    }
  }
};
DepthRenderer._SceneComponentInitialization = (_) => {
  throw _WarnImport("DepthRendererSceneComponent");
};

// node_modules/@babylonjs/core/Shaders/minmaxRedux.fragment.js
var name61 = "minmaxReduxPixelShader";
var shader61 = `varying vec2 vUV;
uniform sampler2D textureSampler;
#if defined(INITIAL)
uniform sampler2D sourceTexture;
uniform vec2 texSize;
void main(void)
{
ivec2 coord=ivec2(vUV*(texSize-1.0));
float f1=texelFetch(sourceTexture,coord,0).r;
float f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;
float f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;
float f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;
float minz=min(min(min(f1,f2),f3),f4);
#ifdef DEPTH_REDUX
float maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);
#else
float maxz=max(max(max(f1,f2),f3),f4);
#endif
glFragColor=vec4(minz,maxz,0.,0.);
}
#elif defined(MAIN)
uniform vec2 texSize;
void main(void)
{
ivec2 coord=ivec2(vUV*(texSize-1.0));
vec2 f1=texelFetch(textureSampler,coord,0).rg;
vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;
vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;
vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;
float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);
float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);
glFragColor=vec4(minz,maxz,0.,0.);
}
#elif defined(ONEBEFORELAST)
uniform ivec2 texSize;
void main(void)
{
ivec2 coord=ivec2(vUV*vec2(texSize-1));
vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;
vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;
vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;
vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;
float minz=min(f1.x,f2.x);
float maxz=max(f1.y,f2.y);
glFragColor=vec4(minz,maxz,0.,0.);
}
#elif defined(LAST)
void main(void)
{
glFragColor=vec4(0.);
if (true) { 
discard;
}
}
#endif
`;
ShaderStore.ShadersStore[name61] = shader61;

// node_modules/@babylonjs/core/Misc/minMaxReducer.js
var MinMaxReducer = class {
  constructor(camera) {
    this.onAfterReductionPerformed = new Observable();
    this._forceFullscreenViewport = true;
    this._activated = false;
    this._camera = camera;
    this._postProcessManager = new PostProcessManager(camera.getScene());
    this._onContextRestoredObserver = camera.getEngine().onContextRestoredObservable.add(() => {
      this._postProcessManager._rebuild();
    });
  }
  get sourceTexture() {
    return this._sourceTexture;
  }
  setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {
    if (sourceTexture === this._sourceTexture) {
      return;
    }
    this.dispose(false);
    this._sourceTexture = sourceTexture;
    this._reductionSteps = [];
    this._forceFullscreenViewport = forceFullscreenViewport;
    const scene = this._camera.getScene();
    const reductionInitial = new PostProcess(
      "Initial reduction phase",
      "minmaxRedux",
      ["texSize"],
      ["sourceTexture"],
      1,
      null,
      1,
      scene.getEngine(),
      false,
      "#define INITIAL" + (depthRedux ? "\n#define DEPTH_REDUX" : ""),
      type,
      void 0,
      void 0,
      void 0,
      7
    );
    reductionInitial.autoClear = false;
    reductionInitial.forceFullscreenViewport = forceFullscreenViewport;
    let w = this._sourceTexture.getRenderWidth(), h = this._sourceTexture.getRenderHeight();
    reductionInitial.onApply = ((w2, h2) => {
      return (effect) => {
        effect.setTexture("sourceTexture", this._sourceTexture);
        effect.setFloat2("texSize", w2, h2);
      };
    })(w, h);
    this._reductionSteps.push(reductionInitial);
    let index = 1;
    while (w > 1 || h > 1) {
      w = Math.max(Math.round(w / 2), 1);
      h = Math.max(Math.round(h / 2), 1);
      const reduction = new PostProcess(
        "Reduction phase " + index,
        "minmaxRedux",
        ["texSize"],
        null,
        { width: w, height: h },
        null,
        1,
        scene.getEngine(),
        false,
        "#define " + (w == 1 && h == 1 ? "LAST" : w == 1 || h == 1 ? "ONEBEFORELAST" : "MAIN"),
        type,
        void 0,
        void 0,
        void 0,
        7
      );
      reduction.autoClear = false;
      reduction.forceFullscreenViewport = forceFullscreenViewport;
      reduction.onApply = ((w2, h2) => {
        return (effect) => {
          if (w2 == 1 || h2 == 1) {
            effect.setInt2("texSize", w2, h2);
          } else {
            effect.setFloat2("texSize", w2, h2);
          }
        };
      })(w, h);
      this._reductionSteps.push(reduction);
      index++;
      if (w == 1 && h == 1) {
        const func = (w2, h2, reduction2) => {
          const buffer = new Float32Array(4 * w2 * h2), minmax = { min: 0, max: 0 };
          return () => {
            scene.getEngine()._readTexturePixels(reduction2.inputTexture.texture, w2, h2, -1, 0, buffer, false);
            minmax.min = buffer[0];
            minmax.max = buffer[1];
            this.onAfterReductionPerformed.notifyObservers(minmax);
          };
        };
        reduction.onAfterRenderObservable.add(func(w, h, reduction));
      }
    }
  }
  get refreshRate() {
    return this._sourceTexture ? this._sourceTexture.refreshRate : -1;
  }
  set refreshRate(value) {
    if (this._sourceTexture) {
      this._sourceTexture.refreshRate = value;
    }
  }
  get activated() {
    return this._activated;
  }
  activate() {
    if (this._onAfterUnbindObserver || !this._sourceTexture) {
      return;
    }
    this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(() => {
      var _a, _b;
      const engine = this._camera.getScene().getEngine();
      (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `min max reduction`, 1);
      this._reductionSteps[0].activate(this._camera);
      this._postProcessManager.directRender(this._reductionSteps, this._reductionSteps[0].inputTexture, this._forceFullscreenViewport);
      engine.unBindFramebuffer(this._reductionSteps[0].inputTexture, false);
      (_b = engine._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(engine, 1);
    });
    this._activated = true;
  }
  deactivate() {
    if (!this._onAfterUnbindObserver || !this._sourceTexture) {
      return;
    }
    this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);
    this._onAfterUnbindObserver = null;
    this._activated = false;
  }
  dispose(disposeAll = true) {
    if (disposeAll) {
      this.onAfterReductionPerformed.clear();
      if (this._onContextRestoredObserver) {
        this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
        this._onContextRestoredObserver = null;
      }
    }
    this.deactivate();
    if (this._reductionSteps) {
      for (let i = 0; i < this._reductionSteps.length; ++i) {
        this._reductionSteps[i].dispose();
      }
      this._reductionSteps = null;
    }
    if (this._postProcessManager && disposeAll) {
      this._postProcessManager.dispose();
    }
    this._sourceTexture = null;
  }
};

// node_modules/@babylonjs/core/Misc/depthReducer.js
var DepthReducer = class extends MinMaxReducer {
  constructor(camera) {
    super(camera);
  }
  get depthRenderer() {
    return this._depthRenderer;
  }
  setDepthRenderer(depthRenderer = null, type = 2, forceFullscreenViewport = true) {
    const scene = this._camera.getScene();
    if (this._depthRenderer) {
      delete scene._depthRenderer[this._depthRendererId];
      this._depthRenderer.dispose();
      this._depthRenderer = null;
    }
    if (depthRenderer === null) {
      if (!scene._depthRenderer) {
        scene._depthRenderer = {};
      }
      depthRenderer = this._depthRenderer = new DepthRenderer(scene, type, this._camera, false, 1);
      depthRenderer.enabled = false;
      this._depthRendererId = "minmax" + this._camera.id;
      scene._depthRenderer[this._depthRendererId] = depthRenderer;
    }
    super.setSourceTexture(depthRenderer.getDepthMap(), true, type, forceFullscreenViewport);
  }
  setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {
    super.setSourceTexture(sourceTexture, depthRedux, type, forceFullscreenViewport);
  }
  activate() {
    if (this._depthRenderer) {
      this._depthRenderer.enabled = true;
    }
    super.activate();
  }
  deactivate() {
    super.deactivate();
    if (this._depthRenderer) {
      this._depthRenderer.enabled = false;
    }
  }
  dispose(disposeAll = true) {
    super.dispose(disposeAll);
    if (this._depthRenderer && disposeAll) {
      const scene = this._depthRenderer.getDepthMap().getScene();
      if (scene) {
        delete scene._depthRenderer[this._depthRendererId];
      }
      this._depthRenderer.dispose();
      this._depthRenderer = null;
    }
  }
};

// node_modules/@babylonjs/core/Lights/Shadows/cascadedShadowGenerator.js
var UpDir = Vector3.Up();
var ZeroVec = Vector3.Zero();
var tmpv1 = new Vector3();
var tmpv2 = new Vector3();
var tmpMatrix = new Matrix();
var CascadedShadowGenerator = class extends ShadowGenerator {
  constructor(mapSize, light, usefulFloatFirst, camera) {
    if (!CascadedShadowGenerator.IsSupported) {
      Logger.Error("CascadedShadowMap is not supported by the current engine.");
      return;
    }
    super(mapSize, light, usefulFloatFirst, camera);
    this.usePercentageCloserFiltering = true;
  }
  _validateFilter(filter) {
    if (filter === ShadowGenerator.FILTER_NONE || filter === ShadowGenerator.FILTER_PCF || filter === ShadowGenerator.FILTER_PCSS) {
      return filter;
    }
    console.error('Unsupported filter "' + filter + '"!');
    return ShadowGenerator.FILTER_NONE;
  }
  get numCascades() {
    return this._numCascades;
  }
  set numCascades(value) {
    value = Math.min(Math.max(value, CascadedShadowGenerator.MIN_CASCADES_COUNT), CascadedShadowGenerator.MAX_CASCADES_COUNT);
    if (value === this._numCascades) {
      return;
    }
    this._numCascades = value;
    this.recreateShadowMap();
    this._recreateSceneUBOs();
  }
  get freezeShadowCastersBoundingInfo() {
    return this._freezeShadowCastersBoundingInfo;
  }
  set freezeShadowCastersBoundingInfo(freeze) {
    if (this._freezeShadowCastersBoundingInfoObservable && freeze) {
      this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);
      this._freezeShadowCastersBoundingInfoObservable = null;
    }
    if (!this._freezeShadowCastersBoundingInfoObservable && !freeze) {
      this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(this._computeShadowCastersBoundingInfo.bind(this));
    }
    this._freezeShadowCastersBoundingInfo = freeze;
    if (freeze) {
      this._computeShadowCastersBoundingInfo();
    }
  }
  _computeShadowCastersBoundingInfo() {
    this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._scbiMax.copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
    if (this._shadowMap && this._shadowMap.renderList) {
      const renderList = this._shadowMap.renderList;
      for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
        const mesh = renderList[meshIndex];
        if (!mesh) {
          continue;
        }
        const boundingInfo = mesh.getBoundingInfo(), boundingBox = boundingInfo.boundingBox;
        this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);
        this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);
      }
      const meshes = this._scene.meshes;
      for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
        const mesh = meshes[meshIndex];
        if (!mesh || !mesh.isVisible || !mesh.isEnabled || !mesh.receiveShadows) {
          continue;
        }
        const boundingInfo = mesh.getBoundingInfo(), boundingBox = boundingInfo.boundingBox;
        this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);
        this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);
      }
    }
    this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);
  }
  get shadowCastersBoundingInfo() {
    return this._shadowCastersBoundingInfo;
  }
  set shadowCastersBoundingInfo(boundingInfo) {
    this._shadowCastersBoundingInfo = boundingInfo;
  }
  setMinMaxDistance(min, max) {
    if (this._minDistance === min && this._maxDistance === max) {
      return;
    }
    if (min > max) {
      min = 0;
      max = 1;
    }
    if (min < 0) {
      min = 0;
    }
    if (max > 1) {
      max = 1;
    }
    this._minDistance = min;
    this._maxDistance = max;
    this._breaksAreDirty = true;
  }
  get minDistance() {
    return this._minDistance;
  }
  get maxDistance() {
    return this._maxDistance;
  }
  getClassName() {
    return CascadedShadowGenerator.CLASSNAME;
  }
  getCascadeMinExtents(cascadeIndex) {
    return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMinExtents[cascadeIndex] : null;
  }
  getCascadeMaxExtents(cascadeIndex) {
    return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMaxExtents[cascadeIndex] : null;
  }
  get shadowMaxZ() {
    if (!this._getCamera()) {
      return 0;
    }
    return this._shadowMaxZ;
  }
  set shadowMaxZ(value) {
    const camera = this._getCamera();
    if (!camera) {
      this._shadowMaxZ = value;
      return;
    }
    if (this._shadowMaxZ === value || value < camera.minZ || value > camera.maxZ) {
      return;
    }
    this._shadowMaxZ = value;
    this._light._markMeshesAsLightDirty();
    this._breaksAreDirty = true;
  }
  get debug() {
    return this._debug;
  }
  set debug(dbg) {
    this._debug = dbg;
    this._light._markMeshesAsLightDirty();
  }
  get depthClamp() {
    return this._depthClamp;
  }
  set depthClamp(value) {
    this._depthClamp = value;
  }
  get cascadeBlendPercentage() {
    return this._cascadeBlendPercentage;
  }
  set cascadeBlendPercentage(value) {
    this._cascadeBlendPercentage = value;
    this._light._markMeshesAsLightDirty();
  }
  get lambda() {
    return this._lambda;
  }
  set lambda(value) {
    const lambda = Math.min(Math.max(value, 0), 1);
    if (this._lambda == lambda) {
      return;
    }
    this._lambda = lambda;
    this._breaksAreDirty = true;
  }
  getCascadeViewMatrix(cascadeNum) {
    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._viewMatrices[cascadeNum] : null;
  }
  getCascadeProjectionMatrix(cascadeNum) {
    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._projectionMatrices[cascadeNum] : null;
  }
  getCascadeTransformMatrix(cascadeNum) {
    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._transformMatrices[cascadeNum] : null;
  }
  setDepthRenderer(depthRenderer) {
    this._depthRenderer = depthRenderer;
    if (this._depthReducer) {
      this._depthReducer.setDepthRenderer(this._depthRenderer);
    }
  }
  get autoCalcDepthBounds() {
    return this._autoCalcDepthBounds;
  }
  set autoCalcDepthBounds(value) {
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    this._autoCalcDepthBounds = value;
    if (!value) {
      if (this._depthReducer) {
        this._depthReducer.deactivate();
      }
      this.setMinMaxDistance(0, 1);
      return;
    }
    if (!this._depthReducer) {
      this._depthReducer = new DepthReducer(camera);
      this._depthReducer.onAfterReductionPerformed.add((minmax) => {
        let min = minmax.min, max = minmax.max;
        if (min >= max) {
          min = 0;
          max = 1;
        }
        if (min != this._minDistance || max != this._maxDistance) {
          this.setMinMaxDistance(min, max);
        }
      });
      this._depthReducer.setDepthRenderer(this._depthRenderer);
    }
    this._depthReducer.activate();
  }
  get autoCalcDepthBoundsRefreshRate() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this._depthReducer) === null || _a === void 0 ? void 0 : _a.depthRenderer) === null || _b === void 0 ? void 0 : _b.getDepthMap().refreshRate) !== null && _c !== void 0 ? _c : -1;
  }
  set autoCalcDepthBoundsRefreshRate(value) {
    var _a;
    if ((_a = this._depthReducer) === null || _a === void 0 ? void 0 : _a.depthRenderer) {
      this._depthReducer.depthRenderer.getDepthMap().refreshRate = value;
    }
  }
  splitFrustum() {
    this._breaksAreDirty = true;
  }
  _splitFrustum() {
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    const near = camera.minZ, far = camera.maxZ, cameraRange = far - near, minDistance = this._minDistance, maxDistance = this._shadowMaxZ < far && this._shadowMaxZ >= near ? Math.min((this._shadowMaxZ - near) / (far - near), this._maxDistance) : this._maxDistance;
    const minZ = near + minDistance * cameraRange, maxZ = near + maxDistance * cameraRange;
    const range = maxZ - minZ, ratio = maxZ / minZ;
    for (let cascadeIndex = 0; cascadeIndex < this._cascades.length; ++cascadeIndex) {
      const p = (cascadeIndex + 1) / this._numCascades, log = minZ * ratio ** p, uniform = minZ + range * p;
      const d = this._lambda * (log - uniform) + uniform;
      this._cascades[cascadeIndex].prevBreakDistance = cascadeIndex === 0 ? minDistance : this._cascades[cascadeIndex - 1].breakDistance;
      this._cascades[cascadeIndex].breakDistance = (d - near) / cameraRange;
      this._viewSpaceFrustumsZ[cascadeIndex] = d;
      this._frustumLengths[cascadeIndex] = (this._cascades[cascadeIndex].breakDistance - this._cascades[cascadeIndex].prevBreakDistance) * cameraRange;
    }
    this._breaksAreDirty = false;
  }
  _computeMatrices() {
    const scene = this._scene;
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    Vector3.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection);
    if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1) {
      this._lightDirection.z = 1e-13;
    }
    this._cachedDirection.copyFrom(this._lightDirection);
    const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;
    for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
      this._computeFrustumInWorldSpace(cascadeIndex);
      this._computeCascadeFrustum(cascadeIndex);
      this._cascadeMaxExtents[cascadeIndex].subtractToRef(this._cascadeMinExtents[cascadeIndex], tmpv1);
      this._frustumCenter[cascadeIndex].addToRef(this._lightDirection.scale(this._cascadeMinExtents[cascadeIndex].z), this._shadowCameraPos[cascadeIndex]);
      Matrix.LookAtLHToRef(this._shadowCameraPos[cascadeIndex], this._frustumCenter[cascadeIndex], UpDir, this._viewMatrices[cascadeIndex]);
      let minZ = 0, maxZ = tmpv1.z;
      const boundingInfo = this._shadowCastersBoundingInfo;
      boundingInfo.update(this._viewMatrices[cascadeIndex]);
      maxZ = Math.min(maxZ, boundingInfo.boundingBox.maximumWorld.z);
      if (!this._depthClamp || this.filter === ShadowGenerator.FILTER_PCSS) {
        minZ = Math.min(minZ, boundingInfo.boundingBox.minimumWorld.z);
      } else {
        minZ = Math.max(minZ, boundingInfo.boundingBox.minimumWorld.z);
      }
      Matrix.OrthoOffCenterLHToRef(this._cascadeMinExtents[cascadeIndex].x, this._cascadeMaxExtents[cascadeIndex].x, this._cascadeMinExtents[cascadeIndex].y, this._cascadeMaxExtents[cascadeIndex].y, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, this._projectionMatrices[cascadeIndex], scene.getEngine().isNDCHalfZRange);
      this._cascadeMinExtents[cascadeIndex].z = minZ;
      this._cascadeMaxExtents[cascadeIndex].z = maxZ;
      this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);
      Vector3.TransformCoordinatesToRef(ZeroVec, this._transformMatrices[cascadeIndex], tmpv1);
      tmpv1.scaleInPlace(this._mapSize / 2);
      tmpv2.copyFromFloats(Math.round(tmpv1.x), Math.round(tmpv1.y), Math.round(tmpv1.z));
      tmpv2.subtractInPlace(tmpv1).scaleInPlace(2 / this._mapSize);
      Matrix.TranslationToRef(tmpv2.x, tmpv2.y, 0, tmpMatrix);
      this._projectionMatrices[cascadeIndex].multiplyToRef(tmpMatrix, this._projectionMatrices[cascadeIndex]);
      this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);
      this._transformMatrices[cascadeIndex].copyToArray(this._transformMatricesAsArray, cascadeIndex * 16);
    }
  }
  _computeFrustumInWorldSpace(cascadeIndex) {
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    const prevSplitDist = this._cascades[cascadeIndex].prevBreakDistance, splitDist = this._cascades[cascadeIndex].breakDistance;
    const isNDCHalfZRange = this._scene.getEngine().isNDCHalfZRange;
    camera.getViewMatrix();
    const invViewProj = Matrix.Invert(camera.getTransformationMatrix());
    const cornerIndexOffset = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0;
    for (let cornerIndex = 0; cornerIndex < CascadedShadowGenerator._FrustumCornersNDCSpace.length; ++cornerIndex) {
      tmpv1.copyFrom(CascadedShadowGenerator._FrustumCornersNDCSpace[(cornerIndex + cornerIndexOffset) % CascadedShadowGenerator._FrustumCornersNDCSpace.length]);
      if (isNDCHalfZRange && tmpv1.z === -1) {
        tmpv1.z = 0;
      }
      Vector3.TransformCoordinatesToRef(tmpv1, invViewProj, this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
    }
    for (let cornerIndex = 0; cornerIndex < CascadedShadowGenerator._FrustumCornersNDCSpace.length / 2; ++cornerIndex) {
      tmpv1.copyFrom(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4]).subtractInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
      tmpv2.copyFrom(tmpv1).scaleInPlace(prevSplitDist);
      tmpv1.scaleInPlace(splitDist);
      tmpv1.addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
      this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4].copyFrom(tmpv1);
      this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].addInPlace(tmpv2);
    }
  }
  _computeCascadeFrustum(cascadeIndex) {
    this._cascadeMinExtents[cascadeIndex].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cascadeMaxExtents[cascadeIndex].copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
    this._frustumCenter[cascadeIndex].copyFromFloats(0, 0, 0);
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
      this._frustumCenter[cascadeIndex].addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
    }
    this._frustumCenter[cascadeIndex].scaleInPlace(1 / this._frustumCornersWorldSpace[cascadeIndex].length);
    if (this.stabilizeCascades) {
      let sphereRadius = 0;
      for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
        const dist = this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].subtractToRef(this._frustumCenter[cascadeIndex], tmpv1).length();
        sphereRadius = Math.max(sphereRadius, dist);
      }
      sphereRadius = Math.ceil(sphereRadius * 16) / 16;
      this._cascadeMaxExtents[cascadeIndex].copyFromFloats(sphereRadius, sphereRadius, sphereRadius);
      this._cascadeMinExtents[cascadeIndex].copyFromFloats(-sphereRadius, -sphereRadius, -sphereRadius);
    } else {
      const lightCameraPos = this._frustumCenter[cascadeIndex];
      this._frustumCenter[cascadeIndex].addToRef(this._lightDirection, tmpv1);
      Matrix.LookAtLHToRef(lightCameraPos, tmpv1, UpDir, tmpMatrix);
      for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
        Vector3.TransformCoordinatesToRef(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex], tmpMatrix, tmpv1);
        this._cascadeMinExtents[cascadeIndex].minimizeInPlace(tmpv1);
        this._cascadeMaxExtents[cascadeIndex].maximizeInPlace(tmpv1);
      }
    }
  }
  _recreateSceneUBOs() {
    this._disposeSceneUBOs();
    if (this._sceneUBOs) {
      for (let i = 0; i < this._numCascades; ++i) {
        this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${i})`));
      }
    }
  }
  static get IsSupported() {
    const engine = EngineStore.LastCreatedEngine;
    if (!engine) {
      return false;
    }
    return engine._features.supportCSM;
  }
  _initializeGenerator() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
    this.penumbraDarkness = (_a = this.penumbraDarkness) !== null && _a !== void 0 ? _a : 1;
    this._numCascades = (_b = this._numCascades) !== null && _b !== void 0 ? _b : CascadedShadowGenerator.DEFAULT_CASCADES_COUNT;
    this.stabilizeCascades = (_c = this.stabilizeCascades) !== null && _c !== void 0 ? _c : false;
    this._freezeShadowCastersBoundingInfoObservable = (_d = this._freezeShadowCastersBoundingInfoObservable) !== null && _d !== void 0 ? _d : null;
    this.freezeShadowCastersBoundingInfo = (_e = this.freezeShadowCastersBoundingInfo) !== null && _e !== void 0 ? _e : false;
    this._scbiMin = (_f = this._scbiMin) !== null && _f !== void 0 ? _f : new Vector3(0, 0, 0);
    this._scbiMax = (_g = this._scbiMax) !== null && _g !== void 0 ? _g : new Vector3(0, 0, 0);
    this._shadowCastersBoundingInfo = (_h = this._shadowCastersBoundingInfo) !== null && _h !== void 0 ? _h : new BoundingInfo(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    this._breaksAreDirty = (_j = this._breaksAreDirty) !== null && _j !== void 0 ? _j : true;
    this._minDistance = (_k = this._minDistance) !== null && _k !== void 0 ? _k : 0;
    this._maxDistance = (_l = this._maxDistance) !== null && _l !== void 0 ? _l : 1;
    this._currentLayer = (_m = this._currentLayer) !== null && _m !== void 0 ? _m : 0;
    this._shadowMaxZ = (_q = (_o = this._shadowMaxZ) !== null && _o !== void 0 ? _o : (_p = this._getCamera()) === null || _p === void 0 ? void 0 : _p.maxZ) !== null && _q !== void 0 ? _q : 1e4;
    this._debug = (_r = this._debug) !== null && _r !== void 0 ? _r : false;
    this._depthClamp = (_s = this._depthClamp) !== null && _s !== void 0 ? _s : true;
    this._cascadeBlendPercentage = (_t = this._cascadeBlendPercentage) !== null && _t !== void 0 ? _t : 0.1;
    this._lambda = (_u = this._lambda) !== null && _u !== void 0 ? _u : 0.5;
    this._autoCalcDepthBounds = (_v = this._autoCalcDepthBounds) !== null && _v !== void 0 ? _v : false;
    this._recreateSceneUBOs();
    super._initializeGenerator();
  }
  _createTargetRenderTexture() {
    const engine = this._scene.getEngine();
    const size = { width: this._mapSize, height: this._mapSize, layers: this.numCascades };
    this._shadowMap = new RenderTargetTexture(this._light.name + "_CSMShadowMap", size, this._scene, false, true, this._textureType, false, void 0, false, false, void 0);
    this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true);
  }
  _initializeShadowMap() {
    super._initializeShadowMap();
    if (this._shadowMap === null) {
      return;
    }
    this._transformMatricesAsArray = new Float32Array(this._numCascades * 16);
    this._viewSpaceFrustumsZ = new Array(this._numCascades);
    this._frustumLengths = new Array(this._numCascades);
    this._lightSizeUVCorrection = new Array(this._numCascades * 2);
    this._depthCorrection = new Array(this._numCascades);
    this._cascades = [];
    this._viewMatrices = [];
    this._projectionMatrices = [];
    this._transformMatrices = [];
    this._cascadeMinExtents = [];
    this._cascadeMaxExtents = [];
    this._frustumCenter = [];
    this._shadowCameraPos = [];
    this._frustumCornersWorldSpace = [];
    for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
      this._cascades[cascadeIndex] = {
        prevBreakDistance: 0,
        breakDistance: 0
      };
      this._viewMatrices[cascadeIndex] = Matrix.Zero();
      this._projectionMatrices[cascadeIndex] = Matrix.Zero();
      this._transformMatrices[cascadeIndex] = Matrix.Zero();
      this._cascadeMinExtents[cascadeIndex] = new Vector3();
      this._cascadeMaxExtents[cascadeIndex] = new Vector3();
      this._frustumCenter[cascadeIndex] = new Vector3();
      this._shadowCameraPos[cascadeIndex] = new Vector3();
      this._frustumCornersWorldSpace[cascadeIndex] = new Array(CascadedShadowGenerator._FrustumCornersNDCSpace.length);
      for (let i = 0; i < CascadedShadowGenerator._FrustumCornersNDCSpace.length; ++i) {
        this._frustumCornersWorldSpace[cascadeIndex][i] = new Vector3();
      }
    }
    const engine = this._scene.getEngine();
    this._shadowMap.onBeforeBindObservable.clear();
    this._shadowMap.onBeforeRenderObservable.clear();
    this._shadowMap.onBeforeRenderObservable.add((layer) => {
      if (this._sceneUBOs) {
        this._scene.setSceneUniformBuffer(this._sceneUBOs[layer]);
      }
      this._currentLayer = layer;
      if (this._filter === ShadowGenerator.FILTER_PCF) {
        engine.setColorWrite(false);
      }
      this._scene.setTransformMatrix(this.getCascadeViewMatrix(layer), this.getCascadeProjectionMatrix(layer));
      if (this._useUBO) {
        this._scene.getSceneUniformBuffer().unbindEffect();
        this._scene.finalizeSceneUbo();
      }
    });
    this._shadowMap.onBeforeBindObservable.add(() => {
      var _a;
      this._currentSceneUBO = this._scene.getSceneUniformBuffer();
      (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `cascaded shadow map generation for pass id ${engine.currentRenderPassId}`, 1);
      if (this._breaksAreDirty) {
        this._splitFrustum();
      }
      this._computeMatrices();
    });
    this._splitFrustum();
  }
  _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect) {
    effect.setMatrix("viewProjection", this.getCascadeTransformMatrix(this._currentLayer));
  }
  _isReadyCustomDefines(defines) {
    defines.push("#define SM_DEPTHCLAMP " + (this._depthClamp && this._filter !== ShadowGenerator.FILTER_PCSS ? "1" : "0"));
  }
  prepareDefines(defines, lightIndex) {
    super.prepareDefines(defines, lightIndex);
    const scene = this._scene;
    const light = this._light;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    defines["SHADOWCSM" + lightIndex] = true;
    defines["SHADOWCSMDEBUG" + lightIndex] = this.debug;
    defines["SHADOWCSMNUM_CASCADES" + lightIndex] = this.numCascades;
    defines["SHADOWCSM_RIGHTHANDED" + lightIndex] = scene.useRightHandedSystem;
    const camera = this._getCamera();
    if (camera && this._shadowMaxZ < camera.maxZ) {
      defines["SHADOWCSMUSESHADOWMAXZ" + lightIndex] = true;
    }
    if (this.cascadeBlendPercentage === 0) {
      defines["SHADOWCSMNOBLEND" + lightIndex] = true;
    }
  }
  bindShadowLight(lightIndex, effect) {
    const light = this._light;
    const scene = this._scene;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    const shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return;
    }
    const width = shadowMap.getSize().width;
    effect.setMatrices("lightMatrix" + lightIndex, this._transformMatricesAsArray);
    effect.setArray("viewFrustumZ" + lightIndex, this._viewSpaceFrustumsZ);
    effect.setFloat("cascadeBlendFactor" + lightIndex, this.cascadeBlendPercentage === 0 ? 1e4 : 1 / this.cascadeBlendPercentage);
    effect.setArray("frustumLengths" + lightIndex, this._frustumLengths);
    if (this._filter === ShadowGenerator.FILTER_PCF) {
      effect.setDepthStencilTexture("shadowSampler" + lightIndex, shadowMap);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);
    } else if (this._filter === ShadowGenerator.FILTER_PCSS) {
      for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
        this._lightSizeUVCorrection[cascadeIndex * 2 + 0] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[cascadeIndex].x - this._cascadeMinExtents[cascadeIndex].x);
        this._lightSizeUVCorrection[cascadeIndex * 2 + 1] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[cascadeIndex].y - this._cascadeMinExtents[cascadeIndex].y);
        this._depthCorrection[cascadeIndex] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[cascadeIndex].z - this._cascadeMinExtents[cascadeIndex].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);
      }
      effect.setDepthStencilTexture("shadowSampler" + lightIndex, shadowMap);
      effect.setTexture("depthSampler" + lightIndex, shadowMap);
      effect.setArray2("lightSizeUVCorrection" + lightIndex, this._lightSizeUVCorrection);
      effect.setArray("depthCorrection" + lightIndex, this._depthCorrection);
      effect.setFloat("penumbraDarkness" + lightIndex, this.penumbraDarkness);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / width, this._contactHardeningLightSizeUVRatio * width, this.frustumEdgeFalloff, lightIndex);
    } else {
      effect.setTexture("shadowSampler" + lightIndex, shadowMap);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);
    }
    light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
  }
  getTransformMatrix() {
    return this.getCascadeTransformMatrix(0);
  }
  dispose() {
    super.dispose();
    if (this._freezeShadowCastersBoundingInfoObservable) {
      this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);
      this._freezeShadowCastersBoundingInfoObservable = null;
    }
    if (this._depthReducer) {
      this._depthReducer.dispose();
      this._depthReducer = null;
    }
  }
  serialize() {
    const serializationObject = super.serialize();
    const shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return serializationObject;
    }
    serializationObject.numCascades = this._numCascades;
    serializationObject.debug = this._debug;
    serializationObject.stabilizeCascades = this.stabilizeCascades;
    serializationObject.lambda = this._lambda;
    serializationObject.cascadeBlendPercentage = this.cascadeBlendPercentage;
    serializationObject.depthClamp = this._depthClamp;
    serializationObject.autoCalcDepthBounds = this.autoCalcDepthBounds;
    serializationObject.shadowMaxZ = this._shadowMaxZ;
    serializationObject.penumbraDarkness = this.penumbraDarkness;
    serializationObject.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo;
    serializationObject.minDistance = this.minDistance;
    serializationObject.maxDistance = this.maxDistance;
    serializationObject.renderList = [];
    if (shadowMap.renderList) {
      for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
        const mesh = shadowMap.renderList[meshIndex];
        serializationObject.renderList.push(mesh.id);
      }
    }
    return serializationObject;
  }
  static Parse(parsedShadowGenerator, scene) {
    const shadowGenerator = ShadowGenerator.Parse(parsedShadowGenerator, scene, (mapSize, light, camera) => new CascadedShadowGenerator(mapSize, light, void 0, camera));
    if (parsedShadowGenerator.numCascades !== void 0) {
      shadowGenerator.numCascades = parsedShadowGenerator.numCascades;
    }
    if (parsedShadowGenerator.debug !== void 0) {
      shadowGenerator.debug = parsedShadowGenerator.debug;
    }
    if (parsedShadowGenerator.stabilizeCascades !== void 0) {
      shadowGenerator.stabilizeCascades = parsedShadowGenerator.stabilizeCascades;
    }
    if (parsedShadowGenerator.lambda !== void 0) {
      shadowGenerator.lambda = parsedShadowGenerator.lambda;
    }
    if (parsedShadowGenerator.cascadeBlendPercentage !== void 0) {
      shadowGenerator.cascadeBlendPercentage = parsedShadowGenerator.cascadeBlendPercentage;
    }
    if (parsedShadowGenerator.depthClamp !== void 0) {
      shadowGenerator.depthClamp = parsedShadowGenerator.depthClamp;
    }
    if (parsedShadowGenerator.autoCalcDepthBounds !== void 0) {
      shadowGenerator.autoCalcDepthBounds = parsedShadowGenerator.autoCalcDepthBounds;
    }
    if (parsedShadowGenerator.shadowMaxZ !== void 0) {
      shadowGenerator.shadowMaxZ = parsedShadowGenerator.shadowMaxZ;
    }
    if (parsedShadowGenerator.penumbraDarkness !== void 0) {
      shadowGenerator.penumbraDarkness = parsedShadowGenerator.penumbraDarkness;
    }
    if (parsedShadowGenerator.freezeShadowCastersBoundingInfo !== void 0) {
      shadowGenerator.freezeShadowCastersBoundingInfo = parsedShadowGenerator.freezeShadowCastersBoundingInfo;
    }
    if (parsedShadowGenerator.minDistance !== void 0 && parsedShadowGenerator.maxDistance !== void 0) {
      shadowGenerator.setMinMaxDistance(parsedShadowGenerator.minDistance, parsedShadowGenerator.maxDistance);
    }
    return shadowGenerator;
  }
};
CascadedShadowGenerator._FrustumCornersNDCSpace = [
  new Vector3(-1, 1, -1),
  new Vector3(1, 1, -1),
  new Vector3(1, -1, -1),
  new Vector3(-1, -1, -1),
  new Vector3(-1, 1, 1),
  new Vector3(1, 1, 1),
  new Vector3(1, -1, 1),
  new Vector3(-1, -1, 1)
];
CascadedShadowGenerator.CLASSNAME = "CascadedShadowGenerator";
CascadedShadowGenerator.DEFAULT_CASCADES_COUNT = 4;
CascadedShadowGenerator.MIN_CASCADES_COUNT = 2;
CascadedShadowGenerator.MAX_CASCADES_COUNT = 4;
CascadedShadowGenerator._SceneComponentInitialization = (_) => {
  throw _WarnImport("ShadowGeneratorSceneComponent");
};

// node_modules/@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent.js
AbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData, scene) => {
  if (parsedData.shadowGenerators !== void 0 && parsedData.shadowGenerators !== null) {
    for (let index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {
      const parsedShadowGenerator = parsedData.shadowGenerators[index];
      if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {
        CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);
      } else {
        ShadowGenerator.Parse(parsedShadowGenerator, scene);
      }
    }
  }
});
var ShadowGeneratorSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_SHADOWGENERATOR;
    this.scene = scene;
  }
  register() {
    this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);
  }
  rebuild() {
  }
  serialize(serializationObject) {
    serializationObject.shadowGenerators = [];
    const lights = this.scene.lights;
    for (const light of lights) {
      const shadowGenerators = light.getShadowGenerators();
      if (shadowGenerators) {
        const iterator = shadowGenerators.values();
        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
          const shadowGenerator = key.value;
          serializationObject.shadowGenerators.push(shadowGenerator.serialize());
        }
      }
    }
  }
  addFromContainer(container) {
  }
  removeFromContainer(container, dispose) {
  }
  dispose() {
  }
  _gatherRenderTargets(renderTargets) {
    const scene = this.scene;
    if (this.scene.shadowsEnabled) {
      for (let lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {
        const light = scene.lights[lightIndex];
        const shadowGenerators = light.getShadowGenerators();
        if (light.isEnabled() && light.shadowEnabled && shadowGenerators) {
          const iterator = shadowGenerators.values();
          for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
            const shadowGenerator = key.value;
            const shadowMap = shadowGenerator.getShadowMap();
            if (scene.textures.indexOf(shadowMap) !== -1) {
              renderTargets.push(shadowMap);
            }
          }
        }
      }
    }
  }
};
ShadowGenerator._SceneComponentInitialization = (scene) => {
  let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);
  if (!component) {
    component = new ShadowGeneratorSceneComponent(scene);
    scene._addComponent(component);
  }
};

// node_modules/@babylonjs/core/Loading/loadingScreen.js
var DefaultLoadingScreen = class {
  constructor(_renderingCanvas, _loadingText = "", _loadingDivBackgroundColor = "black") {
    this._renderingCanvas = _renderingCanvas;
    this._loadingText = _loadingText;
    this._loadingDivBackgroundColor = _loadingDivBackgroundColor;
    this._resizeLoadingUI = () => {
      const canvasRect = this._renderingCanvas.getBoundingClientRect();
      const canvasPositioning = window.getComputedStyle(this._renderingCanvas).position;
      if (!this._loadingDiv) {
        return;
      }
      this._loadingDiv.style.position = canvasPositioning === "fixed" ? "fixed" : "absolute";
      this._loadingDiv.style.left = canvasRect.left + "px";
      this._loadingDiv.style.top = canvasRect.top + "px";
      this._loadingDiv.style.width = canvasRect.width + "px";
      this._loadingDiv.style.height = canvasRect.height + "px";
    };
  }
  displayLoadingUI() {
    if (this._loadingDiv) {
      return;
    }
    this._loadingDiv = document.createElement("div");
    this._loadingDiv.id = "babylonjsLoadingDiv";
    this._loadingDiv.style.opacity = "0";
    this._loadingDiv.style.transition = "opacity 1.5s ease";
    this._loadingDiv.style.pointerEvents = "none";
    this._loadingDiv.style.display = "grid";
    this._loadingDiv.style.gridTemplateRows = "100%";
    this._loadingDiv.style.gridTemplateColumns = "100%";
    this._loadingDiv.style.justifyItems = "center";
    this._loadingDiv.style.alignItems = "center";
    this._loadingTextDiv = document.createElement("div");
    this._loadingTextDiv.style.position = "absolute";
    this._loadingTextDiv.style.left = "0";
    this._loadingTextDiv.style.top = "50%";
    this._loadingTextDiv.style.marginTop = "80px";
    this._loadingTextDiv.style.width = "100%";
    this._loadingTextDiv.style.height = "20px";
    this._loadingTextDiv.style.fontFamily = "Arial";
    this._loadingTextDiv.style.fontSize = "14px";
    this._loadingTextDiv.style.color = "white";
    this._loadingTextDiv.style.textAlign = "center";
    this._loadingTextDiv.style.zIndex = "1";
    this._loadingTextDiv.innerHTML = "Loading";
    this._loadingDiv.appendChild(this._loadingTextDiv);
    this._loadingTextDiv.innerHTML = this._loadingText;
    this._style = document.createElement("style");
    this._style.type = "text/css";
    const keyFrames = `@-webkit-keyframes spin1 {                    0% { -webkit-transform: rotate(0deg);}
                    100% { -webkit-transform: rotate(360deg);}
                }                @keyframes spin1 {                    0% { transform: rotate(0deg);}
                    100% { transform: rotate(360deg);}
                }`;
    this._style.innerHTML = keyFrames;
    document.getElementsByTagName("head")[0].appendChild(this._style);
    const svgSupport = !!window.SVGSVGElement;
    const imgBack = new Image();
    if (!DefaultLoadingScreen.DefaultLogoUrl) {
      imgBack.src = !svgSupport ? "https://cdn.babylonjs.com/Assets/babylonLogo.png" : `data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxODAuMTcgMjA4LjA0Ij48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZjt9LmNscy0ye2ZpbGw6I2UwNjg0Yjt9LmNscy0ze2ZpbGw6I2JiNDY0Yjt9LmNscy00e2ZpbGw6I2UwZGVkODt9LmNscy01e2ZpbGw6I2Q1ZDJjYTt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPkJhYnlsb25Mb2dvPC90aXRsZT48ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIj48ZyBpZD0iUGFnZV9FbGVtZW50cyIgZGF0YS1uYW1lPSJQYWdlIEVsZW1lbnRzIj48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik05MC4wOSwwLDAsNTJWMTU2bDkwLjA5LDUyLDkwLjA4LTUyVjUyWiIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtMiIgcG9pbnRzPSIxODAuMTcgNTIuMDEgMTUxLjk3IDM1LjczIDEyNC44NSA1MS4zOSAxNTMuMDUgNjcuNjcgMTgwLjE3IDUyLjAxIi8+PHBvbHlnb24gY2xhc3M9ImNscy0yIiBwb2ludHM9IjI3LjEyIDY3LjY3IDExNy4yMSAxNS42NiA5MC4wOCAwIDAgNTIuMDEgMjcuMTIgNjcuNjciLz48cG9seWdvbiBjbGFzcz0iY2xzLTIiIHBvaW50cz0iNjEuODkgMTIwLjMgOTAuMDggMTM2LjU4IDExOC4yOCAxMjAuMyA5MC4wOCAxMDQuMDIgNjEuODkgMTIwLjMiLz48cG9seWdvbiBjbGFzcz0iY2xzLTMiIHBvaW50cz0iMTUzLjA1IDY3LjY3IDE1My4wNSAxNDAuMzcgOTAuMDggMTc2LjcyIDI3LjEyIDE0MC4zNyAyNy4xMiA2Ny42NyAwIDUyLjAxIDAgMTU2LjAzIDkwLjA4IDIwOC4wNCAxODAuMTcgMTU2LjAzIDE4MC4xNyA1Mi4wMSAxNTMuMDUgNjcuNjciLz48cG9seWdvbiBjbGFzcz0iY2xzLTMiIHBvaW50cz0iOTAuMDggNzEuNDYgNjEuODkgODcuNzQgNjEuODkgMTIwLjMgOTAuMDggMTA0LjAyIDExOC4yOCAxMjAuMyAxMTguMjggODcuNzQgOTAuMDggNzEuNDYiLz48cG9seWdvbiBjbGFzcz0iY2xzLTQiIHBvaW50cz0iMTUzLjA1IDY3LjY3IDExOC4yOCA4Ny43NCAxMTguMjggMTIwLjMgOTAuMDggMTM2LjU4IDkwLjA4IDE3Ni43MiAxNTMuMDUgMTQwLjM3IDE1My4wNSA2Ny42NyIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtNSIgcG9pbnRzPSIyNy4xMiA2Ny42NyA2MS44OSA4Ny43NCA2MS44OSAxMjAuMyA5MC4wOCAxMzYuNTggOTAuMDggMTc2LjcyIDI3LjEyIDE0MC4zNyAyNy4xMiA2Ny42NyIvPjwvZz48L2c+PC9zdmc+`;
    } else {
      imgBack.src = DefaultLoadingScreen.DefaultLogoUrl;
    }
    imgBack.style.width = "150px";
    imgBack.style.gridColumn = "1";
    imgBack.style.gridRow = "1";
    imgBack.style.top = "50%";
    imgBack.style.left = "50%";
    imgBack.style.transform = "translate(-50%, -50%)";
    imgBack.style.position = "absolute";
    const imageSpinnerContainer = document.createElement("div");
    imageSpinnerContainer.style.width = "300px";
    imageSpinnerContainer.style.gridColumn = "1";
    imageSpinnerContainer.style.gridRow = "1";
    imageSpinnerContainer.style.top = "50%";
    imageSpinnerContainer.style.left = "50%";
    imageSpinnerContainer.style.transform = "translate(-50%, -50%)";
    imageSpinnerContainer.style.position = "absolute";
    const imgSpinner = new Image();
    if (!DefaultLoadingScreen.DefaultSpinnerUrl) {
      imgSpinner.src = !svgSupport ? "https://cdn.babylonjs.com/Assets/loadingIcon.png" : `data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzOTIgMzkyIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2UwNjg0Yjt9LmNscy0ye2ZpbGw6bm9uZTt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPlNwaW5uZXJJY29uPC90aXRsZT48ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIj48ZyBpZD0iU3Bpbm5lciI+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNDAuMjEsMTI2LjQzYzMuNy03LjMxLDcuNjctMTQuNDQsMTItMjEuMzJsMy4zNi01LjEsMy41Mi01YzEuMjMtMS42MywyLjQxLTMuMjksMy42NS00LjkxczIuNTMtMy4yMSwzLjgyLTQuNzlBMTg1LjIsMTg1LjIsMCwwLDEsODMuNCw2Ny40M2EyMDgsMjA4LDAsMCwxLDE5LTE1LjY2YzMuMzUtMi40MSw2Ljc0LTQuNzgsMTAuMjUtN3M3LjExLTQuMjgsMTAuNzUtNi4zMmM3LjI5LTQsMTQuNzMtOCwyMi41My0xMS40OSwzLjktMS43Miw3Ljg4LTMuMywxMi00LjY0YTEwNC4yMiwxMDQuMjIsMCwwLDEsMTIuNDQtMy4yMyw2Mi40NCw2Mi40NCwwLDAsMSwxMi43OC0xLjM5QTI1LjkyLDI1LjkyLDAsMCwxLDE5NiwyMS40NGE2LjU1LDYuNTUsMCwwLDEsMi4wNSw5LDYuNjYsNi42NiwwLDAsMS0xLjY0LDEuNzhsLS40MS4yOWEyMi4wNywyMi4wNywwLDAsMS01Ljc4LDMsMzAuNDIsMzAuNDIsMCwwLDEtNS42NywxLjYyLDM3LjgyLDM3LjgyLDAsMCwxLTUuNjkuNzFjLTEsMC0xLjkuMTgtMi44NS4yNmwtMi44NS4yNHEtNS43Mi41MS0xMS40OCwxLjFjLTMuODQuNC03LjcxLjgyLTExLjU4LDEuNGExMTIuMzQsMTEyLjM0LDAsMCwwLTIyLjk0LDUuNjFjLTMuNzIsMS4zNS03LjM0LDMtMTAuOTQsNC42NHMtNy4xNCwzLjUxLTEwLjYsNS41MUExNTEuNiwxNTEuNiwwLDAsMCw2OC41Niw4N0M2Ny4yMyw4OC40OCw2Niw5MCw2NC42NCw5MS41NnMtMi41MSwzLjE1LTMuNzUsNC43M2wtMy41NCw0LjljLTEuMTMsMS42Ni0yLjIzLDMuMzUtMy4zMyw1YTEyNywxMjcsMCwwLDAtMTAuOTMsMjEuNDksMS41OCwxLjU4LDAsMSwxLTMtMS4xNVM0MC4xOSwxMjYuNDcsNDAuMjEsMTI2LjQzWiIvPjxyZWN0IGNsYXNzPSJjbHMtMiIgd2lkdGg9IjM5MiIgaGVpZ2h0PSIzOTIiLz48L2c+PC9nPjwvc3ZnPg==`;
    } else {
      imgSpinner.src = DefaultLoadingScreen.DefaultSpinnerUrl;
    }
    imgSpinner.style.animation = "spin1 0.75s infinite linear";
    imgSpinner.style.webkitAnimation = "spin1 0.75s infinite linear";
    imgSpinner.style.transformOrigin = "50% 50%";
    imgSpinner.style.webkitTransformOrigin = "50% 50%";
    if (!svgSupport) {
      const logoSize = { w: 16, h: 18.5 };
      const loadingSize = { w: 30, h: 30 };
      imgBack.style.width = `${logoSize.w}vh`;
      imgBack.style.height = `${logoSize.h}vh`;
      imgBack.style.left = `calc(50% - ${logoSize.w / 2}vh)`;
      imgBack.style.top = `calc(50% - ${logoSize.h / 2}vh)`;
      imgSpinner.style.width = `${loadingSize.w}vh`;
      imgSpinner.style.height = `${loadingSize.h}vh`;
      imgSpinner.style.left = `calc(50% - ${loadingSize.w / 2}vh)`;
      imgSpinner.style.top = `calc(50% - ${loadingSize.h / 2}vh)`;
    }
    imageSpinnerContainer.appendChild(imgSpinner);
    this._loadingDiv.appendChild(imgBack);
    this._loadingDiv.appendChild(imageSpinnerContainer);
    this._resizeLoadingUI();
    window.addEventListener("resize", this._resizeLoadingUI);
    this._loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor;
    document.body.appendChild(this._loadingDiv);
    this._loadingDiv.style.opacity = "1";
  }
  hideLoadingUI() {
    if (!this._loadingDiv) {
      return;
    }
    const onTransitionEnd = () => {
      if (this._loadingTextDiv) {
        this._loadingTextDiv.remove();
        this._loadingTextDiv = null;
      }
      if (this._loadingDiv) {
        this._loadingDiv.remove();
        this._loadingDiv = null;
      }
      if (this._style) {
        this._style.remove();
        this._style = null;
      }
      window.removeEventListener("resize", this._resizeLoadingUI);
    };
    this._loadingDiv.style.opacity = "0";
    this._loadingDiv.addEventListener("transitionend", onTransitionEnd);
  }
  set loadingUIText(text) {
    this._loadingText = text;
    if (this._loadingTextDiv) {
      this._loadingTextDiv.innerHTML = this._loadingText;
    }
  }
  get loadingUIText() {
    return this._loadingText;
  }
  get loadingUIBackgroundColor() {
    return this._loadingDivBackgroundColor;
  }
  set loadingUIBackgroundColor(color) {
    this._loadingDivBackgroundColor = color;
    if (!this._loadingDiv) {
      return;
    }
    this._loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor;
  }
};
DefaultLoadingScreen.DefaultLogoUrl = "";
DefaultLoadingScreen.DefaultSpinnerUrl = "";
Engine.DefaultLoadingScreenFactory = (canvas) => {
  return new DefaultLoadingScreen(canvas);
};

// node_modules/@babylonjs/core/Misc/HighDynamicRange/panoramaToCubemap.js
var PanoramaToCubeMapTools = class {
  static ConvertPanoramaToCubemap(float32Array, inputWidth, inputHeight, size) {
    if (!float32Array) {
      throw "ConvertPanoramaToCubemap: input cannot be null";
    }
    if (float32Array.length != inputWidth * inputHeight * 3) {
      throw "ConvertPanoramaToCubemap: input size is wrong";
    }
    const textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight);
    const textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight);
    const textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight);
    const textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight);
    const textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight);
    const textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight);
    return {
      front: textureFront,
      back: textureBack,
      left: textureLeft,
      right: textureRight,
      up: textureUp,
      down: textureDown,
      size,
      type: 1,
      format: 4,
      gammaSpace: false
    };
  }
  static CreateCubemapTexture(texSize, faceData, float32Array, inputWidth, inputHeight) {
    const buffer = new ArrayBuffer(texSize * texSize * 4 * 3);
    const textureArray = new Float32Array(buffer);
    const rotDX1 = faceData[1].subtract(faceData[0]).scale(1 / texSize);
    const rotDX2 = faceData[3].subtract(faceData[2]).scale(1 / texSize);
    const dy = 1 / texSize;
    let fy = 0;
    for (let y = 0; y < texSize; y++) {
      let xv1 = faceData[0];
      let xv2 = faceData[2];
      for (let x = 0; x < texSize; x++) {
        const v = xv2.subtract(xv1).scale(fy).add(xv1);
        v.normalize();
        const color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);
        textureArray[y * texSize * 3 + x * 3 + 0] = color.r;
        textureArray[y * texSize * 3 + x * 3 + 1] = color.g;
        textureArray[y * texSize * 3 + x * 3 + 2] = color.b;
        xv1 = xv1.add(rotDX1);
        xv2 = xv2.add(rotDX2);
      }
      fy += dy;
    }
    return textureArray;
  }
  static CalcProjectionSpherical(vDir, float32Array, inputWidth, inputHeight) {
    let theta = Math.atan2(vDir.z, vDir.x);
    const phi = Math.acos(vDir.y);
    while (theta < -Math.PI) {
      theta += 2 * Math.PI;
    }
    while (theta > Math.PI) {
      theta -= 2 * Math.PI;
    }
    let dx = theta / Math.PI;
    const dy = phi / Math.PI;
    dx = dx * 0.5 + 0.5;
    let px = Math.round(dx * inputWidth);
    if (px < 0) {
      px = 0;
    } else if (px >= inputWidth) {
      px = inputWidth - 1;
    }
    let py = Math.round(dy * inputHeight);
    if (py < 0) {
      py = 0;
    } else if (py >= inputHeight) {
      py = inputHeight - 1;
    }
    const inputY = inputHeight - py - 1;
    const r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];
    const g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];
    const b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];
    return {
      r,
      g,
      b
    };
  }
};
PanoramaToCubeMapTools.FACE_LEFT = [new Vector3(-1, -1, -1), new Vector3(1, -1, -1), new Vector3(-1, 1, -1), new Vector3(1, 1, -1)];
PanoramaToCubeMapTools.FACE_RIGHT = [new Vector3(1, -1, 1), new Vector3(-1, -1, 1), new Vector3(1, 1, 1), new Vector3(-1, 1, 1)];
PanoramaToCubeMapTools.FACE_FRONT = [new Vector3(1, -1, -1), new Vector3(1, -1, 1), new Vector3(1, 1, -1), new Vector3(1, 1, 1)];
PanoramaToCubeMapTools.FACE_BACK = [new Vector3(-1, -1, 1), new Vector3(-1, -1, -1), new Vector3(-1, 1, 1), new Vector3(-1, 1, -1)];
PanoramaToCubeMapTools.FACE_DOWN = [new Vector3(1, 1, -1), new Vector3(1, 1, 1), new Vector3(-1, 1, -1), new Vector3(-1, 1, 1)];
PanoramaToCubeMapTools.FACE_UP = [new Vector3(-1, -1, -1), new Vector3(-1, -1, 1), new Vector3(1, -1, -1), new Vector3(1, -1, 1)];

// node_modules/@babylonjs/core/Misc/HighDynamicRange/hdr.js
var HDRTools = class {
  static _Ldexp(mantissa, exponent) {
    if (exponent > 1023) {
      return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);
    }
    if (exponent < -1074) {
      return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);
    }
    return mantissa * Math.pow(2, exponent);
  }
  static _Rgbe2float(float32array, red, green, blue, exponent, index) {
    if (exponent > 0) {
      exponent = this._Ldexp(1, exponent - (128 + 8));
      float32array[index + 0] = red * exponent;
      float32array[index + 1] = green * exponent;
      float32array[index + 2] = blue * exponent;
    } else {
      float32array[index + 0] = 0;
      float32array[index + 1] = 0;
      float32array[index + 2] = 0;
    }
  }
  static _ReadStringLine(uint8array, startIndex) {
    let line = "";
    let character = "";
    for (let i = startIndex; i < uint8array.length - startIndex; i++) {
      character = String.fromCharCode(uint8array[i]);
      if (character == "\n") {
        break;
      }
      line += character;
    }
    return line;
  }
  static RGBE_ReadHeader(uint8array) {
    let height = 0;
    let width = 0;
    let line = this._ReadStringLine(uint8array, 0);
    if (line[0] != "#" || line[1] != "?") {
      throw "Bad HDR Format.";
    }
    let endOfHeader = false;
    let findFormat = false;
    let lineIndex = 0;
    do {
      lineIndex += line.length + 1;
      line = this._ReadStringLine(uint8array, lineIndex);
      if (line == "FORMAT=32-bit_rle_rgbe") {
        findFormat = true;
      } else if (line.length == 0) {
        endOfHeader = true;
      }
    } while (!endOfHeader);
    if (!findFormat) {
      throw "HDR Bad header format, unsupported FORMAT";
    }
    lineIndex += line.length + 1;
    line = this._ReadStringLine(uint8array, lineIndex);
    const sizeRegexp = /^-Y (.*) \+X (.*)$/g;
    const match = sizeRegexp.exec(line);
    if (!match || match.length < 3) {
      throw "HDR Bad header format, no size";
    }
    width = parseInt(match[2]);
    height = parseInt(match[1]);
    if (width < 8 || width > 32767) {
      throw "HDR Bad header format, unsupported size";
    }
    lineIndex += line.length + 1;
    return {
      height,
      width,
      dataPosition: lineIndex
    };
  }
  static GetCubeMapTextureData(buffer, size) {
    const uint8array = new Uint8Array(buffer);
    const hdrInfo = this.RGBE_ReadHeader(uint8array);
    const data = this.RGBE_ReadPixels(uint8array, hdrInfo);
    const cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size);
    return cubeMapData;
  }
  static RGBE_ReadPixels(uint8array, hdrInfo) {
    return this._RGBEReadPixelsRLE(uint8array, hdrInfo);
  }
  static _RGBEReadPixelsRLE(uint8array, hdrInfo) {
    let num_scanlines = hdrInfo.height;
    const scanline_width = hdrInfo.width;
    let a, b, c, d, count;
    let dataIndex = hdrInfo.dataPosition;
    let index = 0, endIndex = 0, i = 0;
    const scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4);
    const scanLineArray = new Uint8Array(scanLineArrayBuffer);
    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);
    const resultArray = new Float32Array(resultBuffer);
    while (num_scanlines > 0) {
      a = uint8array[dataIndex++];
      b = uint8array[dataIndex++];
      c = uint8array[dataIndex++];
      d = uint8array[dataIndex++];
      if (a != 2 || b != 2 || c & 128 || hdrInfo.width < 8 || hdrInfo.width > 32767) {
        return this._RGBEReadPixelsNOTRLE(uint8array, hdrInfo);
      }
      if ((c << 8 | d) != scanline_width) {
        throw "HDR Bad header format, wrong scan line width";
      }
      index = 0;
      for (i = 0; i < 4; i++) {
        endIndex = (i + 1) * scanline_width;
        while (index < endIndex) {
          a = uint8array[dataIndex++];
          b = uint8array[dataIndex++];
          if (a > 128) {
            count = a - 128;
            if (count == 0 || count > endIndex - index) {
              throw "HDR Bad Format, bad scanline data (run)";
            }
            while (count-- > 0) {
              scanLineArray[index++] = b;
            }
          } else {
            count = a;
            if (count == 0 || count > endIndex - index) {
              throw "HDR Bad Format, bad scanline data (non-run)";
            }
            scanLineArray[index++] = b;
            if (--count > 0) {
              for (let j = 0; j < count; j++) {
                scanLineArray[index++] = uint8array[dataIndex++];
              }
            }
          }
        }
      }
      for (i = 0; i < scanline_width; i++) {
        a = scanLineArray[i];
        b = scanLineArray[i + scanline_width];
        c = scanLineArray[i + 2 * scanline_width];
        d = scanLineArray[i + 3 * scanline_width];
        this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);
      }
      num_scanlines--;
    }
    return resultArray;
  }
  static _RGBEReadPixelsNOTRLE(uint8array, hdrInfo) {
    let num_scanlines = hdrInfo.height;
    const scanline_width = hdrInfo.width;
    let a, b, c, d, i;
    let dataIndex = hdrInfo.dataPosition;
    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);
    const resultArray = new Float32Array(resultBuffer);
    while (num_scanlines > 0) {
      for (i = 0; i < hdrInfo.width; i++) {
        a = uint8array[dataIndex++];
        b = uint8array[dataIndex++];
        c = uint8array[dataIndex++];
        d = uint8array[dataIndex++];
        this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);
      }
      num_scanlines--;
    }
    return resultArray;
  }
};

// node_modules/@babylonjs/core/Shaders/hdrFiltering.vertex.js
var name62 = "hdrFilteringVertexShader";
var shader62 = `attribute vec2 position;
varying vec3 direction;
uniform vec3 up;
uniform vec3 right;
uniform vec3 front;
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
mat3 view=mat3(up,right,front);
direction=view*vec3(position,1.0);
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name62] = shader62;

// node_modules/@babylonjs/core/Shaders/hdrFiltering.fragment.js
var name63 = "hdrFilteringPixelShader";
var shader63 = `#include<helperFunctions>
#include<importanceSampling>
#include<pbrBRDFFunctions>
#include<hdrFilteringFunctions>
uniform float alphaG;
uniform samplerCube inputTexture;
uniform vec2 vFilteringInfo;
uniform float hdrScale;
varying vec3 direction;
void main() {
vec3 color=radiance(alphaG,inputTexture,direction,vFilteringInfo);
gl_FragColor=vec4(color*hdrScale,1.0);
}`;
ShaderStore.ShadersStore[name63] = shader63;

// node_modules/@babylonjs/core/Materials/Textures/Filtering/hdrFiltering.js
var HDRFiltering = class {
  constructor(engine, options = {}) {
    this._lodGenerationOffset = 0;
    this._lodGenerationScale = 0.8;
    this.quality = 4096;
    this.hdrScale = 1;
    this._engine = engine;
    this.hdrScale = options.hdrScale || this.hdrScale;
    this.quality = options.quality || this.quality;
  }
  _createRenderTarget(size) {
    let textureType = 0;
    if (this._engine.getCaps().textureHalfFloatRender) {
      textureType = 2;
    } else if (this._engine.getCaps().textureFloatRender) {
      textureType = 1;
    }
    const rtWrapper = this._engine.createRenderTargetCubeTexture(size, {
      format: 5,
      type: textureType,
      createMipMaps: true,
      generateMipMaps: false,
      generateDepthBuffer: false,
      generateStencilBuffer: false,
      samplingMode: 1
    });
    this._engine.updateTextureWrappingMode(rtWrapper.texture, 0, 0, 0);
    this._engine.updateTextureSamplingMode(3, rtWrapper.texture, true);
    return rtWrapper;
  }
  _prefilterInternal(texture) {
    const width = texture.getSize().width;
    const mipmapsCount = Scalar.ILog2(width) + 1;
    const effect = this._effectWrapper.effect;
    const outputTexture = this._createRenderTarget(width);
    this._effectRenderer.setViewport();
    const intTexture = texture.getInternalTexture();
    if (intTexture) {
      this._engine.updateTextureSamplingMode(3, intTexture, true);
    }
    this._effectRenderer.applyEffectWrapper(this._effectWrapper);
    const directions = [
      [new Vector3(0, 0, -1), new Vector3(0, -1, 0), new Vector3(1, 0, 0)],
      [new Vector3(0, 0, 1), new Vector3(0, -1, 0), new Vector3(-1, 0, 0)],
      [new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 1, 0)],
      [new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)],
      [new Vector3(1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1)],
      [new Vector3(-1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, -1)]
    ];
    effect.setFloat("hdrScale", this.hdrScale);
    effect.setFloat2("vFilteringInfo", texture.getSize().width, mipmapsCount);
    effect.setTexture("inputTexture", texture);
    for (let face = 0; face < 6; face++) {
      effect.setVector3("up", directions[face][0]);
      effect.setVector3("right", directions[face][1]);
      effect.setVector3("front", directions[face][2]);
      for (let lod = 0; lod < mipmapsCount; lod++) {
        this._engine.bindFramebuffer(outputTexture, face, void 0, void 0, true, lod);
        this._effectRenderer.applyEffectWrapper(this._effectWrapper);
        let alpha = Math.pow(2, (lod - this._lodGenerationOffset) / this._lodGenerationScale) / width;
        if (lod === 0) {
          alpha = 0;
        }
        effect.setFloat("alphaG", alpha);
        this._effectRenderer.draw();
      }
    }
    this._effectRenderer.restoreStates();
    this._engine.restoreDefaultFramebuffer();
    this._engine._releaseTexture(texture._texture);
    outputTexture._swapAndDie(texture._texture);
    texture._prefiltered = true;
    return texture;
  }
  _createEffect(texture, onCompiled) {
    const defines = [];
    if (texture.gammaSpace) {
      defines.push("#define GAMMA_INPUT");
    }
    defines.push("#define NUM_SAMPLES " + this.quality + "u");
    const effectWrapper = new EffectWrapper({
      engine: this._engine,
      name: "hdrFiltering",
      vertexShader: "hdrFiltering",
      fragmentShader: "hdrFiltering",
      samplerNames: ["inputTexture"],
      uniformNames: ["vSampleDirections", "vWeights", "up", "right", "front", "vFilteringInfo", "hdrScale", "alphaG"],
      useShaderStore: true,
      defines,
      onCompiled
    });
    return effectWrapper;
  }
  isReady(texture) {
    return texture.isReady() && this._effectWrapper.effect.isReady();
  }
  prefilter(texture, onFinished = null) {
    if (!this._engine._features.allowTexturePrefiltering) {
      Logger.Warn("HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.");
      return Promise.reject("HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.");
    }
    return new Promise((resolve) => {
      this._effectRenderer = new EffectRenderer(this._engine);
      this._effectWrapper = this._createEffect(texture);
      this._effectWrapper.effect.executeWhenCompiled(() => {
        this._prefilterInternal(texture);
        this._effectRenderer.dispose();
        this._effectWrapper.dispose();
        resolve();
        if (onFinished) {
          onFinished();
        }
      });
    });
  }
};

// node_modules/@babylonjs/core/Materials/Textures/hdrCubeTexture.js
var HDRCubeTexture = class extends BaseTexture {
  constructor(url, sceneOrEngine, size, noMipmap = false, generateHarmonics = true, gammaSpace = false, prefilterOnLoad = false, onLoad = null, onError = null) {
    var _a;
    super(sceneOrEngine);
    this._generateHarmonics = true;
    this._onError = null;
    this._isBlocking = true;
    this._rotationY = 0;
    this.boundingBoxPosition = Vector3.Zero();
    this.onLoadObservable = new Observable();
    if (!url) {
      return;
    }
    this._coordinatesMode = Texture.CUBIC_MODE;
    this.name = url;
    this.url = url;
    this.hasAlpha = false;
    this.isCube = true;
    this._textureMatrix = Matrix.Identity();
    this._prefilterOnLoad = prefilterOnLoad;
    this._onLoad = () => {
      this.onLoadObservable.notifyObservers(this);
      if (onLoad) {
        onLoad();
      }
    };
    this._onError = onError;
    this.gammaSpace = gammaSpace;
    this._noMipmap = noMipmap;
    this._size = size;
    this._generateHarmonics = generateHarmonics;
    this._texture = this._getFromCache(url, this._noMipmap, void 0, void 0, void 0, this.isCube);
    if (!this._texture) {
      if (!((_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.useDelayedTextureLoading)) {
        this._loadTexture();
      } else {
        this.delayLoadState = 4;
      }
    } else {
      if (this._texture.isReady) {
        Tools.SetImmediate(() => this._onLoad());
      } else {
        this._texture.onLoadedObservable.add(this._onLoad);
      }
    }
  }
  set isBlocking(value) {
    this._isBlocking = value;
  }
  get isBlocking() {
    return this._isBlocking;
  }
  set rotationY(value) {
    this._rotationY = value;
    this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));
  }
  get rotationY() {
    return this._rotationY;
  }
  set boundingBoxSize(value) {
    if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
      return;
    }
    this._boundingBoxSize = value;
    const scene = this.getScene();
    if (scene) {
      scene.markAllMaterialsAsDirty(1);
    }
  }
  get boundingBoxSize() {
    return this._boundingBoxSize;
  }
  getClassName() {
    return "HDRCubeTexture";
  }
  _loadTexture() {
    const engine = this._getEngine();
    const caps = engine.getCaps();
    let textureType = 0;
    if (caps.textureFloat && caps.textureFloatLinearFiltering) {
      textureType = 1;
    } else if (caps.textureHalfFloat && caps.textureHalfFloatLinearFiltering) {
      textureType = 2;
    }
    const callback = (buffer) => {
      this.lodGenerationOffset = 0;
      this.lodGenerationScale = 0.8;
      const data = HDRTools.GetCubeMapTextureData(buffer, this._size);
      if (this._generateHarmonics) {
        const sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial(data);
        this.sphericalPolynomial = sphericalPolynomial;
      }
      const results = [];
      let byteArray = null;
      let shortArray = null;
      for (let j = 0; j < 6; j++) {
        if (textureType === 2) {
          shortArray = new Uint16Array(this._size * this._size * 3);
        } else if (textureType === 0) {
          byteArray = new Uint8Array(this._size * this._size * 3);
        }
        const dataFace = data[HDRCubeTexture._FacesMapping[j]];
        if (this.gammaSpace || shortArray || byteArray) {
          for (let i = 0; i < this._size * this._size; i++) {
            if (this.gammaSpace) {
              dataFace[i * 3 + 0] = Math.pow(dataFace[i * 3 + 0], ToGammaSpace);
              dataFace[i * 3 + 1] = Math.pow(dataFace[i * 3 + 1], ToGammaSpace);
              dataFace[i * 3 + 2] = Math.pow(dataFace[i * 3 + 2], ToGammaSpace);
            }
            if (shortArray) {
              shortArray[i * 3 + 0] = ToHalfFloat(dataFace[i * 3 + 0]);
              shortArray[i * 3 + 1] = ToHalfFloat(dataFace[i * 3 + 1]);
              shortArray[i * 3 + 2] = ToHalfFloat(dataFace[i * 3 + 2]);
            }
            if (byteArray) {
              let r = Math.max(dataFace[i * 3 + 0] * 255, 0);
              let g = Math.max(dataFace[i * 3 + 1] * 255, 0);
              let b = Math.max(dataFace[i * 3 + 2] * 255, 0);
              const max = Math.max(Math.max(r, g), b);
              if (max > 255) {
                const scale = 255 / max;
                r *= scale;
                g *= scale;
                b *= scale;
              }
              byteArray[i * 3 + 0] = r;
              byteArray[i * 3 + 1] = g;
              byteArray[i * 3 + 2] = b;
            }
          }
        }
        if (shortArray) {
          results.push(shortArray);
        } else if (byteArray) {
          results.push(byteArray);
        } else {
          results.push(dataFace);
        }
      }
      return results;
    };
    if (engine._features.allowTexturePrefiltering && this._prefilterOnLoad) {
      const previousOnLoad = this._onLoad;
      const hdrFiltering = new HDRFiltering(engine);
      this._onLoad = () => {
        hdrFiltering.prefilter(this, previousOnLoad);
      };
    }
    this._texture = engine.createRawCubeTextureFromUrl(this.url, this.getScene(), this._size, 4, textureType, this._noMipmap, callback, null, this._onLoad, this._onError);
  }
  clone() {
    const newTexture = new HDRCubeTexture(this.url, this.getScene() || this._getEngine(), this._size, this._noMipmap, this._generateHarmonics, this.gammaSpace);
    newTexture.level = this.level;
    newTexture.wrapU = this.wrapU;
    newTexture.wrapV = this.wrapV;
    newTexture.coordinatesIndex = this.coordinatesIndex;
    newTexture.coordinatesMode = this.coordinatesMode;
    return newTexture;
  }
  delayLoad() {
    if (this.delayLoadState !== 4) {
      return;
    }
    this.delayLoadState = 1;
    this._texture = this._getFromCache(this.url, this._noMipmap);
    if (!this._texture) {
      this._loadTexture();
    }
  }
  getReflectionTextureMatrix() {
    return this._textureMatrix;
  }
  setReflectionTextureMatrix(value) {
    var _a;
    this._textureMatrix = value;
    if (value.updateFlag === this._textureMatrix.updateFlag) {
      return;
    }
    if (value.isIdentity() !== this._textureMatrix.isIdentity()) {
      (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1, (mat) => mat.getActiveTextures().indexOf(this) !== -1);
    }
  }
  dispose() {
    this.onLoadObservable.clear();
    super.dispose();
  }
  static Parse(parsedTexture, scene, rootUrl) {
    let texture = null;
    if (parsedTexture.name && !parsedTexture.isRenderTarget) {
      texture = new HDRCubeTexture(rootUrl + parsedTexture.name, scene, parsedTexture.size, parsedTexture.noMipmap, parsedTexture.generateHarmonics, parsedTexture.useInGammaSpace);
      texture.name = parsedTexture.name;
      texture.hasAlpha = parsedTexture.hasAlpha;
      texture.level = parsedTexture.level;
      texture.coordinatesMode = parsedTexture.coordinatesMode;
      texture.isBlocking = parsedTexture.isBlocking;
    }
    if (texture) {
      if (parsedTexture.boundingBoxPosition) {
        texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);
      }
      if (parsedTexture.boundingBoxSize) {
        texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);
      }
      if (parsedTexture.rotationY) {
        texture.rotationY = parsedTexture.rotationY;
      }
    }
    return texture;
  }
  serialize() {
    if (!this.name) {
      return null;
    }
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.hasAlpha = this.hasAlpha;
    serializationObject.isCube = true;
    serializationObject.level = this.level;
    serializationObject.size = this._size;
    serializationObject.coordinatesMode = this.coordinatesMode;
    serializationObject.useInGammaSpace = this.gammaSpace;
    serializationObject.generateHarmonics = this._generateHarmonics;
    serializationObject.customType = "BABYLON.HDRCubeTexture";
    serializationObject.noMipmap = this._noMipmap;
    serializationObject.isBlocking = this._isBlocking;
    serializationObject.rotationY = this._rotationY;
    return serializationObject;
  }
};
HDRCubeTexture._FacesMapping = ["right", "left", "up", "down", "front", "back"];
RegisterClass("BABYLON.HDRCubeTexture", HDRCubeTexture);

// node_modules/@babylonjs/core/Physics/physicsRaycastResult.js
var PhysicsRaycastResult = class {
  constructor() {
    this._hasHit = false;
    this._hitDistance = 0;
    this._hitNormalWorld = Vector3.Zero();
    this._hitPointWorld = Vector3.Zero();
    this._rayFromWorld = Vector3.Zero();
    this._rayToWorld = Vector3.Zero();
  }
  get hasHit() {
    return this._hasHit;
  }
  get hitDistance() {
    return this._hitDistance;
  }
  get hitNormalWorld() {
    return this._hitNormalWorld;
  }
  get hitPointWorld() {
    return this._hitPointWorld;
  }
  get rayFromWorld() {
    return this._rayFromWorld;
  }
  get rayToWorld() {
    return this._rayToWorld;
  }
  setHitData(hitNormalWorld, hitPointWorld) {
    this._hasHit = true;
    this._hitNormalWorld = new Vector3(hitNormalWorld.x, hitNormalWorld.y, hitNormalWorld.z);
    this._hitPointWorld = new Vector3(hitPointWorld.x, hitPointWorld.y, hitPointWorld.z);
  }
  setHitDistance(distance) {
    this._hitDistance = distance;
  }
  calculateHitDistance() {
    this._hitDistance = Vector3.Distance(this._rayFromWorld, this._hitPointWorld);
  }
  reset(from = Vector3.Zero(), to = Vector3.Zero()) {
    this._rayFromWorld = from;
    this._rayToWorld = to;
    this._hasHit = false;
    this._hitDistance = 0;
    this._hitNormalWorld = Vector3.Zero();
    this._hitPointWorld = Vector3.Zero();
  }
};

// node_modules/@babylonjs/core/Physics/v1/physicsEngine.js
var PhysicsEngine = class {
  constructor(gravity, _physicsPlugin = PhysicsEngine.DefaultPluginFactory()) {
    this._physicsPlugin = _physicsPlugin;
    this._impostors = [];
    this._joints = [];
    this._subTimeStep = 0;
    this._uniqueIdCounter = 0;
    if (!this._physicsPlugin.isSupported()) {
      throw new Error("Physics Engine " + this._physicsPlugin.name + " cannot be found. Please make sure it is included.");
    }
    gravity = gravity || new Vector3(0, -9.807, 0);
    this.setGravity(gravity);
    this.setTimeStep();
  }
  getPluginVersion() {
    return this._physicsPlugin.getPluginVersion();
  }
  static DefaultPluginFactory() {
    throw _WarnImport("CannonJSPlugin");
  }
  setGravity(gravity) {
    this.gravity = gravity;
    this._physicsPlugin.setGravity(this.gravity);
  }
  setTimeStep(newTimeStep = 1 / 60) {
    this._physicsPlugin.setTimeStep(newTimeStep);
  }
  getTimeStep() {
    return this._physicsPlugin.getTimeStep();
  }
  setSubTimeStep(subTimeStep = 0) {
    this._subTimeStep = subTimeStep;
  }
  getSubTimeStep() {
    return this._subTimeStep;
  }
  dispose() {
    this._impostors.forEach(function(impostor) {
      impostor.dispose();
    });
    this._physicsPlugin.dispose();
  }
  getPhysicsPluginName() {
    return this._physicsPlugin.name;
  }
  addImpostor(impostor) {
    this._impostors.push(impostor);
    impostor.uniqueId = this._uniqueIdCounter++;
    if (!impostor.parent) {
      this._physicsPlugin.generatePhysicsBody(impostor);
    }
  }
  removeImpostor(impostor) {
    const index = this._impostors.indexOf(impostor);
    if (index > -1) {
      const removed = this._impostors.splice(index, 1);
      if (removed.length) {
        this.getPhysicsPlugin().removePhysicsBody(impostor);
      }
    }
  }
  addJoint(mainImpostor, connectedImpostor, joint) {
    const impostorJoint = {
      mainImpostor,
      connectedImpostor,
      joint
    };
    joint.physicsPlugin = this._physicsPlugin;
    this._joints.push(impostorJoint);
    this._physicsPlugin.generateJoint(impostorJoint);
  }
  removeJoint(mainImpostor, connectedImpostor, joint) {
    const matchingJoints = this._joints.filter(function(impostorJoint) {
      return impostorJoint.connectedImpostor === connectedImpostor && impostorJoint.joint === joint && impostorJoint.mainImpostor === mainImpostor;
    });
    if (matchingJoints.length) {
      this._physicsPlugin.removeJoint(matchingJoints[0]);
    }
  }
  _step(delta) {
    this._impostors.forEach((impostor) => {
      if (impostor.isBodyInitRequired()) {
        this._physicsPlugin.generatePhysicsBody(impostor);
      }
    });
    if (delta > 0.1) {
      delta = 0.1;
    } else if (delta <= 0) {
      delta = 1 / 60;
    }
    this._physicsPlugin.executeStep(delta, this._impostors);
  }
  getPhysicsPlugin() {
    return this._physicsPlugin;
  }
  getImpostors() {
    return this._impostors;
  }
  getImpostorForPhysicsObject(object) {
    for (let i = 0; i < this._impostors.length; ++i) {
      if (this._impostors[i].object === object) {
        return this._impostors[i];
      }
    }
    return null;
  }
  getImpostorWithPhysicsBody(body) {
    for (let i = 0; i < this._impostors.length; ++i) {
      if (this._impostors[i].physicsBody === body) {
        return this._impostors[i];
      }
    }
    return null;
  }
  raycast(from, to) {
    return this._physicsPlugin.raycast(from, to);
  }
  raycastToRef(from, to, result) {
    return this._physicsPlugin.raycastToRef(from, to, result);
  }
};

// node_modules/@babylonjs/core/Physics/v1/Plugins/cannonJSPlugin.js
var CannonJSPlugin = class {
  constructor(_useDeltaForWorldStep = true, iterations = 10, cannonInjection = CANNON) {
    this._useDeltaForWorldStep = _useDeltaForWorldStep;
    this.name = "CannonJSPlugin";
    this._physicsMaterials = new Array();
    this._fixedTimeStep = 1 / 60;
    this._physicsBodiesToRemoveAfterStep = new Array();
    this._firstFrame = true;
    this._tmpQuaternion = new Quaternion();
    this._minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);
    this._plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);
    this._tmpPosition = Vector3.Zero();
    this._tmpDeltaPosition = Vector3.Zero();
    this._tmpUnityRotation = new Quaternion();
    this.BJSCANNON = cannonInjection;
    if (!this.isSupported()) {
      Logger.Error("CannonJS is not available. Please make sure you included the js file.");
      return;
    }
    this._extendNamespace();
    this.world = new this.BJSCANNON.World();
    this.world.broadphase = new this.BJSCANNON.NaiveBroadphase();
    this.world.solver.iterations = iterations;
    this._cannonRaycastResult = new this.BJSCANNON.RaycastResult();
    this._raycastResult = new PhysicsRaycastResult();
  }
  getPluginVersion() {
    return 1;
  }
  setGravity(gravity) {
    const vec = gravity;
    this.world.gravity.set(vec.x, vec.y, vec.z);
  }
  setTimeStep(timeStep) {
    this._fixedTimeStep = timeStep;
  }
  getTimeStep() {
    return this._fixedTimeStep;
  }
  executeStep(delta, impostors) {
    if (this._firstFrame) {
      this._firstFrame = false;
      for (const impostor of impostors) {
        if (!(impostor.type == PhysicsImpostor.HeightmapImpostor || impostor.type === PhysicsImpostor.PlaneImpostor)) {
          impostor.beforeStep();
        }
      }
    }
    this.world.step(this._useDeltaForWorldStep ? delta : this._fixedTimeStep);
    this._removeMarkedPhysicsBodiesFromWorld();
  }
  _removeMarkedPhysicsBodiesFromWorld() {
    if (this._physicsBodiesToRemoveAfterStep.length > 0) {
      this._physicsBodiesToRemoveAfterStep.forEach((physicsBody) => {
        if (typeof this.world.removeBody === "function") {
          this.world.removeBody(physicsBody);
        } else {
          this.world.remove(physicsBody);
        }
      });
      this._physicsBodiesToRemoveAfterStep.length = 0;
    }
  }
  applyImpulse(impostor, force, contactPoint) {
    const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);
    const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);
    impostor.physicsBody.applyImpulse(impulse, worldPoint);
  }
  applyForce(impostor, force, contactPoint) {
    const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);
    const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);
    impostor.physicsBody.applyForce(impulse, worldPoint);
  }
  generatePhysicsBody(impostor) {
    this._removeMarkedPhysicsBodiesFromWorld();
    if (impostor.parent) {
      if (impostor.physicsBody) {
        this.removePhysicsBody(impostor);
        impostor.forceUpdate();
      }
      return;
    }
    if (impostor.isBodyInitRequired()) {
      const shape = this._createShape(impostor);
      if (!shape) {
        Logger.Warn("It was not possible to create a physics body for this object.");
        return;
      }
      const oldBody = impostor.physicsBody;
      if (oldBody) {
        this.removePhysicsBody(impostor);
      }
      const material = this._addMaterial("mat-" + impostor.uniqueId, impostor.getParam("friction"), impostor.getParam("restitution"));
      const bodyCreationObject = {
        mass: impostor.getParam("mass"),
        material
      };
      const nativeOptions = impostor.getParam("nativeOptions");
      for (const key in nativeOptions) {
        if (Object.prototype.hasOwnProperty.call(nativeOptions, key)) {
          bodyCreationObject[key] = nativeOptions[key];
        }
      }
      impostor.physicsBody = new this.BJSCANNON.Body(bodyCreationObject);
      impostor.physicsBody.addEventListener("collide", impostor.onCollide);
      this.world.addEventListener("preStep", impostor.beforeStep);
      this.world.addEventListener("postStep", impostor.afterStep);
      impostor.physicsBody.addShape(shape);
      if (typeof this.world.addBody === "function") {
        this.world.addBody(impostor.physicsBody);
      } else {
        this.world.add(impostor.physicsBody);
      }
      if (oldBody) {
        ["force", "torque", "velocity", "angularVelocity"].forEach(function(param) {
          const vec = oldBody[param];
          impostor.physicsBody[param].set(vec.x, vec.y, vec.z);
        });
      }
      this._processChildMeshes(impostor);
    }
    this._updatePhysicsBodyTransformation(impostor);
  }
  _processChildMeshes(mainImpostor) {
    const meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];
    const mainRotation = mainImpostor.object.rotationQuaternion;
    if (mainRotation) {
      mainRotation.conjugateToRef(this._tmpQuaternion);
    } else {
      this._tmpQuaternion.set(0, 0, 0, 1);
    }
    if (meshChildren.length) {
      const processMesh = (mesh) => {
        if (!mesh.rotationQuaternion) {
          return;
        }
        const childImpostor = mesh.getPhysicsImpostor();
        if (childImpostor) {
          const parent = childImpostor.parent;
          if (parent !== mainImpostor && mesh.parent) {
            const pPosition = mesh.getAbsolutePosition().subtract(mesh.parent.getAbsolutePosition());
            const q = mesh.rotationQuaternion.multiply(this._tmpQuaternion);
            if (childImpostor.physicsBody) {
              this.removePhysicsBody(childImpostor);
              childImpostor.physicsBody = null;
            }
            childImpostor.parent = mainImpostor;
            childImpostor.resetUpdateFlags();
            mainImpostor.physicsBody.addShape(this._createShape(childImpostor), new this.BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z), new this.BJSCANNON.Quaternion(q.x, q.y, q.z, q.w));
            mainImpostor.physicsBody.mass += childImpostor.getParam("mass");
          }
        }
        mesh.getChildMeshes(true).filter((m) => !!m.physicsImpostor).forEach(processMesh);
      };
      meshChildren.filter((m) => !!m.physicsImpostor).forEach(processMesh);
    }
  }
  removePhysicsBody(impostor) {
    impostor.physicsBody.removeEventListener("collide", impostor.onCollide);
    this.world.removeEventListener("preStep", impostor.beforeStep);
    this.world.removeEventListener("postStep", impostor.afterStep);
    if (this._physicsBodiesToRemoveAfterStep.indexOf(impostor.physicsBody) === -1) {
      this._physicsBodiesToRemoveAfterStep.push(impostor.physicsBody);
    }
  }
  generateJoint(impostorJoint) {
    const mainBody = impostorJoint.mainImpostor.physicsBody;
    const connectedBody = impostorJoint.connectedImpostor.physicsBody;
    if (!mainBody || !connectedBody) {
      return;
    }
    let constraint;
    const jointData = impostorJoint.joint.jointData;
    const constraintData = {
      pivotA: jointData.mainPivot ? new this.BJSCANNON.Vec3().set(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z) : null,
      pivotB: jointData.connectedPivot ? new this.BJSCANNON.Vec3().set(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z) : null,
      axisA: jointData.mainAxis ? new this.BJSCANNON.Vec3().set(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z) : null,
      axisB: jointData.connectedAxis ? new this.BJSCANNON.Vec3().set(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z) : null,
      maxForce: jointData.nativeParams.maxForce,
      collideConnected: !!jointData.collision
    };
    switch (impostorJoint.joint.type) {
      case PhysicsJoint.HingeJoint:
      case PhysicsJoint.Hinge2Joint:
        constraint = new this.BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);
        break;
      case PhysicsJoint.DistanceJoint:
        constraint = new this.BJSCANNON.DistanceConstraint(mainBody, connectedBody, jointData.maxDistance || 2);
        break;
      case PhysicsJoint.SpringJoint: {
        const springData = jointData;
        constraint = new this.BJSCANNON.Spring(mainBody, connectedBody, {
          restLength: springData.length,
          stiffness: springData.stiffness,
          damping: springData.damping,
          localAnchorA: constraintData.pivotA,
          localAnchorB: constraintData.pivotB
        });
        break;
      }
      case PhysicsJoint.LockJoint:
        constraint = new this.BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);
        break;
      case PhysicsJoint.PointToPointJoint:
      case PhysicsJoint.BallAndSocketJoint:
      default:
        constraint = new this.BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotB, constraintData.maxForce);
        break;
    }
    constraint.collideConnected = !!jointData.collision;
    impostorJoint.joint.physicsJoint = constraint;
    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {
      this.world.addConstraint(constraint);
    } else {
      impostorJoint.joint.jointData.forceApplicationCallback = impostorJoint.joint.jointData.forceApplicationCallback || function() {
        constraint.applyForce();
      };
      impostorJoint.mainImpostor.registerAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);
    }
  }
  removeJoint(impostorJoint) {
    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {
      this.world.removeConstraint(impostorJoint.joint.physicsJoint);
    } else {
      impostorJoint.mainImpostor.unregisterAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);
    }
  }
  _addMaterial(name137, friction, restitution) {
    let index;
    let mat;
    for (index = 0; index < this._physicsMaterials.length; index++) {
      mat = this._physicsMaterials[index];
      if (mat.friction === friction && mat.restitution === restitution) {
        return mat;
      }
    }
    const currentMat = new this.BJSCANNON.Material(name137);
    currentMat.friction = friction;
    currentMat.restitution = restitution;
    this._physicsMaterials.push(currentMat);
    return currentMat;
  }
  _checkWithEpsilon(value) {
    return value < Epsilon ? Epsilon : value;
  }
  _createShape(impostor) {
    const object = impostor.object;
    let returnValue;
    const impostorExtents = impostor.getObjectExtents();
    switch (impostor.type) {
      case PhysicsImpostor.SphereImpostor: {
        const radiusX = impostorExtents.x;
        const radiusY = impostorExtents.y;
        const radiusZ = impostorExtents.z;
        returnValue = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);
        break;
      }
      case PhysicsImpostor.CylinderImpostor: {
        let nativeParams = impostor.getParam("nativeOptions");
        if (!nativeParams) {
          nativeParams = {};
        }
        const radiusTop = nativeParams.radiusTop !== void 0 ? nativeParams.radiusTop : this._checkWithEpsilon(impostorExtents.x) / 2;
        const radiusBottom = nativeParams.radiusBottom !== void 0 ? nativeParams.radiusBottom : this._checkWithEpsilon(impostorExtents.x) / 2;
        const height = nativeParams.height !== void 0 ? nativeParams.height : this._checkWithEpsilon(impostorExtents.y);
        const numSegments = nativeParams.numSegments !== void 0 ? nativeParams.numSegments : 16;
        returnValue = new this.BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments);
        const quat = new this.BJSCANNON.Quaternion();
        quat.setFromAxisAngle(new this.BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);
        const translation = new this.BJSCANNON.Vec3(0, 0, 0);
        returnValue.transformAllPoints(translation, quat);
        break;
      }
      case PhysicsImpostor.BoxImpostor: {
        const box = impostorExtents.scale(0.5);
        returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));
        break;
      }
      case PhysicsImpostor.PlaneImpostor:
        Logger.Warn("Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead");
        returnValue = new this.BJSCANNON.Plane();
        break;
      case PhysicsImpostor.MeshImpostor: {
        const rawVerts = object.getVerticesData ? object.getVerticesData(VertexBuffer.PositionKind) : [];
        const rawFaces = object.getIndices ? object.getIndices() : [];
        if (!rawVerts) {
          Logger.Warn("Tried to create a MeshImpostor for an object without vertices. This will fail.");
          return;
        }
        const oldPosition = object.position.clone();
        const oldRotation = object.rotation && object.rotation.clone();
        const oldQuaternion = object.rotationQuaternion && object.rotationQuaternion.clone();
        object.position.copyFromFloats(0, 0, 0);
        object.rotation && object.rotation.copyFromFloats(0, 0, 0);
        object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());
        object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();
        const transform = object.computeWorldMatrix(true);
        const transformedVertices = new Array();
        let index;
        for (index = 0; index < rawVerts.length; index += 3) {
          Vector3.TransformCoordinates(Vector3.FromArray(rawVerts, index), transform).toArray(transformedVertices, index);
        }
        Logger.Warn("MeshImpostor only collides against spheres.");
        returnValue = new this.BJSCANNON.Trimesh(transformedVertices, rawFaces);
        object.position.copyFrom(oldPosition);
        oldRotation && object.rotation && object.rotation.copyFrom(oldRotation);
        oldQuaternion && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion);
        break;
      }
      case PhysicsImpostor.HeightmapImpostor: {
        const oldPosition2 = object.position.clone();
        const oldRotation2 = object.rotation && object.rotation.clone();
        const oldQuaternion2 = object.rotationQuaternion && object.rotationQuaternion.clone();
        object.position.copyFromFloats(0, 0, 0);
        object.rotation && object.rotation.copyFromFloats(0, 0, 0);
        object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());
        object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();
        object.rotationQuaternion && object.rotationQuaternion.multiplyInPlace(this._minus90X);
        returnValue = this._createHeightmap(object);
        object.position.copyFrom(oldPosition2);
        oldRotation2 && object.rotation && object.rotation.copyFrom(oldRotation2);
        oldQuaternion2 && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion2);
        object.computeWorldMatrix(true);
        break;
      }
      case PhysicsImpostor.ParticleImpostor:
        returnValue = new this.BJSCANNON.Particle();
        break;
      case PhysicsImpostor.NoImpostor:
        returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0, 0, 0));
        break;
    }
    return returnValue;
  }
  _createHeightmap(object, pointDepth) {
    let pos = object.getVerticesData(VertexBuffer.PositionKind);
    const transform = object.computeWorldMatrix(true);
    const transformedVertices = new Array();
    let index;
    for (index = 0; index < pos.length; index += 3) {
      Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(transformedVertices, index);
    }
    pos = transformedVertices;
    const matrix = new Array();
    const arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);
    const boundingInfo = object.getBoundingInfo();
    const dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);
    const minY = boundingInfo.boundingBox.extendSizeWorld.z;
    const elementSize = dim * 2 / arraySize;
    for (let i = 0; i < pos.length; i = i + 3) {
      const x = Math.round(pos[i + 0] / elementSize + arraySize / 2);
      const z = Math.round((pos[i + 1] / elementSize - arraySize / 2) * -1);
      const y = -pos[i + 2] + minY;
      if (!matrix[x]) {
        matrix[x] = [];
      }
      if (!matrix[x][z]) {
        matrix[x][z] = y;
      }
      matrix[x][z] = Math.max(y, matrix[x][z]);
    }
    for (let x = 0; x <= arraySize; ++x) {
      if (!matrix[x]) {
        let loc = 1;
        while (!matrix[(x + loc) % arraySize]) {
          loc++;
        }
        matrix[x] = matrix[(x + loc) % arraySize].slice();
      }
      for (let z = 0; z <= arraySize; ++z) {
        if (!matrix[x][z]) {
          let loc = 1;
          let newValue;
          while (newValue === void 0) {
            newValue = matrix[x][(z + loc++) % arraySize];
          }
          matrix[x][z] = newValue;
        }
      }
    }
    const shape = new this.BJSCANNON.Heightfield(matrix, {
      elementSize
    });
    shape.minY = minY;
    return shape;
  }
  _updatePhysicsBodyTransformation(impostor) {
    const object = impostor.object;
    object.computeWorldMatrix && object.computeWorldMatrix(true);
    if (!object.getBoundingInfo()) {
      return;
    }
    const center = impostor.getObjectCenter();
    this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));
    this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);
    this._tmpPosition.copyFrom(center);
    let quaternion = object.rotationQuaternion;
    if (!quaternion) {
      return;
    }
    if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor) {
      quaternion = quaternion.multiply(this._minus90X);
      impostor.setDeltaRotation(this._plus90X);
    }
    if (impostor.type === PhysicsImpostor.HeightmapImpostor) {
      const mesh = object;
      let boundingInfo = mesh.getBoundingInfo();
      const rotationQuaternion = mesh.rotationQuaternion;
      mesh.rotationQuaternion = this._tmpUnityRotation;
      mesh.computeWorldMatrix(true);
      const c = center.clone();
      let oldPivot = mesh.getPivotMatrix();
      if (oldPivot) {
        oldPivot = oldPivot.clone();
      } else {
        oldPivot = Matrix.Identity();
      }
      const p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);
      mesh.setPreTransformMatrix(p);
      mesh.computeWorldMatrix(true);
      boundingInfo = mesh.getBoundingInfo();
      const translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();
      this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z);
      this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));
      this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y;
      mesh.rotationQuaternion = rotationQuaternion;
      mesh.setPreTransformMatrix(oldPivot);
      mesh.computeWorldMatrix(true);
    } else if (impostor.type === PhysicsImpostor.MeshImpostor) {
      this._tmpDeltaPosition.copyFromFloats(0, 0, 0);
    }
    impostor.setDeltaPosition(this._tmpDeltaPosition);
    impostor.physicsBody.position.set(this._tmpPosition.x, this._tmpPosition.y, this._tmpPosition.z);
    impostor.physicsBody.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
  }
  setTransformationFromPhysicsBody(impostor) {
    impostor.object.position.set(impostor.physicsBody.position.x, impostor.physicsBody.position.y, impostor.physicsBody.position.z);
    if (impostor.object.rotationQuaternion) {
      const q = impostor.physicsBody.quaternion;
      impostor.object.rotationQuaternion.set(q.x, q.y, q.z, q.w);
    }
  }
  setPhysicsBodyTransformation(impostor, newPosition, newRotation) {
    impostor.physicsBody.position.set(newPosition.x, newPosition.y, newPosition.z);
    impostor.physicsBody.quaternion.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);
  }
  isSupported() {
    return this.BJSCANNON !== void 0;
  }
  setLinearVelocity(impostor, velocity) {
    impostor.physicsBody.velocity.set(velocity.x, velocity.y, velocity.z);
  }
  setAngularVelocity(impostor, velocity) {
    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);
  }
  getLinearVelocity(impostor) {
    const v = impostor.physicsBody.velocity;
    if (!v) {
      return null;
    }
    return new Vector3(v.x, v.y, v.z);
  }
  getAngularVelocity(impostor) {
    const v = impostor.physicsBody.angularVelocity;
    if (!v) {
      return null;
    }
    return new Vector3(v.x, v.y, v.z);
  }
  setBodyMass(impostor, mass) {
    impostor.physicsBody.mass = mass;
    impostor.physicsBody.updateMassProperties();
  }
  getBodyMass(impostor) {
    return impostor.physicsBody.mass;
  }
  getBodyFriction(impostor) {
    return impostor.physicsBody.material.friction;
  }
  setBodyFriction(impostor, friction) {
    impostor.physicsBody.material.friction = friction;
  }
  getBodyRestitution(impostor) {
    return impostor.physicsBody.material.restitution;
  }
  setBodyRestitution(impostor, restitution) {
    impostor.physicsBody.material.restitution = restitution;
  }
  sleepBody(impostor) {
    impostor.physicsBody.sleep();
  }
  wakeUpBody(impostor) {
    impostor.physicsBody.wakeUp();
  }
  updateDistanceJoint(joint, maxDistance) {
    joint.physicsJoint.distance = maxDistance;
  }
  setMotor(joint, speed, maxForce, motorIndex) {
    if (!motorIndex) {
      joint.physicsJoint.enableMotor();
      joint.physicsJoint.setMotorSpeed(speed);
      if (maxForce) {
        this.setLimit(joint, maxForce);
      }
    }
  }
  setLimit(joint, minForce, maxForce) {
    joint.physicsJoint.motorEquation.maxForce = maxForce;
    joint.physicsJoint.motorEquation.minForce = minForce === void 0 ? -minForce : minForce;
  }
  syncMeshWithImpostor(mesh, impostor) {
    const body = impostor.physicsBody;
    mesh.position.x = body.position.x;
    mesh.position.y = body.position.y;
    mesh.position.z = body.position.z;
    if (mesh.rotationQuaternion) {
      mesh.rotationQuaternion.x = body.quaternion.x;
      mesh.rotationQuaternion.y = body.quaternion.y;
      mesh.rotationQuaternion.z = body.quaternion.z;
      mesh.rotationQuaternion.w = body.quaternion.w;
    }
  }
  getRadius(impostor) {
    const shape = impostor.physicsBody.shapes[0];
    return shape.boundingSphereRadius;
  }
  getBoxSizeToRef(impostor, result) {
    const shape = impostor.physicsBody.shapes[0];
    result.x = shape.halfExtents.x * 2;
    result.y = shape.halfExtents.y * 2;
    result.z = shape.halfExtents.z * 2;
  }
  dispose() {
  }
  _extendNamespace() {
    const step_tmp1 = new this.BJSCANNON.Vec3();
    const engine = this.BJSCANNON;
    this.BJSCANNON.World.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps) {
      maxSubSteps = maxSubSteps || 10;
      timeSinceLastCalled = timeSinceLastCalled || 0;
      if (timeSinceLastCalled === 0) {
        this.internalStep(dt);
        this.time += dt;
      } else {
        let internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
        internalSteps = Math.min(internalSteps, maxSubSteps) || 1;
        const t0 = performance.now();
        for (let i = 0; i !== internalSteps; i++) {
          this.internalStep(dt);
          if (performance.now() - t0 > dt * 1e3) {
            break;
          }
        }
        this.time += timeSinceLastCalled;
        const h = this.time % dt;
        const h_div_dt = h / dt;
        const interpvelo = step_tmp1;
        const bodies = this.bodies;
        for (let j = 0; j !== bodies.length; j++) {
          const b = bodies[j];
          if (b.type !== engine.Body.STATIC && b.sleepState !== engine.Body.SLEEPING) {
            b.position.vsub(b.previousPosition, interpvelo);
            interpvelo.scale(h_div_dt, interpvelo);
            b.position.vadd(interpvelo, b.interpolatedPosition);
          } else {
            b.interpolatedPosition.set(b.position.x, b.position.y, b.position.z);
            b.interpolatedQuaternion.set(b.quaternion.x, b.quaternion.y, b.quaternion.z, b.quaternion.w);
          }
        }
      }
    };
  }
  raycast(from, to) {
    this._raycastResult.reset(from, to);
    this.raycastToRef(from, to, this._raycastResult);
    return this._raycastResult;
  }
  raycastToRef(from, to, result) {
    this._cannonRaycastResult.reset();
    this.world.raycastClosest(from, to, {}, this._cannonRaycastResult);
    result.reset(from, to);
    if (this._cannonRaycastResult.hasHit) {
      result.setHitData({
        x: this._cannonRaycastResult.hitNormalWorld.x,
        y: this._cannonRaycastResult.hitNormalWorld.y,
        z: this._cannonRaycastResult.hitNormalWorld.z
      }, {
        x: this._cannonRaycastResult.hitPointWorld.x,
        y: this._cannonRaycastResult.hitPointWorld.y,
        z: this._cannonRaycastResult.hitPointWorld.z
      });
      result.setHitDistance(this._cannonRaycastResult.distance);
    }
  }
};
PhysicsEngine.DefaultPluginFactory = () => {
  return new CannonJSPlugin();
};

// node_modules/@babylonjs/core/Physics/v1/Plugins/oimoJSPlugin.js
var OimoJSPlugin = class {
  constructor(_useDeltaForWorldStep = true, iterations, oimoInjection = OIMO) {
    this._useDeltaForWorldStep = _useDeltaForWorldStep;
    this.name = "OimoJSPlugin";
    this._fixedTimeStep = 1 / 60;
    this._tmpImpostorsArray = [];
    this._tmpPositionVector = Vector3.Zero();
    this.BJSOIMO = oimoInjection;
    this.world = new this.BJSOIMO.World({
      iterations
    });
    this.world.clear();
    this._raycastResult = new PhysicsRaycastResult();
  }
  getPluginVersion() {
    return 1;
  }
  setGravity(gravity) {
    this.world.gravity.set(gravity.x, gravity.y, gravity.z);
  }
  setTimeStep(timeStep) {
    this.world.timeStep = timeStep;
  }
  getTimeStep() {
    return this.world.timeStep;
  }
  executeStep(delta, impostors) {
    impostors.forEach(function(impostor) {
      impostor.beforeStep();
    });
    this.world.timeStep = this._useDeltaForWorldStep ? delta : this._fixedTimeStep;
    this.world.step();
    impostors.forEach((impostor) => {
      impostor.afterStep();
      this._tmpImpostorsArray[impostor.uniqueId] = impostor;
    });
    let contact = this.world.contacts;
    while (contact !== null) {
      if (contact.touching && !contact.body1.sleeping && !contact.body2.sleeping) {
        contact = contact.next;
        continue;
      }
      const mainImpostor = this._tmpImpostorsArray[+contact.body1.name];
      const collidingImpostor = this._tmpImpostorsArray[+contact.body2.name];
      if (!mainImpostor || !collidingImpostor) {
        contact = contact.next;
        continue;
      }
      mainImpostor.onCollide({ body: collidingImpostor.physicsBody, point: null, distance: 0, impulse: 0, normal: null });
      collidingImpostor.onCollide({ body: mainImpostor.physicsBody, point: null, distance: 0, impulse: 0, normal: null });
      contact = contact.next;
    }
  }
  applyImpulse(impostor, force, contactPoint) {
    const mass = impostor.physicsBody.mass;
    impostor.physicsBody.applyImpulse(contactPoint.scale(this.world.invScale), force.scale(this.world.invScale * mass));
  }
  applyForce(impostor, force, contactPoint) {
    Logger.Warn("Oimo doesn't support applying force. Using impulse instead.");
    this.applyImpulse(impostor, force, contactPoint);
  }
  generatePhysicsBody(impostor) {
    if (impostor.parent) {
      if (impostor.physicsBody) {
        this.removePhysicsBody(impostor);
        impostor.forceUpdate();
      }
      return;
    }
    if (impostor.isBodyInitRequired()) {
      const bodyConfig = {
        name: impostor.uniqueId,
        config: [impostor.getParam("mass") || 1e-3, impostor.getParam("friction"), impostor.getParam("restitution")],
        size: [],
        type: [],
        pos: [],
        posShape: [],
        rot: [],
        rotShape: [],
        move: impostor.getParam("mass") !== 0,
        density: impostor.getParam("mass"),
        friction: impostor.getParam("friction"),
        restitution: impostor.getParam("restitution"),
        world: this.world
      };
      const impostors = [impostor];
      const addToArray = (parent) => {
        if (!parent.getChildMeshes) {
          return;
        }
        parent.getChildMeshes().forEach(function(m) {
          if (m.physicsImpostor) {
            impostors.push(m.physicsImpostor);
          }
        });
      };
      addToArray(impostor.object);
      const checkWithEpsilon = (value) => {
        return Math.max(value, Epsilon);
      };
      const globalQuaternion = new Quaternion();
      impostors.forEach((i) => {
        if (!i.object.rotationQuaternion) {
          return;
        }
        const oldQuaternion = i.object.rotationQuaternion;
        globalQuaternion.copyFrom(oldQuaternion);
        i.object.rotationQuaternion.set(0, 0, 0, 1);
        i.object.computeWorldMatrix(true);
        const rot = globalQuaternion.toEulerAngles();
        const impostorExtents = i.getObjectExtents();
        const radToDeg = 57.29577951308232;
        if (i === impostor) {
          const center = impostor.getObjectCenter();
          impostor.object.getAbsolutePivotPoint().subtractToRef(center, this._tmpPositionVector);
          this._tmpPositionVector.divideInPlace(impostor.object.scaling);
          bodyConfig.pos.push(center.x);
          bodyConfig.pos.push(center.y);
          bodyConfig.pos.push(center.z);
          bodyConfig.posShape.push(0, 0, 0);
          bodyConfig.rotShape.push(0, 0, 0);
        } else {
          const localPosition = i.object.position.clone();
          bodyConfig.posShape.push(localPosition.x);
          bodyConfig.posShape.push(localPosition.y);
          bodyConfig.posShape.push(localPosition.z);
          bodyConfig.rotShape.push(rot.x * radToDeg, rot.y * radToDeg, rot.z * radToDeg);
        }
        i.object.rotationQuaternion.copyFrom(globalQuaternion);
        switch (i.type) {
          case PhysicsImpostor.ParticleImpostor:
            Logger.Warn("No Particle support in OIMO.js. using SphereImpostor instead");
          case PhysicsImpostor.SphereImpostor: {
            const radiusX = impostorExtents.x;
            const radiusY = impostorExtents.y;
            const radiusZ = impostorExtents.z;
            const size = Math.max(checkWithEpsilon(radiusX), checkWithEpsilon(radiusY), checkWithEpsilon(radiusZ)) / 2;
            bodyConfig.type.push("sphere");
            bodyConfig.size.push(size);
            bodyConfig.size.push(size);
            bodyConfig.size.push(size);
            break;
          }
          case PhysicsImpostor.CylinderImpostor: {
            const sizeX = checkWithEpsilon(impostorExtents.x) / 2;
            const sizeY = checkWithEpsilon(impostorExtents.y);
            bodyConfig.type.push("cylinder");
            bodyConfig.size.push(sizeX);
            bodyConfig.size.push(sizeY);
            bodyConfig.size.push(sizeY);
            break;
          }
          case PhysicsImpostor.PlaneImpostor:
          case PhysicsImpostor.BoxImpostor:
          default: {
            const sizeX = checkWithEpsilon(impostorExtents.x);
            const sizeY = checkWithEpsilon(impostorExtents.y);
            const sizeZ = checkWithEpsilon(impostorExtents.z);
            bodyConfig.type.push("box");
            bodyConfig.size.push(sizeX);
            bodyConfig.size.push(sizeY);
            bodyConfig.size.push(sizeZ);
            break;
          }
        }
        i.object.rotationQuaternion = oldQuaternion;
      });
      impostor.physicsBody = this.world.add(bodyConfig);
      impostor.physicsBody.resetQuaternion(globalQuaternion);
      impostor.physicsBody.updatePosition(0);
    } else {
      this._tmpPositionVector.copyFromFloats(0, 0, 0);
    }
    impostor.setDeltaPosition(this._tmpPositionVector);
  }
  removePhysicsBody(impostor) {
    this.world.removeRigidBody(impostor.physicsBody);
  }
  generateJoint(impostorJoint) {
    const mainBody = impostorJoint.mainImpostor.physicsBody;
    const connectedBody = impostorJoint.connectedImpostor.physicsBody;
    if (!mainBody || !connectedBody) {
      return;
    }
    const jointData = impostorJoint.joint.jointData;
    const options = jointData.nativeParams || {};
    let type;
    const nativeJointData = {
      body1: mainBody,
      body2: connectedBody,
      axe1: options.axe1 || (jointData.mainAxis ? jointData.mainAxis.asArray() : null),
      axe2: options.axe2 || (jointData.connectedAxis ? jointData.connectedAxis.asArray() : null),
      pos1: options.pos1 || (jointData.mainPivot ? jointData.mainPivot.asArray() : null),
      pos2: options.pos2 || (jointData.connectedPivot ? jointData.connectedPivot.asArray() : null),
      min: options.min,
      max: options.max,
      collision: options.collision || jointData.collision,
      spring: options.spring,
      world: this.world
    };
    switch (impostorJoint.joint.type) {
      case PhysicsJoint.BallAndSocketJoint:
        type = "jointBall";
        break;
      case PhysicsJoint.SpringJoint: {
        Logger.Warn("OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead");
        const springData = jointData;
        nativeJointData.min = springData.length || nativeJointData.min;
        nativeJointData.max = Math.max(nativeJointData.min, nativeJointData.max);
      }
      case PhysicsJoint.DistanceJoint:
        type = "jointDistance";
        nativeJointData.max = jointData.maxDistance;
        break;
      case PhysicsJoint.PrismaticJoint:
        type = "jointPrisme";
        break;
      case PhysicsJoint.SliderJoint:
        type = "jointSlide";
        break;
      case PhysicsJoint.WheelJoint:
        type = "jointWheel";
        break;
      case PhysicsJoint.HingeJoint:
      default:
        type = "jointHinge";
        break;
    }
    nativeJointData.type = type;
    impostorJoint.joint.physicsJoint = this.world.add(nativeJointData);
  }
  removeJoint(impostorJoint) {
    try {
      this.world.removeJoint(impostorJoint.joint.physicsJoint);
    } catch (e) {
      Logger.Warn(e);
    }
  }
  isSupported() {
    return this.BJSOIMO !== void 0;
  }
  setTransformationFromPhysicsBody(impostor) {
    if (!impostor.physicsBody.sleeping) {
      if (impostor.physicsBody.shapes.next) {
        let parent = impostor.physicsBody.shapes;
        while (parent.next) {
          parent = parent.next;
        }
        impostor.object.position.set(parent.position.x, parent.position.y, parent.position.z);
      } else {
        const pos = impostor.physicsBody.getPosition();
        impostor.object.position.set(pos.x, pos.y, pos.z);
      }
      if (impostor.object.rotationQuaternion) {
        const quat = impostor.physicsBody.getQuaternion();
        impostor.object.rotationQuaternion.set(quat.x, quat.y, quat.z, quat.w);
      }
    }
  }
  setPhysicsBodyTransformation(impostor, newPosition, newRotation) {
    const body = impostor.physicsBody;
    if (impostor.physicsBody.shapes.next) {
      return;
    }
    body.position.set(newPosition.x, newPosition.y, newPosition.z);
    body.orientation.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);
    body.syncShapes();
    body.awake();
  }
  setLinearVelocity(impostor, velocity) {
    impostor.physicsBody.linearVelocity.set(velocity.x, velocity.y, velocity.z);
  }
  setAngularVelocity(impostor, velocity) {
    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);
  }
  getLinearVelocity(impostor) {
    const v = impostor.physicsBody.linearVelocity;
    if (!v) {
      return null;
    }
    return new Vector3(v.x, v.y, v.z);
  }
  getAngularVelocity(impostor) {
    const v = impostor.physicsBody.angularVelocity;
    if (!v) {
      return null;
    }
    return new Vector3(v.x, v.y, v.z);
  }
  setBodyMass(impostor, mass) {
    const staticBody = mass === 0;
    impostor.physicsBody.shapes.density = staticBody ? 1 : mass;
    impostor.physicsBody.setupMass(staticBody ? 2 : 1);
  }
  getBodyMass(impostor) {
    return impostor.physicsBody.shapes.density;
  }
  getBodyFriction(impostor) {
    return impostor.physicsBody.shapes.friction;
  }
  setBodyFriction(impostor, friction) {
    impostor.physicsBody.shapes.friction = friction;
  }
  getBodyRestitution(impostor) {
    return impostor.physicsBody.shapes.restitution;
  }
  setBodyRestitution(impostor, restitution) {
    impostor.physicsBody.shapes.restitution = restitution;
  }
  sleepBody(impostor) {
    impostor.physicsBody.sleep();
  }
  wakeUpBody(impostor) {
    impostor.physicsBody.awake();
  }
  updateDistanceJoint(joint, maxDistance, minDistance) {
    joint.physicsJoint.limitMotor.upperLimit = maxDistance;
    if (minDistance !== void 0) {
      joint.physicsJoint.limitMotor.lowerLimit = minDistance;
    }
  }
  setMotor(joint, speed, force, motorIndex) {
    if (force !== void 0) {
      Logger.Warn("OimoJS plugin currently has unexpected behavior when using setMotor with force parameter");
    } else {
      force = 1e6;
    }
    speed *= -1;
    const motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;
    if (motor) {
      motor.setMotor(speed, force);
    }
  }
  setLimit(joint, upperLimit, lowerLimit, motorIndex) {
    const motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;
    if (motor) {
      motor.setLimit(upperLimit, lowerLimit === void 0 ? -upperLimit : lowerLimit);
    }
  }
  syncMeshWithImpostor(mesh, impostor) {
    const body = impostor.physicsBody;
    mesh.position.x = body.position.x;
    mesh.position.y = body.position.y;
    mesh.position.z = body.position.z;
    if (mesh.rotationQuaternion) {
      mesh.rotationQuaternion.x = body.orientation.x;
      mesh.rotationQuaternion.y = body.orientation.y;
      mesh.rotationQuaternion.z = body.orientation.z;
      mesh.rotationQuaternion.w = body.orientation.w;
    }
  }
  getRadius(impostor) {
    return impostor.physicsBody.shapes.radius;
  }
  getBoxSizeToRef(impostor, result) {
    const shape = impostor.physicsBody.shapes;
    result.x = shape.halfWidth * 2;
    result.y = shape.halfHeight * 2;
    result.z = shape.halfDepth * 2;
  }
  dispose() {
    this.world.clear();
  }
  raycast(from, to) {
    Logger.Warn("raycast is not currently supported by the Oimo physics plugin");
    this._raycastResult.reset(from, to);
    return this._raycastResult;
  }
  raycastToRef(from, to, result) {
    Logger.Warn("raycast is not currently supported by the Oimo physics plugin");
    result.reset(from, to);
  }
};

// node_modules/@babylonjs/core/Physics/v1/Plugins/ammoJSPlugin.js
var AmmoJSPlugin = class {
  constructor(_useDeltaForWorldStep = true, ammoInjection = Ammo, overlappingPairCache = null) {
    this._useDeltaForWorldStep = _useDeltaForWorldStep;
    this.bjsAMMO = {};
    this.name = "AmmoJSPlugin";
    this._timeStep = 1 / 60;
    this._fixedTimeStep = 1 / 60;
    this._maxSteps = 5;
    this._tmpQuaternion = new Quaternion();
    this._tmpContactCallbackResult = false;
    this._tmpContactPoint = new Vector3();
    this._tmpContactNormal = new Vector3();
    this._tmpVec3 = new Vector3();
    this._tmpMatrix = new Matrix();
    if (typeof ammoInjection === "function") {
      Logger.Error("AmmoJS is not ready. Please make sure you await Ammo() before using the plugin.");
      return;
    } else {
      this.bjsAMMO = ammoInjection;
    }
    if (!this.isSupported()) {
      Logger.Error("AmmoJS is not available. Please make sure you included the js file.");
      return;
    }
    this._collisionConfiguration = new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration();
    this._dispatcher = new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration);
    this._overlappingPairCache = overlappingPairCache || new this.bjsAMMO.btDbvtBroadphase();
    this._solver = new this.bjsAMMO.btSequentialImpulseConstraintSolver();
    this._softBodySolver = new this.bjsAMMO.btDefaultSoftBodySolver();
    this.world = new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher, this._overlappingPairCache, this._solver, this._collisionConfiguration, this._softBodySolver);
    this._tmpAmmoConcreteContactResultCallback = new this.bjsAMMO.ConcreteContactResultCallback();
    this._tmpAmmoConcreteContactResultCallback.addSingleResult = (contactPoint) => {
      contactPoint = this.bjsAMMO.wrapPointer(contactPoint, this.bjsAMMO.btManifoldPoint);
      const worldPoint = contactPoint.getPositionWorldOnA();
      const worldNormal = contactPoint.m_normalWorldOnB;
      this._tmpContactPoint.x = worldPoint.x();
      this._tmpContactPoint.y = worldPoint.y();
      this._tmpContactPoint.z = worldPoint.z();
      this._tmpContactNormal.x = worldNormal.x();
      this._tmpContactNormal.y = worldNormal.y();
      this._tmpContactNormal.z = worldNormal.z();
      this._tmpContactImpulse = contactPoint.getAppliedImpulse();
      this._tmpContactDistance = contactPoint.getDistance();
      this._tmpContactCallbackResult = true;
    };
    this._raycastResult = new PhysicsRaycastResult();
    this._tmpAmmoTransform = new this.bjsAMMO.btTransform();
    this._tmpAmmoTransform.setIdentity();
    this._tmpAmmoQuaternion = new this.bjsAMMO.btQuaternion(0, 0, 0, 1);
    this._tmpAmmoVectorA = new this.bjsAMMO.btVector3(0, 0, 0);
    this._tmpAmmoVectorB = new this.bjsAMMO.btVector3(0, 0, 0);
    this._tmpAmmoVectorC = new this.bjsAMMO.btVector3(0, 0, 0);
    this._tmpAmmoVectorD = new this.bjsAMMO.btVector3(0, 0, 0);
  }
  getPluginVersion() {
    return 1;
  }
  setGravity(gravity) {
    this._tmpAmmoVectorA.setValue(gravity.x, gravity.y, gravity.z);
    this.world.setGravity(this._tmpAmmoVectorA);
    this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA);
  }
  setTimeStep(timeStep) {
    this._timeStep = timeStep;
  }
  setFixedTimeStep(fixedTimeStep) {
    this._fixedTimeStep = fixedTimeStep;
  }
  setMaxSteps(maxSteps) {
    this._maxSteps = maxSteps;
  }
  getTimeStep() {
    return this._timeStep;
  }
  _isImpostorInContact(impostor) {
    this._tmpContactCallbackResult = false;
    this.world.contactTest(impostor.physicsBody, this._tmpAmmoConcreteContactResultCallback);
    return this._tmpContactCallbackResult;
  }
  _isImpostorPairInContact(impostorA, impostorB) {
    this._tmpContactCallbackResult = false;
    this.world.contactPairTest(impostorA.physicsBody, impostorB.physicsBody, this._tmpAmmoConcreteContactResultCallback);
    return this._tmpContactCallbackResult;
  }
  _stepSimulation(timeStep = 1 / 60, maxSteps = 10, fixedTimeStep = 1 / 60) {
    if (maxSteps == 0) {
      this.world.stepSimulation(timeStep, 0);
    } else {
      while (maxSteps > 0 && timeStep > 0) {
        if (timeStep - fixedTimeStep < fixedTimeStep) {
          this.world.stepSimulation(timeStep, 0);
          timeStep = 0;
        } else {
          timeStep -= fixedTimeStep;
          this.world.stepSimulation(fixedTimeStep, 0);
        }
        maxSteps--;
      }
    }
  }
  executeStep(delta, impostors) {
    for (const impostor of impostors) {
      if (!impostor.soft) {
        impostor.beforeStep();
      }
    }
    this._stepSimulation(this._useDeltaForWorldStep ? delta : this._timeStep, this._maxSteps, this._fixedTimeStep);
    for (const mainImpostor of impostors) {
      if (mainImpostor.soft) {
        this._afterSoftStep(mainImpostor);
      } else {
        mainImpostor.afterStep();
      }
      if (mainImpostor._onPhysicsCollideCallbacks.length > 0) {
        if (this._isImpostorInContact(mainImpostor)) {
          for (const collideCallback of mainImpostor._onPhysicsCollideCallbacks) {
            for (const otherImpostor of collideCallback.otherImpostors) {
              if (mainImpostor.physicsBody.isActive() || otherImpostor.physicsBody.isActive()) {
                if (this._isImpostorPairInContact(mainImpostor, otherImpostor)) {
                  mainImpostor.onCollide({
                    body: otherImpostor.physicsBody,
                    point: this._tmpContactPoint,
                    distance: this._tmpContactDistance,
                    impulse: this._tmpContactImpulse,
                    normal: this._tmpContactNormal
                  });
                  otherImpostor.onCollide({
                    body: mainImpostor.physicsBody,
                    point: this._tmpContactPoint,
                    distance: this._tmpContactDistance,
                    impulse: this._tmpContactImpulse,
                    normal: this._tmpContactNormal
                  });
                }
              }
            }
          }
        }
      }
    }
  }
  _afterSoftStep(impostor) {
    if (impostor.type === PhysicsImpostor.RopeImpostor) {
      this._ropeStep(impostor);
    } else {
      this._softbodyOrClothStep(impostor);
    }
  }
  _ropeStep(impostor) {
    const bodyVertices = impostor.physicsBody.get_m_nodes();
    const nbVertices = bodyVertices.size();
    let node;
    let nodePositions;
    let x, y, z;
    const path = new Array();
    for (let n = 0; n < nbVertices; n++) {
      node = bodyVertices.at(n);
      nodePositions = node.get_m_x();
      x = nodePositions.x();
      y = nodePositions.y();
      z = nodePositions.z();
      path.push(new Vector3(x, y, z));
    }
    const object = impostor.object;
    const shape = impostor.getParam("shape");
    if (impostor._isFromLine) {
      impostor.object = CreateLines("lines", { points: path, instance: object });
    } else {
      impostor.object = ExtrudeShape("ext", { shape, path, instance: object });
    }
  }
  _softbodyOrClothStep(impostor) {
    const normalDirection = impostor.type === PhysicsImpostor.ClothImpostor ? 1 : -1;
    const object = impostor.object;
    let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);
    if (!vertexPositions) {
      vertexPositions = [];
    }
    let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);
    if (!vertexNormals) {
      vertexNormals = [];
    }
    const nbVertices = vertexPositions.length / 3;
    const bodyVertices = impostor.physicsBody.get_m_nodes();
    let node;
    let nodePositions;
    let x, y, z;
    let nx, ny, nz;
    for (let n = 0; n < nbVertices; n++) {
      node = bodyVertices.at(n);
      nodePositions = node.get_m_x();
      x = nodePositions.x();
      y = nodePositions.y();
      z = nodePositions.z() * normalDirection;
      const nodeNormals = node.get_m_n();
      nx = nodeNormals.x();
      ny = nodeNormals.y();
      nz = nodeNormals.z() * normalDirection;
      vertexPositions[3 * n] = x;
      vertexPositions[3 * n + 1] = y;
      vertexPositions[3 * n + 2] = z;
      vertexNormals[3 * n] = nx;
      vertexNormals[3 * n + 1] = ny;
      vertexNormals[3 * n + 2] = nz;
    }
    const vertex_data = new VertexData();
    vertex_data.positions = vertexPositions;
    vertex_data.normals = vertexNormals;
    vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);
    vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);
    if (object && object.getIndices) {
      vertex_data.indices = object.getIndices();
    }
    vertex_data.applyToMesh(object);
  }
  applyImpulse(impostor, force, contactPoint) {
    if (!impostor.soft) {
      impostor.physicsBody.activate();
      const worldPoint = this._tmpAmmoVectorA;
      const impulse = this._tmpAmmoVectorB;
      if (impostor.object && impostor.object.getWorldMatrix) {
        contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());
      }
      worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);
      impulse.setValue(force.x, force.y, force.z);
      impostor.physicsBody.applyImpulse(impulse, worldPoint);
    } else {
      Logger.Warn("Cannot be applied to a soft body");
    }
  }
  applyForce(impostor, force, contactPoint) {
    if (!impostor.soft) {
      impostor.physicsBody.activate();
      const worldPoint = this._tmpAmmoVectorA;
      const impulse = this._tmpAmmoVectorB;
      if (impostor.object && impostor.object.getWorldMatrix) {
        const localTranslation = impostor.object.getWorldMatrix().getTranslation();
        worldPoint.setValue(contactPoint.x - localTranslation.x, contactPoint.y - localTranslation.y, contactPoint.z - localTranslation.z);
      } else {
        worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);
      }
      impulse.setValue(force.x, force.y, force.z);
      impostor.physicsBody.applyForce(impulse, worldPoint);
    } else {
      Logger.Warn("Cannot be applied to a soft body");
    }
  }
  generatePhysicsBody(impostor) {
    impostor._pluginData.toDispose = [];
    if (impostor.parent) {
      if (impostor.physicsBody) {
        this.removePhysicsBody(impostor);
        impostor.forceUpdate();
      }
      return;
    }
    if (impostor.isBodyInitRequired()) {
      const colShape = this._createShape(impostor);
      const mass = impostor.getParam("mass");
      impostor._pluginData.mass = mass;
      if (impostor.soft) {
        colShape.get_m_cfg().set_collisions(17);
        colShape.get_m_cfg().set_kDP(impostor.getParam("damping"));
        this.bjsAMMO.castObject(colShape, this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(impostor.getParam("margin"));
        colShape.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);
        this.world.addSoftBody(colShape, 1, -1);
        impostor.physicsBody = colShape;
        impostor._pluginData.toDispose.push(colShape);
        this.setBodyPressure(impostor, 0);
        if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {
          this.setBodyPressure(impostor, impostor.getParam("pressure"));
        }
        this.setBodyStiffness(impostor, impostor.getParam("stiffness"));
        this.setBodyVelocityIterations(impostor, impostor.getParam("velocityIterations"));
        this.setBodyPositionIterations(impostor, impostor.getParam("positionIterations"));
      } else {
        const localInertia = new this.bjsAMMO.btVector3(0, 0, 0);
        const startTransform = new this.bjsAMMO.btTransform();
        impostor.object.computeWorldMatrix(true);
        startTransform.setIdentity();
        if (mass !== 0) {
          colShape.calculateLocalInertia(mass, localInertia);
        }
        this._tmpAmmoVectorA.setValue(impostor.object.position.x, impostor.object.position.y, impostor.object.position.z);
        this._tmpAmmoQuaternion.setValue(impostor.object.rotationQuaternion.x, impostor.object.rotationQuaternion.y, impostor.object.rotationQuaternion.z, impostor.object.rotationQuaternion.w);
        startTransform.setOrigin(this._tmpAmmoVectorA);
        startTransform.setRotation(this._tmpAmmoQuaternion);
        const myMotionState = new this.bjsAMMO.btDefaultMotionState(startTransform);
        const rbInfo = new this.bjsAMMO.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);
        const body = new this.bjsAMMO.btRigidBody(rbInfo);
        if (mass === 0) {
          body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._KINEMATIC_FLAG);
          body.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);
        }
        if (impostor.type == PhysicsImpostor.NoImpostor && !colShape.getChildShape) {
          body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._DISABLE_COLLISION_FLAG);
        }
        if (impostor.type !== PhysicsImpostor.MeshImpostor && impostor.type !== PhysicsImpostor.NoImpostor) {
          const boundingInfo = impostor.object.getBoundingInfo();
          this._tmpVec3.copyFrom(impostor.object.getAbsolutePosition());
          this._tmpVec3.subtractInPlace(boundingInfo.boundingBox.centerWorld);
          this._tmpVec3.x /= impostor.object.scaling.x;
          this._tmpVec3.y /= impostor.object.scaling.y;
          this._tmpVec3.z /= impostor.object.scaling.z;
          impostor.setDeltaPosition(this._tmpVec3);
        }
        const group = impostor.getParam("group");
        const mask = impostor.getParam("mask");
        if (group && mask) {
          this.world.addRigidBody(body, group, mask);
        } else {
          this.world.addRigidBody(body);
        }
        impostor.physicsBody = body;
        impostor._pluginData.toDispose = impostor._pluginData.toDispose.concat([body, rbInfo, myMotionState, startTransform, localInertia, colShape]);
      }
      this.setBodyRestitution(impostor, impostor.getParam("restitution"));
      this.setBodyFriction(impostor, impostor.getParam("friction"));
    }
  }
  removePhysicsBody(impostor) {
    if (this.world) {
      if (impostor.soft) {
        this.world.removeSoftBody(impostor.physicsBody);
      } else {
        this.world.removeRigidBody(impostor.physicsBody);
      }
      if (impostor._pluginData) {
        impostor._pluginData.toDispose.forEach((d) => {
          this.bjsAMMO.destroy(d);
        });
        impostor._pluginData.toDispose = [];
      }
    }
  }
  generateJoint(impostorJoint) {
    const mainBody = impostorJoint.mainImpostor.physicsBody;
    const connectedBody = impostorJoint.connectedImpostor.physicsBody;
    if (!mainBody || !connectedBody) {
      return;
    }
    const jointData = impostorJoint.joint.jointData;
    if (!jointData.mainPivot) {
      jointData.mainPivot = new Vector3(0, 0, 0);
    }
    if (!jointData.connectedPivot) {
      jointData.connectedPivot = new Vector3(0, 0, 0);
    }
    let joint;
    switch (impostorJoint.joint.type) {
      case PhysicsJoint.DistanceJoint: {
        const distance = jointData.maxDistance;
        if (distance) {
          jointData.mainPivot = new Vector3(0, -distance / 2, 0);
          jointData.connectedPivot = new Vector3(0, distance / 2, 0);
        }
        joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));
        break;
      }
      case PhysicsJoint.HingeJoint: {
        if (!jointData.mainAxis) {
          jointData.mainAxis = new Vector3(0, 0, 0);
        }
        if (!jointData.connectedAxis) {
          jointData.connectedAxis = new Vector3(0, 0, 0);
        }
        const mainAxis = new this.bjsAMMO.btVector3(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z);
        const connectedAxis = new this.bjsAMMO.btVector3(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z);
        joint = new this.bjsAMMO.btHingeConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z), mainAxis, connectedAxis);
        break;
      }
      case PhysicsJoint.BallAndSocketJoint:
        joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));
        break;
      default:
        Logger.Warn("JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint");
        joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));
        break;
    }
    this.world.addConstraint(joint, !impostorJoint.joint.jointData.collision);
    impostorJoint.joint.physicsJoint = joint;
  }
  removeJoint(impostorJoint) {
    if (this.world) {
      this.world.removeConstraint(impostorJoint.joint.physicsJoint);
    }
  }
  _addMeshVerts(btTriangleMesh, topLevelObject, object) {
    let triangleCount = 0;
    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {
      let indices = object.getIndices();
      if (!indices) {
        indices = [];
      }
      let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);
      if (!vertexPositions) {
        vertexPositions = [];
      }
      let localMatrix;
      if (topLevelObject && topLevelObject !== object) {
        let topLevelQuaternion;
        if (topLevelObject.rotationQuaternion) {
          topLevelQuaternion = topLevelObject.rotationQuaternion;
        } else if (topLevelObject.rotation) {
          topLevelQuaternion = Quaternion.FromEulerAngles(topLevelObject.rotation.x, topLevelObject.rotation.y, topLevelObject.rotation.z);
        } else {
          topLevelQuaternion = Quaternion.Identity();
        }
        const topLevelMatrix = Matrix.Compose(Vector3.One(), topLevelQuaternion, topLevelObject.position);
        topLevelMatrix.invertToRef(this._tmpMatrix);
        const wm = object.computeWorldMatrix(false);
        localMatrix = wm.multiply(this._tmpMatrix);
      } else {
        Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);
        localMatrix = this._tmpMatrix;
      }
      const faceCount = indices.length / 3;
      for (let i = 0; i < faceCount; i++) {
        const triPoints = [];
        for (let point = 0; point < 3; point++) {
          let v = new Vector3(vertexPositions[indices[i * 3 + point] * 3 + 0], vertexPositions[indices[i * 3 + point] * 3 + 1], vertexPositions[indices[i * 3 + point] * 3 + 2]);
          v = Vector3.TransformCoordinates(v, localMatrix);
          let vec;
          if (point == 0) {
            vec = this._tmpAmmoVectorA;
          } else if (point == 1) {
            vec = this._tmpAmmoVectorB;
          } else {
            vec = this._tmpAmmoVectorC;
          }
          vec.setValue(v.x, v.y, v.z);
          triPoints.push(vec);
        }
        btTriangleMesh.addTriangle(triPoints[0], triPoints[1], triPoints[2]);
        triangleCount++;
      }
      object.getChildMeshes().forEach((m) => {
        triangleCount += this._addMeshVerts(btTriangleMesh, topLevelObject, m);
      });
    }
    return triangleCount;
  }
  _softVertexData(impostor) {
    const object = impostor.object;
    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {
      let indices = object.getIndices();
      if (!indices) {
        indices = [];
      }
      let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);
      if (!vertexPositions) {
        vertexPositions = [];
      }
      let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);
      if (!vertexNormals) {
        vertexNormals = [];
      }
      object.computeWorldMatrix(false);
      const newPoints = [];
      const newNorms = [];
      for (let i = 0; i < vertexPositions.length; i += 3) {
        let v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);
        let n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);
        v = Vector3.TransformCoordinates(v, object.getWorldMatrix());
        n = Vector3.TransformNormal(n, object.getWorldMatrix());
        newPoints.push(v.x, v.y, v.z);
        newNorms.push(n.x, n.y, n.z);
      }
      const vertex_data = new VertexData();
      vertex_data.positions = newPoints;
      vertex_data.normals = newNorms;
      vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);
      vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);
      if (object && object.getIndices) {
        vertex_data.indices = object.getIndices();
      }
      vertex_data.applyToMesh(object);
      object.position = Vector3.Zero();
      object.rotationQuaternion = null;
      object.rotation = Vector3.Zero();
      object.computeWorldMatrix(true);
      return vertex_data;
    }
    return VertexData.ExtractFromMesh(object);
  }
  _createSoftbody(impostor) {
    const object = impostor.object;
    if (object && object.getIndices) {
      let indices = object.getIndices();
      if (!indices) {
        indices = [];
      }
      const vertex_data = this._softVertexData(impostor);
      const vertexPositions = vertex_data.positions;
      const vertexNormals = vertex_data.normals;
      if (vertexPositions === null || vertexNormals === null) {
        return new this.bjsAMMO.btCompoundShape();
      } else {
        const triPoints = [];
        const triNorms = [];
        for (let i = 0; i < vertexPositions.length; i += 3) {
          const v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);
          const n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);
          triPoints.push(v.x, v.y, -v.z);
          triNorms.push(n.x, n.y, -n.z);
        }
        const softBody = new this.bjsAMMO.btSoftBodyHelpers().CreateFromTriMesh(this.world.getWorldInfo(), triPoints, object.getIndices(), indices.length / 3, true);
        const nbVertices = vertexPositions.length / 3;
        const bodyVertices = softBody.get_m_nodes();
        let node;
        let nodeNormals;
        for (let i = 0; i < nbVertices; i++) {
          node = bodyVertices.at(i);
          nodeNormals = node.get_m_n();
          nodeNormals.setX(triNorms[3 * i]);
          nodeNormals.setY(triNorms[3 * i + 1]);
          nodeNormals.setZ(triNorms[3 * i + 2]);
        }
        return softBody;
      }
    }
  }
  _createCloth(impostor) {
    const object = impostor.object;
    if (object && object.getIndices) {
      let indices = object.getIndices();
      if (!indices) {
        indices = [];
      }
      const vertex_data = this._softVertexData(impostor);
      const vertexPositions = vertex_data.positions;
      const vertexNormals = vertex_data.normals;
      if (vertexPositions === null || vertexNormals === null) {
        return new this.bjsAMMO.btCompoundShape();
      } else {
        const len = vertexPositions.length;
        const segments = Math.sqrt(len / 3);
        impostor.segments = segments;
        const segs = segments - 1;
        this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);
        this._tmpAmmoVectorB.setValue(vertexPositions[3 * segs], vertexPositions[3 * segs + 1], vertexPositions[3 * segs + 2]);
        this._tmpAmmoVectorD.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);
        this._tmpAmmoVectorC.setValue(vertexPositions[len - 3 - 3 * segs], vertexPositions[len - 2 - 3 * segs], vertexPositions[len - 1 - 3 * segs]);
        const clothBody = new this.bjsAMMO.btSoftBodyHelpers().CreatePatch(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, this._tmpAmmoVectorC, this._tmpAmmoVectorD, segments, segments, impostor.getParam("fixedPoints"), true);
        return clothBody;
      }
    }
  }
  _createRope(impostor) {
    let len;
    let segments;
    const vertex_data = this._softVertexData(impostor);
    const vertexPositions = vertex_data.positions;
    const vertexNormals = vertex_data.normals;
    if (vertexPositions === null || vertexNormals === null) {
      return new this.bjsAMMO.btCompoundShape();
    }
    vertex_data.applyToMesh(impostor.object, true);
    impostor._isFromLine = true;
    const vertexSquared = vertexNormals.map((x) => x * x);
    const reducer = (accumulator, currentValue) => accumulator + currentValue;
    const reduced = vertexSquared.reduce(reducer);
    if (reduced === 0) {
      len = vertexPositions.length;
      segments = len / 3 - 1;
      this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);
      this._tmpAmmoVectorB.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);
    } else {
      impostor._isFromLine = false;
      const pathVectors = impostor.getParam("path");
      const shape = impostor.getParam("shape");
      if (shape === null) {
        Logger.Warn("No shape available for extruded mesh");
        return new this.bjsAMMO.btCompoundShape();
      }
      len = pathVectors.length;
      segments = len - 1;
      this._tmpAmmoVectorA.setValue(pathVectors[0].x, pathVectors[0].y, pathVectors[0].z);
      this._tmpAmmoVectorB.setValue(pathVectors[len - 1].x, pathVectors[len - 1].y, pathVectors[len - 1].z);
    }
    impostor.segments = segments;
    let fixedPoints = impostor.getParam("fixedPoints");
    fixedPoints = fixedPoints > 3 ? 3 : fixedPoints;
    const ropeBody = new this.bjsAMMO.btSoftBodyHelpers().CreateRope(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, segments - 1, fixedPoints);
    ropeBody.get_m_cfg().set_collisions(17);
    return ropeBody;
  }
  _createCustom(impostor) {
    let returnValue = null;
    if (this.onCreateCustomShape) {
      returnValue = this.onCreateCustomShape(impostor);
    }
    if (returnValue == null) {
      returnValue = new this.bjsAMMO.btCompoundShape();
    }
    return returnValue;
  }
  _addHullVerts(btConvexHullShape, topLevelObject, object) {
    let triangleCount = 0;
    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {
      let indices = object.getIndices();
      if (!indices) {
        indices = [];
      }
      let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);
      if (!vertexPositions) {
        vertexPositions = [];
      }
      object.computeWorldMatrix(false);
      const faceCount = indices.length / 3;
      for (let i = 0; i < faceCount; i++) {
        const triPoints = [];
        for (let point = 0; point < 3; point++) {
          let v = new Vector3(vertexPositions[indices[i * 3 + point] * 3 + 0], vertexPositions[indices[i * 3 + point] * 3 + 1], vertexPositions[indices[i * 3 + point] * 3 + 2]);
          Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);
          v = Vector3.TransformCoordinates(v, this._tmpMatrix);
          let vec;
          if (point == 0) {
            vec = this._tmpAmmoVectorA;
          } else if (point == 1) {
            vec = this._tmpAmmoVectorB;
          } else {
            vec = this._tmpAmmoVectorC;
          }
          vec.setValue(v.x, v.y, v.z);
          triPoints.push(vec);
        }
        btConvexHullShape.addPoint(triPoints[0], true);
        btConvexHullShape.addPoint(triPoints[1], true);
        btConvexHullShape.addPoint(triPoints[2], true);
        triangleCount++;
      }
      object.getChildMeshes().forEach((m) => {
        triangleCount += this._addHullVerts(btConvexHullShape, topLevelObject, m);
      });
    }
    return triangleCount;
  }
  _createShape(impostor, ignoreChildren = false) {
    const object = impostor.object;
    let returnValue;
    const impostorExtents = impostor.getObjectExtents();
    if (!ignoreChildren) {
      const meshChildren = impostor.object.getChildMeshes ? impostor.object.getChildMeshes(true) : [];
      returnValue = new this.bjsAMMO.btCompoundShape();
      let childrenAdded = 0;
      meshChildren.forEach((childMesh) => {
        const childImpostor = childMesh.getPhysicsImpostor();
        if (childImpostor) {
          if (childImpostor.type == PhysicsImpostor.MeshImpostor) {
            throw "A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)";
          }
          const shape = this._createShape(childImpostor);
          const parentMat = childMesh.parent.getWorldMatrix().clone();
          const s = new Vector3();
          parentMat.decompose(s);
          this._tmpAmmoTransform.getOrigin().setValue(childMesh.position.x * s.x, childMesh.position.y * s.y, childMesh.position.z * s.z);
          this._tmpAmmoQuaternion.setValue(childMesh.rotationQuaternion.x, childMesh.rotationQuaternion.y, childMesh.rotationQuaternion.z, childMesh.rotationQuaternion.w);
          this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);
          returnValue.addChildShape(this._tmpAmmoTransform, shape);
          childImpostor.dispose();
          childrenAdded++;
        }
      });
      if (childrenAdded > 0) {
        if (impostor.type != PhysicsImpostor.NoImpostor) {
          const shape = this._createShape(impostor, true);
          if (shape) {
            this._tmpAmmoTransform.getOrigin().setValue(0, 0, 0);
            this._tmpAmmoQuaternion.setValue(0, 0, 0, 1);
            this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);
            returnValue.addChildShape(this._tmpAmmoTransform, shape);
          }
        }
        return returnValue;
      } else {
        this.bjsAMMO.destroy(returnValue);
        returnValue = null;
      }
    }
    switch (impostor.type) {
      case PhysicsImpostor.SphereImpostor:
        if (Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.y, 1e-4) && Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.z, 1e-4)) {
          returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);
        } else {
          const positions = [new this.bjsAMMO.btVector3(0, 0, 0)];
          const radii = [1];
          returnValue = new this.bjsAMMO.btMultiSphereShape(positions, radii, 1);
          returnValue.setLocalScaling(new this.bjsAMMO.btVector3(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2));
        }
        break;
      case PhysicsImpostor.CapsuleImpostor:
        {
          const capRadius = impostorExtents.x / 2;
          returnValue = new this.bjsAMMO.btCapsuleShape(capRadius, impostorExtents.y - capRadius * 2);
        }
        break;
      case PhysicsImpostor.CylinderImpostor:
        this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);
        returnValue = new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);
        break;
      case PhysicsImpostor.PlaneImpostor:
      case PhysicsImpostor.BoxImpostor:
        this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);
        returnValue = new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);
        break;
      case PhysicsImpostor.MeshImpostor: {
        if (impostor.getParam("mass") == 0) {
          if (this.onCreateCustomMeshImpostor) {
            returnValue = this.onCreateCustomMeshImpostor(impostor);
          } else {
            const triMesh = new this.bjsAMMO.btTriangleMesh();
            impostor._pluginData.toDispose.push(triMesh);
            const triangleCount = this._addMeshVerts(triMesh, object, object);
            if (triangleCount == 0) {
              returnValue = new this.bjsAMMO.btCompoundShape();
            } else {
              returnValue = new this.bjsAMMO.btBvhTriangleMeshShape(triMesh);
            }
          }
          break;
        }
      }
      case PhysicsImpostor.ConvexHullImpostor: {
        if (this.onCreateCustomConvexHullImpostor) {
          returnValue = this.onCreateCustomConvexHullImpostor(impostor);
        } else {
          const convexHull = new this.bjsAMMO.btConvexHullShape();
          const triangleCount = this._addHullVerts(convexHull, object, object);
          if (triangleCount == 0) {
            impostor._pluginData.toDispose.push(convexHull);
            returnValue = new this.bjsAMMO.btCompoundShape();
          } else {
            returnValue = convexHull;
          }
        }
        break;
      }
      case PhysicsImpostor.NoImpostor:
        returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);
        break;
      case PhysicsImpostor.CustomImpostor:
        returnValue = this._createCustom(impostor);
        break;
      case PhysicsImpostor.SoftbodyImpostor:
        returnValue = this._createSoftbody(impostor);
        break;
      case PhysicsImpostor.ClothImpostor:
        returnValue = this._createCloth(impostor);
        break;
      case PhysicsImpostor.RopeImpostor:
        returnValue = this._createRope(impostor);
        break;
      default:
        Logger.Warn("The impostor type is not currently supported by the ammo plugin.");
        break;
    }
    return returnValue;
  }
  setTransformationFromPhysicsBody(impostor) {
    impostor.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform);
    impostor.object.position.set(this._tmpAmmoTransform.getOrigin().x(), this._tmpAmmoTransform.getOrigin().y(), this._tmpAmmoTransform.getOrigin().z());
    if (!impostor.object.rotationQuaternion) {
      if (impostor.object.rotation) {
        this._tmpQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());
        this._tmpQuaternion.toEulerAnglesToRef(impostor.object.rotation);
      }
    } else {
      impostor.object.rotationQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());
    }
  }
  setPhysicsBodyTransformation(impostor, newPosition, newRotation) {
    const trans = impostor.physicsBody.getWorldTransform();
    if (Math.abs(trans.getOrigin().x() - newPosition.x) > Epsilon || Math.abs(trans.getOrigin().y() - newPosition.y) > Epsilon || Math.abs(trans.getOrigin().z() - newPosition.z) > Epsilon || Math.abs(trans.getRotation().x() - newRotation.x) > Epsilon || Math.abs(trans.getRotation().y() - newRotation.y) > Epsilon || Math.abs(trans.getRotation().z() - newRotation.z) > Epsilon || Math.abs(trans.getRotation().w() - newRotation.w) > Epsilon) {
      this._tmpAmmoVectorA.setValue(newPosition.x, newPosition.y, newPosition.z);
      trans.setOrigin(this._tmpAmmoVectorA);
      this._tmpAmmoQuaternion.setValue(newRotation.x, newRotation.y, newRotation.z, newRotation.w);
      trans.setRotation(this._tmpAmmoQuaternion);
      impostor.physicsBody.setWorldTransform(trans);
      if (impostor.mass == 0) {
        const motionState = impostor.physicsBody.getMotionState();
        if (motionState) {
          motionState.setWorldTransform(trans);
        }
      } else {
        impostor.physicsBody.activate();
      }
    }
  }
  isSupported() {
    return this.bjsAMMO !== void 0;
  }
  setLinearVelocity(impostor, velocity) {
    this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);
    if (impostor.soft) {
      impostor.physicsBody.linearVelocity(this._tmpAmmoVectorA);
    } else {
      impostor.physicsBody.setLinearVelocity(this._tmpAmmoVectorA);
    }
  }
  setAngularVelocity(impostor, velocity) {
    this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);
    if (impostor.soft) {
      impostor.physicsBody.angularVelocity(this._tmpAmmoVectorA);
    } else {
      impostor.physicsBody.setAngularVelocity(this._tmpAmmoVectorA);
    }
  }
  getLinearVelocity(impostor) {
    let v;
    if (impostor.soft) {
      v = impostor.physicsBody.linearVelocity();
    } else {
      v = impostor.physicsBody.getLinearVelocity();
    }
    if (!v) {
      return null;
    }
    const result = new Vector3(v.x(), v.y(), v.z());
    this.bjsAMMO.destroy(v);
    return result;
  }
  getAngularVelocity(impostor) {
    let v;
    if (impostor.soft) {
      v = impostor.physicsBody.angularVelocity();
    } else {
      v = impostor.physicsBody.getAngularVelocity();
    }
    if (!v) {
      return null;
    }
    const result = new Vector3(v.x(), v.y(), v.z());
    this.bjsAMMO.destroy(v);
    return result;
  }
  setBodyMass(impostor, mass) {
    if (impostor.soft) {
      impostor.physicsBody.setTotalMass(mass, false);
    } else {
      impostor.physicsBody.setMassProps(mass);
    }
    impostor._pluginData.mass = mass;
  }
  getBodyMass(impostor) {
    return impostor._pluginData.mass || 0;
  }
  getBodyFriction(impostor) {
    return impostor._pluginData.friction || 0;
  }
  setBodyFriction(impostor, friction) {
    if (impostor.soft) {
      impostor.physicsBody.get_m_cfg().set_kDF(friction);
    } else {
      impostor.physicsBody.setFriction(friction);
    }
    impostor._pluginData.friction = friction;
  }
  getBodyRestitution(impostor) {
    return impostor._pluginData.restitution || 0;
  }
  setBodyRestitution(impostor, restitution) {
    impostor.physicsBody.setRestitution(restitution);
    impostor._pluginData.restitution = restitution;
  }
  getBodyPressure(impostor) {
    if (!impostor.soft) {
      Logger.Warn("Pressure is not a property of a rigid body");
      return 0;
    }
    return impostor._pluginData.pressure || 0;
  }
  setBodyPressure(impostor, pressure) {
    if (impostor.soft) {
      if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {
        impostor.physicsBody.get_m_cfg().set_kPR(pressure);
        impostor._pluginData.pressure = pressure;
      } else {
        impostor.physicsBody.get_m_cfg().set_kPR(0);
        impostor._pluginData.pressure = 0;
      }
    } else {
      Logger.Warn("Pressure can only be applied to a softbody");
    }
  }
  getBodyStiffness(impostor) {
    if (!impostor.soft) {
      Logger.Warn("Stiffness is not a property of a rigid body");
      return 0;
    }
    return impostor._pluginData.stiffness || 0;
  }
  setBodyStiffness(impostor, stiffness) {
    if (impostor.soft) {
      stiffness = stiffness < 0 ? 0 : stiffness;
      stiffness = stiffness > 1 ? 1 : stiffness;
      impostor.physicsBody.get_m_materials().at(0).set_m_kLST(stiffness);
      impostor._pluginData.stiffness = stiffness;
    } else {
      Logger.Warn("Stiffness cannot be applied to a rigid body");
    }
  }
  getBodyVelocityIterations(impostor) {
    if (!impostor.soft) {
      Logger.Warn("Velocity iterations is not a property of a rigid body");
      return 0;
    }
    return impostor._pluginData.velocityIterations || 0;
  }
  setBodyVelocityIterations(impostor, velocityIterations) {
    if (impostor.soft) {
      velocityIterations = velocityIterations < 0 ? 0 : velocityIterations;
      impostor.physicsBody.get_m_cfg().set_viterations(velocityIterations);
      impostor._pluginData.velocityIterations = velocityIterations;
    } else {
      Logger.Warn("Velocity iterations cannot be applied to a rigid body");
    }
  }
  getBodyPositionIterations(impostor) {
    if (!impostor.soft) {
      Logger.Warn("Position iterations is not a property of a rigid body");
      return 0;
    }
    return impostor._pluginData.positionIterations || 0;
  }
  setBodyPositionIterations(impostor, positionIterations) {
    if (impostor.soft) {
      positionIterations = positionIterations < 0 ? 0 : positionIterations;
      impostor.physicsBody.get_m_cfg().set_piterations(positionIterations);
      impostor._pluginData.positionIterations = positionIterations;
    } else {
      Logger.Warn("Position iterations cannot be applied to a rigid body");
    }
  }
  appendAnchor(impostor, otherImpostor, width, height, influence = 1, noCollisionBetweenLinkedBodies = false) {
    const segs = impostor.segments;
    const nbAcross = Math.round((segs - 1) * width);
    const nbUp = Math.round((segs - 1) * height);
    const nbDown = segs - 1 - nbUp;
    const node = nbAcross + segs * nbDown;
    impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);
  }
  appendHook(impostor, otherImpostor, length, influence = 1, noCollisionBetweenLinkedBodies = false) {
    const node = Math.round(impostor.segments * length);
    impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);
  }
  sleepBody(impostor) {
    impostor.physicsBody.forceActivationState(0);
  }
  wakeUpBody(impostor) {
    impostor.physicsBody.activate();
  }
  updateDistanceJoint() {
    Logger.Warn("updateDistanceJoint is not currently supported by the Ammo physics plugin");
  }
  setMotor(joint, speed, maxForce) {
    joint.physicsJoint.enableAngularMotor(true, speed, maxForce);
  }
  setLimit() {
    Logger.Warn("setLimit is not currently supported by the Ammo physics plugin");
  }
  syncMeshWithImpostor(mesh, impostor) {
    const body = impostor.physicsBody;
    body.getMotionState().getWorldTransform(this._tmpAmmoTransform);
    mesh.position.x = this._tmpAmmoTransform.getOrigin().x();
    mesh.position.y = this._tmpAmmoTransform.getOrigin().y();
    mesh.position.z = this._tmpAmmoTransform.getOrigin().z();
    if (mesh.rotationQuaternion) {
      mesh.rotationQuaternion.x = this._tmpAmmoTransform.getRotation().x();
      mesh.rotationQuaternion.y = this._tmpAmmoTransform.getRotation().y();
      mesh.rotationQuaternion.z = this._tmpAmmoTransform.getRotation().z();
      mesh.rotationQuaternion.w = this._tmpAmmoTransform.getRotation().w();
    }
  }
  getRadius(impostor) {
    const extents = impostor.getObjectExtents();
    return extents.x / 2;
  }
  getBoxSizeToRef(impostor, result) {
    const extents = impostor.getObjectExtents();
    result.x = extents.x;
    result.y = extents.y;
    result.z = extents.z;
  }
  dispose() {
    this.bjsAMMO.destroy(this.world);
    this.bjsAMMO.destroy(this._solver);
    this.bjsAMMO.destroy(this._overlappingPairCache);
    this.bjsAMMO.destroy(this._dispatcher);
    this.bjsAMMO.destroy(this._collisionConfiguration);
    this.bjsAMMO.destroy(this._tmpAmmoVectorA);
    this.bjsAMMO.destroy(this._tmpAmmoVectorB);
    this.bjsAMMO.destroy(this._tmpAmmoVectorC);
    this.bjsAMMO.destroy(this._tmpAmmoTransform);
    this.bjsAMMO.destroy(this._tmpAmmoQuaternion);
    this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback);
    this.world = null;
  }
  raycast(from, to) {
    this.raycastToRef(from, to, this._raycastResult);
    return this._raycastResult;
  }
  raycastToRef(from, to, result) {
    this._tmpAmmoVectorRCA = new this.bjsAMMO.btVector3(from.x, from.y, from.z);
    this._tmpAmmoVectorRCB = new this.bjsAMMO.btVector3(to.x, to.y, to.z);
    const rayCallback = new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB);
    this.world.rayTest(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB, rayCallback);
    result.reset(from, to);
    if (rayCallback.hasHit()) {
      result.setHitData({
        x: rayCallback.get_m_hitNormalWorld().x(),
        y: rayCallback.get_m_hitNormalWorld().y(),
        z: rayCallback.get_m_hitNormalWorld().z()
      }, {
        x: rayCallback.get_m_hitPointWorld().x(),
        y: rayCallback.get_m_hitPointWorld().y(),
        z: rayCallback.get_m_hitPointWorld().z()
      });
      result.calculateHitDistance();
    }
    this.bjsAMMO.destroy(rayCallback);
    this.bjsAMMO.destroy(this._tmpAmmoVectorRCA);
    this.bjsAMMO.destroy(this._tmpAmmoVectorRCB);
  }
};
AmmoJSPlugin._DISABLE_COLLISION_FLAG = 4;
AmmoJSPlugin._KINEMATIC_FLAG = 2;
AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG = 4;

// node_modules/@babylonjs/core/Probes/reflectionProbe.js
AbstractScene.prototype.removeReflectionProbe = function(toRemove) {
  if (!this.reflectionProbes) {
    return -1;
  }
  const index = this.reflectionProbes.indexOf(toRemove);
  if (index !== -1) {
    this.reflectionProbes.splice(index, 1);
  }
  return index;
};
AbstractScene.prototype.addReflectionProbe = function(newReflectionProbe) {
  if (!this.reflectionProbes) {
    this.reflectionProbes = [];
  }
  this.reflectionProbes.push(newReflectionProbe);
};
var ReflectionProbe = class {
  constructor(name137, size, scene, generateMipMaps = true, useFloat = false, linearSpace = false) {
    this.name = name137;
    this._viewMatrix = Matrix.Identity();
    this._target = Vector3.Zero();
    this._add = Vector3.Zero();
    this._invertYAxis = false;
    this.position = Vector3.Zero();
    this.metadata = null;
    this._parentContainer = null;
    this._scene = scene;
    if (scene.getEngine().supportsUniformBuffers) {
      this._sceneUBOs = [];
      for (let i = 0; i < 6; ++i) {
        this._sceneUBOs.push(scene.createSceneUniformBuffer(`Scene for Reflection Probe (name "${name137}") face #${i}`));
      }
    }
    if (!this._scene.reflectionProbes) {
      this._scene.reflectionProbes = new Array();
    }
    this._scene.reflectionProbes.push(this);
    let textureType = 0;
    if (useFloat) {
      const caps = this._scene.getEngine().getCaps();
      if (caps.textureHalfFloatRender) {
        textureType = 2;
      } else if (caps.textureFloatRender) {
        textureType = 1;
      }
    }
    this._renderTargetTexture = new RenderTargetTexture(name137, size, scene, generateMipMaps, true, textureType, true);
    this._renderTargetTexture.gammaSpace = !linearSpace;
    const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;
    this._renderTargetTexture.onBeforeRenderObservable.add((faceIndex) => {
      if (this._sceneUBOs) {
        scene.setSceneUniformBuffer(this._sceneUBOs[faceIndex]);
        scene.getSceneUniformBuffer().unbindEffect();
      }
      switch (faceIndex) {
        case 0:
          this._add.copyFromFloats(1, 0, 0);
          break;
        case 1:
          this._add.copyFromFloats(-1, 0, 0);
          break;
        case 2:
          this._add.copyFromFloats(0, this._invertYAxis ? 1 : -1, 0);
          break;
        case 3:
          this._add.copyFromFloats(0, this._invertYAxis ? -1 : 1, 0);
          break;
        case 4:
          this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? -1 : 1);
          break;
        case 5:
          this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? 1 : -1);
          break;
      }
      if (this._attachedMesh) {
        this.position.copyFrom(this._attachedMesh.getAbsolutePosition());
      }
      this.position.addToRef(this._add, this._target);
      const lookAtFunction = scene.useRightHandedSystem ? Matrix.LookAtRHToRef : Matrix.LookAtLHToRef;
      const perspectiveFunction = scene.useRightHandedSystem ? Matrix.PerspectiveFovRH : Matrix.PerspectiveFovLH;
      lookAtFunction(this.position, this._target, Vector3.Up(), this._viewMatrix);
      if (scene.activeCamera) {
        this._projectionMatrix = perspectiveFunction(Math.PI / 2, 1, useReverseDepthBuffer ? scene.activeCamera.maxZ : scene.activeCamera.minZ, useReverseDepthBuffer ? scene.activeCamera.minZ : scene.activeCamera.maxZ, this._scene.getEngine().isNDCHalfZRange);
        scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);
        if (scene.activeCamera.isRigCamera && !this._renderTargetTexture.activeCamera) {
          this._renderTargetTexture.activeCamera = scene.activeCamera.rigParent || null;
        }
      }
      scene._forcedViewPosition = this.position;
    });
    let currentApplyByPostProcess;
    this._renderTargetTexture.onBeforeBindObservable.add(() => {
      var _a, _b;
      this._currentSceneUBO = scene.getSceneUniformBuffer();
      (_b = (_a = scene.getEngine())._debugPushGroup) === null || _b === void 0 ? void 0 : _b.call(_a, `reflection probe generation for ${name137}`, 1);
      currentApplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;
      if (linearSpace) {
        scene.imageProcessingConfiguration.applyByPostProcess = true;
      }
    });
    this._renderTargetTexture.onAfterUnbindObservable.add(() => {
      var _a, _b;
      scene.imageProcessingConfiguration.applyByPostProcess = currentApplyByPostProcess;
      scene._forcedViewPosition = null;
      if (this._sceneUBOs) {
        scene.setSceneUniformBuffer(this._currentSceneUBO);
      }
      scene.updateTransformMatrix(true);
      (_b = (_a = scene.getEngine())._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(_a, 1);
    });
  }
  get samples() {
    return this._renderTargetTexture.samples;
  }
  set samples(value) {
    this._renderTargetTexture.samples = value;
  }
  get refreshRate() {
    return this._renderTargetTexture.refreshRate;
  }
  set refreshRate(value) {
    this._renderTargetTexture.refreshRate = value;
  }
  getScene() {
    return this._scene;
  }
  get cubeTexture() {
    return this._renderTargetTexture;
  }
  get renderList() {
    return this._renderTargetTexture.renderList;
  }
  attachToMesh(mesh) {
    this._attachedMesh = mesh;
  }
  setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil) {
    this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);
  }
  dispose() {
    const index = this._scene.reflectionProbes.indexOf(this);
    if (index !== -1) {
      this._scene.reflectionProbes.splice(index, 1);
    }
    if (this._parentContainer) {
      const index2 = this._parentContainer.reflectionProbes.indexOf(this);
      if (index2 > -1) {
        this._parentContainer.reflectionProbes.splice(index2, 1);
      }
      this._parentContainer = null;
    }
    if (this._renderTargetTexture) {
      this._renderTargetTexture.dispose();
      this._renderTargetTexture = null;
    }
    if (this._sceneUBOs) {
      for (const ubo of this._sceneUBOs) {
        ubo.dispose();
      }
      this._sceneUBOs = [];
    }
  }
  toString(fullDetails) {
    let ret = "Name: " + this.name;
    if (fullDetails) {
      ret += ", position: " + this.position.toString();
      if (this._attachedMesh) {
        ret += ", attached mesh: " + this._attachedMesh.name;
      }
    }
    return ret;
  }
  getClassName() {
    return "ReflectionProbe";
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());
    serializationObject.isReflectionProbe = true;
    serializationObject.metadata = this.metadata;
    return serializationObject;
  }
  static Parse(parsedReflectionProbe, scene, rootUrl) {
    let reflectionProbe = null;
    if (scene.reflectionProbes) {
      for (let index = 0; index < scene.reflectionProbes.length; index++) {
        const rp = scene.reflectionProbes[index];
        if (rp.name === parsedReflectionProbe.name) {
          reflectionProbe = rp;
          break;
        }
      }
    }
    reflectionProbe = SerializationHelper.Parse(() => reflectionProbe || new ReflectionProbe(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps), parsedReflectionProbe, scene, rootUrl);
    reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;
    if (parsedReflectionProbe._attachedMesh) {
      reflectionProbe.attachToMesh(scene.getMeshById(parsedReflectionProbe._attachedMesh));
    }
    if (parsedReflectionProbe.metadata) {
      reflectionProbe.metadata = parsedReflectionProbe.metadata;
    }
    return reflectionProbe;
  }
};
__decorate([
  serializeAsMeshReference()
], ReflectionProbe.prototype, "_attachedMesh", void 0);
__decorate([
  serializeAsVector3()
], ReflectionProbe.prototype, "position", void 0);

// node_modules/@babylonjs/core/Loading/Plugins/babylonFileLoader.js
var _BabylonLoaderRegistered = true;
var BabylonFileLoaderConfiguration = class {
};
BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine = void 0;
var tempIndexContainer = {};
var tempMaterialIndexContainer = {};
var parseMaterialByPredicate = (predicate, parsedData, scene, rootUrl) => {
  if (!parsedData.materials) {
    return null;
  }
  for (let index = 0, cache = parsedData.materials.length; index < cache; index++) {
    const parsedMaterial = parsedData.materials[index];
    if (predicate(parsedMaterial)) {
      return { parsedMaterial, material: Material.Parse(parsedMaterial, scene, rootUrl) };
    }
  }
  return null;
};
var isDescendantOf = (mesh, names, hierarchyIds) => {
  for (const i in names) {
    if (mesh.name === names[i]) {
      hierarchyIds.push(mesh.id);
      return true;
    }
  }
  if (mesh.parentId !== void 0 && hierarchyIds.indexOf(mesh.parentId) !== -1) {
    hierarchyIds.push(mesh.id);
    return true;
  }
  return false;
};
var logOperation = (operation, producer) => {
  return operation + " of " + (producer ? producer.file + " from " + producer.name + " version: " + producer.version + ", exporter version: " + producer.exporter_version : "unknown");
};
var loadDetailLevels = (scene, mesh) => {
  const mastermesh = mesh;
  if (mesh._waitingData.lods) {
    if (mesh._waitingData.lods.ids && mesh._waitingData.lods.ids.length > 0) {
      const lodmeshes = mesh._waitingData.lods.ids;
      const wasenabled = mastermesh.isEnabled(false);
      if (mesh._waitingData.lods.distances) {
        const distances = mesh._waitingData.lods.distances;
        if (distances.length >= lodmeshes.length) {
          const culling = distances.length > lodmeshes.length ? distances[distances.length - 1] : 0;
          mastermesh.setEnabled(false);
          for (let index = 0; index < lodmeshes.length; index++) {
            const lodid = lodmeshes[index];
            const lodmesh = scene.getMeshById(lodid);
            if (lodmesh != null) {
              mastermesh.addLODLevel(distances[index], lodmesh);
            }
          }
          if (culling > 0) {
            mastermesh.addLODLevel(culling, null);
          }
          if (wasenabled === true) {
            mastermesh.setEnabled(true);
          }
        } else {
          Tools.Warn("Invalid level of detail distances for " + mesh.name);
        }
      }
    }
    mesh._waitingData.lods = null;
  }
};
var findParent = (parentId, parentInstanceIndex, scene) => {
  if (typeof parentId !== "number") {
    const parentEntry = scene.getLastEntryById(parentId);
    if (parentEntry && parentInstanceIndex !== void 0 && parentInstanceIndex !== null) {
      const instance = parentEntry.instances[parseInt(parentInstanceIndex)];
      return instance;
    }
    return parentEntry;
  }
  const parent = tempIndexContainer[parentId];
  if (parent && parentInstanceIndex !== void 0 && parentInstanceIndex !== null) {
    const instance = parent.instances[parseInt(parentInstanceIndex)];
    return instance;
  }
  return parent;
};
var findMaterial = (materialId, scene) => {
  if (typeof materialId !== "number") {
    return scene.getLastMaterialById(materialId, true);
  }
  return tempMaterialIndexContainer[materialId];
};
var loadAssetContainer = (scene, data, rootUrl, onError, addToScene = false) => {
  const container = new AssetContainer(scene);
  let log = "importScene has failed JSON parse";
  try {
    var parsedData = JSON.parse(data);
    log = "";
    const fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;
    let index;
    let cache;
    if (parsedData.environmentTexture !== void 0 && parsedData.environmentTexture !== null) {
      const isPBR = parsedData.isPBR !== void 0 ? parsedData.isPBR : true;
      if (parsedData.environmentTextureType && parsedData.environmentTextureType === "BABYLON.HDRCubeTexture") {
        const hdrSize = parsedData.environmentTextureSize ? parsedData.environmentTextureSize : 128;
        const hdrTexture = new HDRCubeTexture((parsedData.environmentTexture.match(/https?:\/\//g) ? "" : rootUrl) + parsedData.environmentTexture, scene, hdrSize, true, !isPBR, void 0, parsedData.environmentTexturePrefilterOnLoad);
        if (parsedData.environmentTextureRotationY) {
          hdrTexture.rotationY = parsedData.environmentTextureRotationY;
        }
        scene.environmentTexture = hdrTexture;
      } else {
        if (typeof parsedData.environmentTexture === "object") {
          const environmentTexture = CubeTexture.Parse(parsedData.environmentTexture, scene, rootUrl);
          scene.environmentTexture = environmentTexture;
        } else if (parsedData.environmentTexture.endsWith(".env")) {
          const compressedTexture = new CubeTexture((parsedData.environmentTexture.match(/https?:\/\//g) ? "" : rootUrl) + parsedData.environmentTexture, scene, parsedData.environmentTextureForcedExtension);
          if (parsedData.environmentTextureRotationY) {
            compressedTexture.rotationY = parsedData.environmentTextureRotationY;
          }
          scene.environmentTexture = compressedTexture;
        } else {
          const cubeTexture = CubeTexture.CreateFromPrefilteredData((parsedData.environmentTexture.match(/https?:\/\//g) ? "" : rootUrl) + parsedData.environmentTexture, scene, parsedData.environmentTextureForcedExtension);
          if (parsedData.environmentTextureRotationY) {
            cubeTexture.rotationY = parsedData.environmentTextureRotationY;
          }
          scene.environmentTexture = cubeTexture;
        }
      }
      if (parsedData.createDefaultSkybox === true) {
        const skyboxScale = scene.activeCamera !== void 0 && scene.activeCamera !== null ? (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2 : 1e3;
        const skyboxBlurLevel = parsedData.skyboxBlurLevel || 0;
        scene.createDefaultSkybox(scene.environmentTexture, isPBR, skyboxScale, skyboxBlurLevel);
      }
      container.environmentTexture = scene.environmentTexture;
    }
    if (parsedData.environmentIntensity !== void 0 && parsedData.environmentIntensity !== null) {
      scene.environmentIntensity = parsedData.environmentIntensity;
    }
    if (parsedData.lights !== void 0 && parsedData.lights !== null) {
      for (index = 0, cache = parsedData.lights.length; index < cache; index++) {
        const parsedLight = parsedData.lights[index];
        const light = Light.Parse(parsedLight, scene);
        if (light) {
          tempIndexContainer[parsedLight.uniqueId] = light;
          container.lights.push(light);
          light._parentContainer = container;
          log += index === 0 ? "\n	Lights:" : "";
          log += "\n		" + light.toString(fullDetails);
        }
      }
    }
    if (parsedData.reflectionProbes !== void 0 && parsedData.reflectionProbes !== null) {
      for (index = 0, cache = parsedData.reflectionProbes.length; index < cache; index++) {
        const parsedReflectionProbe = parsedData.reflectionProbes[index];
        const reflectionProbe = ReflectionProbe.Parse(parsedReflectionProbe, scene, rootUrl);
        if (reflectionProbe) {
          container.reflectionProbes.push(reflectionProbe);
          reflectionProbe._parentContainer = container;
          log += index === 0 ? "\n	Reflection Probes:" : "";
          log += "\n		" + reflectionProbe.toString(fullDetails);
        }
      }
    }
    if (parsedData.animations !== void 0 && parsedData.animations !== null) {
      for (index = 0, cache = parsedData.animations.length; index < cache; index++) {
        const parsedAnimation = parsedData.animations[index];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          const animation = internalClass.Parse(parsedAnimation);
          scene.animations.push(animation);
          container.animations.push(animation);
          log += index === 0 ? "\n	Animations:" : "";
          log += "\n		" + animation.toString(fullDetails);
        }
      }
    }
    if (parsedData.materials !== void 0 && parsedData.materials !== null) {
      for (index = 0, cache = parsedData.materials.length; index < cache; index++) {
        const parsedMaterial = parsedData.materials[index];
        const mat = Material.Parse(parsedMaterial, scene, rootUrl);
        if (mat) {
          tempMaterialIndexContainer[parsedMaterial.uniqueId || parsedMaterial.id] = mat;
          container.materials.push(mat);
          mat._parentContainer = container;
          log += index === 0 ? "\n	Materials:" : "";
          log += "\n		" + mat.toString(fullDetails);
          const textures = mat.getActiveTextures();
          textures.forEach((t) => {
            if (container.textures.indexOf(t) == -1) {
              container.textures.push(t);
              t._parentContainer = container;
            }
          });
        }
      }
    }
    if (parsedData.multiMaterials !== void 0 && parsedData.multiMaterials !== null) {
      for (index = 0, cache = parsedData.multiMaterials.length; index < cache; index++) {
        const parsedMultiMaterial = parsedData.multiMaterials[index];
        const mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);
        tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;
        container.multiMaterials.push(mmat);
        mmat._parentContainer = container;
        log += index === 0 ? "\n	MultiMaterials:" : "";
        log += "\n		" + mmat.toString(fullDetails);
        const textures = mmat.getActiveTextures();
        textures.forEach((t) => {
          if (container.textures.indexOf(t) == -1) {
            container.textures.push(t);
            t._parentContainer = container;
          }
        });
      }
    }
    if (parsedData.morphTargetManagers !== void 0 && parsedData.morphTargetManagers !== null) {
      for (const managerData of parsedData.morphTargetManagers) {
        const manager = MorphTargetManager.Parse(managerData, scene);
        container.morphTargetManagers.push(manager);
        manager._parentContainer = container;
      }
    }
    if (parsedData.skeletons !== void 0 && parsedData.skeletons !== null) {
      for (index = 0, cache = parsedData.skeletons.length; index < cache; index++) {
        const parsedSkeleton = parsedData.skeletons[index];
        const skeleton = Skeleton.Parse(parsedSkeleton, scene);
        container.skeletons.push(skeleton);
        skeleton._parentContainer = container;
        log += index === 0 ? "\n	Skeletons:" : "";
        log += "\n		" + skeleton.toString(fullDetails);
      }
    }
    const geometries = parsedData.geometries;
    if (geometries !== void 0 && geometries !== null) {
      const addedGeometry = new Array();
      const vertexData = geometries.vertexData;
      if (vertexData !== void 0 && vertexData !== null) {
        for (index = 0, cache = vertexData.length; index < cache; index++) {
          const parsedVertexData = vertexData[index];
          addedGeometry.push(Geometry.Parse(parsedVertexData, scene, rootUrl));
        }
      }
      addedGeometry.forEach((g) => {
        if (g) {
          container.geometries.push(g);
          g._parentContainer = container;
        }
      });
    }
    if (parsedData.transformNodes !== void 0 && parsedData.transformNodes !== null) {
      for (index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {
        const parsedTransformNode = parsedData.transformNodes[index];
        const node = TransformNode.Parse(parsedTransformNode, scene, rootUrl);
        tempIndexContainer[parsedTransformNode.uniqueId] = node;
        container.transformNodes.push(node);
        node._parentContainer = container;
      }
    }
    if (parsedData.meshes !== void 0 && parsedData.meshes !== null) {
      for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {
        const parsedMesh = parsedData.meshes[index];
        const mesh = Mesh.Parse(parsedMesh, scene, rootUrl);
        tempIndexContainer[parsedMesh.uniqueId] = mesh;
        container.meshes.push(mesh);
        mesh._parentContainer = container;
        if (mesh.hasInstances) {
          for (const instance of mesh.instances) {
            container.meshes.push(instance);
            instance._parentContainer = container;
          }
        }
        log += index === 0 ? "\n	Meshes:" : "";
        log += "\n		" + mesh.toString(fullDetails);
      }
    }
    if (parsedData.cameras !== void 0 && parsedData.cameras !== null) {
      for (index = 0, cache = parsedData.cameras.length; index < cache; index++) {
        const parsedCamera = parsedData.cameras[index];
        const camera = Camera.Parse(parsedCamera, scene);
        tempIndexContainer[parsedCamera.uniqueId] = camera;
        container.cameras.push(camera);
        camera._parentContainer = container;
        log += index === 0 ? "\n	Cameras:" : "";
        log += "\n		" + camera.toString(fullDetails);
      }
    }
    if (parsedData.postProcesses !== void 0 && parsedData.postProcesses !== null) {
      for (index = 0, cache = parsedData.postProcesses.length; index < cache; index++) {
        const parsedPostProcess = parsedData.postProcesses[index];
        const postProcess = PostProcess.Parse(parsedPostProcess, scene, rootUrl);
        if (postProcess) {
          container.postProcesses.push(postProcess);
          postProcess._parentContainer = container;
          log += index === 0 ? "\nPostprocesses:" : "";
          log += "\n		" + postProcess.toString();
        }
      }
    }
    if (parsedData.animationGroups !== void 0 && parsedData.animationGroups !== null) {
      for (index = 0, cache = parsedData.animationGroups.length; index < cache; index++) {
        const parsedAnimationGroup = parsedData.animationGroups[index];
        const animationGroup = AnimationGroup.Parse(parsedAnimationGroup, scene);
        container.animationGroups.push(animationGroup);
        animationGroup._parentContainer = container;
        log += index === 0 ? "\n	AnimationGroups:" : "";
        log += "\n		" + animationGroup.toString(fullDetails);
      }
    }
    for (index = 0, cache = scene.cameras.length; index < cache; index++) {
      const camera = scene.cameras[index];
      if (camera._waitingParentId !== null) {
        camera.parent = findParent(camera._waitingParentId, camera._waitingParentInstanceIndex, scene);
        camera._waitingParentId = null;
        camera._waitingParentInstanceIndex = null;
      }
    }
    for (index = 0, cache = scene.lights.length; index < cache; index++) {
      const light = scene.lights[index];
      if (light && light._waitingParentId !== null) {
        light.parent = findParent(light._waitingParentId, light._waitingParentInstanceIndex, scene);
        light._waitingParentId = null;
        light._waitingParentInstanceIndex = null;
      }
    }
    for (index = 0, cache = scene.transformNodes.length; index < cache; index++) {
      const transformNode = scene.transformNodes[index];
      if (transformNode._waitingParentId !== null) {
        transformNode.parent = findParent(transformNode._waitingParentId, transformNode._waitingParentInstanceIndex, scene);
        transformNode._waitingParentId = null;
        transformNode._waitingParentInstanceIndex = null;
      }
    }
    for (index = 0, cache = scene.meshes.length; index < cache; index++) {
      const mesh = scene.meshes[index];
      if (mesh._waitingParentId !== null) {
        mesh.parent = findParent(mesh._waitingParentId, mesh._waitingParentInstanceIndex, scene);
        mesh._waitingParentId = null;
        mesh._waitingParentInstanceIndex = null;
      }
      if (mesh._waitingData.lods) {
        loadDetailLevels(scene, mesh);
      }
    }
    scene.multiMaterials.forEach((multimat) => {
      multimat._waitingSubMaterialsUniqueIds.forEach((subMaterial) => {
        multimat.subMaterials.push(findMaterial(subMaterial, scene));
      });
      multimat._waitingSubMaterialsUniqueIds = [];
    });
    scene.meshes.forEach((mesh) => {
      if (mesh._waitingMaterialId !== null) {
        mesh.material = findMaterial(mesh._waitingMaterialId, scene);
        mesh._waitingMaterialId = null;
      }
    });
    for (index = 0, cache = scene.skeletons.length; index < cache; index++) {
      const skeleton = scene.skeletons[index];
      if (skeleton._hasWaitingData) {
        if (skeleton.bones != null) {
          skeleton.bones.forEach((bone) => {
            if (bone._waitingTransformNodeId) {
              const linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId);
              if (linkTransformNode) {
                bone.linkTransformNode(linkTransformNode);
              }
              bone._waitingTransformNodeId = null;
            }
          });
        }
        skeleton._hasWaitingData = null;
      }
    }
    for (index = 0, cache = scene.meshes.length; index < cache; index++) {
      const currentMesh = scene.meshes[index];
      if (currentMesh._waitingData.freezeWorldMatrix) {
        currentMesh.freezeWorldMatrix();
        currentMesh._waitingData.freezeWorldMatrix = null;
      } else {
        currentMesh.computeWorldMatrix(true);
      }
    }
    for (index = 0, cache = scene.lights.length; index < cache; index++) {
      const light = scene.lights[index];
      if (light._excludedMeshesIds.length > 0) {
        for (let excludedIndex = 0; excludedIndex < light._excludedMeshesIds.length; excludedIndex++) {
          const excludedMesh = scene.getMeshById(light._excludedMeshesIds[excludedIndex]);
          if (excludedMesh) {
            light.excludedMeshes.push(excludedMesh);
          }
        }
        light._excludedMeshesIds = [];
      }
      if (light._includedOnlyMeshesIds.length > 0) {
        for (let includedOnlyIndex = 0; includedOnlyIndex < light._includedOnlyMeshesIds.length; includedOnlyIndex++) {
          const includedOnlyMesh = scene.getMeshById(light._includedOnlyMeshesIds[includedOnlyIndex]);
          if (includedOnlyMesh) {
            light.includedOnlyMeshes.push(includedOnlyMesh);
          }
        }
        light._includedOnlyMeshesIds = [];
      }
    }
    scene.geometries.forEach((g) => {
      g._loadedUniqueId = "";
    });
    AbstractScene.Parse(parsedData, scene, container, rootUrl);
    for (index = 0, cache = scene.meshes.length; index < cache; index++) {
      const mesh = scene.meshes[index];
      if (mesh._waitingData.actions) {
        ActionManager.Parse(mesh._waitingData.actions, mesh, scene);
        mesh._waitingData.actions = null;
      }
    }
    if (parsedData.actions !== void 0 && parsedData.actions !== null) {
      ActionManager.Parse(parsedData.actions, null, scene);
    }
  } catch (err) {
    const msg = logOperation("loadAssets", parsedData ? parsedData.producer : "Unknown") + log;
    if (onError) {
      onError(msg, err);
    } else {
      Logger.Log(msg);
      throw err;
    }
  } finally {
    tempIndexContainer = {};
    tempMaterialIndexContainer = {};
    if (!addToScene) {
      container.removeAllFromScene();
    }
    if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {
      Logger.Log(logOperation("loadAssets", parsedData ? parsedData.producer : "Unknown") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : ""));
    }
  }
  return container;
};
SceneLoader.RegisterPlugin({
  name: "babylon.js",
  extensions: ".babylon",
  canDirectLoad: (data) => {
    if (data.indexOf("babylon") !== -1) {
      return true;
    }
    return false;
  },
  importMesh: (meshesNames, scene, data, rootUrl, meshes, particleSystems, skeletons, onError) => {
    var _a;
    let log = "importMesh has failed JSON parse";
    try {
      var parsedData = JSON.parse(data);
      log = "";
      const fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;
      if (!meshesNames) {
        meshesNames = null;
      } else if (!Array.isArray(meshesNames)) {
        meshesNames = [meshesNames];
      }
      const hierarchyIds = new Array();
      const parsedIdToNodeMap = /* @__PURE__ */ new Map();
      const loadedTransformNodes = [];
      if (parsedData.transformNodes !== void 0 && parsedData.transformNodes !== null) {
        for (let index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {
          const parsedJSONTransformNode = parsedData.transformNodes[index];
          const parsedTransformNode = TransformNode.Parse(parsedJSONTransformNode, scene, rootUrl);
          loadedTransformNodes.push(parsedTransformNode);
          parsedIdToNodeMap.set(parsedTransformNode._waitingParsedUniqueId, parsedTransformNode);
          parsedTransformNode._waitingParsedUniqueId = null;
        }
      }
      if (parsedData.meshes !== void 0 && parsedData.meshes !== null) {
        const loadedSkeletonsIds = [];
        const loadedMaterialsIds = [];
        const loadedMaterialsUniqueIds = [];
        const loadedMorphTargetsIds = [];
        for (let index = 0, cache = parsedData.meshes.length; index < cache; index++) {
          const parsedMesh = parsedData.meshes[index];
          if (meshesNames === null || isDescendantOf(parsedMesh, meshesNames, hierarchyIds)) {
            if (meshesNames !== null) {
              delete meshesNames[meshesNames.indexOf(parsedMesh.name)];
            }
            if (parsedMesh.geometryId !== void 0 && parsedMesh.geometryId !== null) {
              if (parsedData.geometries !== void 0 && parsedData.geometries !== null) {
                let found = false;
                ["boxes", "spheres", "cylinders", "toruses", "grounds", "planes", "torusKnots", "vertexData"].forEach((geometryType) => {
                  if (found === true || !parsedData.geometries[geometryType] || !Array.isArray(parsedData.geometries[geometryType])) {
                    return;
                  } else {
                    parsedData.geometries[geometryType].forEach((parsedGeometryData) => {
                      if (parsedGeometryData.id === parsedMesh.geometryId) {
                        switch (geometryType) {
                          case "vertexData":
                            Geometry.Parse(parsedGeometryData, scene, rootUrl);
                            break;
                        }
                        found = true;
                      }
                    });
                  }
                });
                if (found === false) {
                  Logger.Warn("Geometry not found for mesh " + parsedMesh.id);
                }
              }
            }
            if (parsedMesh.materialUniqueId || parsedMesh.materialId) {
              const materialArray = parsedMesh.materialUniqueId ? loadedMaterialsUniqueIds : loadedMaterialsIds;
              let materialFound = materialArray.indexOf(parsedMesh.materialUniqueId || parsedMesh.materialId) !== -1;
              if (materialFound === false && parsedData.multiMaterials !== void 0 && parsedData.multiMaterials !== null) {
                const loadSubMaterial = (subMatId, predicate) => {
                  materialArray.push(subMatId);
                  const mat = parseMaterialByPredicate(predicate, parsedData, scene, rootUrl);
                  if (mat && mat.material) {
                    tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;
                    log += "\n	Material " + mat.material.toString(fullDetails);
                  }
                };
                for (let multimatIndex = 0, multimatCache = parsedData.multiMaterials.length; multimatIndex < multimatCache; multimatIndex++) {
                  const parsedMultiMaterial = parsedData.multiMaterials[multimatIndex];
                  if (parsedMesh.materialUniqueId && parsedMultiMaterial.uniqueId === parsedMesh.materialUniqueId || parsedMultiMaterial.id === parsedMesh.materialId) {
                    if (parsedMultiMaterial.materialsUniqueIds) {
                      parsedMultiMaterial.materialsUniqueIds.forEach((subMatId) => loadSubMaterial(subMatId, (parsedMaterial) => parsedMaterial.uniqueId === subMatId));
                    } else {
                      parsedMultiMaterial.materials.forEach((subMatId) => loadSubMaterial(subMatId, (parsedMaterial) => parsedMaterial.id === subMatId));
                    }
                    materialArray.push(parsedMultiMaterial.uniqueId || parsedMultiMaterial.id);
                    const mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);
                    tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;
                    if (mmat) {
                      materialFound = true;
                      log += "\n	Multi-Material " + mmat.toString(fullDetails);
                    }
                    break;
                  }
                }
              }
              if (materialFound === false) {
                materialArray.push(parsedMesh.materialUniqueId || parsedMesh.materialId);
                const mat = parseMaterialByPredicate((parsedMaterial) => parsedMesh.materialUniqueId && parsedMaterial.uniqueId === parsedMesh.materialUniqueId || parsedMaterial.id === parsedMesh.materialId, parsedData, scene, rootUrl);
                if (!mat || !mat.material) {
                  Logger.Warn("Material not found for mesh " + parsedMesh.id);
                } else {
                  tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;
                  log += "\n	Material " + mat.material.toString(fullDetails);
                }
              }
            }
            if (parsedMesh.skeletonId > -1 && parsedData.skeletons !== void 0 && parsedData.skeletons !== null) {
              const skeletonAlreadyLoaded = loadedSkeletonsIds.indexOf(parsedMesh.skeletonId) > -1;
              if (!skeletonAlreadyLoaded) {
                for (let skeletonIndex = 0, skeletonCache = parsedData.skeletons.length; skeletonIndex < skeletonCache; skeletonIndex++) {
                  const parsedSkeleton = parsedData.skeletons[skeletonIndex];
                  if (parsedSkeleton.id === parsedMesh.skeletonId) {
                    const skeleton = Skeleton.Parse(parsedSkeleton, scene);
                    skeletons.push(skeleton);
                    loadedSkeletonsIds.push(parsedSkeleton.id);
                    log += "\n	Skeleton " + skeleton.toString(fullDetails);
                  }
                }
              }
            }
            if (parsedMesh.morphTargetManagerId > -1 && parsedData.morphTargetManagers !== void 0 && parsedData.morphTargetManagers !== null) {
              const morphTargetAlreadyLoaded = loadedMorphTargetsIds.indexOf(parsedMesh.morphTargetManagerId) > -1;
              if (!morphTargetAlreadyLoaded) {
                for (let morphTargetIndex = 0, morphTargetCache = parsedData.morphTargetManagers.length; morphTargetIndex < morphTargetCache; morphTargetIndex++) {
                  const parsedMorphTarget = parsedData.morphTargetManagers[morphTargetIndex];
                  if (parsedMorphTarget.id === parsedMesh.morphTargetManagerId) {
                    const morphTarget = MorphTargetManager.Parse(parsedMorphTarget, scene);
                    loadedMorphTargetsIds.push(morphTarget.uniqueId);
                    log += "\nMorph target " + morphTarget.toString();
                  }
                }
              }
            }
            const mesh = Mesh.Parse(parsedMesh, scene, rootUrl);
            meshes.push(mesh);
            parsedIdToNodeMap.set(mesh._waitingParsedUniqueId, mesh);
            mesh._waitingParsedUniqueId = null;
            log += "\n	Mesh " + mesh.toString(fullDetails);
          }
        }
        scene.multiMaterials.forEach((multimat) => {
          multimat._waitingSubMaterialsUniqueIds.forEach((subMaterial) => {
            multimat.subMaterials.push(findMaterial(subMaterial, scene));
          });
          multimat._waitingSubMaterialsUniqueIds = [];
        });
        scene.meshes.forEach((mesh) => {
          if (mesh._waitingMaterialId !== null) {
            mesh.material = findMaterial(mesh._waitingMaterialId, scene);
            mesh._waitingMaterialId = null;
          }
        });
        for (let index = 0, cache = scene.transformNodes.length; index < cache; index++) {
          const transformNode = scene.transformNodes[index];
          if (transformNode._waitingParentId !== null) {
            let parent = parsedIdToNodeMap.get(parseInt(transformNode._waitingParentId)) || null;
            if (parent === null) {
              parent = scene.getLastEntryById(transformNode._waitingParentId);
            }
            let parentNode = parent;
            if (transformNode._waitingParentInstanceIndex) {
              parentNode = parent.instances[parseInt(transformNode._waitingParentInstanceIndex)];
              transformNode._waitingParentInstanceIndex = null;
            }
            transformNode.parent = parentNode;
            transformNode._waitingParentId = null;
          }
        }
        let currentMesh;
        for (let index = 0, cache = scene.meshes.length; index < cache; index++) {
          currentMesh = scene.meshes[index];
          if (currentMesh._waitingParentId) {
            let parent = parsedIdToNodeMap.get(parseInt(currentMesh._waitingParentId)) || null;
            if (parent === null) {
              parent = scene.getLastEntryById(currentMesh._waitingParentId);
            }
            let parentNode = parent;
            if (currentMesh._waitingParentInstanceIndex) {
              parentNode = parent.instances[parseInt(currentMesh._waitingParentInstanceIndex)];
              currentMesh._waitingParentInstanceIndex = null;
            }
            currentMesh.parent = parentNode;
            if (((_a = currentMesh.parent) === null || _a === void 0 ? void 0 : _a.getClassName()) === "TransformNode") {
              const loadedTransformNodeIndex = loadedTransformNodes.indexOf(currentMesh.parent);
              if (loadedTransformNodeIndex > -1) {
                loadedTransformNodes.splice(loadedTransformNodeIndex, 1);
              }
            }
            currentMesh._waitingParentId = null;
          }
          if (currentMesh._waitingData.lods) {
            loadDetailLevels(scene, currentMesh);
          }
        }
        for (const transformNode of loadedTransformNodes) {
          transformNode.dispose();
        }
        for (let index = 0, cache = scene.skeletons.length; index < cache; index++) {
          const skeleton = scene.skeletons[index];
          if (skeleton._hasWaitingData) {
            if (skeleton.bones != null) {
              skeleton.bones.forEach((bone) => {
                if (bone._waitingTransformNodeId) {
                  const linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId);
                  if (linkTransformNode) {
                    bone.linkTransformNode(linkTransformNode);
                  }
                  bone._waitingTransformNodeId = null;
                }
              });
            }
            skeleton._hasWaitingData = null;
          }
        }
        for (let index = 0, cache = scene.meshes.length; index < cache; index++) {
          currentMesh = scene.meshes[index];
          if (currentMesh._waitingData.freezeWorldMatrix) {
            currentMesh.freezeWorldMatrix();
            currentMesh._waitingData.freezeWorldMatrix = null;
          } else {
            currentMesh.computeWorldMatrix(true);
          }
        }
      }
      if (parsedData.particleSystems !== void 0 && parsedData.particleSystems !== null) {
        const parser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);
        if (parser) {
          for (let index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {
            const parsedParticleSystem = parsedData.particleSystems[index];
            if (hierarchyIds.indexOf(parsedParticleSystem.emitterId) !== -1) {
              particleSystems.push(parser(parsedParticleSystem, scene, rootUrl));
            }
          }
        }
      }
      return true;
    } catch (err) {
      const msg = logOperation("importMesh", parsedData ? parsedData.producer : "Unknown") + log;
      if (onError) {
        onError(msg, err);
      } else {
        Logger.Log(msg);
        throw err;
      }
    } finally {
      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {
        Logger.Log(logOperation("importMesh", parsedData ? parsedData.producer : "Unknown") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : ""));
      }
    }
    return false;
  },
  load: (scene, data, rootUrl, onError) => {
    let log = "importScene has failed JSON parse";
    try {
      var parsedData = JSON.parse(data);
      log = "";
      if (parsedData.useDelayedTextureLoading !== void 0 && parsedData.useDelayedTextureLoading !== null) {
        scene.useDelayedTextureLoading = parsedData.useDelayedTextureLoading && !SceneLoader.ForceFullSceneLoadingForIncremental;
      }
      if (parsedData.autoClear !== void 0 && parsedData.autoClear !== null) {
        scene.autoClear = parsedData.autoClear;
      }
      if (parsedData.clearColor !== void 0 && parsedData.clearColor !== null) {
        scene.clearColor = Color4.FromArray(parsedData.clearColor);
      }
      if (parsedData.ambientColor !== void 0 && parsedData.ambientColor !== null) {
        scene.ambientColor = Color3.FromArray(parsedData.ambientColor);
      }
      if (parsedData.gravity !== void 0 && parsedData.gravity !== null) {
        scene.gravity = Vector3.FromArray(parsedData.gravity);
      }
      if (parsedData.useRightHandedSystem !== void 0) {
        scene.useRightHandedSystem = !!parsedData.useRightHandedSystem;
      }
      if (parsedData.fogMode && parsedData.fogMode !== 0) {
        scene.fogMode = parsedData.fogMode;
        scene.fogColor = Color3.FromArray(parsedData.fogColor);
        scene.fogStart = parsedData.fogStart;
        scene.fogEnd = parsedData.fogEnd;
        scene.fogDensity = parsedData.fogDensity;
        log += "	Fog mode for scene:  ";
        switch (scene.fogMode) {
          case 1:
            log += "exp\n";
            break;
          case 2:
            log += "exp2\n";
            break;
          case 3:
            log += "linear\n";
            break;
        }
      }
      if (parsedData.physicsEnabled) {
        let physicsPlugin;
        if (parsedData.physicsEngine === "cannon" || parsedData.physicsEngine === CannonJSPlugin.name) {
          physicsPlugin = new CannonJSPlugin(void 0, void 0, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);
        } else if (parsedData.physicsEngine === "oimo" || parsedData.physicsEngine === OimoJSPlugin.name) {
          physicsPlugin = new OimoJSPlugin(void 0, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);
        } else if (parsedData.physicsEngine === "ammo" || parsedData.physicsEngine === AmmoJSPlugin.name) {
          physicsPlugin = new AmmoJSPlugin(void 0, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine, void 0);
        }
        log = "	Physics engine " + (parsedData.physicsEngine ? parsedData.physicsEngine : "oimo") + " enabled\n";
        const physicsGravity = parsedData.physicsGravity ? Vector3.FromArray(parsedData.physicsGravity) : null;
        scene.enablePhysics(physicsGravity, physicsPlugin);
      }
      if (parsedData.metadata !== void 0 && parsedData.metadata !== null) {
        scene.metadata = parsedData.metadata;
      }
      if (parsedData.collisionsEnabled !== void 0 && parsedData.collisionsEnabled !== null) {
        scene.collisionsEnabled = parsedData.collisionsEnabled;
      }
      const container = loadAssetContainer(scene, data, rootUrl, onError, true);
      if (!container) {
        return false;
      }
      if (parsedData.autoAnimate) {
        scene.beginAnimation(scene, parsedData.autoAnimateFrom, parsedData.autoAnimateTo, parsedData.autoAnimateLoop, parsedData.autoAnimateSpeed || 1);
      }
      if (parsedData.activeCameraID !== void 0 && parsedData.activeCameraID !== null) {
        scene.setActiveCameraById(parsedData.activeCameraID);
      }
      return true;
    } catch (err) {
      const msg = logOperation("importScene", parsedData ? parsedData.producer : "Unknown") + log;
      if (onError) {
        onError(msg, err);
      } else {
        Logger.Log(msg);
        throw err;
      }
    } finally {
      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {
        Logger.Log(logOperation("importScene", parsedData ? parsedData.producer : "Unknown") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : ""));
      }
    }
    return false;
  },
  loadAssetContainer: (scene, data, rootUrl, onError) => {
    const container = loadAssetContainer(scene, data, rootUrl, onError);
    return container;
  }
});

// node_modules/@babylonjs/core/Materials/fresnelParameters.js
var FresnelParameters = class {
  constructor(options = {}) {
    this._isEnabled = true;
    this.bias = options.bias === void 0 ? 0 : options.bias;
    this.power = options.power === void 0 ? 1 : options.power;
    this.leftColor = options.leftColor || Color3.White();
    this.rightColor = options.rightColor || Color3.Black();
    if (options.isEnabled === false) {
      this.isEnabled = false;
    }
  }
  get isEnabled() {
    return this._isEnabled;
  }
  set isEnabled(value) {
    if (this._isEnabled === value) {
      return;
    }
    this._isEnabled = value;
    Engine.MarkAllMaterialsAsDirty(4 | 16);
  }
  clone() {
    const newFresnelParameters = new FresnelParameters();
    DeepCopier.DeepCopy(this, newFresnelParameters);
    return newFresnelParameters;
  }
  equals(otherFresnelParameters) {
    return otherFresnelParameters && this.bias === otherFresnelParameters.bias && this.power === otherFresnelParameters.power && this.leftColor.equals(otherFresnelParameters.leftColor) && this.rightColor.equals(otherFresnelParameters.rightColor) && this.isEnabled === otherFresnelParameters.isEnabled;
  }
  serialize() {
    return {
      isEnabled: this.isEnabled,
      leftColor: this.leftColor.asArray(),
      rightColor: this.rightColor.asArray(),
      bias: this.bias,
      power: this.power
    };
  }
  static Parse(parsedFresnelParameters) {
    return new FresnelParameters({
      isEnabled: parsedFresnelParameters.isEnabled,
      leftColor: Color3.FromArray(parsedFresnelParameters.leftColor),
      rightColor: Color3.FromArray(parsedFresnelParameters.rightColor),
      bias: parsedFresnelParameters.bias,
      power: parsedFresnelParameters.power || 1
    });
  }
};
SerializationHelper._FresnelParametersParser = FresnelParameters.Parse;

// node_modules/@babylonjs/core/Materials/Occlusion/occlusionMaterial.js
var OcclusionMaterial = class extends ShaderMaterial {
  constructor(name137, scene) {
    super(name137, scene, "color", {
      attributes: ["position"],
      uniforms: ["world", "viewProjection", "color"]
    });
    this.disableColorWrite = true;
    this.forceDepthWrite = true;
    this.setColor4("color", new Color4(0, 0, 0, 1));
  }
};

// node_modules/@babylonjs/core/Materials/PBR/pbrBaseSimpleMaterial.js
var PBRBaseSimpleMaterial = class extends PBRBaseMaterial {
  constructor(name137, scene) {
    super(name137, scene);
    this.maxSimultaneousLights = 4;
    this.disableLighting = false;
    this.invertNormalMapX = false;
    this.invertNormalMapY = false;
    this.emissiveColor = new Color3(0, 0, 0);
    this.occlusionStrength = 1;
    this.useLightmapAsShadowmap = false;
    this._useAlphaFromAlbedoTexture = true;
    this._useAmbientInGrayScale = true;
  }
  get doubleSided() {
    return this._twoSidedLighting;
  }
  set doubleSided(value) {
    if (this._twoSidedLighting === value) {
      return;
    }
    this._twoSidedLighting = value;
    this.backFaceCulling = !value;
    this._markAllSubMeshesAsTexturesDirty();
  }
  getClassName() {
    return "PBRBaseSimpleMaterial";
  }
};
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], PBRBaseSimpleMaterial.prototype, "maxSimultaneousLights", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], PBRBaseSimpleMaterial.prototype, "disableLighting", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", "_reflectionTexture")
], PBRBaseSimpleMaterial.prototype, "environmentTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRBaseSimpleMaterial.prototype, "invertNormalMapX", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRBaseSimpleMaterial.prototype, "invertNormalMapY", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", "_bumpTexture")
], PBRBaseSimpleMaterial.prototype, "normalTexture", void 0);
__decorate([
  serializeAsColor3("emissive"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRBaseSimpleMaterial.prototype, "emissiveColor", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRBaseSimpleMaterial.prototype, "emissiveTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", "_ambientTextureStrength")
], PBRBaseSimpleMaterial.prototype, "occlusionStrength", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", "_ambientTexture")
], PBRBaseSimpleMaterial.prototype, "occlusionTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", "_alphaCutOff")
], PBRBaseSimpleMaterial.prototype, "alphaCutOff", void 0);
__decorate([
  serialize()
], PBRBaseSimpleMaterial.prototype, "doubleSided", null);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", null)
], PBRBaseSimpleMaterial.prototype, "lightmapTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRBaseSimpleMaterial.prototype, "useLightmapAsShadowmap", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrMetallicRoughnessMaterial.js
var PBRMetallicRoughnessMaterial = class extends PBRBaseSimpleMaterial {
  constructor(name137, scene) {
    super(name137, scene);
    this._useRoughnessFromMetallicTextureAlpha = false;
    this._useRoughnessFromMetallicTextureGreen = true;
    this._useMetallnessFromMetallicTextureBlue = true;
    this.metallic = 1;
    this.roughness = 1;
  }
  getClassName() {
    return "PBRMetallicRoughnessMaterial";
  }
  clone(name137) {
    const clone = SerializationHelper.Clone(() => new PBRMetallicRoughnessMaterial(name137, this.getScene()), this);
    clone.id = name137;
    clone.name = name137;
    this.clearCoat.copyTo(clone.clearCoat);
    this.anisotropy.copyTo(clone.anisotropy);
    this.brdf.copyTo(clone.brdf);
    this.sheen.copyTo(clone.sheen);
    this.subSurface.copyTo(clone.subSurface);
    return clone;
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.PBRMetallicRoughnessMaterial";
    serializationObject.clearCoat = this.clearCoat.serialize();
    serializationObject.anisotropy = this.anisotropy.serialize();
    serializationObject.brdf = this.brdf.serialize();
    serializationObject.sheen = this.sheen.serialize();
    serializationObject.subSurface = this.subSurface.serialize();
    serializationObject.iridescence = this.iridescence.serialize();
    return serializationObject;
  }
  static Parse(source, scene, rootUrl) {
    const material = SerializationHelper.Parse(() => new PBRMetallicRoughnessMaterial(source.name, scene), source, scene, rootUrl);
    if (source.clearCoat) {
      material.clearCoat.parse(source.clearCoat, scene, rootUrl);
    }
    if (source.anisotropy) {
      material.anisotropy.parse(source.anisotropy, scene, rootUrl);
    }
    if (source.brdf) {
      material.brdf.parse(source.brdf, scene, rootUrl);
    }
    if (source.sheen) {
      material.sheen.parse(source.sheen, scene, rootUrl);
    }
    if (source.subSurface) {
      material.subSurface.parse(source.subSurface, scene, rootUrl);
    }
    if (source.iridescence) {
      material.iridescence.parse(source.iridescence, scene, rootUrl);
    }
    return material;
  }
};
__decorate([
  serializeAsColor3(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", "_albedoColor")
], PBRMetallicRoughnessMaterial.prototype, "baseColor", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", "_albedoTexture")
], PBRMetallicRoughnessMaterial.prototype, "baseTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMetallicRoughnessMaterial.prototype, "metallic", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMetallicRoughnessMaterial.prototype, "roughness", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", "_metallicTexture")
], PBRMetallicRoughnessMaterial.prototype, "metallicRoughnessTexture", void 0);
RegisterClass("BABYLON.PBRMetallicRoughnessMaterial", PBRMetallicRoughnessMaterial);

// node_modules/@babylonjs/core/Materials/PBR/pbrSpecularGlossinessMaterial.js
var PBRSpecularGlossinessMaterial = class extends PBRBaseSimpleMaterial {
  constructor(name137, scene) {
    super(name137, scene);
    this._useMicroSurfaceFromReflectivityMapAlpha = true;
  }
  get useMicroSurfaceFromReflectivityMapAlpha() {
    return this._useMicroSurfaceFromReflectivityMapAlpha;
  }
  getClassName() {
    return "PBRSpecularGlossinessMaterial";
  }
  clone(name137) {
    const clone = SerializationHelper.Clone(() => new PBRSpecularGlossinessMaterial(name137, this.getScene()), this);
    clone.id = name137;
    clone.name = name137;
    this.clearCoat.copyTo(clone.clearCoat);
    this.anisotropy.copyTo(clone.anisotropy);
    this.brdf.copyTo(clone.brdf);
    this.sheen.copyTo(clone.sheen);
    this.subSurface.copyTo(clone.subSurface);
    return clone;
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.PBRSpecularGlossinessMaterial";
    serializationObject.clearCoat = this.clearCoat.serialize();
    serializationObject.anisotropy = this.anisotropy.serialize();
    serializationObject.brdf = this.brdf.serialize();
    serializationObject.sheen = this.sheen.serialize();
    serializationObject.subSurface = this.subSurface.serialize();
    serializationObject.iridescence = this.iridescence.serialize();
    return serializationObject;
  }
  static Parse(source, scene, rootUrl) {
    const material = SerializationHelper.Parse(() => new PBRSpecularGlossinessMaterial(source.name, scene), source, scene, rootUrl);
    if (source.clearCoat) {
      material.clearCoat.parse(source.clearCoat, scene, rootUrl);
    }
    if (source.anisotropy) {
      material.anisotropy.parse(source.anisotropy, scene, rootUrl);
    }
    if (source.brdf) {
      material.brdf.parse(source.brdf, scene, rootUrl);
    }
    if (source.sheen) {
      material.sheen.parse(source.sheen, scene, rootUrl);
    }
    if (source.subSurface) {
      material.subSurface.parse(source.subSurface, scene, rootUrl);
    }
    if (source.iridescence) {
      material.iridescence.parse(source.iridescence, scene, rootUrl);
    }
    return material;
  }
};
__decorate([
  serializeAsColor3("diffuse"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", "_albedoColor")
], PBRSpecularGlossinessMaterial.prototype, "diffuseColor", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", "_albedoTexture")
], PBRSpecularGlossinessMaterial.prototype, "diffuseTexture", void 0);
__decorate([
  serializeAsColor3("specular"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", "_reflectivityColor")
], PBRSpecularGlossinessMaterial.prototype, "specularColor", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", "_microSurface")
], PBRSpecularGlossinessMaterial.prototype, "glossiness", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", "_reflectivityTexture")
], PBRSpecularGlossinessMaterial.prototype, "specularGlossinessTexture", void 0);
RegisterClass("BABYLON.PBRSpecularGlossinessMaterial", PBRSpecularGlossinessMaterial);

// node_modules/@babylonjs/core/Materials/Textures/colorGradingTexture.js
var ColorGradingTexture = class extends BaseTexture {
  constructor(url, sceneOrEngine, onLoad = null) {
    super(sceneOrEngine);
    if (!url) {
      return;
    }
    this._textureMatrix = Matrix.Identity();
    this.name = url;
    this.url = url;
    this._onLoad = onLoad;
    this._texture = this._getFromCache(url, true);
    if (!this._texture) {
      const scene = this.getScene();
      if (scene) {
        if (!scene.useDelayedTextureLoading) {
          this._loadTexture();
        } else {
          this.delayLoadState = 4;
        }
      } else {
        this._loadTexture();
      }
    } else {
      this._triggerOnLoad();
    }
  }
  _triggerOnLoad() {
    if (this._onLoad) {
      this._onLoad();
    }
  }
  getTextureMatrix() {
    return this._textureMatrix;
  }
  _load3dlTexture() {
    const engine = this._getEngine();
    let texture;
    if (!engine._features.support3DTextures) {
      texture = engine.createRawTexture(null, 1, 1, 5, false, false, 2, null, 0);
    } else {
      texture = engine.createRawTexture3D(null, 1, 1, 1, 5, false, false, 2, null, 0);
    }
    this._texture = texture;
    this._texture.isReady = false;
    this.isCube = false;
    this.is3D = engine._features.support3DTextures;
    this.wrapU = 0;
    this.wrapV = 0;
    this.wrapR = 0;
    this.anisotropicFilteringLevel = 1;
    const callback = (text) => {
      if (typeof text !== "string") {
        return;
      }
      let data = null;
      let tempData = null;
      let line;
      const lines = text.split("\n");
      let size = 0, pixelIndexW = 0, pixelIndexH = 0, pixelIndexSlice = 0;
      let maxColor = 0;
      for (let i = 0; i < lines.length; i++) {
        line = lines[i];
        if (!ColorGradingTexture._NoneEmptyLineRegex.test(line)) {
          continue;
        }
        if (line.indexOf("#") === 0) {
          continue;
        }
        const words = line.split(" ");
        if (size === 0) {
          size = words.length;
          data = new Uint8Array(size * size * size * 4);
          tempData = new Float32Array(size * size * size * 4);
          continue;
        }
        if (size != 0) {
          const r = Math.max(parseInt(words[0]), 0);
          const g = Math.max(parseInt(words[1]), 0);
          const b = Math.max(parseInt(words[2]), 0);
          maxColor = Math.max(r, maxColor);
          maxColor = Math.max(g, maxColor);
          maxColor = Math.max(b, maxColor);
          const pixelStorageIndex = (pixelIndexW + pixelIndexSlice * size + pixelIndexH * size * size) * 4;
          if (tempData) {
            tempData[pixelStorageIndex + 0] = r;
            tempData[pixelStorageIndex + 1] = g;
            tempData[pixelStorageIndex + 2] = b;
          }
          pixelIndexH++;
          if (pixelIndexH % size == 0) {
            pixelIndexSlice++;
            pixelIndexH = 0;
            if (pixelIndexSlice % size == 0) {
              pixelIndexW++;
              pixelIndexSlice = 0;
            }
          }
        }
      }
      if (tempData && data) {
        for (let i = 0; i < tempData.length; i++) {
          if (i > 0 && (i + 1) % 4 === 0) {
            data[i] = 255;
          } else {
            const value = tempData[i];
            data[i] = value / maxColor * 255;
          }
        }
      }
      if (texture.is3D) {
        texture.updateSize(size, size, size);
        engine.updateRawTexture3D(texture, data, 5, false);
      } else {
        texture.updateSize(size * size, size);
        engine.updateRawTexture(texture, data, 5, false);
      }
      texture.isReady = true;
      this._triggerOnLoad();
    };
    const scene = this.getScene();
    if (scene) {
      scene._loadFile(this.url, callback);
    } else {
      engine._loadFile(this.url, callback);
    }
    return this._texture;
  }
  _loadTexture() {
    if (this.url && this.url.toLocaleLowerCase().indexOf(".3dl") == this.url.length - 4) {
      this._load3dlTexture();
    }
  }
  clone() {
    const newTexture = new ColorGradingTexture(this.url, this.getScene() || this._getEngine());
    newTexture.level = this.level;
    return newTexture;
  }
  delayLoad() {
    if (this.delayLoadState !== 4) {
      return;
    }
    this.delayLoadState = 1;
    this._texture = this._getFromCache(this.url, true);
    if (!this._texture) {
      this._loadTexture();
    }
  }
  static Parse(parsedTexture, scene) {
    let texture = null;
    if (parsedTexture.name && !parsedTexture.isRenderTarget) {
      texture = new ColorGradingTexture(parsedTexture.name, scene);
      texture.name = parsedTexture.name;
      texture.level = parsedTexture.level;
    }
    return texture;
  }
  serialize() {
    if (!this.name) {
      return null;
    }
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.level = this.level;
    serializationObject.customType = "BABYLON.ColorGradingTexture";
    return serializationObject;
  }
};
ColorGradingTexture._NoneEmptyLineRegex = /\S+/;
RegisterClass("BABYLON.ColorGradingTexture", ColorGradingTexture);

// node_modules/@babylonjs/core/Materials/Textures/equiRectangularCubeTexture.js
var EquiRectangularCubeTexture = class extends BaseTexture {
  constructor(url, scene, size, noMipmap = false, gammaSpace = true, onLoad = null, onError = null) {
    super(scene);
    this._onLoad = null;
    this._onError = null;
    if (!url) {
      throw new Error("Image url is not set");
    }
    this._coordinatesMode = Texture.CUBIC_MODE;
    this.name = url;
    this.url = url;
    this._size = size;
    this._noMipmap = noMipmap;
    this.gammaSpace = gammaSpace;
    this._onLoad = onLoad;
    this._onError = onError;
    this.hasAlpha = false;
    this.isCube = true;
    this._texture = this._getFromCache(url, this._noMipmap, void 0, void 0, void 0, this.isCube);
    if (!this._texture) {
      if (!scene.useDelayedTextureLoading) {
        this._loadImage(this._loadTexture.bind(this), this._onError);
      } else {
        this.delayLoadState = 4;
      }
    } else if (onLoad) {
      if (this._texture.isReady) {
        Tools.SetImmediate(() => onLoad());
      } else {
        this._texture.onLoadedObservable.add(onLoad);
      }
    }
  }
  _loadImage(loadTextureCallback, onError) {
    const canvas = document.createElement("canvas");
    LoadImage(this.url, (image) => {
      this._width = image.width;
      this._height = image.height;
      canvas.width = this._width;
      canvas.height = this._height;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(image, 0, 0);
      const imageData = ctx.getImageData(0, 0, image.width, image.height);
      this._buffer = imageData.data.buffer;
      canvas.remove();
      loadTextureCallback();
    }, (_, e) => {
      if (onError) {
        onError(`${this.getClassName()} could not be loaded`, e);
      }
    }, null);
  }
  _loadTexture() {
    const scene = this.getScene();
    const callback = () => {
      const imageData = this._getFloat32ArrayFromArrayBuffer(this._buffer);
      const data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, this._width, this._height, this._size);
      const results = [];
      for (let i = 0; i < 6; i++) {
        const dataFace = data[EquiRectangularCubeTexture._FacesMapping[i]];
        results.push(dataFace);
      }
      return results;
    };
    if (!scene) {
      return;
    }
    this._texture = scene.getEngine().createRawCubeTextureFromUrl(this.url, scene, this._size, 4, scene.getEngine().getCaps().textureFloat ? 1 : 7, this._noMipmap, callback, null, this._onLoad, this._onError);
  }
  _getFloat32ArrayFromArrayBuffer(buffer) {
    const dataView = new DataView(buffer);
    const floatImageData = new Float32Array(buffer.byteLength * 3 / 4);
    let k = 0;
    for (let i = 0; i < buffer.byteLength; i++) {
      if ((i + 1) % 4 !== 0) {
        floatImageData[k++] = dataView.getUint8(i) / 255;
      }
    }
    return floatImageData;
  }
  getClassName() {
    return "EquiRectangularCubeTexture";
  }
  clone() {
    const scene = this.getScene();
    if (!scene) {
      return this;
    }
    const newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace);
    newTexture.level = this.level;
    newTexture.wrapU = this.wrapU;
    newTexture.wrapV = this.wrapV;
    newTexture.coordinatesIndex = this.coordinatesIndex;
    newTexture.coordinatesMode = this.coordinatesMode;
    return newTexture;
  }
};
EquiRectangularCubeTexture._FacesMapping = ["right", "left", "up", "down", "front", "back"];

// node_modules/@babylonjs/core/Materials/Textures/htmlElementTexture.js
var HtmlElementTexture = class extends BaseTexture {
  constructor(name137, element, options) {
    var _a, _b;
    super(options.scene || options.engine);
    this.onLoadObservable = new Observable();
    if (!element || !options.engine && !options.scene) {
      return;
    }
    options = {
      ...HtmlElementTexture._DefaultOptions,
      ...options
    };
    this._generateMipMaps = options.generateMipMaps;
    this._samplingMode = options.samplingMode;
    this._textureMatrix = Matrix.Identity();
    this._format = options.format;
    this.name = name137;
    this.element = element;
    this._isVideo = element instanceof HTMLVideoElement;
    this._externalTexture = this._isVideo ? (_b = (_a = this._engine) === null || _a === void 0 ? void 0 : _a.createExternalTexture(element)) !== null && _b !== void 0 ? _b : null : null;
    this.anisotropicFilteringLevel = 1;
    this._createInternalTexture();
  }
  _createInternalTexture() {
    let width = 0;
    let height = 0;
    if (this._isVideo) {
      width = this.element.videoWidth;
      height = this.element.videoHeight;
    } else {
      width = this.element.width;
      height = this.element.height;
    }
    const engine = this._getEngine();
    if (engine) {
      this._texture = engine.createDynamicTexture(width, height, this._generateMipMaps, this._samplingMode);
      this._texture.format = this._format;
    }
    this.update();
  }
  getTextureMatrix() {
    return this._textureMatrix;
  }
  update(invertY = null) {
    const engine = this._getEngine();
    if (this._texture == null || engine == null) {
      return;
    }
    const wasReady = this.isReady();
    if (this._isVideo) {
      const videoElement = this.element;
      if (videoElement.readyState < videoElement.HAVE_CURRENT_DATA) {
        return;
      }
      engine.updateVideoTexture(this._texture, this._externalTexture ? this._externalTexture : videoElement, invertY === null ? true : invertY);
    } else {
      const canvasElement = this.element;
      engine.updateDynamicTexture(this._texture, canvasElement, invertY === null ? true : invertY, false, this._format);
    }
    if (!wasReady && this.isReady()) {
      this.onLoadObservable.notifyObservers(this);
    }
  }
  dispose() {
    this.onLoadObservable.clear();
    super.dispose();
  }
};
HtmlElementTexture._DefaultOptions = {
  generateMipMaps: false,
  samplingMode: 2,
  format: 5,
  engine: null,
  scene: null
};

// node_modules/@babylonjs/core/Misc/tga.js
var _TYPE_INDEXED = 1;
var _TYPE_RGB = 2;
var _TYPE_GREY = 3;
var _TYPE_RLE_INDEXED = 9;
var _TYPE_RLE_RGB = 10;
var _TYPE_RLE_GREY = 11;
var _ORIGIN_MASK = 48;
var _ORIGIN_SHIFT = 4;
var _ORIGIN_BL = 0;
var _ORIGIN_BR = 1;
var _ORIGIN_UL = 2;
var _ORIGIN_UR = 3;
function GetTGAHeader(data) {
  let offset = 0;
  const header = {
    id_length: data[offset++],
    colormap_type: data[offset++],
    image_type: data[offset++],
    colormap_index: data[offset++] | data[offset++] << 8,
    colormap_length: data[offset++] | data[offset++] << 8,
    colormap_size: data[offset++],
    origin: [data[offset++] | data[offset++] << 8, data[offset++] | data[offset++] << 8],
    width: data[offset++] | data[offset++] << 8,
    height: data[offset++] | data[offset++] << 8,
    pixel_size: data[offset++],
    flags: data[offset++]
  };
  return header;
}
function UploadContent(texture, data) {
  if (data.length < 19) {
    Logger.Error("Unable to load TGA file - Not enough data to contain header");
    return;
  }
  let offset = 18;
  const header = GetTGAHeader(data);
  if (header.id_length + offset > data.length) {
    Logger.Error("Unable to load TGA file - Not enough data");
    return;
  }
  offset += header.id_length;
  let use_rle = false;
  let use_pal = false;
  let use_grey = false;
  switch (header.image_type) {
    case _TYPE_RLE_INDEXED:
      use_rle = true;
    case _TYPE_INDEXED:
      use_pal = true;
      break;
    case _TYPE_RLE_RGB:
      use_rle = true;
    case _TYPE_RGB:
      break;
    case _TYPE_RLE_GREY:
      use_rle = true;
    case _TYPE_GREY:
      use_grey = true;
      break;
  }
  let pixel_data;
  const pixel_size = header.pixel_size >> 3;
  const pixel_total = header.width * header.height * pixel_size;
  let palettes;
  if (use_pal) {
    palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));
  }
  if (use_rle) {
    pixel_data = new Uint8Array(pixel_total);
    let c, count, i;
    let localOffset = 0;
    const pixels = new Uint8Array(pixel_size);
    while (offset < pixel_total && localOffset < pixel_total) {
      c = data[offset++];
      count = (c & 127) + 1;
      if (c & 128) {
        for (i = 0; i < pixel_size; ++i) {
          pixels[i] = data[offset++];
        }
        for (i = 0; i < count; ++i) {
          pixel_data.set(pixels, localOffset + i * pixel_size);
        }
        localOffset += pixel_size * count;
      } else {
        count *= pixel_size;
        for (i = 0; i < count; ++i) {
          pixel_data[localOffset + i] = data[offset++];
        }
        localOffset += count;
      }
    }
  } else {
    pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);
  }
  let x_start, y_start, x_step, y_step, y_end, x_end;
  switch ((header.flags & _ORIGIN_MASK) >> _ORIGIN_SHIFT) {
    default:
    case _ORIGIN_UL:
      x_start = 0;
      x_step = 1;
      x_end = header.width;
      y_start = 0;
      y_step = 1;
      y_end = header.height;
      break;
    case _ORIGIN_BL:
      x_start = 0;
      x_step = 1;
      x_end = header.width;
      y_start = header.height - 1;
      y_step = -1;
      y_end = -1;
      break;
    case _ORIGIN_UR:
      x_start = header.width - 1;
      x_step = -1;
      x_end = -1;
      y_start = 0;
      y_step = 1;
      y_end = header.height;
      break;
    case _ORIGIN_BR:
      x_start = header.width - 1;
      x_step = -1;
      x_end = -1;
      y_start = header.height - 1;
      y_step = -1;
      y_end = -1;
      break;
  }
  const func = "_getImageData" + (use_grey ? "Grey" : "") + header.pixel_size + "bits";
  const imageData = TGATools[func](header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end);
  const engine = texture.getEngine();
  engine._uploadDataToTextureDirectly(texture, imageData);
}
function _getImageData8bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
  const image = pixel_data, colormap = palettes;
  const width = header.width, height = header.height;
  let color, i = 0, x, y;
  const imageData = new Uint8Array(width * height * 4);
  for (y = y_start; y !== y_end; y += y_step) {
    for (x = x_start; x !== x_end; x += x_step, i++) {
      color = image[i];
      imageData[(x + width * y) * 4 + 3] = 255;
      imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];
      imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];
      imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];
    }
  }
  return imageData;
}
function _getImageData16bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
  const image = pixel_data;
  const width = header.width, height = header.height;
  let color, i = 0, x, y;
  const imageData = new Uint8Array(width * height * 4);
  for (y = y_start; y !== y_end; y += y_step) {
    for (x = x_start; x !== x_end; x += x_step, i += 2) {
      color = image[i + 0] + (image[i + 1] << 8);
      const r = ((color & 31744) >> 10) * 255 / 31 | 0;
      const g = ((color & 992) >> 5) * 255 / 31 | 0;
      const b = (color & 31) * 255 / 31 | 0;
      imageData[(x + width * y) * 4 + 0] = r;
      imageData[(x + width * y) * 4 + 1] = g;
      imageData[(x + width * y) * 4 + 2] = b;
      imageData[(x + width * y) * 4 + 3] = color & 32768 ? 0 : 255;
    }
  }
  return imageData;
}
function _getImageData24bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
  const image = pixel_data;
  const width = header.width, height = header.height;
  let i = 0, x, y;
  const imageData = new Uint8Array(width * height * 4);
  for (y = y_start; y !== y_end; y += y_step) {
    for (x = x_start; x !== x_end; x += x_step, i += 3) {
      imageData[(x + width * y) * 4 + 3] = 255;
      imageData[(x + width * y) * 4 + 2] = image[i + 0];
      imageData[(x + width * y) * 4 + 1] = image[i + 1];
      imageData[(x + width * y) * 4 + 0] = image[i + 2];
    }
  }
  return imageData;
}
function _getImageData32bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
  const image = pixel_data;
  const width = header.width, height = header.height;
  let i = 0, x, y;
  const imageData = new Uint8Array(width * height * 4);
  for (y = y_start; y !== y_end; y += y_step) {
    for (x = x_start; x !== x_end; x += x_step, i += 4) {
      imageData[(x + width * y) * 4 + 2] = image[i + 0];
      imageData[(x + width * y) * 4 + 1] = image[i + 1];
      imageData[(x + width * y) * 4 + 0] = image[i + 2];
      imageData[(x + width * y) * 4 + 3] = image[i + 3];
    }
  }
  return imageData;
}
function _getImageDataGrey8bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
  const image = pixel_data;
  const width = header.width, height = header.height;
  let color, i = 0, x, y;
  const imageData = new Uint8Array(width * height * 4);
  for (y = y_start; y !== y_end; y += y_step) {
    for (x = x_start; x !== x_end; x += x_step, i++) {
      color = image[i];
      imageData[(x + width * y) * 4 + 0] = color;
      imageData[(x + width * y) * 4 + 1] = color;
      imageData[(x + width * y) * 4 + 2] = color;
      imageData[(x + width * y) * 4 + 3] = 255;
    }
  }
  return imageData;
}
function _getImageDataGrey16bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
  const image = pixel_data;
  const width = header.width, height = header.height;
  let i = 0, x, y;
  const imageData = new Uint8Array(width * height * 4);
  for (y = y_start; y !== y_end; y += y_step) {
    for (x = x_start; x !== x_end; x += x_step, i += 2) {
      imageData[(x + width * y) * 4 + 0] = image[i + 0];
      imageData[(x + width * y) * 4 + 1] = image[i + 0];
      imageData[(x + width * y) * 4 + 2] = image[i + 0];
      imageData[(x + width * y) * 4 + 3] = image[i + 1];
    }
  }
  return imageData;
}
var TGATools = {
  GetTGAHeader,
  UploadContent,
  _getImageData8bits,
  _getImageData16bits,
  _getImageData24bits,
  _getImageData32bits,
  _getImageDataGrey8bits,
  _getImageDataGrey16bits
};

// node_modules/@babylonjs/core/Materials/Textures/Loaders/tgaTextureLoader.js
var _TGATextureLoader = class {
  constructor() {
    this.supportCascades = false;
  }
  canLoad(extension) {
    return extension.endsWith(".tga");
  }
  loadCubeData() {
    throw ".env not supported in Cube.";
  }
  loadData(data, texture, callback) {
    const bytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    const header = GetTGAHeader(bytes);
    callback(header.width, header.height, texture.generateMipMaps, false, () => {
      UploadContent(texture, bytes);
    });
  }
};
Engine._TextureLoaders.push(new _TGATextureLoader());

// node_modules/@babylonjs/core/Materials/Textures/Loaders/hdrTextureLoader.js
var _HDRTextureLoader = class {
  constructor() {
    this.supportCascades = false;
  }
  canLoad(extension) {
    return extension.endsWith(".hdr");
  }
  loadCubeData() {
    throw ".env not supported in Cube.";
  }
  loadData(data, texture, callback) {
    const uint8array = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    const hdrInfo = HDRTools.RGBE_ReadHeader(uint8array);
    const pixelsDataRGB32 = HDRTools.RGBE_ReadPixels(uint8array, hdrInfo);
    const pixels = hdrInfo.width * hdrInfo.height;
    const pixelsDataRGBA32 = new Float32Array(pixels * 4);
    for (let i = 0; i < pixels; i += 1) {
      pixelsDataRGBA32[i * 4] = pixelsDataRGB32[i * 3];
      pixelsDataRGBA32[i * 4 + 1] = pixelsDataRGB32[i * 3 + 1];
      pixelsDataRGBA32[i * 4 + 2] = pixelsDataRGB32[i * 3 + 2];
      pixelsDataRGBA32[i * 4 + 3] = 1;
    }
    callback(hdrInfo.width, hdrInfo.height, texture.generateMipMaps, false, () => {
      const engine = texture.getEngine();
      texture.type = 1;
      texture.format = 5;
      texture._gammaSpace = false;
      engine._uploadDataToTextureDirectly(texture, pixelsDataRGBA32);
    });
  }
};
Engine._TextureLoaders.push(new _HDRTextureLoader());

// node_modules/@babylonjs/core/Misc/basis.js
var BasisTranscodeConfiguration = class {
};
var BASIS_FORMATS;
(function(BASIS_FORMATS2) {
  BASIS_FORMATS2[BASIS_FORMATS2["cTFETC1"] = 0] = "cTFETC1";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFETC2"] = 1] = "cTFETC2";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBC1"] = 2] = "cTFBC1";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBC3"] = 3] = "cTFBC3";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBC4"] = 4] = "cTFBC4";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBC5"] = 5] = "cTFBC5";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBC7"] = 6] = "cTFBC7";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFPVRTC1_4_RGB"] = 8] = "cTFPVRTC1_4_RGB";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFPVRTC1_4_RGBA"] = 9] = "cTFPVRTC1_4_RGBA";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFASTC_4x4"] = 10] = "cTFASTC_4x4";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFATC_RGB"] = 11] = "cTFATC_RGB";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFATC_RGBA_INTERPOLATED_ALPHA"] = 12] = "cTFATC_RGBA_INTERPOLATED_ALPHA";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFRGBA32"] = 13] = "cTFRGBA32";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFRGB565"] = 14] = "cTFRGB565";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBGR565"] = 15] = "cTFBGR565";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFRGBA4444"] = 16] = "cTFRGBA4444";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFFXT1_RGB"] = 17] = "cTFFXT1_RGB";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFPVRTC2_4_RGB"] = 18] = "cTFPVRTC2_4_RGB";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFPVRTC2_4_RGBA"] = 19] = "cTFPVRTC2_4_RGBA";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFETC2_EAC_R11"] = 20] = "cTFETC2_EAC_R11";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFETC2_EAC_RG11"] = 21] = "cTFETC2_EAC_RG11";
})(BASIS_FORMATS || (BASIS_FORMATS = {}));
var BasisToolsOptions = {
  JSModuleURL: "https://cdn.babylonjs.com/basisTranscoder/1/basis_transcoder.js",
  WasmModuleURL: "https://cdn.babylonjs.com/basisTranscoder/1/basis_transcoder.wasm"
};
var GetInternalFormatFromBasisFormat = (basisFormat, engine) => {
  let format;
  switch (basisFormat) {
    case BASIS_FORMATS.cTFETC1:
      format = 36196;
      break;
    case BASIS_FORMATS.cTFBC1:
      format = 33776;
      break;
    case BASIS_FORMATS.cTFBC4:
      format = 33779;
      break;
    case BASIS_FORMATS.cTFASTC_4x4:
      format = 37808;
      break;
    case BASIS_FORMATS.cTFETC2:
      format = 37496;
      break;
    case BASIS_FORMATS.cTFBC7:
      format = 36492;
      break;
  }
  if (format === void 0) {
    throw "The chosen Basis transcoder format is not currently supported";
  }
  return format;
};
var _WorkerPromise = null;
var _Worker = null;
var _actionId = 0;
var _IgnoreSupportedFormats = false;
var _CreateWorkerAsync = () => {
  if (!_WorkerPromise) {
    _WorkerPromise = new Promise((res, reject) => {
      if (_Worker) {
        res(_Worker);
      } else {
        Tools.LoadFileAsync(BasisToolsOptions.WasmModuleURL).then((wasmBinary) => {
          if (typeof URL !== "function") {
            return reject("Basis transcoder requires an environment with a URL constructor");
          }
          const workerBlobUrl = URL.createObjectURL(new Blob([`(${workerFunc2})()`], { type: "application/javascript" }));
          _Worker = new Worker(workerBlobUrl);
          const initHandler = (msg) => {
            if (msg.data.action === "init") {
              _Worker.removeEventListener("message", initHandler);
              res(_Worker);
            } else if (msg.data.action === "error") {
              reject(msg.data.error || "error initializing worker");
            }
          };
          _Worker.addEventListener("message", initHandler);
          _Worker.postMessage({ action: "init", url: BasisToolsOptions.JSModuleURL, wasmBinary });
        }).catch(reject);
      }
    });
  }
  return _WorkerPromise;
};
var TranscodeAsync = (data, config) => {
  const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
  return new Promise((res, rej) => {
    _CreateWorkerAsync().then(() => {
      const actionId = _actionId++;
      const messageHandler = (msg) => {
        if (msg.data.action === "transcode" && msg.data.id === actionId) {
          _Worker.removeEventListener("message", messageHandler);
          if (!msg.data.success) {
            rej("Transcode is not supported on this device");
          } else {
            res(msg.data);
          }
        }
      };
      _Worker.addEventListener("message", messageHandler);
      const dataViewCopy = new Uint8Array(dataView.byteLength);
      dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));
      _Worker.postMessage({ action: "transcode", id: actionId, imageData: dataViewCopy, config, ignoreSupportedFormats: _IgnoreSupportedFormats }, [
        dataViewCopy.buffer
      ]);
    }, (error) => {
      rej(error);
    });
  });
};
var BindTexture = (texture, engine) => {
  var _a, _b;
  let target = (_a = engine._gl) === null || _a === void 0 ? void 0 : _a.TEXTURE_2D;
  if (texture.isCube) {
    target = (_b = engine._gl) === null || _b === void 0 ? void 0 : _b.TEXTURE_CUBE_MAP;
  }
  engine._bindTextureDirectly(target, texture, true);
};
var LoadTextureFromTranscodeResult = (texture, transcodeResult) => {
  const engine = texture.getEngine();
  for (let i = 0; i < transcodeResult.fileInfo.images.length; i++) {
    const rootImage = transcodeResult.fileInfo.images[i].levels[0];
    texture._invertVScale = texture.invertY;
    if (transcodeResult.format === -1 || transcodeResult.format === BASIS_FORMATS.cTFRGB565) {
      texture.type = 10;
      texture.format = 4;
      if (engine._features.basisNeedsPOT && (Scalar.Log2(rootImage.width) % 1 !== 0 || Scalar.Log2(rootImage.height) % 1 !== 0)) {
        const source = new InternalTexture(engine, InternalTextureSource.Temp);
        texture._invertVScale = texture.invertY;
        source.type = 10;
        source.format = 4;
        source.width = rootImage.width + 3 & ~3;
        source.height = rootImage.height + 3 & ~3;
        BindTexture(source, engine);
        engine._uploadDataToTextureDirectly(source, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, 4, true);
        engine._rescaleTexture(source, texture, engine.scenes[0], engine._getInternalFormat(4), () => {
          engine._releaseTexture(source);
          BindTexture(texture, engine);
        });
      } else {
        texture._invertVScale = !texture.invertY;
        texture.width = rootImage.width + 3 & ~3;
        texture.height = rootImage.height + 3 & ~3;
        texture.samplingMode = 2;
        BindTexture(texture, engine);
        engine._uploadDataToTextureDirectly(texture, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, 4, true);
      }
    } else {
      texture.width = rootImage.width;
      texture.height = rootImage.height;
      texture.generateMipMaps = transcodeResult.fileInfo.images[i].levels.length > 1;
      const format = BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format, engine);
      texture.format = format;
      BindTexture(texture, engine);
      transcodeResult.fileInfo.images[i].levels.forEach((level, index) => {
        engine._uploadCompressedDataToTextureDirectly(texture, format, level.width, level.height, level.transcodedPixels, i, index);
      });
      if (engine._features.basisNeedsPOT && (Scalar.Log2(texture.width) % 1 !== 0 || Scalar.Log2(texture.height) % 1 !== 0)) {
        Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.");
        texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;
        texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;
      }
    }
  }
};
var BasisTools = {
  JSModuleURL: BasisToolsOptions.JSModuleURL,
  WasmModuleURL: BasisToolsOptions.WasmModuleURL,
  GetInternalFormatFromBasisFormat,
  TranscodeAsync,
  LoadTextureFromTranscodeResult
};
function workerFunc2() {
  const _BASIS_FORMAT = {
    cTFETC1: 0,
    cTFETC2: 1,
    cTFBC1: 2,
    cTFBC3: 3,
    cTFBC4: 4,
    cTFBC5: 5,
    cTFBC7: 6,
    cTFPVRTC1_4_RGB: 8,
    cTFPVRTC1_4_RGBA: 9,
    cTFASTC_4x4: 10,
    cTFATC_RGB: 11,
    cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
    cTFRGBA32: 13,
    cTFRGB565: 14,
    cTFBGR565: 15,
    cTFRGBA4444: 16,
    cTFFXT1_RGB: 17,
    cTFPVRTC2_4_RGB: 18,
    cTFPVRTC2_4_RGBA: 19,
    cTFETC2_EAC_R11: 20,
    cTFETC2_EAC_RG11: 21
  };
  let transcoderModulePromise = null;
  onmessage = (event) => {
    if (event.data.action === "init") {
      if (!transcoderModulePromise) {
        try {
          importScripts(event.data.url);
        } catch (e) {
          postMessage({ action: "error", error: e });
        }
        transcoderModulePromise = BASIS({
          wasmBinary: event.data.wasmBinary
        });
      }
      if (transcoderModulePromise !== null) {
        transcoderModulePromise.then((m) => {
          BASIS = m;
          m.initializeBasis();
          postMessage({ action: "init" });
        });
      }
    } else if (event.data.action === "transcode") {
      const config = event.data.config;
      const imgData = event.data.imageData;
      const loadedFile = new BASIS.BasisFile(imgData);
      const fileInfo = GetFileInfo(loadedFile);
      let format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);
      let needsConversion = false;
      if (format === null) {
        needsConversion = true;
        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;
      }
      let success = true;
      if (!loadedFile.startTranscoding()) {
        success = false;
      }
      const buffers = [];
      for (let imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {
        if (!success) {
          break;
        }
        const image = fileInfo.images[imageIndex];
        if (config.loadSingleImage === void 0 || config.loadSingleImage === imageIndex) {
          let mipCount = image.levels.length;
          if (config.loadMipmapLevels === false) {
            mipCount = 1;
          }
          for (let levelIndex = 0; levelIndex < mipCount; levelIndex++) {
            const levelInfo = image.levels[levelIndex];
            const pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format, needsConversion);
            if (!pixels) {
              success = false;
              break;
            }
            levelInfo.transcodedPixels = pixels;
            buffers.push(levelInfo.transcodedPixels.buffer);
          }
        }
      }
      loadedFile.close();
      loadedFile.delete();
      if (needsConversion) {
        format = -1;
      }
      if (!success) {
        postMessage({ action: "transcode", success, id: event.data.id });
      } else {
        postMessage({ action: "transcode", success, id: event.data.id, fileInfo, format }, buffers);
      }
    }
  };
  function GetSupportedTranscodeFormat(config, fileInfo) {
    let format = null;
    if (config.supportedCompressionFormats) {
      if (config.supportedCompressionFormats.astc) {
        format = _BASIS_FORMAT.cTFASTC_4x4;
      } else if (config.supportedCompressionFormats.bc7) {
        format = _BASIS_FORMAT.cTFBC7;
      } else if (config.supportedCompressionFormats.s3tc) {
        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;
      } else if (config.supportedCompressionFormats.pvrtc) {
        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFPVRTC1_4_RGBA : _BASIS_FORMAT.cTFPVRTC1_4_RGB;
      } else if (config.supportedCompressionFormats.etc2) {
        format = _BASIS_FORMAT.cTFETC2;
      } else if (config.supportedCompressionFormats.etc1) {
        format = _BASIS_FORMAT.cTFETC1;
      } else {
        format = _BASIS_FORMAT.cTFRGB565;
      }
    }
    return format;
  }
  function GetFileInfo(basisFile) {
    const hasAlpha = basisFile.getHasAlpha();
    const imageCount = basisFile.getNumImages();
    const images = [];
    for (let i = 0; i < imageCount; i++) {
      const imageInfo = {
        levels: []
      };
      const levelCount = basisFile.getNumLevels(i);
      for (let level = 0; level < levelCount; level++) {
        const levelInfo = {
          width: basisFile.getImageWidth(i, level),
          height: basisFile.getImageHeight(i, level)
        };
        imageInfo.levels.push(levelInfo);
      }
      images.push(imageInfo);
    }
    const info = { hasAlpha, images };
    return info;
  }
  function TranscodeLevel(loadedFile, imageIndex, levelIndex, format, convertToRgb565) {
    const dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);
    let dst = new Uint8Array(dstSize);
    if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {
      return null;
    }
    if (convertToRgb565) {
      const alignedWidth = loadedFile.getImageWidth(imageIndex, levelIndex) + 3 & ~3;
      const alignedHeight = loadedFile.getImageHeight(imageIndex, levelIndex) + 3 & ~3;
      dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);
    }
    return dst;
  }
  function ConvertDxtToRgb565(src, srcByteOffset, width, height) {
    const c = new Uint16Array(4);
    const dst = new Uint16Array(width * height);
    const blockWidth = width / 4;
    const blockHeight = height / 4;
    for (let blockY = 0; blockY < blockHeight; blockY++) {
      for (let blockX = 0; blockX < blockWidth; blockX++) {
        const i = srcByteOffset + 8 * (blockY * blockWidth + blockX);
        c[0] = src[i] | src[i + 1] << 8;
        c[1] = src[i + 2] | src[i + 3] << 8;
        c[2] = (2 * (c[0] & 31) + 1 * (c[1] & 31)) / 3 | (2 * (c[0] & 2016) + 1 * (c[1] & 2016)) / 3 & 2016 | (2 * (c[0] & 63488) + 1 * (c[1] & 63488)) / 3 & 63488;
        c[3] = (2 * (c[1] & 31) + 1 * (c[0] & 31)) / 3 | (2 * (c[1] & 2016) + 1 * (c[0] & 2016)) / 3 & 2016 | (2 * (c[1] & 63488) + 1 * (c[0] & 63488)) / 3 & 63488;
        for (let row = 0; row < 4; row++) {
          const m = src[i + 4 + row];
          let dstI = (blockY * 4 + row) * width + blockX * 4;
          dst[dstI++] = c[m & 3];
          dst[dstI++] = c[m >> 2 & 3];
          dst[dstI++] = c[m >> 4 & 3];
          dst[dstI++] = c[m >> 6 & 3];
        }
      }
    }
    return dst;
  }
}
Object.defineProperty(BasisTools, "JSModuleURL", {
  get: function() {
    return BasisToolsOptions.JSModuleURL;
  },
  set: function(value) {
    BasisToolsOptions.JSModuleURL = value;
  }
});
Object.defineProperty(BasisTools, "WasmModuleURL", {
  get: function() {
    return BasisToolsOptions.WasmModuleURL;
  },
  set: function(value) {
    BasisToolsOptions.WasmModuleURL = value;
  }
});

// node_modules/@babylonjs/core/Materials/Textures/Loaders/basisTextureLoader.js
var _BasisTextureLoader = class {
  constructor() {
    this.supportCascades = false;
  }
  canLoad(extension) {
    return extension.endsWith(".basis");
  }
  loadCubeData(data, texture, createPolynomials, onLoad, onError) {
    if (Array.isArray(data)) {
      return;
    }
    const caps = texture.getEngine().getCaps();
    const transcodeConfig = {
      supportedCompressionFormats: {
        etc1: caps.etc1 ? true : false,
        s3tc: caps.s3tc ? true : false,
        pvrtc: caps.pvrtc ? true : false,
        etc2: caps.etc2 ? true : false,
        astc: caps.astc ? true : false,
        bc7: caps.bptc ? true : false
      }
    };
    TranscodeAsync(data, transcodeConfig).then((result) => {
      const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;
      LoadTextureFromTranscodeResult(texture, result);
      texture.getEngine()._setCubeMapTextureParams(texture, hasMipmap);
      texture.isReady = true;
      texture.onLoadedObservable.notifyObservers(texture);
      texture.onLoadedObservable.clear();
      if (onLoad) {
        onLoad();
      }
    }).catch((err) => {
      const errorMessage = "Failed to transcode Basis file, transcoding may not be supported on this device";
      Tools.Warn(errorMessage);
      texture.isReady = true;
      if (onError) {
        onError(err);
      }
    });
  }
  loadData(data, texture, callback) {
    const caps = texture.getEngine().getCaps();
    const transcodeConfig = {
      supportedCompressionFormats: {
        etc1: caps.etc1 ? true : false,
        s3tc: caps.s3tc ? true : false,
        pvrtc: caps.pvrtc ? true : false,
        etc2: caps.etc2 ? true : false,
        astc: caps.astc ? true : false,
        bc7: caps.bptc ? true : false
      }
    };
    TranscodeAsync(data, transcodeConfig).then((result) => {
      const rootImage = result.fileInfo.images[0].levels[0];
      const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;
      callback(rootImage.width, rootImage.height, hasMipmap, result.format !== -1, () => {
        LoadTextureFromTranscodeResult(texture, result);
      });
    }).catch((err) => {
      Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device");
      Tools.Warn(`Failed to transcode Basis file: ${err}`);
      callback(0, 0, false, false, () => {
      }, true);
    });
  }
};
Engine._TextureLoaders.push(new _BasisTextureLoader());

// node_modules/@babylonjs/core/Materials/Textures/multiRenderTarget.js
var MultiRenderTarget = class extends RenderTargetTexture {
  constructor(name137, size, count, scene, options, textureNames) {
    const generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;
    const generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;
    const depthTextureFormat = options && options.depthTextureFormat ? options.depthTextureFormat : 15;
    const doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === void 0 ? true : options.doNotChangeAspectRatio;
    const drawOnlyOnFirstAttachmentByDefault = options && options.drawOnlyOnFirstAttachmentByDefault ? options.drawOnlyOnFirstAttachmentByDefault : false;
    super(name137, size, scene, generateMipMaps, doNotChangeAspectRatio, void 0, void 0, void 0, void 0, void 0, void 0, void 0, true);
    if (!this.isSupported) {
      this.dispose();
      return;
    }
    const types = [];
    const samplingModes = [];
    const useSRGBBuffers = [];
    this._initTypes(count, types, samplingModes, useSRGBBuffers, options);
    const generateDepthBuffer = !options || options.generateDepthBuffer === void 0 ? true : options.generateDepthBuffer;
    const generateStencilBuffer = !options || options.generateStencilBuffer === void 0 ? false : options.generateStencilBuffer;
    this._size = size;
    this._multiRenderTargetOptions = {
      samplingModes,
      generateMipMaps,
      generateDepthBuffer,
      generateStencilBuffer,
      generateDepthTexture,
      depthTextureFormat,
      types,
      textureCount: count,
      useSRGBBuffers
    };
    this._count = count;
    this._drawOnlyOnFirstAttachmentByDefault = drawOnlyOnFirstAttachmentByDefault;
    if (count > 0) {
      this._createInternalTextures();
      this._createTextures(textureNames);
    }
  }
  get isSupported() {
    var _a, _b;
    return (_b = (_a = this._engine) === null || _a === void 0 ? void 0 : _a.getCaps().drawBuffersExtension) !== null && _b !== void 0 ? _b : false;
  }
  get textures() {
    return this._textures;
  }
  get count() {
    return this._count;
  }
  get depthTexture() {
    return this._textures[this._textures.length - 1];
  }
  set wrapU(wrap) {
    if (this._textures) {
      for (let i = 0; i < this._textures.length; i++) {
        this._textures[i].wrapU = wrap;
      }
    }
  }
  set wrapV(wrap) {
    if (this._textures) {
      for (let i = 0; i < this._textures.length; i++) {
        this._textures[i].wrapV = wrap;
      }
    }
  }
  _initTypes(count, types, samplingModes, useSRGBBuffers, options) {
    for (let i = 0; i < count; i++) {
      if (options && options.types && options.types[i] !== void 0) {
        types.push(options.types[i]);
      } else {
        types.push(options && options.defaultType ? options.defaultType : 0);
      }
      if (options && options.samplingModes && options.samplingModes[i] !== void 0) {
        samplingModes.push(options.samplingModes[i]);
      } else {
        samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);
      }
      if (options && options.useSRGBBuffers && options.useSRGBBuffers[i] !== void 0) {
        useSRGBBuffers.push(options.useSRGBBuffers[i]);
      } else {
        useSRGBBuffers.push(false);
      }
    }
  }
  _rebuild(forceFullRebuild = false, textureNames) {
    if (this._count < 1) {
      return;
    }
    this.releaseInternalTextures();
    this._createInternalTextures();
    if (forceFullRebuild) {
      this._releaseTextures();
      this._createTextures(textureNames);
    }
    const internalTextures = this._renderTarget.textures;
    for (let i = 0; i < internalTextures.length; i++) {
      const texture = this._textures[i];
      texture._texture = internalTextures[i];
    }
    if (this.samples !== 1) {
      this._renderTarget.setSamples(this.samples, !this._drawOnlyOnFirstAttachmentByDefault, true);
    }
  }
  _createInternalTextures() {
    this._renderTarget = this._getEngine().createMultipleRenderTarget(this._size, this._multiRenderTargetOptions, !this._drawOnlyOnFirstAttachmentByDefault);
    this._texture = this._renderTarget.texture;
  }
  _releaseTextures() {
    if (this._textures) {
      for (let i = 0; i < this._textures.length; i++) {
        this._textures[i]._texture = null;
        this._textures[i].dispose();
      }
    }
  }
  _createTextures(textureNames) {
    const internalTextures = this._renderTarget.textures;
    this._textures = [];
    for (let i = 0; i < internalTextures.length; i++) {
      const texture = new Texture(null, this.getScene());
      if (textureNames === null || textureNames === void 0 ? void 0 : textureNames[i]) {
        texture.name = textureNames[i];
      }
      texture._texture = internalTextures[i];
      this._textures.push(texture);
    }
  }
  setInternalTexture(texture, index, disposePrevious = true) {
    if (!this.renderTarget) {
      return;
    }
    if (index === 0) {
      this._texture = texture;
    }
    this.renderTarget.setTexture(texture, index, disposePrevious);
    if (!this.textures[index]) {
      this.textures[index] = new Texture(null, this.getScene());
    }
    this.textures[index]._texture = texture;
    this._count = this.renderTarget.textures ? this.renderTarget.textures.length : 0;
    if (this._multiRenderTargetOptions.types) {
      this._multiRenderTargetOptions.types[index] = texture.type;
    }
    if (this._multiRenderTargetOptions.samplingModes) {
      this._multiRenderTargetOptions.samplingModes[index] = texture.samplingMode;
    }
    if (this._multiRenderTargetOptions.useSRGBBuffers) {
      this._multiRenderTargetOptions.useSRGBBuffers[index] = texture._useSRGBBuffer;
    }
  }
  get samples() {
    return this._samples;
  }
  set samples(value) {
    if (this._renderTarget) {
      this._samples = this._renderTarget.setSamples(value);
    } else {
      this._samples = value;
    }
  }
  resize(size) {
    this._size = size;
    this._rebuild();
  }
  updateCount(count, options, textureNames) {
    this._multiRenderTargetOptions.textureCount = count;
    this._count = count;
    const types = [];
    const samplingModes = [];
    const useSRGBBuffers = [];
    this._initTypes(count, types, samplingModes, useSRGBBuffers, options);
    this._multiRenderTargetOptions.types = types;
    this._multiRenderTargetOptions.samplingModes = samplingModes;
    this._multiRenderTargetOptions.useSRGBBuffers = useSRGBBuffers;
    this._rebuild(true, textureNames);
  }
  _unbindFrameBuffer(engine, faceIndex) {
    if (this._renderTarget) {
      engine.unBindMultiColorAttachmentFramebuffer(this._renderTarget, this.isCube, () => {
        this.onAfterRenderObservable.notifyObservers(faceIndex);
      });
    }
  }
  dispose(doNotDisposeInternalTextures = false) {
    this._releaseTextures();
    if (!doNotDisposeInternalTextures) {
      this.releaseInternalTextures();
    } else {
      this._texture = null;
    }
    super.dispose();
  }
  releaseInternalTextures() {
    var _a, _b;
    const internalTextures = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.textures;
    if (!internalTextures) {
      return;
    }
    for (let i = internalTextures.length - 1; i >= 0; i--) {
      this._textures[i]._texture = null;
    }
    (_b = this._renderTarget) === null || _b === void 0 ? void 0 : _b.dispose();
    this._renderTarget = null;
  }
};

// node_modules/@babylonjs/core/Materials/Textures/Packer/frame.js
var TexturePackerFrame = class {
  constructor(id, scale, offset) {
    this.id = id;
    this.scale = scale;
    this.offset = offset;
  }
};

// node_modules/@babylonjs/core/Materials/Textures/Packer/packer.js
var TexturePacker = class {
  constructor(name137, meshes, options, scene) {
    var _b, _c, _d, _e, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    this.name = name137;
    this.meshes = meshes;
    this.scene = scene;
    this.options = options;
    this.options.map = (_b = this.options.map) !== null && _b !== void 0 ? _b : [
      "ambientTexture",
      "bumpTexture",
      "diffuseTexture",
      "emissiveTexture",
      "lightmapTexture",
      "opacityTexture",
      "reflectionTexture",
      "refractionTexture",
      "specularTexture"
    ];
    this.options.uvsIn = (_c = this.options.uvsIn) !== null && _c !== void 0 ? _c : VertexBuffer.UVKind;
    this.options.uvsOut = (_d = this.options.uvsOut) !== null && _d !== void 0 ? _d : VertexBuffer.UVKind;
    this.options.layout = (_e = this.options.layout) !== null && _e !== void 0 ? _e : TexturePacker.LAYOUT_STRIP;
    if (this.options.layout === TexturePacker.LAYOUT_COLNUM) {
      this.options.colnum = (_g = this.options.colnum) !== null && _g !== void 0 ? _g : 8;
    }
    this.options.updateInputMeshes = (_h = this.options.updateInputMeshes) !== null && _h !== void 0 ? _h : true;
    this.options.disposeSources = (_j = this.options.disposeSources) !== null && _j !== void 0 ? _j : true;
    this._expecting = 0;
    this.options.fillBlanks = (_k = this.options.fillBlanks) !== null && _k !== void 0 ? _k : true;
    if (this.options.fillBlanks === true) {
      this.options.customFillColor = (_l = this.options.customFillColor) !== null && _l !== void 0 ? _l : "black";
    }
    this.options.frameSize = (_m = this.options.frameSize) !== null && _m !== void 0 ? _m : 256;
    this.options.paddingRatio = (_o = this.options.paddingRatio) !== null && _o !== void 0 ? _o : 0.0115;
    this._paddingValue = Math.ceil(this.options.frameSize * this.options.paddingRatio);
    if (this._paddingValue % 2 !== 0) {
      this._paddingValue++;
    }
    this.options.paddingMode = (_p = this.options.paddingMode) !== null && _p !== void 0 ? _p : TexturePacker.SUBUV_WRAP;
    if (this.options.paddingMode === TexturePacker.SUBUV_COLOR) {
      this.options.paddingColor = (_q = this.options.paddingColor) !== null && _q !== void 0 ? _q : new Color4(0, 0, 0, 1);
    }
    this.sets = {};
    this.frames = [];
    return this;
  }
  _createFrames(resolve) {
    const dtSize = this._calculateSize();
    const dtUnits = new Vector2(1, 1).divide(dtSize);
    let doneCount = 0;
    const expecting = this._expecting;
    const meshLength = this.meshes.length;
    const sKeys = Object.keys(this.sets);
    for (let i = 0; i < sKeys.length; i++) {
      const setName = sKeys[i];
      const dt = new DynamicTexture(
        this.name + ".TexturePack." + setName + "Set",
        { width: dtSize.x, height: dtSize.y },
        this.scene,
        true,
        Texture.TRILINEAR_SAMPLINGMODE,
        Engine.TEXTUREFORMAT_RGBA
      );
      const dtx = dt.getContext();
      dtx.fillStyle = "rgba(0,0,0,0)";
      dtx.fillRect(0, 0, dtSize.x, dtSize.y);
      dt.update(false);
      this.sets[setName] = dt;
    }
    const baseSize = this.options.frameSize || 256;
    const padding = this._paddingValue;
    const tcs = baseSize + 2 * padding;
    const done = () => {
      this._calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, this.options.updateInputMeshes || false);
    };
    for (let i = 0; i < meshLength; i++) {
      const m = this.meshes[i];
      const mat = m.material;
      for (let j = 0; j < sKeys.length; j++) {
        const tempTexture = new DynamicTexture("temp", tcs, this.scene, true);
        const tcx = tempTexture.getContext();
        const offset = this._getFrameOffset(i);
        const updateDt = () => {
          doneCount++;
          tempTexture.update(false);
          const iDat = tcx.getImageData(0, 0, tcs, tcs);
          const dt = this.sets[setName];
          const dtx = dt.getContext();
          dtx.putImageData(iDat, dtSize.x * offset.x, dtSize.y * offset.y);
          tempTexture.dispose();
          dt.update(false);
          if (doneCount == expecting) {
            done();
            resolve();
            return;
          }
        };
        const setName = sKeys[j] || "_blank";
        if (!mat || mat[setName] === null) {
          tcx.fillStyle = "rgba(0,0,0,0)";
          if (this.options.fillBlanks) {
            tcx.fillStyle = this.options.customFillColor;
          }
          tcx.fillRect(0, 0, tcs, tcs);
          updateDt();
        } else {
          const setTexture = mat[setName];
          const img = new Image();
          if (setTexture instanceof DynamicTexture) {
            img.src = setTexture.getContext().canvas.toDataURL("image/png");
          } else {
            img.src = setTexture.url;
          }
          Tools.SetCorsBehavior(img.src, img);
          img.onload = () => {
            tcx.fillStyle = "rgba(0,0,0,0)";
            tcx.fillRect(0, 0, tcs, tcs);
            tempTexture.update(false);
            tcx.setTransform(1, 0, 0, -1, 0, 0);
            const cellOffsets = [0, 0, 1, 0, 1, 1, 0, 1, -1, 1, -1, 0, -1 - 1, 0, -1, 1, -1];
            switch (this.options.paddingMode) {
              case 0:
                for (let i2 = 0; i2 < 9; i2++) {
                  tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[i2], padding + baseSize * cellOffsets[i2 + 1] - tcs, baseSize, baseSize);
                }
                break;
              case 1:
                for (let i2 = 0; i2 < padding; i2++) {
                  tcx.drawImage(img, 0, 0, img.width, img.height, i2 + baseSize * cellOffsets[0], padding - tcs, baseSize, baseSize);
                  tcx.drawImage(img, 0, 0, img.width, img.height, padding * 2 - i2, padding - tcs, baseSize, baseSize);
                  tcx.drawImage(img, 0, 0, img.width, img.height, padding, i2 - tcs, baseSize, baseSize);
                  tcx.drawImage(img, 0, 0, img.width, img.height, padding, padding * 2 - i2 - tcs, baseSize, baseSize);
                }
                tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);
                break;
              case 2:
                tcx.fillStyle = (this.options.paddingColor || Color3.Black()).toHexString();
                tcx.fillRect(0, 0, tcs, -tcs);
                tcx.clearRect(padding, padding, baseSize, baseSize);
                tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);
                break;
            }
            tcx.setTransform(1, 0, 0, 1, 0, 0);
            updateDt();
          };
        }
      }
    }
  }
  _calculateSize() {
    const meshLength = this.meshes.length || 0;
    const baseSize = this.options.frameSize || 0;
    const padding = this._paddingValue || 0;
    switch (this.options.layout) {
      case 0: {
        return new Vector2(baseSize * meshLength + 2 * padding * meshLength, baseSize + 2 * padding);
      }
      case 1: {
        const sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));
        const size = baseSize * sqrtCount + 2 * padding * sqrtCount;
        return new Vector2(size, size);
      }
      case 2: {
        const cols = this.options.colnum || 1;
        const rowCnt = Math.max(1, Math.ceil(meshLength / cols));
        return new Vector2(baseSize * cols + 2 * padding * cols, baseSize * rowCnt + 2 * padding * rowCnt);
      }
    }
    return Vector2.Zero();
  }
  _calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, update) {
    const meshLength = this.meshes.length;
    for (let i = 0; i < meshLength; i++) {
      const m = this.meshes[i];
      const scale = new Vector2(baseSize / dtSize.x, baseSize / dtSize.y);
      const pOffset = dtUnits.clone().scale(padding);
      const frameOffset = this._getFrameOffset(i);
      const offset = frameOffset.add(pOffset);
      const frame = new TexturePackerFrame(i, scale, offset);
      this.frames.push(frame);
      if (update) {
        this._updateMeshUV(m, i);
        this._updateTextureReferences(m);
      }
    }
  }
  _getFrameOffset(index) {
    const meshLength = this.meshes.length;
    let uvStep, yStep, xStep;
    switch (this.options.layout) {
      case 0: {
        uvStep = 1 / meshLength;
        return new Vector2(index * uvStep, 0);
      }
      case 1: {
        const sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));
        yStep = Math.floor(index / sqrtCount);
        xStep = index - yStep * sqrtCount;
        uvStep = 1 / sqrtCount;
        return new Vector2(xStep * uvStep, yStep * uvStep);
      }
      case 2: {
        const cols = this.options.colnum || 1;
        const rowCnt = Math.max(1, Math.ceil(meshLength / cols));
        xStep = Math.floor(index / rowCnt);
        yStep = index - xStep * rowCnt;
        uvStep = new Vector2(1 / cols, 1 / rowCnt);
        return new Vector2(xStep * uvStep.x, yStep * uvStep.y);
      }
    }
    return Vector2.Zero();
  }
  _updateMeshUV(mesh, frameID) {
    const frame = this.frames[frameID];
    const uvIn = mesh.getVerticesData(this.options.uvsIn || VertexBuffer.UVKind);
    const uvOut = [];
    let toCount = 0;
    if (uvIn.length) {
      toCount = uvIn.length || 0;
    }
    for (let i = 0; i < toCount; i += 2) {
      uvOut.push(uvIn[i] * frame.scale.x + frame.offset.x, uvIn[i + 1] * frame.scale.y + frame.offset.y);
    }
    mesh.setVerticesData(this.options.uvsOut || VertexBuffer.UVKind, uvOut);
  }
  _updateTextureReferences(m, force = false) {
    const mat = m.material;
    const sKeys = Object.keys(this.sets);
    const _dispose = (_t) => {
      if (_t.dispose) {
        _t.dispose();
      }
    };
    for (let i = 0; i < sKeys.length; i++) {
      const setName = sKeys[i];
      if (!force) {
        if (!mat) {
          return;
        }
        if (mat[setName] !== null) {
          _dispose(mat[setName]);
          mat[setName] = this.sets[setName];
        }
      } else {
        if (mat[setName] !== null) {
          _dispose(mat[setName]);
        }
        mat[setName] = this.sets[setName];
      }
    }
  }
  setMeshToFrame(m, frameID, updateMaterial = false) {
    this._updateMeshUV(m, frameID);
    if (updateMaterial) {
      this._updateTextureReferences(m, true);
    }
  }
  processAsync() {
    return new Promise((resolve, reject) => {
      try {
        if (this.meshes.length === 0) {
          resolve();
          return;
        }
        let done = 0;
        const doneCheck = (mat) => {
          done++;
          if (this.options.map) {
            for (let j = 0; j < this.options.map.length; j++) {
              const index = this.options.map[j];
              const t = mat[index];
              if (t !== null) {
                if (!this.sets[this.options.map[j]]) {
                  this.sets[this.options.map[j]] = true;
                }
                this._expecting++;
              }
            }
            if (done === this.meshes.length) {
              this._createFrames(resolve);
            }
          }
        };
        for (let i = 0; i < this.meshes.length; i++) {
          const mesh = this.meshes[i];
          const material = mesh.material;
          if (!material) {
            done++;
            if (done === this.meshes.length) {
              return this._createFrames(resolve);
            }
            continue;
          }
          material.forceCompilationAsync(mesh).then(() => {
            doneCheck(material);
          });
        }
      } catch (e) {
        return reject(e);
      }
    });
  }
  dispose() {
    const sKeys = Object.keys(this.sets);
    for (let i = 0; i < sKeys.length; i++) {
      const channel = sKeys[i];
      this.sets[channel].dispose();
    }
  }
  download(imageType = "png", quality = 1) {
    setTimeout(() => {
      const pack = {
        name: this.name,
        sets: {},
        options: {},
        frames: []
      };
      const sKeys = Object.keys(this.sets);
      const oKeys = Object.keys(this.options);
      try {
        for (let i = 0; i < sKeys.length; i++) {
          const channel = sKeys[i];
          const dt = this.sets[channel];
          pack.sets[channel] = dt.getContext().canvas.toDataURL("image/" + imageType, quality);
        }
        for (let i = 0; i < oKeys.length; i++) {
          const opt = oKeys[i];
          pack.options[opt] = this.options[opt];
        }
        for (let i = 0; i < this.frames.length; i++) {
          const _f = this.frames[i];
          pack.frames.push(_f.scale.x, _f.scale.y, _f.offset.x, _f.offset.y);
        }
      } catch (err) {
        Logger.Warn("Unable to download: " + err);
        return;
      }
      const data = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(pack, null, 4));
      const _a = document.createElement("a");
      _a.setAttribute("href", data);
      _a.setAttribute("download", this.name + "_texurePackage.json");
      document.body.appendChild(_a);
      _a.click();
      _a.remove();
    }, 0);
  }
  updateFromJSON(data) {
    try {
      const parsedData = JSON.parse(data);
      this.name = parsedData.name;
      const _options = Object.keys(parsedData.options);
      for (let i = 0; i < _options.length; i++) {
        this.options[_options[i]] = parsedData.options[_options[i]];
      }
      for (let i = 0; i < parsedData.frames.length; i += 4) {
        const frame = new TexturePackerFrame(i / 4, new Vector2(parsedData.frames[i], parsedData.frames[i + 1]), new Vector2(parsedData.frames[i + 2], parsedData.frames[i + 3]));
        this.frames.push(frame);
      }
      const channels = Object.keys(parsedData.sets);
      for (let i = 0; i < channels.length; i++) {
        const _t = new Texture(parsedData.sets[channels[i]], this.scene, false, false);
        this.sets[channels[i]] = _t;
      }
    } catch (err) {
      Logger.Warn("Unable to update from JSON: " + err);
    }
  }
};
TexturePacker.LAYOUT_STRIP = 0;
TexturePacker.LAYOUT_POWER2 = 1;
TexturePacker.LAYOUT_COLNUM = 2;
TexturePacker.SUBUV_WRAP = 0;
TexturePacker.SUBUV_EXTEND = 1;
TexturePacker.SUBUV_COLOR = 2;

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/customProceduralTexture.js
var CustomProceduralTexture = class extends ProceduralTexture {
  constructor(name137, texturePath, size, scene, fallbackTexture, generateMipMaps, skipJson) {
    super(name137, size, null, scene, fallbackTexture, generateMipMaps);
    this._animate = true;
    this._time = 0;
    this._texturePath = texturePath;
    if (!skipJson) {
      this._loadJson(texturePath);
    } else {
      this.setFragment(this._texturePath);
    }
    this.refreshRate = 1;
  }
  _loadJson(jsonUrl) {
    const noConfigFile = () => {
      try {
        this.setFragment(this._texturePath);
      } catch (ex) {
        Logger.Log("No json or ShaderStore or DOM element found for CustomProceduralTexture");
      }
    };
    const configFileUrl = jsonUrl + "/config.json";
    const xhr = new WebRequest();
    xhr.open("GET", configFileUrl);
    xhr.addEventListener("load", () => {
      if (xhr.status === 200 || xhr.responseText && xhr.responseText.length > 0) {
        try {
          this._config = JSON.parse(xhr.response);
          this.updateShaderUniforms();
          this.updateTextures();
          this.setFragment(this._texturePath + "/custom");
          this._animate = this._config.animate;
          this.refreshRate = this._config.refreshrate;
        } catch (ex) {
          noConfigFile();
        }
      } else {
        noConfigFile();
      }
    }, false);
    xhr.addEventListener("error", () => {
      noConfigFile();
    }, false);
    try {
      xhr.send();
    } catch (ex) {
      Logger.Error("CustomProceduralTexture: Error on XHR send request.");
    }
  }
  isReady() {
    if (!super.isReady()) {
      return false;
    }
    for (const name137 in this._textures) {
      const texture = this._textures[name137];
      if (!texture.isReady()) {
        return false;
      }
    }
    return true;
  }
  render(useCameraPostProcess) {
    const scene = this.getScene();
    if (this._animate && scene) {
      this._time += scene.getAnimationRatio() * 0.03;
      this.updateShaderUniforms();
    }
    super.render(useCameraPostProcess);
  }
  updateTextures() {
    for (let i = 0; i < this._config.sampler2Ds.length; i++) {
      this.setTexture(this._config.sampler2Ds[i].sample2Dname, new Texture(this._texturePath + "/" + this._config.sampler2Ds[i].textureRelativeUrl, this.getScene()));
    }
  }
  updateShaderUniforms() {
    if (this._config) {
      for (let j = 0; j < this._config.uniforms.length; j++) {
        const uniform = this._config.uniforms[j];
        switch (uniform.type) {
          case "float":
            this.setFloat(uniform.name, uniform.value);
            break;
          case "color3":
            this.setColor3(uniform.name, new Color3(uniform.r, uniform.g, uniform.b));
            break;
          case "color4":
            this.setColor4(uniform.name, new Color4(uniform.r, uniform.g, uniform.b, uniform.a));
            break;
          case "vector2":
            this.setVector2(uniform.name, new Vector2(uniform.x, uniform.y));
            break;
          case "vector3":
            this.setVector3(uniform.name, new Vector3(uniform.x, uniform.y, uniform.z));
            break;
        }
      }
    }
    this.setFloat("time", this._time);
  }
  get animate() {
    return this._animate;
  }
  set animate(value) {
    this._animate = value;
  }
};

// node_modules/@babylonjs/core/Shaders/noise.fragment.js
var name64 = "noisePixelShader";
var shader64 = `uniform float brightness;
uniform float persistence;
uniform float timeScale;
varying vec2 vUV;
vec2 hash22(vec2 p)
{
p=p*mat2(127.1,311.7,269.5,183.3);
p=-1.0+2.0*fract(sin(p)*43758.5453123);
return sin(p*6.283+timeScale);
}
float interpolationNoise(vec2 p)
{
vec2 pi=floor(p);
vec2 pf=p-pi;
vec2 w=pf*pf*(3.-2.*pf);
float f00=dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));
float f01=dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));
float f10=dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));
float f11=dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));
float xm1=mix(f00,f10,w.x);
float xm2=mix(f01,f11,w.x);
float ym=mix(xm1,xm2,w.y); 
return ym;
}
float perlinNoise2D(float x,float y)
{
float sum=0.0;
float frequency=0.0;
float amplitude=0.0;
for(int i=0; i<OCTAVES; i++)
{
frequency=pow(2.0,float(i));
amplitude=pow(persistence,float(i));
sum=sum+interpolationNoise(vec2(x*frequency,y*frequency))*amplitude;
}
return sum;
}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
float x=abs(vUV.x);
float y=abs(vUV.y);
float noise=brightness+(1.0-brightness)*perlinNoise2D(x,y);
gl_FragColor=vec4(noise,noise,noise,1.0);
}
`;
ShaderStore.ShadersStore[name64] = shader64;

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/noiseProceduralTexture.js
var NoiseProceduralTexture = class extends ProceduralTexture {
  constructor(name137, size = 256, scene = EngineStore.LastCreatedScene, fallbackTexture, generateMipMaps) {
    super(name137, size, "noise", scene, fallbackTexture, generateMipMaps);
    this.time = 0;
    this.brightness = 0.2;
    this.octaves = 3;
    this.persistence = 0.8;
    this.animationSpeedFactor = 1;
    this.autoClear = false;
    this._updateShaderUniforms();
  }
  _updateShaderUniforms() {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    this.time += scene.getAnimationRatio() * this.animationSpeedFactor * 0.01;
    this.setFloat("brightness", this.brightness);
    this.setFloat("persistence", this.persistence);
    this.setFloat("timeScale", this.time);
  }
  _getDefines() {
    return "#define OCTAVES " + (this.octaves | 0);
  }
  render(useCameraPostProcess) {
    this._updateShaderUniforms();
    super.render(useCameraPostProcess);
  }
  serialize() {
    const serializationObject = {};
    serializationObject.customType = "BABYLON.NoiseProceduralTexture";
    serializationObject.brightness = this.brightness;
    serializationObject.octaves = this.octaves;
    serializationObject.persistence = this.persistence;
    serializationObject.animationSpeedFactor = this.animationSpeedFactor;
    serializationObject.size = this.getSize().width;
    serializationObject.generateMipMaps = this._generateMipMaps;
    serializationObject.time = this.time;
    return serializationObject;
  }
  clone() {
    const textureSize = this.getSize();
    const newTexture = new NoiseProceduralTexture(this.name, textureSize.width, this.getScene(), this._fallbackTexture ? this._fallbackTexture : void 0, this._generateMipMaps);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.coordinatesMode = this.coordinatesMode;
    newTexture.brightness = this.brightness;
    newTexture.octaves = this.octaves;
    newTexture.persistence = this.persistence;
    newTexture.animationSpeedFactor = this.animationSpeedFactor;
    newTexture.time = this.time;
    return newTexture;
  }
  static Parse(parsedTexture, scene) {
    var _a;
    const texture = new NoiseProceduralTexture(parsedTexture.name, parsedTexture.size, scene, void 0, parsedTexture.generateMipMaps);
    texture.brightness = parsedTexture.brightness;
    texture.octaves = parsedTexture.octaves;
    texture.persistence = parsedTexture.persistence;
    texture.animationSpeedFactor = parsedTexture.animationSpeedFactor;
    texture.time = (_a = parsedTexture.time) !== null && _a !== void 0 ? _a : 0;
    return texture;
  }
};
RegisterClass("BABYLON.NoiseProceduralTexture", NoiseProceduralTexture);

// node_modules/@babylonjs/core/Materials/Textures/rawTexture3D.js
var RawTexture3D = class extends Texture {
  constructor(data, width, height, depth, format, scene, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, textureType = 0) {
    super(null, scene, !generateMipMaps, invertY);
    this.format = format;
    this._texture = scene.getEngine().createRawTexture3D(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType);
    this.is3D = true;
  }
  update(data) {
    if (!this._texture) {
      return;
    }
    this._getEngine().updateRawTexture3D(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);
  }
};

// node_modules/@babylonjs/core/Materials/Textures/refractionTexture.js
var RefractionTexture = class extends RenderTargetTexture {
  constructor(name137, size, scene, generateMipMaps) {
    super(name137, size, scene, generateMipMaps, true);
    this.refractionPlane = new Plane(0, 1, 0, 1);
    this.depth = 2;
    this.onBeforeRenderObservable.add(() => {
      this.getScene().clipPlane = this.refractionPlane;
    });
    this.onAfterRenderObservable.add(() => {
      this.getScene().clipPlane = null;
    });
  }
  clone() {
    const scene = this.getScene();
    if (!scene) {
      return this;
    }
    const textureSize = this.getSize();
    const newTexture = new RefractionTexture(this.name, textureSize.width, scene, this._generateMipMaps);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.refractionPlane = this.refractionPlane.clone();
    if (this.renderList) {
      newTexture.renderList = this.renderList.slice(0);
    }
    newTexture.depth = this.depth;
    return newTexture;
  }
  serialize() {
    if (!this.name) {
      return null;
    }
    const serializationObject = super.serialize();
    serializationObject.mirrorPlane = this.refractionPlane.asArray();
    serializationObject.depth = this.depth;
    return serializationObject;
  }
};

// node_modules/@babylonjs/core/Materials/Textures/thinRenderTargetTexture.js
var ThinRenderTargetTexture = class extends ThinTexture {
  constructor(engine, size, options) {
    super(null);
    this._renderTarget = null;
    this._engine = engine;
    this._renderTargetOptions = options;
    this.resize(size);
  }
  get renderTarget() {
    return this._renderTarget;
  }
  resize(size) {
    var _a;
    (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose();
    this._renderTarget = null;
    this._texture = null;
    this._size = size;
    if (this._engine) {
      this._renderTarget = this._engine.createRenderTargetTexture(this._size, this._renderTargetOptions);
    }
    this._texture = this.renderTarget.texture;
  }
  getInternalTexture() {
    return this._texture;
  }
  getClassName() {
    return "ThinRenderTargetTexture";
  }
  dispose(disposeOnlyFramebuffers = false) {
    var _a;
    (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose(true);
    this._renderTarget = null;
    if (!disposeOnlyFramebuffers) {
      super.dispose();
    }
  }
};

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialConnectionPointCustomObject.js
var NodeMaterialConnectionPointCustomObject = class extends NodeMaterialConnectionPoint {
  constructor(name137, ownerBlock, direction, _blockType, _blockName) {
    super(name137, ownerBlock, direction);
    this._blockType = _blockType;
    this._blockName = _blockName;
    this.needDualDirectionValidation = true;
  }
  checkCompatibilityState(connectionPoint) {
    return connectionPoint instanceof NodeMaterialConnectionPointCustomObject && connectionPoint._blockName === this._blockName ? NodeMaterialConnectionPointCompatibilityStates.Compatible : NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;
  }
  createCustomInputBlock() {
    return [new this._blockType(this._blockName), this.name];
  }
};

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/bonesBlock.js
var BonesBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Vertex);
    this.registerInput("matricesIndices", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("matricesWeights", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("matricesIndicesExtra", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("matricesWeightsExtra", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  initialize(state) {
    state._excludeVariableName("boneSampler");
    state._excludeVariableName("boneTextureWidth");
    state._excludeVariableName("mBones");
    state._excludeVariableName("BonesPerMesh");
  }
  getClassName() {
    return "BonesBlock";
  }
  get matricesIndices() {
    return this._inputs[0];
  }
  get matricesWeights() {
    return this._inputs[1];
  }
  get matricesIndicesExtra() {
    return this._inputs[2];
  }
  get matricesWeightsExtra() {
    return this._inputs[3];
  }
  get world() {
    return this._inputs[4];
  }
  get output() {
    return this._outputs[0];
  }
  autoConfigure(material) {
    if (!this.matricesIndices.isConnected) {
      let matricesIndicesInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "matricesIndices");
      if (!matricesIndicesInput) {
        matricesIndicesInput = new InputBlock("matricesIndices");
        matricesIndicesInput.setAsAttribute("matricesIndices");
      }
      matricesIndicesInput.output.connectTo(this.matricesIndices);
    }
    if (!this.matricesWeights.isConnected) {
      let matricesWeightsInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "matricesWeights");
      if (!matricesWeightsInput) {
        matricesWeightsInput = new InputBlock("matricesWeights");
        matricesWeightsInput.setAsAttribute("matricesWeights");
      }
      matricesWeightsInput.output.connectTo(this.matricesWeights);
    }
    if (!this.world.isConnected) {
      let worldInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.World);
      if (!worldInput) {
        worldInput = new InputBlock("world");
        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
      }
      worldInput.output.connectTo(this.world);
    }
  }
  provideFallbacks(mesh, fallbacks) {
    if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      fallbacks.addCPUSkinningFallback(0, mesh);
    }
  }
  bind(effect, nodeMaterial, mesh) {
    MaterialHelper.BindBonesParameters(mesh, effect);
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    if (!defines._areAttributesDirty) {
      return;
    }
    MaterialHelper.PrepareDefinesForBones(mesh, defines);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    state.sharedData.blocksWithFallbacks.push(this);
    state.sharedData.forcedBindableBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    state.uniforms.push("boneTextureWidth");
    state.uniforms.push("mBones");
    state.samplers.push("boneSampler");
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("bonesDeclaration", comments, {
      removeAttributes: true,
      removeUniforms: false,
      removeVaryings: true,
      removeIfDef: false
    });
    const influenceVariablename = state._getFreeVariableName("influence");
    state.compilationString += state._emitCodeFromInclude("bonesVertex", comments, {
      replaceStrings: [
        {
          search: /finalWorld=finalWorld\*influence;/,
          replace: ""
        },
        {
          search: /influence/gm,
          replace: influenceVariablename
        }
      ]
    });
    const output = this._outputs[0];
    const worldInput = this.world;
    state.compilationString += `#if NUM_BONE_INFLUENCERS>0\r
`;
    state.compilationString += this._declareOutput(output, state) + ` = ${worldInput.associatedVariableName} * ${influenceVariablename};\r
`;
    state.compilationString += `#else\r
`;
    state.compilationString += this._declareOutput(output, state) + ` = ${worldInput.associatedVariableName};\r
`;
    state.compilationString += `#endif\r
`;
    return this;
  }
};
RegisterClass("BABYLON.BonesBlock", BonesBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/instancesBlock.js
var InstancesBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Vertex);
    this.registerInput("world0", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("world1", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("world2", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("world3", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix, true);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Matrix);
    this.registerOutput("instanceID", NodeMaterialBlockConnectionPointTypes.Float);
  }
  getClassName() {
    return "InstancesBlock";
  }
  get world0() {
    return this._inputs[0];
  }
  get world1() {
    return this._inputs[1];
  }
  get world2() {
    return this._inputs[2];
  }
  get world3() {
    return this._inputs[3];
  }
  get world() {
    return this._inputs[4];
  }
  get output() {
    return this._outputs[0];
  }
  get instanceID() {
    return this._outputs[1];
  }
  autoConfigure(material) {
    if (!this.world0.connectedPoint) {
      let world0Input = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "world0");
      if (!world0Input) {
        world0Input = new InputBlock("world0");
        world0Input.setAsAttribute("world0");
      }
      world0Input.output.connectTo(this.world0);
    }
    if (!this.world1.connectedPoint) {
      let world1Input = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "world1");
      if (!world1Input) {
        world1Input = new InputBlock("world1");
        world1Input.setAsAttribute("world1");
      }
      world1Input.output.connectTo(this.world1);
    }
    if (!this.world2.connectedPoint) {
      let world2Input = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "world2");
      if (!world2Input) {
        world2Input = new InputBlock("world2");
        world2Input.setAsAttribute("world2");
      }
      world2Input.output.connectTo(this.world2);
    }
    if (!this.world3.connectedPoint) {
      let world3Input = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "world3");
      if (!world3Input) {
        world3Input = new InputBlock("world3");
        world3Input.setAsAttribute("world3");
      }
      world3Input.output.connectTo(this.world3);
    }
    if (!this.world.connectedPoint) {
      let worldInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "world");
      if (!worldInput) {
        worldInput = new InputBlock("world");
        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
      }
      worldInput.output.connectTo(this.world);
    }
    this.world.define = "!INSTANCES || THIN_INSTANCES";
  }
  prepareDefines(mesh, nodeMaterial, defines, useInstances = false, subMesh) {
    let changed = false;
    if (defines["INSTANCES"] !== useInstances) {
      defines.setValue("INSTANCES", useInstances);
      changed = true;
    }
    if (subMesh && defines["THIN_INSTANCES"] !== !!(subMesh === null || subMesh === void 0 ? void 0 : subMesh.getRenderingMesh().hasThinInstances)) {
      defines.setValue("THIN_INSTANCES", !!(subMesh === null || subMesh === void 0 ? void 0 : subMesh.getRenderingMesh().hasThinInstances));
      changed = true;
    }
    if (changed) {
      defines.markAsUnprocessed();
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const engine = state.sharedData.scene.getEngine();
    state.sharedData.blocksWithDefines.push(this);
    const output = this._outputs[0];
    const instanceID = this._outputs[1];
    const world0 = this.world0;
    const world1 = this.world1;
    const world2 = this.world2;
    const world3 = this.world3;
    state.compilationString += `#ifdef INSTANCES\r
`;
    state.compilationString += this._declareOutput(output, state) + ` = mat4(${world0.associatedVariableName}, ${world1.associatedVariableName}, ${world2.associatedVariableName}, ${world3.associatedVariableName});\r
`;
    state.compilationString += `#ifdef THIN_INSTANCES\r
`;
    state.compilationString += `${output.associatedVariableName} = ${this.world.associatedVariableName} * ${output.associatedVariableName};\r
`;
    state.compilationString += `#endif\r
`;
    if (engine._caps.canUseGLInstanceID) {
      state.compilationString += this._declareOutput(instanceID, state) + ` = float(gl_InstanceID);\r
`;
    } else {
      state.compilationString += this._declareOutput(instanceID, state) + ` = 0.0;\r
`;
    }
    state.compilationString += `#else\r
`;
    state.compilationString += this._declareOutput(output, state) + ` = ${this.world.associatedVariableName};\r
`;
    state.compilationString += this._declareOutput(instanceID, state) + ` = 0.0;\r
`;
    state.compilationString += `#endif\r
`;
    return this;
  }
};
RegisterClass("BABYLON.InstancesBlock", InstancesBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/morphTargetsBlock.js
var MorphTargetsBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Vertex);
    this.registerInput("position", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("normal", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("tangent", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.tangent.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("positionOutput", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("normalOutput", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("tangentOutput", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("uvOutput", NodeMaterialBlockConnectionPointTypes.Vector2);
  }
  getClassName() {
    return "MorphTargetsBlock";
  }
  get position() {
    return this._inputs[0];
  }
  get normal() {
    return this._inputs[1];
  }
  get tangent() {
    return this._inputs[2];
  }
  get uv() {
    return this._inputs[3];
  }
  get positionOutput() {
    return this._outputs[0];
  }
  get normalOutput() {
    return this._outputs[1];
  }
  get tangentOutput() {
    return this._outputs[2];
  }
  get uvOutput() {
    return this._outputs[3];
  }
  initialize(state) {
    state._excludeVariableName("morphTargetInfluences");
  }
  autoConfigure(material) {
    if (!this.position.isConnected) {
      let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "position");
      if (!positionInput) {
        positionInput = new InputBlock("position");
        positionInput.setAsAttribute();
      }
      positionInput.output.connectTo(this.position);
    }
    if (!this.normal.isConnected) {
      let normalInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "normal");
      if (!normalInput) {
        normalInput = new InputBlock("normal");
        normalInput.setAsAttribute("normal");
      }
      normalInput.output.connectTo(this.normal);
    }
    if (!this.tangent.isConnected) {
      let tangentInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "tangent");
      if (!tangentInput) {
        tangentInput = new InputBlock("tangent");
        tangentInput.setAsAttribute("tangent");
      }
      tangentInput.output.connectTo(this.tangent);
    }
    if (!this.uv.isConnected) {
      let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "uv");
      if (!uvInput) {
        uvInput = new InputBlock("uv");
        uvInput.setAsAttribute("uv");
      }
      uvInput.output.connectTo(this.uv);
    }
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    if (mesh.morphTargetManager) {
      const morphTargetManager = mesh.morphTargetManager;
      if ((morphTargetManager === null || morphTargetManager === void 0 ? void 0 : morphTargetManager.isUsingTextureForTargets) && morphTargetManager.numInfluencers !== defines["NUM_MORPH_INFLUENCERS"]) {
        defines.markAsAttributesDirty();
      }
    }
    if (!defines._areAttributesDirty) {
      return;
    }
    MaterialHelper.PrepareDefinesForMorphTargets(mesh, defines);
  }
  bind(effect, nodeMaterial, mesh) {
    if (mesh && mesh.morphTargetManager && mesh.morphTargetManager.numInfluencers > 0) {
      MaterialHelper.BindMorphTargetParameters(mesh, effect);
      if (mesh.morphTargetManager.isUsingTextureForTargets) {
        mesh.morphTargetManager._bind(effect);
      }
    }
  }
  replaceRepeatableContent(vertexShaderState, fragmentShaderState, mesh, defines) {
    const position = this.position;
    const normal = this.normal;
    const tangent = this.tangent;
    const uv = this.uv;
    const positionOutput = this.positionOutput;
    const normalOutput = this.normalOutput;
    const tangentOutput = this.tangentOutput;
    const uvOutput = this.uvOutput;
    const state = vertexShaderState;
    const repeatCount = defines.NUM_MORPH_INFLUENCERS;
    const manager = mesh.morphTargetManager;
    const hasNormals = manager && manager.supportsNormals && defines["NORMAL"];
    const hasTangents = manager && manager.supportsTangents && defines["TANGENT"];
    const hasUVs = manager && manager.supportsUVs && defines["UV1"];
    let injectionCode = "";
    if ((manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) && repeatCount > 0) {
      injectionCode += `float vertexID;\r
`;
    }
    for (let index = 0; index < repeatCount; index++) {
      injectionCode += `#ifdef MORPHTARGETS\r
`;
      if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {
        injectionCode += `vertexID = float(gl_VertexID) * morphTargetTextureInfo.x;\r
`;
        injectionCode += `${positionOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID) - ${position.associatedVariableName}) * morphTargetInfluences[${index}];\r
`;
        injectionCode += `vertexID += 1.0;\r
`;
      } else {
        injectionCode += `${positionOutput.associatedVariableName} += (position${index} - ${position.associatedVariableName}) * morphTargetInfluences[${index}];\r
`;
      }
      if (hasNormals) {
        injectionCode += `#ifdef MORPHTARGETS_NORMAL\r
`;
        if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {
          injectionCode += `${normalOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID) - ${normal.associatedVariableName}) * morphTargetInfluences[${index}];\r
`;
          injectionCode += `vertexID += 1.0;\r
`;
        } else {
          injectionCode += `${normalOutput.associatedVariableName} += (normal${index} - ${normal.associatedVariableName}) * morphTargetInfluences[${index}];\r
`;
        }
        injectionCode += `#endif\r
`;
      }
      if (hasUVs) {
        injectionCode += `#ifdef MORPHTARGETS_UV\r
`;
        if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {
          injectionCode += `${uvOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID).xy - ${uv.associatedVariableName}) * morphTargetInfluences[${index}];\r
`;
          injectionCode += `vertexID += 1.0;\r
`;
        } else {
          injectionCode += `${uvOutput.associatedVariableName}.xy += (uv_${index} - ${uv.associatedVariableName}.xy) * morphTargetInfluences[${index}];\r
`;
        }
        injectionCode += `#endif\r
`;
      }
      if (hasTangents) {
        injectionCode += `#ifdef MORPHTARGETS_TANGENT\r
`;
        if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {
          injectionCode += `${tangentOutput.associatedVariableName}.xyz += (readVector3FromRawSampler(${index}, vertexID) - ${tangent.associatedVariableName}.xyz) * morphTargetInfluences[${index}];\r
`;
        } else {
          injectionCode += `${tangentOutput.associatedVariableName}.xyz += (tangent${index} - ${tangent.associatedVariableName}.xyz) * morphTargetInfluences[${index}];\r
`;
        }
        if (tangent.type === NodeMaterialBlockConnectionPointTypes.Vector4) {
          injectionCode += `${tangentOutput.associatedVariableName}.w = ${tangent.associatedVariableName}.w;\r
`;
        } else {
          injectionCode += `${tangentOutput.associatedVariableName}.w = 1.;\r
`;
        }
        injectionCode += `#endif\r
`;
      }
      injectionCode += `#endif\r
`;
    }
    state.compilationString = state.compilationString.replace(this._repeatableContentAnchor, injectionCode);
    if (repeatCount > 0) {
      for (let index = 0; index < repeatCount; index++) {
        state.attributes.push(VertexBuffer.PositionKind + index);
        if (hasNormals) {
          state.attributes.push(VertexBuffer.NormalKind + index);
        }
        if (hasTangents) {
          state.attributes.push(VertexBuffer.TangentKind + index);
        }
        if (hasUVs) {
          state.attributes.push(VertexBuffer.UVKind + "_" + index);
        }
      }
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.bindableBlocks.push(this);
    state.sharedData.repeatableContentBlocks.push(this);
    const position = this.position;
    const normal = this.normal;
    const tangent = this.tangent;
    const uv = this.uv;
    const positionOutput = this.positionOutput;
    const normalOutput = this.normalOutput;
    const tangentOutput = this.tangentOutput;
    const uvOutput = this.uvOutput;
    const comments = `//${this.name}`;
    state.uniforms.push("morphTargetInfluences");
    state.uniforms.push("morphTargetTextureInfo");
    state.uniforms.push("morphTargetTextureIndices");
    state.samplers.push("morphTargets");
    state._emitFunctionFromInclude("morphTargetsVertexGlobalDeclaration", comments);
    state._emitFunctionFromInclude("morphTargetsVertexDeclaration", comments, {
      repeatKey: "maxSimultaneousMorphTargets"
    });
    state.compilationString += `${this._declareOutput(positionOutput, state)} = ${position.associatedVariableName};\r
`;
    state.compilationString += `#ifdef NORMAL\r
`;
    state.compilationString += `${this._declareOutput(normalOutput, state)} = ${normal.associatedVariableName};\r
`;
    state.compilationString += `#else\r
`;
    state.compilationString += `${this._declareOutput(normalOutput, state)} = vec3(0., 0., 0.);\r
`;
    state.compilationString += `#endif\r
`;
    state.compilationString += `#ifdef TANGENT\r
`;
    state.compilationString += `${this._declareOutput(tangentOutput, state)} = ${tangent.associatedVariableName};\r
`;
    state.compilationString += `#else\r
`;
    state.compilationString += `${this._declareOutput(tangentOutput, state)} = vec4(0., 0., 0., 0.);\r
`;
    state.compilationString += `#endif\r
`;
    state.compilationString += `#ifdef UV1\r
`;
    state.compilationString += `${this._declareOutput(uvOutput, state)} = ${uv.associatedVariableName};\r
`;
    state.compilationString += `#else\r
`;
    state.compilationString += `${this._declareOutput(uvOutput, state)} = vec2(0., 0.);\r
`;
    state.compilationString += `#endif\r
`;
    this._repeatableContentAnchor = state._repeatableContentAnchor;
    state.compilationString += this._repeatableContentAnchor;
    return this;
  }
};
RegisterClass("BABYLON.MorphTargetsBlock", MorphTargetsBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/lightInformationBlock.js
var LightInformationBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Vertex);
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    this.registerOutput("direction", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("color", NodeMaterialBlockConnectionPointTypes.Color3);
    this.registerOutput("intensity", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("shadowBias", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("shadowNormalBias", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("shadowDepthScale", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("shadowDepthRange", NodeMaterialBlockConnectionPointTypes.Vector2);
  }
  getClassName() {
    return "LightInformationBlock";
  }
  get worldPosition() {
    return this._inputs[0];
  }
  get direction() {
    return this._outputs[0];
  }
  get color() {
    return this._outputs[1];
  }
  get intensity() {
    return this._outputs[2];
  }
  get shadowBias() {
    return this._outputs[3];
  }
  get shadowNormalBias() {
    return this._outputs[4];
  }
  get shadowDepthScale() {
    return this._outputs[5];
  }
  get shadowDepthRange() {
    return this._outputs[6];
  }
  bind(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    if (this.light && this.light.isDisposed()) {
      this.light = null;
    }
    let light = this.light;
    const scene = nodeMaterial.getScene();
    if (!light && scene.lights.length) {
      light = this.light = scene.lights[0];
      this._forcePrepareDefines = true;
    }
    if (!light || !light.isEnabled) {
      effect.setFloat3(this._lightDataUniformName, 0, 0, 0);
      effect.setFloat4(this._lightColorUniformName, 0, 0, 0, 0);
      return;
    }
    light.transferToNodeMaterialEffect(effect, this._lightDataUniformName);
    effect.setColor4(this._lightColorUniformName, light.diffuse, light.intensity);
    const generator = light.getShadowGenerator();
    if (this.shadowBias.hasEndpoints || this.shadowNormalBias.hasEndpoints || this.shadowDepthScale.hasEndpoints) {
      if (generator) {
        effect.setFloat3(this._lightShadowUniformName, generator.bias, generator.normalBias, generator.depthScale);
      } else {
        effect.setFloat3(this._lightShadowUniformName, 0, 0, 0);
      }
    }
    if (this.shadowDepthRange) {
      if (generator && scene.activeCamera) {
        const shadowLight = light;
        effect.setFloat2(this._lightShadowExtraUniformName, shadowLight.getDepthMinZ(scene.activeCamera), shadowLight.getDepthMinZ(scene.activeCamera) + shadowLight.getDepthMaxZ(scene.activeCamera));
      } else {
        effect.setFloat2(this._lightShadowExtraUniformName, 0, 0);
      }
    }
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    if (!defines._areLightsDirty && !this._forcePrepareDefines) {
      return;
    }
    this._forcePrepareDefines = false;
    const light = this.light;
    defines.setValue(this._lightTypeDefineName, light && light instanceof PointLight ? true : false, true);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    state.sharedData.bindableBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    const direction = this.direction;
    const color = this.color;
    const intensity = this.intensity;
    const shadowBias = this.shadowBias;
    const shadowNormalBias = this.shadowNormalBias;
    const shadowDepthScale = this.shadowDepthScale;
    const shadowDepthRange = this.shadowDepthRange;
    this._lightDataUniformName = state._getFreeVariableName("lightData");
    this._lightColorUniformName = state._getFreeVariableName("lightColor");
    this._lightShadowUniformName = state._getFreeVariableName("shadowData");
    this._lightShadowExtraUniformName = state._getFreeVariableName("shadowExtraData");
    this._lightTypeDefineName = state._getFreeDefineName("LIGHTPOINTTYPE");
    state._emitUniformFromString(this._lightDataUniformName, "vec3");
    state._emitUniformFromString(this._lightColorUniformName, "vec4");
    state.compilationString += `#ifdef ${this._lightTypeDefineName}\r
`;
    state.compilationString += this._declareOutput(direction, state) + ` = normalize(${this.worldPosition.associatedVariableName}.xyz - ${this._lightDataUniformName});\r
`;
    state.compilationString += `#else\r
`;
    state.compilationString += this._declareOutput(direction, state) + ` = ${this._lightDataUniformName};\r
`;
    state.compilationString += `#endif\r
`;
    state.compilationString += this._declareOutput(color, state) + ` = ${this._lightColorUniformName}.rgb;\r
`;
    state.compilationString += this._declareOutput(intensity, state) + ` = ${this._lightColorUniformName}.a;\r
`;
    if (shadowBias.hasEndpoints || shadowNormalBias.hasEndpoints || shadowDepthScale.hasEndpoints) {
      state._emitUniformFromString(this._lightShadowUniformName, "vec3");
      if (shadowBias.hasEndpoints) {
        state.compilationString += this._declareOutput(shadowBias, state) + ` = ${this._lightShadowUniformName}.x;\r
`;
      }
      if (shadowNormalBias.hasEndpoints) {
        state.compilationString += this._declareOutput(shadowNormalBias, state) + ` = ${this._lightShadowUniformName}.y;\r
`;
      }
      if (shadowDepthScale.hasEndpoints) {
        state.compilationString += this._declareOutput(shadowDepthScale, state) + ` = ${this._lightShadowUniformName}.z;\r
`;
      }
    }
    if (shadowDepthRange.hasEndpoints) {
      state._emitUniformFromString(this._lightShadowExtraUniformName, "vec2");
      state.compilationString += this._declareOutput(shadowDepthRange, state) + ` = ${this._lightShadowUniformName};\r
`;
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    if (this.light) {
      serializationObject.lightId = this.light.id;
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    if (serializationObject.lightId) {
      this.light = scene.getLightById(serializationObject.lightId);
    }
  }
};
RegisterClass("BABYLON.LightInformationBlock", LightInformationBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/imageProcessingBlock.js
var ImageProcessingBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this.convertInputToLinearSpace = true;
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Color4);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  getClassName() {
    return "ImageProcessingBlock";
  }
  get color() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  get rgb() {
    return this._outputs[1];
  }
  initialize(state) {
    state._excludeVariableName("exposureLinear");
    state._excludeVariableName("contrast");
    state._excludeVariableName("vInverseScreenSize");
    state._excludeVariableName("vignetteSettings1");
    state._excludeVariableName("vignetteSettings2");
    state._excludeVariableName("vCameraColorCurveNegative");
    state._excludeVariableName("vCameraColorCurveNeutral");
    state._excludeVariableName("vCameraColorCurvePositive");
    state._excludeVariableName("txColorTransform");
    state._excludeVariableName("colorTransformSettings");
    state._excludeVariableName("ditherIntensity");
  }
  isReady(mesh, nodeMaterial, defines) {
    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {
      if (!nodeMaterial.imageProcessingConfiguration.isReady()) {
        return false;
      }
    }
    return true;
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {
      nodeMaterial.imageProcessingConfiguration.prepareDefines(defines);
    }
  }
  bind(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    if (!nodeMaterial.imageProcessingConfiguration) {
      return;
    }
    nodeMaterial.imageProcessingConfiguration.bind(effect);
  }
  _buildBlock(state) {
    var _a;
    super._buildBlock(state);
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.bindableBlocks.push(this);
    state.uniforms.push("exposureLinear");
    state.uniforms.push("contrast");
    state.uniforms.push("vInverseScreenSize");
    state.uniforms.push("vignetteSettings1");
    state.uniforms.push("vignetteSettings2");
    state.uniforms.push("vCameraColorCurveNegative");
    state.uniforms.push("vCameraColorCurveNeutral");
    state.uniforms.push("vCameraColorCurvePositive");
    state.uniforms.push("txColorTransform");
    state.uniforms.push("colorTransformSettings");
    state.uniforms.push("ditherIntensity");
    const color = this.color;
    const output = this._outputs[0];
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    state._emitFunctionFromInclude("imageProcessingDeclaration", comments);
    state._emitFunctionFromInclude("imageProcessingFunctions", comments);
    if ((_a = color.connectedPoint) === null || _a === void 0 ? void 0 : _a.isConnected) {
      if (color.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Color4 || color.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4) {
        state.compilationString += `${this._declareOutput(output, state)} = ${color.associatedVariableName};\r
`;
      } else {
        state.compilationString += `${this._declareOutput(output, state)} = vec4(${color.associatedVariableName}, 1.0);\r
`;
      }
      state.compilationString += `#ifdef IMAGEPROCESSINGPOSTPROCESS\r
`;
      if (this.convertInputToLinearSpace) {
        state.compilationString += `${output.associatedVariableName}.rgb = toLinearSpace(${color.associatedVariableName}.rgb);\r
`;
      }
      state.compilationString += `#else\r
`;
      state.compilationString += `#ifdef IMAGEPROCESSING\r
`;
      if (this.convertInputToLinearSpace) {
        state.compilationString += `${output.associatedVariableName}.rgb = toLinearSpace(${color.associatedVariableName}.rgb);\r
`;
      }
      state.compilationString += `${output.associatedVariableName} = applyImageProcessing(${output.associatedVariableName});\r
`;
      state.compilationString += `#endif\r
`;
      state.compilationString += `#endif\r
`;
      if (this.rgb.hasEndpoints) {
        state.compilationString += this._declareOutput(this.rgb, state) + ` = ${this.output.associatedVariableName}.xyz;\r
`;
      }
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.convertInputToLinearSpace = ${this.convertInputToLinearSpace};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertInputToLinearSpace = this.convertInputToLinearSpace;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    var _a;
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertInputToLinearSpace = (_a = serializationObject.convertInputToLinearSpace) !== null && _a !== void 0 ? _a : true;
  }
};
__decorate([
  editableInPropertyPage("Convert input to linear space", PropertyTypeForEdition.Boolean, "ADVANCED")
], ImageProcessingBlock.prototype, "convertInputToLinearSpace", void 0);
RegisterClass("BABYLON.ImageProcessingBlock", ImageProcessingBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/TBNBlock.js
var TBNBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment, true);
    this.registerInput("normal", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);
    this.normal.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("tangent", NodeMaterialBlockConnectionPointTypes.Vector4, false);
    this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix, false);
    this.registerOutput("TBN", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("TBN", this, NodeMaterialConnectionPointDirection.Output, TBNBlock, "TBNBlock"));
    this.registerOutput("row0", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("row1", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("row2", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);
  }
  getClassName() {
    return "TBNBlock";
  }
  initialize(state) {
    state._excludeVariableName("tbnNormal");
    state._excludeVariableName("tbnTangent");
    state._excludeVariableName("tbnBitangent");
    state._excludeVariableName("TBN");
  }
  get normal() {
    return this._inputs[0];
  }
  get tangent() {
    return this._inputs[1];
  }
  get world() {
    return this._inputs[2];
  }
  get TBN() {
    return this._outputs[0];
  }
  get row0() {
    return this._outputs[1];
  }
  get row1() {
    return this._outputs[2];
  }
  get row2() {
    return this._outputs[3];
  }
  get target() {
    return NodeMaterialBlockTargets.Fragment;
  }
  set target(value) {
  }
  autoConfigure(material) {
    if (!this.world.isConnected) {
      let worldInput = material.getInputBlockByPredicate((b) => b.isSystemValue && b.systemValue === NodeMaterialSystemValues.World);
      if (!worldInput) {
        worldInput = new InputBlock("world");
        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
      }
      worldInput.output.connectTo(this.world);
    }
    if (!this.normal.isConnected) {
      let normalInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "normal");
      if (!normalInput) {
        normalInput = new InputBlock("normal");
        normalInput.setAsAttribute("normal");
      }
      normalInput.output.connectTo(this.normal);
    }
    if (!this.tangent.isConnected) {
      let tangentInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "tangent" && b.type === NodeMaterialBlockConnectionPointTypes.Vector4);
      if (!tangentInput) {
        tangentInput = new InputBlock("tangent");
        tangentInput.setAsAttribute("tangent");
      }
      tangentInput.output.connectTo(this.tangent);
    }
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    var _a, _b, _c, _d;
    const normal = this.normal;
    const tangent = this.tangent;
    let normalAvailable = normal.isConnected;
    if (((_a = normal.connectInputBlock) === null || _a === void 0 ? void 0 : _a.isAttribute) && !mesh.isVerticesDataPresent((_b = normal.connectInputBlock) === null || _b === void 0 ? void 0 : _b.name)) {
      normalAvailable = false;
    }
    let tangentAvailable = tangent.isConnected;
    if (((_c = tangent.connectInputBlock) === null || _c === void 0 ? void 0 : _c.isAttribute) && !mesh.isVerticesDataPresent((_d = tangent.connectInputBlock) === null || _d === void 0 ? void 0 : _d.name)) {
      tangentAvailable = false;
    }
    const useTBNBlock = normalAvailable && tangentAvailable;
    defines.setValue("TBNBLOCK", useTBNBlock, true);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const normal = this.normal;
    const tangent = this.tangent;
    const world = this.world;
    const TBN = this.TBN;
    const row0 = this.row0;
    const row1 = this.row1;
    const row2 = this.row2;
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `
                // ${this.name}
                vec3 tbnNormal = normalize(${normal.associatedVariableName}).xyz;
                vec3 tbnTangent = normalize(${tangent.associatedVariableName}.xyz);
                vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${tangent.associatedVariableName}.w;
                mat3 ${TBN.associatedVariableName} = mat3(${world.associatedVariableName}) * mat3(tbnTangent, tbnBitangent, tbnNormal);
            `;
      if (row0.hasEndpoints) {
        state.compilationString += this._declareOutput(row0, state) + ` = vec3(${TBN.associatedVariableName}[0][0], ${TBN.associatedVariableName}[0][1], ${TBN.associatedVariableName}[0][2]);\r
`;
      }
      if (row1.hasEndpoints) {
        state.compilationString += this._declareOutput(row1, state) + ` = vec3(${TBN.associatedVariableName}[1[0], ${TBN.associatedVariableName}[1][1], ${TBN.associatedVariableName}[1][2]);\r
`;
      }
      if (row2.hasEndpoints) {
        state.compilationString += this._declareOutput(row2, state) + ` = vec3(${TBN.associatedVariableName}[2][0], ${TBN.associatedVariableName}[2][1], ${TBN.associatedVariableName}[2][2]);\r
`;
      }
      state.sharedData.blocksWithDefines.push(this);
    }
    return this;
  }
};
RegisterClass("BABYLON.TBNBlock", TBNBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/perturbNormalBlock.js
var PerturbNormalBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this._tangentSpaceParameterName = "";
    this._tangentCorrectionFactorName = "";
    this.invertX = false;
    this.invertY = false;
    this.useParallaxOcclusion = false;
    this._isUnique = true;
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector4, false);
    this.registerInput("worldTangent", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2, false);
    this.registerInput("normalMapColor", NodeMaterialBlockConnectionPointTypes.Color3, false);
    this.registerInput("strength", NodeMaterialBlockConnectionPointTypes.Float, false);
    this.registerInput("viewDirection", NodeMaterialBlockConnectionPointTypes.Vector3, true);
    this.registerInput("parallaxScale", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("parallaxHeight", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("TBN", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("TBN", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, "TBNBlock"));
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("uvOffset", NodeMaterialBlockConnectionPointTypes.Vector2);
  }
  getClassName() {
    return "PerturbNormalBlock";
  }
  get worldPosition() {
    return this._inputs[0];
  }
  get worldNormal() {
    return this._inputs[1];
  }
  get worldTangent() {
    return this._inputs[2];
  }
  get uv() {
    return this._inputs[3];
  }
  get normalMapColor() {
    return this._inputs[4];
  }
  get strength() {
    return this._inputs[5];
  }
  get viewDirection() {
    return this._inputs[6];
  }
  get parallaxScale() {
    return this._inputs[7];
  }
  get parallaxHeight() {
    return this._inputs[8];
  }
  get TBN() {
    return this._inputs[9];
  }
  get output() {
    return this._outputs[0];
  }
  get uvOffset() {
    return this._outputs[1];
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    const normalSamplerName = this.normalMapColor.connectedPoint._ownerBlock.samplerName;
    const useParallax = this.viewDirection.isConnected && (this.useParallaxOcclusion && normalSamplerName || !this.useParallaxOcclusion && this.parallaxHeight.isConnected);
    defines.setValue("BUMP", true);
    defines.setValue("PARALLAX", useParallax, true);
    defines.setValue("PARALLAXOCCLUSION", this.useParallaxOcclusion, true);
  }
  bind(effect, nodeMaterial, mesh) {
    if (nodeMaterial.getScene()._mirroredCameraPosition) {
      effect.setFloat2(this._tangentSpaceParameterName, this.invertX ? 1 : -1, this.invertY ? 1 : -1);
    } else {
      effect.setFloat2(this._tangentSpaceParameterName, this.invertX ? -1 : 1, this.invertY ? -1 : 1);
    }
    if (mesh) {
      effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);
    }
  }
  autoConfigure(material) {
    if (!this.uv.isConnected) {
      let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "uv");
      if (!uvInput) {
        uvInput = new InputBlock("uv");
        uvInput.setAsAttribute();
      }
      uvInput.output.connectTo(this.uv);
    }
    if (!this.strength.isConnected) {
      const strengthInput = new InputBlock("strength");
      strengthInput.value = 1;
      strengthInput.output.connectTo(this.strength);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const comments = `//${this.name}`;
    const uv = this.uv;
    const worldPosition = this.worldPosition;
    const worldNormal = this.worldNormal;
    const worldTangent = this.worldTangent;
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.bindableBlocks.push(this);
    this._tangentSpaceParameterName = state._getFreeDefineName("tangentSpaceParameter");
    state._emitUniformFromString(this._tangentSpaceParameterName, "vec2");
    this._tangentCorrectionFactorName = state._getFreeDefineName("tangentCorrectionFactor");
    state._emitUniformFromString(this._tangentCorrectionFactorName, "float");
    let normalSamplerName = null;
    if (this.normalMapColor.connectedPoint) {
      normalSamplerName = this.normalMapColor.connectedPoint._ownerBlock.samplerName;
    }
    const useParallax = this.viewDirection.isConnected && (this.useParallaxOcclusion && normalSamplerName || !this.useParallaxOcclusion && this.parallaxHeight.isConnected);
    const replaceForParallaxInfos = !this.parallaxScale.isConnectedToInputBlock ? "0.05" : this.parallaxScale.connectInputBlock.isConstant ? state._emitFloat(this.parallaxScale.connectInputBlock.value) : this.parallaxScale.associatedVariableName;
    const replaceForBumpInfos = this.strength.isConnectedToInputBlock && this.strength.connectInputBlock.isConstant ? `\r
#if !defined(NORMALXYSCALE)\r
1.0/\r
#endif\r
${state._emitFloat(this.strength.connectInputBlock.value)}` : `\r
#if !defined(NORMALXYSCALE)\r
1.0/\r
#endif\r
${this.strength.associatedVariableName}`;
    state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    const tangentReplaceString = { search: /defined\(TANGENT\)/g, replace: worldTangent.isConnected ? "defined(TANGENT)" : "defined(IGNORE)" };
    const tbnVarying = { search: /varying mat3 vTBN/g, replace: "" };
    const TBN = this.TBN;
    if (TBN.isConnected) {
      state.compilationString += `
            #ifdef TBNBLOCK
            mat3 vTBN = ${TBN.associatedVariableName};
            #endif
            `;
    } else if (worldTangent.isConnected) {
      state.compilationString += `vec3 tbnNormal = normalize(${worldNormal.associatedVariableName}.xyz);\r
`;
      state.compilationString += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\r
`;
      state.compilationString += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\r
`;
      state.compilationString += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\r
`;
    }
    state._emitFunctionFromInclude("bumpFragmentMainFunctions", comments, {
      replaceStrings: [tangentReplaceString, tbnVarying]
    });
    state._emitFunctionFromInclude("bumpFragmentFunctions", comments, {
      replaceStrings: [
        { search: /#include<samplerFragmentDeclaration>\(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump\)/g, replace: "" },
        { search: /uniform sampler2D bumpSampler;/g, replace: "" },
        {
          search: /vec2 parallaxOcclusion\(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale\)/g,
          replace: "#define inline\r\nvec2 parallaxOcclusion(vec3 vViewDirCoT, vec3 vNormalCoT, vec2 texCoord, float parallaxScale, sampler2D bumpSampler)"
        },
        { search: /vec2 parallaxOffset\(vec3 viewDir,float heightScale\)/g, replace: "vec2 parallaxOffset(vec3 viewDir, float heightScale, float height_)" },
        { search: /texture2D\(bumpSampler,vBumpUV\)\.w/g, replace: "height_" }
      ]
    });
    const uvForPerturbNormal = !useParallax || !normalSamplerName ? this.normalMapColor.associatedVariableName : `texture2D(${normalSamplerName}, ${uv.associatedVariableName} + uvOffset).xyz`;
    state.compilationString += this._declareOutput(this.output, state) + " = vec4(0.);\r\n";
    state.compilationString += state._emitCodeFromInclude("bumpFragment", comments, {
      replaceStrings: [
        { search: /perturbNormal\(TBN,texture2D\(bumpSampler,vBumpUV\+uvOffset\).xyz,vBumpInfos.y\)/g, replace: `perturbNormal(TBN, ${uvForPerturbNormal}, vBumpInfos.y)` },
        {
          search: /parallaxOcclusion\(invTBN\*-viewDirectionW,invTBN\*normalW,vBumpUV,vBumpInfos.z\)/g,
          replace: `parallaxOcclusion((invTBN * -viewDirectionW), (invTBN * normalW), vBumpUV, vBumpInfos.z, ${useParallax && this.useParallaxOcclusion ? normalSamplerName : "bumpSampler"})`
        },
        {
          search: /parallaxOffset\(invTBN\*viewDirectionW,vBumpInfos\.z\)/g,
          replace: `parallaxOffset(invTBN * viewDirectionW, vBumpInfos.z, ${useParallax ? this.parallaxHeight.associatedVariableName : "0."})`
        },
        { search: /vTangentSpaceParams/g, replace: this._tangentSpaceParameterName },
        { search: /vBumpInfos.y/g, replace: replaceForBumpInfos },
        { search: /vBumpInfos.z/g, replace: replaceForParallaxInfos },
        { search: /vBumpUV/g, replace: uv.associatedVariableName },
        { search: /vPositionW/g, replace: worldPosition.associatedVariableName + ".xyz" },
        { search: /normalW=/g, replace: this.output.associatedVariableName + ".xyz = " },
        { search: /mat3\(normalMatrix\)\*normalW/g, replace: "mat3(normalMatrix) * " + this.output.associatedVariableName + ".xyz" },
        { search: /normalW/g, replace: worldNormal.associatedVariableName + ".xyz" },
        { search: /viewDirectionW/g, replace: useParallax ? this.viewDirection.associatedVariableName : "vec3(0.)" },
        tangentReplaceString
      ]
    });
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.invertX = ${this.invertX};\r
`;
    codeString += `${this._codeVariableName}.invertY = ${this.invertY};\r
`;
    codeString += `${this._codeVariableName}.useParallaxOcclusion = ${this.useParallaxOcclusion};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.invertX = this.invertX;
    serializationObject.invertY = this.invertY;
    serializationObject.useParallaxOcclusion = this.useParallaxOcclusion;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.invertX = serializationObject.invertX;
    this.invertY = serializationObject.invertY;
    this.useParallaxOcclusion = !!serializationObject.useParallaxOcclusion;
  }
};
__decorate([
  editableInPropertyPage("Invert X axis", PropertyTypeForEdition.Boolean, "PROPERTIES", { notifiers: { update: false } })
], PerturbNormalBlock.prototype, "invertX", void 0);
__decorate([
  editableInPropertyPage("Invert Y axis", PropertyTypeForEdition.Boolean, "PROPERTIES", { notifiers: { update: false } })
], PerturbNormalBlock.prototype, "invertY", void 0);
__decorate([
  editableInPropertyPage("Use parallax occlusion", PropertyTypeForEdition.Boolean)
], PerturbNormalBlock.prototype, "useParallaxOcclusion", void 0);
RegisterClass("BABYLON.PerturbNormalBlock", PerturbNormalBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/discardBlock.js
var DiscardBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment, true);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("cutoff", NodeMaterialBlockConnectionPointTypes.Float, true);
  }
  getClassName() {
    return "DiscardBlock";
  }
  get value() {
    return this._inputs[0];
  }
  get cutoff() {
    return this._inputs[1];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    state.sharedData.hints.needAlphaTesting = true;
    if (!this.cutoff.isConnected || !this.value.isConnected) {
      return;
    }
    state.compilationString += `if (${this.value.associatedVariableName} < ${this.cutoff.associatedVariableName}) discard;\r
`;
    return this;
  }
};
RegisterClass("BABYLON.DiscardBlock", DiscardBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/frontFacingBlock.js
var FrontFacingBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
  }
  getClassName() {
    return "FrontFacingBlock";
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      throw "FrontFacingBlock must only be used in a fragment shader";
    }
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = gl_FrontFacing ? 1.0 : 0.0;\r
`;
    return this;
  }
};
RegisterClass("BABYLON.FrontFacingBlock", FrontFacingBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/derivativeBlock.js
var DerivativeBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);
    this.registerOutput("dx", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this.registerOutput("dy", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._outputs[1]._typeConnectionSource = this._inputs[0];
  }
  getClassName() {
    return "DerivativeBlock";
  }
  get input() {
    return this._inputs[0];
  }
  get dx() {
    return this._outputs[0];
  }
  get dy() {
    return this._outputs[1];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const dx = this._outputs[0];
    const dy = this._outputs[1];
    state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    if (dx.hasEndpoints) {
      state.compilationString += this._declareOutput(dx, state) + ` = dFdx(${this.input.associatedVariableName});\r
`;
    }
    if (dy.hasEndpoints) {
      state.compilationString += this._declareOutput(dy, state) + ` = dFdy(${this.input.associatedVariableName});\r
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.DerivativeBlock", DerivativeBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/fragCoordBlock.js
var FragCoordBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("xyzw", NodeMaterialBlockConnectionPointTypes.Vector4, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("z", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("w", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
  }
  getClassName() {
    return "FragCoordBlock";
  }
  get xy() {
    return this._outputs[0];
  }
  get xyz() {
    return this._outputs[1];
  }
  get xyzw() {
    return this._outputs[2];
  }
  get x() {
    return this._outputs[3];
  }
  get y() {
    return this._outputs[4];
  }
  get z() {
    return this._outputs[5];
  }
  get output() {
    return this._outputs[6];
  }
  writeOutputs(state) {
    let code = "";
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        code += `${this._declareOutput(output, state)} = gl_FragCoord.${output.name};\r
`;
      }
    }
    return code;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      throw "FragCoordBlock must only be used in a fragment shader";
    }
    state.compilationString += this.writeOutputs(state);
    return this;
  }
};
RegisterClass("BABYLON.FragCoordBlock", FragCoordBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/screenSizeBlock.js
var ScreenSizeBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
  }
  getClassName() {
    return "ScreenSizeBlock";
  }
  get xy() {
    return this._outputs[0];
  }
  get x() {
    return this._outputs[1];
  }
  get y() {
    return this._outputs[2];
  }
  bind(effect) {
    const engine = this._scene.getEngine();
    effect.setFloat2(this._varName, engine.getRenderWidth(), engine.getRenderHeight());
  }
  writeOutputs(state, varName) {
    let code = "";
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        code += `${this._declareOutput(output, state)} = ${varName}.${output.name};\r
`;
      }
    }
    return code;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this._scene = state.sharedData.scene;
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      throw "ScreenSizeBlock must only be used in a fragment shader";
    }
    state.sharedData.bindableBlocks.push(this);
    this._varName = state._getFreeVariableName("screenSize");
    state._emitUniformFromString(this._varName, "vec2");
    state.compilationString += this.writeOutputs(state, this._varName);
    return this;
  }
};
RegisterClass("BABYLON.ScreenSizeBlock", ScreenSizeBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/screenSpaceBlock.js
var ScreenSpaceBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this.registerInput("vector", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("worldViewProjection", NodeMaterialBlockConnectionPointTypes.Matrix);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float);
    this.inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  getClassName() {
    return "ScreenSpaceBlock";
  }
  get vector() {
    return this._inputs[0];
  }
  get worldViewProjection() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  get x() {
    return this._outputs[1];
  }
  get y() {
    return this._outputs[2];
  }
  autoConfigure(material) {
    if (!this.worldViewProjection.isConnected) {
      let worldViewProjectionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.WorldViewProjection);
      if (!worldViewProjectionInput) {
        worldViewProjectionInput = new InputBlock("worldViewProjection");
        worldViewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.WorldViewProjection);
      }
      worldViewProjectionInput.output.connectTo(this.worldViewProjection);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const vector = this.vector;
    const worldViewProjection = this.worldViewProjection;
    if (!vector.connectedPoint) {
      return;
    }
    const worldViewProjectionName = worldViewProjection.associatedVariableName;
    const tempVariableName = state._getFreeVariableName("screenSpaceTemp");
    switch (vector.connectedPoint.type) {
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        state.compilationString += `vec4 ${tempVariableName} = ${worldViewProjectionName} * vec4(${vector.associatedVariableName}, 1.0);\r
`;
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        state.compilationString += `vec4 ${tempVariableName} = ${worldViewProjectionName} * ${vector.associatedVariableName};\r
`;
        break;
    }
    state.compilationString += `${tempVariableName}.xy /= ${tempVariableName}.w;`;
    state.compilationString += `${tempVariableName}.xy = ${tempVariableName}.xy * 0.5 + vec2(0.5, 0.5);`;
    if (this.output.hasEndpoints) {
      state.compilationString += this._declareOutput(this.output, state) + ` = ${tempVariableName}.xy;\r
`;
    }
    if (this.x.hasEndpoints) {
      state.compilationString += this._declareOutput(this.x, state) + ` = ${tempVariableName}.x;\r
`;
    }
    if (this.y.hasEndpoints) {
      state.compilationString += this._declareOutput(this.y, state) + ` = ${tempVariableName}.y;\r
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.ScreenSpaceBlock", ScreenSpaceBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/twirlBlock.js
var TwirlBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerInput("strength", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("center", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerInput("offset", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float);
  }
  getClassName() {
    return "TwirlBlock";
  }
  get input() {
    return this._inputs[0];
  }
  get strength() {
    return this._inputs[1];
  }
  get center() {
    return this._inputs[2];
  }
  get offset() {
    return this._inputs[3];
  }
  get output() {
    return this._outputs[0];
  }
  get x() {
    return this._outputs[1];
  }
  get y() {
    return this._outputs[2];
  }
  autoConfigure() {
    if (!this.center.isConnected) {
      const centerInput = new InputBlock("center");
      centerInput.value = new Vector2(0.5, 0.5);
      centerInput.output.connectTo(this.center);
    }
    if (!this.strength.isConnected) {
      const strengthInput = new InputBlock("strength");
      strengthInput.value = 1;
      strengthInput.output.connectTo(this.strength);
    }
    if (!this.offset.isConnected) {
      const offsetInput = new InputBlock("offset");
      offsetInput.value = new Vector2(0, 0);
      offsetInput.output.connectTo(this.offset);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const tempDelta = state._getFreeVariableName("delta");
    const tempAngle = state._getFreeVariableName("angle");
    const tempX = state._getFreeVariableName("x");
    const tempY = state._getFreeVariableName("y");
    const tempResult = state._getFreeVariableName("result");
    state.compilationString += `
            vec2 ${tempDelta} = ${this.input.associatedVariableName} - ${this.center.associatedVariableName};
            float ${tempAngle} = ${this.strength.associatedVariableName} * length(${tempDelta});
            float ${tempX} = cos(${tempAngle}) * ${tempDelta}.x - sin(${tempAngle}) * ${tempDelta}.y;
            float ${tempY} = sin(${tempAngle}) * ${tempDelta}.x + cos(${tempAngle}) * ${tempDelta}.y;
            vec2 ${tempResult} = vec2(${tempX} + ${this.center.associatedVariableName}.x + ${this.offset.associatedVariableName}.x, ${tempY} + ${this.center.associatedVariableName}.y + ${this.offset.associatedVariableName}.y);
        `;
    if (this.output.hasEndpoints) {
      state.compilationString += this._declareOutput(this.output, state) + ` = ${tempResult};\r
`;
    }
    if (this.x.hasEndpoints) {
      state.compilationString += this._declareOutput(this.x, state) + ` = ${tempResult}.x;\r
`;
    }
    if (this.y.hasEndpoints) {
      state.compilationString += this._declareOutput(this.y, state) + ` = ${tempResult}.y;\r
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.TwirlBlock", TwirlBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/heightToNormalBlock.js
var HeightToNormalBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this.generateInWorldSpace = false;
    this.automaticNormalizationNormal = true;
    this.automaticNormalizationTangent = true;
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("worldTangent", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
    this._inputs[3].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  getClassName() {
    return "HeightToNormalBlock";
  }
  get input() {
    return this._inputs[0];
  }
  get worldPosition() {
    return this._inputs[1];
  }
  get worldNormal() {
    return this._inputs[2];
  }
  get worldTangent() {
    return this._inputs[3];
  }
  get output() {
    return this._outputs[0];
  }
  get xyz() {
    return this._outputs[1];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    if (!this.generateInWorldSpace && !this.worldTangent.isConnected) {
      console.error(`You must connect the 'worldTangent' input of the ${this.name} block!`);
    }
    const startCode = this.generateInWorldSpace ? "" : `
            vec3 biTangent = cross(normal, tangent);
            mat3 TBN = mat3(tangent, biTangent, normal);
            `;
    const endCode = this.generateInWorldSpace ? "" : `
            result = TBN * result;
            result = result * vec3(0.5) + vec3(0.5);
            `;
    const heightToNormal = `
            vec4 heightToNormal(in float height, in vec3 position, in vec3 tangent, in vec3 normal) {
                ${startCode}
                ${this.automaticNormalizationTangent ? "tangent = normalize(tangent);" : ""}
                ${this.automaticNormalizationNormal ? "normal = normalize(normal);" : ""}
                vec3 worlddX = dFdx(position);
                vec3 worlddY = dFdy(position);
                vec3 crossX = cross(normal, worlddX);
                vec3 crossY = cross(normal, worlddY);
                float d = abs(dot(crossY, worlddX));
                vec3 inToNormal = vec3(((((height + dFdx(height)) - height) * crossY) + (((height + dFdy(height)) - height) * crossX)) * sign(d));
                inToNormal.y *= -1.0;
                vec3 result = normalize((d * normal) - inToNormal);
                ${endCode}
                return vec4(result, 0.);
            }`;
    state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    state._emitFunction("heightToNormal", heightToNormal, "// heightToNormal");
    state.compilationString += this._declareOutput(output, state) + ` = heightToNormal(${this.input.associatedVariableName}, ${this.worldPosition.associatedVariableName}, ${this.worldTangent.isConnected ? this.worldTangent.associatedVariableName : "vec3(0.)"}.xyz, ${this.worldNormal.associatedVariableName});\r
`;
    if (this.xyz.hasEndpoints) {
      state.compilationString += this._declareOutput(this.xyz, state) + ` = ${this.output.associatedVariableName}.xyz;\r
`;
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.generateInWorldSpace = ${this.generateInWorldSpace};\r
`;
    codeString += `${this._codeVariableName}.automaticNormalizationNormal = ${this.automaticNormalizationNormal};\r
`;
    codeString += `${this._codeVariableName}.automaticNormalizationTangent = ${this.automaticNormalizationTangent};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.generateInWorldSpace = this.generateInWorldSpace;
    serializationObject.automaticNormalizationNormal = this.automaticNormalizationNormal;
    serializationObject.automaticNormalizationTangent = this.automaticNormalizationTangent;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.generateInWorldSpace = serializationObject.generateInWorldSpace;
    this.automaticNormalizationNormal = serializationObject.automaticNormalizationNormal;
    this.automaticNormalizationTangent = serializationObject.automaticNormalizationTangent;
  }
};
__decorate([
  editableInPropertyPage("Generate in world space instead of tangent space", PropertyTypeForEdition.Boolean, "PROPERTIES", { notifiers: { update: true } })
], HeightToNormalBlock.prototype, "generateInWorldSpace", void 0);
__decorate([
  editableInPropertyPage("Force normalization for the worldNormal input", PropertyTypeForEdition.Boolean, "PROPERTIES", { notifiers: { update: true } })
], HeightToNormalBlock.prototype, "automaticNormalizationNormal", void 0);
__decorate([
  editableInPropertyPage("Force normalization for the worldTangent input", PropertyTypeForEdition.Boolean, "PROPERTIES", { notifiers: { update: true } })
], HeightToNormalBlock.prototype, "automaticNormalizationTangent", void 0);
RegisterClass("BABYLON.HeightToNormalBlock", HeightToNormalBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/fragDepthBlock.js
var FragDepthBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment, true);
    this.registerInput("depth", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("worldPos", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("viewProjection", NodeMaterialBlockConnectionPointTypes.Matrix, true);
  }
  getClassName() {
    return "FragDepthBlock";
  }
  get depth() {
    return this._inputs[0];
  }
  get worldPos() {
    return this._inputs[1];
  }
  get viewProjection() {
    return this._inputs[2];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (this.depth.isConnected) {
      state.compilationString += `gl_FragDepth = ${this.depth.associatedVariableName};\r
`;
    } else if (this.worldPos.isConnected && this.viewProjection.isConnected) {
      state.compilationString += `
                vec4 p = ${this.viewProjection.associatedVariableName} * ${this.worldPos.associatedVariableName};
                float v = p.z / p.w;
                #ifndef IS_NDC_HALF_ZRANGE
                    v = v * 0.5 + 0.5;
                #endif
                gl_FragDepth = v;
    
            `;
    } else {
      console.warn("FragDepthBlock: either the depth input or both the worldPos and viewProjection inputs must be connected!");
    }
    return this;
  }
};
RegisterClass("BABYLON.FragDepthBlock", FragDepthBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/shadowMapBlock.js
var ShadowMapBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false);
    this.registerInput("viewProjection", NodeMaterialBlockConnectionPointTypes.Matrix, false);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerOutput("depth", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.worldNormal.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  getClassName() {
    return "ShadowMapBlock";
  }
  initialize(state) {
    state._excludeVariableName("vPositionWSM");
    state._excludeVariableName("lightDataSM");
    state._excludeVariableName("biasAndScaleSM");
    state._excludeVariableName("depthValuesSM");
    state._excludeVariableName("clipPos");
    state._excludeVariableName("worldPos");
    state._excludeVariableName("zSM");
  }
  get worldPosition() {
    return this._inputs[0];
  }
  get viewProjection() {
    return this._inputs[1];
  }
  get worldNormal() {
    return this._inputs[2];
  }
  get depth() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const comments = `//${this.name}`;
    state._emitUniformFromString("biasAndScaleSM", "vec3");
    state._emitUniformFromString("lightDataSM", "vec3");
    state._emitUniformFromString("depthValuesSM", "vec2");
    state._emitFunctionFromInclude("packingFunctions", comments);
    state.compilationString += `vec4 worldPos = ${this.worldPosition.associatedVariableName};\r
`;
    state.compilationString += `vec3 vPositionWSM;\r
`;
    state.compilationString += `float vDepthMetricSM = 0.0;\r
`;
    state.compilationString += `float zSM;\r
`;
    if (this.worldNormal.isConnected) {
      state.compilationString += `vec3 vNormalW = ${this.worldNormal.associatedVariableName}.xyz;\r
`;
      state.compilationString += state._emitCodeFromInclude("shadowMapVertexNormalBias", comments);
    }
    state.compilationString += `vec4 clipPos = ${this.viewProjection.associatedVariableName} * worldPos;\r
`;
    state.compilationString += state._emitCodeFromInclude("shadowMapVertexMetric", comments, {
      replaceStrings: [
        {
          search: /gl_Position/g,
          replace: "clipPos"
        }
      ]
    });
    state.compilationString += state._emitCodeFromInclude("shadowMapFragment", comments, {
      replaceStrings: [
        {
          search: /return;/g,
          replace: ""
        }
      ]
    });
    state.compilationString += `
            #if SM_DEPTHTEXTURE == 1
                #ifdef IS_NDC_HALF_ZRANGE
                    gl_FragDepth = (clipPos.z / clipPos.w);
                #else
                    gl_FragDepth = (clipPos.z / clipPos.w) * 0.5 + 0.5;
                #endif
            #endif
        `;
    state.compilationString += `${this._declareOutput(this.depth, state)} = vec3(depthSM, 1., 1.);\r
`;
    return this;
  }
};
RegisterClass("BABYLON.ShadowMapBlock", ShadowMapBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/fogBlock.js
var FogBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.VertexAndFragment, false);
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("view", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("fogColor", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.input.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Color4);
    this.fogColor.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Color4);
  }
  getClassName() {
    return "FogBlock";
  }
  get worldPosition() {
    return this._inputs[0];
  }
  get view() {
    return this._inputs[1];
  }
  get input() {
    return this._inputs[2];
  }
  get fogColor() {
    return this._inputs[3];
  }
  get output() {
    return this._outputs[0];
  }
  autoConfigure(material) {
    if (!this.view.isConnected) {
      let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View);
      if (!viewInput) {
        viewInput = new InputBlock("view");
        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);
      }
      viewInput.output.connectTo(this.view);
    }
    if (!this.fogColor.isConnected) {
      let fogColorInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.FogColor);
      if (!fogColorInput) {
        fogColorInput = new InputBlock("fogColor", void 0, NodeMaterialBlockConnectionPointTypes.Color3);
        fogColorInput.setAsSystemValue(NodeMaterialSystemValues.FogColor);
      }
      fogColorInput.output.connectTo(this.fogColor);
    }
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    const scene = mesh.getScene();
    defines.setValue("FOG", nodeMaterial.fogEnabled && MaterialHelper.GetFogState(mesh, scene));
  }
  bind(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    const scene = mesh.getScene();
    effect.setFloat4(this._fogParameters, scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.blocksWithDefines.push(this);
      state.sharedData.bindableBlocks.push(this);
      state._emitFunctionFromInclude("fogFragmentDeclaration", `//${this.name}`, {
        removeUniforms: true,
        removeVaryings: true,
        removeIfDef: false,
        replaceStrings: [{ search: /float CalcFogFactor\(\)/, replace: "float CalcFogFactor(vec3 vFogDistance, vec4 vFogInfos)" }]
      });
      const tempFogVariablename = state._getFreeVariableName("fog");
      const color = this.input;
      const fogColor = this.fogColor;
      this._fogParameters = state._getFreeVariableName("fogParameters");
      const output = this._outputs[0];
      state._emitUniformFromString(this._fogParameters, "vec4");
      state.compilationString += `#ifdef FOG\r
`;
      state.compilationString += `float ${tempFogVariablename} = CalcFogFactor(${this._fogDistanceName}, ${this._fogParameters});\r
`;
      state.compilationString += this._declareOutput(output, state) + ` = ${tempFogVariablename} * ${color.associatedVariableName}.rgb + (1.0 - ${tempFogVariablename}) * ${fogColor.associatedVariableName}.rgb;\r
`;
      state.compilationString += `#else\r
${this._declareOutput(output, state)} =  ${color.associatedVariableName}.rgb;\r
`;
      state.compilationString += `#endif\r
`;
    } else {
      const worldPos = this.worldPosition;
      const view = this.view;
      this._fogDistanceName = state._getFreeVariableName("vFogDistance");
      state._emitVaryingFromString(this._fogDistanceName, "vec3");
      state.compilationString += `${this._fogDistanceName} = (${view.associatedVariableName} * ${worldPos.associatedVariableName}).xyz;\r
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.FogBlock", FogBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/lightBlock.js
var LightBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.VertexAndFragment);
    this._lightId = 0;
    this.generateOnlyFragmentCode = false;
    this._isUnique = true;
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("cameraPosition", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("glossiness", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("glossPower", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("diffuseColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("specularColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("view", NodeMaterialBlockConnectionPointTypes.Matrix, true);
    this.registerOutput("diffuseOutput", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("specularOutput", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("shadow", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
  }
  static _OnGenerateOnlyFragmentCodeChanged(block, _propertyName) {
    const that = block;
    if (that.worldPosition.isConnected) {
      that.generateOnlyFragmentCode = !that.generateOnlyFragmentCode;
      console.error("The worldPosition input must not be connected to be able to switch!");
      return false;
    }
    that._setTarget();
    return true;
  }
  _setTarget() {
    this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);
    this.getInputByName("worldPosition").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;
  }
  getClassName() {
    return "LightBlock";
  }
  get worldPosition() {
    return this._inputs[0];
  }
  get worldNormal() {
    return this._inputs[1];
  }
  get cameraPosition() {
    return this._inputs[2];
  }
  get glossiness() {
    return this._inputs[3];
  }
  get glossPower() {
    return this._inputs[4];
  }
  get diffuseColor() {
    return this._inputs[5];
  }
  get specularColor() {
    return this._inputs[6];
  }
  get view() {
    return this._inputs[7];
  }
  get diffuseOutput() {
    return this._outputs[0];
  }
  get specularOutput() {
    return this._outputs[1];
  }
  get shadow() {
    return this._outputs[2];
  }
  autoConfigure(material) {
    if (!this.cameraPosition.isConnected) {
      let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition);
      if (!cameraPositionInput) {
        cameraPositionInput = new InputBlock("cameraPosition");
        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);
      }
      cameraPositionInput.output.connectTo(this.cameraPosition);
    }
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    if (!defines._areLightsDirty) {
      return;
    }
    const scene = mesh.getScene();
    if (!this.light) {
      MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);
    } else {
      const state = {
        needNormals: false,
        needRebuild: false,
        lightmapMode: false,
        shadowEnabled: false,
        specularEnabled: false
      };
      MaterialHelper.PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);
      if (state.needRebuild) {
        defines.rebuild();
      }
    }
  }
  updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {
    for (let lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {
      if (!defines["LIGHT" + lightIndex]) {
        break;
      }
      const onlyUpdateBuffersList = state.uniforms.indexOf("vLightData" + lightIndex) >= 0;
      MaterialHelper.PrepareUniformsAndSamplersForLight(lightIndex, state.uniforms, state.samplers, defines["PROJECTEDLIGHTTEXTURE" + lightIndex], uniformBuffers, onlyUpdateBuffersList);
    }
  }
  bind(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    const scene = mesh.getScene();
    if (!this.light) {
      MaterialHelper.BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);
    } else {
      MaterialHelper.BindLight(this.light, this._lightId, scene, effect, true);
    }
  }
  _injectVertexCode(state) {
    const worldPos = this.worldPosition;
    const comments = `//${this.name}`;
    if (!this.light) {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightVxUboDeclaration" : "lightVxFragmentDeclaration", comments, {
        repeatKey: "maxSimultaneousLights"
      });
      this._lightId = 0;
      state.sharedData.dynamicUniformBlocks.push(this);
    } else {
      this._lightId = (state.counters["lightCounter"] !== void 0 ? state.counters["lightCounter"] : -1) + 1;
      state.counters["lightCounter"] = this._lightId;
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightVxUboDeclaration" : "lightVxFragmentDeclaration", comments, {
        replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]
      }, this._lightId.toString());
    }
    const worldPosVaryingName = "v_" + worldPos.associatedVariableName;
    if (state._emitVaryingFromString(worldPosVaryingName, "vec4")) {
      state.compilationString += `${worldPosVaryingName} = ${worldPos.associatedVariableName};\r
`;
    }
    if (this.light) {
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        replaceStrings: [
          { search: /{X}/g, replace: this._lightId.toString() },
          { search: /worldPos/g, replace: worldPos.associatedVariableName }
        ]
      });
    } else {
      state.compilationString += `vec4 worldPos = ${worldPos.associatedVariableName};\r
`;
      if (this.view.isConnected) {
        state.compilationString += `mat4 view = ${this.view.associatedVariableName};\r
`;
      }
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        repeatKey: "maxSimultaneousLights"
      });
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      this._injectVertexCode(state);
      return;
    }
    if (this.generateOnlyFragmentCode) {
      state.sharedData.dynamicUniformBlocks.push(this);
    }
    state.sharedData.forcedBindableBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    const comments = `//${this.name}`;
    const worldPos = this.worldPosition;
    let worldPosVariableName = worldPos.associatedVariableName;
    if (this.generateOnlyFragmentCode) {
      worldPosVariableName = state._getFreeVariableName("globalWorldPos");
      state._emitFunction("light_globalworldpos", `vec3 ${worldPosVariableName};\r
`, comments);
      state.compilationString += `${worldPosVariableName} = ${worldPos.associatedVariableName}.xyz;\r
`;
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        repeatKey: "maxSimultaneousLights",
        substitutionVars: this.generateOnlyFragmentCode ? `worldPos,${worldPos.associatedVariableName}` : void 0
      });
    } else {
      worldPosVariableName = "v_" + worldPosVariableName + ".xyz";
    }
    state._emitFunctionFromInclude("helperFunctions", comments);
    state._emitFunctionFromInclude("lightsFragmentFunctions", comments, {
      replaceStrings: [{ search: /vPositionW/g, replace: worldPosVariableName }]
    });
    state._emitFunctionFromInclude("shadowsFragmentFunctions", comments, {
      replaceStrings: [{ search: /vPositionW/g, replace: worldPosVariableName }]
    });
    if (!this.light) {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        repeatKey: "maxSimultaneousLights",
        substitutionVars: this.generateOnlyFragmentCode ? "varying," : void 0
      });
    } else {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]
      }, this._lightId.toString());
    }
    if (this._lightId === 0) {
      if (state._registerTempVariable("viewDirectionW")) {
        state.compilationString += `vec3 viewDirectionW = normalize(${this.cameraPosition.associatedVariableName} - ${worldPosVariableName});\r
`;
      }
      state.compilationString += `lightingInfo info;\r
`;
      state.compilationString += `float shadow = 1.;\r
`;
      state.compilationString += `float glossiness = ${this.glossiness.isConnected ? this.glossiness.associatedVariableName : "1.0"} * ${this.glossPower.isConnected ? this.glossPower.associatedVariableName : "1024.0"};\r
`;
      state.compilationString += `vec3 diffuseBase = vec3(0., 0., 0.);\r
`;
      state.compilationString += `vec3 specularBase = vec3(0., 0., 0.);\r
`;
      state.compilationString += `vec3 normalW = ${this.worldNormal.associatedVariableName}.xyz;\r
`;
    }
    if (this.light) {
      state.compilationString += state._emitCodeFromInclude("lightFragment", comments, {
        replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]
      });
    } else {
      state.compilationString += state._emitCodeFromInclude("lightFragment", comments, {
        repeatKey: "maxSimultaneousLights"
      });
    }
    const diffuseOutput = this.diffuseOutput;
    const specularOutput = this.specularOutput;
    state.compilationString += this._declareOutput(diffuseOutput, state) + ` = diffuseBase${this.diffuseColor.isConnected ? " * " + this.diffuseColor.associatedVariableName : ""};\r
`;
    if (specularOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(specularOutput, state) + ` = specularBase${this.specularColor.isConnected ? " * " + this.specularColor.associatedVariableName : ""};\r
`;
    }
    if (this.shadow.hasEndpoints) {
      state.compilationString += this._declareOutput(this.shadow, state) + ` = shadow;\r
`;
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;
    if (this.light) {
      serializationObject.lightId = this.light.id;
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    if (serializationObject.lightId) {
      this.light = scene.getLightById(serializationObject.lightId);
    }
    this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;
    this._setTarget();
  }
};
__decorate([
  editableInPropertyPage("Generate only fragment code", PropertyTypeForEdition.Boolean, "ADVANCED", {
    notifiers: { rebuild: true, update: true, onValidation: LightBlock._OnGenerateOnlyFragmentCodeChanged }
  })
], LightBlock.prototype, "generateOnlyFragmentCode", void 0);
RegisterClass("BABYLON.LightBlock", LightBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/imageSourceBlock.js
var ImageSourceBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.VertexAndFragment);
    this.registerOutput("source", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("source", this, NodeMaterialConnectionPointDirection.Output, ImageSourceBlock, "ImageSourceBlock"));
  }
  get texture() {
    return this._texture;
  }
  set texture(texture) {
    var _a;
    if (this._texture === texture) {
      return;
    }
    const scene = (_a = texture === null || texture === void 0 ? void 0 : texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;
    if (!texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this._texture);
      });
    }
    this._texture = texture;
    if (texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(texture);
      });
    }
  }
  get samplerName() {
    return this._samplerName;
  }
  bind(effect) {
    if (!this.texture) {
      return;
    }
    effect.setTexture(this._samplerName, this.texture);
  }
  isReady() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  getClassName() {
    return "ImageSourceBlock";
  }
  get source() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      this._samplerName = state._getFreeVariableName(this.name + "Sampler");
      state.sharedData.blockingBlocks.push(this);
      state.sharedData.textureBlocks.push(this);
      state.sharedData.bindableBlocks.push(this);
    }
    state._emit2DSampler(this._samplerName);
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    if (!this.texture) {
      return codeString;
    }
    codeString += `${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\r
`;
    codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\r
`;
    codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\r
`;
    codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\r
`;
    codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\r
`;
    codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\r
`;
    codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\r
`;
    codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\r
`;
    codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\r
`;
    codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\r
`;
    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    if (this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== "VideoTexture") {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== void 0) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
    }
  }
};
RegisterClass("BABYLON.ImageSourceBlock", ImageSourceBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/textureBlock.js
var TextureBlock = class extends NodeMaterialBlock {
  constructor(name137, fragmentOnly = false) {
    super(name137, fragmentOnly ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);
    this._convertToGammaSpace = false;
    this._convertToLinearSpace = false;
    this.disableLevelMultiplication = false;
    this._fragmentOnly = fragmentOnly;
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);
    this.registerInput("source", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("source", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, "ImageSourceBlock"));
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("level", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this._inputs[0]._prioritizeVertex = !fragmentOnly;
  }
  get texture() {
    var _a;
    if (this.source.isConnected) {
      return ((_a = this.source.connectedPoint) === null || _a === void 0 ? void 0 : _a.ownerBlock).texture;
    }
    return this._texture;
  }
  set texture(texture) {
    var _a;
    if (this._texture === texture) {
      return;
    }
    const scene = (_a = texture === null || texture === void 0 ? void 0 : texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;
    if (!texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this._texture);
      });
    }
    this._texture = texture;
    if (texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(texture);
      });
    }
  }
  get samplerName() {
    if (this._imageSource) {
      return this._imageSource.samplerName;
    }
    return this._samplerName;
  }
  get hasImageSource() {
    return this.source.isConnected;
  }
  set convertToGammaSpace(value) {
    var _a;
    if (value === this._convertToGammaSpace) {
      return;
    }
    this._convertToGammaSpace = value;
    if (this.texture) {
      const scene = (_a = this.texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;
      scene === null || scene === void 0 ? void 0 : scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this.texture);
      });
    }
  }
  get convertToGammaSpace() {
    return this._convertToGammaSpace;
  }
  set convertToLinearSpace(value) {
    var _a;
    if (value === this._convertToLinearSpace) {
      return;
    }
    this._convertToLinearSpace = value;
    if (this.texture) {
      const scene = (_a = this.texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;
      scene === null || scene === void 0 ? void 0 : scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this.texture);
      });
    }
  }
  get convertToLinearSpace() {
    return this._convertToLinearSpace;
  }
  getClassName() {
    return "TextureBlock";
  }
  get uv() {
    return this._inputs[0];
  }
  get source() {
    return this._inputs[1];
  }
  get rgba() {
    return this._outputs[0];
  }
  get rgb() {
    return this._outputs[1];
  }
  get r() {
    return this._outputs[2];
  }
  get g() {
    return this._outputs[3];
  }
  get b() {
    return this._outputs[4];
  }
  get a() {
    return this._outputs[5];
  }
  get level() {
    return this._outputs[6];
  }
  get target() {
    if (this._fragmentOnly) {
      return NodeMaterialBlockTargets.Fragment;
    }
    if (!this.uv.isConnected) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    if (this.uv.sourceBlock.isInput) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    let parent = this.uv.connectedPoint;
    while (parent) {
      if (parent.target === NodeMaterialBlockTargets.Fragment) {
        return NodeMaterialBlockTargets.Fragment;
      }
      if (parent.target === NodeMaterialBlockTargets.Vertex) {
        return NodeMaterialBlockTargets.VertexAndFragment;
      }
      if (parent.target === NodeMaterialBlockTargets.Neutral || parent.target === NodeMaterialBlockTargets.VertexAndFragment) {
        const parentBlock = parent.ownerBlock;
        if (parentBlock.target === NodeMaterialBlockTargets.Fragment) {
          return NodeMaterialBlockTargets.Fragment;
        }
        parent = null;
        for (const input of parentBlock.inputs) {
          if (input.connectedPoint) {
            parent = input.connectedPoint;
            break;
          }
        }
      }
    }
    return NodeMaterialBlockTargets.VertexAndFragment;
  }
  set target(value) {
  }
  autoConfigure(material) {
    if (!this.uv.isConnected) {
      if (material.mode === NodeMaterialModes.PostProcess) {
        const uvInput = material.getBlockByPredicate((b) => b.name === "uv");
        if (uvInput) {
          uvInput.connectTo(this);
        }
      } else {
        const attributeName = material.mode === NodeMaterialModes.Particle ? "particle_uv" : "uv";
        let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === attributeName);
        if (!uvInput) {
          uvInput = new InputBlock("uv");
          uvInput.setAsAttribute(attributeName);
        }
        uvInput.output.connectTo(this.uv);
      }
    }
  }
  initializeDefines(mesh, nodeMaterial, defines) {
    if (!defines._areTexturesDirty) {
      return;
    }
    if (this._mainUVDefineName !== void 0) {
      defines.setValue(this._mainUVDefineName, false, true);
    }
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    if (!defines._areTexturesDirty) {
      return;
    }
    if (!this.texture || !this.texture.getTextureMatrix) {
      if (this._isMixed) {
        defines.setValue(this._defineName, false, true);
        defines.setValue(this._mainUVDefineName, true, true);
      }
      return;
    }
    const toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;
    const toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace;
    defines.setValue(this._linearDefineName, toGamma, true);
    defines.setValue(this._gammaDefineName, toLinear, true);
    if (this._isMixed) {
      if (!this.texture.getTextureMatrix().isIdentityAs3x2()) {
        defines.setValue(this._defineName, true);
        if (defines[this._mainUVDefineName] == void 0) {
          defines.setValue(this._mainUVDefineName, false, true);
        }
      } else {
        defines.setValue(this._defineName, false, true);
        defines.setValue(this._mainUVDefineName, true, true);
      }
    }
  }
  isReady() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  bind(effect) {
    if (!this.texture) {
      return;
    }
    if (this._isMixed) {
      effect.setFloat(this._textureInfoName, this.texture.level);
      effect.setMatrix(this._textureTransformName, this.texture.getTextureMatrix());
    }
    if (!this._imageSource) {
      effect.setTexture(this._samplerName, this.texture);
    }
  }
  get _isMixed() {
    return this.target !== NodeMaterialBlockTargets.Fragment;
  }
  _injectVertexCode(state) {
    const uvInput = this.uv;
    this._defineName = state._getFreeDefineName("UVTRANSFORM");
    this._mainUVDefineName = "VMAIN" + uvInput.associatedVariableName.toUpperCase();
    this._mainUVName = "vMain" + uvInput.associatedVariableName;
    this._transformedUVName = state._getFreeVariableName("transformedUV");
    this._textureTransformName = state._getFreeVariableName("textureTransform");
    this._textureInfoName = state._getFreeVariableName("textureInfoName");
    this.level.associatedVariableName = this._textureInfoName;
    state._emitVaryingFromString(this._transformedUVName, "vec2", this._defineName);
    state._emitVaryingFromString(this._mainUVName, "vec2", this._mainUVDefineName);
    state._emitUniformFromString(this._textureTransformName, "mat4", this._defineName);
    state.compilationString += `#ifdef ${this._defineName}\r
`;
    state.compilationString += `${this._transformedUVName} = vec2(${this._textureTransformName} * vec4(${uvInput.associatedVariableName}.xy, 1.0, 0.0));\r
`;
    state.compilationString += `#elif defined(${this._mainUVDefineName})\r
`;
    state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\r
`;
    state.compilationString += `#endif\r
`;
    if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {
      return;
    }
    this._writeTextureRead(state, true);
    for (const output of this._outputs) {
      if (output.hasEndpoints && output.name !== "level") {
        this._writeOutput(state, output, output.name, true);
      }
    }
  }
  _generateTextureLookup(state) {
    const samplerName = this.samplerName;
    state.compilationString += `#ifdef ${this._defineName}\r
`;
    state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${samplerName}, ${this._transformedUVName});\r
`;
    state.compilationString += `#elif defined(${this._mainUVDefineName})\r
`;
    state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${samplerName}, ${this._mainUVName ? this._mainUVName : this.uv.associatedVariableName});\r
`;
    state.compilationString += `#endif\r
`;
  }
  _writeTextureRead(state, vertexMode = false) {
    const uvInput = this.uv;
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      this._generateTextureLookup(state);
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this.samplerName}, ${uvInput.associatedVariableName});\r
`;
      return;
    }
    this._generateTextureLookup(state);
  }
  _generateConversionCode(state, output, swizzle) {
    if (swizzle !== "a") {
      if (!this.texture || !this.texture.gammaSpace) {
        state.compilationString += `#ifdef ${this._linearDefineName}
                    ${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});
                    #endif
                `;
      }
      state.compilationString += `#ifdef ${this._gammaDefineName}
                ${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});
                #endif
            `;
    }
  }
  _writeOutput(state, output, swizzle, vertexMode = false) {
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\r
`;
      this._generateConversionCode(state, output, swizzle);
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\r
`;
      this._generateConversionCode(state, output, swizzle);
      return;
    }
    let complement = "";
    if (!this.disableLevelMultiplication) {
      complement = ` * ${this._textureInfoName}`;
    }
    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle}${complement};\r
`;
    this._generateConversionCode(state, output, swizzle);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (this.source.isConnected) {
      this._imageSource = this.source.connectedPoint.ownerBlock;
    } else {
      this._imageSource = null;
    }
    if (state.target === NodeMaterialBlockTargets.Vertex || this._fragmentOnly || state.target === NodeMaterialBlockTargets.Fragment) {
      this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
      this._linearDefineName = state._getFreeDefineName("ISLINEAR");
      this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
    }
    if (!this._isMixed && state.target === NodeMaterialBlockTargets.Fragment || this._isMixed && state.target === NodeMaterialBlockTargets.Vertex) {
      if (!this._imageSource) {
        this._samplerName = state._getFreeVariableName(this.name + "Sampler");
        state._emit2DSampler(this._samplerName);
      }
      state.sharedData.blockingBlocks.push(this);
      state.sharedData.textureBlocks.push(this);
      state.sharedData.blocksWithDefines.push(this);
      state.sharedData.bindableBlocks.push(this);
    }
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      this._injectVertexCode(state);
      return;
    }
    if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {
      return;
    }
    if (this._isMixed && !this._imageSource) {
      state._emit2DSampler(this._samplerName);
    }
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    if (this._isMixed) {
      state._emitUniformFromString(this._textureInfoName, "float");
    }
    this._writeTextureRead(state);
    for (const output of this._outputs) {
      if (output.hasEndpoints && output.name !== "level") {
        this._writeOutput(state, output, output.name);
      }
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\r
`;
    codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\r
`;
    codeString += `${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};\r
`;
    if (!this.texture) {
      return codeString;
    }
    codeString += `${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\r
`;
    codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\r
`;
    codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\r
`;
    codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\r
`;
    codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\r
`;
    codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\r
`;
    codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\r
`;
    codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\r
`;
    codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\r
`;
    codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\r
`;
    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    serializationObject.fragmentOnly = this._fragmentOnly;
    serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;
    if (!this.hasImageSource && this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== "VideoTexture") {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    this._fragmentOnly = !!serializationObject.fragmentOnly;
    this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;
    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== void 0) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
    }
  }
};
RegisterClass("BABYLON.TextureBlock", TextureBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/reflectionTextureBaseBlock.js
var ReflectionTextureBaseBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.VertexAndFragment);
    this.generateOnlyFragmentCode = false;
  }
  get texture() {
    return this._texture;
  }
  set texture(texture) {
    var _a;
    if (this._texture === texture) {
      return;
    }
    const scene = (_a = texture === null || texture === void 0 ? void 0 : texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;
    if (!texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this._texture);
      });
    }
    this._texture = texture;
    if (texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(texture);
      });
    }
  }
  static _OnGenerateOnlyFragmentCodeChanged(block, _propertyName) {
    const that = block;
    return that._onGenerateOnlyFragmentCodeChanged();
  }
  _onGenerateOnlyFragmentCodeChanged() {
    this._setTarget();
    return true;
  }
  _setTarget() {
    this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);
  }
  getClassName() {
    return "ReflectionTextureBaseBlock";
  }
  _getTexture() {
    return this.texture;
  }
  autoConfigure(material) {
    if (!this.position.isConnected) {
      let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "position");
      if (!positionInput) {
        positionInput = new InputBlock("position");
        positionInput.setAsAttribute();
      }
      positionInput.output.connectTo(this.position);
    }
    if (!this.world.isConnected) {
      let worldInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.World);
      if (!worldInput) {
        worldInput = new InputBlock("world");
        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
      }
      worldInput.output.connectTo(this.world);
    }
    if (this.view && !this.view.isConnected) {
      let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View);
      if (!viewInput) {
        viewInput = new InputBlock("view");
        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);
      }
      viewInput.output.connectTo(this.view);
    }
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    if (!defines._areTexturesDirty) {
      return;
    }
    const texture = this._getTexture();
    if (!texture || !texture.getTextureMatrix) {
      return;
    }
    defines.setValue(this._define3DName, texture.isCube, true);
    defines.setValue(this._defineLocalCubicName, texture.boundingBoxSize ? true : false, true);
    defines.setValue(this._defineExplicitName, texture.coordinatesMode === 0, true);
    defines.setValue(this._defineSkyboxName, texture.coordinatesMode === 5, true);
    defines.setValue(this._defineCubicName, texture.coordinatesMode === 3 || texture.coordinatesMode === 6, true);
    defines.setValue("INVERTCUBICMAP", texture.coordinatesMode === 6, true);
    defines.setValue(this._defineSphericalName, texture.coordinatesMode === 1, true);
    defines.setValue(this._definePlanarName, texture.coordinatesMode === 2, true);
    defines.setValue(this._defineProjectionName, texture.coordinatesMode === 4, true);
    defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === 7, true);
    defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === 8, true);
    defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === 9, true);
  }
  isReady() {
    const texture = this._getTexture();
    if (texture && !texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  bind(effect, nodeMaterial, mesh) {
    const texture = this._getTexture();
    if (!mesh || !texture) {
      return;
    }
    effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());
    if (texture.isCube) {
      effect.setTexture(this._cubeSamplerName, texture);
    } else {
      effect.setTexture(this._2DSamplerName, texture);
    }
    if (texture.boundingBoxSize) {
      const cubeTexture = texture;
      effect.setVector3(this._reflectionPositionName, cubeTexture.boundingBoxPosition);
      effect.setVector3(this._reflectionSizeName, cubeTexture.boundingBoxSize);
    }
  }
  handleVertexSide(state) {
    if (this.generateOnlyFragmentCode && state.target === NodeMaterialBlockTargets.Vertex) {
      return "";
    }
    this._define3DName = state._getFreeDefineName("REFLECTIONMAP_3D");
    this._defineCubicName = state._getFreeDefineName("REFLECTIONMAP_CUBIC");
    this._defineSphericalName = state._getFreeDefineName("REFLECTIONMAP_SPHERICAL");
    this._definePlanarName = state._getFreeDefineName("REFLECTIONMAP_PLANAR");
    this._defineProjectionName = state._getFreeDefineName("REFLECTIONMAP_PROJECTION");
    this._defineExplicitName = state._getFreeDefineName("REFLECTIONMAP_EXPLICIT");
    this._defineEquirectangularName = state._getFreeDefineName("REFLECTIONMAP_EQUIRECTANGULAR");
    this._defineLocalCubicName = state._getFreeDefineName("USE_LOCAL_REFLECTIONMAP_CUBIC");
    this._defineMirroredEquirectangularFixedName = state._getFreeDefineName("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");
    this._defineEquirectangularFixedName = state._getFreeDefineName("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");
    this._defineSkyboxName = state._getFreeDefineName("REFLECTIONMAP_SKYBOX");
    this._defineOppositeZ = state._getFreeDefineName("REFLECTIONMAP_OPPOSITEZ");
    this._reflectionMatrixName = state._getFreeVariableName("reflectionMatrix");
    state._emitUniformFromString(this._reflectionMatrixName, "mat4");
    let code = "";
    this._worldPositionNameInFragmentOnlyMode = state._getFreeVariableName("worldPosition");
    const worldPosVaryingName = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : "v_" + this.worldPosition.associatedVariableName;
    if (this.generateOnlyFragmentCode || state._emitVaryingFromString(worldPosVaryingName, "vec4")) {
      code += `${this.generateOnlyFragmentCode ? "vec4 " : ""}${worldPosVaryingName} = ${this.worldPosition.associatedVariableName};\r
`;
    }
    this._positionUVWName = state._getFreeVariableName("positionUVW");
    this._directionWName = state._getFreeVariableName("directionW");
    if (this.generateOnlyFragmentCode || state._emitVaryingFromString(this._positionUVWName, "vec3", this._defineSkyboxName)) {
      code += `#ifdef ${this._defineSkyboxName}\r
`;
      code += `${this.generateOnlyFragmentCode ? "vec3 " : ""}${this._positionUVWName} = ${this.position.associatedVariableName}.xyz;\r
`;
      code += `#endif\r
`;
    }
    if (this.generateOnlyFragmentCode || state._emitVaryingFromString(this._directionWName, "vec3", `defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})`)) {
      code += `#if defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})\r
`;
      code += `${this.generateOnlyFragmentCode ? "vec3 " : ""}${this._directionWName} = normalize(vec3(${this.world.associatedVariableName} * vec4(${this.position.associatedVariableName}.xyz, 0.0)));\r
`;
      code += `#endif\r
`;
    }
    return code;
  }
  handleFragmentSideInits(state) {
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.textureBlocks.push(this);
    this._cubeSamplerName = state._getFreeVariableName(this.name + "CubeSampler");
    state.samplers.push(this._cubeSamplerName);
    this._2DSamplerName = state._getFreeVariableName(this.name + "2DSampler");
    state.samplers.push(this._2DSamplerName);
    state._samplerDeclaration += `#ifdef ${this._define3DName}\r
`;
    state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\r
`;
    state._samplerDeclaration += `#else\r
`;
    state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\r
`;
    state._samplerDeclaration += `#endif\r
`;
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.bindableBlocks.push(this);
    const comments = `//${this.name}`;
    state._emitFunction("ReciprocalPI", "#define RECIPROCAL_PI2 0.15915494", "");
    state._emitFunctionFromInclude("helperFunctions", comments);
    state._emitFunctionFromInclude("reflectionFunction", comments, {
      replaceStrings: [{ search: /vec3 computeReflectionCoords/g, replace: "void DUMMYFUNC" }]
    });
    this._reflectionColorName = state._getFreeVariableName("reflectionColor");
    this._reflectionVectorName = state._getFreeVariableName("reflectionUVW");
    this._reflectionCoordsName = state._getFreeVariableName("reflectionCoords");
    this._reflectionPositionName = state._getFreeVariableName("vReflectionPosition");
    state._emitUniformFromString(this._reflectionPositionName, "vec3");
    this._reflectionSizeName = state._getFreeVariableName("vReflectionPosition");
    state._emitUniformFromString(this._reflectionSizeName, "vec3");
  }
  handleFragmentSideCodeReflectionCoords(worldNormalVarName, worldPos, onlyReflectionVector = false, doNotEmitInvertZ = false) {
    if (!worldPos) {
      worldPos = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : `v_${this.worldPosition.associatedVariableName}`;
    }
    const reflectionMatrix = this._reflectionMatrixName;
    const direction = `normalize(${this._directionWName})`;
    const positionUVW = `${this._positionUVWName}`;
    const vEyePosition = `${this.cameraPosition.associatedVariableName}`;
    const view = `${this.view.associatedVariableName}`;
    worldNormalVarName += ".xyz";
    let code = `
            #ifdef ${this._defineMirroredEquirectangularFixedName}
                vec3 ${this._reflectionVectorName} = computeMirroredFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});
            #endif

            #ifdef ${this._defineEquirectangularFixedName}
                vec3 ${this._reflectionVectorName} = computeFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});
            #endif

            #ifdef ${this._defineEquirectangularName}
                vec3 ${this._reflectionVectorName} = computeEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});
            #endif

            #ifdef ${this._defineSphericalName}
                vec3 ${this._reflectionVectorName} = computeSphericalCoords(${worldPos}, ${worldNormalVarName}, ${view}, ${reflectionMatrix});
            #endif

            #ifdef ${this._definePlanarName}
                vec3 ${this._reflectionVectorName} = computePlanarCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});
            #endif

            #ifdef ${this._defineCubicName}
                #ifdef ${this._defineLocalCubicName}
                    vec3 ${this._reflectionVectorName} = computeCubicLocalCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix}, ${this._reflectionSizeName}, ${this._reflectionPositionName});
                #else
                vec3 ${this._reflectionVectorName} = computeCubicCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});
                #endif
            #endif

            #ifdef ${this._defineProjectionName}
                vec3 ${this._reflectionVectorName} = computeProjectionCoords(${worldPos}, ${view}, ${reflectionMatrix});
            #endif

            #ifdef ${this._defineSkyboxName}
                vec3 ${this._reflectionVectorName} = computeSkyBoxCoords(${positionUVW}, ${reflectionMatrix});
            #endif

            #ifdef ${this._defineExplicitName}
                vec3 ${this._reflectionVectorName} = vec3(0, 0, 0);
            #endif\r
`;
    if (!doNotEmitInvertZ) {
      code += `#ifdef ${this._defineOppositeZ}
                ${this._reflectionVectorName}.z *= -1.0;
            #endif\r
`;
    }
    if (!onlyReflectionVector) {
      code += `
                #ifdef ${this._define3DName}
                    vec3 ${this._reflectionCoordsName} = ${this._reflectionVectorName};
                #else
                    vec2 ${this._reflectionCoordsName} = ${this._reflectionVectorName}.xy;
                    #ifdef ${this._defineProjectionName}
                        ${this._reflectionCoordsName} /= ${this._reflectionVectorName}.z;
                    #endif
                    ${this._reflectionCoordsName}.y = 1.0 - ${this._reflectionCoordsName}.y;
                #endif\r
`;
    }
    return code;
  }
  handleFragmentSideCodeReflectionColor(lodVarName, swizzleLookupTexture = ".rgb") {
    const colorType = "vec" + (swizzleLookupTexture.length === 0 ? "4" : swizzleLookupTexture.length - 1);
    let code = `${colorType} ${this._reflectionColorName};
            #ifdef ${this._define3DName}\r
`;
    if (lodVarName) {
      code += `${this._reflectionColorName} = textureCubeLodEXT(${this._cubeSamplerName}, ${this._reflectionVectorName}, ${lodVarName})${swizzleLookupTexture};\r
`;
    } else {
      code += `${this._reflectionColorName} = textureCube(${this._cubeSamplerName}, ${this._reflectionVectorName})${swizzleLookupTexture};\r
`;
    }
    code += `
            #else\r
`;
    if (lodVarName) {
      code += `${this._reflectionColorName} = texture2DLodEXT(${this._2DSamplerName}, ${this._reflectionCoordsName}, ${lodVarName})${swizzleLookupTexture};\r
`;
    } else {
      code += `${this._reflectionColorName} = texture2D(${this._2DSamplerName}, ${this._reflectionCoordsName})${swizzleLookupTexture};\r
`;
    }
    code += `#endif\r
`;
    return code;
  }
  writeOutputs(state, varName) {
    let code = "";
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      for (const output of this._outputs) {
        if (output.hasEndpoints) {
          code += `${this._declareOutput(output, state)} = ${varName}.${output.name};\r
`;
        }
      }
    }
    return code;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    if (!this.texture) {
      return codeString;
    }
    if (this.texture.isCube) {
      const forcedExtension = this.texture.forcedExtension;
      codeString += `${this._codeVariableName}.texture = new BABYLON.CubeTexture("${this.texture.name}", undefined, undefined, ${this.texture.noMipmap}, null, undefined, undefined, undefined, ${this.texture._prefiltered}, ${forcedExtension ? '"' + forcedExtension + '"' : "null"});\r
`;
    } else {
      codeString += `${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}", null);\r
`;
    }
    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    if (this.texture && !this.texture.isRenderTarget) {
      serializationObject.texture = this.texture.serialize();
    }
    serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      if (serializationObject.texture.isCube) {
        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);
      } else {
        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
      }
    }
    this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;
    this._setTarget();
  }
};
__decorate([
  editableInPropertyPage("Generate only fragment code", PropertyTypeForEdition.Boolean, "ADVANCED", {
    notifiers: { rebuild: true, update: true, onValidation: ReflectionTextureBaseBlock._OnGenerateOnlyFragmentCodeChanged }
  })
], ReflectionTextureBaseBlock.prototype, "generateOnlyFragmentCode", void 0);
RegisterClass("BABYLON.ReflectionTextureBaseBlock", ReflectionTextureBaseBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/reflectionTextureBlock.js
var ReflectionTextureBlock = class extends ReflectionTextureBaseBlock {
  _onGenerateOnlyFragmentCodeChanged() {
    if (this.position.isConnected) {
      this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;
      console.error("The position input must not be connected to be able to switch!");
      return false;
    }
    if (this.worldPosition.isConnected) {
      this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;
      console.error("The worldPosition input must not be connected to be able to switch!");
      return false;
    }
    this._setTarget();
    return true;
  }
  _setTarget() {
    super._setTarget();
    this.getInputByName("position").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;
    this.getInputByName("worldPosition").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;
  }
  constructor(name137) {
    super(name137);
    this.registerInput("position", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("cameraPosition", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("view", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  getClassName() {
    return "ReflectionTextureBlock";
  }
  get position() {
    return this._inputs[0];
  }
  get worldPosition() {
    return this._inputs[1];
  }
  get worldNormal() {
    return this._inputs[2];
  }
  get world() {
    return this._inputs[3];
  }
  get cameraPosition() {
    return this._inputs[4];
  }
  get view() {
    return this._inputs[5];
  }
  get rgb() {
    return this._outputs[0];
  }
  get rgba() {
    return this._outputs[1];
  }
  get r() {
    return this._outputs[2];
  }
  get g() {
    return this._outputs[3];
  }
  get b() {
    return this._outputs[4];
  }
  get a() {
    return this._outputs[5];
  }
  autoConfigure(material) {
    super.autoConfigure(material);
    if (!this.cameraPosition.isConnected) {
      let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition);
      if (!cameraPositionInput) {
        cameraPositionInput = new InputBlock("cameraPosition");
        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);
      }
      cameraPositionInput.output.connectTo(this.cameraPosition);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (!this.texture) {
      state.compilationString += this.writeOutputs(state, "vec4(0.)");
      return this;
    }
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      state.compilationString += this.handleVertexSide(state);
      return this;
    }
    if (this.generateOnlyFragmentCode) {
      state.compilationString += this.handleVertexSide(state);
    }
    this.handleFragmentSideInits(state);
    const normalWUnit = state._getFreeVariableName("normalWUnit");
    state.compilationString += `vec4 ${normalWUnit} = normalize(${this.worldNormal.associatedVariableName});\r
`;
    state.compilationString += this.handleFragmentSideCodeReflectionCoords(normalWUnit);
    state.compilationString += this.handleFragmentSideCodeReflectionColor(void 0, "");
    state.compilationString += this.writeOutputs(state, this._reflectionColorName);
    return this;
  }
};
RegisterClass("BABYLON.ReflectionTextureBlock", ReflectionTextureBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/sceneDepthBlock.js
var SceneDepthBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.VertexAndFragment);
    this.useNonLinearDepth = false;
    this.force32itsFloat = false;
    this._isUnique = true;
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);
    this.registerOutput("depth", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this._inputs[0]._prioritizeVertex = false;
  }
  getClassName() {
    return "SceneDepthBlock";
  }
  get uv() {
    return this._inputs[0];
  }
  get depth() {
    return this._outputs[0];
  }
  initialize(state) {
    state._excludeVariableName("textureSampler");
  }
  get target() {
    if (!this.uv.isConnected) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    if (this.uv.sourceBlock.isInput) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    return NodeMaterialBlockTargets.Fragment;
  }
  _getTexture(scene) {
    const depthRenderer = scene.enableDepthRenderer(void 0, this.useNonLinearDepth, this.force32itsFloat);
    return depthRenderer.getDepthMap();
  }
  bind(effect, nodeMaterial) {
    const texture = this._getTexture(nodeMaterial.getScene());
    effect.setTexture(this._samplerName, texture);
  }
  _injectVertexCode(state) {
    const uvInput = this.uv;
    if (uvInput.connectedPoint.ownerBlock.isInput) {
      const uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;
      if (!uvInputOwnerBlock.isAttribute) {
        state._emitUniformFromString(uvInput.associatedVariableName, "vec" + (uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector3 ? "3" : uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? "4" : "2"));
      }
    }
    this._mainUVName = "vMain" + uvInput.associatedVariableName;
    state._emitVaryingFromString(this._mainUVName, "vec2");
    state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\r
`;
    if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {
      return;
    }
    this._writeTextureRead(state, true);
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, "r", true);
      }
    }
  }
  _writeTextureRead(state, vertexMode = false) {
    const uvInput = this.uv;
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName}.xy);\r
`;
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName}.xy);\r
`;
      return;
    }
    state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._mainUVName});\r
`;
  }
  _writeOutput(state, output, swizzle, vertexMode = false) {
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\r
`;
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\r
`;
      return;
    }
    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\r
`;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this._samplerName = state._getFreeVariableName(this.name + "Sampler");
    this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
    if (state.sharedData.bindableBlocks.indexOf(this) < 0) {
      state.sharedData.bindableBlocks.push(this);
    }
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      state._emit2DSampler(this._samplerName);
      this._injectVertexCode(state);
      return;
    }
    if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {
      return;
    }
    state._emit2DSampler(this._samplerName);
    this._writeTextureRead(state);
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, "r");
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.useNonLinearDepth = this.useNonLinearDepth;
    serializationObject.force32itsFloat = this.force32itsFloat;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.useNonLinearDepth = serializationObject.useNonLinearDepth;
    this.force32itsFloat = serializationObject.force32itsFloat;
  }
};
__decorate([
  editableInPropertyPage("Use non linear depth", PropertyTypeForEdition.Boolean, "ADVANCED", {
    notifiers: { activatePreviewCommand: true, callback: (scene) => scene.disableDepthRenderer() }
  })
], SceneDepthBlock.prototype, "useNonLinearDepth", void 0);
__decorate([
  editableInPropertyPage("Force 32 bits float", PropertyTypeForEdition.Boolean, "ADVANCED", {
    notifiers: { activatePreviewCommand: true, callback: (scene) => scene.disableDepthRenderer() }
  })
], SceneDepthBlock.prototype, "force32itsFloat", void 0);
RegisterClass("BABYLON.SceneDepthBlock", SceneDepthBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/clipPlanesBlock.js
var ClipPlanesBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.VertexAndFragment, true);
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false);
  }
  getClassName() {
    return "ClipPlanesBlock";
  }
  initialize(state) {
    state._excludeVariableName("vClipPlane");
    state._excludeVariableName("fClipDistance");
    state._excludeVariableName("vClipPlane2");
    state._excludeVariableName("fClipDistance2");
    state._excludeVariableName("vClipPlane3");
    state._excludeVariableName("fClipDistance3");
    state._excludeVariableName("vClipPlane4");
    state._excludeVariableName("fClipDistance4");
    state._excludeVariableName("vClipPlane5");
    state._excludeVariableName("fClipDistance5");
    state._excludeVariableName("vClipPlane6");
    state._excludeVariableName("fClipDistance6");
  }
  get worldPosition() {
    return this._inputs[0];
  }
  get target() {
    return NodeMaterialBlockTargets.VertexAndFragment;
  }
  set target(value) {
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    var _a, _b, _c, _d, _e, _f;
    const scene = mesh.getScene();
    const useClipPlane1 = ((_a = nodeMaterial.clipPlane) !== null && _a !== void 0 ? _a : scene.clipPlane) ? true : false;
    const useClipPlane2 = ((_b = nodeMaterial.clipPlane2) !== null && _b !== void 0 ? _b : scene.clipPlane2) ? true : false;
    const useClipPlane3 = ((_c = nodeMaterial.clipPlane3) !== null && _c !== void 0 ? _c : scene.clipPlane3) ? true : false;
    const useClipPlane4 = ((_d = nodeMaterial.clipPlane4) !== null && _d !== void 0 ? _d : scene.clipPlane4) ? true : false;
    const useClipPlane5 = ((_e = nodeMaterial.clipPlane5) !== null && _e !== void 0 ? _e : scene.clipPlane5) ? true : false;
    const useClipPlane6 = ((_f = nodeMaterial.clipPlane6) !== null && _f !== void 0 ? _f : scene.clipPlane6) ? true : false;
    defines.setValue("CLIPPLANE", useClipPlane1, true);
    defines.setValue("CLIPPLANE2", useClipPlane2, true);
    defines.setValue("CLIPPLANE3", useClipPlane3, true);
    defines.setValue("CLIPPLANE4", useClipPlane4, true);
    defines.setValue("CLIPPLANE5", useClipPlane5, true);
    defines.setValue("CLIPPLANE6", useClipPlane6, true);
  }
  bind(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    const scene = mesh.getScene();
    bindClipPlane(effect, nodeMaterial, scene);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const comments = `//${this.name}`;
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      const worldPos = this.worldPosition;
      state._emitFunctionFromInclude("clipPlaneVertexDeclaration", comments, {
        replaceStrings: [{ search: /uniform vec4 vClipPlane\d*;/g, replace: "" }]
      });
      state.compilationString += state._emitCodeFromInclude("clipPlaneVertex", comments, {
        replaceStrings: [{ search: /worldPos/g, replace: worldPos.associatedVariableName }]
      });
      state._emitUniformFromString("vClipPlane", "vec4");
      state._emitUniformFromString("vClipPlane2", "vec4");
      state._emitUniformFromString("vClipPlane3", "vec4");
      state._emitUniformFromString("vClipPlane4", "vec4");
      state._emitUniformFromString("vClipPlane5", "vec4");
      state._emitUniformFromString("vClipPlane6", "vec4");
      return;
    }
    state.sharedData.bindableBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    state._emitFunctionFromInclude("clipPlaneFragmentDeclaration", comments);
    state.compilationString += state._emitCodeFromInclude("clipPlaneFragment", comments);
    return this;
  }
};
RegisterClass("BABYLON.ClipPlanesBlock", ClipPlanesBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/addBlock.js
var AddBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
  }
  getClassName() {
    return "AddBlock";
  }
  get left() {
    return this._inputs[0];
  }
  get right() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = ${this.left.associatedVariableName} + ${this.right.associatedVariableName};\r
`;
    return this;
  }
};
RegisterClass("BABYLON.AddBlock", AddBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/scaleBlock.js
var ScaleBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("factor", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  getClassName() {
    return "ScaleBlock";
  }
  get input() {
    return this._inputs[0];
  }
  get factor() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = ${this.input.associatedVariableName} * ${this.factor.associatedVariableName};\r
`;
    return this;
  }
};
RegisterClass("BABYLON.ScaleBlock", ScaleBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/clampBlock.js
var ClampBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.minimum = 0;
    this.maximum = 1;
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  getClassName() {
    return "ClampBlock";
  }
  get value() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = clamp(${this.value.associatedVariableName}, ${this._writeFloat(this.minimum)}, ${this._writeFloat(this.maximum)});\r
`;
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.minimum = ${this.minimum};\r
`;
    codeString += `${this._codeVariableName}.maximum = ${this.maximum};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.minimum = this.minimum;
    serializationObject.maximum = this.maximum;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.minimum = serializationObject.minimum;
    this.maximum = serializationObject.maximum;
  }
};
__decorate([
  editableInPropertyPage("Minimum", PropertyTypeForEdition.Float)
], ClampBlock.prototype, "minimum", void 0);
__decorate([
  editableInPropertyPage("Maximum", PropertyTypeForEdition.Float)
], ClampBlock.prototype, "maximum", void 0);
RegisterClass("BABYLON.ClampBlock", ClampBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/crossBlock.js
var CrossBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector3);
    this._linkConnectionTypes(0, 1);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector2);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector2);
  }
  getClassName() {
    return "CrossBlock";
  }
  get left() {
    return this._inputs[0];
  }
  get right() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = cross(${this.left.associatedVariableName}.xyz, ${this.right.associatedVariableName}.xyz);\r
`;
    return this;
  }
};
RegisterClass("BABYLON.CrossBlock", CrossBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/customBlock.js
var CustomBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137);
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this._deserializeOptions(options);
  }
  getClassName() {
    return "CustomBlock";
  }
  _buildBlock(state) {
    super._buildBlock(state);
    let code = this._code;
    let functionName = this._options.functionName;
    this._inputs.forEach((input) => {
      const rexp = new RegExp("\\{TYPE_" + input.name + "\\}", "gm");
      const type = state._getGLType(input.type);
      code = code.replace(rexp, type);
      functionName = functionName.replace(rexp, type);
    });
    this._outputs.forEach((output) => {
      const rexp = new RegExp("\\{TYPE_" + output.name + "\\}", "gm");
      const type = state._getGLType(output.type);
      code = code.replace(rexp, type);
      functionName = functionName.replace(rexp, type);
    });
    state._emitFunction(functionName, code, "");
    this._outputs.forEach((output) => {
      state.compilationString += this._declareOutput(output, state) + ";\r\n";
    });
    state.compilationString += functionName + "(";
    let hasInput = false;
    this._inputs.forEach((input, index) => {
      if (index > 0) {
        state.compilationString += ", ";
      }
      state.compilationString += input.associatedVariableName;
      hasInput = true;
    });
    this._outputs.forEach((output, index) => {
      if (index > 0 || hasInput) {
        state.compilationString += ", ";
      }
      state.compilationString += output.associatedVariableName;
    });
    state.compilationString += ");\r\n";
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.options = ${JSON.stringify(this._options)};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.options = this._options;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    this._deserializeOptions(serializationObject.options);
    super._deserialize(serializationObject, scene, rootUrl);
  }
  _deserializeOptions(options) {
    var _a, _b, _c;
    this._options = options;
    this._code = options.code.join("\r\n") + "\r\n";
    this.name = this.name || options.name;
    this.target = NodeMaterialBlockTargets[options.target];
    (_a = options.inParameters) === null || _a === void 0 ? void 0 : _a.forEach((input, index) => {
      const type = NodeMaterialBlockConnectionPointTypes[input.type];
      this.registerInput(input.name, type);
      Object.defineProperty(this, input.name, {
        get: function() {
          return this._inputs[index];
        },
        enumerable: true,
        configurable: true
      });
    });
    (_b = options.outParameters) === null || _b === void 0 ? void 0 : _b.forEach((output, index) => {
      this.registerOutput(output.name, NodeMaterialBlockConnectionPointTypes[output.type]);
      Object.defineProperty(this, output.name, {
        get: function() {
          return this._outputs[index];
        },
        enumerable: true,
        configurable: true
      });
      if (output.type === "BasedOnInput") {
        this._outputs[index]._typeConnectionSource = this._findInputByName(output.typeFromInput)[0];
      }
    });
    (_c = options.inLinkedConnectionTypes) === null || _c === void 0 ? void 0 : _c.forEach((connection) => {
      this._linkConnectionTypes(this._findInputByName(connection.input1)[1], this._findInputByName(connection.input2)[1]);
    });
  }
  _findInputByName(name137) {
    if (!name137) {
      return null;
    }
    for (let i = 0; i < this._inputs.length; i++) {
      if (this._inputs[i].name === name137) {
        return [this._inputs[i], i];
      }
    }
    return null;
  }
};
RegisterClass("BABYLON.CustomBlock", CustomBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/dotBlock.js
var DotBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    this._linkConnectionTypes(0, 1);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  getClassName() {
    return "DotBlock";
  }
  get left() {
    return this._inputs[0];
  }
  get right() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = dot(${this.left.associatedVariableName}, ${this.right.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.DotBlock", DotBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/normalizeBlock.js
var NormalizeBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  getClassName() {
    return "NormalizeBlock";
  }
  get input() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const input = this._inputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = normalize(${input.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.NormalizeBlock", NormalizeBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/colorMergerBlock.js
var ColorMergerBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.rSwizzle = "r";
    this.gSwizzle = "g";
    this.bSwizzle = "b";
    this.aSwizzle = "a";
    this.registerInput("rgb ", NodeMaterialBlockConnectionPointTypes.Color3, true);
    this.registerInput("r", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("g", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("b", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("a", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3);
  }
  getClassName() {
    return "ColorMergerBlock";
  }
  get rgbIn() {
    return this._inputs[0];
  }
  get r() {
    return this._inputs[1];
  }
  get g() {
    return this._inputs[2];
  }
  get b() {
    return this._inputs[3];
  }
  get a() {
    return this._inputs[4];
  }
  get rgba() {
    return this._outputs[0];
  }
  get rgbOut() {
    return this._outputs[1];
  }
  get rgb() {
    return this.rgbOut;
  }
  _inputRename(name137) {
    if (name137 === "rgb ") {
      return "rgbIn";
    }
    return name137;
  }
  _buildSwizzle(len) {
    const swizzle = this.rSwizzle + this.gSwizzle + this.bSwizzle + this.aSwizzle;
    return "." + swizzle.substr(0, len);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const rInput = this.r;
    const gInput = this.g;
    const bInput = this.b;
    const aInput = this.a;
    const rgbInput = this.rgbIn;
    const color4Output = this._outputs[0];
    const color3Output = this._outputs[1];
    if (rgbInput.isConnected) {
      if (color4Output.hasEndpoints) {
        state.compilationString += this._declareOutput(color4Output, state) + ` = vec4(${rgbInput.associatedVariableName}, ${aInput.isConnected ? this._writeVariable(aInput) : "0.0"})${this._buildSwizzle(4)};\r
`;
      }
      if (color3Output.hasEndpoints) {
        state.compilationString += this._declareOutput(color3Output, state) + ` = ${rgbInput.associatedVariableName}${this._buildSwizzle(3)};\r
`;
      }
    } else {
      if (color4Output.hasEndpoints) {
        state.compilationString += this._declareOutput(color4Output, state) + ` = vec4(${rInput.isConnected ? this._writeVariable(rInput) : "0.0"}, ${gInput.isConnected ? this._writeVariable(gInput) : "0.0"}, ${bInput.isConnected ? this._writeVariable(bInput) : "0.0"}, ${aInput.isConnected ? this._writeVariable(aInput) : "0.0"})${this._buildSwizzle(4)};\r
`;
      }
      if (color3Output.hasEndpoints) {
        state.compilationString += this._declareOutput(color3Output, state) + ` = vec3(${rInput.isConnected ? this._writeVariable(rInput) : "0.0"}, ${gInput.isConnected ? this._writeVariable(gInput) : "0.0"}, ${bInput.isConnected ? this._writeVariable(bInput) : "0.0"})${this._buildSwizzle(3)};\r
`;
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.rSwizzle = this.rSwizzle;
    serializationObject.gSwizzle = this.gSwizzle;
    serializationObject.bSwizzle = this.bSwizzle;
    serializationObject.aSwizzle = this.aSwizzle;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    var _a, _b, _c, _d;
    super._deserialize(serializationObject, scene, rootUrl);
    this.rSwizzle = (_a = serializationObject.rSwizzle) !== null && _a !== void 0 ? _a : "r";
    this.gSwizzle = (_b = serializationObject.gSwizzle) !== null && _b !== void 0 ? _b : "g";
    this.bSwizzle = (_c = serializationObject.bSwizzle) !== null && _c !== void 0 ? _c : "b";
    this.aSwizzle = (_d = serializationObject.aSwizzle) !== null && _d !== void 0 ? _d : "a";
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.rSwizzle = "${this.rSwizzle}";\r
`;
    codeString += `${this._codeVariableName}.gSwizzle = "${this.gSwizzle}";\r
`;
    codeString += `${this._codeVariableName}.bSwizzle = "${this.bSwizzle}";\r
`;
    codeString += `${this._codeVariableName}.aSwizzle = "${this.aSwizzle}";\r
`;
    return codeString;
  }
};
RegisterClass("BABYLON.ColorMergerBlock", ColorMergerBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/vectorSplitterBlock.js
var VectorSplitterBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("xyzw", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("xyz ", NodeMaterialBlockConnectionPointTypes.Vector3, true);
    this.registerInput("xy ", NodeMaterialBlockConnectionPointTypes.Vector2, true);
    this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("zw", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("z", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("w", NodeMaterialBlockConnectionPointTypes.Float);
    this.inputsAreExclusive = true;
  }
  getClassName() {
    return "VectorSplitterBlock";
  }
  get xyzw() {
    return this._inputs[0];
  }
  get xyzIn() {
    return this._inputs[1];
  }
  get xyIn() {
    return this._inputs[2];
  }
  get xyzOut() {
    return this._outputs[0];
  }
  get xyOut() {
    return this._outputs[1];
  }
  get zw() {
    return this._outputs[2];
  }
  get x() {
    return this._outputs[3];
  }
  get y() {
    return this._outputs[4];
  }
  get z() {
    return this._outputs[5];
  }
  get w() {
    return this._outputs[6];
  }
  _inputRename(name137) {
    switch (name137) {
      case "xy ":
        return "xyIn";
      case "xyz ":
        return "xyzIn";
      default:
        return name137;
    }
  }
  _outputRename(name137) {
    switch (name137) {
      case "xy":
        return "xyOut";
      case "xyz":
        return "xyzOut";
      default:
        return name137;
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const input = this.xyzw.isConnected ? this.xyzw : this.xyzIn.isConnected ? this.xyzIn : this.xyIn;
    const xyzOutput = this._outputs[0];
    const xyOutput = this._outputs[1];
    const zwOutput = this._outputs[2];
    const xOutput = this._outputs[3];
    const yOutput = this._outputs[4];
    const zOutput = this._outputs[5];
    const wOutput = this._outputs[6];
    if (xyzOutput.hasEndpoints) {
      if (input === this.xyIn) {
        state.compilationString += this._declareOutput(xyzOutput, state) + ` = vec3(${input.associatedVariableName}, 0.0);\r
`;
      } else {
        state.compilationString += this._declareOutput(xyzOutput, state) + ` = ${input.associatedVariableName}.xyz;\r
`;
      }
    }
    if (zwOutput.hasEndpoints && this.xyzw.isConnected) {
      state.compilationString += this._declareOutput(zwOutput, state) + ` = ${this.xyzw.associatedVariableName}.zw;\r
`;
    }
    if (xyOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(xyOutput, state) + ` = ${input.associatedVariableName}.xy;\r
`;
    }
    if (xOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(xOutput, state) + ` = ${input.associatedVariableName}.x;\r
`;
    }
    if (yOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(yOutput, state) + ` = ${input.associatedVariableName}.y;\r
`;
    }
    if (zOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(zOutput, state) + ` = ${input.associatedVariableName}.z;\r
`;
    }
    if (wOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(wOutput, state) + ` = ${input.associatedVariableName}.w;\r
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.VectorSplitterBlock", VectorSplitterBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/lerpBlock.js
var LerpBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("gradient", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
    this._linkConnectionTypes(1, 2, true);
    this._inputs[2].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
  }
  getClassName() {
    return "LerpBlock";
  }
  get left() {
    return this._inputs[0];
  }
  get right() {
    return this._inputs[1];
  }
  get gradient() {
    return this._inputs[2];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = mix(${this.left.associatedVariableName} , ${this.right.associatedVariableName}, ${this.gradient.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.LerpBlock", LerpBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/divideBlock.js
var DivideBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
  }
  getClassName() {
    return "DivideBlock";
  }
  get left() {
    return this._inputs[0];
  }
  get right() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = ${this.left.associatedVariableName} / ${this.right.associatedVariableName};\r
`;
    return this;
  }
};
RegisterClass("BABYLON.DivideBlock", DivideBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/subtractBlock.js
var SubtractBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
  }
  getClassName() {
    return "SubtractBlock";
  }
  get left() {
    return this._inputs[0];
  }
  get right() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = ${this.left.associatedVariableName} - ${this.right.associatedVariableName};\r
`;
    return this;
  }
};
RegisterClass("BABYLON.SubtractBlock", SubtractBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/stepBlock.js
var StepBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("edge", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
  }
  getClassName() {
    return "StepBlock";
  }
  get value() {
    return this._inputs[0];
  }
  get edge() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = step(${this.edge.associatedVariableName}, ${this.value.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.StepBlock", StepBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/oneMinusBlock.js
var OneMinusBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._outputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  getClassName() {
    return "OneMinusBlock";
  }
  get input() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = 1. - ${this.input.associatedVariableName};\r
`;
    return this;
  }
};
RegisterClass("BABYLON.OneMinusBlock", OneMinusBlock);
RegisterClass("BABYLON.OppositeBlock", OneMinusBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/viewDirectionBlock.js
var ViewDirectionBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("cameraPosition", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector3);
  }
  getClassName() {
    return "ViewDirectionBlock";
  }
  get worldPosition() {
    return this._inputs[0];
  }
  get cameraPosition() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  autoConfigure(material) {
    if (!this.cameraPosition.isConnected) {
      let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition);
      if (!cameraPositionInput) {
        cameraPositionInput = new InputBlock("cameraPosition");
        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);
      }
      cameraPositionInput.output.connectTo(this.cameraPosition);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = normalize(${this.cameraPosition.associatedVariableName} - ${this.worldPosition.associatedVariableName}.xyz);\r
`;
    return this;
  }
};
RegisterClass("BABYLON.ViewDirectionBlock", ViewDirectionBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/fresnelBlock.js
var FresnelBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("viewDirection", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("bias", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("power", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("fresnel", NodeMaterialBlockConnectionPointTypes.Float);
  }
  getClassName() {
    return "FresnelBlock";
  }
  get worldNormal() {
    return this._inputs[0];
  }
  get viewDirection() {
    return this._inputs[1];
  }
  get bias() {
    return this._inputs[2];
  }
  get power() {
    return this._inputs[3];
  }
  get fresnel() {
    return this._outputs[0];
  }
  autoConfigure(material) {
    if (!this.viewDirection.isConnected) {
      const viewDirectionInput = new ViewDirectionBlock("View direction");
      viewDirectionInput.output.connectTo(this.viewDirection);
      viewDirectionInput.autoConfigure(material);
    }
    if (!this.bias.isConnected) {
      const biasInput = new InputBlock("bias");
      biasInput.value = 0;
      biasInput.output.connectTo(this.bias);
    }
    if (!this.power.isConnected) {
      const powerInput = new InputBlock("power");
      powerInput.value = 1;
      powerInput.output.connectTo(this.power);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("fresnelFunction", comments, { removeIfDef: true });
    state.compilationString += this._declareOutput(this.fresnel, state) + ` = computeFresnelTerm(${this.viewDirection.associatedVariableName}.xyz, ${this.worldNormal.associatedVariableName}.xyz, ${this.bias.associatedVariableName}, ${this.power.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.FresnelBlock", FresnelBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/maxBlock.js
var MaxBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
  }
  getClassName() {
    return "MaxBlock";
  }
  get left() {
    return this._inputs[0];
  }
  get right() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = max(${this.left.associatedVariableName}, ${this.right.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.MaxBlock", MaxBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/minBlock.js
var MinBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
  }
  getClassName() {
    return "MinBlock";
  }
  get left() {
    return this._inputs[0];
  }
  get right() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = min(${this.left.associatedVariableName}, ${this.right.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.MinBlock", MinBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/distanceBlock.js
var DistanceBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    this._linkConnectionTypes(0, 1);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  getClassName() {
    return "DistanceBlock";
  }
  get left() {
    return this._inputs[0];
  }
  get right() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = length(${this.left.associatedVariableName} - ${this.right.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.DistanceBlock", DistanceBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/lengthBlock.js
var LengthBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  getClassName() {
    return "LengthBlock";
  }
  get value() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = length(${this.value.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.LengthBlock", LengthBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/negateBlock.js
var NegateBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  getClassName() {
    return "NegateBlock";
  }
  get value() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = -1.0 * ${this.value.associatedVariableName};\r
`;
    return this;
  }
};
RegisterClass("BABYLON.NegateBlock", NegateBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/powBlock.js
var PowBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("power", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
  }
  getClassName() {
    return "PowBlock";
  }
  get value() {
    return this._inputs[0];
  }
  get power() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = pow(${this.value.associatedVariableName}, ${this.power.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.PowBlock", PowBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/randomNumberBlock.js
var RandomNumberBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("seed", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4);
  }
  getClassName() {
    return "RandomNumberBlock";
  }
  get seed() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    state.compilationString += this._declareOutput(output, state) + ` = getRand(${this.seed.associatedVariableName}.xy);\r
`;
    return this;
  }
};
RegisterClass("BABYLON.RandomNumberBlock", RandomNumberBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/arcTan2Block.js
var ArcTan2Block = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("x", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("y", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
  }
  getClassName() {
    return "ArcTan2Block";
  }
  get x() {
    return this._inputs[0];
  }
  get y() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = atan(${this.x.associatedVariableName}, ${this.y.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.ArcTan2Block", ArcTan2Block);

// node_modules/@babylonjs/core/Materials/Node/Blocks/smoothStepBlock.js
var SmoothStepBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("edge0", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("edge1", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  getClassName() {
    return "SmoothStepBlock";
  }
  get value() {
    return this._inputs[0];
  }
  get edge0() {
    return this._inputs[1];
  }
  get edge1() {
    return this._inputs[2];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = smoothstep(${this.edge0.associatedVariableName}, ${this.edge1.associatedVariableName}, ${this.value.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.SmoothStepBlock", SmoothStepBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/reciprocalBlock.js
var ReciprocalBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  getClassName() {
    return "ReciprocalBlock";
  }
  get input() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    if (this.input.type === NodeMaterialBlockConnectionPointTypes.Matrix) {
      state.compilationString += this._declareOutput(output, state) + ` = inverse(${this.input.associatedVariableName});\r
`;
    } else {
      state.compilationString += this._declareOutput(output, state) + ` = 1. / ${this.input.associatedVariableName};\r
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.ReciprocalBlock", ReciprocalBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/replaceColorBlock.js
var ReplaceColorBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("reference", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("distance", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("replacement", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
    this._linkConnectionTypes(0, 3);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[3].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[3].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  getClassName() {
    return "ReplaceColorBlock";
  }
  get value() {
    return this._inputs[0];
  }
  get reference() {
    return this._inputs[1];
  }
  get distance() {
    return this._inputs[2];
  }
  get replacement() {
    return this._inputs[3];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + `;\r
`;
    state.compilationString += `if (length(${this.value.associatedVariableName} - ${this.reference.associatedVariableName}) < ${this.distance.associatedVariableName}) {\r
`;
    state.compilationString += `${output.associatedVariableName} = ${this.replacement.associatedVariableName};\r
`;
    state.compilationString += `} else {\r
`;
    state.compilationString += `${output.associatedVariableName} = ${this.value.associatedVariableName};\r
`;
    state.compilationString += `}\r
`;
    return this;
  }
};
RegisterClass("BABYLON.ReplaceColorBlock", ReplaceColorBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/posterizeBlock.js
var PosterizeBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("steps", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  getClassName() {
    return "PosterizeBlock";
  }
  get value() {
    return this._inputs[0];
  }
  get steps() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = floor(${this.value.associatedVariableName} / (1.0 / ${this.steps.associatedVariableName})) * (1.0 / ${this.steps.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.PosterizeBlock", PosterizeBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/waveBlock.js
var WaveBlockKind;
(function(WaveBlockKind2) {
  WaveBlockKind2[WaveBlockKind2["SawTooth"] = 0] = "SawTooth";
  WaveBlockKind2[WaveBlockKind2["Square"] = 1] = "Square";
  WaveBlockKind2[WaveBlockKind2["Triangle"] = 2] = "Triangle";
})(WaveBlockKind || (WaveBlockKind = {}));
var WaveBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.kind = WaveBlockKind.SawTooth;
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  getClassName() {
    return "WaveBlock";
  }
  get input() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    switch (this.kind) {
      case WaveBlockKind.SawTooth: {
        state.compilationString += this._declareOutput(output, state) + ` = ${this.input.associatedVariableName} - floor(0.5 + ${this.input.associatedVariableName});\r
`;
        break;
      }
      case WaveBlockKind.Square: {
        state.compilationString += this._declareOutput(output, state) + ` = 1.0 - 2.0 * round(fract(${this.input.associatedVariableName}));\r
`;
        break;
      }
      case WaveBlockKind.Triangle: {
        state.compilationString += this._declareOutput(output, state) + ` = 2.0 * abs(2.0 * (${this.input.associatedVariableName} - floor(0.5 + ${this.input.associatedVariableName}))) - 1.0;\r
`;
        break;
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.kind = this.kind;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.kind = serializationObject.kind;
  }
};
RegisterClass("BABYLON.WaveBlock", WaveBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/gradientBlock.js
var GradientBlockColorStep = class {
  constructor(step, color) {
    this.step = step;
    this.color = color;
  }
  get step() {
    return this._step;
  }
  set step(val) {
    this._step = val;
  }
  get color() {
    return this._color;
  }
  set color(val) {
    this._color = val;
  }
};
var GradientBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.colorSteps = [new GradientBlockColorStep(0, Color3.Black()), new GradientBlockColorStep(1, Color3.White())];
    this.onValueChangedObservable = new Observable();
    this.registerInput("gradient", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Color3);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Float | NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4);
  }
  colorStepsUpdated() {
    this.onValueChangedObservable.notifyObservers(this);
  }
  getClassName() {
    return "GradientBlock";
  }
  get gradient() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  _writeColorConstant(index) {
    const step = this.colorSteps[index];
    return `vec3(${step.color.r}, ${step.color.g}, ${step.color.b})`;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    if (!this.colorSteps.length || !this.gradient.connectedPoint) {
      state.compilationString += this._declareOutput(output, state) + ` = vec3(0., 0., 0.);\r
`;
      return;
    }
    const tempColor = state._getFreeVariableName("gradientTempColor");
    const tempPosition = state._getFreeVariableName("gradientTempPosition");
    state.compilationString += `vec3 ${tempColor} = ${this._writeColorConstant(0)};\r
`;
    state.compilationString += `float ${tempPosition};\r
`;
    let gradientSource = this.gradient.associatedVariableName;
    if (this.gradient.connectedPoint.type !== NodeMaterialBlockConnectionPointTypes.Float) {
      gradientSource += ".x";
    }
    for (let index = 1; index < this.colorSteps.length; index++) {
      const step = this.colorSteps[index];
      const previousStep = this.colorSteps[index - 1];
      state.compilationString += `${tempPosition} = clamp((${gradientSource} - ${state._emitFloat(previousStep.step)}) / (${state._emitFloat(step.step)} -  ${state._emitFloat(previousStep.step)}), 0.0, 1.0) * step(${state._emitFloat(index)}, ${state._emitFloat(this.colorSteps.length - 1)});\r
`;
      state.compilationString += `${tempColor} = mix(${tempColor}, ${this._writeColorConstant(index)}, ${tempPosition});\r
`;
    }
    state.compilationString += this._declareOutput(output, state) + ` = ${tempColor};\r
`;
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.colorSteps = [];
    for (const step of this.colorSteps) {
      serializationObject.colorSteps.push({
        step: step.step,
        color: {
          r: step.color.r,
          g: step.color.g,
          b: step.color.b
        }
      });
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.colorSteps.length = 0;
    for (const step of serializationObject.colorSteps) {
      this.colorSteps.push(new GradientBlockColorStep(step.step, new Color3(step.color.r, step.color.g, step.color.b)));
    }
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.colorSteps = [];\r
`;
    for (const colorStep of this.colorSteps) {
      codeString += `${this._codeVariableName}.colorSteps.push(new BABYLON.GradientBlockColorStep(${colorStep.step}, new BABYLON.Color3(${colorStep.color.r}, ${colorStep.color.g}, ${colorStep.color.b})));\r
`;
    }
    return codeString;
  }
};
RegisterClass("BABYLON.GradientBlock", GradientBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/nLerpBlock.js
var NLerpBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("gradient", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
    this._linkConnectionTypes(1, 2, true);
    this._inputs[2].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
  }
  getClassName() {
    return "NLerpBlock";
  }
  get left() {
    return this._inputs[0];
  }
  get right() {
    return this._inputs[1];
  }
  get gradient() {
    return this._inputs[2];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = normalize(mix(${this.left.associatedVariableName} , ${this.right.associatedVariableName}, ${this.gradient.associatedVariableName}));\r
`;
    return this;
  }
};
RegisterClass("BABYLON.NLerpBlock", NLerpBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/worleyNoise3DBlock.js
var WorleyNoise3DBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.manhattanDistance = false;
    this.registerInput("seed", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("jitter", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float);
  }
  getClassName() {
    return "WorleyNoise3DBlock";
  }
  get seed() {
    return this._inputs[0];
  }
  get jitter() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  get x() {
    return this._outputs[1];
  }
  get y() {
    return this._outputs[2];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (!this.seed.isConnected) {
      return;
    }
    if (!this.output.hasEndpoints && !this.x.hasEndpoints && !this.y.hasEndpoints) {
      return;
    }
    let functionString = `vec3 permute(vec3 x){\r
`;
    functionString += `    return mod((34.0 * x + 1.0) * x, 289.0);\r
`;
    functionString += `}\r
\r
`;
    functionString += `vec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance){\r
`;
    functionString += `    return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\r
`;
    functionString += `}\r
\r
`;
    functionString += `vec2 worley(vec3 P, float jitter, bool manhattanDistance){\r
`;
    functionString += `    float K = 0.142857142857; // 1/7\r
`;
    functionString += `    float Ko = 0.428571428571; // 1/2-K/2\r
`;
    functionString += `    float  K2 = 0.020408163265306; // 1/(7*7)\r
`;
    functionString += `    float Kz = 0.166666666667; // 1/6\r
`;
    functionString += `    float Kzo = 0.416666666667; // 1/2-1/6*2\r
`;
    functionString += `\r
`;
    functionString += `    vec3 Pi = mod(floor(P), 289.0);\r
`;
    functionString += `    vec3 Pf = fract(P) - 0.5;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\r
`;
    functionString += `    vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\r
`;
    functionString += `    vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\r
`;
    functionString += `\r
`;
    functionString += `    vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\r
`;
    functionString += `    vec3 p1 = permute(p + Pi.y - 1.0);\r
`;
    functionString += `    vec3 p2 = permute(p + Pi.y);\r
`;
    functionString += `    vec3 p3 = permute(p + Pi.y + 1.0);\r
`;
    functionString += `\r
`;
    functionString += `    vec3 p11 = permute(p1 + Pi.z - 1.0);\r
`;
    functionString += `    vec3 p12 = permute(p1 + Pi.z);\r
`;
    functionString += `    vec3 p13 = permute(p1 + Pi.z + 1.0);\r
`;
    functionString += `\r
`;
    functionString += `    vec3 p21 = permute(p2 + Pi.z - 1.0);\r
`;
    functionString += `    vec3 p22 = permute(p2 + Pi.z);\r
`;
    functionString += `    vec3 p23 = permute(p2 + Pi.z + 1.0);\r
`;
    functionString += `\r
`;
    functionString += `    vec3 p31 = permute(p3 + Pi.z - 1.0);\r
`;
    functionString += `    vec3 p32 = permute(p3 + Pi.z);\r
`;
    functionString += `    vec3 p33 = permute(p3 + Pi.z + 1.0);\r
`;
    functionString += `\r
`;
    functionString += `    vec3 ox11 = fract(p11*K) - Ko;\r
`;
    functionString += `    vec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\r
`;
    functionString += `    vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\r
`;
    functionString += `\r
`;
    functionString += `    vec3 ox12 = fract(p12*K) - Ko;\r
`;
    functionString += `    vec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\r
`;
    functionString += `    vec3 oz12 = floor(p12*K2)*Kz - Kzo;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 ox13 = fract(p13*K) - Ko;\r
`;
    functionString += `    vec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\r
`;
    functionString += `    vec3 oz13 = floor(p13*K2)*Kz - Kzo;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 ox21 = fract(p21*K) - Ko;\r
`;
    functionString += `    vec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\r
`;
    functionString += `    vec3 oz21 = floor(p21*K2)*Kz - Kzo;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 ox22 = fract(p22*K) - Ko;\r
`;
    functionString += `    vec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\r
`;
    functionString += `    vec3 oz22 = floor(p22*K2)*Kz - Kzo;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 ox23 = fract(p23*K) - Ko;\r
`;
    functionString += `    vec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\r
`;
    functionString += `    vec3 oz23 = floor(p23*K2)*Kz - Kzo;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 ox31 = fract(p31*K) - Ko;\r
`;
    functionString += `    vec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\r
`;
    functionString += `    vec3 oz31 = floor(p31*K2)*Kz - Kzo;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 ox32 = fract(p32*K) - Ko;\r
`;
    functionString += `    vec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\r
`;
    functionString += `    vec3 oz32 = floor(p32*K2)*Kz - Kzo;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 ox33 = fract(p33*K) - Ko;\r
`;
    functionString += `    vec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\r
`;
    functionString += `    vec3 oz33 = floor(p33*K2)*Kz - Kzo;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 dx11 = Pfx + jitter*ox11;\r
`;
    functionString += `    vec3 dy11 = Pfy.x + jitter*oy11;\r
`;
    functionString += `    vec3 dz11 = Pfz.x + jitter*oz11;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 dx12 = Pfx + jitter*ox12;\r
`;
    functionString += `    vec3 dy12 = Pfy.x + jitter*oy12;\r
`;
    functionString += `    vec3 dz12 = Pfz.y + jitter*oz12;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 dx13 = Pfx + jitter*ox13;\r
`;
    functionString += `    vec3 dy13 = Pfy.x + jitter*oy13;\r
`;
    functionString += `    vec3 dz13 = Pfz.z + jitter*oz13;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 dx21 = Pfx + jitter*ox21;\r
`;
    functionString += `    vec3 dy21 = Pfy.y + jitter*oy21;\r
`;
    functionString += `    vec3 dz21 = Pfz.x + jitter*oz21;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 dx22 = Pfx + jitter*ox22;\r
`;
    functionString += `    vec3 dy22 = Pfy.y + jitter*oy22;\r
`;
    functionString += `    vec3 dz22 = Pfz.y + jitter*oz22;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 dx23 = Pfx + jitter*ox23;\r
`;
    functionString += `    vec3 dy23 = Pfy.y + jitter*oy23;\r
`;
    functionString += `    vec3 dz23 = Pfz.z + jitter*oz23;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 dx31 = Pfx + jitter*ox31;\r
`;
    functionString += `    vec3 dy31 = Pfy.z + jitter*oy31;\r
`;
    functionString += `    vec3 dz31 = Pfz.x + jitter*oz31;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 dx32 = Pfx + jitter*ox32;\r
`;
    functionString += `    vec3 dy32 = Pfy.z + jitter*oy32;\r
`;
    functionString += `    vec3 dz32 = Pfz.y + jitter*oz32;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 dx33 = Pfx + jitter*ox33;\r
`;
    functionString += `    vec3 dy33 = Pfy.z + jitter*oy33;\r
`;
    functionString += `    vec3 dz33 = Pfz.z + jitter*oz33;\r
`;
    functionString += `\r
`;
    functionString += `    vec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\r
`;
    functionString += `    vec3 d12 =dist(dx12, dy12, dz12, manhattanDistance);\r
`;
    functionString += `    vec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\r
`;
    functionString += `    vec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\r
`;
    functionString += `    vec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\r
`;
    functionString += `    vec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\r
`;
    functionString += `    vec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\r
`;
    functionString += `    vec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\r
`;
    functionString += `    vec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\r
`;
    functionString += `\r
`;
    functionString += `    vec3 d1a = min(d11, d12);\r
`;
    functionString += `    d12 = max(d11, d12);\r
`;
    functionString += `    d11 = min(d1a, d13); // Smallest now not in d12 or d13\r
`;
    functionString += `    d13 = max(d1a, d13);\r
`;
    functionString += `    d12 = min(d12, d13); // 2nd smallest now not in d13\r
`;
    functionString += `    vec3 d2a = min(d21, d22);\r
`;
    functionString += `    d22 = max(d21, d22);\r
`;
    functionString += `    d21 = min(d2a, d23); // Smallest now not in d22 or d23\r
`;
    functionString += `    d23 = max(d2a, d23);\r
`;
    functionString += `    d22 = min(d22, d23); // 2nd smallest now not in d23\r
`;
    functionString += `    vec3 d3a = min(d31, d32);\r
`;
    functionString += `    d32 = max(d31, d32);\r
`;
    functionString += `    d31 = min(d3a, d33); // Smallest now not in d32 or d33\r
`;
    functionString += `    d33 = max(d3a, d33);\r
`;
    functionString += `    d32 = min(d32, d33); // 2nd smallest now not in d33\r
`;
    functionString += `    vec3 da = min(d11, d21);\r
`;
    functionString += `    d21 = max(d11, d21);\r
`;
    functionString += `    d11 = min(da, d31); // Smallest now in d11\r
`;
    functionString += `    d31 = max(da, d31); // 2nd smallest now not in d31\r
`;
    functionString += `    d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\r
`;
    functionString += `    d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\r
`;
    functionString += `    d12 = min(d12, d21); // 2nd smallest now not in d21\r
`;
    functionString += `    d12 = min(d12, d22); // nor in d22\r
`;
    functionString += `    d12 = min(d12, d31); // nor in d31\r
`;
    functionString += `    d12 = min(d12, d32); // nor in d32\r
`;
    functionString += `    d11.yz = min(d11.yz,d12.xy); // nor in d12.yz\r
`;
    functionString += `    d11.y = min(d11.y,d12.z); // Only two more to go\r
`;
    functionString += `    d11.y = min(d11.y,d11.z); // Done! (Phew!)\r
`;
    functionString += `    return sqrt(d11.xy); // F1, F2\r
`;
    functionString += `}\r
\r
`;
    state._emitFunction("worley3D", functionString, "// Worley3D");
    const tempVariable = state._getFreeVariableName("worleyTemp");
    state.compilationString += `vec2 ${tempVariable} = worley(${this.seed.associatedVariableName}, ${this.jitter.associatedVariableName}, ${this.manhattanDistance});\r
`;
    if (this.output.hasEndpoints) {
      state.compilationString += this._declareOutput(this.output, state) + ` = ${tempVariable};\r
`;
    }
    if (this.x.hasEndpoints) {
      state.compilationString += this._declareOutput(this.x, state) + ` = ${tempVariable}.x;\r
`;
    }
    if (this.y.hasEndpoints) {
      state.compilationString += this._declareOutput(this.y, state) + ` = ${tempVariable}.y;\r
`;
    }
    return this;
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.manhattanDistance = ${this.manhattanDistance};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.manhattanDistance = this.manhattanDistance;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.manhattanDistance = serializationObject.manhattanDistance;
  }
};
__decorate([
  editableInPropertyPage("Use Manhattan Distance", PropertyTypeForEdition.Boolean, "PROPERTIES", { notifiers: { update: false } })
], WorleyNoise3DBlock.prototype, "manhattanDistance", void 0);
RegisterClass("BABYLON.WorleyNoise3DBlock", WorleyNoise3DBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/simplexPerlin3DBlock.js
var SimplexPerlin3DBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("seed", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
  }
  getClassName() {
    return "SimplexPerlin3DBlock";
  }
  get seed() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (!this.seed.isConnected) {
      return;
    }
    if (!this._outputs[0].hasEndpoints) {
      return;
    }
    let functionString = `const float SKEWFACTOR = 1.0/3.0;\r
`;
    functionString += `const float UNSKEWFACTOR = 1.0/6.0;\r
`;
    functionString += `const float SIMPLEX_CORNER_POS = 0.5;\r
`;
    functionString += `const float SIMPLEX_TETRAHADRON_HEIGHT = 0.70710678118654752440084436210485;\r
`;
    functionString += `float SimplexPerlin3D( vec3 P ){\r
`;
    functionString += `    P.x = P == vec3(0., 0., 0.) ? 0.00001 : P.x;\r
`;
    functionString += `    P *= SIMPLEX_TETRAHADRON_HEIGHT;\r
`;
    functionString += `    vec3 Pi = floor( P + dot( P, vec3( SKEWFACTOR) ) );`;
    functionString += `    vec3 x0 = P - Pi + dot(Pi, vec3( UNSKEWFACTOR ) );\r
`;
    functionString += `    vec3 g = step(x0.yzx, x0.xyz);\r
`;
    functionString += `    vec3 l = 1.0 - g;\r
`;
    functionString += `    vec3 Pi_1 = min( g.xyz, l.zxy );\r
`;
    functionString += `    vec3 Pi_2 = max( g.xyz, l.zxy );\r
`;
    functionString += `    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;\r
`;
    functionString += `    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;\r
`;
    functionString += `    vec3 x3 = x0 - SIMPLEX_CORNER_POS;\r
`;
    functionString += `    vec4 v1234_x = vec4( x0.x, x1.x, x2.x, x3.x );\r
`;
    functionString += `    vec4 v1234_y = vec4( x0.y, x1.y, x2.y, x3.y );\r
`;
    functionString += `    vec4 v1234_z = vec4( x0.z, x1.z, x2.z, x3.z );\r
`;
    functionString += `    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\r
`;
    functionString += `    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\r
`;
    functionString += `    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\r
`;
    functionString += `    Pt *= Pt;\r
`;
    functionString += `    vec4 V1xy_V2xy = mix( Pt.xyxy, Pt.zwzw, vec4( Pi_1.xy, Pi_2.xy ) );\r
`;
    functionString += `    Pt = vec4( Pt.x, V1xy_V2xy.xz, Pt.z ) * vec4( Pt.y, V1xy_V2xy.yw, Pt.w );\r
`;
    functionString += `    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\r
`;
    functionString += `    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\r
`;
    functionString += `    vec3 lowz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi.zzz * ZINC.xyz ) );\r
`;
    functionString += `    vec3 highz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi_inc1.zzz * ZINC.xyz ) );\r
`;
    functionString += `    Pi_1 = ( Pi_1.z < 0.5 ) ? lowz_mods : highz_mods;\r
`;
    functionString += `    Pi_2 = ( Pi_2.z < 0.5 ) ? lowz_mods : highz_mods;\r
`;
    functionString += `    vec4 hash_0 = fract( Pt * vec4( lowz_mods.x, Pi_1.x, Pi_2.x, highz_mods.x ) ) - 0.49999;\r
`;
    functionString += `    vec4 hash_1 = fract( Pt * vec4( lowz_mods.y, Pi_1.y, Pi_2.y, highz_mods.y ) ) - 0.49999;\r
`;
    functionString += `    vec4 hash_2 = fract( Pt * vec4( lowz_mods.z, Pi_1.z, Pi_2.z, highz_mods.z ) ) - 0.49999;\r
`;
    functionString += `    vec4 grad_results = inversesqrt( hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2 ) * ( hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z );\r
`;
    functionString += `    const float FINAL_NORMALIZATION = 37.837227241611314102871574478976;\r
`;
    functionString += `    vec4 kernel_weights = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;\r
`;
    functionString += `    kernel_weights = max(0.5 - kernel_weights, 0.0);\r
`;
    functionString += `    kernel_weights = kernel_weights*kernel_weights*kernel_weights;\r
`;
    functionString += `    return dot( kernel_weights, grad_results ) * FINAL_NORMALIZATION;\r
`;
    functionString += `}\r
`;
    state._emitFunction("SimplexPerlin3D", functionString, "// SimplexPerlin3D");
    state.compilationString += this._declareOutput(this._outputs[0], state) + ` = SimplexPerlin3D(${this.seed.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.SimplexPerlin3DBlock", SimplexPerlin3DBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/normalBlendBlock.js
var NormalBlendBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("normalMap0", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("normalMap1", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector3);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this._inputs[1].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  getClassName() {
    return "NormalBlendBlock";
  }
  get normalMap0() {
    return this._inputs[0];
  }
  get normalMap1() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const input0 = this._inputs[0];
    const input1 = this._inputs[1];
    const stepR = state._getFreeVariableName("stepR");
    const stepG = state._getFreeVariableName("stepG");
    state.compilationString += `float ${stepR} = step(0.5, ${input0.associatedVariableName}.r);\r
`;
    state.compilationString += `float ${stepG} = step(0.5, ${input0.associatedVariableName}.g);\r
`;
    state.compilationString += this._declareOutput(output, state) + `;\r
`;
    state.compilationString += `${output.associatedVariableName}.r = (1.0 - ${stepR}) * ${input0.associatedVariableName}.r * ${input1.associatedVariableName}.r * 2.0 + ${stepR} * (1.0 - (1.0 - ${input0.associatedVariableName}.r) * (1.0 - ${input1.associatedVariableName}.r) * 2.0);\r
`;
    state.compilationString += `${output.associatedVariableName}.g = (1.0 - ${stepG}) * ${input0.associatedVariableName}.g * ${input1.associatedVariableName}.g * 2.0 + ${stepG} * (1.0 - (1.0 - ${input0.associatedVariableName}.g) * (1.0 - ${input1.associatedVariableName}.g) * 2.0);\r
`;
    state.compilationString += `${output.associatedVariableName}.b = ${input0.associatedVariableName}.b * ${input1.associatedVariableName}.b;\r
`;
    return this;
  }
};
RegisterClass("BABYLON.NormalBlendBlock", NormalBlendBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/rotate2dBlock.js
var Rotate2dBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerInput("angle", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector2);
  }
  getClassName() {
    return "Rotate2dBlock";
  }
  get input() {
    return this._inputs[0];
  }
  get angle() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.angle.isConnected) {
      const angleInput = new InputBlock("angle");
      angleInput.value = 0;
      angleInput.output.connectTo(this.angle);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const angle = this.angle;
    const input = this.input;
    state.compilationString += this._declareOutput(output, state) + ` = vec2(cos(${angle.associatedVariableName}) * ${input.associatedVariableName}.x - sin(${angle.associatedVariableName}) * ${input.associatedVariableName}.y, sin(${angle.associatedVariableName}) * ${input.associatedVariableName}.x + cos(${angle.associatedVariableName}) * ${input.associatedVariableName}.y);\r
`;
    return this;
  }
};
RegisterClass("BABYLON.Rotate2dBlock", Rotate2dBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/reflectBlock.js
var ReflectBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("incident", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("normal", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector3);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4);
    this._inputs[1].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4);
  }
  getClassName() {
    return "ReflectBlock";
  }
  get incident() {
    return this._inputs[0];
  }
  get normal() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = reflect(${this.incident.associatedVariableName}.xyz, ${this.normal.associatedVariableName}.xyz);\r
`;
    return this;
  }
};
RegisterClass("BABYLON.ReflectBlock", ReflectBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/refractBlock.js
var RefractBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("incident", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("normal", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("ior", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector3);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4);
    this._inputs[1].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4);
  }
  getClassName() {
    return "RefractBlock";
  }
  get incident() {
    return this._inputs[0];
  }
  get normal() {
    return this._inputs[1];
  }
  get ior() {
    return this._inputs[2];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = refract(${this.incident.associatedVariableName}.xyz, ${this.normal.associatedVariableName}.xyz, ${this.ior.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.RefractBlock", RefractBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/desaturateBlock.js
var DesaturateBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color3);
    this.registerInput("level", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Color3);
  }
  getClassName() {
    return "DesaturateBlock";
  }
  get color() {
    return this._inputs[0];
  }
  get level() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const color = this.color;
    const colorName = color.associatedVariableName;
    const tempMin = state._getFreeVariableName("colorMin");
    const tempMax = state._getFreeVariableName("colorMax");
    const tempMerge = state._getFreeVariableName("colorMerge");
    state.compilationString += `float ${tempMin} = min(min(${colorName}.x, ${colorName}.y), ${colorName}.z);\r
`;
    state.compilationString += `float ${tempMax} = max(max(${colorName}.x, ${colorName}.y), ${colorName}.z);\r
`;
    state.compilationString += `float ${tempMerge} = 0.5 * (${tempMin} + ${tempMax});\r
`;
    state.compilationString += this._declareOutput(output, state) + ` = mix(${colorName}, vec3(${tempMerge}, ${tempMerge}, ${tempMerge}), ${this.level.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.DesaturateBlock", DesaturateBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/sheenBlock.js
var SheenBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this.albedoScaling = false;
    this.linkSheenWithAlbedo = false;
    this._isUnique = true;
    this.registerInput("intensity", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("roughness", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("sheen", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("sheen", this, NodeMaterialConnectionPointDirection.Output, SheenBlock, "SheenBlock"));
  }
  initialize(state) {
    state._excludeVariableName("sheenOut");
    state._excludeVariableName("sheenMapData");
    state._excludeVariableName("vSheenColor");
    state._excludeVariableName("vSheenRoughness");
  }
  getClassName() {
    return "SheenBlock";
  }
  get intensity() {
    return this._inputs[0];
  }
  get color() {
    return this._inputs[1];
  }
  get roughness() {
    return this._inputs[2];
  }
  get sheen() {
    return this._outputs[0];
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    super.prepareDefines(mesh, nodeMaterial, defines);
    defines.setValue("SHEEN", true);
    defines.setValue("SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE", true, true);
    defines.setValue("SHEEN_LINKWITHALBEDO", this.linkSheenWithAlbedo, true);
    defines.setValue("SHEEN_ROUGHNESS", this.roughness.isConnected, true);
    defines.setValue("SHEEN_ALBEDOSCALING", this.albedoScaling, true);
  }
  getCode(reflectionBlock) {
    let code = "";
    const color = this.color.isConnected ? this.color.associatedVariableName : "vec3(1.)";
    const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : "1.";
    const roughness = this.roughness.isConnected ? this.roughness.associatedVariableName : "0.";
    const texture = "vec4(0.)";
    code = `#ifdef SHEEN
            sheenOutParams sheenOut;

            vec4 vSheenColor = vec4(${color}, ${intensity});

            sheenBlock(
                vSheenColor,
            #ifdef SHEEN_ROUGHNESS
                ${roughness},
            #endif
                roughness,
            #ifdef SHEEN_TEXTURE
                ${texture},
                1.0,
            #endif
                reflectance,
            #ifdef SHEEN_LINKWITHALBEDO
                baseColor,
                surfaceAlbedo,
            #endif
            #ifdef ENVIRONMENTBRDF
                NdotV,
                environmentBrdf,
            #endif
            #if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
                AARoughnessFactors,
                ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._vReflectionMicrosurfaceInfosName},
                ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._vReflectionInfosName},
                ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock.reflectionColor},
                vLightingIntensity,
                #ifdef ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName}
                    ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName},
                #else
                    ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._2DSamplerName},
                #endif
                reflectionOut.reflectionCoords,
                NdotVUnclamped,
                #ifndef LODBASEDMICROSFURACE
                    #ifdef ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName}
                        ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName},
                        ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName},
                    #else
                        ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._2DSamplerName},
                        ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._2DSamplerName},
                    #endif
                #endif
                #if !defined(${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName}) && defined(RADIANCEOCCLUSION)
                    seo,
                #endif
                #if !defined(${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName}) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName})
                    eho,
                #endif
            #endif
                sheenOut
            );

            #ifdef SHEEN_LINKWITHALBEDO
                surfaceAlbedo = sheenOut.surfaceAlbedo;
            #endif
        #endif\r
`;
    return code;
  }
  _buildBlock(state) {
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.blocksWithDefines.push(this);
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.albedoScaling = ${this.albedoScaling};\r
`;
    codeString += `${this._codeVariableName}.linkSheenWithAlbedo = ${this.linkSheenWithAlbedo};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.albedoScaling = this.albedoScaling;
    serializationObject.linkSheenWithAlbedo = this.linkSheenWithAlbedo;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.albedoScaling = serializationObject.albedoScaling;
    this.linkSheenWithAlbedo = serializationObject.linkSheenWithAlbedo;
  }
};
__decorate([
  editableInPropertyPage("Albedo scaling", PropertyTypeForEdition.Boolean, "PROPERTIES", { notifiers: { update: true } })
], SheenBlock.prototype, "albedoScaling", void 0);
__decorate([
  editableInPropertyPage("Link sheen with albedo", PropertyTypeForEdition.Boolean, "PROPERTIES", { notifiers: { update: true } })
], SheenBlock.prototype, "linkSheenWithAlbedo", void 0);
RegisterClass("BABYLON.SheenBlock", SheenBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/anisotropyBlock.js
var AnisotropyBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this._tangentCorrectionFactorName = "";
    this._isUnique = true;
    this.registerInput("intensity", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("direction", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2, true);
    this.registerInput("worldTangent", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("TBN", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("TBN", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, "TBNBlock"));
    this.registerOutput("anisotropy", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("anisotropy", this, NodeMaterialConnectionPointDirection.Output, AnisotropyBlock, "AnisotropyBlock"));
  }
  initialize(state) {
    state._excludeVariableName("anisotropicOut");
    state._excludeVariableName("TBN");
  }
  getClassName() {
    return "AnisotropyBlock";
  }
  get intensity() {
    return this._inputs[0];
  }
  get direction() {
    return this._inputs[1];
  }
  get uv() {
    return this._inputs[2];
  }
  get worldTangent() {
    return this._inputs[3];
  }
  get TBN() {
    return this._inputs[4];
  }
  get anisotropy() {
    return this._outputs[0];
  }
  _generateTBNSpace(state) {
    let code = "";
    const comments = `//${this.name}`;
    const uv = this.uv;
    const worldPosition = this.worldPositionConnectionPoint;
    const worldNormal = this.worldNormalConnectionPoint;
    const worldTangent = this.worldTangent;
    if (!uv.isConnected) {
      console.error("You must connect the 'uv' input of the Anisotropy block!");
    }
    state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    const tangentReplaceString = { search: /defined\(TANGENT\)/g, replace: worldTangent.isConnected ? "defined(TANGENT)" : "defined(IGNORE)" };
    const TBN = this.TBN;
    if (TBN.isConnected) {
      state.compilationString += `
            #ifdef TBNBLOCK
            mat3 vTBN = ${TBN.associatedVariableName};
            #endif
            `;
    } else if (worldTangent.isConnected) {
      code += `vec3 tbnNormal = normalize(${worldNormal.associatedVariableName}.xyz);\r
`;
      code += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\r
`;
      code += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\r
`;
      code += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\r
`;
    }
    code += `
            #if defined(${worldTangent.isConnected ? "TANGENT" : "IGNORE"}) && defined(NORMAL)
                mat3 TBN = vTBN;
            #else
                mat3 TBN = cotangent_frame(${worldNormal.associatedVariableName + ".xyz"}, ${"v_" + worldPosition.associatedVariableName + ".xyz"}, ${uv.isConnected ? uv.associatedVariableName : "vec2(0.)"}, vec2(1., 1.));
            #endif\r
`;
    state._emitFunctionFromInclude("bumpFragmentMainFunctions", comments, {
      replaceStrings: [tangentReplaceString]
    });
    return code;
  }
  getCode(state, generateTBNSpace = false) {
    let code = "";
    if (generateTBNSpace) {
      code += this._generateTBNSpace(state);
    }
    const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : "1.0";
    const direction = this.direction.isConnected ? this.direction.associatedVariableName : "vec2(1., 0.)";
    code += `anisotropicOutParams anisotropicOut;
            anisotropicBlock(
                vec3(${direction}, ${intensity}),
            #ifdef ANISOTROPIC_TEXTURE
                vec3(0.),
            #endif
                TBN,
                normalW,
                viewDirectionW,
                anisotropicOut
            );\r
`;
    return code;
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    super.prepareDefines(mesh, nodeMaterial, defines);
    defines.setValue("ANISOTROPIC", true);
    defines.setValue("ANISOTROPIC_TEXTURE", false, true);
  }
  bind(effect, nodeMaterial, mesh) {
    super.bind(effect, nodeMaterial, mesh);
    if (mesh) {
      effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);
    }
  }
  _buildBlock(state) {
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.blocksWithDefines.push(this);
      state.sharedData.bindableBlocks.push(this);
      this._tangentCorrectionFactorName = state._getFreeDefineName("tangentCorrectionFactor");
      state._emitUniformFromString(this._tangentCorrectionFactorName, "float");
    }
    return this;
  }
};
RegisterClass("BABYLON.AnisotropyBlock", AnisotropyBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/reflectionBlock.js
var ReflectionBlock = class extends ReflectionTextureBaseBlock {
  constructor(name137) {
    super(name137);
    this.useSphericalHarmonics = true;
    this.forceIrradianceInFragment = false;
    this._isUnique = true;
    this.registerInput("position", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("reflection", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("reflection", this, NodeMaterialConnectionPointDirection.Output, ReflectionBlock, "ReflectionBlock"));
    this.position.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  _onGenerateOnlyFragmentCodeChanged() {
    if (this.position.isConnected) {
      this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;
      console.error("The position input must not be connected to be able to switch!");
      return false;
    }
    this._setTarget();
    return true;
  }
  _setTarget() {
    super._setTarget();
    this.getInputByName("position").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;
    if (this.generateOnlyFragmentCode) {
      this.forceIrradianceInFragment = true;
    }
  }
  getClassName() {
    return "ReflectionBlock";
  }
  get position() {
    return this._inputs[0];
  }
  get worldPosition() {
    return this.worldPositionConnectionPoint;
  }
  get worldNormal() {
    return this.worldNormalConnectionPoint;
  }
  get world() {
    return this._inputs[1];
  }
  get cameraPosition() {
    return this.cameraPositionConnectionPoint;
  }
  get view() {
    return this.viewConnectionPoint;
  }
  get color() {
    return this._inputs[2];
  }
  get reflection() {
    return this._outputs[0];
  }
  get hasTexture() {
    return !!this._getTexture();
  }
  get reflectionColor() {
    return this.color.isConnected ? this.color.associatedVariableName : "vec3(1., 1., 1.)";
  }
  _getTexture() {
    if (this.texture) {
      return this.texture;
    }
    return this._scene.environmentTexture;
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    super.prepareDefines(mesh, nodeMaterial, defines);
    const reflectionTexture = this._getTexture();
    const reflection = reflectionTexture && reflectionTexture.getTextureMatrix;
    defines.setValue("REFLECTION", reflection, true);
    if (!reflection) {
      return;
    }
    defines.setValue(this._defineLODReflectionAlpha, reflectionTexture.lodLevelInAlpha, true);
    defines.setValue(this._defineLinearSpecularReflection, reflectionTexture.linearSpecularLOD, true);
    defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ, true);
    defines.setValue("SPHERICAL_HARMONICS", this.useSphericalHarmonics, true);
    defines.setValue("GAMMAREFLECTION", reflectionTexture.gammaSpace, true);
    defines.setValue("RGBDREFLECTION", reflectionTexture.isRGBD, true);
    if (reflectionTexture && reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {
      if (reflectionTexture.isCube) {
        defines.setValue("USESPHERICALFROMREFLECTIONMAP", true);
        defines.setValue("USEIRRADIANCEMAP", false);
        if (this.forceIrradianceInFragment || this._scene.getEngine().getCaps().maxVaryingVectors <= 8) {
          defines.setValue("USESPHERICALINVERTEX", false);
        } else {
          defines.setValue("USESPHERICALINVERTEX", true);
        }
      }
    }
  }
  bind(effect, nodeMaterial, mesh, subMesh) {
    super.bind(effect, nodeMaterial, mesh);
    const reflectionTexture = this._getTexture();
    if (!reflectionTexture || !subMesh) {
      return;
    }
    if (reflectionTexture.isCube) {
      effect.setTexture(this._cubeSamplerName, reflectionTexture);
    } else {
      effect.setTexture(this._2DSamplerName, reflectionTexture);
    }
    const width = reflectionTexture.getSize().width;
    effect.setFloat3(this._vReflectionMicrosurfaceInfosName, width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);
    effect.setFloat2(this._vReflectionFilteringInfoName, width, Scalar.Log2(width));
    const defines = subMesh.materialDefines;
    const polynomials = reflectionTexture.sphericalPolynomial;
    if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {
      if (defines.SPHERICAL_HARMONICS) {
        const preScaledHarmonics = polynomials.preScaledHarmonics;
        effect.setVector3("vSphericalL00", preScaledHarmonics.l00);
        effect.setVector3("vSphericalL1_1", preScaledHarmonics.l1_1);
        effect.setVector3("vSphericalL10", preScaledHarmonics.l10);
        effect.setVector3("vSphericalL11", preScaledHarmonics.l11);
        effect.setVector3("vSphericalL2_2", preScaledHarmonics.l2_2);
        effect.setVector3("vSphericalL2_1", preScaledHarmonics.l2_1);
        effect.setVector3("vSphericalL20", preScaledHarmonics.l20);
        effect.setVector3("vSphericalL21", preScaledHarmonics.l21);
        effect.setVector3("vSphericalL22", preScaledHarmonics.l22);
      } else {
        effect.setFloat3("vSphericalX", polynomials.x.x, polynomials.x.y, polynomials.x.z);
        effect.setFloat3("vSphericalY", polynomials.y.x, polynomials.y.y, polynomials.y.z);
        effect.setFloat3("vSphericalZ", polynomials.z.x, polynomials.z.y, polynomials.z.z);
        effect.setFloat3("vSphericalXX_ZZ", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);
        effect.setFloat3("vSphericalYY_ZZ", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);
        effect.setFloat3("vSphericalZZ", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);
        effect.setFloat3("vSphericalXY", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);
        effect.setFloat3("vSphericalYZ", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);
        effect.setFloat3("vSphericalZX", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);
      }
    }
  }
  handleVertexSide(state) {
    let code = super.handleVertexSide(state);
    state._emitFunctionFromInclude("harmonicsFunctions", `//${this.name}`, {
      replaceStrings: [
        { search: /uniform vec3 vSphericalL00;[\s\S]*?uniform vec3 vSphericalL22;/g, replace: "" },
        { search: /uniform vec3 vSphericalX;[\s\S]*?uniform vec3 vSphericalZX;/g, replace: "" }
      ]
    });
    const reflectionVectorName = state._getFreeVariableName("reflectionVector");
    this._vEnvironmentIrradianceName = state._getFreeVariableName("vEnvironmentIrradiance");
    state._emitVaryingFromString(this._vEnvironmentIrradianceName, "vec3", "defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)");
    state._emitUniformFromString("vSphericalL00", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL1_1", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL10", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL11", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL2_2", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL2_1", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL20", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL21", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL22", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalX", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalY", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalZ", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalXX_ZZ", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalYY_ZZ", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalZZ", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalXY", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalYZ", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalZX", "vec3", "SPHERICAL_HARMONICS", true);
    code += `#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
                vec3 ${reflectionVectorName} = vec3(${this._reflectionMatrixName} * vec4(normalize(${this.worldNormal.associatedVariableName}).xyz, 0)).xyz;
                #ifdef ${this._defineOppositeZ}
                    ${reflectionVectorName}.z *= -1.0;
                #endif
                ${this._vEnvironmentIrradianceName} = computeEnvironmentIrradiance(${reflectionVectorName});
            #endif\r
`;
    return code;
  }
  getCode(state, normalVarName) {
    let code = "";
    this.handleFragmentSideInits(state);
    state._emitFunctionFromInclude("harmonicsFunctions", `//${this.name}`, {
      replaceStrings: [
        { search: /uniform vec3 vSphericalL00;[\s\S]*?uniform vec3 vSphericalL22;/g, replace: "" },
        { search: /uniform vec3 vSphericalX;[\s\S]*?uniform vec3 vSphericalZX;/g, replace: "" }
      ]
    });
    state._emitFunction("sampleReflection", `
            #ifdef ${this._define3DName}
                #define sampleReflection(s, c) textureCube(s, c)
            #else
                #define sampleReflection(s, c) texture2D(s, c)
            #endif\r
`, `//${this.name}`);
    state._emitFunction("sampleReflectionLod", `
            #ifdef ${this._define3DName}
                #define sampleReflectionLod(s, c, l) textureCubeLodEXT(s, c, l)
            #else
                #define sampleReflectionLod(s, c, l) texture2DLodEXT(s, c, l)
            #endif\r
`, `//${this.name}`);
    const computeReflectionCoordsFunc = `
            vec3 computeReflectionCoordsPBR(vec4 worldPos, vec3 worldNormal) {
                ${this.handleFragmentSideCodeReflectionCoords("worldNormal", "worldPos", true, true)}
                return ${this._reflectionVectorName};
            }\r
`;
    state._emitFunction("computeReflectionCoordsPBR", computeReflectionCoordsFunc, `//${this.name}`);
    this._vReflectionMicrosurfaceInfosName = state._getFreeVariableName("vReflectionMicrosurfaceInfos");
    state._emitUniformFromString(this._vReflectionMicrosurfaceInfosName, "vec3");
    this._vReflectionInfosName = state._getFreeVariableName("vReflectionInfos");
    this._vReflectionFilteringInfoName = state._getFreeVariableName("vReflectionFilteringInfo");
    state._emitUniformFromString(this._vReflectionFilteringInfoName, "vec2");
    code += `#ifdef REFLECTION
            vec2 ${this._vReflectionInfosName} = vec2(1., 0.);

            reflectionOutParams reflectionOut;

            reflectionBlock(
                ${this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : "v_" + this.worldPosition.associatedVariableName}.xyz,
                ${normalVarName},
                alphaG,
                ${this._vReflectionMicrosurfaceInfosName},
                ${this._vReflectionInfosName},
                ${this.reflectionColor},
            #ifdef ANISOTROPIC
                anisotropicOut,
            #endif
            #if defined(${this._defineLODReflectionAlpha}) && !defined(${this._defineSkyboxName})
                NdotVUnclamped,
            #endif
            #ifdef ${this._defineLinearSpecularReflection}
                roughness,
            #endif
            #ifdef ${this._define3DName}
                ${this._cubeSamplerName},
            #else
                ${this._2DSamplerName},
            #endif
            #if defined(NORMAL) && defined(USESPHERICALINVERTEX)
                ${this._vEnvironmentIrradianceName},
            #endif
            #ifdef USESPHERICALFROMREFLECTIONMAP
                #if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
                    ${this._reflectionMatrixName},
                #endif
            #endif
            #ifdef USEIRRADIANCEMAP
                irradianceSampler, // ** not handled **
            #endif
            #ifndef LODBASEDMICROSFURACE
                #ifdef ${this._define3DName}
                    ${this._cubeSamplerName},
                    ${this._cubeSamplerName},
                #else
                    ${this._2DSamplerName},
                    ${this._2DSamplerName},
                #endif
            #endif
            #ifdef REALTIME_FILTERING
                ${this._vReflectionFilteringInfoName},
            #endif
                reflectionOut
            );
        #endif\r
`;
    return code;
  }
  _buildBlock(state) {
    this._scene = state.sharedData.scene;
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      this._defineLODReflectionAlpha = state._getFreeDefineName("LODINREFLECTIONALPHA");
      this._defineLinearSpecularReflection = state._getFreeDefineName("LINEARSPECULARREFLECTION");
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    if (this.texture) {
      codeString += `${this._codeVariableName}.texture.gammaSpace = ${this.texture.gammaSpace};\r
`;
    }
    codeString += `${this._codeVariableName}.useSphericalHarmonics = ${this.useSphericalHarmonics};\r
`;
    codeString += `${this._codeVariableName}.forceIrradianceInFragment = ${this.forceIrradianceInFragment};\r
`;
    return codeString;
  }
  serialize() {
    var _a, _b;
    const serializationObject = super.serialize();
    serializationObject.useSphericalHarmonics = this.useSphericalHarmonics;
    serializationObject.forceIrradianceInFragment = this.forceIrradianceInFragment;
    serializationObject.gammaSpace = (_b = (_a = this.texture) === null || _a === void 0 ? void 0 : _a.gammaSpace) !== null && _b !== void 0 ? _b : true;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.useSphericalHarmonics = serializationObject.useSphericalHarmonics;
    this.forceIrradianceInFragment = serializationObject.forceIrradianceInFragment;
    if (this.texture) {
      this.texture.gammaSpace = serializationObject.gammaSpace;
    }
  }
};
__decorate([
  editableInPropertyPage("Spherical Harmonics", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { update: true } })
], ReflectionBlock.prototype, "useSphericalHarmonics", void 0);
__decorate([
  editableInPropertyPage("Force irradiance in fragment", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { update: true } })
], ReflectionBlock.prototype, "forceIrradianceInFragment", void 0);
RegisterClass("BABYLON.ReflectionBlock", ReflectionBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/clearCoatBlock.js
var ClearCoatBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this._tangentCorrectionFactorName = "";
    this.remapF0OnInterfaceChange = true;
    this._isUnique = true;
    this.registerInput("intensity", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("roughness", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("indexOfRefraction", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("normalMapColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("tintColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("tintAtDistance", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("tintThickness", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("worldTangent", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.worldNormal.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("TBN", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("TBN", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, "TBNBlock"));
    this.registerOutput("clearcoat", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("clearcoat", this, NodeMaterialConnectionPointDirection.Output, ClearCoatBlock, "ClearCoatBlock"));
  }
  initialize(state) {
    state._excludeVariableName("clearcoatOut");
    state._excludeVariableName("vClearCoatParams");
    state._excludeVariableName("vClearCoatTintParams");
    state._excludeVariableName("vClearCoatRefractionParams");
    state._excludeVariableName("vClearCoatTangentSpaceParams");
    state._excludeVariableName("vGeometricNormaClearCoatW");
  }
  getClassName() {
    return "ClearCoatBlock";
  }
  get intensity() {
    return this._inputs[0];
  }
  get roughness() {
    return this._inputs[1];
  }
  get indexOfRefraction() {
    return this._inputs[2];
  }
  get normalMapColor() {
    return this._inputs[3];
  }
  get uv() {
    return this._inputs[4];
  }
  get tintColor() {
    return this._inputs[5];
  }
  get tintAtDistance() {
    return this._inputs[6];
  }
  get tintThickness() {
    return this._inputs[7];
  }
  get worldTangent() {
    return this._inputs[8];
  }
  get worldNormal() {
    return this._inputs[9];
  }
  get TBN() {
    return this._inputs[10];
  }
  get clearcoat() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.intensity.isConnected) {
      const intensityInput = new InputBlock("ClearCoat intensity", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);
      intensityInput.value = 1;
      intensityInput.output.connectTo(this.intensity);
    }
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    super.prepareDefines(mesh, nodeMaterial, defines);
    defines.setValue("CLEARCOAT", true);
    defines.setValue("CLEARCOAT_TEXTURE", false, true);
    defines.setValue("CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE", true, true);
    defines.setValue("CLEARCOAT_TINT", this.tintColor.isConnected || this.tintThickness.isConnected || this.tintAtDistance.isConnected, true);
    defines.setValue("CLEARCOAT_BUMP", this.normalMapColor.isConnected, true);
    defines.setValue("CLEARCOAT_DEFAULTIOR", this.indexOfRefraction.isConnected ? this.indexOfRefraction.connectInputBlock.value === PBRClearCoatConfiguration._DefaultIndexOfRefraction : true, true);
    defines.setValue("CLEARCOAT_REMAP_F0", this.remapF0OnInterfaceChange, true);
  }
  bind(effect, nodeMaterial, mesh) {
    var _a, _b;
    super.bind(effect, nodeMaterial, mesh);
    const indexOfRefraction = (_b = (_a = this.indexOfRefraction.connectInputBlock) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : PBRClearCoatConfiguration._DefaultIndexOfRefraction;
    const a = 1 - indexOfRefraction;
    const b = 1 + indexOfRefraction;
    const f0 = Math.pow(-a / b, 2);
    const eta = 1 / indexOfRefraction;
    effect.setFloat4("vClearCoatRefractionParams", f0, eta, a, b);
    const mainPBRBlock = this.clearcoat.hasEndpoints ? this.clearcoat.endpoints[0].ownerBlock : null;
    const perturbedNormalBlock = (mainPBRBlock === null || mainPBRBlock === void 0 ? void 0 : mainPBRBlock.perturbedNormal.isConnected) ? mainPBRBlock.perturbedNormal.connectedPoint.ownerBlock : null;
    if (this._scene._mirroredCameraPosition) {
      effect.setFloat2("vClearCoatTangentSpaceParams", (perturbedNormalBlock === null || perturbedNormalBlock === void 0 ? void 0 : perturbedNormalBlock.invertX) ? 1 : -1, (perturbedNormalBlock === null || perturbedNormalBlock === void 0 ? void 0 : perturbedNormalBlock.invertY) ? 1 : -1);
    } else {
      effect.setFloat2("vClearCoatTangentSpaceParams", (perturbedNormalBlock === null || perturbedNormalBlock === void 0 ? void 0 : perturbedNormalBlock.invertX) ? -1 : 1, (perturbedNormalBlock === null || perturbedNormalBlock === void 0 ? void 0 : perturbedNormalBlock.invertY) ? -1 : 1);
    }
    if (mesh) {
      effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);
    }
  }
  _generateTBNSpace(state, worldPositionVarName, worldNormalVarName) {
    let code = "";
    const comments = `//${this.name}`;
    const worldTangent = this.worldTangent;
    state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    const tangentReplaceString = { search: /defined\(TANGENT\)/g, replace: worldTangent.isConnected ? "defined(TANGENT)" : "defined(IGNORE)" };
    const TBN = this.TBN;
    if (TBN.isConnected) {
      state.compilationString += `
            #ifdef TBNBLOCK
            mat3 vTBN = ${TBN.associatedVariableName};
            #endif
            `;
    } else if (worldTangent.isConnected) {
      code += `vec3 tbnNormal = normalize(${worldNormalVarName}.xyz);\r
`;
      code += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\r
`;
      code += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\r
`;
      code += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\r
`;
    }
    state._emitFunctionFromInclude("bumpFragmentMainFunctions", comments, {
      replaceStrings: [tangentReplaceString]
    });
    return code;
  }
  static GetCode(state, ccBlock, reflectionBlock, worldPosVarName, generateTBNSpace, vTBNAvailable, worldNormalVarName) {
    let code = "";
    const intensity = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.intensity.isConnected) ? ccBlock.intensity.associatedVariableName : "1.";
    const roughness = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.roughness.isConnected) ? ccBlock.roughness.associatedVariableName : "0.";
    const normalMapColor = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.normalMapColor.isConnected) ? ccBlock.normalMapColor.associatedVariableName : "vec3(0.)";
    const uv = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.uv.isConnected) ? ccBlock.uv.associatedVariableName : "vec2(0.)";
    const tintColor = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.tintColor.isConnected) ? ccBlock.tintColor.associatedVariableName : "vec3(1.)";
    const tintThickness = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.tintThickness.isConnected) ? ccBlock.tintThickness.associatedVariableName : "1.";
    const tintAtDistance = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.tintAtDistance.isConnected) ? ccBlock.tintAtDistance.associatedVariableName : "1.";
    const tintTexture = "vec4(0.)";
    if (ccBlock) {
      state._emitUniformFromString("vClearCoatRefractionParams", "vec4");
      state._emitUniformFromString("vClearCoatTangentSpaceParams", "vec2");
      const normalShading = ccBlock.worldNormal;
      code += `vec3 vGeometricNormaClearCoatW = ${normalShading.isConnected ? "normalize(" + normalShading.associatedVariableName + ".xyz)" : "geometricNormalW"};\r
`;
    } else {
      code += `vec3 vGeometricNormaClearCoatW = geometricNormalW;\r
`;
    }
    if (generateTBNSpace && ccBlock) {
      code += ccBlock._generateTBNSpace(state, worldPosVarName, worldNormalVarName);
      vTBNAvailable = ccBlock.worldTangent.isConnected;
    }
    code += `clearcoatOutParams clearcoatOut;

        #ifdef CLEARCOAT
            vec2 vClearCoatParams = vec2(${intensity}, ${roughness});
            vec4 vClearCoatTintParams = vec4(${tintColor}, ${tintThickness});

            clearcoatBlock(
                ${worldPosVarName}.xyz,
                vGeometricNormaClearCoatW,
                viewDirectionW,
                vClearCoatParams,
                specularEnvironmentR0,
            #ifdef CLEARCOAT_TEXTURE
                vec2(0.),
            #endif
            #ifdef CLEARCOAT_TINT
                vClearCoatTintParams,
                ${tintAtDistance},
                vClearCoatRefractionParams,
                #ifdef CLEARCOAT_TINT_TEXTURE
                    ${tintTexture},
                #endif
            #endif
            #ifdef CLEARCOAT_BUMP
                vec2(0., 1.),
                vec4(${normalMapColor}, 0.),
                ${uv},
                #if defined(${vTBNAvailable ? "TANGENT" : "IGNORE"}) && defined(NORMAL)
                    vTBN,
                #else
                    vClearCoatTangentSpaceParams,
                #endif
                #ifdef OBJECTSPACE_NORMALMAP
                    normalMatrix,
                #endif
            #endif
            #if defined(FORCENORMALFORWARD) && defined(NORMAL)
                faceNormal,
            #endif
            #ifdef REFLECTION
                ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._vReflectionMicrosurfaceInfosName},
                ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._vReflectionInfosName},
                ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock.reflectionColor},
                vLightingIntensity,
                #ifdef ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName}
                    ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName},
                #else
                    ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._2DSamplerName},
                #endif
                #ifndef LODBASEDMICROSFURACE
                    #ifdef ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName}
                        ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName},
                        ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName},
                    #else
                        ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._2DSamplerName},
                        ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._2DSamplerName},
                    #endif
                #endif
            #endif
            #if defined(ENVIRONMENTBRDF) && !defined(${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName})
                #ifdef RADIANCEOCCLUSION
                    ambientMonochrome,
                #endif
            #endif
            #if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)
                (gl_FrontFacing ? 1. : -1.),
            #endif
                clearcoatOut
            );
        #else
            clearcoatOut.specularEnvironmentR0 = specularEnvironmentR0;
        #endif\r
`;
    return code;
  }
  _buildBlock(state) {
    this._scene = state.sharedData.scene;
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.bindableBlocks.push(this);
      state.sharedData.blocksWithDefines.push(this);
      this._tangentCorrectionFactorName = state._getFreeDefineName("tangentCorrectionFactor");
      state._emitUniformFromString(this._tangentCorrectionFactorName, "float");
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.remapF0OnInterfaceChange = ${this.remapF0OnInterfaceChange};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.remapF0OnInterfaceChange = this.remapF0OnInterfaceChange;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    var _a;
    super._deserialize(serializationObject, scene, rootUrl);
    this.remapF0OnInterfaceChange = (_a = serializationObject.remapF0OnInterfaceChange) !== null && _a !== void 0 ? _a : true;
  }
};
__decorate([
  editableInPropertyPage("Remap F0 on interface change", PropertyTypeForEdition.Boolean, "ADVANCED")
], ClearCoatBlock.prototype, "remapF0OnInterfaceChange", void 0);
RegisterClass("BABYLON.ClearCoatBlock", ClearCoatBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/iridescenceBlock.js
var IridescenceBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this._isUnique = true;
    this.registerInput("intensity", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("indexOfRefraction", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("thickness", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("iridescence", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("iridescence", this, NodeMaterialConnectionPointDirection.Output, IridescenceBlock, "IridescenceBlock"));
  }
  initialize(state) {
    state._excludeVariableName("iridescenceOut");
    state._excludeVariableName("vIridescenceParams");
  }
  getClassName() {
    return "IridescenceBlock";
  }
  get intensity() {
    return this._inputs[0];
  }
  get indexOfRefraction() {
    return this._inputs[1];
  }
  get thickness() {
    return this._inputs[2];
  }
  get iridescence() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.intensity.isConnected) {
      const intensityInput = new InputBlock("Iridescence intensity", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);
      intensityInput.value = 1;
      intensityInput.output.connectTo(this.intensity);
      const indexOfRefractionInput = new InputBlock("Iridescence ior", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);
      indexOfRefractionInput.value = 1.3;
      indexOfRefractionInput.output.connectTo(this.indexOfRefraction);
      const thicknessInput = new InputBlock("Iridescence thickness", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);
      thicknessInput.value = 400;
      thicknessInput.output.connectTo(this.thickness);
    }
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    super.prepareDefines(mesh, nodeMaterial, defines);
    defines.setValue("IRIDESCENCE", true, true);
    defines.setValue("IRIDESCENCE_TEXTURE", false, true);
    defines.setValue("IRIDESCENCE_THICKNESS_TEXTURE", false, true);
  }
  static GetCode(iridescenceBlock) {
    let code = "";
    const intensityName = (iridescenceBlock === null || iridescenceBlock === void 0 ? void 0 : iridescenceBlock.intensity.isConnected) ? iridescenceBlock.intensity.associatedVariableName : "1.";
    const indexOfRefraction = (iridescenceBlock === null || iridescenceBlock === void 0 ? void 0 : iridescenceBlock.indexOfRefraction.isConnected) ? iridescenceBlock.indexOfRefraction.associatedVariableName : PBRIridescenceConfiguration._DefaultIndexOfRefraction;
    const thickness = (iridescenceBlock === null || iridescenceBlock === void 0 ? void 0 : iridescenceBlock.thickness.isConnected) ? iridescenceBlock.thickness.associatedVariableName : PBRIridescenceConfiguration._DefaultMaximumThickness;
    code += `iridescenceOutParams iridescenceOut;

        #ifdef IRIDESCENCE
            iridescenceBlock(
                vec4(${intensityName}, ${indexOfRefraction}, 1., ${thickness}),
                NdotV,
                specularEnvironmentR0,
                #ifdef CLEARCOAT
                    NdotVUnclamped,
                #endif
                iridescenceOut
            );

            float iridescenceIntensity = iridescenceOut.iridescenceIntensity;
            specularEnvironmentR0 = iridescenceOut.specularEnvironmentR0;
        #endif\r
`;
    return code;
  }
  _buildBlock(state) {
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.bindableBlocks.push(this);
      state.sharedData.blocksWithDefines.push(this);
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
  }
};
RegisterClass("BABYLON.IridescenceBlock", IridescenceBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/refractionBlock.js
var RefractionBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this.linkRefractionWithTransparency = false;
    this.invertRefractionY = false;
    this.useThicknessAsDepth = false;
    this._isUnique = true;
    this.registerInput("intensity", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("tintAtDistance", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("volumeIndexOfRefraction", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("refraction", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("refraction", this, NodeMaterialConnectionPointDirection.Output, RefractionBlock, "RefractionBlock"));
  }
  initialize(state) {
    state._excludeVariableName("vRefractionPosition");
    state._excludeVariableName("vRefractionSize");
  }
  getClassName() {
    return "RefractionBlock";
  }
  get intensity() {
    return this._inputs[0];
  }
  get tintAtDistance() {
    return this._inputs[1];
  }
  get volumeIndexOfRefraction() {
    return this._inputs[2];
  }
  get view() {
    return this.viewConnectionPoint;
  }
  get refraction() {
    return this._outputs[0];
  }
  get hasTexture() {
    return !!this._getTexture();
  }
  _getTexture() {
    if (this.texture) {
      return this.texture;
    }
    return this._scene.environmentTexture;
  }
  autoConfigure(material) {
    if (!this.intensity.isConnected) {
      const intensityInput = new InputBlock("Refraction intensity", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);
      intensityInput.value = 1;
      intensityInput.output.connectTo(this.intensity);
    }
    if (this.view && !this.view.isConnected) {
      let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View);
      if (!viewInput) {
        viewInput = new InputBlock("view");
        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);
      }
      viewInput.output.connectTo(this.view);
    }
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    super.prepareDefines(mesh, nodeMaterial, defines);
    const refractionTexture = this._getTexture();
    const refraction = refractionTexture && refractionTexture.getTextureMatrix;
    defines.setValue("SS_REFRACTION", refraction, true);
    if (!refraction) {
      return;
    }
    defines.setValue(this._define3DName, refractionTexture.isCube, true);
    defines.setValue(this._defineLODRefractionAlpha, refractionTexture.lodLevelInAlpha, true);
    defines.setValue(this._defineLinearSpecularRefraction, refractionTexture.linearSpecularLOD, true);
    defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !refractionTexture.invertZ : refractionTexture.invertZ, true);
    defines.setValue("SS_LINKREFRACTIONTOTRANSPARENCY", this.linkRefractionWithTransparency, true);
    defines.setValue("SS_GAMMAREFRACTION", refractionTexture.gammaSpace, true);
    defines.setValue("SS_RGBDREFRACTION", refractionTexture.isRGBD, true);
    defines.setValue("SS_USE_LOCAL_REFRACTIONMAP_CUBIC", refractionTexture.boundingBoxSize ? true : false, true);
    defines.setValue("SS_USE_THICKNESS_AS_DEPTH", this.useThicknessAsDepth, true);
  }
  isReady() {
    const texture = this._getTexture();
    if (texture && !texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  bind(effect, nodeMaterial, mesh) {
    var _a, _b, _c, _d;
    super.bind(effect, nodeMaterial, mesh);
    const refractionTexture = this._getTexture();
    if (!refractionTexture) {
      return;
    }
    if (refractionTexture.isCube) {
      effect.setTexture(this._cubeSamplerName, refractionTexture);
    } else {
      effect.setTexture(this._2DSamplerName, refractionTexture);
    }
    effect.setMatrix(this._refractionMatrixName, refractionTexture.getReflectionTextureMatrix());
    let depth = 1;
    if (!refractionTexture.isCube) {
      if (refractionTexture.depth) {
        depth = refractionTexture.depth;
      }
    }
    const indexOfRefraction = (_d = (_b = (_a = this.volumeIndexOfRefraction.connectInputBlock) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : (_c = this.indexOfRefractionConnectionPoint.connectInputBlock) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : 1.5;
    effect.setFloat4(this._vRefractionInfosName, refractionTexture.level, 1 / indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);
    effect.setFloat4(this._vRefractionMicrosurfaceInfosName, refractionTexture.getSize().width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1 / indexOfRefraction);
    const width = refractionTexture.getSize().width;
    effect.setFloat2(this._vRefractionFilteringInfoName, width, Scalar.Log2(width));
    if (refractionTexture.boundingBoxSize) {
      const cubeTexture = refractionTexture;
      effect.setVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
      effect.setVector3("vRefractionSize", cubeTexture.boundingBoxSize);
    }
  }
  getCode(state) {
    const code = "";
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.textureBlocks.push(this);
    this._cubeSamplerName = state._getFreeVariableName(this.name + "CubeSampler");
    state.samplers.push(this._cubeSamplerName);
    this._2DSamplerName = state._getFreeVariableName(this.name + "2DSampler");
    state.samplers.push(this._2DSamplerName);
    this._define3DName = state._getFreeDefineName("SS_REFRACTIONMAP_3D");
    state._samplerDeclaration += `#ifdef ${this._define3DName}\r
`;
    state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\r
`;
    state._samplerDeclaration += `#else\r
`;
    state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\r
`;
    state._samplerDeclaration += `#endif\r
`;
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.bindableBlocks.push(this);
    this._defineLODRefractionAlpha = state._getFreeDefineName("SS_LODINREFRACTIONALPHA");
    this._defineLinearSpecularRefraction = state._getFreeDefineName("SS_LINEARSPECULARREFRACTION");
    this._defineOppositeZ = state._getFreeDefineName("SS_REFRACTIONMAP_OPPOSITEZ");
    this._refractionMatrixName = state._getFreeVariableName("refractionMatrix");
    state._emitUniformFromString(this._refractionMatrixName, "mat4");
    state._emitFunction("sampleRefraction", `
            #ifdef ${this._define3DName}
                #define sampleRefraction(s, c) textureCube(s, c)
            #else
                #define sampleRefraction(s, c) texture2D(s, c)
            #endif\r
`, `//${this.name}`);
    state._emitFunction("sampleRefractionLod", `
            #ifdef ${this._define3DName}
                #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)
            #else
                #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)
            #endif\r
`, `//${this.name}`);
    this._vRefractionMicrosurfaceInfosName = state._getFreeVariableName("vRefractionMicrosurfaceInfos");
    state._emitUniformFromString(this._vRefractionMicrosurfaceInfosName, "vec4");
    this._vRefractionInfosName = state._getFreeVariableName("vRefractionInfos");
    state._emitUniformFromString(this._vRefractionInfosName, "vec4");
    this._vRefractionFilteringInfoName = state._getFreeVariableName("vRefractionFilteringInfo");
    state._emitUniformFromString(this._vRefractionFilteringInfoName, "vec2");
    state._emitUniformFromString("vRefractionPosition", "vec3");
    state._emitUniformFromString("vRefractionSize", "vec3");
    return code;
  }
  _buildBlock(state) {
    this._scene = state.sharedData.scene;
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    if (this.texture) {
      if (this.texture.isCube) {
        codeString = `${this._codeVariableName}.texture = new BABYLON.CubeTexture("${this.texture.name}");\r
`;
      } else {
        codeString = `${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}");\r
`;
      }
      codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\r
`;
    }
    codeString += `${this._codeVariableName}.linkRefractionWithTransparency = ${this.linkRefractionWithTransparency};\r
`;
    codeString += `${this._codeVariableName}.invertRefractionY = ${this.invertRefractionY};\r
`;
    codeString += `${this._codeVariableName}.useThicknessAsDepth = ${this.useThicknessAsDepth};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    if (this.texture && !this.texture.isRenderTarget) {
      serializationObject.texture = this.texture.serialize();
    }
    serializationObject.linkRefractionWithTransparency = this.linkRefractionWithTransparency;
    serializationObject.invertRefractionY = this.invertRefractionY;
    serializationObject.useThicknessAsDepth = this.useThicknessAsDepth;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    if (serializationObject.texture) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      if (serializationObject.texture.isCube) {
        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);
      } else {
        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
      }
    }
    this.linkRefractionWithTransparency = serializationObject.linkRefractionWithTransparency;
    this.invertRefractionY = serializationObject.invertRefractionY;
    this.useThicknessAsDepth = !!serializationObject.useThicknessAsDepth;
  }
};
__decorate([
  editableInPropertyPage("Link refraction to transparency", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { update: true } })
], RefractionBlock.prototype, "linkRefractionWithTransparency", void 0);
__decorate([
  editableInPropertyPage("Invert refraction Y", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { update: true } })
], RefractionBlock.prototype, "invertRefractionY", void 0);
__decorate([
  editableInPropertyPage("Use thickness as depth", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { update: true } })
], RefractionBlock.prototype, "useThicknessAsDepth", void 0);
RegisterClass("BABYLON.RefractionBlock", RefractionBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/subSurfaceBlock.js
var SubSurfaceBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Fragment);
    this._isUnique = true;
    this.registerInput("thickness", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("tintColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("translucencyIntensity", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("translucencyDiffusionDist", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("refraction", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("refraction", this, NodeMaterialConnectionPointDirection.Input, RefractionBlock, "RefractionBlock"));
    this.registerOutput("subsurface", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("subsurface", this, NodeMaterialConnectionPointDirection.Output, SubSurfaceBlock, "SubSurfaceBlock"));
  }
  initialize(state) {
    state._excludeVariableName("subSurfaceOut");
    state._excludeVariableName("vThicknessParam");
    state._excludeVariableName("vTintColor");
    state._excludeVariableName("vSubSurfaceIntensity");
  }
  getClassName() {
    return "SubSurfaceBlock";
  }
  get thickness() {
    return this._inputs[0];
  }
  get tintColor() {
    return this._inputs[1];
  }
  get translucencyIntensity() {
    return this._inputs[2];
  }
  get translucencyDiffusionDist() {
    return this._inputs[3];
  }
  get refraction() {
    return this._inputs[4];
  }
  get subsurface() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.thickness.isConnected) {
      const thicknessInput = new InputBlock("SubSurface thickness", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);
      thicknessInput.value = 0;
      thicknessInput.output.connectTo(this.thickness);
    }
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    super.prepareDefines(mesh, nodeMaterial, defines);
    const translucencyEnabled = this.translucencyDiffusionDist.isConnected || this.translucencyIntensity.isConnected;
    defines.setValue("SUBSURFACE", translucencyEnabled || this.refraction.isConnected, true);
    defines.setValue("SS_TRANSLUCENCY", translucencyEnabled, true);
    defines.setValue("SS_THICKNESSANDMASK_TEXTURE", false, true);
    defines.setValue("SS_REFRACTIONINTENSITY_TEXTURE", false, true);
    defines.setValue("SS_TRANSLUCENCYINTENSITY_TEXTURE", false, true);
    defines.setValue("SS_MASK_FROM_THICKNESS_TEXTURE", false, true);
    defines.setValue("SS_USE_GLTF_TEXTURES", false, true);
  }
  static GetCode(state, ssBlock, reflectionBlock, worldPosVarName) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    let code = "";
    const thickness = (ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.thickness.isConnected) ? ssBlock.thickness.associatedVariableName : "0.";
    const tintColor = (ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.tintColor.isConnected) ? ssBlock.tintColor.associatedVariableName : "vec3(1.)";
    const translucencyIntensity = (ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.translucencyIntensity.isConnected) ? ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.translucencyIntensity.associatedVariableName : "1.";
    const translucencyDiffusionDistance = (ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.translucencyDiffusionDist.isConnected) ? ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.translucencyDiffusionDist.associatedVariableName : "vec3(1.)";
    const refractionBlock = (ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.refraction.isConnected) ? (_a = ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.refraction.connectedPoint) === null || _a === void 0 ? void 0 : _a.ownerBlock : null;
    const refractionTintAtDistance = (refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock.tintAtDistance.isConnected) ? refractionBlock.tintAtDistance.associatedVariableName : "1.";
    const refractionIntensity = (refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock.intensity.isConnected) ? refractionBlock.intensity.associatedVariableName : "1.";
    const refractionView = (refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock.view.isConnected) ? refractionBlock.view.associatedVariableName : "";
    code += (_b = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock.getCode(state)) !== null && _b !== void 0 ? _b : "";
    code += `subSurfaceOutParams subSurfaceOut;

        #ifdef SUBSURFACE
            vec2 vThicknessParam = vec2(0., ${thickness});
            vec4 vTintColor = vec4(${tintColor}, ${refractionTintAtDistance});
            vec3 vSubSurfaceIntensity = vec3(${refractionIntensity}, ${translucencyIntensity}, 0.);

            subSurfaceBlock(
                vSubSurfaceIntensity,
                vThicknessParam,
                vTintColor,
                normalW,
                specularEnvironmentReflectance,
            #ifdef SS_THICKNESSANDMASK_TEXTURE
                vec4(0.),
            #endif
            #ifdef REFLECTION
                #ifdef SS_TRANSLUCENCY
                    ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._reflectionMatrixName},
                    #ifdef USESPHERICALFROMREFLECTIONMAP
                        #if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
                            reflectionOut.irradianceVector,
                        #endif
                        #if defined(REALTIME_FILTERING)
                            ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName},
                            ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._vReflectionFilteringInfoName},
                        #endif
                        #endif
                    #ifdef USEIRRADIANCEMAP
                        irradianceSampler,
                    #endif
                #endif
            #endif
            #if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)
                surfaceAlbedo,
            #endif
            #ifdef SS_REFRACTION
                ${worldPosVarName}.xyz,
                viewDirectionW,
                ${refractionView},
                ${(_c = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._vRefractionInfosName) !== null && _c !== void 0 ? _c : ""},
                ${(_d = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._refractionMatrixName) !== null && _d !== void 0 ? _d : ""},
                ${(_e = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._vRefractionMicrosurfaceInfosName) !== null && _e !== void 0 ? _e : ""},
                vLightingIntensity,
                #ifdef SS_LINKREFRACTIONTOTRANSPARENCY
                    alpha,
                #endif
                #ifdef ${(_f = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._defineLODRefractionAlpha) !== null && _f !== void 0 ? _f : "IGNORE"}
                    NdotVUnclamped,
                #endif
                #ifdef ${(_g = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._defineLinearSpecularRefraction) !== null && _g !== void 0 ? _g : "IGNORE"}
                    roughness,
                #endif
                alphaG,
                #ifdef ${(_h = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._define3DName) !== null && _h !== void 0 ? _h : "IGNORE"}
                    ${(_j = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._cubeSamplerName) !== null && _j !== void 0 ? _j : ""},
                #else
                    ${(_k = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._2DSamplerName) !== null && _k !== void 0 ? _k : ""},
                #endif
                #ifndef LODBASEDMICROSFURACE
                    #ifdef ${(_l = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._define3DName) !== null && _l !== void 0 ? _l : "IGNORE"}
                        ${(_m = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._cubeSamplerName) !== null && _m !== void 0 ? _m : ""},
                        ${(_o = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._cubeSamplerName) !== null && _o !== void 0 ? _o : ""},
                    #else
                        ${(_p = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._2DSamplerName) !== null && _p !== void 0 ? _p : ""},
                        ${(_q = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._2DSamplerName) !== null && _q !== void 0 ? _q : ""},
                    #endif
                #endif
                #ifdef ANISOTROPIC
                    anisotropicOut,
                #endif
                #ifdef REALTIME_FILTERING
                    ${(_r = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._vRefractionFilteringInfoName) !== null && _r !== void 0 ? _r : ""},
                #endif
                #ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
                    vRefractionPosition,
                    vRefractionSize,
                #endif
            #endif
            #ifdef SS_TRANSLUCENCY
                ${translucencyDiffusionDistance},
            #endif
                subSurfaceOut
            );

            #ifdef SS_REFRACTION
                surfaceAlbedo = subSurfaceOut.surfaceAlbedo;
                #ifdef SS_LINKREFRACTIONTOTRANSPARENCY
                    alpha = subSurfaceOut.alpha;
                #endif
            #endif
        #else
            subSurfaceOut.specularEnvironmentReflectance = specularEnvironmentReflectance;
        #endif\r
`;
    return code;
  }
  _buildBlock(state) {
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.blocksWithDefines.push(this);
    }
    return this;
  }
};
RegisterClass("BABYLON.SubSurfaceBlock", SubSurfaceBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/pbrMetallicRoughnessBlock.js
var mapOutputToVariable = {
  ambientClr: ["finalAmbient", ""],
  diffuseDir: ["finalDiffuse", ""],
  specularDir: ["finalSpecularScaled", "!defined(UNLIT) && defined(SPECULARTERM)"],
  clearcoatDir: ["finalClearCoatScaled", "!defined(UNLIT) && defined(CLEARCOAT)"],
  sheenDir: ["finalSheenScaled", "!defined(UNLIT) && defined(SHEEN)"],
  diffuseInd: ["finalIrradiance", "!defined(UNLIT) && defined(REFLECTION)"],
  specularInd: ["finalRadianceScaled", "!defined(UNLIT) && defined(REFLECTION)"],
  clearcoatInd: ["clearcoatOut.finalClearCoatRadianceScaled", "!defined(UNLIT) && defined(REFLECTION) && defined(CLEARCOAT)"],
  sheenInd: ["sheenOut.finalSheenRadianceScaled", "!defined(UNLIT) && defined(REFLECTION) && defined(SHEEN) && defined(ENVIRONMENTBRDF)"],
  refraction: ["subSurfaceOut.finalRefraction", "!defined(UNLIT) && defined(SS_REFRACTION)"],
  lighting: ["finalColor.rgb", ""],
  shadow: ["shadow", ""],
  alpha: ["alpha", ""]
};
var PBRMetallicRoughnessBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.VertexAndFragment);
    this._environmentBRDFTexture = null;
    this._metallicReflectanceColor = Color3.White();
    this._metallicF0Factor = 1;
    this.directIntensity = 1;
    this.environmentIntensity = 1;
    this.specularIntensity = 1;
    this.lightFalloff = 0;
    this.useAlphaTest = false;
    this.alphaTestCutoff = 0.5;
    this.useAlphaBlending = false;
    this.useRadianceOverAlpha = true;
    this.useSpecularOverAlpha = true;
    this.enableSpecularAntiAliasing = false;
    this.realTimeFiltering = false;
    this.realTimeFilteringQuality = 8;
    this.useEnergyConservation = true;
    this.useRadianceOcclusion = true;
    this.useHorizonOcclusion = true;
    this.unlit = false;
    this.forceNormalForward = false;
    this.generateOnlyFragmentCode = false;
    this.debugMode = 0;
    this.debugLimit = 0;
    this.debugFactor = 1;
    this._isUnique = true;
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("view", NodeMaterialBlockConnectionPointTypes.Matrix, false);
    this.registerInput("cameraPosition", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("perturbedNormal", NodeMaterialBlockConnectionPointTypes.Vector4, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("baseColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("metallic", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("roughness", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("ambientOcc", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("opacity", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("indexOfRefraction", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("ambientColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("reflection", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("reflection", this, NodeMaterialConnectionPointDirection.Input, ReflectionBlock, "ReflectionBlock"));
    this.registerInput("clearcoat", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("clearcoat", this, NodeMaterialConnectionPointDirection.Input, ClearCoatBlock, "ClearCoatBlock"));
    this.registerInput("sheen", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("sheen", this, NodeMaterialConnectionPointDirection.Input, SheenBlock, "SheenBlock"));
    this.registerInput("subsurface", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("subsurface", this, NodeMaterialConnectionPointDirection.Input, SubSurfaceBlock, "SubSurfaceBlock"));
    this.registerInput("anisotropy", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("anisotropy", this, NodeMaterialConnectionPointDirection.Input, AnisotropyBlock, "AnisotropyBlock"));
    this.registerInput("iridescence", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("iridescence", this, NodeMaterialConnectionPointDirection.Input, IridescenceBlock, "IridescenceBlock"));
    this.registerOutput("ambientClr", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("diffuseDir", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("specularDir", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("clearcoatDir", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("sheenDir", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("diffuseInd", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("specularInd", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("clearcoatInd", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("sheenInd", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("refraction", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("lighting", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("shadow", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("alpha", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
  }
  static _OnGenerateOnlyFragmentCodeChanged(block, _propertyName) {
    const that = block;
    if (that.worldPosition.isConnected) {
      that.generateOnlyFragmentCode = !that.generateOnlyFragmentCode;
      console.error("The worldPosition input must not be connected to be able to switch!");
      return false;
    }
    that._setTarget();
    return true;
  }
  _setTarget() {
    this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);
    this.getInputByName("worldPosition").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;
  }
  initialize(state) {
    state._excludeVariableName("vLightingIntensity");
    state._excludeVariableName("geometricNormalW");
    state._excludeVariableName("normalW");
    state._excludeVariableName("faceNormal");
    state._excludeVariableName("albedoOpacityOut");
    state._excludeVariableName("surfaceAlbedo");
    state._excludeVariableName("alpha");
    state._excludeVariableName("aoOut");
    state._excludeVariableName("baseColor");
    state._excludeVariableName("reflectivityOut");
    state._excludeVariableName("microSurface");
    state._excludeVariableName("roughness");
    state._excludeVariableName("NdotVUnclamped");
    state._excludeVariableName("NdotV");
    state._excludeVariableName("alphaG");
    state._excludeVariableName("AARoughnessFactors");
    state._excludeVariableName("environmentBrdf");
    state._excludeVariableName("ambientMonochrome");
    state._excludeVariableName("seo");
    state._excludeVariableName("eho");
    state._excludeVariableName("environmentRadiance");
    state._excludeVariableName("irradianceVector");
    state._excludeVariableName("environmentIrradiance");
    state._excludeVariableName("diffuseBase");
    state._excludeVariableName("specularBase");
    state._excludeVariableName("preInfo");
    state._excludeVariableName("info");
    state._excludeVariableName("shadow");
    state._excludeVariableName("finalDiffuse");
    state._excludeVariableName("finalAmbient");
    state._excludeVariableName("ambientOcclusionForDirectDiffuse");
    state._excludeVariableName("finalColor");
    state._excludeVariableName("vClipSpacePosition");
    state._excludeVariableName("vDebugMode");
  }
  getClassName() {
    return "PBRMetallicRoughnessBlock";
  }
  get worldPosition() {
    return this._inputs[0];
  }
  get worldNormal() {
    return this._inputs[1];
  }
  get view() {
    return this._inputs[2];
  }
  get cameraPosition() {
    return this._inputs[3];
  }
  get perturbedNormal() {
    return this._inputs[4];
  }
  get baseColor() {
    return this._inputs[5];
  }
  get metallic() {
    return this._inputs[6];
  }
  get roughness() {
    return this._inputs[7];
  }
  get ambientOcc() {
    return this._inputs[8];
  }
  get opacity() {
    return this._inputs[9];
  }
  get indexOfRefraction() {
    return this._inputs[10];
  }
  get ambientColor() {
    return this._inputs[11];
  }
  get reflection() {
    return this._inputs[12];
  }
  get clearcoat() {
    return this._inputs[13];
  }
  get sheen() {
    return this._inputs[14];
  }
  get subsurface() {
    return this._inputs[15];
  }
  get anisotropy() {
    return this._inputs[16];
  }
  get iridescence() {
    return this._inputs[17];
  }
  get ambientClr() {
    return this._outputs[0];
  }
  get diffuseDir() {
    return this._outputs[1];
  }
  get specularDir() {
    return this._outputs[2];
  }
  get clearcoatDir() {
    return this._outputs[3];
  }
  get sheenDir() {
    return this._outputs[4];
  }
  get diffuseInd() {
    return this._outputs[5];
  }
  get specularInd() {
    return this._outputs[6];
  }
  get clearcoatInd() {
    return this._outputs[7];
  }
  get sheenInd() {
    return this._outputs[8];
  }
  get refraction() {
    return this._outputs[9];
  }
  get lighting() {
    return this._outputs[10];
  }
  get shadow() {
    return this._outputs[11];
  }
  get alpha() {
    return this._outputs[12];
  }
  autoConfigure(material) {
    if (!this.cameraPosition.isConnected) {
      let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition);
      if (!cameraPositionInput) {
        cameraPositionInput = new InputBlock("cameraPosition");
        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);
      }
      cameraPositionInput.output.connectTo(this.cameraPosition);
    }
    if (!this.view.isConnected) {
      let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View);
      if (!viewInput) {
        viewInput = new InputBlock("view");
        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);
      }
      viewInput.output.connectTo(this.view);
    }
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    defines.setValue("PBR", true);
    defines.setValue("METALLICWORKFLOW", true);
    defines.setValue("DEBUGMODE", this.debugMode, true);
    defines.setValue("NORMALXYSCALE", true);
    defines.setValue("BUMP", this.perturbedNormal.isConnected, true);
    defines.setValue("LODBASEDMICROSFURACE", this._scene.getEngine().getCaps().textureLOD);
    defines.setValue("ALBEDO", false, true);
    defines.setValue("OPACITY", this.opacity.isConnected, true);
    defines.setValue("AMBIENT", true, true);
    defines.setValue("AMBIENTINGRAYSCALE", false, true);
    defines.setValue("REFLECTIVITY", false, true);
    defines.setValue("AOSTOREINMETALMAPRED", false, true);
    defines.setValue("METALLNESSSTOREINMETALMAPBLUE", false, true);
    defines.setValue("ROUGHNESSSTOREINMETALMAPALPHA", false, true);
    defines.setValue("ROUGHNESSSTOREINMETALMAPGREEN", false, true);
    if (this.lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {
      defines.setValue("USEPHYSICALLIGHTFALLOFF", false);
      defines.setValue("USEGLTFLIGHTFALLOFF", false);
    } else if (this.lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF) {
      defines.setValue("USEPHYSICALLIGHTFALLOFF", false);
      defines.setValue("USEGLTFLIGHTFALLOFF", true);
    } else {
      defines.setValue("USEPHYSICALLIGHTFALLOFF", true);
      defines.setValue("USEGLTFLIGHTFALLOFF", false);
    }
    const alphaTestCutOffString = this.alphaTestCutoff.toString();
    defines.setValue("ALPHABLEND", this.useAlphaBlending, true);
    defines.setValue("ALPHAFROMALBEDO", false, true);
    defines.setValue("ALPHATEST", this.useAlphaTest, true);
    defines.setValue("ALPHATESTVALUE", alphaTestCutOffString.indexOf(".") < 0 ? alphaTestCutOffString + "." : alphaTestCutOffString, true);
    defines.setValue("OPACITYRGB", false, true);
    defines.setValue("RADIANCEOVERALPHA", this.useRadianceOverAlpha, true);
    defines.setValue("SPECULAROVERALPHA", this.useSpecularOverAlpha, true);
    defines.setValue("SPECULARAA", this._scene.getEngine().getCaps().standardDerivatives && this.enableSpecularAntiAliasing, true);
    defines.setValue("REALTIME_FILTERING", this.realTimeFiltering, true);
    const scene = mesh.getScene();
    const engine = scene.getEngine();
    if (engine._features.needTypeSuffixInShaderConstants) {
      defines.setValue("NUM_SAMPLES", this.realTimeFilteringQuality + "u", true);
    } else {
      defines.setValue("NUM_SAMPLES", "" + this.realTimeFilteringQuality, true);
    }
    defines.setValue("BRDF_V_HEIGHT_CORRELATED", true);
    defines.setValue("MS_BRDF_ENERGY_CONSERVATION", this.useEnergyConservation, true);
    defines.setValue("RADIANCEOCCLUSION", this.useRadianceOcclusion, true);
    defines.setValue("HORIZONOCCLUSION", this.useHorizonOcclusion, true);
    defines.setValue("UNLIT", this.unlit, true);
    defines.setValue("FORCENORMALFORWARD", this.forceNormalForward, true);
    if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
      defines.setValue("ENVIRONMENTBRDF", true);
      defines.setValue("ENVIRONMENTBRDF_RGBD", this._environmentBRDFTexture.isRGBD, true);
    } else {
      defines.setValue("ENVIRONMENTBRDF", false);
      defines.setValue("ENVIRONMENTBRDF_RGBD", false);
    }
    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {
      nodeMaterial.imageProcessingConfiguration.prepareDefines(defines);
    }
    if (!defines._areLightsDirty) {
      return;
    }
    if (!this.light) {
      MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);
      defines._needNormals = true;
      MaterialHelper.PrepareDefinesForMultiview(scene, defines);
    } else {
      const state = {
        needNormals: false,
        needRebuild: false,
        lightmapMode: false,
        shadowEnabled: false,
        specularEnabled: false
      };
      MaterialHelper.PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);
      if (state.needRebuild) {
        defines.rebuild();
      }
    }
  }
  updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {
    for (let lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {
      if (!defines["LIGHT" + lightIndex]) {
        break;
      }
      const onlyUpdateBuffersList = state.uniforms.indexOf("vLightData" + lightIndex) >= 0;
      MaterialHelper.PrepareUniformsAndSamplersForLight(lightIndex, state.uniforms, state.samplers, defines["PROJECTEDLIGHTTEXTURE" + lightIndex], uniformBuffers, onlyUpdateBuffersList);
    }
  }
  isReady(mesh, nodeMaterial, defines) {
    if (this._environmentBRDFTexture && !this._environmentBRDFTexture.isReady()) {
      return false;
    }
    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {
      if (!nodeMaterial.imageProcessingConfiguration.isReady()) {
        return false;
      }
    }
    return true;
  }
  bind(effect, nodeMaterial, mesh) {
    var _a, _b;
    if (!mesh) {
      return;
    }
    const scene = mesh.getScene();
    if (!this.light) {
      MaterialHelper.BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);
    } else {
      MaterialHelper.BindLight(this.light, this._lightId, scene, effect, true);
    }
    effect.setTexture(this._environmentBrdfSamplerName, this._environmentBRDFTexture);
    effect.setFloat2("vDebugMode", this.debugLimit, this.debugFactor);
    const ambientScene = this._scene.ambientColor;
    if (ambientScene) {
      effect.setColor3("ambientFromScene", ambientScene);
    }
    const invertNormal = scene.useRightHandedSystem === (scene._mirroredCameraPosition != null);
    effect.setFloat(this._invertNormalName, invertNormal ? -1 : 1);
    effect.setFloat4("vLightingIntensity", this.directIntensity, 1, this.environmentIntensity * this._scene.environmentIntensity, this.specularIntensity);
    const outsideIOR = 1;
    const ior = (_b = (_a = this.indexOfRefraction.connectInputBlock) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 1.5;
    const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);
    this._metallicReflectanceColor.scaleToRef(f0 * this._metallicF0Factor, TmpColors.Color3[0]);
    const metallicF90 = this._metallicF0Factor;
    effect.setColor4(this._vMetallicReflectanceFactorsName, TmpColors.Color3[0], metallicF90);
    if (nodeMaterial.imageProcessingConfiguration) {
      nodeMaterial.imageProcessingConfiguration.bind(effect);
    }
  }
  _injectVertexCode(state) {
    var _a, _b;
    const worldPos = this.worldPosition;
    const comments = `//${this.name}`;
    if (!this.light) {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightVxUboDeclaration" : "lightVxFragmentDeclaration", comments, {
        repeatKey: "maxSimultaneousLights"
      });
      this._lightId = 0;
      state.sharedData.dynamicUniformBlocks.push(this);
    } else {
      this._lightId = (state.counters["lightCounter"] !== void 0 ? state.counters["lightCounter"] : -1) + 1;
      state.counters["lightCounter"] = this._lightId;
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightVxUboDeclaration" : "lightVxFragmentDeclaration", comments, {
        replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]
      }, this._lightId.toString());
    }
    const worldPosVaryingName = "v_" + worldPos.associatedVariableName;
    if (state._emitVaryingFromString(worldPosVaryingName, "vec4")) {
      state.compilationString += `${worldPosVaryingName} = ${worldPos.associatedVariableName};\r
`;
    }
    const reflectionBlock = this.reflection.isConnected ? (_a = this.reflection.connectedPoint) === null || _a === void 0 ? void 0 : _a.ownerBlock : null;
    if (reflectionBlock) {
      reflectionBlock.viewConnectionPoint = this.view;
    }
    state.compilationString += (_b = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock.handleVertexSide(state)) !== null && _b !== void 0 ? _b : "";
    if (state._emitVaryingFromString("vClipSpacePosition", "vec4", "defined(IGNORE) || DEBUGMODE > 0")) {
      state._injectAtEnd += `#if DEBUGMODE > 0\r
`;
      state._injectAtEnd += `vClipSpacePosition = gl_Position;\r
`;
      state._injectAtEnd += `#endif\r
`;
    }
    if (this.light) {
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        replaceStrings: [
          { search: /{X}/g, replace: this._lightId.toString() },
          { search: /worldPos/g, replace: worldPos.associatedVariableName }
        ]
      });
    } else {
      state.compilationString += `vec4 worldPos = ${worldPos.associatedVariableName};\r
`;
      if (this.view.isConnected) {
        state.compilationString += `mat4 view = ${this.view.associatedVariableName};\r
`;
      }
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        repeatKey: "maxSimultaneousLights"
      });
    }
  }
  _getAlbedoOpacityCode() {
    let code = `albedoOpacityOutParams albedoOpacityOut;\r
`;
    const albedoColor = this.baseColor.isConnected ? this.baseColor.associatedVariableName : "vec3(1.)";
    const opacity = this.opacity.isConnected ? this.opacity.associatedVariableName : "1.";
    code += `albedoOpacityBlock(
                vec4(${albedoColor}, 1.),
            #ifdef ALBEDO
                vec4(1.),
                vec2(1., 1.),
            #endif
            #ifdef OPACITY
                vec4(${opacity}),
                vec2(1., 1.),
            #endif
                albedoOpacityOut
            );

            vec3 surfaceAlbedo = albedoOpacityOut.surfaceAlbedo;
            float alpha = albedoOpacityOut.alpha;\r
`;
    return code;
  }
  _getAmbientOcclusionCode() {
    let code = `ambientOcclusionOutParams aoOut;\r
`;
    const ao = this.ambientOcc.isConnected ? this.ambientOcc.associatedVariableName : "1.";
    code += `ambientOcclusionBlock(
            #ifdef AMBIENT
                vec3(${ao}),
                vec4(0., 1.0, 1.0, 0.),
            #endif
                aoOut
            );\r
`;
    return code;
  }
  _getReflectivityCode(state) {
    let code = `reflectivityOutParams reflectivityOut;\r
`;
    const aoIntensity = "1.";
    this._vMetallicReflectanceFactorsName = state._getFreeVariableName("vMetallicReflectanceFactors");
    state._emitUniformFromString(this._vMetallicReflectanceFactorsName, "vec4");
    code += `vec3 baseColor = surfaceAlbedo;

            reflectivityBlock(
                vec4(${this.metallic.associatedVariableName}, ${this.roughness.associatedVariableName}, 0., 0.),
            #ifdef METALLICWORKFLOW
                surfaceAlbedo,
                ${this._vMetallicReflectanceFactorsName},
            #endif
            #ifdef REFLECTIVITY
                vec3(0., 0., ${aoIntensity}),
                vec4(1.),
            #endif
            #if defined(METALLICWORKFLOW) && defined(REFLECTIVITY)  && defined(AOSTOREINMETALMAPRED)
                aoOut.ambientOcclusionColor,
            #endif
            #ifdef MICROSURFACEMAP
                microSurfaceTexel, <== not handled!
            #endif
                reflectivityOut
            );

            float microSurface = reflectivityOut.microSurface;
            float roughness = reflectivityOut.roughness;

            #ifdef METALLICWORKFLOW
                surfaceAlbedo = reflectivityOut.surfaceAlbedo;
            #endif
            #if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
                aoOut.ambientOcclusionColor = reflectivityOut.ambientOcclusionColor;
            #endif\r
`;
    return code;
  }
  _buildBlock(state) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16;
    super._buildBlock(state);
    this._scene = state.sharedData.scene;
    if (!this._environmentBRDFTexture) {
      this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this._scene);
    }
    const reflectionBlock = this.reflection.isConnected ? (_a = this.reflection.connectedPoint) === null || _a === void 0 ? void 0 : _a.ownerBlock : null;
    if (reflectionBlock) {
      reflectionBlock.worldPositionConnectionPoint = this.worldPosition;
      reflectionBlock.cameraPositionConnectionPoint = this.cameraPosition;
      reflectionBlock.worldNormalConnectionPoint = this.worldNormal;
      reflectionBlock.viewConnectionPoint = this.view;
    }
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      this._injectVertexCode(state);
      return this;
    }
    state.sharedData.forcedBindableBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.blockingBlocks.push(this);
    if (this.generateOnlyFragmentCode) {
      state.sharedData.dynamicUniformBlocks.push(this);
    }
    const comments = `//${this.name}`;
    const normalShading = this.perturbedNormal;
    let worldPosVarName = this.worldPosition.associatedVariableName;
    if (this.generateOnlyFragmentCode) {
      worldPosVarName = state._getFreeVariableName("globalWorldPos");
      state._emitFunction("pbr_globalworldpos", `vec3 ${worldPosVarName};\r
`, comments);
      state.compilationString += `${worldPosVarName} = ${this.worldPosition.associatedVariableName}.xyz;\r
`;
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        repeatKey: "maxSimultaneousLights",
        substitutionVars: this.generateOnlyFragmentCode ? `worldPos,${this.worldPosition.associatedVariableName}` : void 0
      });
      state.compilationString += `#if DEBUGMODE > 0\r
`;
      state.compilationString += `vec4 vClipSpacePosition = vec4((vec2(gl_FragCoord.xy) / vec2(1.0)) * 2.0 - 1.0, 0.0, 1.0);\r
`;
      state.compilationString += `#endif\r
`;
    } else {
      worldPosVarName = "v_" + worldPosVarName;
    }
    this._environmentBrdfSamplerName = state._getFreeVariableName("environmentBrdfSampler");
    state._emit2DSampler(this._environmentBrdfSamplerName);
    state.sharedData.hints.needAlphaBlending = state.sharedData.hints.needAlphaBlending || this.useAlphaBlending;
    state.sharedData.hints.needAlphaTesting = state.sharedData.hints.needAlphaTesting || this.useAlphaTest;
    state._emitExtension("lod", "#extension GL_EXT_shader_texture_lod : enable", "defined(LODBASEDMICROSFURACE)");
    state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    state._emitUniformFromString("vDebugMode", "vec2", "defined(IGNORE) || DEBUGMODE > 0");
    state._emitUniformFromString("ambientFromScene", "vec3");
    state.uniforms.push("exposureLinear");
    state.uniforms.push("contrast");
    state.uniforms.push("vInverseScreenSize");
    state.uniforms.push("vignetteSettings1");
    state.uniforms.push("vignetteSettings2");
    state.uniforms.push("vCameraColorCurveNegative");
    state.uniforms.push("vCameraColorCurveNeutral");
    state.uniforms.push("vCameraColorCurvePositive");
    state.uniforms.push("txColorTransform");
    state.uniforms.push("colorTransformSettings");
    state.uniforms.push("ditherIntensity");
    if (!this.light) {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        repeatKey: "maxSimultaneousLights",
        substitutionVars: this.generateOnlyFragmentCode ? "varying," : void 0
      });
    } else {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]
      }, this._lightId.toString());
    }
    state._emitFunctionFromInclude("helperFunctions", comments);
    state._emitFunctionFromInclude("importanceSampling", comments);
    state._emitFunctionFromInclude("pbrHelperFunctions", comments);
    state._emitFunctionFromInclude("imageProcessingDeclaration", comments);
    state._emitFunctionFromInclude("imageProcessingFunctions", comments);
    state._emitFunctionFromInclude("shadowsFragmentFunctions", comments, {
      replaceStrings: [{ search: /vPositionW/g, replace: worldPosVarName + ".xyz" }]
    });
    state._emitFunctionFromInclude("pbrDirectLightingSetupFunctions", comments, {
      replaceStrings: [{ search: /vPositionW/g, replace: worldPosVarName + ".xyz" }]
    });
    state._emitFunctionFromInclude("pbrDirectLightingFalloffFunctions", comments);
    state._emitFunctionFromInclude("pbrBRDFFunctions", comments, {
      replaceStrings: [{ search: /REFLECTIONMAP_SKYBOX/g, replace: (_b = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName) !== null && _b !== void 0 ? _b : "REFLECTIONMAP_SKYBOX" }]
    });
    state._emitFunctionFromInclude("hdrFilteringFunctions", comments);
    state._emitFunctionFromInclude("pbrDirectLightingFunctions", comments, {
      replaceStrings: [{ search: /vPositionW/g, replace: worldPosVarName + ".xyz" }]
    });
    state._emitFunctionFromInclude("pbrIBLFunctions", comments);
    state._emitFunctionFromInclude("pbrBlockAlbedoOpacity", comments);
    state._emitFunctionFromInclude("pbrBlockReflectivity", comments);
    state._emitFunctionFromInclude("pbrBlockAmbientOcclusion", comments);
    state._emitFunctionFromInclude("pbrBlockAlphaFresnel", comments);
    state._emitFunctionFromInclude("pbrBlockAnisotropic", comments);
    state._emitUniformFromString("vLightingIntensity", "vec4");
    if (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock.generateOnlyFragmentCode) {
      state.compilationString += reflectionBlock.handleVertexSide(state);
    }
    this._vNormalWName = state._getFreeVariableName("vNormalW");
    state.compilationString += `vec4 ${this._vNormalWName} = normalize(${this.worldNormal.associatedVariableName});\r
`;
    if (state._registerTempVariable("viewDirectionW")) {
      state.compilationString += `vec3 viewDirectionW = normalize(${this.cameraPosition.associatedVariableName} - ${worldPosVarName}.xyz);\r
`;
    }
    state.compilationString += `vec3 geometricNormalW = ${this._vNormalWName}.xyz;\r
`;
    state.compilationString += `vec3 normalW = ${normalShading.isConnected ? "normalize(" + normalShading.associatedVariableName + ".xyz)" : "geometricNormalW"};\r
`;
    this._invertNormalName = state._getFreeVariableName("invertNormal");
    state._emitUniformFromString(this._invertNormalName, "float");
    state.compilationString += state._emitCodeFromInclude("pbrBlockNormalFinal", comments, {
      replaceStrings: [
        { search: /vPositionW/g, replace: worldPosVarName + ".xyz" },
        { search: /vEyePosition.w/g, replace: this._invertNormalName }
      ]
    });
    state.compilationString += this._getAlbedoOpacityCode();
    state.compilationString += state._emitCodeFromInclude("depthPrePass", comments);
    state.compilationString += this._getAmbientOcclusionCode();
    state.compilationString += state._emitCodeFromInclude("pbrBlockLightmapInit", comments);
    state.compilationString += `#ifdef UNLIT
                vec3 diffuseBase = vec3(1., 1., 1.);
            #else\r
`;
    state.compilationString += this._getReflectivityCode(state);
    state.compilationString += state._emitCodeFromInclude("pbrBlockGeometryInfo", comments, {
      replaceStrings: [
        { search: /REFLECTIONMAP_SKYBOX/g, replace: (_c = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName) !== null && _c !== void 0 ? _c : "REFLECTIONMAP_SKYBOX" },
        { search: /REFLECTIONMAP_3D/g, replace: (_d = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) !== null && _d !== void 0 ? _d : "REFLECTIONMAP_3D" }
      ]
    });
    const anisotropyBlock = this.anisotropy.isConnected ? (_e = this.anisotropy.connectedPoint) === null || _e === void 0 ? void 0 : _e.ownerBlock : null;
    if (anisotropyBlock) {
      anisotropyBlock.worldPositionConnectionPoint = this.worldPosition;
      anisotropyBlock.worldNormalConnectionPoint = this.worldNormal;
      state.compilationString += anisotropyBlock.getCode(state, !this.perturbedNormal.isConnected);
    }
    if (reflectionBlock && reflectionBlock.hasTexture) {
      state.compilationString += reflectionBlock.getCode(state, anisotropyBlock ? "anisotropicOut.anisotropicNormal" : "normalW");
    }
    state._emitFunctionFromInclude("pbrBlockReflection", comments, {
      replaceStrings: [
        { search: /computeReflectionCoords/g, replace: "computeReflectionCoordsPBR" },
        { search: /REFLECTIONMAP_3D/g, replace: (_f = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) !== null && _f !== void 0 ? _f : "REFLECTIONMAP_3D" },
        { search: /REFLECTIONMAP_OPPOSITEZ/g, replace: (_g = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineOppositeZ) !== null && _g !== void 0 ? _g : "REFLECTIONMAP_OPPOSITEZ" },
        { search: /REFLECTIONMAP_PROJECTION/g, replace: (_h = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineProjectionName) !== null && _h !== void 0 ? _h : "REFLECTIONMAP_PROJECTION" },
        { search: /REFLECTIONMAP_SKYBOX/g, replace: (_j = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName) !== null && _j !== void 0 ? _j : "REFLECTIONMAP_SKYBOX" },
        { search: /LODINREFLECTIONALPHA/g, replace: (_k = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineLODReflectionAlpha) !== null && _k !== void 0 ? _k : "LODINREFLECTIONALPHA" },
        { search: /LINEARSPECULARREFLECTION/g, replace: (_l = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineLinearSpecularReflection) !== null && _l !== void 0 ? _l : "LINEARSPECULARREFLECTION" },
        { search: /vReflectionFilteringInfo/g, replace: (_m = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._vReflectionFilteringInfoName) !== null && _m !== void 0 ? _m : "vReflectionFilteringInfo" }
      ]
    });
    state.compilationString += state._emitCodeFromInclude("pbrBlockReflectance0", comments, {
      replaceStrings: [{ search: /metallicReflectanceFactors/g, replace: this._vMetallicReflectanceFactorsName }]
    });
    const sheenBlock = this.sheen.isConnected ? (_o = this.sheen.connectedPoint) === null || _o === void 0 ? void 0 : _o.ownerBlock : null;
    if (sheenBlock) {
      state.compilationString += sheenBlock.getCode(reflectionBlock);
    }
    state._emitFunctionFromInclude("pbrBlockSheen", comments, {
      replaceStrings: [
        { search: /REFLECTIONMAP_3D/g, replace: (_p = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) !== null && _p !== void 0 ? _p : "REFLECTIONMAP_3D" },
        { search: /REFLECTIONMAP_SKYBOX/g, replace: (_q = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName) !== null && _q !== void 0 ? _q : "REFLECTIONMAP_SKYBOX" },
        { search: /LODINREFLECTIONALPHA/g, replace: (_r = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineLODReflectionAlpha) !== null && _r !== void 0 ? _r : "LODINREFLECTIONALPHA" },
        { search: /LINEARSPECULARREFLECTION/g, replace: (_s = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineLinearSpecularReflection) !== null && _s !== void 0 ? _s : "LINEARSPECULARREFLECTION" }
      ]
    });
    const iridescenceBlock = this.iridescence.isConnected ? (_t = this.iridescence.connectedPoint) === null || _t === void 0 ? void 0 : _t.ownerBlock : null;
    state.compilationString += IridescenceBlock.GetCode(iridescenceBlock);
    state._emitFunctionFromInclude("pbrBlockIridescence", comments, {
      replaceStrings: []
    });
    const clearcoatBlock = this.clearcoat.isConnected ? (_u = this.clearcoat.connectedPoint) === null || _u === void 0 ? void 0 : _u.ownerBlock : null;
    const generateTBNSpace = !this.perturbedNormal.isConnected && !this.anisotropy.isConnected;
    const isTangentConnectedToPerturbNormal = this.perturbedNormal.isConnected && ((_w = ((_v = this.perturbedNormal.connectedPoint) === null || _v === void 0 ? void 0 : _v.ownerBlock).worldTangent) === null || _w === void 0 ? void 0 : _w.isConnected);
    const isTangentConnectedToAnisotropy = this.anisotropy.isConnected && ((_x = this.anisotropy.connectedPoint) === null || _x === void 0 ? void 0 : _x.ownerBlock).worldTangent.isConnected;
    let vTBNAvailable = isTangentConnectedToPerturbNormal || !this.perturbedNormal.isConnected && isTangentConnectedToAnisotropy;
    state.compilationString += ClearCoatBlock.GetCode(state, clearcoatBlock, reflectionBlock, worldPosVarName, generateTBNSpace, vTBNAvailable, this.worldNormal.associatedVariableName);
    if (generateTBNSpace) {
      vTBNAvailable = (_y = clearcoatBlock === null || clearcoatBlock === void 0 ? void 0 : clearcoatBlock.worldTangent.isConnected) !== null && _y !== void 0 ? _y : false;
    }
    state._emitFunctionFromInclude("pbrBlockClearcoat", comments, {
      replaceStrings: [
        { search: /computeReflectionCoords/g, replace: "computeReflectionCoordsPBR" },
        { search: /REFLECTIONMAP_3D/g, replace: (_z = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) !== null && _z !== void 0 ? _z : "REFLECTIONMAP_3D" },
        { search: /REFLECTIONMAP_OPPOSITEZ/g, replace: (_0 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineOppositeZ) !== null && _0 !== void 0 ? _0 : "REFLECTIONMAP_OPPOSITEZ" },
        { search: /REFLECTIONMAP_PROJECTION/g, replace: (_1 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineProjectionName) !== null && _1 !== void 0 ? _1 : "REFLECTIONMAP_PROJECTION" },
        { search: /REFLECTIONMAP_SKYBOX/g, replace: (_2 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName) !== null && _2 !== void 0 ? _2 : "REFLECTIONMAP_SKYBOX" },
        { search: /LODINREFLECTIONALPHA/g, replace: (_3 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineLODReflectionAlpha) !== null && _3 !== void 0 ? _3 : "LODINREFLECTIONALPHA" },
        { search: /LINEARSPECULARREFLECTION/g, replace: (_4 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineLinearSpecularReflection) !== null && _4 !== void 0 ? _4 : "LINEARSPECULARREFLECTION" },
        { search: /defined\(TANGENT\)/g, replace: vTBNAvailable ? "defined(TANGENT)" : "defined(IGNORE)" }
      ]
    });
    state.compilationString += state._emitCodeFromInclude("pbrBlockReflectance", comments, {
      replaceStrings: [
        { search: /REFLECTIONMAP_SKYBOX/g, replace: (_5 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName) !== null && _5 !== void 0 ? _5 : "REFLECTIONMAP_SKYBOX" },
        { search: /REFLECTIONMAP_3D/g, replace: (_6 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) !== null && _6 !== void 0 ? _6 : "REFLECTIONMAP_3D" }
      ]
    });
    const subsurfaceBlock = this.subsurface.isConnected ? (_7 = this.subsurface.connectedPoint) === null || _7 === void 0 ? void 0 : _7.ownerBlock : null;
    const refractionBlock = this.subsurface.isConnected ? (_9 = ((_8 = this.subsurface.connectedPoint) === null || _8 === void 0 ? void 0 : _8.ownerBlock).refraction.connectedPoint) === null || _9 === void 0 ? void 0 : _9.ownerBlock : null;
    if (refractionBlock) {
      refractionBlock.viewConnectionPoint = this.view;
      refractionBlock.indexOfRefractionConnectionPoint = this.indexOfRefraction;
    }
    state.compilationString += SubSurfaceBlock.GetCode(state, subsurfaceBlock, reflectionBlock, worldPosVarName);
    state._emitFunctionFromInclude("pbrBlockSubSurface", comments, {
      replaceStrings: [
        { search: /REFLECTIONMAP_3D/g, replace: (_10 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) !== null && _10 !== void 0 ? _10 : "REFLECTIONMAP_3D" },
        { search: /REFLECTIONMAP_OPPOSITEZ/g, replace: (_11 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineOppositeZ) !== null && _11 !== void 0 ? _11 : "REFLECTIONMAP_OPPOSITEZ" },
        { search: /REFLECTIONMAP_PROJECTION/g, replace: (_12 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineProjectionName) !== null && _12 !== void 0 ? _12 : "REFLECTIONMAP_PROJECTION" },
        { search: /SS_REFRACTIONMAP_3D/g, replace: (_13 = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._define3DName) !== null && _13 !== void 0 ? _13 : "SS_REFRACTIONMAP_3D" },
        { search: /SS_LODINREFRACTIONALPHA/g, replace: (_14 = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._defineLODRefractionAlpha) !== null && _14 !== void 0 ? _14 : "SS_LODINREFRACTIONALPHA" },
        { search: /SS_LINEARSPECULARREFRACTION/g, replace: (_15 = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._defineLinearSpecularRefraction) !== null && _15 !== void 0 ? _15 : "SS_LINEARSPECULARREFRACTION" },
        { search: /SS_REFRACTIONMAP_OPPOSITEZ/g, replace: (_16 = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._defineOppositeZ) !== null && _16 !== void 0 ? _16 : "SS_REFRACTIONMAP_OPPOSITEZ" }
      ]
    });
    state.compilationString += state._emitCodeFromInclude("pbrBlockDirectLighting", comments);
    if (this.light) {
      state.compilationString += state._emitCodeFromInclude("lightFragment", comments, {
        replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]
      });
    } else {
      state.compilationString += state._emitCodeFromInclude("lightFragment", comments, {
        repeatKey: "maxSimultaneousLights"
      });
    }
    state.compilationString += state._emitCodeFromInclude("pbrBlockFinalLitComponents", comments);
    state.compilationString += `#endif\r
`;
    const aoColor = this.ambientColor.isConnected ? this.ambientColor.associatedVariableName : "vec3(0., 0., 0.)";
    let aoDirectLightIntensity = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS.toString();
    if (aoDirectLightIntensity.indexOf(".") === -1) {
      aoDirectLightIntensity += ".";
    }
    state.compilationString += state._emitCodeFromInclude("pbrBlockFinalUnlitComponents", comments, {
      replaceStrings: [
        { search: /vec3 finalEmissive[\s\S]*?finalEmissive\*=vLightingIntensity\.y;/g, replace: "" },
        { search: /vAmbientColor/g, replace: aoColor + " * ambientFromScene" },
        { search: /vAmbientInfos\.w/g, replace: aoDirectLightIntensity }
      ]
    });
    state.compilationString += state._emitCodeFromInclude("pbrBlockFinalColorComposition", comments, {
      replaceStrings: [{ search: /finalEmissive/g, replace: "vec3(0.)" }]
    });
    state.compilationString += state._emitCodeFromInclude("pbrBlockImageProcessing", comments, {
      replaceStrings: [{ search: /visibility/g, replace: "1." }]
    });
    state.compilationString += state._emitCodeFromInclude("pbrDebug", comments, {
      replaceStrings: [
        { search: /vNormalW/g, replace: this._vNormalWName },
        { search: /vPositionW/g, replace: worldPosVarName },
        { search: /albedoTexture\.rgb;/g, replace: "vec3(1.);\r\ngl_FragColor.rgb = toGammaSpace(gl_FragColor.rgb);\r\n" }
      ]
    });
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        const remap = mapOutputToVariable[output.name];
        if (remap) {
          const [varName, conditions] = remap;
          if (conditions) {
            state.compilationString += `#if ${conditions}\r
`;
          }
          state.compilationString += `${this._declareOutput(output, state)} = ${varName};\r
`;
          if (conditions) {
            state.compilationString += `#else\r
`;
            state.compilationString += `${this._declareOutput(output, state)} = vec3(0.);\r
`;
            state.compilationString += `#endif\r
`;
          }
        } else {
          console.error(`There's no remapping for the ${output.name} end point! No code generated`);
        }
      }
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.lightFalloff = ${this.lightFalloff};\r
`;
    codeString += `${this._codeVariableName}.useAlphaTest = ${this.useAlphaTest};\r
`;
    codeString += `${this._codeVariableName}.alphaTestCutoff = ${this.alphaTestCutoff};\r
`;
    codeString += `${this._codeVariableName}.useAlphaBlending = ${this.useAlphaBlending};\r
`;
    codeString += `${this._codeVariableName}.useRadianceOverAlpha = ${this.useRadianceOverAlpha};\r
`;
    codeString += `${this._codeVariableName}.useSpecularOverAlpha = ${this.useSpecularOverAlpha};\r
`;
    codeString += `${this._codeVariableName}.enableSpecularAntiAliasing = ${this.enableSpecularAntiAliasing};\r
`;
    codeString += `${this._codeVariableName}.realTimeFiltering = ${this.realTimeFiltering};\r
`;
    codeString += `${this._codeVariableName}.realTimeFilteringQuality = ${this.realTimeFilteringQuality};\r
`;
    codeString += `${this._codeVariableName}.useEnergyConservation = ${this.useEnergyConservation};\r
`;
    codeString += `${this._codeVariableName}.useRadianceOcclusion = ${this.useRadianceOcclusion};\r
`;
    codeString += `${this._codeVariableName}.useHorizonOcclusion = ${this.useHorizonOcclusion};\r
`;
    codeString += `${this._codeVariableName}.unlit = ${this.unlit};\r
`;
    codeString += `${this._codeVariableName}.forceNormalForward = ${this.forceNormalForward};\r
`;
    codeString += `${this._codeVariableName}.debugMode = ${this.debugMode};\r
`;
    codeString += `${this._codeVariableName}.debugLimit = ${this.debugLimit};\r
`;
    codeString += `${this._codeVariableName}.debugFactor = ${this.debugFactor};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    if (this.light) {
      serializationObject.lightId = this.light.id;
    }
    serializationObject.lightFalloff = this.lightFalloff;
    serializationObject.useAlphaTest = this.useAlphaTest;
    serializationObject.alphaTestCutoff = this.alphaTestCutoff;
    serializationObject.useAlphaBlending = this.useAlphaBlending;
    serializationObject.useRadianceOverAlpha = this.useRadianceOverAlpha;
    serializationObject.useSpecularOverAlpha = this.useSpecularOverAlpha;
    serializationObject.enableSpecularAntiAliasing = this.enableSpecularAntiAliasing;
    serializationObject.realTimeFiltering = this.realTimeFiltering;
    serializationObject.realTimeFilteringQuality = this.realTimeFilteringQuality;
    serializationObject.useEnergyConservation = this.useEnergyConservation;
    serializationObject.useRadianceOcclusion = this.useRadianceOcclusion;
    serializationObject.useHorizonOcclusion = this.useHorizonOcclusion;
    serializationObject.unlit = this.unlit;
    serializationObject.forceNormalForward = this.forceNormalForward;
    serializationObject.debugMode = this.debugMode;
    serializationObject.debugLimit = this.debugLimit;
    serializationObject.debugFactor = this.debugFactor;
    serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    var _a, _b;
    super._deserialize(serializationObject, scene, rootUrl);
    if (serializationObject.lightId) {
      this.light = scene.getLightById(serializationObject.lightId);
    }
    this.lightFalloff = (_a = serializationObject.lightFalloff) !== null && _a !== void 0 ? _a : 0;
    this.useAlphaTest = serializationObject.useAlphaTest;
    this.alphaTestCutoff = serializationObject.alphaTestCutoff;
    this.useAlphaBlending = serializationObject.useAlphaBlending;
    this.useRadianceOverAlpha = serializationObject.useRadianceOverAlpha;
    this.useSpecularOverAlpha = serializationObject.useSpecularOverAlpha;
    this.enableSpecularAntiAliasing = serializationObject.enableSpecularAntiAliasing;
    this.realTimeFiltering = !!serializationObject.realTimeFiltering;
    this.realTimeFilteringQuality = (_b = serializationObject.realTimeFilteringQuality) !== null && _b !== void 0 ? _b : 8;
    this.useEnergyConservation = serializationObject.useEnergyConservation;
    this.useRadianceOcclusion = serializationObject.useRadianceOcclusion;
    this.useHorizonOcclusion = serializationObject.useHorizonOcclusion;
    this.unlit = serializationObject.unlit;
    this.forceNormalForward = !!serializationObject.forceNormalForward;
    this.debugMode = serializationObject.debugMode;
    this.debugLimit = serializationObject.debugLimit;
    this.debugFactor = serializationObject.debugFactor;
    this.generateOnlyFragmentCode = !!serializationObject.generateOnlyFragmentCode;
    this._setTarget();
  }
};
__decorate([
  editableInPropertyPage("Direct lights", PropertyTypeForEdition.Float, "INTENSITY", { min: 0, max: 1, notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "directIntensity", void 0);
__decorate([
  editableInPropertyPage("Environment lights", PropertyTypeForEdition.Float, "INTENSITY", { min: 0, max: 1, notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "environmentIntensity", void 0);
__decorate([
  editableInPropertyPage("Specular highlights", PropertyTypeForEdition.Float, "INTENSITY", { min: 0, max: 1, notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "specularIntensity", void 0);
__decorate([
  editableInPropertyPage("Light falloff", PropertyTypeForEdition.List, "LIGHTING & COLORS", {
    notifiers: { update: true },
    options: [
      { label: "Physical", value: PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL },
      { label: "GLTF", value: PBRBaseMaterial.LIGHTFALLOFF_GLTF },
      { label: "Standard", value: PBRBaseMaterial.LIGHTFALLOFF_STANDARD }
    ]
  })
], PBRMetallicRoughnessBlock.prototype, "lightFalloff", void 0);
__decorate([
  editableInPropertyPage("Alpha Testing", PropertyTypeForEdition.Boolean, "OPACITY")
], PBRMetallicRoughnessBlock.prototype, "useAlphaTest", void 0);
__decorate([
  editableInPropertyPage("Alpha CutOff", PropertyTypeForEdition.Float, "OPACITY", { min: 0, max: 1, notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "alphaTestCutoff", void 0);
__decorate([
  editableInPropertyPage("Alpha blending", PropertyTypeForEdition.Boolean, "OPACITY")
], PBRMetallicRoughnessBlock.prototype, "useAlphaBlending", void 0);
__decorate([
  editableInPropertyPage("Radiance over alpha", PropertyTypeForEdition.Boolean, "RENDERING", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "useRadianceOverAlpha", void 0);
__decorate([
  editableInPropertyPage("Specular over alpha", PropertyTypeForEdition.Boolean, "RENDERING", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "useSpecularOverAlpha", void 0);
__decorate([
  editableInPropertyPage("Specular anti-aliasing", PropertyTypeForEdition.Boolean, "RENDERING", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "enableSpecularAntiAliasing", void 0);
__decorate([
  editableInPropertyPage("Realtime filtering", PropertyTypeForEdition.Boolean, "RENDERING", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "realTimeFiltering", void 0);
__decorate([
  editableInPropertyPage("Realtime filtering quality", PropertyTypeForEdition.List, "RENDERING", {
    notifiers: { update: true },
    options: [
      { label: "Low", value: 8 },
      { label: "Medium", value: 16 },
      { label: "High", value: 64 }
    ]
  })
], PBRMetallicRoughnessBlock.prototype, "realTimeFilteringQuality", void 0);
__decorate([
  editableInPropertyPage("Energy Conservation", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "useEnergyConservation", void 0);
__decorate([
  editableInPropertyPage("Radiance occlusion", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "useRadianceOcclusion", void 0);
__decorate([
  editableInPropertyPage("Horizon occlusion", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "useHorizonOcclusion", void 0);
__decorate([
  editableInPropertyPage("Unlit", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "unlit", void 0);
__decorate([
  editableInPropertyPage("Force normal forward", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "forceNormalForward", void 0);
__decorate([
  editableInPropertyPage("Generate only fragment code", PropertyTypeForEdition.Boolean, "ADVANCED", {
    notifiers: { rebuild: true, update: true, onValidation: PBRMetallicRoughnessBlock._OnGenerateOnlyFragmentCodeChanged }
  })
], PBRMetallicRoughnessBlock.prototype, "generateOnlyFragmentCode", void 0);
__decorate([
  editableInPropertyPage("Debug mode", PropertyTypeForEdition.List, "DEBUG", {
    notifiers: { update: true },
    options: [
      { label: "None", value: 0 },
      { label: "Normalized position", value: 1 },
      { label: "Normals", value: 2 },
      { label: "Tangents", value: 3 },
      { label: "Bitangents", value: 4 },
      { label: "Bump Normals", value: 5 },
      { label: "ClearCoat Normals", value: 8 },
      { label: "ClearCoat Tangents", value: 9 },
      { label: "ClearCoat Bitangents", value: 10 },
      { label: "Anisotropic Normals", value: 11 },
      { label: "Anisotropic Tangents", value: 12 },
      { label: "Anisotropic Bitangents", value: 13 },
      { label: "Env Refraction", value: 40 },
      { label: "Env Reflection", value: 41 },
      { label: "Env Clear Coat", value: 42 },
      { label: "Direct Diffuse", value: 50 },
      { label: "Direct Specular", value: 51 },
      { label: "Direct Clear Coat", value: 52 },
      { label: "Direct Sheen", value: 53 },
      { label: "Env Irradiance", value: 54 },
      { label: "Surface Albedo", value: 60 },
      { label: "Reflectance 0", value: 61 },
      { label: "Metallic", value: 62 },
      { label: "Metallic F0", value: 71 },
      { label: "Roughness", value: 63 },
      { label: "AlphaG", value: 64 },
      { label: "NdotV", value: 65 },
      { label: "ClearCoat Color", value: 66 },
      { label: "ClearCoat Roughness", value: 67 },
      { label: "ClearCoat NdotV", value: 68 },
      { label: "Transmittance", value: 69 },
      { label: "Refraction Transmittance", value: 70 },
      { label: "SEO", value: 80 },
      { label: "EHO", value: 81 },
      { label: "Energy Factor", value: 82 },
      { label: "Specular Reflectance", value: 83 },
      { label: "Clear Coat Reflectance", value: 84 },
      { label: "Sheen Reflectance", value: 85 },
      { label: "Luminance Over Alpha", value: 86 },
      { label: "Alpha", value: 87 }
    ]
  })
], PBRMetallicRoughnessBlock.prototype, "debugMode", void 0);
__decorate([
  editableInPropertyPage("Split position", PropertyTypeForEdition.Float, "DEBUG", { min: -1, max: 1, notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "debugLimit", void 0);
__decorate([
  editableInPropertyPage("Output factor", PropertyTypeForEdition.Float, "DEBUG", { min: 0, max: 5, notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "debugFactor", void 0);
RegisterClass("BABYLON.PBRMetallicRoughnessBlock", PBRMetallicRoughnessBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/modBlock.js
var ModBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
  }
  getClassName() {
    return "ModBlock";
  }
  get left() {
    return this._inputs[0];
  }
  get right() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = mod(${this.left.associatedVariableName}, ${this.right.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.ModBlock", ModBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/matrixBuilderBlock.js
var MatrixBuilderBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("row0", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("row1", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("row2", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("row3", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  getClassName() {
    return "MatrixBuilder";
  }
  get row0() {
    return this._inputs[0];
  }
  get row1() {
    return this._inputs[1];
  }
  get row2() {
    return this._inputs[2];
  }
  get row3() {
    return this._inputs[3];
  }
  get output() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.row0.isConnected) {
      const row0Input = new InputBlock("row0");
      row0Input.value = new Vector4(1, 0, 0, 0);
      row0Input.output.connectTo(this.row0);
    }
    if (!this.row1.isConnected) {
      const row1Input = new InputBlock("row1");
      row1Input.value = new Vector4(0, 1, 0, 0);
      row1Input.output.connectTo(this.row1);
    }
    if (!this.row2.isConnected) {
      const row2Input = new InputBlock("row2");
      row2Input.value = new Vector4(0, 0, 1, 0);
      row2Input.output.connectTo(this.row2);
    }
    if (!this.row3.isConnected) {
      const row3Input = new InputBlock("row3");
      row3Input.value = new Vector4(0, 0, 0, 1);
      row3Input.output.connectTo(this.row3);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const row0 = this.row0;
    const row1 = this.row1;
    const row2 = this.row2;
    const row3 = this.row3;
    state.compilationString += this._declareOutput(output, state) + ` = mat4(${row0.associatedVariableName}, ${row1.associatedVariableName}, ${row2.associatedVariableName}, ${row3.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.MatrixBuilder", MatrixBuilderBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/conditionalBlock.js
var ConditionalBlockConditions;
(function(ConditionalBlockConditions2) {
  ConditionalBlockConditions2[ConditionalBlockConditions2["Equal"] = 0] = "Equal";
  ConditionalBlockConditions2[ConditionalBlockConditions2["NotEqual"] = 1] = "NotEqual";
  ConditionalBlockConditions2[ConditionalBlockConditions2["LessThan"] = 2] = "LessThan";
  ConditionalBlockConditions2[ConditionalBlockConditions2["GreaterThan"] = 3] = "GreaterThan";
  ConditionalBlockConditions2[ConditionalBlockConditions2["LessOrEqual"] = 4] = "LessOrEqual";
  ConditionalBlockConditions2[ConditionalBlockConditions2["GreaterOrEqual"] = 5] = "GreaterOrEqual";
  ConditionalBlockConditions2[ConditionalBlockConditions2["Xor"] = 6] = "Xor";
  ConditionalBlockConditions2[ConditionalBlockConditions2["Or"] = 7] = "Or";
  ConditionalBlockConditions2[ConditionalBlockConditions2["And"] = 8] = "And";
})(ConditionalBlockConditions || (ConditionalBlockConditions = {}));
var ConditionalBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.condition = ConditionalBlockConditions.LessThan;
    this.registerInput("a", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("b", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("true", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerInput("false", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._linkConnectionTypes(2, 3);
    this._outputs[0]._typeConnectionSource = this._inputs[2];
    this._outputs[0]._defaultConnectionPointType = NodeMaterialBlockConnectionPointTypes.Float;
  }
  getClassName() {
    return "ConditionalBlock";
  }
  get a() {
    return this._inputs[0];
  }
  get b() {
    return this._inputs[1];
  }
  get true() {
    return this._inputs[2];
  }
  get false() {
    return this._inputs[3];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const trueStatement = this.true.isConnected ? this.true.associatedVariableName : "1.0";
    const falseStatement = this.false.isConnected ? this.false.associatedVariableName : "0.0";
    switch (this.condition) {
      case ConditionalBlockConditions.Equal: {
        state.compilationString += this._declareOutput(output, state) + ` = ${this.a.associatedVariableName} == ${this.b.associatedVariableName} ? ${trueStatement} : ${falseStatement};\r
`;
        break;
      }
      case ConditionalBlockConditions.NotEqual: {
        state.compilationString += this._declareOutput(output, state) + ` = ${this.a.associatedVariableName} != ${this.b.associatedVariableName} ? ${trueStatement} : ${falseStatement};\r
`;
        break;
      }
      case ConditionalBlockConditions.LessThan: {
        state.compilationString += this._declareOutput(output, state) + ` = ${this.a.associatedVariableName} < ${this.b.associatedVariableName} ? ${trueStatement} : ${falseStatement};\r
`;
        break;
      }
      case ConditionalBlockConditions.LessOrEqual: {
        state.compilationString += this._declareOutput(output, state) + ` = ${this.a.associatedVariableName} <= ${this.b.associatedVariableName} ? ${trueStatement} : ${falseStatement};\r
`;
        break;
      }
      case ConditionalBlockConditions.GreaterThan: {
        state.compilationString += this._declareOutput(output, state) + ` = ${this.a.associatedVariableName} > ${this.b.associatedVariableName} ? ${trueStatement} : ${falseStatement};\r
`;
        break;
      }
      case ConditionalBlockConditions.GreaterOrEqual: {
        state.compilationString += this._declareOutput(output, state) + ` = ${this.a.associatedVariableName} >= ${this.b.associatedVariableName} ? ${trueStatement} : ${falseStatement};\r
`;
        break;
      }
      case ConditionalBlockConditions.Xor: {
        state.compilationString += this._declareOutput(output, state) + ` = (mod(${this.a.associatedVariableName} + ${this.b.associatedVariableName}, 2.0) > 0.0) ? ${trueStatement} : ${falseStatement};\r
`;
        break;
      }
      case ConditionalBlockConditions.Or: {
        state.compilationString += this._declareOutput(output, state) + ` = (min(${this.a.associatedVariableName} + ${this.b.associatedVariableName}, 1.0) > 0.0) ? ${trueStatement} : ${falseStatement};\r
`;
        break;
      }
      case ConditionalBlockConditions.And: {
        state.compilationString += this._declareOutput(output, state) + ` = (${this.a.associatedVariableName} * ${this.b.associatedVariableName} > 0.0)  ? ${trueStatement} : ${falseStatement};\r
`;
        break;
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.condition = this.condition;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.condition = serializationObject.condition;
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.condition = BABYLON.ConditionalBlockConditions.${ConditionalBlockConditions[this.condition]};\r
`;
    return codeString;
  }
};
RegisterClass("BABYLON.ConditionalBlock", ConditionalBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/cloudBlock.js
var CloudBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.octaves = 6;
    this.registerInput("seed", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("chaos", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerInput("offsetX", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("offsetY", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("offsetZ", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector2);
    this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);
    this._linkConnectionTypes(0, 1);
  }
  getClassName() {
    return "CloudBlock";
  }
  get seed() {
    return this._inputs[0];
  }
  get chaos() {
    return this._inputs[1];
  }
  get offsetX() {
    return this._inputs[2];
  }
  get offsetY() {
    return this._inputs[3];
  }
  get offsetZ() {
    return this._inputs[4];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    var _a, _b;
    super._buildBlock(state);
    if (!this.seed.isConnected) {
      return;
    }
    if (!this._outputs[0].hasEndpoints) {
      return;
    }
    const functionString = `

        float cloudRandom(in float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }

        // Based on Morgan McGuire @morgan3d
        // https://www.shadertoy.com/view/4dS3Wd
        float cloudNoise(in vec2 x, in vec2 chaos) {
            vec2 step = chaos * vec2(75., 120.) + vec2(75., 120.);

            vec2 i = floor(x);
            vec2 f = fract(x);

            float n = dot(i, step);

            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(
                    mix(cloudRandom(n + dot(step, vec2(0, 0))), cloudRandom(n + dot(step, vec2(1, 0))), u.x),
                    mix(cloudRandom(n + dot(step, vec2(0, 1))), cloudRandom(n + dot(step, vec2(1, 1))), u.x),
                    u.y
                );
        }

        float cloudNoise(in vec3 x, in vec3 chaos) {
            vec3 step = chaos * vec3(60., 120., 75.) + vec3(60., 120., 75.);

            vec3 i = floor(x);
            vec3 f = fract(x);

            float n = dot(i, step);

            vec3 u = f * f * (3.0 - 2.0 * f);
            return mix(mix(mix( cloudRandom(n + dot(step, vec3(0, 0, 0))), cloudRandom(n + dot(step, vec3(1, 0, 0))), u.x),
                           mix( cloudRandom(n + dot(step, vec3(0, 1, 0))), cloudRandom(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
                       mix(mix( cloudRandom(n + dot(step, vec3(0, 0, 1))), cloudRandom(n + dot(step, vec3(1, 0, 1))), u.x),
                           mix( cloudRandom(n + dot(step, vec3(0, 1, 1))), cloudRandom(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
        }`;
    const fractalBrownianString = `
        float fbm(in vec2 st, in vec2 chaos) {
            // Initial values
            float value = 0.0;
            float amplitude = .5;
            float frequency = 0.;

            // Loop of octaves
            for (int i = 0; i < OCTAVES; i++) {
                value += amplitude * cloudNoise(st, chaos);
                st *= 2.0;
                amplitude *= 0.5;
            }
            return value;
        }

        float fbm(in vec3 x, in vec3 chaos) {
            // Initial values
            float value = 0.0;
            float amplitude = 0.5;
            for (int i = 0; i < OCTAVES; ++i) {
                value += amplitude * cloudNoise(x, chaos);
                x = x * 2.0;
                amplitude *= 0.5;
            }
            return value;
        }`;
    const fbmNewName = `fbm${this.octaves}`;
    state._emitFunction("CloudBlockCode", functionString, "// CloudBlockCode");
    state._emitFunction("CloudBlockCodeFBM" + this.octaves, fractalBrownianString.replace(/fbm/gi, fbmNewName).replace(/OCTAVES/gi, (this.octaves | 0).toString()), "// CloudBlockCode FBM");
    const localVariable = state._getFreeVariableName("st");
    const seedType = ((_a = this.seed.connectedPoint) === null || _a === void 0 ? void 0 : _a.type) === NodeMaterialBlockConnectionPointTypes.Vector2 ? "vec2" : "vec3";
    state.compilationString += `${seedType} ${localVariable} = ${this.seed.associatedVariableName};\r
`;
    if (this.offsetX.isConnected) {
      state.compilationString += `${localVariable}.x += 0.1 * ${this.offsetX.associatedVariableName};\r
`;
    }
    if (this.offsetY.isConnected) {
      state.compilationString += `${localVariable}.y += 0.1 * ${this.offsetY.associatedVariableName};\r
`;
    }
    if (this.offsetZ.isConnected && seedType === "vec3") {
      state.compilationString += `${localVariable}.z += 0.1 * ${this.offsetZ.associatedVariableName};\r
`;
    }
    let chaosValue = "";
    if (this.chaos.isConnected) {
      chaosValue = this.chaos.associatedVariableName;
    } else {
      chaosValue = ((_b = this.seed.connectedPoint) === null || _b === void 0 ? void 0 : _b.type) === NodeMaterialBlockConnectionPointTypes.Vector2 ? "vec2(0., 0.)" : "vec3(0., 0., 0.)";
    }
    state.compilationString += this._declareOutput(this._outputs[0], state) + ` = ${fbmNewName}(${localVariable}, ${chaosValue});\r
`;
    return this;
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.octaves = ${this.octaves};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.octaves = this.octaves;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.octaves = serializationObject.octaves;
  }
};
__decorate([
  editableInPropertyPage("Octaves", PropertyTypeForEdition.Int)
], CloudBlock.prototype, "octaves", void 0);
RegisterClass("BABYLON.CloudBlock", CloudBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/voronoiNoiseBlock.js
var VoronoiNoiseBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("seed", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerInput("offset", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("density", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("cells", NodeMaterialBlockConnectionPointTypes.Float);
  }
  getClassName() {
    return "VoronoiNoiseBlock";
  }
  get seed() {
    return this._inputs[0];
  }
  get offset() {
    return this._inputs[1];
  }
  get density() {
    return this._inputs[2];
  }
  get output() {
    return this._outputs[0];
  }
  get cells() {
    return this._outputs[1];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (!this.seed.isConnected) {
      return;
    }
    let functionString = `vec2 voronoiRandom(vec2 seed, float offset){
            mat2 m = mat2(15.27, 47.63, 99.41, 89.98);
            vec2 uv = fract(sin(m * seed) * 46839.32);
            return vec2(sin(uv.y * offset) * 0.5 + 0.5, cos(uv.x * offset) * 0.5 + 0.5);
        }
        `;
    state._emitFunction("voronoiRandom", functionString, "// Voronoi random generator");
    functionString = `void voronoi(vec2 seed, float offset, float density, out float outValue, out float cells){
            vec2 g = floor(seed * density);
            vec2 f = fract(seed * density);
            float t = 8.0;
            vec3 res = vec3(8.0, 0.0, 0.0);

            for(int y=-1; y<=1; y++)
            {
                for(int x=-1; x<=1; x++)
                {
                    vec2 lattice = vec2(x,y);
                    vec2 randomOffset = voronoiRandom(lattice + g, offset);
                    float d = distance(lattice + randomOffset, f);
                    if(d < res.x)
                    {
                        res = vec3(d, randomOffset.x, randomOffset.y);
                        outValue = res.x;
                        cells = res.y;
                    }
                }
            }
        }
        `;
    state._emitFunction("voronoi", functionString, "// Voronoi");
    const tempOutput = state._getFreeVariableName("tempOutput");
    const tempCells = state._getFreeVariableName("tempCells");
    state.compilationString += `float ${tempOutput} = 0.0;\r
`;
    state.compilationString += `float ${tempCells} = 0.0;\r
`;
    state.compilationString += `voronoi(${this.seed.associatedVariableName}, ${this.offset.associatedVariableName}, ${this.density.associatedVariableName}, ${tempOutput}, ${tempCells});\r
`;
    if (this.output.hasEndpoints) {
      state.compilationString += this._declareOutput(this.output, state) + ` = ${tempOutput};\r
`;
    }
    if (this.cells.hasEndpoints) {
      state.compilationString += this._declareOutput(this.cells, state) + ` = ${tempCells};\r
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.VoronoiNoiseBlock", VoronoiNoiseBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/elbowBlock.js
var ElbowBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  getClassName() {
    return "ElbowBlock";
  }
  get input() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  get target() {
    const input = this._inputs[0];
    if (input.isConnected) {
      const block = input.connectedPoint.ownerBlock;
      if (block.target !== NodeMaterialBlockTargets.VertexAndFragment) {
        return block.target;
      }
      if (input.connectedPoint.target !== NodeMaterialBlockTargets.VertexAndFragment) {
        return input.connectedPoint.target;
      }
    }
    return this._target;
  }
  set target(value) {
    if ((this._target & value) !== 0) {
      return;
    }
    this._target = value;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const input = this._inputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = ${input.associatedVariableName};\r
`;
    return this;
  }
};
RegisterClass("BABYLON.ElbowBlock", ElbowBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/triPlanarBlock.js
var TriPlanarBlock = class extends NodeMaterialBlock {
  constructor(name137, hideSourceZ = false) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this._convertToGammaSpace = false;
    this._convertToLinearSpace = false;
    this.disableLevelMultiplication = false;
    this.registerInput("position", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);
    this.registerInput("normal", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);
    this.registerInput("sharpness", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("source", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("source", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, "ImageSourceBlock"));
    this.registerInput("sourceY", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("sourceY", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, "ImageSourceBlock"));
    if (!hideSourceZ) {
      this.registerInput("sourceZ", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("sourceZ", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, "ImageSourceBlock"));
    }
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("level", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this._inputs[1].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  get texture() {
    var _a;
    if (this.source.isConnected) {
      return ((_a = this.source.connectedPoint) === null || _a === void 0 ? void 0 : _a.ownerBlock).texture;
    }
    return this._texture;
  }
  set texture(texture) {
    var _a;
    if (this._texture === texture) {
      return;
    }
    const scene = (_a = texture === null || texture === void 0 ? void 0 : texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;
    if (!texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this._texture);
      });
    }
    this._texture = texture;
    if (texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(texture);
      });
    }
  }
  get textureY() {
    var _a;
    if (this.sourceY.isConnected) {
      return ((_a = this.sourceY.connectedPoint) === null || _a === void 0 ? void 0 : _a.ownerBlock).texture;
    }
    return null;
  }
  get textureZ() {
    var _a, _b;
    if ((_a = this.sourceZ) === null || _a === void 0 ? void 0 : _a.isConnected) {
      return ((_b = this.sourceY.connectedPoint) === null || _b === void 0 ? void 0 : _b.ownerBlock).texture;
    }
    return null;
  }
  _getImageSourceBlock(connectionPoint) {
    return (connectionPoint === null || connectionPoint === void 0 ? void 0 : connectionPoint.isConnected) ? connectionPoint.connectedPoint.ownerBlock : null;
  }
  get samplerName() {
    const imageSourceBlock = this._getImageSourceBlock(this.source);
    if (imageSourceBlock) {
      return imageSourceBlock.samplerName;
    }
    return this._samplerName;
  }
  get samplerYName() {
    var _a, _b;
    return (_b = (_a = this._getImageSourceBlock(this.sourceY)) === null || _a === void 0 ? void 0 : _a.samplerName) !== null && _b !== void 0 ? _b : null;
  }
  get samplerZName() {
    var _a, _b;
    return (_b = (_a = this._getImageSourceBlock(this.sourceZ)) === null || _a === void 0 ? void 0 : _a.samplerName) !== null && _b !== void 0 ? _b : null;
  }
  get hasImageSource() {
    return this.source.isConnected;
  }
  set convertToGammaSpace(value) {
    var _a;
    if (value === this._convertToGammaSpace) {
      return;
    }
    this._convertToGammaSpace = value;
    if (this.texture) {
      const scene = (_a = this.texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;
      scene === null || scene === void 0 ? void 0 : scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this.texture);
      });
    }
  }
  get convertToGammaSpace() {
    return this._convertToGammaSpace;
  }
  set convertToLinearSpace(value) {
    var _a;
    if (value === this._convertToLinearSpace) {
      return;
    }
    this._convertToLinearSpace = value;
    if (this.texture) {
      const scene = (_a = this.texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;
      scene === null || scene === void 0 ? void 0 : scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this.texture);
      });
    }
  }
  get convertToLinearSpace() {
    return this._convertToLinearSpace;
  }
  getClassName() {
    return "TriPlanarBlock";
  }
  get position() {
    return this._inputs[0];
  }
  get normal() {
    return this._inputs[1];
  }
  get sharpness() {
    return this._inputs[2];
  }
  get source() {
    return this._inputs[3];
  }
  get sourceY() {
    return this._inputs[4];
  }
  get sourceZ() {
    return this._inputs[5];
  }
  get rgba() {
    return this._outputs[0];
  }
  get rgb() {
    return this._outputs[1];
  }
  get r() {
    return this._outputs[2];
  }
  get g() {
    return this._outputs[3];
  }
  get b() {
    return this._outputs[4];
  }
  get a() {
    return this._outputs[5];
  }
  get level() {
    return this._outputs[6];
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    if (!defines._areTexturesDirty) {
      return;
    }
    const toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;
    const toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace;
    defines.setValue(this._linearDefineName, toGamma, true);
    defines.setValue(this._gammaDefineName, toLinear, true);
  }
  isReady() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  bind(effect) {
    if (!this.texture) {
      return;
    }
    effect.setFloat(this._textureInfoName, this.texture.level);
    if (!this._imageSource) {
      effect.setTexture(this._samplerName, this.texture);
    }
  }
  _generateTextureLookup(state) {
    var _a, _b;
    const samplerName = this.samplerName;
    const samplerYName = (_a = this.samplerYName) !== null && _a !== void 0 ? _a : samplerName;
    const samplerZName = (_b = this.samplerZName) !== null && _b !== void 0 ? _b : samplerName;
    const sharpness = this.sharpness.isConnected ? this.sharpness.associatedVariableName : "1.0";
    const x = state._getFreeVariableName("x");
    const y = state._getFreeVariableName("y");
    const z = state._getFreeVariableName("z");
    const w = state._getFreeVariableName("z");
    state.compilationString += `
            vec4 ${x} = texture2D(${samplerName}, ${this.position.associatedVariableName}.yz);
            vec4 ${y} = texture2D(${samplerYName}, ${this.position.associatedVariableName}.zx);
            vec4 ${z} = texture2D(${samplerZName}, ${this.position.associatedVariableName}.xy);
            
            // blend weights
            vec3 ${w} = pow(abs(${this.normal.associatedVariableName}.xyz), vec3(${sharpness}));

            // blend and return
            vec4 ${this._tempTextureRead} = (${x}*${w}.x + ${y}*${w}.y + ${z}*${w}.z) / (${w}.x + ${w}.y + ${w}.z);        
        `;
  }
  _generateConversionCode(state, output, swizzle) {
    if (swizzle !== "a") {
      if (!this.texture || !this.texture.gammaSpace) {
        state.compilationString += `#ifdef ${this._linearDefineName}
                    ${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});
                    #endif
                `;
      }
      state.compilationString += `#ifdef ${this._gammaDefineName}
                ${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});
                #endif
            `;
    }
  }
  _writeOutput(state, output, swizzle) {
    let complement = "";
    if (!this.disableLevelMultiplication) {
      complement = ` * ${this._textureInfoName}`;
    }
    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle}${complement};\r
`;
    this._generateConversionCode(state, output, swizzle);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (this.source.isConnected) {
      this._imageSource = this.source.connectedPoint.ownerBlock;
    } else {
      this._imageSource = null;
    }
    this._textureInfoName = state._getFreeVariableName("textureInfoName");
    this.level.associatedVariableName = this._textureInfoName;
    this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
    this._linearDefineName = state._getFreeDefineName("ISLINEAR");
    this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
    if (!this._imageSource) {
      this._samplerName = state._getFreeVariableName(this.name + "Sampler");
      state._emit2DSampler(this._samplerName);
    }
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.textureBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.bindableBlocks.push(this);
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    state._emitUniformFromString(this._textureInfoName, "float");
    this._generateTextureLookup(state);
    for (const output of this._outputs) {
      if (output.hasEndpoints && output.name !== "level") {
        this._writeOutput(state, output, output.name);
      }
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\r
`;
    codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\r
`;
    codeString += `${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};\r
`;
    if (!this.texture) {
      return codeString;
    }
    codeString += `${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\r
`;
    codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\r
`;
    codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\r
`;
    codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\r
`;
    codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\r
`;
    codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\r
`;
    codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\r
`;
    codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\r
`;
    codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\r
`;
    codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\r
`;
    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;
    if (!this.hasImageSource && this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== "VideoTexture") {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;
    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== void 0) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
    }
  }
};
RegisterClass("BABYLON.TriPlanarBlock", TriPlanarBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/biPlanarBlock.js
var BiPlanarBlock = class extends TriPlanarBlock {
  constructor(name137) {
    super(name137, true);
  }
  getClassName() {
    return "BiPlanarBlock";
  }
  _generateTextureLookup(state) {
    var _a;
    const samplerName = this.samplerName;
    const samplerYName = (_a = this.samplerYName) !== null && _a !== void 0 ? _a : this.samplerName;
    const sharpness = this.sharpness.isConnected ? this.sharpness.associatedVariableName : "1.0";
    const dpdx = state._getFreeVariableName("dpdx");
    const dpdy = state._getFreeVariableName("dpdy");
    const n = state._getFreeVariableName("n");
    const ma = state._getFreeVariableName("ma");
    const mi = state._getFreeVariableName("mi");
    const me = state._getFreeVariableName("me");
    const x = state._getFreeVariableName("x");
    const y = state._getFreeVariableName("y");
    const w = state._getFreeVariableName("y");
    state.compilationString += `
            // grab coord derivatives for texturing
            vec3 ${dpdx} = dFdx(${this.position.associatedVariableName}.xyz);
            vec3 ${dpdy} = dFdy(${this.position.associatedVariableName}.xyz);
            vec3 ${n} = abs(${this.normal.associatedVariableName}.xyz);
        
            // determine major axis (in x; yz are following axis)
            ivec3 ${ma} = (${n}.x>${n}.y && ${n}.x>${n}.z) ? ivec3(0,1,2) :
                    (${n}.y>${n}.z)            ? ivec3(1,2,0) :
                                            ivec3(2,0,1) ;
            // determine minor axis (in x; yz are following axis)
            ivec3 ${mi} = (${n}.x<${n}.y && ${n}.x<${n}.z) ? ivec3(0,1,2) :
                    (${n}.y<${n}.z)            ? ivec3(1,2,0) :
                                            ivec3(2,0,1) ;
            // determine median axis (in x;  yz are following axis)
            ivec3 ${me} = ivec3(3) - ${mi} - ${ma};
            
            // project+fetch
            vec4 ${x} = textureGrad( ${samplerName}, vec2(   ${this.position.associatedVariableName}[${ma}.y],   ${this.position.associatedVariableName}[${ma}.z]), 
                                    vec2(${dpdx}[${ma}.y],${dpdx}[${ma}.z]), 
                                    vec2(${dpdy}[${ma}.y],${dpdy}[${ma}.z]) );
            vec4 ${y} = textureGrad( ${samplerYName}, vec2(   ${this.position.associatedVariableName}[${me}.y],   ${this.position.associatedVariableName}[${me}.z]), 
                                    vec2(${dpdx}[${me}.y],${dpdx}[${me}.z]),
                                    vec2(${dpdy}[${me}.y],${dpdy}[${me}.z]) );
            
            // blend factors
            vec2 ${w} = vec2(${n}[${ma}.x],${n}[${me}.x]);
            // make local support
            ${w} = clamp( (${w}-0.5773)/(1.0-0.5773), 0.0, 1.0 );
            // shape transition
            ${w} = pow( ${w}, vec2(${sharpness}/8.0) );
            // blend and return
            vec4 ${this._tempTextureRead} = (${x}*${w}.x + ${y}*${w}.y) / (${w}.x + ${w}.y);
        `;
  }
};
RegisterClass("BABYLON.BiPlanarBlock", BiPlanarBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/matrixDeterminantBlock.js
var MatrixDeterminantBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.Matrix);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
  }
  getClassName() {
    return "MatrixDeterminantBlock";
  }
  get input() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this.output;
    const input = this.input;
    state.compilationString += this._declareOutput(output, state) + `${output.associatedVariableName} = determinant(${input.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.MatrixDeterminantBlock", MatrixDeterminantBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/matrixTransposeBlock.js
var MatrixTransposeBlock = class extends NodeMaterialBlock {
  constructor(name137) {
    super(name137, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.Matrix);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  getClassName() {
    return "MatrixTransposeBlock";
  }
  get input() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this.output;
    const input = this.input;
    state.compilationString += this._declareOutput(output, state) + `${output.associatedVariableName} = transpose(${input.associatedVariableName});\r
`;
    return this;
  }
};
RegisterClass("BABYLON.MatrixTransposeBlock", MatrixTransposeBlock);

// node_modules/@babylonjs/core/Materials/Node/Optimizers/nodeMaterialOptimizer.js
var NodeMaterialOptimizer = class {
  optimize(_vertexOutputNodes, _fragmentOutputNodes) {
  }
};

// node_modules/@babylonjs/core/Materials/shadowDepthWrapper.js
var MapMap = class {
  constructor() {
    this.mm = /* @__PURE__ */ new Map();
  }
  get(a, b) {
    const m = this.mm.get(a);
    if (m !== void 0) {
      return m.get(b);
    }
    return void 0;
  }
  set(a, b, v) {
    let m = this.mm.get(a);
    if (m === void 0) {
      this.mm.set(a, m = /* @__PURE__ */ new Map());
    }
    m.set(b, v);
  }
};
var ShadowDepthWrapper = class {
  constructor(baseMaterial, scene, options) {
    this._baseMaterial = baseMaterial;
    this._scene = scene !== null && scene !== void 0 ? scene : EngineStore.LastCreatedScene;
    this._options = options;
    this._subMeshToEffect = /* @__PURE__ */ new Map();
    this._subMeshToDepthWrapper = new MapMap();
    this._meshes = /* @__PURE__ */ new Map();
    this._onEffectCreatedObserver = this._baseMaterial.onEffectCreatedObservable.add((params) => {
      var _a;
      const mesh = (_a = params.subMesh) === null || _a === void 0 ? void 0 : _a.getMesh();
      if (mesh && !this._meshes.has(mesh)) {
        this._meshes.set(mesh, mesh.onDisposeObservable.add((mesh2) => {
          const iterator = this._subMeshToEffect.keys();
          for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
            const subMesh = key.value;
            if ((subMesh === null || subMesh === void 0 ? void 0 : subMesh.getMesh()) === mesh2) {
              this._subMeshToEffect.delete(subMesh);
              this._subMeshToDepthWrapper.mm.delete(subMesh);
            }
          }
        }));
      }
      this._subMeshToEffect.set(params.subMesh, [params.effect, this._scene.getEngine().currentRenderPassId]);
      this._subMeshToDepthWrapper.mm.delete(params.subMesh);
    });
  }
  get standalone() {
    var _a, _b;
    return (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.standalone) !== null && _b !== void 0 ? _b : false;
  }
  get baseMaterial() {
    return this._baseMaterial;
  }
  get doNotInjectCode() {
    var _a, _b;
    return (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.doNotInjectCode) !== null && _b !== void 0 ? _b : false;
  }
  getEffect(subMesh, shadowGenerator, passIdForDrawWrapper) {
    var _a;
    const entry = (_a = this._subMeshToDepthWrapper.mm.get(subMesh)) === null || _a === void 0 ? void 0 : _a.get(shadowGenerator);
    if (!entry) {
      return null;
    }
    let drawWrapper = entry.drawWrapper[passIdForDrawWrapper];
    if (!drawWrapper) {
      drawWrapper = entry.drawWrapper[passIdForDrawWrapper] = new DrawWrapper(this._scene.getEngine());
      drawWrapper.setEffect(entry.mainDrawWrapper.effect, entry.mainDrawWrapper.defines);
    }
    return drawWrapper;
  }
  isReadyForSubMesh(subMesh, defines, shadowGenerator, useInstances, passIdForDrawWrapper) {
    var _a, _b;
    if (this.standalone) {
      if (!this._baseMaterial.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances)) {
        return false;
      }
    }
    return (_b = (_a = this._makeEffect(subMesh, defines, shadowGenerator, passIdForDrawWrapper)) === null || _a === void 0 ? void 0 : _a.isReady()) !== null && _b !== void 0 ? _b : false;
  }
  dispose() {
    this._baseMaterial.onEffectCreatedObservable.remove(this._onEffectCreatedObserver);
    this._onEffectCreatedObserver = null;
    const iterator = this._meshes.entries();
    for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {
      const [mesh, observer] = entry.value;
      mesh.onDisposeObservable.remove(observer);
    }
  }
  _makeEffect(subMesh, defines, shadowGenerator, passIdForDrawWrapper) {
    var _a, _b, _c;
    const engine = this._scene.getEngine();
    const origEffectAndRenderPassId = this._subMeshToEffect.get(subMesh);
    if (!origEffectAndRenderPassId) {
      return null;
    }
    const [origEffect, origRenderPassId] = origEffectAndRenderPassId;
    let params = this._subMeshToDepthWrapper.get(subMesh, shadowGenerator);
    if (!params) {
      const mainDrawWrapper = new DrawWrapper(engine);
      mainDrawWrapper.defines = (_b = (_a = subMesh._getDrawWrapper(origRenderPassId)) === null || _a === void 0 ? void 0 : _a.defines) !== null && _b !== void 0 ? _b : null;
      params = {
        drawWrapper: [],
        mainDrawWrapper,
        depthDefines: "",
        token: RandomGUID()
      };
      params.drawWrapper[passIdForDrawWrapper] = mainDrawWrapper;
      this._subMeshToDepthWrapper.set(subMesh, shadowGenerator, params);
    }
    const join = defines.join("\n");
    if (params.mainDrawWrapper.effect) {
      if (join === params.depthDefines) {
        return params.mainDrawWrapper.effect;
      }
    }
    params.depthDefines = join;
    const uniforms = origEffect.getUniformNames().slice();
    let vertexCode = origEffect.vertexSourceCodeBeforeMigration, fragmentCode = origEffect.fragmentSourceCodeBeforeMigration;
    if (!this.doNotInjectCode) {
      const vertexNormalBiasCode = this._options && this._options.remappedVariables ? `#include<shadowMapVertexNormalBias>(${this._options.remappedVariables.join(",")})` : Effect.IncludesShadersStore["shadowMapVertexNormalBias"], vertexMetricCode = this._options && this._options.remappedVariables ? `#include<shadowMapVertexMetric>(${this._options.remappedVariables.join(",")})` : Effect.IncludesShadersStore["shadowMapVertexMetric"], fragmentSoftTransparentShadow = this._options && this._options.remappedVariables ? `#include<shadowMapFragmentSoftTransparentShadow>(${this._options.remappedVariables.join(",")})` : Effect.IncludesShadersStore["shadowMapFragmentSoftTransparentShadow"], fragmentBlockCode = Effect.IncludesShadersStore["shadowMapFragment"];
      vertexCode = vertexCode.replace(/void\s+?main/g, Effect.IncludesShadersStore["shadowMapVertexExtraDeclaration"] + "\r\nvoid main");
      vertexCode = vertexCode.replace(/#define SHADOWDEPTH_NORMALBIAS|#define CUSTOM_VERTEX_UPDATE_WORLDPOS/g, vertexNormalBiasCode);
      if (vertexCode.indexOf("#define SHADOWDEPTH_METRIC") !== -1) {
        vertexCode = vertexCode.replace(/#define SHADOWDEPTH_METRIC/g, vertexMetricCode);
      } else {
        vertexCode = vertexCode.replace(/}\s*$/g, vertexMetricCode + "\r\n}");
      }
      vertexCode = vertexCode.replace(/#define SHADER_NAME.*?\n|out vec4 glFragColor;\n/g, "");
      const hasLocationForSoftTransparentShadow = fragmentCode.indexOf("#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW") >= 0 || fragmentCode.indexOf("#define CUSTOM_FRAGMENT_BEFORE_FOG") >= 0;
      const hasLocationForFragment = fragmentCode.indexOf("#define SHADOWDEPTH_FRAGMENT") !== -1;
      let fragmentCodeToInjectAtEnd = "";
      if (!hasLocationForSoftTransparentShadow) {
        fragmentCodeToInjectAtEnd = fragmentSoftTransparentShadow + "\r\n";
      } else {
        fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW|#define CUSTOM_FRAGMENT_BEFORE_FOG/g, fragmentSoftTransparentShadow);
      }
      fragmentCode = fragmentCode.replace(/void\s+?main/g, Effect.IncludesShadersStore["shadowMapFragmentExtraDeclaration"] + "\r\nvoid main");
      if (hasLocationForFragment) {
        fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_FRAGMENT/g, fragmentBlockCode);
      } else {
        fragmentCodeToInjectAtEnd += fragmentBlockCode + "\r\n";
      }
      if (fragmentCodeToInjectAtEnd) {
        fragmentCode = fragmentCode.replace(/}\s*$/g, fragmentCodeToInjectAtEnd + "}");
      }
      uniforms.push("biasAndScaleSM", "depthValuesSM", "lightDataSM", "softTransparentShadowSM");
    }
    params.mainDrawWrapper.effect = engine.createEffect({
      vertexSource: vertexCode,
      fragmentSource: fragmentCode,
      vertexToken: params.token,
      fragmentToken: params.token
    }, {
      attributes: origEffect.getAttributesNames(),
      uniformsNames: uniforms,
      uniformBuffersNames: origEffect.getUniformBuffersNames(),
      samplers: origEffect.getSamplers(),
      defines: join + "\n" + origEffect.defines.replace("#define SHADOWS", "").replace(/#define SHADOW\d/g, ""),
      indexParameters: origEffect.getIndexParameters()
    }, engine);
    for (let id = 0; id < params.drawWrapper.length; ++id) {
      if (id !== passIdForDrawWrapper) {
        (_c = params.drawWrapper[id]) === null || _c === void 0 ? void 0 : _c.setEffect(params.mainDrawWrapper.effect, params.mainDrawWrapper.defines);
      }
    }
    return params.mainDrawWrapper.effect;
  }
};

// node_modules/@babylonjs/core/Materials/materialPluginFactoryExport.js
function createPBRAnisotropicPlugin(material) {
  if (material instanceof PBRBaseMaterial) {
    return new PBRAnisotropicConfiguration(material);
  }
  return null;
}
function createPBRBRDFPlugin(material) {
  if (material instanceof PBRBaseMaterial) {
    return new PBRBRDFConfiguration(material);
  }
  return null;
}
function createPBRClearCoatPlugin(material) {
  if (material instanceof PBRBaseMaterial) {
    return new PBRClearCoatConfiguration(material);
  }
  return null;
}
function createPBRIridescencePlugin(material) {
  if (material instanceof PBRBaseMaterial) {
    return new PBRIridescenceConfiguration(material);
  }
  return null;
}
function createPBRSheenPlugin(material) {
  if (material instanceof PBRBaseMaterial) {
    return new PBRSheenConfiguration(material);
  }
  return null;
}
function createPBRSubSurfacePlugin(material) {
  if (material instanceof PBRBaseMaterial) {
    return new PBRSubSurfaceConfiguration(material);
  }
  return null;
}
function createDetailMapPlugin(material) {
  if (material instanceof PBRBaseMaterial || material instanceof StandardMaterial) {
    return new DetailMapConfiguration(material);
  }
  return null;
}

// node_modules/@babylonjs/core/Maths/math.polar.js
var Polar = class {
  constructor(radius, theta) {
    this.radius = radius;
    this.theta = theta;
  }
  getClassName() {
    return "Polar";
  }
  toString() {
    return JSON.stringify(this);
  }
  asArray() {
    return [this.radius, this.theta];
  }
  addToRef(polar, ref) {
    ref.radius = this.radius + polar.radius;
    ref.theta = this.theta + polar.theta;
    return ref;
  }
  add(polar) {
    const ref = new Polar(0, 0);
    this.addToRef(polar, ref);
    return ref;
  }
  addInPlace(polar) {
    this.addToRef(polar, this);
    return this;
  }
  addInPlaceFromFloats(radius, theta) {
    this.radius += radius;
    this.theta += theta;
    return this;
  }
  subtractToRef(polar, ref) {
    ref.radius = this.radius - polar.radius;
    ref.theta = this.theta - polar.theta;
    return ref;
  }
  subtract(polar) {
    const ref = new Polar(0, 0);
    this.subtractToRef(polar, ref);
    return ref;
  }
  subtractInPlace(polar) {
    this.subtractToRef(polar, this);
    return this;
  }
  subtractFromFloatsToRef(radius, theta, ref) {
    ref.radius = this.radius - radius;
    ref.theta = this.theta - theta;
    return ref;
  }
  subtractFromFloats(radius, theta) {
    const ref = new Polar(0, 0);
    this.subtractFromFloatsToRef(radius, theta, ref);
    return ref;
  }
  multiplyToRef(polar, ref) {
    ref.radius = this.radius * polar.radius;
    ref.theta = this.theta * polar.theta;
    return ref;
  }
  multiply(polar) {
    const ref = new Polar(0, 0);
    this.multiplyToRef(polar, ref);
    return ref;
  }
  multiplyInPlace(polar) {
    this.multiplyToRef(polar, this);
    return this;
  }
  divideToRef(polar, ref) {
    ref.radius = this.radius / polar.radius;
    ref.theta = this.theta / polar.theta;
    return ref;
  }
  divide(polar) {
    const ref = new Polar(0, 0);
    this.divideToRef(polar, ref);
    return ref;
  }
  divideInPlace(polar) {
    this.divideToRef(polar, this);
    return this;
  }
  clone() {
    return new Polar(this.radius, this.theta);
  }
  copyFrom(source) {
    this.radius = source.radius;
    this.theta = source.theta;
    return this;
  }
  copyFromFloats(radius, theta) {
    this.radius = radius;
    this.theta = theta;
    return this;
  }
  scaleToRef(scale, ref) {
    ref.radius = this.radius * scale;
    ref.theta = this.theta * scale;
    return ref;
  }
  scale(scale) {
    const ref = new Polar(0, 0);
    this.scaleToRef(scale, ref);
    return ref;
  }
  scaleInPlace(scale) {
    this.scaleToRef(scale, this);
    return this;
  }
  set(radius, theta) {
    this.radius = radius;
    this.theta = theta;
    return this;
  }
  setAll(value) {
    this.set(value, value);
    return this;
  }
  toVector2ToRef(ref) {
    const x = this.radius * Math.cos(this.theta);
    const y = this.radius * Math.sin(this.theta);
    ref.set(x, y);
    return ref;
  }
  toVector2() {
    const ref = new Vector2(0, 0);
    return this.toVector2ToRef(ref);
  }
  static FromVector2ToRef(v, ref) {
    const theta = Math.sign(v.y) * Math.acos(v.x / v.length());
    ref.radius = v.length();
    ref.theta = theta;
    return ref;
  }
  static FromVector2(v) {
    const polar = new Polar(0, 0);
    Polar.FromVector2ToRef(v, polar);
    return polar;
  }
  static FromArray(array) {
    return new Polar(array[0], array[1]);
  }
};
var Spherical = class {
  constructor(radius, theta, phi) {
    this.radius = radius;
    this.theta = theta;
    this.phi = phi;
  }
  getClassName() {
    return "Spherical";
  }
  toString() {
    return JSON.stringify(this);
  }
  asArray() {
    return [this.radius, this.theta, this.phi];
  }
  addToRef(spherical, ref) {
    ref.radius = this.radius + spherical.radius;
    ref.theta = this.theta + spherical.theta;
    ref.phi = this.phi + spherical.phi;
    return ref;
  }
  add(spherical) {
    const ref = new Spherical(0, 0, 0);
    this.addToRef(spherical, ref);
    return ref;
  }
  addInPlace(spherical) {
    this.addToRef(spherical, this);
    return this;
  }
  addInPlaceFromFloats(radius, theta, phi) {
    this.radius += radius;
    this.theta += theta;
    this.phi += phi;
    return this;
  }
  subtractToRef(spherical, ref) {
    ref.radius = this.radius - spherical.radius;
    ref.theta = this.theta - spherical.theta;
    ref.phi = this.phi - spherical.phi;
    return ref;
  }
  subtract(spherical) {
    const ref = new Spherical(0, 0, 0);
    this.subtractToRef(spherical, ref);
    return ref;
  }
  subtractInPlace(spherical) {
    this.subtractToRef(spherical, this);
    return this;
  }
  subtractFromFloatsToRef(radius, theta, phi, ref) {
    ref.radius = this.radius - radius;
    ref.theta = this.theta - theta;
    ref.phi = this.phi - phi;
    return ref;
  }
  subtractFromFloats(radius, theta, phi) {
    const ref = new Spherical(0, 0, 0);
    this.subtractFromFloatsToRef(radius, theta, phi, ref);
    return ref;
  }
  multiplyToRef(spherical, ref) {
    ref.radius = this.radius * spherical.radius;
    ref.theta = this.theta * spherical.theta;
    ref.phi = this.phi * spherical.phi;
    return ref;
  }
  multiply(spherical) {
    const ref = new Spherical(0, 0, 0);
    this.multiplyToRef(spherical, ref);
    return ref;
  }
  multiplyInPlace(spherical) {
    this.multiplyToRef(spherical, this);
    return this;
  }
  divideToRef(spherical, ref) {
    ref.radius = this.radius / spherical.radius;
    ref.theta = this.theta / spherical.theta;
    ref.phi = this.phi / spherical.phi;
    return ref;
  }
  divide(spherical) {
    const ref = new Spherical(0, 0, 0);
    this.divideToRef(spherical, ref);
    return ref;
  }
  divideInPlace(spherical) {
    this.divideToRef(spherical, this);
    return this;
  }
  clone() {
    return new Spherical(this.radius, this.theta, this.phi);
  }
  copyFrom(source) {
    this.radius = source.radius;
    this.theta = source.theta;
    this.phi = source.phi;
    return this;
  }
  copyFromFloats(radius, theta, phi) {
    this.radius = radius;
    this.theta = theta;
    this.phi = phi;
    return this;
  }
  scaleToRef(scale, ref) {
    ref.radius = this.radius * scale;
    ref.theta = this.theta * scale;
    ref.phi = this.phi * scale;
    return ref;
  }
  scale(scale) {
    const ref = new Spherical(0, 0, 0);
    this.scaleToRef(scale, ref);
    return ref;
  }
  scaleInPlace(scale) {
    this.scaleToRef(scale, this);
    return this;
  }
  set(radius, theta, phi) {
    this.radius = radius;
    this.theta = theta;
    this.phi = phi;
    return this;
  }
  setAll(value) {
    this.set(value, value, value);
    return this;
  }
  toVector3ToRef(ref) {
    const x = this.radius * Math.sin(this.theta) * Math.cos(this.phi);
    const y = this.radius * Math.cos(this.theta);
    const z = this.radius * Math.sin(this.theta) * Math.sin(this.phi);
    ref.set(x, y, z);
    return ref;
  }
  toVector3() {
    const ref = new Vector3(0, 0, 0);
    return this.toVector3ToRef(ref);
  }
  static FromVector3ToRef(vector, ref) {
    ref.radius = vector.length();
    ref.theta = Math.acos(vector.y / ref.radius);
    ref.phi = Math.atan2(vector.z, vector.x);
    return ref;
  }
  static FromVector3(vector) {
    const spherical = new Spherical(0, 0, 0);
    Spherical.FromVector3ToRef(vector, spherical);
    return spherical;
  }
  static FromArray(array) {
    return new Spherical(array[0], array[1], array[2]);
  }
};

// node_modules/@babylonjs/core/Meshes/csg.js
var currentCSGMeshId = 0;
var Vertex = class {
  constructor(pos, normal, uv, vertColor) {
    this.pos = pos;
    this.normal = normal;
    this.uv = uv;
    this.vertColor = vertColor;
  }
  clone() {
    var _a, _b;
    return new Vertex(this.pos.clone(), this.normal.clone(), (_a = this.uv) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.vertColor) === null || _b === void 0 ? void 0 : _b.clone());
  }
  flip() {
    this.normal = this.normal.scale(-1);
  }
  interpolate(other, t) {
    return new Vertex(Vector3.Lerp(this.pos, other.pos, t), Vector3.Lerp(this.normal, other.normal, t), this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : void 0, this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : void 0);
  }
};
var Plane2 = class {
  constructor(normal, w) {
    this.normal = normal;
    this.w = w;
  }
  static FromPoints(a, b, c) {
    const v0 = c.subtract(a);
    const v1 = b.subtract(a);
    if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {
      return null;
    }
    const n = Vector3.Normalize(Vector3.Cross(v0, v1));
    return new Plane2(n, Vector3.Dot(n, a));
  }
  clone() {
    return new Plane2(this.normal.clone(), this.w);
  }
  flip() {
    this.normal.scaleInPlace(-1);
    this.w = -this.w;
  }
  splitPolygon(polygon, coplanarFront, coplanarBack, front, back) {
    const COPLANAR = 0;
    const FRONT = 1;
    const BACK = 2;
    const SPANNING = 3;
    let polygonType = 0;
    const types = [];
    let i;
    let t;
    for (i = 0; i < polygon.vertices.length; i++) {
      t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;
      const type = t < -Plane2.EPSILON ? BACK : t > Plane2.EPSILON ? FRONT : COPLANAR;
      polygonType |= type;
      types.push(type);
    }
    switch (polygonType) {
      case COPLANAR:
        (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);
        break;
      case FRONT:
        front.push(polygon);
        break;
      case BACK:
        back.push(polygon);
        break;
      case SPANNING: {
        const f = [], b = [];
        for (i = 0; i < polygon.vertices.length; i++) {
          const j = (i + 1) % polygon.vertices.length;
          const ti = types[i], tj = types[j];
          const vi = polygon.vertices[i], vj = polygon.vertices[j];
          if (ti !== BACK) {
            f.push(vi);
          }
          if (ti !== FRONT) {
            b.push(ti !== BACK ? vi.clone() : vi);
          }
          if ((ti | tj) === SPANNING) {
            t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));
            const v = vi.interpolate(vj, t);
            f.push(v);
            b.push(v.clone());
          }
        }
        let poly;
        if (f.length >= 3) {
          poly = new Polygon(f, polygon.shared);
          if (poly.plane) {
            front.push(poly);
          }
        }
        if (b.length >= 3) {
          poly = new Polygon(b, polygon.shared);
          if (poly.plane) {
            back.push(poly);
          }
        }
        break;
      }
    }
  }
};
Plane2.EPSILON = 1e-5;
var Polygon = class {
  constructor(vertices, shared) {
    this.vertices = vertices;
    this.shared = shared;
    this.plane = Plane2.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);
  }
  clone() {
    const vertices = this.vertices.map((v) => v.clone());
    return new Polygon(vertices, this.shared);
  }
  flip() {
    this.vertices.reverse().map((v) => {
      v.flip();
    });
    this.plane.flip();
  }
};
var Node3 = class {
  constructor(polygons) {
    this._plane = null;
    this._front = null;
    this._back = null;
    this._polygons = new Array();
    if (polygons) {
      this.build(polygons);
    }
  }
  clone() {
    const node = new Node3();
    node._plane = this._plane && this._plane.clone();
    node._front = this._front && this._front.clone();
    node._back = this._back && this._back.clone();
    node._polygons = this._polygons.map((p) => p.clone());
    return node;
  }
  invert() {
    for (let i = 0; i < this._polygons.length; i++) {
      this._polygons[i].flip();
    }
    if (this._plane) {
      this._plane.flip();
    }
    if (this._front) {
      this._front.invert();
    }
    if (this._back) {
      this._back.invert();
    }
    const temp = this._front;
    this._front = this._back;
    this._back = temp;
  }
  clipPolygons(polygons) {
    if (!this._plane) {
      return polygons.slice();
    }
    let front = new Array(), back = new Array();
    for (let i = 0; i < polygons.length; i++) {
      this._plane.splitPolygon(polygons[i], front, back, front, back);
    }
    if (this._front) {
      front = this._front.clipPolygons(front);
    }
    if (this._back) {
      back = this._back.clipPolygons(back);
    } else {
      back = [];
    }
    return front.concat(back);
  }
  clipTo(bsp) {
    this._polygons = bsp.clipPolygons(this._polygons);
    if (this._front) {
      this._front.clipTo(bsp);
    }
    if (this._back) {
      this._back.clipTo(bsp);
    }
  }
  allPolygons() {
    let polygons = this._polygons.slice();
    if (this._front) {
      polygons = polygons.concat(this._front.allPolygons());
    }
    if (this._back) {
      polygons = polygons.concat(this._back.allPolygons());
    }
    return polygons;
  }
  build(polygons) {
    if (!polygons.length) {
      return;
    }
    if (!this._plane) {
      this._plane = polygons[0].plane.clone();
    }
    const front = new Array(), back = new Array();
    for (let i = 0; i < polygons.length; i++) {
      this._plane.splitPolygon(polygons[i], this._polygons, this._polygons, front, back);
    }
    if (front.length) {
      if (!this._front) {
        this._front = new Node3();
      }
      this._front.build(front);
    }
    if (back.length) {
      if (!this._back) {
        this._back = new Node3();
      }
      this._back.build(back);
    }
  }
};
var CSG = class {
  constructor() {
    this._polygons = new Array();
  }
  static FromMesh(mesh, absolute = false) {
    let vertex, normal, uv = void 0, position, vertColor = void 0, polygon, vertices;
    const polygons = new Array();
    let matrix, meshPosition, meshRotation, meshRotationQuaternion = null, meshScaling;
    let invertWinding = false;
    if (mesh instanceof Mesh) {
      mesh.computeWorldMatrix(true);
      matrix = mesh.getWorldMatrix();
      meshPosition = mesh.position.clone();
      meshRotation = mesh.rotation.clone();
      if (mesh.rotationQuaternion) {
        meshRotationQuaternion = mesh.rotationQuaternion.clone();
      }
      meshScaling = mesh.scaling.clone();
      if (mesh.material && absolute) {
        invertWinding = mesh.material.sideOrientation === 0;
      }
    } else {
      throw "BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh";
    }
    const indices = mesh.getIndices(), positions = mesh.getVerticesData(VertexBuffer.PositionKind), normals = mesh.getVerticesData(VertexBuffer.NormalKind), uvs = mesh.getVerticesData(VertexBuffer.UVKind), vertColors = mesh.getVerticesData(VertexBuffer.ColorKind);
    const subMeshes = mesh.subMeshes;
    for (let sm = 0, sml = subMeshes.length; sm < sml; sm++) {
      for (let i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {
        vertices = [];
        for (let j = 0; j < 3; j++) {
          const indexIndices = j === 0 ? i + j : invertWinding ? i + 3 - j : i + j;
          const sourceNormal = new Vector3(normals[indices[indexIndices] * 3], normals[indices[indexIndices] * 3 + 1], normals[indices[indexIndices] * 3 + 2]);
          if (uvs) {
            uv = new Vector2(uvs[indices[indexIndices] * 2], uvs[indices[indexIndices] * 2 + 1]);
          }
          if (vertColors) {
            vertColor = new Color4(vertColors[indices[indexIndices] * 4], vertColors[indices[indexIndices] * 4 + 1], vertColors[indices[indexIndices] * 4 + 2], vertColors[indices[indexIndices] * 4 + 3]);
          }
          const sourcePosition = new Vector3(positions[indices[indexIndices] * 3], positions[indices[indexIndices] * 3 + 1], positions[indices[indexIndices] * 3 + 2]);
          position = Vector3.TransformCoordinates(sourcePosition, matrix);
          normal = Vector3.TransformNormal(sourceNormal, matrix);
          vertex = new Vertex(position, normal, uv, vertColor);
          vertices.push(vertex);
        }
        polygon = new Polygon(vertices, { subMeshId: sm, meshId: currentCSGMeshId, materialIndex: subMeshes[sm].materialIndex });
        if (polygon.plane) {
          polygons.push(polygon);
        }
      }
    }
    const csg = CSG._FromPolygons(polygons);
    csg.matrix = absolute ? Matrix.Identity() : matrix;
    csg.position = absolute ? Vector3.Zero() : meshPosition;
    csg.rotation = absolute ? Vector3.Zero() : meshRotation;
    csg.scaling = absolute ? Vector3.One() : meshScaling;
    csg.rotationQuaternion = absolute && meshRotationQuaternion ? Quaternion.Identity() : meshRotationQuaternion;
    currentCSGMeshId++;
    return csg;
  }
  static _FromPolygons(polygons) {
    const csg = new CSG();
    csg._polygons = polygons;
    return csg;
  }
  clone() {
    const csg = new CSG();
    csg._polygons = this._polygons.map((p) => p.clone());
    csg.copyTransformAttributes(this);
    return csg;
  }
  union(csg) {
    const a = new Node3(this.clone()._polygons);
    const b = new Node3(csg.clone()._polygons);
    a.clipTo(b);
    b.clipTo(a);
    b.invert();
    b.clipTo(a);
    b.invert();
    a.build(b.allPolygons());
    return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);
  }
  unionInPlace(csg) {
    const a = new Node3(this._polygons);
    const b = new Node3(csg._polygons);
    a.clipTo(b);
    b.clipTo(a);
    b.invert();
    b.clipTo(a);
    b.invert();
    a.build(b.allPolygons());
    this._polygons = a.allPolygons();
  }
  subtract(csg) {
    const a = new Node3(this.clone()._polygons);
    const b = new Node3(csg.clone()._polygons);
    a.invert();
    a.clipTo(b);
    b.clipTo(a);
    b.invert();
    b.clipTo(a);
    b.invert();
    a.build(b.allPolygons());
    a.invert();
    return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);
  }
  subtractInPlace(csg) {
    const a = new Node3(this._polygons);
    const b = new Node3(csg._polygons);
    a.invert();
    a.clipTo(b);
    b.clipTo(a);
    b.invert();
    b.clipTo(a);
    b.invert();
    a.build(b.allPolygons());
    a.invert();
    this._polygons = a.allPolygons();
  }
  intersect(csg) {
    const a = new Node3(this.clone()._polygons);
    const b = new Node3(csg.clone()._polygons);
    a.invert();
    b.clipTo(a);
    b.invert();
    a.clipTo(b);
    b.clipTo(a);
    a.build(b.allPolygons());
    a.invert();
    return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);
  }
  intersectInPlace(csg) {
    const a = new Node3(this._polygons);
    const b = new Node3(csg._polygons);
    a.invert();
    b.clipTo(a);
    b.invert();
    a.clipTo(b);
    b.clipTo(a);
    a.build(b.allPolygons());
    a.invert();
    this._polygons = a.allPolygons();
  }
  inverse() {
    const csg = this.clone();
    csg.inverseInPlace();
    return csg;
  }
  inverseInPlace() {
    this._polygons.map((p) => {
      p.flip();
    });
  }
  copyTransformAttributes(csg) {
    this.matrix = csg.matrix;
    this.position = csg.position;
    this.rotation = csg.rotation;
    this.scaling = csg.scaling;
    this.rotationQuaternion = csg.rotationQuaternion;
    return this;
  }
  buildMeshGeometry(name137, scene, keepSubMeshes) {
    const matrix = this.matrix.clone();
    matrix.invert();
    const mesh = new Mesh(name137, scene);
    const vertices = [];
    const indices = [];
    const normals = [];
    let uvs = null;
    let vertColors = null;
    const vertex = Vector3.Zero();
    const normal = Vector3.Zero();
    const uv = Vector2.Zero();
    const vertColor = new Color4(0, 0, 0, 0);
    const polygons = this._polygons;
    const polygonIndices = [0, 0, 0];
    let polygon;
    const vertice_dict = {};
    let vertex_idx;
    let currentIndex = 0;
    const subMeshDict = {};
    let subMeshObj;
    if (keepSubMeshes) {
      polygons.sort((a, b) => {
        if (a.shared.meshId === b.shared.meshId) {
          return a.shared.subMeshId - b.shared.subMeshId;
        } else {
          return a.shared.meshId - b.shared.meshId;
        }
      });
    }
    for (let i = 0, il = polygons.length; i < il; i++) {
      polygon = polygons[i];
      if (!subMeshDict[polygon.shared.meshId]) {
        subMeshDict[polygon.shared.meshId] = {};
      }
      if (!subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId]) {
        subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId] = {
          indexStart: Infinity,
          indexEnd: -Infinity,
          materialIndex: polygon.shared.materialIndex
        };
      }
      subMeshObj = subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId];
      for (let j = 2, jl = polygon.vertices.length; j < jl; j++) {
        polygonIndices[0] = 0;
        polygonIndices[1] = j - 1;
        polygonIndices[2] = j;
        for (let k = 0; k < 3; k++) {
          vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);
          normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);
          if (polygon.vertices[polygonIndices[k]].uv) {
            if (!uvs) {
              uvs = [];
            }
            uv.copyFrom(polygon.vertices[polygonIndices[k]].uv);
          }
          if (polygon.vertices[polygonIndices[k]].vertColor) {
            if (!vertColors) {
              vertColors = [];
            }
            vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor);
          }
          const localVertex = Vector3.TransformCoordinates(vertex, matrix);
          const localNormal = Vector3.TransformNormal(normal, matrix);
          vertex_idx = vertice_dict[localVertex.x + "," + localVertex.y + "," + localVertex.z];
          let areUvsDifferent = false;
          if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {
            areUvsDifferent = true;
          }
          let areColorsDifferent = false;
          if (vertColors && !(vertColors[vertex_idx * 4] === vertColor.r || vertColors[vertex_idx * 4 + 1] === vertColor.g || vertColors[vertex_idx * 4 + 2] === vertColor.b || vertColors[vertex_idx * 4 + 3] === vertColor.a)) {
            areColorsDifferent = true;
          }
          if (!(typeof vertex_idx !== "undefined" && normals[vertex_idx * 3] === localNormal.x && normals[vertex_idx * 3 + 1] === localNormal.y && normals[vertex_idx * 3 + 2] === localNormal.z) || areUvsDifferent || areColorsDifferent) {
            vertices.push(localVertex.x, localVertex.y, localVertex.z);
            if (uvs) {
              uvs.push(uv.x, uv.y);
            }
            normals.push(normal.x, normal.y, normal.z);
            if (vertColors) {
              vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);
            }
            vertex_idx = vertice_dict[localVertex.x + "," + localVertex.y + "," + localVertex.z] = vertices.length / 3 - 1;
          }
          indices.push(vertex_idx);
          subMeshObj.indexStart = Math.min(currentIndex, subMeshObj.indexStart);
          subMeshObj.indexEnd = Math.max(currentIndex, subMeshObj.indexEnd);
          currentIndex++;
        }
      }
    }
    mesh.setVerticesData(VertexBuffer.PositionKind, vertices);
    mesh.setVerticesData(VertexBuffer.NormalKind, normals);
    if (uvs) {
      mesh.setVerticesData(VertexBuffer.UVKind, uvs);
    }
    if (vertColors) {
      mesh.setVerticesData(VertexBuffer.ColorKind, vertColors);
    }
    mesh.setIndices(indices, null);
    if (keepSubMeshes) {
      let materialIndexOffset = 0, materialMaxIndex;
      mesh.subMeshes = new Array();
      for (const m in subMeshDict) {
        materialMaxIndex = -1;
        for (const sm in subMeshDict[m]) {
          subMeshObj = subMeshDict[m][sm];
          SubMesh.CreateFromIndices(subMeshObj.materialIndex + materialIndexOffset, subMeshObj.indexStart, subMeshObj.indexEnd - subMeshObj.indexStart + 1, mesh);
          materialMaxIndex = Math.max(subMeshObj.materialIndex, materialMaxIndex);
        }
        materialIndexOffset += ++materialMaxIndex;
      }
    }
    return mesh;
  }
  toMesh(name137, material = null, scene, keepSubMeshes) {
    const mesh = this.buildMeshGeometry(name137, scene, keepSubMeshes);
    mesh.material = material;
    mesh.position.copyFrom(this.position);
    mesh.rotation.copyFrom(this.rotation);
    if (this.rotationQuaternion) {
      mesh.rotationQuaternion = this.rotationQuaternion.clone();
    }
    mesh.scaling.copyFrom(this.scaling);
    mesh.computeWorldMatrix(true);
    return mesh;
  }
};

// node_modules/@babylonjs/core/Meshes/goldbergMesh.js
Mesh._GoldbergMeshParser = (parsedMesh, scene) => {
  return GoldbergMesh.Parse(parsedMesh, scene);
};
var GoldbergMesh = class extends Mesh {
  constructor() {
    super(...arguments);
    this.goldbergData = {
      faceColors: [],
      faceCenters: [],
      faceZaxis: [],
      faceXaxis: [],
      faceYaxis: [],
      nbSharedFaces: 0,
      nbUnsharedFaces: 0,
      nbFaces: 0,
      nbFacesAtPole: 0,
      adjacentFaces: []
    };
  }
  relatedGoldbergFace(poleOrShared, fromPole) {
    if (fromPole === void 0) {
      if (poleOrShared > this.goldbergData.nbUnsharedFaces - 1) {
        Logger.Warn("Maximum number of unshared faces used");
        poleOrShared = this.goldbergData.nbUnsharedFaces - 1;
      }
      return this.goldbergData.nbUnsharedFaces + poleOrShared;
    }
    if (poleOrShared > 11) {
      Logger.Warn("Last pole used");
      poleOrShared = 11;
    }
    if (fromPole > this.goldbergData.nbFacesAtPole - 1) {
      Logger.Warn("Maximum number of faces at a pole used");
      fromPole = this.goldbergData.nbFacesAtPole - 1;
    }
    return 12 + poleOrShared * this.goldbergData.nbFacesAtPole + fromPole;
  }
  _changeGoldbergFaceColors(colorRange) {
    for (let i = 0; i < colorRange.length; i++) {
      const min = colorRange[i][0];
      const max = colorRange[i][1];
      const col = colorRange[i][2];
      for (let f = min; f < max + 1; f++) {
        this.goldbergData.faceColors[f] = col;
      }
    }
    const newCols = [];
    for (let f = 0; f < 12; f++) {
      for (let i = 0; i < 5; i++) {
        newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);
      }
    }
    for (let f = 12; f < this.goldbergData.faceColors.length; f++) {
      for (let i = 0; i < 6; i++) {
        newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);
      }
    }
    return newCols;
  }
  setGoldbergFaceColors(colorRange) {
    const newCols = this._changeGoldbergFaceColors(colorRange);
    this.setVerticesData(VertexBuffer.ColorKind, newCols);
  }
  updateGoldbergFaceColors(colorRange) {
    const newCols = this._changeGoldbergFaceColors(colorRange);
    this.updateVerticesData(VertexBuffer.ColorKind, newCols);
  }
  _changeGoldbergFaceUVs(uvRange) {
    const uvs = this.getVerticesData(VertexBuffer.UVKind);
    for (let i = 0; i < uvRange.length; i++) {
      const min = uvRange[i][0];
      const max = uvRange[i][1];
      const center = uvRange[i][2];
      const radius = uvRange[i][3];
      const angle = uvRange[i][4];
      const points5 = [];
      const points6 = [];
      let u;
      let v;
      for (let p = 0; p < 5; p++) {
        u = center.x + radius * Math.cos(angle + p * Math.PI / 2.5);
        v = center.y + radius * Math.sin(angle + p * Math.PI / 2.5);
        if (u < 0) {
          u = 0;
        }
        if (u > 1) {
          u = 1;
        }
        points5.push(u, v);
      }
      for (let p = 0; p < 6; p++) {
        u = center.x + radius * Math.cos(angle + p * Math.PI / 3);
        v = center.y + radius * Math.sin(angle + p * Math.PI / 3);
        if (u < 0) {
          u = 0;
        }
        if (u > 1) {
          u = 1;
        }
        points6.push(u, v);
      }
      for (let f = min; f < Math.min(12, max + 1); f++) {
        for (let p = 0; p < 5; p++) {
          uvs[10 * f + 2 * p] = points5[2 * p];
          uvs[10 * f + 2 * p + 1] = points5[2 * p + 1];
        }
      }
      for (let f = Math.max(12, min); f < max + 1; f++) {
        for (let p = 0; p < 6; p++) {
          uvs[12 * f - 24 + 2 * p] = points6[2 * p];
          uvs[12 * f - 23 + 2 * p] = points6[2 * p + 1];
        }
      }
    }
    return uvs;
  }
  setGoldbergFaceUVs(uvRange) {
    const newUVs = this._changeGoldbergFaceUVs(uvRange);
    this.setVerticesData(VertexBuffer.UVKind, newUVs);
  }
  updateGoldbergFaceUVs(uvRange) {
    const newUVs = this._changeGoldbergFaceUVs(uvRange);
    this.updateVerticesData(VertexBuffer.UVKind, newUVs);
  }
  placeOnGoldbergFaceAt(mesh, face, position) {
    const orientation = Vector3.RotationFromAxis(this.goldbergData.faceXaxis[face], this.goldbergData.faceYaxis[face], this.goldbergData.faceZaxis[face]);
    mesh.rotation = orientation;
    mesh.position = this.goldbergData.faceCenters[face].add(this.goldbergData.faceXaxis[face].scale(position.x)).add(this.goldbergData.faceYaxis[face].scale(position.y)).add(this.goldbergData.faceZaxis[face].scale(position.z));
  }
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.type = "GoldbergMesh";
    const goldbergData = {};
    goldbergData.adjacentFaces = this.goldbergData.adjacentFaces;
    goldbergData.nbSharedFaces = this.goldbergData.nbSharedFaces;
    goldbergData.nbUnsharedFaces = this.goldbergData.nbUnsharedFaces;
    goldbergData.nbFaces = this.goldbergData.nbFaces;
    goldbergData.nbFacesAtPole = this.goldbergData.nbFacesAtPole;
    if (this.goldbergData.faceColors) {
      goldbergData.faceColors = [];
      for (const color of this.goldbergData.faceColors) {
        goldbergData.faceColors.push(color.asArray());
      }
    }
    if (this.goldbergData.faceCenters) {
      goldbergData.faceCenters = [];
      for (const vector of this.goldbergData.faceCenters) {
        goldbergData.faceCenters.push(vector.asArray());
      }
    }
    if (this.goldbergData.faceZaxis) {
      goldbergData.faceZaxis = [];
      for (const vector of this.goldbergData.faceZaxis) {
        goldbergData.faceZaxis.push(vector.asArray());
      }
    }
    if (this.goldbergData.faceYaxis) {
      goldbergData.faceYaxis = [];
      for (const vector of this.goldbergData.faceYaxis) {
        goldbergData.faceYaxis.push(vector.asArray());
      }
    }
    if (this.goldbergData.faceXaxis) {
      goldbergData.faceXaxis = [];
      for (const vector of this.goldbergData.faceXaxis) {
        goldbergData.faceXaxis.push(vector.asArray());
      }
    }
    serializationObject.goldbergData = goldbergData;
  }
  static Parse(parsedMesh, scene) {
    const goldbergData = parsedMesh.goldbergData;
    goldbergData.faceColors = goldbergData.faceColors.map((el) => Color4.FromArray(el));
    goldbergData.faceCenters = goldbergData.faceCenters.map((el) => Vector3.FromArray(el));
    goldbergData.faceZaxis = goldbergData.faceZaxis.map((el) => Vector3.FromArray(el));
    goldbergData.faceXaxis = goldbergData.faceXaxis.map((el) => Vector3.FromArray(el));
    goldbergData.faceYaxis = goldbergData.faceYaxis.map((el) => Vector3.FromArray(el));
    const goldberg = new GoldbergMesh(parsedMesh.name, scene);
    goldberg.goldbergData = goldbergData;
    return goldberg;
  }
};

// node_modules/@babylonjs/core/Meshes/trailMesh.js
var TrailMesh = class extends Mesh {
  constructor(name137, generator, scene, diameter = 1, length = 60, autoStart = true) {
    super(name137, scene);
    this._sectionPolygonPointsCount = 4;
    this._running = false;
    this._autoStart = autoStart;
    this._generator = generator;
    this._diameter = diameter;
    this._length = length;
    this._sectionVectors = [];
    this._sectionNormalVectors = [];
    for (let i = 0; i < this._sectionPolygonPointsCount; i++) {
      this._sectionVectors[i] = Vector3.Zero();
      this._sectionNormalVectors[i] = Vector3.Zero();
    }
    this._createMesh();
  }
  getClassName() {
    return "TrailMesh";
  }
  _createMesh() {
    const data = new VertexData();
    const positions = [];
    const normals = [];
    const indices = [];
    let meshCenter = Vector3.Zero();
    if (this._generator instanceof AbstractMesh && this._generator.hasBoundingInfo) {
      meshCenter = this._generator.getBoundingInfo().boundingBox.centerWorld;
    } else {
      meshCenter = this._generator.position;
    }
    const alpha = 2 * Math.PI / this._sectionPolygonPointsCount;
    for (let i = 0; i < this._sectionPolygonPointsCount; i++) {
      positions.push(meshCenter.x + Math.cos(i * alpha) * this._diameter, meshCenter.y + Math.sin(i * alpha) * this._diameter, meshCenter.z);
    }
    for (let i = 1; i <= this._length; i++) {
      for (let j = 0; j < this._sectionPolygonPointsCount; j++) {
        positions.push(meshCenter.x + Math.cos(j * alpha) * this._diameter, meshCenter.y + Math.sin(j * alpha) * this._diameter, meshCenter.z);
      }
      const l = positions.length / 3 - 2 * this._sectionPolygonPointsCount;
      for (let j = 0; j < this._sectionPolygonPointsCount - 1; j++) {
        indices.push(l + j, l + j + this._sectionPolygonPointsCount, l + j + this._sectionPolygonPointsCount + 1);
        indices.push(l + j, l + j + this._sectionPolygonPointsCount + 1, l + j + 1);
      }
      indices.push(l + this._sectionPolygonPointsCount - 1, l + this._sectionPolygonPointsCount - 1 + this._sectionPolygonPointsCount, l + this._sectionPolygonPointsCount);
      indices.push(l + this._sectionPolygonPointsCount - 1, l + this._sectionPolygonPointsCount, l);
    }
    VertexData.ComputeNormals(positions, indices, normals);
    data.positions = positions;
    data.normals = normals;
    data.indices = indices;
    data.applyToMesh(this, true);
    if (this._autoStart) {
      this.start();
    }
  }
  start() {
    if (!this._running) {
      this._running = true;
      this._beforeRenderObserver = this.getScene().onBeforeRenderObservable.add(() => {
        this.update();
      });
    }
  }
  stop() {
    if (this._beforeRenderObserver && this._running) {
      this._running = false;
      this.getScene().onBeforeRenderObservable.remove(this._beforeRenderObserver);
    }
  }
  update() {
    const positions = this.getVerticesData(VertexBuffer.PositionKind);
    const normals = this.getVerticesData(VertexBuffer.NormalKind);
    const wm = this._generator.getWorldMatrix();
    if (positions && normals) {
      for (let i = 3 * this._sectionPolygonPointsCount; i < positions.length; i++) {
        positions[i - 3 * this._sectionPolygonPointsCount] = positions[i] - normals[i] / this._length * this._diameter;
      }
      for (let i = 3 * this._sectionPolygonPointsCount; i < normals.length; i++) {
        normals[i - 3 * this._sectionPolygonPointsCount] = normals[i];
      }
      const l = positions.length - 3 * this._sectionPolygonPointsCount;
      const alpha = 2 * Math.PI / this._sectionPolygonPointsCount;
      for (let i = 0; i < this._sectionPolygonPointsCount; i++) {
        this._sectionVectors[i].copyFromFloats(Math.cos(i * alpha) * this._diameter, Math.sin(i * alpha) * this._diameter, 0);
        this._sectionNormalVectors[i].copyFromFloats(Math.cos(i * alpha), Math.sin(i * alpha), 0);
        Vector3.TransformCoordinatesToRef(this._sectionVectors[i], wm, this._sectionVectors[i]);
        Vector3.TransformNormalToRef(this._sectionNormalVectors[i], wm, this._sectionNormalVectors[i]);
      }
      for (let i = 0; i < this._sectionPolygonPointsCount; i++) {
        positions[l + 3 * i] = this._sectionVectors[i].x;
        positions[l + 3 * i + 1] = this._sectionVectors[i].y;
        positions[l + 3 * i + 2] = this._sectionVectors[i].z;
        normals[l + 3 * i] = this._sectionNormalVectors[i].x;
        normals[l + 3 * i + 1] = this._sectionNormalVectors[i].y;
        normals[l + 3 * i + 2] = this._sectionNormalVectors[i].z;
      }
      this.updateVerticesData(VertexBuffer.PositionKind, positions, true, false);
      this.updateVerticesData(VertexBuffer.NormalKind, normals, true, false);
    }
  }
  clone(name137 = "", newGenerator) {
    return new TrailMesh(name137, newGenerator === void 0 ? this._generator : newGenerator, this.getScene(), this._diameter, this._length, this._autoStart);
  }
  serialize(serializationObject) {
    super.serialize(serializationObject);
  }
  static Parse(parsedMesh, scene) {
    return new TrailMesh(parsedMesh.name, parsedMesh._generator, scene, parsedMesh._diameter, parsedMesh._length, parsedMesh._autoStart);
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/tiledPlaneBuilder.js
function CreateTiledPlaneVertexData(options) {
  const flipTile = options.pattern || Mesh.NO_FLIP;
  const tileWidth = options.tileWidth || options.tileSize || 1;
  const tileHeight = options.tileHeight || options.tileSize || 1;
  const alignH = options.alignHorizontal || 0;
  const alignV = options.alignVertical || 0;
  const width = options.width || options.size || 1;
  const tilesX = Math.floor(width / tileWidth);
  let offsetX = width - tilesX * tileWidth;
  const height = options.height || options.size || 1;
  const tilesY = Math.floor(height / tileHeight);
  let offsetY = height - tilesY * tileHeight;
  const halfWidth = tileWidth * tilesX / 2;
  const halfHeight = tileHeight * tilesY / 2;
  let adjustX = 0;
  let adjustY = 0;
  let startX = 0;
  let startY = 0;
  let endX = 0;
  let endY = 0;
  if (offsetX > 0 || offsetY > 0) {
    startX = -halfWidth;
    startY = -halfHeight;
    endX = halfWidth;
    endY = halfHeight;
    switch (alignH) {
      case Mesh.CENTER:
        offsetX /= 2;
        startX -= offsetX;
        endX += offsetX;
        break;
      case Mesh.LEFT:
        endX += offsetX;
        adjustX = -offsetX / 2;
        break;
      case Mesh.RIGHT:
        startX -= offsetX;
        adjustX = offsetX / 2;
        break;
    }
    switch (alignV) {
      case Mesh.CENTER:
        offsetY /= 2;
        startY -= offsetY;
        endY += offsetY;
        break;
      case Mesh.BOTTOM:
        endY += offsetY;
        adjustY = -offsetY / 2;
        break;
      case Mesh.TOP:
        startY -= offsetY;
        adjustY = offsetY / 2;
        break;
    }
  }
  const positions = [];
  const normals = [];
  const uvBase = [];
  uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];
  uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];
  if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
    uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];
  }
  if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
    uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];
  }
  if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
    uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];
  }
  let uvs = [];
  const colors = [];
  const indices = [];
  let index = 0;
  for (let y = 0; y < tilesY; y++) {
    for (let x = 0; x < tilesX; x++) {
      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
        uvs = uvs.concat(uvBase[(x % 2 + y % 2) % 2]);
      } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvs = uvs.concat(uvBase[y % 2]);
      } else {
        uvs = uvs.concat(uvBase[0]);
      }
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      index += 4;
    }
  }
  if (offsetX > 0 || offsetY > 0) {
    const partialBottomRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP);
    const partialTopRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM);
    const partialLeftCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT);
    const partialRightCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT);
    let uvPart = [];
    let a, b, c, d;
    if (partialBottomRow && partialLeftCol) {
      positions.push(startX + adjustX, startY + adjustY, 0);
      positions.push(-halfWidth + adjustX, startY + adjustY, 0);
      positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);
      positions.push(startX + adjustX, startY + offsetY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 1 - offsetX / tileWidth;
      b = 1 - offsetY / tileHeight;
      c = 1;
      d = 1;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialBottomRow && partialRightCol) {
      positions.push(halfWidth + adjustX, startY + adjustY, 0);
      positions.push(endX + adjustX, startY + adjustY, 0);
      positions.push(endX + adjustX, startY + offsetY + adjustY, 0);
      positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 0;
      b = 1 - offsetY / tileHeight;
      c = offsetX / tileWidth;
      d = 1;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.ROTATE_TILE && tilesX % 2 === 0) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.FLIP_TILE && tilesX % 2 === 0) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesX % 2 === 0) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialTopRow && partialLeftCol) {
      positions.push(startX + adjustX, halfHeight + adjustY, 0);
      positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);
      positions.push(-halfWidth + adjustX, endY + adjustY, 0);
      positions.push(startX + adjustX, endY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 1 - offsetX / tileWidth;
      b = 0;
      c = 1;
      d = offsetY / tileHeight;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && tilesY % 1 === 0) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && tilesY % 2 === 0) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesY % 2 === 0) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialTopRow && partialRightCol) {
      positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);
      positions.push(endX + adjustX, halfHeight + adjustY, 0);
      positions.push(endX + adjustX, endY + adjustY, 0);
      positions.push(halfWidth + adjustX, endY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 0;
      b = 0;
      c = offsetX / tileWidth;
      d = offsetY / tileHeight;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialBottomRow) {
      const uvBaseBR = [];
      a = 0;
      b = 1 - offsetY / tileHeight;
      c = 1;
      d = 1;
      uvBaseBR[0] = [a, b, c, b, c, d, a, d];
      uvBaseBR[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (let x = 0; x < tilesX; x++) {
        positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);
        positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseBR[1]);
        } else {
          uvs = uvs.concat(uvBaseBR[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
    if (partialTopRow) {
      const uvBaseTR = [];
      a = 0;
      b = 0;
      c = 1;
      d = offsetY / tileHeight;
      uvBaseTR[0] = [a, b, c, b, c, d, a, d];
      uvBaseTR[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (let x = 0; x < tilesX; x++) {
        positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);
        positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseTR[tilesY % 2]);
        } else {
          uvs = uvs.concat(uvBaseTR[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
    if (partialLeftCol) {
      const uvBaseLC = [];
      a = 1 - offsetX / tileWidth;
      b = 0;
      c = 1;
      d = 1;
      uvBaseLC[0] = [a, b, c, b, c, d, a, d];
      uvBaseLC[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (let y = 0; y < tilesY; y++) {
        positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseLC[y % 2]);
        } else {
          uvs = uvs.concat(uvBaseLC[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
    if (partialRightCol) {
      const uvBaseRC = [];
      a = 0;
      b = 0;
      c = offsetX / tileHeight;
      d = 1;
      uvBaseRC[0] = [a, b, c, b, c, d, a, d];
      uvBaseRC[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (let y = 0; y < tilesY; y++) {
        positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseRC[y % 2]);
        } else {
          uvs = uvs.concat(uvBaseRC[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
  }
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
  vertexData.colors = totalColors;
  return vertexData;
}
function CreateTiledPlane(name137, options, scene = null) {
  const plane = new Mesh(name137, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  plane._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateTiledPlaneVertexData(options);
  vertexData.applyToMesh(plane, options.updatable);
  return plane;
}
var TiledPlaneBuilder = {
  CreateTiledPlane
};
VertexData.CreateTiledPlane = CreateTiledPlaneVertexData;

// node_modules/@babylonjs/core/Meshes/Builders/tiledBoxBuilder.js
function CreateTiledBoxVertexData(options) {
  const nbFaces = 6;
  const faceUV = options.faceUV || new Array(6);
  const faceColors = options.faceColors;
  const flipTile = options.pattern || Mesh.NO_FLIP;
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const depth = options.depth || options.size || 1;
  const tileWidth = options.tileWidth || options.tileSize || 1;
  const tileHeight = options.tileHeight || options.tileSize || 1;
  const alignH = options.alignHorizontal || 0;
  const alignV = options.alignVertical || 0;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  for (let f = 0; f < nbFaces; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  const halfWidth = width / 2;
  const halfHeight = height / 2;
  const halfDepth = depth / 2;
  const faceVertexData = [];
  for (let f = 0; f < 2; f++) {
    faceVertexData[f] = CreateTiledPlaneVertexData({
      pattern: flipTile,
      tileWidth,
      tileHeight,
      width,
      height,
      alignVertical: alignV,
      alignHorizontal: alignH,
      sideOrientation
    });
  }
  for (let f = 2; f < 4; f++) {
    faceVertexData[f] = CreateTiledPlaneVertexData({
      pattern: flipTile,
      tileWidth,
      tileHeight,
      width: depth,
      height,
      alignVertical: alignV,
      alignHorizontal: alignH,
      sideOrientation
    });
  }
  let baseAlignV = alignV;
  if (alignV === Mesh.BOTTOM) {
    baseAlignV = Mesh.TOP;
  } else if (alignV === Mesh.TOP) {
    baseAlignV = Mesh.BOTTOM;
  }
  for (let f = 4; f < 6; f++) {
    faceVertexData[f] = CreateTiledPlaneVertexData({
      pattern: flipTile,
      tileWidth,
      tileHeight,
      width,
      height: depth,
      alignVertical: baseAlignV,
      alignHorizontal: alignH,
      sideOrientation
    });
  }
  let positions = [];
  let normals = [];
  let uvs = [];
  let indices = [];
  const colors = [];
  const facePositions = [];
  const faceNormals = [];
  const newFaceUV = [];
  let lu = 0;
  let li = 0;
  for (let f = 0; f < nbFaces; f++) {
    const len = faceVertexData[f].positions.length;
    facePositions[f] = [];
    faceNormals[f] = [];
    for (let p = 0; p < len / 3; p++) {
      facePositions[f].push(new Vector3(faceVertexData[f].positions[3 * p], faceVertexData[f].positions[3 * p + 1], faceVertexData[f].positions[3 * p + 2]));
      faceNormals[f].push(new Vector3(faceVertexData[f].normals[3 * p], faceVertexData[f].normals[3 * p + 1], faceVertexData[f].normals[3 * p + 2]));
    }
    lu = faceVertexData[f].uvs.length;
    newFaceUV[f] = [];
    for (let i = 0; i < lu; i += 2) {
      newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs[i];
      newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs[i + 1];
      if (CompatibilityOptions.UseOpenGLOrientationForUV) {
        newFaceUV[f][i + 1] = 1 - newFaceUV[f][i + 1];
      }
    }
    uvs = uvs.concat(newFaceUV[f]);
    indices = indices.concat(faceVertexData[f].indices.map((x) => x + li));
    li += facePositions[f].length;
    if (faceColors) {
      for (let c = 0; c < 4; c++) {
        colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);
      }
    }
  }
  const vec0 = new Vector3(0, 0, halfDepth);
  const mtrx0 = Matrix.RotationY(Math.PI);
  positions = facePositions[0].map((entry) => Vector3.TransformNormal(entry, mtrx0).add(vec0)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
  normals = faceNormals[0].map((entry) => Vector3.TransformNormal(entry, mtrx0)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
  positions = positions.concat(facePositions[1].map((entry) => entry.subtract(vec0)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  normals = normals.concat(faceNormals[1].map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  const vec2 = new Vector3(halfWidth, 0, 0);
  const mtrx2 = Matrix.RotationY(-Math.PI / 2);
  positions = positions.concat(facePositions[2].map((entry) => Vector3.TransformNormal(entry, mtrx2).add(vec2)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  normals = normals.concat(faceNormals[2].map((entry) => Vector3.TransformNormal(entry, mtrx2)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  const mtrx3 = Matrix.RotationY(Math.PI / 2);
  positions = positions.concat(facePositions[3].map((entry) => Vector3.TransformNormal(entry, mtrx3).subtract(vec2)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  normals = normals.concat(faceNormals[3].map((entry) => Vector3.TransformNormal(entry, mtrx3)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  const vec4 = new Vector3(0, halfHeight, 0);
  const mtrx4 = Matrix.RotationX(Math.PI / 2);
  positions = positions.concat(facePositions[4].map((entry) => Vector3.TransformNormal(entry, mtrx4).add(vec4)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  normals = normals.concat(faceNormals[4].map((entry) => Vector3.TransformNormal(entry, mtrx4)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  const mtrx5 = Matrix.RotationX(-Math.PI / 2);
  positions = positions.concat(facePositions[5].map((entry) => Vector3.TransformNormal(entry, mtrx5).subtract(vec4)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  normals = normals.concat(faceNormals[5].map((entry) => Vector3.TransformNormal(entry, mtrx5)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
}
function CreateTiledBox(name137, options, scene = null) {
  const box = new Mesh(name137, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  box._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateTiledBoxVertexData(options);
  vertexData.applyToMesh(box, options.updatable);
  return box;
}
var TiledBoxBuilder = {
  CreateTiledBox
};
VertexData.CreateTiledBox = CreateTiledBoxVertexData;

// node_modules/@babylonjs/core/Meshes/Builders/torusKnotBuilder.js
function CreateTorusKnotVertexData(options) {
  const indices = new Array();
  const positions = new Array();
  const normals = new Array();
  const uvs = new Array();
  const radius = options.radius || 2;
  const tube = options.tube || 0.5;
  const radialSegments = options.radialSegments || 32;
  const tubularSegments = options.tubularSegments || 32;
  const p = options.p || 2;
  const q = options.q || 3;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const getPos = (angle) => {
    const cu = Math.cos(angle);
    const su = Math.sin(angle);
    const quOverP = q / p * angle;
    const cs = Math.cos(quOverP);
    const tx = radius * (2 + cs) * 0.5 * cu;
    const ty = radius * (2 + cs) * su * 0.5;
    const tz = radius * Math.sin(quOverP) * 0.5;
    return new Vector3(tx, ty, tz);
  };
  let i;
  let j;
  for (i = 0; i <= radialSegments; i++) {
    const modI = i % radialSegments;
    const u = modI / radialSegments * 2 * p * Math.PI;
    const p1 = getPos(u);
    const p2 = getPos(u + 0.01);
    const tang = p2.subtract(p1);
    let n = p2.add(p1);
    const bitan = Vector3.Cross(tang, n);
    n = Vector3.Cross(bitan, tang);
    bitan.normalize();
    n.normalize();
    for (j = 0; j < tubularSegments; j++) {
      const modJ = j % tubularSegments;
      const v = modJ / tubularSegments * 2 * Math.PI;
      const cx = -tube * Math.cos(v);
      const cy = tube * Math.sin(v);
      positions.push(p1.x + cx * n.x + cy * bitan.x);
      positions.push(p1.y + cx * n.y + cy * bitan.y);
      positions.push(p1.z + cx * n.z + cy * bitan.z);
      uvs.push(i / radialSegments);
      uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - j / tubularSegments : j / tubularSegments);
    }
  }
  for (i = 0; i < radialSegments; i++) {
    for (j = 0; j < tubularSegments; j++) {
      const jNext = (j + 1) % tubularSegments;
      const a = i * tubularSegments + j;
      const b = (i + 1) * tubularSegments + j;
      const c = (i + 1) * tubularSegments + jNext;
      const d = i * tubularSegments + jNext;
      indices.push(d);
      indices.push(b);
      indices.push(a);
      indices.push(d);
      indices.push(c);
      indices.push(b);
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateTorusKnot(name137, options = {}, scene) {
  const torusKnot = new Mesh(name137, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  torusKnot._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateTorusKnotVertexData(options);
  vertexData.applyToMesh(torusKnot, options.updatable);
  return torusKnot;
}
var TorusKnotBuilder = {
  CreateTorusKnot
};
VertexData.CreateTorusKnot = CreateTorusKnotVertexData;
Mesh.CreateTorusKnot = (name137, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) => {
  const options = {
    radius,
    tube,
    radialSegments,
    tubularSegments,
    p,
    q,
    sideOrientation,
    updatable
  };
  return CreateTorusKnot(name137, options, scene);
};

// node_modules/@babylonjs/core/Meshes/polygonMesh.js
var IndexedVector2 = class extends Vector2 {
  constructor(original, index) {
    super(original.x, original.y);
    this.index = index;
  }
};
var PolygonPoints = class {
  constructor() {
    this.elements = new Array();
  }
  add(originalPoints) {
    const result = new Array();
    originalPoints.forEach((point) => {
      const newPoint = new IndexedVector2(point, this.elements.length);
      result.push(newPoint);
      this.elements.push(newPoint);
    });
    return result;
  }
  computeBounds() {
    const lmin = new Vector2(this.elements[0].x, this.elements[0].y);
    const lmax = new Vector2(this.elements[0].x, this.elements[0].y);
    this.elements.forEach((point) => {
      if (point.x < lmin.x) {
        lmin.x = point.x;
      } else if (point.x > lmax.x) {
        lmax.x = point.x;
      }
      if (point.y < lmin.y) {
        lmin.y = point.y;
      } else if (point.y > lmax.y) {
        lmax.y = point.y;
      }
    });
    return {
      min: lmin,
      max: lmax,
      width: lmax.x - lmin.x,
      height: lmax.y - lmin.y
    };
  }
};
var Polygon2 = class {
  static Rectangle(xmin, ymin, xmax, ymax) {
    return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];
  }
  static Circle(radius, cx = 0, cy = 0, numberOfSides = 32) {
    const result = new Array();
    let angle = 0;
    const increment = Math.PI * 2 / numberOfSides;
    for (let i = 0; i < numberOfSides; i++) {
      result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));
      angle -= increment;
    }
    return result;
  }
  static Parse(input) {
    const floats = input.split(/[^-+eE.\d]+/).map(parseFloat).filter((val) => !isNaN(val));
    let i;
    const result = [];
    for (i = 0; i < (floats.length & 2147483646); i += 2) {
      result.push(new Vector2(floats[i], floats[i + 1]));
    }
    return result;
  }
  static StartingAt(x, y) {
    return Path2.StartingAt(x, y);
  }
};
var PolygonMeshBuilder = class {
  constructor(name137, contours, scene, earcutInjection = earcut) {
    this._points = new PolygonPoints();
    this._outlinepoints = new PolygonPoints();
    this._holes = new Array();
    this._epoints = new Array();
    this._eholes = new Array();
    this.bjsEarcut = earcutInjection;
    this._name = name137;
    this._scene = scene || EngineStore.LastCreatedScene;
    let points;
    if (contours instanceof Path2) {
      points = contours.getPoints();
    } else {
      points = contours;
    }
    this._addToepoint(points);
    this._points.add(points);
    this._outlinepoints.add(points);
    if (typeof this.bjsEarcut === "undefined") {
      Logger.Warn("Earcut was not found, the polygon will not be built.");
    }
  }
  _addToepoint(points) {
    for (const p of points) {
      this._epoints.push(p.x, p.y);
    }
  }
  addHole(hole) {
    this._points.add(hole);
    const holepoints = new PolygonPoints();
    holepoints.add(hole);
    this._holes.push(holepoints);
    this._eholes.push(this._epoints.length / 2);
    this._addToepoint(hole);
    return this;
  }
  build(updatable = false, depth = 0, smoothingThreshold = 2) {
    const result = new Mesh(this._name, this._scene);
    const vertexData = this.buildVertexData(depth, smoothingThreshold);
    result.setVerticesData(VertexBuffer.PositionKind, vertexData.positions, updatable);
    result.setVerticesData(VertexBuffer.NormalKind, vertexData.normals, updatable);
    result.setVerticesData(VertexBuffer.UVKind, vertexData.uvs, updatable);
    result.setIndices(vertexData.indices);
    return result;
  }
  buildVertexData(depth = 0, smoothingThreshold = 2) {
    const result = new VertexData();
    const normals = new Array();
    const positions = new Array();
    const uvs = new Array();
    const bounds = this._points.computeBounds();
    this._points.elements.forEach((p) => {
      normals.push(0, 1, 0);
      positions.push(p.x, 0, p.y);
      uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);
    });
    const indices = new Array();
    const res = this.bjsEarcut(this._epoints, this._eholes, 2);
    for (let i = 0; i < res.length; i++) {
      indices.push(res[i]);
    }
    if (depth > 0) {
      const positionscount = positions.length / 3;
      this._points.elements.forEach((p) => {
        normals.push(0, -1, 0);
        positions.push(p.x, -depth, p.y);
        uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);
      });
      const totalCount = indices.length;
      for (let i = 0; i < totalCount; i += 3) {
        const i0 = indices[i + 0];
        const i1 = indices[i + 1];
        const i2 = indices[i + 2];
        indices.push(i2 + positionscount);
        indices.push(i1 + positionscount);
        indices.push(i0 + positionscount);
      }
      this._addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false, smoothingThreshold);
      this._holes.forEach((hole) => {
        this._addSide(positions, normals, uvs, indices, bounds, hole, depth, true, smoothingThreshold);
      });
    }
    result.indices = indices;
    result.positions = positions;
    result.normals = normals;
    result.uvs = uvs;
    return result;
  }
  _addSide(positions, normals, uvs, indices, bounds, points, depth, flip, smoothingThreshold) {
    let startIndex = positions.length / 3;
    let ulength = 0;
    for (let i = 0; i < points.elements.length; i++) {
      const p = points.elements[i];
      const p1 = points.elements[(i + 1) % points.elements.length];
      positions.push(p.x, 0, p.y);
      positions.push(p.x, -depth, p.y);
      positions.push(p1.x, 0, p1.y);
      positions.push(p1.x, -depth, p1.y);
      const p0 = points.elements[(i + points.elements.length - 1) % points.elements.length];
      const p2 = points.elements[(i + 2) % points.elements.length];
      let vc = new Vector3(-(p1.y - p.y), 0, p1.x - p.x);
      let vp = new Vector3(-(p.y - p0.y), 0, p.x - p0.x);
      let vn = new Vector3(-(p2.y - p1.y), 0, p2.x - p1.x);
      if (!flip) {
        vc = vc.scale(-1);
        vp = vp.scale(-1);
        vn = vn.scale(-1);
      }
      const vc_norm = vc.normalizeToNew();
      let vp_norm = vp.normalizeToNew();
      let vn_norm = vn.normalizeToNew();
      const dotp = Vector3.Dot(vp_norm, vc_norm);
      if (dotp > smoothingThreshold) {
        if (dotp < Epsilon - 1) {
          vp_norm = new Vector3(p.x, 0, p.y).subtract(new Vector3(p1.x, 0, p1.y)).normalize();
        } else {
          vp_norm = vp.add(vc).normalize();
        }
      } else {
        vp_norm = vc_norm;
      }
      const dotn = Vector3.Dot(vn, vc);
      if (dotn > smoothingThreshold) {
        if (dotn < Epsilon - 1) {
          vn_norm = new Vector3(p1.x, 0, p1.y).subtract(new Vector3(p.x, 0, p.y)).normalize();
        } else {
          vn_norm = vn.add(vc).normalize();
        }
      } else {
        vn_norm = vc_norm;
      }
      uvs.push(ulength / bounds.width, 0);
      uvs.push(ulength / bounds.width, 1);
      ulength += vc.length();
      uvs.push(ulength / bounds.width, 0);
      uvs.push(ulength / bounds.width, 1);
      normals.push(vp_norm.x, vp_norm.y, vp_norm.z);
      normals.push(vp_norm.x, vp_norm.y, vp_norm.z);
      normals.push(vn_norm.x, vn_norm.y, vn_norm.z);
      normals.push(vn_norm.x, vn_norm.y, vn_norm.z);
      if (!flip) {
        indices.push(startIndex);
        indices.push(startIndex + 1);
        indices.push(startIndex + 2);
        indices.push(startIndex + 1);
        indices.push(startIndex + 3);
        indices.push(startIndex + 2);
      } else {
        indices.push(startIndex);
        indices.push(startIndex + 2);
        indices.push(startIndex + 1);
        indices.push(startIndex + 1);
        indices.push(startIndex + 2);
        indices.push(startIndex + 3);
      }
      startIndex += 4;
    }
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/polygonBuilder.js
function CreatePolygonVertexData(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrp) {
  const faceUV = fUV || new Array(3);
  const faceColors = fColors;
  const colors = [];
  const wrap = wrp || false;
  for (let f = 0; f < 3; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  const positions = polygon.getVerticesData(VertexBuffer.PositionKind);
  const normals = polygon.getVerticesData(VertexBuffer.NormalKind);
  const uvs = polygon.getVerticesData(VertexBuffer.UVKind);
  const indices = polygon.getIndices();
  const startIndex = positions.length / 9;
  let disp = 0;
  let distX = 0;
  let distZ = 0;
  let dist = 0;
  let totalLen = 0;
  const cumulate = [0];
  if (wrap) {
    for (let idx2 = startIndex; idx2 < positions.length / 3; idx2 += 4) {
      distX = positions[3 * (idx2 + 2)] - positions[3 * idx2];
      distZ = positions[3 * (idx2 + 2) + 2] - positions[3 * idx2 + 2];
      dist = Math.sqrt(distX * distX + distZ * distZ);
      totalLen += dist;
      cumulate.push(totalLen);
    }
  }
  let idx = 0;
  let face = 0;
  for (let index = 0; index < normals.length; index += 3) {
    if (Math.abs(normals[index + 1]) < 1e-3) {
      face = 1;
    }
    if (Math.abs(normals[index + 1] - 1) < 1e-3) {
      face = 0;
    }
    if (Math.abs(normals[index + 1] + 1) < 1e-3) {
      face = 2;
    }
    idx = index / 3;
    if (face === 1) {
      disp = idx - startIndex;
      if (disp % 4 < 1.5) {
        if (wrap) {
          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)] / totalLen;
        } else {
          uvs[2 * idx] = faceUV[face].x;
        }
      } else {
        if (wrap) {
          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1] / totalLen;
        } else {
          uvs[2 * idx] = faceUV[face].z;
        }
      }
      if (disp % 2 === 0) {
        uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[face].w : faceUV[face].w;
      } else {
        uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[face].y : faceUV[face].y;
      }
    } else {
      uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;
      uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;
      if (CompatibilityOptions.UseOpenGLOrientationForUV) {
        uvs[2 * idx + 1] = 1 - uvs[2 * idx + 1];
      }
    }
    if (faceColors) {
      colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
}
function CreatePolygon(name137, options, scene = null, earcutInjection = earcut) {
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const shape = options.shape;
  const holes = options.holes || [];
  const depth = options.depth || 0;
  const smoothingThreshold = options.smoothingThreshold || 2;
  const contours = [];
  let hole = [];
  for (let i = 0; i < shape.length; i++) {
    contours[i] = new Vector2(shape[i].x, shape[i].z);
  }
  const epsilon = 1e-8;
  if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {
    contours.pop();
  }
  const polygonTriangulation = new PolygonMeshBuilder(name137, contours, scene || EngineStore.LastCreatedScene, earcutInjection);
  for (let hNb = 0; hNb < holes.length; hNb++) {
    hole = [];
    for (let hPoint = 0; hPoint < holes[hNb].length; hPoint++) {
      hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));
    }
    polygonTriangulation.addHole(hole);
  }
  const polygon = polygonTriangulation.build(false, depth, smoothingThreshold);
  polygon._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreatePolygonVertexData(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);
  vertexData.applyToMesh(polygon, options.updatable);
  return polygon;
}
function ExtrudePolygon(name137, options, scene = null, earcutInjection = earcut) {
  return CreatePolygon(name137, options, scene, earcutInjection);
}
var PolygonBuilder = {
  ExtrudePolygon,
  CreatePolygon
};
VertexData.CreatePolygon = CreatePolygonVertexData;
Mesh.CreatePolygon = (name137, shape, scene, holes, updatable, sideOrientation, earcutInjection = earcut) => {
  const options = {
    shape,
    holes,
    updatable,
    sideOrientation
  };
  return CreatePolygon(name137, options, scene, earcutInjection);
};
Mesh.ExtrudePolygon = (name137, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection = earcut) => {
  const options = {
    shape,
    holes,
    depth,
    updatable,
    sideOrientation
  };
  return ExtrudePolygon(name137, options, scene, earcutInjection);
};

// node_modules/@babylonjs/core/Meshes/Builders/latheBuilder.js
function CreateLathe(name137, options, scene = null) {
  const arc = options.arc ? options.arc <= 0 || options.arc > 1 ? 1 : options.arc : 1;
  const closed = options.closed === void 0 ? true : options.closed;
  const shape = options.shape;
  const radius = options.radius || 1;
  const tessellation = options.tessellation || 64;
  const clip = options.clip || 0;
  const updatable = options.updatable;
  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const cap = options.cap || Mesh.NO_CAP;
  const pi2 = Math.PI * 2;
  const paths = new Array();
  const invertUV = options.invertUV || false;
  let i = 0;
  let p = 0;
  const step = pi2 / tessellation * arc;
  let rotated;
  let path;
  for (i = 0; i <= tessellation - clip; i++) {
    path = [];
    if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {
      path.push(new Vector3(0, shape[0].y, 0));
      path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));
    }
    for (p = 0; p < shape.length; p++) {
      rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);
      path.push(rotated);
    }
    if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {
      path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));
      path.push(new Vector3(0, shape[shape.length - 1].y, 0));
    }
    paths.push(path);
  }
  const lathe = CreateRibbon(name137, { pathArray: paths, closeArray: closed, sideOrientation, updatable, invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);
  return lathe;
}
var LatheBuilder = {
  CreateLathe
};
Mesh.CreateLathe = (name137, shape, radius, tessellation, scene, updatable, sideOrientation) => {
  const options = {
    shape,
    radius,
    tessellation,
    sideOrientation,
    updatable
  };
  return CreateLathe(name137, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/tubeBuilder.js
function CreateTube(name137, options, scene = null) {
  const path = options.path;
  let instance = options.instance;
  let radius = 1;
  if (options.radius !== void 0) {
    radius = options.radius;
  } else if (instance) {
    radius = instance._creationDataStorage.radius;
  }
  const tessellation = options.tessellation || 64 | 0;
  const radiusFunction = options.radiusFunction || null;
  let cap = options.cap || Mesh.NO_CAP;
  const invertUV = options.invertUV || false;
  const updatable = options.updatable;
  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  options.arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  const tubePathArray = (path2, path3D2, circlePaths, radius2, tessellation2, radiusFunction2, cap2, arc) => {
    const tangents = path3D2.getTangents();
    const normals = path3D2.getNormals();
    const distances = path3D2.getDistances();
    const pi2 = Math.PI * 2;
    const step = pi2 / tessellation2 * arc;
    const returnRadius = () => radius2;
    const radiusFunctionFinal = radiusFunction2 || returnRadius;
    let circlePath;
    let rad;
    let normal;
    let rotated;
    const rotationMatrix = TmpVectors.Matrix[0];
    let index = cap2 === Mesh.NO_CAP || cap2 === Mesh.CAP_END ? 0 : 2;
    for (let i = 0; i < path2.length; i++) {
      rad = radiusFunctionFinal(i, distances[i]);
      circlePath = Array();
      normal = normals[i];
      for (let t = 0; t < tessellation2; t++) {
        Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);
        rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();
        Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);
        rotated.scaleInPlace(rad).addInPlace(path2[i]);
        circlePath[t] = rotated;
      }
      circlePaths[index] = circlePath;
      index++;
    }
    const capPath = (nbPoints, pathIndex) => {
      const pointCap = Array();
      for (let i = 0; i < nbPoints; i++) {
        pointCap.push(path2[pathIndex]);
      }
      return pointCap;
    };
    switch (cap2) {
      case Mesh.NO_CAP:
        break;
      case Mesh.CAP_START:
        circlePaths[0] = capPath(tessellation2, 0);
        circlePaths[1] = circlePaths[2].slice(0);
        break;
      case Mesh.CAP_END:
        circlePaths[index] = circlePaths[index - 1].slice(0);
        circlePaths[index + 1] = capPath(tessellation2, path2.length - 1);
        break;
      case Mesh.CAP_ALL:
        circlePaths[0] = capPath(tessellation2, 0);
        circlePaths[1] = circlePaths[2].slice(0);
        circlePaths[index] = circlePaths[index - 1].slice(0);
        circlePaths[index + 1] = capPath(tessellation2, path2.length - 1);
        break;
      default:
        break;
    }
    return circlePaths;
  };
  let path3D;
  let pathArray;
  if (instance) {
    const storage = instance._creationDataStorage;
    const arc = options.arc || storage.arc;
    path3D = storage.path3D.update(path);
    pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);
    instance = CreateRibbon("", { pathArray, instance });
    storage.path3D = path3D;
    storage.pathArray = pathArray;
    storage.arc = arc;
    storage.radius = radius;
    return instance;
  }
  path3D = new Path3D(path);
  const newPathArray = new Array();
  cap = cap < 0 || cap > 3 ? 0 : cap;
  pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);
  const tube = CreateRibbon(name137, {
    pathArray,
    closePath: true,
    closeArray: false,
    updatable,
    sideOrientation,
    invertUV,
    frontUVs: options.frontUVs,
    backUVs: options.backUVs
  }, scene);
  tube._creationDataStorage.pathArray = pathArray;
  tube._creationDataStorage.path3D = path3D;
  tube._creationDataStorage.tessellation = tessellation;
  tube._creationDataStorage.cap = cap;
  tube._creationDataStorage.arc = options.arc;
  tube._creationDataStorage.radius = radius;
  return tube;
}
var TubeBuilder = {
  CreateTube
};
Mesh.CreateTube = (name137, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) => {
  const options = {
    path,
    radius,
    tessellation,
    radiusFunction,
    arc: 1,
    cap,
    updatable,
    sideOrientation,
    instance
  };
  return CreateTube(name137, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/decalBuilder.js
var xpAxis = new Vector3(1, 0, 0);
var xnAxis = new Vector3(-1, 0, 0);
var ypAxis = new Vector3(0, 1, 0);
var ynAxis = new Vector3(0, -1, 0);
var zpAxis = new Vector3(0, 0, 1);
var znAxis = new Vector3(0, 0, -1);
var DecalVertex = class {
  constructor(position = Vector3.Zero(), normal = Vector3.Up(), uv = Vector2.Zero(), vertexIdx = 0, vertexIdxForBones = 0, localPositionOverride = null, localNormalOverride = null, matrixIndicesOverride = null, matrixWeightsOverride = null) {
    this.position = position;
    this.normal = normal;
    this.uv = uv;
    this.vertexIdx = vertexIdx;
    this.vertexIdxForBones = vertexIdxForBones;
    this.localPositionOverride = localPositionOverride;
    this.localNormalOverride = localNormalOverride;
    this.matrixIndicesOverride = matrixIndicesOverride;
    this.matrixWeightsOverride = matrixWeightsOverride;
  }
  clone() {
    var _a, _b, _c, _d;
    return new DecalVertex(this.position.clone(), this.normal.clone(), this.uv.clone(), this.vertexIdx, this.vertexIdxForBones, (_a = this.localPositionOverride) === null || _a === void 0 ? void 0 : _a.slice(), (_b = this.localNormalOverride) === null || _b === void 0 ? void 0 : _b.slice(), (_c = this.matrixIndicesOverride) === null || _c === void 0 ? void 0 : _c.slice(), (_d = this.matrixWeightsOverride) === null || _d === void 0 ? void 0 : _d.slice());
  }
};
function CreateDecal(name137, sourceMesh, options) {
  const hasSkeleton = !!sourceMesh.skeleton;
  const useLocalComputation = options.localMode || hasSkeleton;
  const meshHasOverridenMaterial = sourceMesh.overrideMaterialSideOrientation !== null && sourceMesh.overrideMaterialSideOrientation !== void 0;
  const indices = sourceMesh.getIndices();
  const positions = hasSkeleton ? sourceMesh.getPositionData(true, true) : sourceMesh.getVerticesData(VertexBuffer.PositionKind);
  const normals = hasSkeleton ? sourceMesh.getNormalsData(true, true) : sourceMesh.getVerticesData(VertexBuffer.NormalKind);
  const localPositions = useLocalComputation ? hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.PositionKind) : positions : null;
  const localNormals = useLocalComputation ? hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.NormalKind) : normals : null;
  const uvs = sourceMesh.getVerticesData(VertexBuffer.UVKind);
  const matIndices = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesKind) : null;
  const matWeights = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsKind) : null;
  const matIndicesExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
  const matWeightsExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
  const position = options.position || Vector3.Zero();
  let normal = options.normal || Vector3.Up();
  const size = options.size || Vector3.One();
  const angle = options.angle || 0;
  if (!normal) {
    const target = new Vector3(0, 0, 1);
    const camera = sourceMesh.getScene().activeCamera;
    const cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());
    normal = camera.globalPosition.subtract(cameraWorldTarget);
  }
  const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;
  const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);
  const pitch = Math.atan2(normal.y, len);
  const decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));
  const inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);
  const meshWorldMatrix = sourceMesh.getWorldMatrix();
  const transformMatrix = meshWorldMatrix.multiply(inverseDecalWorldMatrix);
  const vertexData = new VertexData();
  vertexData.indices = [];
  vertexData.positions = [];
  vertexData.normals = [];
  vertexData.uvs = [];
  vertexData.matricesIndices = hasSkeleton ? [] : null;
  vertexData.matricesWeights = hasSkeleton ? [] : null;
  vertexData.matricesIndicesExtra = matIndicesExtra ? [] : null;
  vertexData.matricesWeightsExtra = matWeightsExtra ? [] : null;
  let currentVertexDataIndex = 0;
  const extractDecalVector3 = (indexId) => {
    const result = new DecalVertex();
    if (!indices || !positions || !normals) {
      return result;
    }
    const vertexId = indices[indexId];
    result.vertexIdx = vertexId * 3;
    result.vertexIdxForBones = vertexId * 4;
    result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);
    Vector3.TransformCoordinatesToRef(result.position, transformMatrix, result.position);
    result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);
    Vector3.TransformNormalToRef(result.normal, transformMatrix, result.normal);
    if (options.captureUVS && uvs) {
      const v = uvs[vertexId * 2 + 1];
      result.uv = new Vector2(uvs[vertexId * 2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
    }
    return result;
  };
  const emptyArray = [0, 0, 0, 0];
  const clip = (vertices, axis) => {
    if (vertices.length === 0) {
      return vertices;
    }
    const clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));
    const indexOf = (arr, val, start, num) => {
      for (let i = 0; i < num; ++i) {
        if (arr[start + i] === val) {
          return start + i;
        }
      }
      return -1;
    };
    const clipVertices = (v0, v1) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
      const clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);
      let indices2 = emptyArray;
      let weights = emptyArray;
      if (matIndices && matWeights) {
        const mat0Index = v0.matrixIndicesOverride ? 0 : v0.vertexIdxForBones;
        const v0Indices = (_a = v0.matrixIndicesOverride) !== null && _a !== void 0 ? _a : matIndices;
        const v0Weights = (_b = v0.matrixWeightsOverride) !== null && _b !== void 0 ? _b : matWeights;
        const mat1Index = v1.matrixIndicesOverride ? 0 : v1.vertexIdxForBones;
        const v1Indices = (_c = v1.matrixIndicesOverride) !== null && _c !== void 0 ? _c : matIndices;
        const v1Weights = (_d = v1.matrixWeightsOverride) !== null && _d !== void 0 ? _d : matWeights;
        indices2 = [0, 0, 0, 0];
        weights = [0, 0, 0, 0];
        let index = 0;
        for (let i = 0; i < 4; ++i) {
          if (v0Weights[mat0Index + i] > 0) {
            const idx = indexOf(v1Indices, v0Indices[mat0Index + i], mat1Index, 4);
            indices2[index] = v0Indices[mat0Index + i];
            weights[index] = Scalar.Lerp(v0Weights[mat0Index + i], idx >= 0 ? v1Weights[idx] : 0, clipFactor);
            index++;
          }
        }
        for (let i = 0; i < 4 && index < 4; ++i) {
          const ind = v1Indices[mat1Index + i];
          if (indexOf(v0Indices, ind, mat0Index, 4) !== -1)
            continue;
          indices2[index] = ind;
          weights[index] = Scalar.Lerp(0, v1Weights[mat1Index + i], clipFactor);
          index++;
        }
        const sumw = weights[0] + weights[1] + weights[2] + weights[3];
        weights[0] /= sumw;
        weights[1] /= sumw;
        weights[2] /= sumw;
        weights[3] /= sumw;
      }
      const v0LocalPositionX = v0.localPositionOverride ? v0.localPositionOverride[0] : (_e = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v0.vertexIdx]) !== null && _e !== void 0 ? _e : 0;
      const v0LocalPositionY = v0.localPositionOverride ? v0.localPositionOverride[1] : (_f = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v0.vertexIdx + 1]) !== null && _f !== void 0 ? _f : 0;
      const v0LocalPositionZ = v0.localPositionOverride ? v0.localPositionOverride[2] : (_g = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v0.vertexIdx + 2]) !== null && _g !== void 0 ? _g : 0;
      const v1LocalPositionX = v1.localPositionOverride ? v1.localPositionOverride[0] : (_h = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v1.vertexIdx]) !== null && _h !== void 0 ? _h : 0;
      const v1LocalPositionY = v1.localPositionOverride ? v1.localPositionOverride[1] : (_j = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v1.vertexIdx + 1]) !== null && _j !== void 0 ? _j : 0;
      const v1LocalPositionZ = v1.localPositionOverride ? v1.localPositionOverride[2] : (_k = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v1.vertexIdx + 2]) !== null && _k !== void 0 ? _k : 0;
      const v0LocalNormalX = v0.localNormalOverride ? v0.localNormalOverride[0] : (_l = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v0.vertexIdx]) !== null && _l !== void 0 ? _l : 0;
      const v0LocalNormalY = v0.localNormalOverride ? v0.localNormalOverride[1] : (_m = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v0.vertexIdx + 1]) !== null && _m !== void 0 ? _m : 0;
      const v0LocalNormalZ = v0.localNormalOverride ? v0.localNormalOverride[2] : (_o = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v0.vertexIdx + 2]) !== null && _o !== void 0 ? _o : 0;
      const v1LocalNormalX = v1.localNormalOverride ? v1.localNormalOverride[0] : (_p = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v1.vertexIdx]) !== null && _p !== void 0 ? _p : 0;
      const v1LocalNormalY = v1.localNormalOverride ? v1.localNormalOverride[1] : (_q = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v1.vertexIdx + 1]) !== null && _q !== void 0 ? _q : 0;
      const v1LocalNormalZ = v1.localNormalOverride ? v1.localNormalOverride[2] : (_r = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v1.vertexIdx + 2]) !== null && _r !== void 0 ? _r : 0;
      const interpNormalX = v0LocalNormalX + (v1LocalNormalX - v0LocalNormalX) * clipFactor;
      const interpNormalY = v0LocalNormalY + (v1LocalNormalY - v0LocalNormalY) * clipFactor;
      const interpNormalZ = v0LocalNormalZ + (v1LocalNormalZ - v0LocalNormalZ) * clipFactor;
      const norm = Math.sqrt(interpNormalX * interpNormalX + interpNormalY * interpNormalY + interpNormalZ * interpNormalZ);
      return new DecalVertex(Vector3.Lerp(v0.position, v1.position, clipFactor), Vector3.Lerp(v0.normal, v1.normal, clipFactor).normalize(), Vector2.Lerp(v0.uv, v1.uv, clipFactor), -1, -1, localPositions ? [
        v0LocalPositionX + (v1LocalPositionX - v0LocalPositionX) * clipFactor,
        v0LocalPositionY + (v1LocalPositionY - v0LocalPositionY) * clipFactor,
        v0LocalPositionZ + (v1LocalPositionZ - v0LocalPositionZ) * clipFactor
      ] : null, localNormals ? [interpNormalX / norm, interpNormalY / norm, interpNormalZ / norm] : null, indices2, weights);
    };
    let clipResult = null;
    if (vertices.length > 3) {
      clipResult = new Array();
    }
    for (let index = 0; index < vertices.length; index += 3) {
      let total = 0;
      let nV1 = null;
      let nV2 = null;
      let nV3 = null;
      let nV4 = null;
      const d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;
      const d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;
      const d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;
      const v1Out = d1 > 0;
      const v2Out = d2 > 0;
      const v3Out = d3 > 0;
      total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);
      switch (total) {
        case 0:
          if (vertices.length > 3) {
            clipResult.push(vertices[index]);
            clipResult.push(vertices[index + 1]);
            clipResult.push(vertices[index + 2]);
          } else {
            clipResult = vertices;
          }
          break;
        case 1:
          clipResult = clipResult !== null && clipResult !== void 0 ? clipResult : new Array();
          if (v1Out) {
            nV1 = vertices[index + 1];
            nV2 = vertices[index + 2];
            nV3 = clipVertices(vertices[index], nV1);
            nV4 = clipVertices(vertices[index], nV2);
          }
          if (v2Out) {
            nV1 = vertices[index];
            nV2 = vertices[index + 2];
            nV3 = clipVertices(vertices[index + 1], nV1);
            nV4 = clipVertices(vertices[index + 1], nV2);
            clipResult.push(nV3);
            clipResult.push(nV2.clone());
            clipResult.push(nV1.clone());
            clipResult.push(nV2.clone());
            clipResult.push(nV3.clone());
            clipResult.push(nV4);
            break;
          }
          if (v3Out) {
            nV1 = vertices[index];
            nV2 = vertices[index + 1];
            nV3 = clipVertices(vertices[index + 2], nV1);
            nV4 = clipVertices(vertices[index + 2], nV2);
          }
          if (nV1 && nV2 && nV3 && nV4) {
            clipResult.push(nV1.clone());
            clipResult.push(nV2.clone());
            clipResult.push(nV3);
            clipResult.push(nV4);
            clipResult.push(nV3.clone());
            clipResult.push(nV2.clone());
          }
          break;
        case 2:
          clipResult = clipResult !== null && clipResult !== void 0 ? clipResult : new Array();
          if (!v1Out) {
            nV1 = vertices[index].clone();
            nV2 = clipVertices(nV1, vertices[index + 1]);
            nV3 = clipVertices(nV1, vertices[index + 2]);
            clipResult.push(nV1);
            clipResult.push(nV2);
            clipResult.push(nV3);
          }
          if (!v2Out) {
            nV1 = vertices[index + 1].clone();
            nV2 = clipVertices(nV1, vertices[index + 2]);
            nV3 = clipVertices(nV1, vertices[index]);
            clipResult.push(nV1);
            clipResult.push(nV2);
            clipResult.push(nV3);
          }
          if (!v3Out) {
            nV1 = vertices[index + 2].clone();
            nV2 = clipVertices(nV1, vertices[index]);
            nV3 = clipVertices(nV1, vertices[index + 1]);
            clipResult.push(nV1);
            clipResult.push(nV2);
            clipResult.push(nV3);
          }
          break;
        case 3:
          break;
      }
    }
    return clipResult;
  };
  const oneFaceVertices = new Array(3);
  for (let index = 0; index < indices.length; index += 3) {
    let faceVertices = oneFaceVertices;
    faceVertices[0] = extractDecalVector3(index);
    if (meshHasOverridenMaterial && useLocalComputation) {
      faceVertices[1] = extractDecalVector3(index + 2);
      faceVertices[2] = extractDecalVector3(index + 1);
    } else {
      faceVertices[1] = extractDecalVector3(index + 1);
      faceVertices[2] = extractDecalVector3(index + 2);
    }
    if (options.cullBackFaces) {
      if (-faceVertices[0].normal.z <= 0 && -faceVertices[1].normal.z <= 0 && -faceVertices[2].normal.z <= 0) {
        continue;
      }
    }
    faceVertices = clip(faceVertices, xpAxis);
    if (!faceVertices)
      continue;
    faceVertices = clip(faceVertices, xnAxis);
    if (!faceVertices)
      continue;
    faceVertices = clip(faceVertices, ypAxis);
    if (!faceVertices)
      continue;
    faceVertices = clip(faceVertices, ynAxis);
    if (!faceVertices)
      continue;
    faceVertices = clip(faceVertices, zpAxis);
    if (!faceVertices)
      continue;
    faceVertices = clip(faceVertices, znAxis);
    if (!faceVertices)
      continue;
    for (let vIndex = 0; vIndex < faceVertices.length; vIndex++) {
      const vertex = faceVertices[vIndex];
      vertexData.indices.push(currentVertexDataIndex);
      if (useLocalComputation) {
        if (vertex.localPositionOverride) {
          vertexData.positions[currentVertexDataIndex * 3] = vertex.localPositionOverride[0];
          vertexData.positions[currentVertexDataIndex * 3 + 1] = vertex.localPositionOverride[1];
          vertexData.positions[currentVertexDataIndex * 3 + 2] = vertex.localPositionOverride[2];
        } else if (localPositions) {
          vertexData.positions[currentVertexDataIndex * 3] = localPositions[vertex.vertexIdx];
          vertexData.positions[currentVertexDataIndex * 3 + 1] = localPositions[vertex.vertexIdx + 1];
          vertexData.positions[currentVertexDataIndex * 3 + 2] = localPositions[vertex.vertexIdx + 2];
        }
        if (vertex.localNormalOverride) {
          vertexData.normals[currentVertexDataIndex * 3] = vertex.localNormalOverride[0];
          vertexData.normals[currentVertexDataIndex * 3 + 1] = vertex.localNormalOverride[1];
          vertexData.normals[currentVertexDataIndex * 3 + 2] = vertex.localNormalOverride[2];
        } else if (localNormals) {
          vertexData.normals[currentVertexDataIndex * 3] = localNormals[vertex.vertexIdx];
          vertexData.normals[currentVertexDataIndex * 3 + 1] = localNormals[vertex.vertexIdx + 1];
          vertexData.normals[currentVertexDataIndex * 3 + 2] = localNormals[vertex.vertexIdx + 2];
        }
      } else {
        vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);
        vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);
      }
      if (vertexData.matricesIndices && vertexData.matricesWeights) {
        if (vertex.matrixIndicesOverride) {
          vertexData.matricesIndices[currentVertexDataIndex * 4] = vertex.matrixIndicesOverride[0];
          vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = vertex.matrixIndicesOverride[1];
          vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = vertex.matrixIndicesOverride[2];
          vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = vertex.matrixIndicesOverride[3];
        } else {
          if (matIndices) {
            vertexData.matricesIndices[currentVertexDataIndex * 4] = matIndices[vertex.vertexIdxForBones];
            vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = matIndices[vertex.vertexIdxForBones + 1];
            vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = matIndices[vertex.vertexIdxForBones + 2];
            vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = matIndices[vertex.vertexIdxForBones + 3];
          }
          if (matIndicesExtra && vertexData.matricesIndicesExtra) {
            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4] = matIndicesExtra[vertex.vertexIdxForBones];
            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 1] = matIndicesExtra[vertex.vertexIdxForBones + 1];
            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 2] = matIndicesExtra[vertex.vertexIdxForBones + 2];
            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 3] = matIndicesExtra[vertex.vertexIdxForBones + 3];
          }
        }
        if (vertex.matrixWeightsOverride) {
          vertexData.matricesWeights[currentVertexDataIndex * 4] = vertex.matrixWeightsOverride[0];
          vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = vertex.matrixWeightsOverride[1];
          vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = vertex.matrixWeightsOverride[2];
          vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = vertex.matrixWeightsOverride[3];
        } else {
          if (matWeights) {
            vertexData.matricesWeights[currentVertexDataIndex * 4] = matWeights[vertex.vertexIdxForBones];
            vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = matWeights[vertex.vertexIdxForBones + 1];
            vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = matWeights[vertex.vertexIdxForBones + 2];
            vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = matWeights[vertex.vertexIdxForBones + 3];
          }
          if (matWeightsExtra && vertexData.matricesWeightsExtra) {
            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4] = matWeightsExtra[vertex.vertexIdxForBones];
            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 1] = matWeightsExtra[vertex.vertexIdxForBones + 1];
            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 2] = matWeightsExtra[vertex.vertexIdxForBones + 2];
            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 3] = matWeightsExtra[vertex.vertexIdxForBones + 3];
          }
        }
      }
      if (!options.captureUVS) {
        vertexData.uvs.push(0.5 + vertex.position.x / size.x);
        const v = 0.5 + vertex.position.y / size.y;
        vertexData.uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
      } else {
        vertex.uv.toArray(vertexData.uvs, currentVertexDataIndex * 2);
      }
      currentVertexDataIndex++;
    }
  }
  const decal = new Mesh(name137, sourceMesh.getScene());
  vertexData.applyToMesh(decal);
  if (useLocalComputation) {
    decal.skeleton = sourceMesh.skeleton;
    decal.parent = sourceMesh;
  } else {
    decal.position = position.clone();
    decal.rotation = new Vector3(pitch, yaw, angle);
  }
  decal.computeWorldMatrix(true);
  decal.refreshBoundingInfo(true, true);
  return decal;
}
var DecalBuilder = {
  CreateDecal
};
Mesh.CreateDecal = (name137, sourceMesh, position, normal, size, angle) => {
  const options = {
    position,
    normal,
    size,
    angle
  };
  return CreateDecal(name137, sourceMesh, options);
};

// node_modules/@babylonjs/core/Maths/math.isovector.js
var _IsoVector = class {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
    if (x !== Math.floor(x)) {
      x === Math.floor(x);
      Logger.Warn("x is not an integer, floor(x) used");
    }
    if (y !== Math.floor(y)) {
      y === Math.floor(y);
      Logger.Warn("y is not an integer, floor(y) used");
    }
  }
  clone() {
    return new _IsoVector(this.x, this.y);
  }
  rotate60About(other) {
    const x = this.x;
    this.x = other.x + other.y - this.y;
    this.y = x + this.y - other.x;
    return this;
  }
  rotateNeg60About(other) {
    const x = this.x;
    this.x = x + this.y - other.y;
    this.y = other.x + other.y - x;
    return this;
  }
  rotate120(m, n) {
    if (m !== Math.floor(m)) {
      m === Math.floor(m);
      Logger.Warn("m not an integer only floor(m) used");
    }
    if (n !== Math.floor(n)) {
      n === Math.floor(n);
      Logger.Warn("n not an integer only floor(n) used");
    }
    const x = this.x;
    this.x = m - x - this.y;
    this.y = n + x;
    return this;
  }
  rotateNeg120(m, n) {
    if (m !== Math.floor(m)) {
      m === Math.floor(m);
      Logger.Warn("m is not an integer, floor(m) used");
    }
    if (n !== Math.floor(n)) {
      n === Math.floor(n);
      Logger.Warn("n is not an integer,   floor(n) used");
    }
    const x = this.x;
    this.x = this.y - n;
    this.y = m + n - x - this.y;
    return this;
  }
  toCartesianOrigin(origin, isoGridSize) {
    const point = Vector3.Zero();
    point.x = origin.x + 2 * this.x * isoGridSize + this.y * isoGridSize;
    point.y = origin.y + Math.sqrt(3) * this.y * isoGridSize;
    return point;
  }
  static Zero() {
    return new _IsoVector(0, 0);
  }
};

// node_modules/@babylonjs/core/Meshes/geodesicMesh.js
var _PrimaryIsoTriangle = class {
  constructor() {
    this.cartesian = [];
    this.vertices = [];
    this.max = [];
    this.min = [];
    this.closestTo = [];
    this.innerFacets = [];
    this.isoVecsABOB = [];
    this.isoVecsOBOA = [];
    this.isoVecsBAOA = [];
    this.vertexTypes = [];
    this.IDATA = new PolyhedronData("icosahedron", "Regular", [
      [0, PHI, -1],
      [-PHI, 1, 0],
      [-1, 0, -PHI],
      [1, 0, -PHI],
      [PHI, 1, 0],
      [0, PHI, 1],
      [-1, 0, PHI],
      [-PHI, -1, 0],
      [0, -PHI, -1],
      [PHI, -1, 0],
      [1, 0, PHI],
      [0, -PHI, 1]
    ], [
      [0, 2, 1],
      [0, 3, 2],
      [0, 4, 3],
      [0, 5, 4],
      [0, 1, 5],
      [7, 6, 1],
      [8, 7, 2],
      [9, 8, 3],
      [10, 9, 4],
      [6, 10, 5],
      [2, 7, 1],
      [3, 8, 2],
      [4, 9, 3],
      [5, 10, 4],
      [1, 6, 5],
      [11, 6, 7],
      [11, 7, 8],
      [11, 8, 9],
      [11, 9, 10],
      [11, 10, 6]
    ]);
  }
  setIndices() {
    let indexCount = 12;
    const vecToidx = {};
    const m = this.m;
    const n = this.n;
    let g = m;
    let m1 = 1;
    let n1 = 0;
    if (n !== 0) {
      g = Scalar.HCF(m, n);
    }
    m1 = m / g;
    n1 = n / g;
    let fr;
    let rot;
    let O;
    let A;
    let B;
    const oVec = _IsoVector.Zero();
    const aVec = new _IsoVector(m, n);
    const bVec = new _IsoVector(-n, m + n);
    const oaVec = _IsoVector.Zero();
    const abVec = _IsoVector.Zero();
    const obVec = _IsoVector.Zero();
    let verts = [];
    let idx;
    let idxR;
    let isoId;
    let isoIdR;
    const closestTo = [];
    const vDist = this.vertByDist;
    const matchIdx = (f, fr2, isoId2, isoIdR2) => {
      idx = f + "|" + isoId2;
      idxR = fr2 + "|" + isoIdR2;
      if (!(idx in vecToidx || idxR in vecToidx)) {
        vecToidx[idx] = indexCount;
        vecToidx[idxR] = indexCount;
        indexCount++;
      } else if (idx in vecToidx && !(idxR in vecToidx)) {
        vecToidx[idxR] = vecToidx[idx];
      } else if (idxR in vecToidx && !(idx in vecToidx)) {
        vecToidx[idx] = vecToidx[idxR];
      }
      if (vDist[isoId2][0] > 2) {
        closestTo[vecToidx[idx]] = [-vDist[isoId2][0], vDist[isoId2][1], vecToidx[idx]];
      } else {
        closestTo[vecToidx[idx]] = [verts[vDist[isoId2][0]], vDist[isoId2][1], vecToidx[idx]];
      }
    };
    this.IDATA.edgematch = [
      [1, "B"],
      [2, "B"],
      [3, "B"],
      [4, "B"],
      [0, "B"],
      [10, "O", 14, "A"],
      [11, "O", 10, "A"],
      [12, "O", 11, "A"],
      [13, "O", 12, "A"],
      [14, "O", 13, "A"],
      [0, "O"],
      [1, "O"],
      [2, "O"],
      [3, "O"],
      [4, "O"],
      [19, "B", 5, "A"],
      [15, "B", 6, "A"],
      [16, "B", 7, "A"],
      [17, "B", 8, "A"],
      [18, "B", 9, "A"]
    ];
    for (let f = 0; f < 20; f++) {
      verts = this.IDATA.face[f];
      O = verts[2];
      A = verts[1];
      B = verts[0];
      isoId = oVec.x + "|" + oVec.y;
      idx = f + "|" + isoId;
      if (!(idx in vecToidx)) {
        vecToidx[idx] = O;
        closestTo[O] = [verts[vDist[isoId][0]], vDist[isoId][1]];
      }
      isoId = aVec.x + "|" + aVec.y;
      idx = f + "|" + isoId;
      if (!(idx in vecToidx)) {
        vecToidx[idx] = A;
        closestTo[A] = [verts[vDist[isoId][0]], vDist[isoId][1]];
      }
      isoId = bVec.x + "|" + bVec.y;
      idx = f + "|" + isoId;
      if (!(idx in vecToidx)) {
        vecToidx[idx] = B;
        closestTo[B] = [verts[vDist[isoId][0]], vDist[isoId][1]];
      }
      fr = this.IDATA.edgematch[f][0];
      rot = this.IDATA.edgematch[f][1];
      if (rot === "B") {
        for (let i = 1; i < g; i++) {
          abVec.x = m - i * (m1 + n1);
          abVec.y = n + i * m1;
          obVec.x = -i * n1;
          obVec.y = i * (m1 + n1);
          isoId = abVec.x + "|" + abVec.y;
          isoIdR = obVec.x + "|" + obVec.y;
          matchIdx(f, fr, isoId, isoIdR);
        }
      }
      if (rot === "O") {
        for (let i = 1; i < g; i++) {
          obVec.x = -i * n1;
          obVec.y = i * (m1 + n1);
          oaVec.x = i * m1;
          oaVec.y = i * n1;
          isoId = obVec.x + "|" + obVec.y;
          isoIdR = oaVec.x + "|" + oaVec.y;
          matchIdx(f, fr, isoId, isoIdR);
        }
      }
      fr = this.IDATA.edgematch[f][2];
      rot = this.IDATA.edgematch[f][3];
      if (rot && rot === "A") {
        for (let i = 1; i < g; i++) {
          oaVec.x = i * m1;
          oaVec.y = i * n1;
          abVec.x = m - (g - i) * (m1 + n1);
          abVec.y = n + (g - i) * m1;
          isoId = oaVec.x + "|" + oaVec.y;
          isoIdR = abVec.x + "|" + abVec.y;
          matchIdx(f, fr, isoId, isoIdR);
        }
      }
      for (let i = 0; i < this.vertices.length; i++) {
        isoId = this.vertices[i].x + "|" + this.vertices[i].y;
        idx = f + "|" + isoId;
        if (!(idx in vecToidx)) {
          vecToidx[idx] = indexCount++;
          if (vDist[isoId][0] > 2) {
            closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];
          } else {
            closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];
          }
        }
      }
    }
    this.closestTo = closestTo;
    this.vecToidx = vecToidx;
  }
  calcCoeffs() {
    const m = this.m;
    const n = this.n;
    const thirdR3 = Math.sqrt(3) / 3;
    const LSQD = m * m + n * n + m * n;
    this.coau = (m + n) / LSQD;
    this.cobu = -n / LSQD;
    this.coav = -thirdR3 * (m - n) / LSQD;
    this.cobv = thirdR3 * (2 * m + n) / LSQD;
  }
  createInnerFacets() {
    const m = this.m;
    const n = this.n;
    for (let y = 0; y < n + m + 1; y++) {
      for (let x = this.min[y]; x < this.max[y] + 1; x++) {
        if (x < this.max[y] && x < this.max[y + 1] + 1) {
          this.innerFacets.push(["|" + x + "|" + y, "|" + x + "|" + (y + 1), "|" + (x + 1) + "|" + y]);
        }
        if (y > 0 && x < this.max[y - 1] && x + 1 < this.max[y] + 1) {
          this.innerFacets.push(["|" + x + "|" + y, "|" + (x + 1) + "|" + y, "|" + (x + 1) + "|" + (y - 1)]);
        }
      }
    }
  }
  edgeVecsABOB() {
    const m = this.m;
    const n = this.n;
    const B = new _IsoVector(-n, m + n);
    for (let y = 1; y < m + n; y++) {
      const point = new _IsoVector(this.min[y], y);
      const prev = new _IsoVector(this.min[y - 1], y - 1);
      const next = new _IsoVector(this.min[y + 1], y + 1);
      const pointR = point.clone();
      const prevR = prev.clone();
      const nextR = next.clone();
      pointR.rotate60About(B);
      prevR.rotate60About(B);
      nextR.rotate60About(B);
      const maxPoint = new _IsoVector(this.max[pointR.y], pointR.y);
      const maxPrev = new _IsoVector(this.max[pointR.y - 1], pointR.y - 1);
      const maxLeftPrev = new _IsoVector(this.max[pointR.y - 1] - 1, pointR.y - 1);
      if (pointR.x !== maxPoint.x || pointR.y !== maxPoint.y) {
        if (pointR.x !== maxPrev.x) {
          this.vertexTypes.push([1, 0, 0]);
          this.isoVecsABOB.push([point, maxPrev, maxLeftPrev]);
          this.vertexTypes.push([1, 0, 0]);
          this.isoVecsABOB.push([point, maxLeftPrev, maxPoint]);
        } else if (pointR.y === nextR.y) {
          this.vertexTypes.push([1, 1, 0]);
          this.isoVecsABOB.push([point, prev, maxPrev]);
          this.vertexTypes.push([1, 0, 1]);
          this.isoVecsABOB.push([point, maxPrev, next]);
        } else {
          this.vertexTypes.push([1, 1, 0]);
          this.isoVecsABOB.push([point, prev, maxPrev]);
          this.vertexTypes.push([1, 0, 0]);
          this.isoVecsABOB.push([point, maxPrev, maxPoint]);
        }
      }
    }
  }
  mapABOBtoOBOA() {
    const point = new _IsoVector(0, 0);
    for (let i = 0; i < this.isoVecsABOB.length; i++) {
      const temp = [];
      for (let j = 0; j < 3; j++) {
        point.x = this.isoVecsABOB[i][j].x;
        point.y = this.isoVecsABOB[i][j].y;
        if (this.vertexTypes[i][j] === 0) {
          point.rotateNeg120(this.m, this.n);
        }
        temp.push(point.clone());
      }
      this.isoVecsOBOA.push(temp);
    }
  }
  mapABOBtoBAOA() {
    const point = new _IsoVector(0, 0);
    for (let i = 0; i < this.isoVecsABOB.length; i++) {
      const temp = [];
      for (let j = 0; j < 3; j++) {
        point.x = this.isoVecsABOB[i][j].x;
        point.y = this.isoVecsABOB[i][j].y;
        if (this.vertexTypes[i][j] === 1) {
          point.rotate120(this.m, this.n);
        }
        temp.push(point.clone());
      }
      this.isoVecsBAOA.push(temp);
    }
  }
  MapToFace(faceNb, geodesicData) {
    const F = this.IDATA.face[faceNb];
    const oidx = F[2];
    const aidx = F[1];
    const bidx = F[0];
    const O = Vector3.FromArray(this.IDATA.vertex[oidx]);
    const A = Vector3.FromArray(this.IDATA.vertex[aidx]);
    const B = Vector3.FromArray(this.IDATA.vertex[bidx]);
    const OA = A.subtract(O);
    const OB = B.subtract(O);
    const x = OA.scale(this.coau).add(OB.scale(this.cobu));
    const y = OA.scale(this.coav).add(OB.scale(this.cobv));
    const mapped = [];
    let idx;
    let tempVec = TmpVectors.Vector3[0];
    for (let i = 0; i < this.cartesian.length; i++) {
      tempVec = x.scale(this.cartesian[i].x).add(y.scale(this.cartesian[i].y)).add(O);
      mapped[i] = [tempVec.x, tempVec.y, tempVec.z];
      idx = faceNb + "|" + this.vertices[i].x + "|" + this.vertices[i].y;
      geodesicData.vertex[this.vecToidx[idx]] = [tempVec.x, tempVec.y, tempVec.z];
    }
  }
  build(m, n) {
    const vertices = new Array();
    const O = _IsoVector.Zero();
    const A = new _IsoVector(m, n);
    const B = new _IsoVector(-n, m + n);
    vertices.push(O, A, B);
    for (let y2 = n; y2 < m + 1; y2++) {
      for (let x2 = 0; x2 < m + 1 - y2; x2++) {
        vertices.push(new _IsoVector(x2, y2));
      }
    }
    if (n > 0) {
      const g = Scalar.HCF(m, n);
      const m1 = m / g;
      const n1 = n / g;
      for (let i = 1; i < g; i++) {
        vertices.push(new _IsoVector(i * m1, i * n1));
        vertices.push(new _IsoVector(-i * n1, i * (m1 + n1)));
        vertices.push(new _IsoVector(m - i * (m1 + n1), n + i * m1));
      }
      const ratio = m / n;
      for (let y2 = 1; y2 < n; y2++) {
        for (let x2 = 0; x2 < y2 * ratio; x2++) {
          vertices.push(new _IsoVector(x2, y2));
          vertices.push(new _IsoVector(x2, y2).rotate120(m, n));
          vertices.push(new _IsoVector(x2, y2).rotateNeg120(m, n));
        }
      }
    }
    vertices.sort((a, b) => {
      return a.x - b.x;
    });
    vertices.sort((a, b) => {
      return a.y - b.y;
    });
    const min = new Array(m + n + 1);
    const max = new Array(m + n + 1);
    for (let i = 0; i < min.length; i++) {
      min[i] = Infinity;
      max[i] = -Infinity;
    }
    let y = 0;
    let x = 0;
    const len = vertices.length;
    for (let i = 0; i < len; i++) {
      x = vertices[i].x;
      y = vertices[i].y;
      min[y] = Math.min(x, min[y]);
      max[y] = Math.max(x, max[y]);
    }
    const distFrom = (vert, primVert) => {
      const v = vert.clone();
      if (primVert === "A") {
        v.rotateNeg120(m, n);
      }
      if (primVert === "B") {
        v.rotate120(m, n);
      }
      if (v.x < 0) {
        return v.y;
      }
      return v.x + v.y;
    };
    const cartesian = [];
    const distFromO = [];
    const distFromA = [];
    const distFromB = [];
    const vertByDist = {};
    const vertData = [];
    let closest = -1;
    let dist = -1;
    for (let i = 0; i < len; i++) {
      cartesian[i] = vertices[i].toCartesianOrigin(new _IsoVector(0, 0), 0.5);
      distFromO[i] = distFrom(vertices[i], "O");
      distFromA[i] = distFrom(vertices[i], "A");
      distFromB[i] = distFrom(vertices[i], "B");
      if (distFromO[i] === distFromA[i] && distFromA[i] === distFromB[i]) {
        closest = 3;
        dist = distFromO[i];
      } else if (distFromO[i] === distFromA[i]) {
        closest = 4;
        dist = distFromO[i];
      } else if (distFromA[i] === distFromB[i]) {
        closest = 5;
        dist = distFromA[i];
      } else if (distFromB[i] === distFromO[i]) {
        closest = 6;
        dist = distFromO[i];
      }
      if (distFromO[i] < distFromA[i] && distFromO[i] < distFromB[i]) {
        closest = 2;
        dist = distFromO[i];
      }
      if (distFromA[i] < distFromO[i] && distFromA[i] < distFromB[i]) {
        closest = 1;
        dist = distFromA[i];
      }
      if (distFromB[i] < distFromA[i] && distFromB[i] < distFromO[i]) {
        closest = 0;
        dist = distFromB[i];
      }
      vertData.push([closest, dist, vertices[i].x, vertices[i].y]);
    }
    vertData.sort((a, b) => {
      return a[2] - b[2];
    });
    vertData.sort((a, b) => {
      return a[3] - b[3];
    });
    vertData.sort((a, b) => {
      return a[1] - b[1];
    });
    vertData.sort((a, b) => {
      return a[0] - b[0];
    });
    for (let v = 0; v < vertData.length; v++) {
      vertByDist[vertData[v][2] + "|" + vertData[v][3]] = [vertData[v][0], vertData[v][1], v];
    }
    this.m = m;
    this.n = n;
    this.vertices = vertices;
    this.vertByDist = vertByDist;
    this.cartesian = cartesian;
    this.min = min;
    this.max = max;
    return this;
  }
};
var PolyhedronData = class {
  constructor(name137, category, vertex, face) {
    this.name = name137;
    this.category = category;
    this.vertex = vertex;
    this.face = face;
  }
};
var GeodesicData = class extends PolyhedronData {
  innerToData(face, primTri) {
    for (let i = 0; i < primTri.innerFacets.length; i++) {
      this.face.push(primTri.innerFacets[i].map((el) => primTri.vecToidx[face + el]));
    }
  }
  mapABOBtoDATA(faceNb, primTri) {
    const fr = primTri.IDATA.edgematch[faceNb][0];
    for (let i = 0; i < primTri.isoVecsABOB.length; i++) {
      const temp = [];
      for (let j = 0; j < 3; j++) {
        if (primTri.vertexTypes[i][j] === 0) {
          temp.push(faceNb + "|" + primTri.isoVecsABOB[i][j].x + "|" + primTri.isoVecsABOB[i][j].y);
        } else {
          temp.push(fr + "|" + primTri.isoVecsABOB[i][j].x + "|" + primTri.isoVecsABOB[i][j].y);
        }
      }
      this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);
    }
  }
  mapOBOAtoDATA(faceNb, primTri) {
    const fr = primTri.IDATA.edgematch[faceNb][0];
    for (let i = 0; i < primTri.isoVecsOBOA.length; i++) {
      const temp = [];
      for (let j = 0; j < 3; j++) {
        if (primTri.vertexTypes[i][j] === 1) {
          temp.push(faceNb + "|" + primTri.isoVecsOBOA[i][j].x + "|" + primTri.isoVecsOBOA[i][j].y);
        } else {
          temp.push(fr + "|" + primTri.isoVecsOBOA[i][j].x + "|" + primTri.isoVecsOBOA[i][j].y);
        }
      }
      this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);
    }
  }
  mapBAOAtoDATA(faceNb, primTri) {
    const fr = primTri.IDATA.edgematch[faceNb][2];
    for (let i = 0; i < primTri.isoVecsBAOA.length; i++) {
      const temp = [];
      for (let j = 0; j < 3; j++) {
        if (primTri.vertexTypes[i][j] === 1) {
          temp.push(faceNb + "|" + primTri.isoVecsBAOA[i][j].x + "|" + primTri.isoVecsBAOA[i][j].y);
        } else {
          temp.push(fr + "|" + primTri.isoVecsBAOA[i][j].x + "|" + primTri.isoVecsBAOA[i][j].y);
        }
      }
      this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);
    }
  }
  orderData(primTri) {
    const nearTo = [];
    for (let i = 0; i < 13; i++) {
      nearTo[i] = [];
    }
    const close = primTri.closestTo;
    for (let i = 0; i < close.length; i++) {
      if (close[i][0] > -1) {
        if (close[i][1] > 0) {
          nearTo[close[i][0]].push([i, close[i][1]]);
        }
      } else {
        nearTo[12].push([i, close[i][0]]);
      }
    }
    const near = [];
    for (let i = 0; i < 12; i++) {
      near[i] = i;
    }
    let nearIndex = 12;
    for (let i = 0; i < 12; i++) {
      nearTo[i].sort((a, b) => {
        return a[1] - b[1];
      });
      for (let j = 0; j < nearTo[i].length; j++) {
        near[nearTo[i][j][0]] = nearIndex++;
      }
    }
    for (let j = 0; j < nearTo[12].length; j++) {
      near[nearTo[12][j][0]] = nearIndex++;
    }
    for (let i = 0; i < this.vertex.length; i++) {
      this.vertex[i].push(near[i]);
    }
    this.vertex.sort((a, b) => {
      return a[3] - b[3];
    });
    for (let i = 0; i < this.vertex.length; i++) {
      this.vertex[i].pop();
    }
    for (let i = 0; i < this.face.length; i++) {
      for (let j = 0; j < this.face[i].length; j++) {
        this.face[i][j] = near[this.face[i][j]];
      }
    }
    this.sharedNodes = nearTo[12].length;
    this.poleNodes = this.vertex.length - this.sharedNodes;
  }
  setOrder(m, faces) {
    const adjVerts = [];
    const dualFaces = [];
    let face = faces.pop();
    dualFaces.push(face);
    let index = this.face[face].indexOf(m);
    index = (index + 2) % 3;
    let v = this.face[face][index];
    adjVerts.push(v);
    let f = 0;
    while (faces.length > 0) {
      face = faces[f];
      if (this.face[face].indexOf(v) > -1) {
        index = (this.face[face].indexOf(v) + 1) % 3;
        v = this.face[face][index];
        adjVerts.push(v);
        dualFaces.push(face);
        faces.splice(f, 1);
        f = 0;
      } else {
        f++;
      }
    }
    this.adjacentFaces.push(adjVerts);
    return dualFaces;
  }
  toGoldbergPolyhedronData() {
    const goldbergPolyhedronData = new PolyhedronData("GeoDual", "Goldberg", [], []);
    goldbergPolyhedronData.name = "GD dual";
    const verticesNb = this.vertex.length;
    const map = new Array(verticesNb);
    for (let v = 0; v < verticesNb; v++) {
      map[v] = [];
    }
    for (let f = 0; f < this.face.length; f++) {
      for (let i = 0; i < 3; i++) {
        map[this.face[f][i]].push(f);
      }
    }
    let cx = 0;
    let cy = 0;
    let cz = 0;
    let face = [];
    let vertex = [];
    this.adjacentFaces = [];
    for (let m = 0; m < map.length; m++) {
      goldbergPolyhedronData.face[m] = this.setOrder(m, map[m].concat([]));
      map[m].forEach((el) => {
        cx = 0;
        cy = 0;
        cz = 0;
        face = this.face[el];
        for (let i = 0; i < 3; i++) {
          vertex = this.vertex[face[i]];
          cx += vertex[0];
          cy += vertex[1];
          cz += vertex[2];
        }
        goldbergPolyhedronData.vertex[el] = [cx / 3, cy / 3, cz / 3];
      });
    }
    return goldbergPolyhedronData;
  }
  static BuildGeodesicData(primTri) {
    const geodesicData = new GeodesicData("Geodesic-m-n", "Geodesic", [
      [0, PHI, -1],
      [-PHI, 1, 0],
      [-1, 0, -PHI],
      [1, 0, -PHI],
      [PHI, 1, 0],
      [0, PHI, 1],
      [-1, 0, PHI],
      [-PHI, -1, 0],
      [0, -PHI, -1],
      [PHI, -1, 0],
      [1, 0, PHI],
      [0, -PHI, 1]
    ], []);
    primTri.setIndices();
    primTri.calcCoeffs();
    primTri.createInnerFacets();
    primTri.edgeVecsABOB();
    primTri.mapABOBtoOBOA();
    primTri.mapABOBtoBAOA();
    for (let f = 0; f < primTri.IDATA.face.length; f++) {
      primTri.MapToFace(f, geodesicData);
      geodesicData.innerToData(f, primTri);
      if (primTri.IDATA.edgematch[f][1] === "B") {
        geodesicData.mapABOBtoDATA(f, primTri);
      }
      if (primTri.IDATA.edgematch[f][1] === "O") {
        geodesicData.mapOBOAtoDATA(f, primTri);
      }
      if (primTri.IDATA.edgematch[f][3] === "A") {
        geodesicData.mapBAOAtoDATA(f, primTri);
      }
    }
    geodesicData.orderData(primTri);
    const radius = 1;
    geodesicData.vertex = geodesicData.vertex.map(function(el) {
      const a = el[0];
      const b = el[1];
      const c = el[2];
      const d = Math.sqrt(a * a + b * b + c * c);
      el[0] *= radius / d;
      el[1] *= radius / d;
      el[2] *= radius / d;
      return el;
    });
    return geodesicData;
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/geodesicBuilder.js
function CreateGeodesic(name137, options, scene = null) {
  let m = options.m || 1;
  if (m !== Math.floor(m)) {
    m === Math.floor(m);
    Logger.Warn("m not an integer only floor(m) used");
  }
  let n = options.n || 0;
  if (n !== Math.floor(n)) {
    n === Math.floor(n);
    Logger.Warn("n not an integer only floor(n) used");
  }
  if (n > m) {
    const temp = n;
    n = m;
    m = temp;
    Logger.Warn("n > m therefore m and n swapped");
  }
  const primTri = new _PrimaryIsoTriangle();
  primTri.build(m, n);
  const geodesicData = GeodesicData.BuildGeodesicData(primTri);
  const geoOptions = {
    custom: geodesicData,
    size: options.size,
    sizeX: options.sizeX,
    sizeY: options.sizeY,
    sizeZ: options.sizeZ,
    faceUV: options.faceUV,
    faceColors: options.faceColors,
    flat: options.flat,
    updatable: options.updatable,
    sideOrientation: options.sideOrientation,
    frontUVs: options.frontUVs,
    backUVs: options.backUVs
  };
  const geodesic = CreatePolyhedron(name137, geoOptions, scene);
  return geodesic;
}

// node_modules/@babylonjs/core/Meshes/Builders/goldbergBuilder.js
function CreateGoldbergVertexData(options, goldbergData) {
  const size = options.size;
  const sizeX = options.sizeX || size || 1;
  const sizeY = options.sizeY || size || 1;
  const sizeZ = options.sizeZ || size || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const positions = new Array();
  const indices = new Array();
  const normals = new Array();
  const uvs = new Array();
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let v = 0; v < goldbergData.vertex.length; v++) {
    minX = Math.min(minX, goldbergData.vertex[v][0] * sizeX);
    maxX = Math.max(maxX, goldbergData.vertex[v][0] * sizeX);
    minY = Math.min(minY, goldbergData.vertex[v][1] * sizeY);
    maxY = Math.max(maxY, goldbergData.vertex[v][1] * sizeY);
  }
  let index = 0;
  for (let f = 0; f < goldbergData.face.length; f++) {
    const verts = goldbergData.face[f];
    const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);
    const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);
    const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);
    const ba = b.subtract(a);
    const ca = c.subtract(a);
    const norm = Vector3.Cross(ca, ba).normalize();
    for (let v = 0; v < verts.length; v++) {
      normals.push(norm.x, norm.y, norm.z);
      const pdata = goldbergData.vertex[verts[v]];
      positions.push(pdata[0] * sizeX, pdata[1] * sizeY, pdata[2] * sizeZ);
      const vCoord = (pdata[1] * sizeY - minY) / (maxY - minY);
      uvs.push((pdata[0] * sizeX - minX) / (maxX - minX), CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - vCoord : vCoord);
    }
    for (let v = 0; v < verts.length - 2; v++) {
      indices.push(index, index + v + 2, index + v + 1);
    }
    index += verts.length;
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);
  const vertexData = new VertexData();
  vertexData.positions = positions;
  vertexData.indices = indices;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateGoldberg(name137, options, scene = null) {
  const size = options.size;
  const sizeX = options.sizeX || size || 1;
  const sizeY = options.sizeY || size || 1;
  const sizeZ = options.sizeZ || size || 1;
  let m = options.m || 1;
  if (m !== Math.floor(m)) {
    m === Math.floor(m);
    Logger.Warn("m not an integer only floor(m) used");
  }
  let n = options.n || 0;
  if (n !== Math.floor(n)) {
    n === Math.floor(n);
    Logger.Warn("n not an integer only floor(n) used");
  }
  if (n > m) {
    const temp = n;
    n = m;
    m = temp;
    Logger.Warn("n > m therefore m and n swapped");
  }
  const primTri = new _PrimaryIsoTriangle();
  primTri.build(m, n);
  const geodesicData = GeodesicData.BuildGeodesicData(primTri);
  const goldbergData = geodesicData.toGoldbergPolyhedronData();
  const goldberg = new GoldbergMesh(name137, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  goldberg._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateGoldbergVertexData(options, goldbergData);
  vertexData.applyToMesh(goldberg, options.updatable);
  goldberg.goldbergData.nbSharedFaces = geodesicData.sharedNodes;
  goldberg.goldbergData.nbUnsharedFaces = geodesicData.poleNodes;
  goldberg.goldbergData.adjacentFaces = geodesicData.adjacentFaces;
  goldberg.goldbergData.nbFaces = goldberg.goldbergData.nbSharedFaces + goldberg.goldbergData.nbUnsharedFaces;
  goldberg.goldbergData.nbFacesAtPole = (goldberg.goldbergData.nbUnsharedFaces - 12) / 12;
  for (let f = 0; f < geodesicData.vertex.length; f++) {
    goldberg.goldbergData.faceCenters.push(Vector3.FromArray(geodesicData.vertex[f]));
    goldberg.goldbergData.faceCenters[f].x *= sizeX;
    goldberg.goldbergData.faceCenters[f].y *= sizeY;
    goldberg.goldbergData.faceCenters[f].z *= sizeZ;
    goldberg.goldbergData.faceColors.push(new Color4(1, 1, 1, 1));
  }
  for (let f = 0; f < goldbergData.face.length; f++) {
    const verts = goldbergData.face[f];
    const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);
    const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);
    const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);
    const ba = b.subtract(a);
    const ca = c.subtract(a);
    const norm = Vector3.Cross(ca, ba).normalize();
    const z = Vector3.Cross(ca, norm).normalize();
    goldberg.goldbergData.faceXaxis.push(ca.normalize());
    goldberg.goldbergData.faceYaxis.push(norm);
    goldberg.goldbergData.faceZaxis.push(z);
  }
  return goldberg;
}
Mesh.CreateGoldberg = CreateGoldberg;

// node_modules/@babylonjs/core/Meshes/meshBuilder.js
var MeshBuilder = {
  CreateBox,
  CreateTiledBox,
  CreateSphere,
  CreateDisc,
  CreateIcoSphere,
  CreateRibbon,
  CreateCylinder,
  CreateTorus,
  CreateTorusKnot,
  CreateLineSystem,
  CreateLines,
  CreateDashedLines,
  ExtrudeShape,
  ExtrudeShapeCustom,
  CreateLathe,
  CreateTiledPlane,
  CreatePlane,
  CreateGround,
  CreateTiledGround,
  CreateGroundFromHeightMap,
  CreatePolygon,
  ExtrudePolygon,
  CreateTube,
  CreatePolyhedron,
  CreateGeodesic,
  CreateGoldberg,
  CreateDecal,
  CreateCapsule
};

// node_modules/@babylonjs/core/Meshes/meshSimplification.js
var SimplificationSettings = class {
  constructor(quality, distance, optimizeMesh) {
    this.quality = quality;
    this.distance = distance;
    this.optimizeMesh = optimizeMesh;
  }
};
var SimplificationQueue = class {
  constructor() {
    this.running = false;
    this._simplificationArray = [];
  }
  addTask(task) {
    this._simplificationArray.push(task);
  }
  executeNext() {
    const task = this._simplificationArray.pop();
    if (task) {
      this.running = true;
      this.runSimplification(task);
    } else {
      this.running = false;
    }
  }
  runSimplification(task) {
    if (task.parallelProcessing) {
      task.settings.forEach((setting) => {
        const simplifier = this._getSimplifier(task);
        simplifier.simplify(setting, (newMesh) => {
          if (setting.distance !== void 0) {
            task.mesh.addLODLevel(setting.distance, newMesh);
          }
          newMesh.isVisible = true;
          if (setting.quality === task.settings[task.settings.length - 1].quality && task.successCallback) {
            task.successCallback();
          }
          this.executeNext();
        });
      });
    } else {
      const simplifier = this._getSimplifier(task);
      const runDecimation = (setting, callback) => {
        simplifier.simplify(setting, (newMesh) => {
          if (setting.distance !== void 0) {
            task.mesh.addLODLevel(setting.distance, newMesh);
          }
          newMesh.isVisible = true;
          callback();
        });
      };
      AsyncLoop.Run(task.settings.length, (loop) => {
        runDecimation(task.settings[loop.index], () => {
          loop.executeNext();
        });
      }, () => {
        if (task.successCallback) {
          task.successCallback();
        }
        this.executeNext();
      });
    }
  }
  _getSimplifier(task) {
    switch (task.simplificationType) {
      case SimplificationType.QUADRATIC:
      default:
        return new QuadraticErrorSimplification(task.mesh);
    }
  }
};
var SimplificationType;
(function(SimplificationType2) {
  SimplificationType2[SimplificationType2["QUADRATIC"] = 0] = "QUADRATIC";
})(SimplificationType || (SimplificationType = {}));
var DecimationTriangle = class {
  constructor(_vertices) {
    this._vertices = _vertices;
    this.error = new Array(4);
    this.deleted = false;
    this.isDirty = false;
    this.deletePending = false;
    this.borderFactor = 0;
  }
};
var DecimationVertex = class {
  constructor(position, id) {
    this.position = position;
    this.id = id;
    this.isBorder = true;
    this.q = new QuadraticMatrix();
    this.triangleCount = 0;
    this.triangleStart = 0;
    this.originalOffsets = [];
  }
  updatePosition(newPosition) {
    this.position.copyFrom(newPosition);
  }
};
var QuadraticMatrix = class {
  constructor(data) {
    this.data = new Array(10);
    for (let i = 0; i < 10; ++i) {
      if (data && data[i]) {
        this.data[i] = data[i];
      } else {
        this.data[i] = 0;
      }
    }
  }
  det(a11, a12, a13, a21, a22, a23, a31, a32, a33) {
    const det = this.data[a11] * this.data[a22] * this.data[a33] + this.data[a13] * this.data[a21] * this.data[a32] + this.data[a12] * this.data[a23] * this.data[a31] - this.data[a13] * this.data[a22] * this.data[a31] - this.data[a11] * this.data[a23] * this.data[a32] - this.data[a12] * this.data[a21] * this.data[a33];
    return det;
  }
  addInPlace(matrix) {
    for (let i = 0; i < 10; ++i) {
      this.data[i] += matrix.data[i];
    }
  }
  addArrayInPlace(data) {
    for (let i = 0; i < 10; ++i) {
      this.data[i] += data[i];
    }
  }
  add(matrix) {
    const m = new QuadraticMatrix();
    for (let i = 0; i < 10; ++i) {
      m.data[i] = this.data[i] + matrix.data[i];
    }
    return m;
  }
  static FromData(a, b, c, d) {
    return new QuadraticMatrix(QuadraticMatrix.DataFromNumbers(a, b, c, d));
  }
  static DataFromNumbers(a, b, c, d) {
    return [a * a, a * b, a * c, a * d, b * b, b * c, b * d, c * c, c * d, d * d];
  }
};
var Reference = class {
  constructor(vertexId, triangleId) {
    this.vertexId = vertexId;
    this.triangleId = triangleId;
  }
};
var QuadraticErrorSimplification = class {
  constructor(_mesh) {
    this._mesh = _mesh;
    this.syncIterations = 5e3;
    this.aggressiveness = 7;
    this.decimationIterations = 100;
    this.boundingBoxEpsilon = Epsilon;
  }
  simplify(settings, successCallback) {
    this._initDecimatedMesh();
    AsyncLoop.Run(this._mesh.subMeshes.length, (loop) => {
      this._initWithMesh(loop.index, () => {
        this._runDecimation(settings, loop.index, () => {
          loop.executeNext();
        });
      }, settings.optimizeMesh);
    }, () => {
      setTimeout(() => {
        successCallback(this._reconstructedMesh);
      }, 0);
    });
  }
  _runDecimation(settings, submeshIndex, successCallback) {
    const targetCount = ~~(this._triangles.length * settings.quality);
    let deletedTriangles = 0;
    const triangleCount = this._triangles.length;
    const iterationFunction = (iteration, callback) => {
      setTimeout(() => {
        if (iteration % 5 === 0) {
          this._updateMesh(iteration === 0);
        }
        for (let i = 0; i < this._triangles.length; ++i) {
          this._triangles[i].isDirty = false;
        }
        const threshold = 1e-9 * Math.pow(iteration + 3, this.aggressiveness);
        const trianglesIterator = (i) => {
          const tIdx = ~~((this._triangles.length / 2 + i) % this._triangles.length);
          const t = this._triangles[tIdx];
          if (!t) {
            return;
          }
          if (t.error[3] > threshold || t.deleted || t.isDirty) {
            return;
          }
          for (let j = 0; j < 3; ++j) {
            if (t.error[j] < threshold) {
              const deleted0 = [];
              const deleted1 = [];
              const v0 = t._vertices[j];
              const v1 = t._vertices[(j + 1) % 3];
              if (v0.isBorder || v1.isBorder) {
                continue;
              }
              const p = Vector3.Zero();
              this._calculateError(v0, v1, p);
              const delTr = new Array();
              if (this._isFlipped(v0, v1, p, deleted0, delTr)) {
                continue;
              }
              if (this._isFlipped(v1, v0, p, deleted1, delTr)) {
                continue;
              }
              if (deleted0.indexOf(true) < 0 || deleted1.indexOf(true) < 0) {
                continue;
              }
              const uniqueArray = new Array();
              delTr.forEach((deletedT) => {
                if (uniqueArray.indexOf(deletedT) === -1) {
                  deletedT.deletePending = true;
                  uniqueArray.push(deletedT);
                }
              });
              if (uniqueArray.length % 2 !== 0) {
                continue;
              }
              v0.q = v1.q.add(v0.q);
              v0.updatePosition(p);
              const tStart = this._references.length;
              deletedTriangles = this._updateTriangles(v0, v0, deleted0, deletedTriangles);
              deletedTriangles = this._updateTriangles(v0, v1, deleted1, deletedTriangles);
              const tCount = this._references.length - tStart;
              if (tCount <= v0.triangleCount) {
                if (tCount) {
                  for (let c = 0; c < tCount; c++) {
                    this._references[v0.triangleStart + c] = this._references[tStart + c];
                  }
                }
              } else {
                v0.triangleStart = tStart;
              }
              v0.triangleCount = tCount;
              break;
            }
          }
        };
        AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, trianglesIterator, callback, () => {
          return triangleCount - deletedTriangles <= targetCount;
        });
      }, 0);
    };
    AsyncLoop.Run(this.decimationIterations, (loop) => {
      if (triangleCount - deletedTriangles <= targetCount) {
        loop.breakLoop();
      } else {
        iterationFunction(loop.index, () => {
          loop.executeNext();
        });
      }
    }, () => {
      setTimeout(() => {
        this._reconstructMesh(submeshIndex);
        successCallback();
      }, 0);
    });
  }
  _initWithMesh(submeshIndex, callback, optimizeMesh) {
    this._vertices = [];
    this._triangles = [];
    const positionData = this._mesh.getVerticesData(VertexBuffer.PositionKind);
    const indices = this._mesh.getIndices();
    const submesh = this._mesh.subMeshes[submeshIndex];
    const findInVertices = (positionToSearch) => {
      if (optimizeMesh) {
        for (let ii = 0; ii < this._vertices.length; ++ii) {
          if (this._vertices[ii].position.equalsWithEpsilon(positionToSearch, 1e-4)) {
            return this._vertices[ii];
          }
        }
      }
      return null;
    };
    const vertexReferences = [];
    const vertexInit = (i) => {
      if (!positionData) {
        return;
      }
      const offset = i + submesh.verticesStart;
      const position = Vector3.FromArray(positionData, offset * 3);
      const vertex = findInVertices(position) || new DecimationVertex(position, this._vertices.length);
      vertex.originalOffsets.push(offset);
      if (vertex.id === this._vertices.length) {
        this._vertices.push(vertex);
      }
      vertexReferences.push(vertex.id);
    };
    const totalVertices = submesh.verticesCount;
    AsyncLoop.SyncAsyncForLoop(totalVertices, this.syncIterations / 4 >> 0, vertexInit, () => {
      const indicesInit = (i) => {
        if (!indices) {
          return;
        }
        const offset = submesh.indexStart / 3 + i;
        const pos = offset * 3;
        const i0 = indices[pos + 0];
        const i1 = indices[pos + 1];
        const i2 = indices[pos + 2];
        const v0 = this._vertices[vertexReferences[i0 - submesh.verticesStart]];
        const v1 = this._vertices[vertexReferences[i1 - submesh.verticesStart]];
        const v2 = this._vertices[vertexReferences[i2 - submesh.verticesStart]];
        const triangle = new DecimationTriangle([v0, v1, v2]);
        triangle.originalOffset = pos;
        this._triangles.push(triangle);
      };
      AsyncLoop.SyncAsyncForLoop(submesh.indexCount / 3, this.syncIterations, indicesInit, () => {
        this._init(callback);
      });
    });
  }
  _init(callback) {
    const triangleInit1 = (i) => {
      const t = this._triangles[i];
      t.normal = Vector3.Cross(t._vertices[1].position.subtract(t._vertices[0].position), t._vertices[2].position.subtract(t._vertices[0].position)).normalize();
      for (let j = 0; j < 3; j++) {
        t._vertices[j].q.addArrayInPlace(QuadraticMatrix.DataFromNumbers(t.normal.x, t.normal.y, t.normal.z, -Vector3.Dot(t.normal, t._vertices[0].position)));
      }
    };
    AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, triangleInit1, () => {
      const triangleInit2 = (i) => {
        const t = this._triangles[i];
        for (let j = 0; j < 3; ++j) {
          t.error[j] = this._calculateError(t._vertices[j], t._vertices[(j + 1) % 3]);
        }
        t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);
      };
      AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, triangleInit2, () => {
        callback();
      });
    });
  }
  _reconstructMesh(submeshIndex) {
    const newTriangles = [];
    let i;
    for (i = 0; i < this._vertices.length; ++i) {
      this._vertices[i].triangleCount = 0;
    }
    let t;
    let j;
    for (i = 0; i < this._triangles.length; ++i) {
      if (!this._triangles[i].deleted) {
        t = this._triangles[i];
        for (j = 0; j < 3; ++j) {
          t._vertices[j].triangleCount = 1;
        }
        newTriangles.push(t);
      }
    }
    const newPositionData = this._reconstructedMesh.getVerticesData(VertexBuffer.PositionKind) || [];
    const newNormalData = this._reconstructedMesh.getVerticesData(VertexBuffer.NormalKind) || [];
    const newUVsData = this._reconstructedMesh.getVerticesData(VertexBuffer.UVKind) || [];
    const newColorsData = this._reconstructedMesh.getVerticesData(VertexBuffer.ColorKind) || [];
    const normalData = this._mesh.getVerticesData(VertexBuffer.NormalKind);
    const uvs = this._mesh.getVerticesData(VertexBuffer.UVKind);
    const colorsData = this._mesh.getVerticesData(VertexBuffer.ColorKind);
    let vertexCount = 0;
    for (i = 0; i < this._vertices.length; ++i) {
      const vertex = this._vertices[i];
      vertex.id = vertexCount;
      if (vertex.triangleCount) {
        vertex.originalOffsets.forEach((originalOffset) => {
          newPositionData.push(vertex.position.x);
          newPositionData.push(vertex.position.y);
          newPositionData.push(vertex.position.z);
          if (normalData && normalData.length) {
            newNormalData.push(normalData[originalOffset * 3]);
            newNormalData.push(normalData[originalOffset * 3 + 1]);
            newNormalData.push(normalData[originalOffset * 3 + 2]);
          }
          if (uvs && uvs.length) {
            newUVsData.push(uvs[originalOffset * 2]);
            newUVsData.push(uvs[originalOffset * 2 + 1]);
          }
          if (colorsData && colorsData.length) {
            newColorsData.push(colorsData[originalOffset * 4]);
            newColorsData.push(colorsData[originalOffset * 4 + 1]);
            newColorsData.push(colorsData[originalOffset * 4 + 2]);
            newColorsData.push(colorsData[originalOffset * 4 + 3]);
          }
          ++vertexCount;
        });
      }
    }
    const startingIndex = this._reconstructedMesh.getTotalIndices();
    const startingVertex = this._reconstructedMesh.getTotalVertices();
    const submeshesArray = this._reconstructedMesh.subMeshes;
    this._reconstructedMesh.subMeshes = [];
    const newIndicesArray = this._reconstructedMesh.getIndices();
    const originalIndices = this._mesh.getIndices();
    for (i = 0; i < newTriangles.length; ++i) {
      t = newTriangles[i];
      [0, 1, 2].forEach((idx) => {
        const id = originalIndices[t.originalOffset + idx];
        let offset = t._vertices[idx].originalOffsets.indexOf(id);
        if (offset < 0) {
          offset = 0;
        }
        newIndicesArray.push(t._vertices[idx].id + offset + startingVertex);
      });
    }
    this._reconstructedMesh.setIndices(newIndicesArray);
    this._reconstructedMesh.setVerticesData(VertexBuffer.PositionKind, newPositionData);
    if (newNormalData.length > 0) {
      this._reconstructedMesh.setVerticesData(VertexBuffer.NormalKind, newNormalData);
    }
    if (newUVsData.length > 0) {
      this._reconstructedMesh.setVerticesData(VertexBuffer.UVKind, newUVsData);
    }
    if (newColorsData.length > 0) {
      this._reconstructedMesh.setVerticesData(VertexBuffer.ColorKind, newColorsData);
    }
    const originalSubmesh = this._mesh.subMeshes[submeshIndex];
    if (submeshIndex > 0) {
      this._reconstructedMesh.subMeshes = [];
      submeshesArray.forEach((submesh) => {
        SubMesh.AddToMesh(
          submesh.materialIndex,
          submesh.verticesStart,
          submesh.verticesCount,
          submesh.indexStart,
          submesh.indexCount,
          submesh.getMesh()
        );
      });
      SubMesh.AddToMesh(
        originalSubmesh.materialIndex,
        startingVertex,
        vertexCount,
        startingIndex,
        newTriangles.length * 3,
        this._reconstructedMesh
      );
    }
  }
  _initDecimatedMesh() {
    this._reconstructedMesh = new Mesh(this._mesh.name + "Decimated", this._mesh.getScene());
    this._reconstructedMesh.material = this._mesh.material;
    this._reconstructedMesh.parent = this._mesh.parent;
    this._reconstructedMesh.isVisible = false;
    this._reconstructedMesh.renderingGroupId = this._mesh.renderingGroupId;
  }
  _isFlipped(vertex1, vertex2, point, deletedArray, delTr) {
    for (let i = 0; i < vertex1.triangleCount; ++i) {
      const t = this._triangles[this._references[vertex1.triangleStart + i].triangleId];
      if (t.deleted) {
        continue;
      }
      const s = this._references[vertex1.triangleStart + i].vertexId;
      const v1 = t._vertices[(s + 1) % 3];
      const v2 = t._vertices[(s + 2) % 3];
      if (v1 === vertex2 || v2 === vertex2) {
        deletedArray[i] = true;
        delTr.push(t);
        continue;
      }
      let d1 = v1.position.subtract(point);
      d1 = d1.normalize();
      let d2 = v2.position.subtract(point);
      d2 = d2.normalize();
      if (Math.abs(Vector3.Dot(d1, d2)) > 0.999) {
        return true;
      }
      const normal = Vector3.Cross(d1, d2).normalize();
      deletedArray[i] = false;
      if (Vector3.Dot(normal, t.normal) < 0.2) {
        return true;
      }
    }
    return false;
  }
  _updateTriangles(origVertex, vertex, deletedArray, deletedTriangles) {
    let newDeleted = deletedTriangles;
    for (let i = 0; i < vertex.triangleCount; ++i) {
      const ref = this._references[vertex.triangleStart + i];
      const t = this._triangles[ref.triangleId];
      if (t.deleted) {
        continue;
      }
      if (deletedArray[i] && t.deletePending) {
        t.deleted = true;
        newDeleted++;
        continue;
      }
      t._vertices[ref.vertexId] = origVertex;
      t.isDirty = true;
      t.error[0] = this._calculateError(t._vertices[0], t._vertices[1]) + t.borderFactor / 2;
      t.error[1] = this._calculateError(t._vertices[1], t._vertices[2]) + t.borderFactor / 2;
      t.error[2] = this._calculateError(t._vertices[2], t._vertices[0]) + t.borderFactor / 2;
      t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);
      this._references.push(ref);
    }
    return newDeleted;
  }
  _identifyBorder() {
    for (let i = 0; i < this._vertices.length; ++i) {
      const vCount = [];
      const vId = [];
      const v = this._vertices[i];
      let j;
      for (j = 0; j < v.triangleCount; ++j) {
        const triangle = this._triangles[this._references[v.triangleStart + j].triangleId];
        for (let ii = 0; ii < 3; ii++) {
          let ofs = 0;
          const vv = triangle._vertices[ii];
          while (ofs < vCount.length) {
            if (vId[ofs] === vv.id) {
              break;
            }
            ++ofs;
          }
          if (ofs === vCount.length) {
            vCount.push(1);
            vId.push(vv.id);
          } else {
            vCount[ofs]++;
          }
        }
      }
      for (j = 0; j < vCount.length; ++j) {
        if (vCount[j] === 1) {
          this._vertices[vId[j]].isBorder = true;
        } else {
          this._vertices[vId[j]].isBorder = false;
        }
      }
    }
  }
  _updateMesh(identifyBorders = false) {
    let i;
    if (!identifyBorders) {
      const newTrianglesVector = [];
      for (i = 0; i < this._triangles.length; ++i) {
        if (!this._triangles[i].deleted) {
          newTrianglesVector.push(this._triangles[i]);
        }
      }
      this._triangles = newTrianglesVector;
    }
    for (i = 0; i < this._vertices.length; ++i) {
      this._vertices[i].triangleCount = 0;
      this._vertices[i].triangleStart = 0;
    }
    let t;
    let j;
    let v;
    for (i = 0; i < this._triangles.length; ++i) {
      t = this._triangles[i];
      for (j = 0; j < 3; ++j) {
        v = t._vertices[j];
        v.triangleCount++;
      }
    }
    let tStart = 0;
    for (i = 0; i < this._vertices.length; ++i) {
      this._vertices[i].triangleStart = tStart;
      tStart += this._vertices[i].triangleCount;
      this._vertices[i].triangleCount = 0;
    }
    const newReferences = new Array(this._triangles.length * 3);
    for (i = 0; i < this._triangles.length; ++i) {
      t = this._triangles[i];
      for (j = 0; j < 3; ++j) {
        v = t._vertices[j];
        newReferences[v.triangleStart + v.triangleCount] = new Reference(j, i);
        v.triangleCount++;
      }
    }
    this._references = newReferences;
    if (identifyBorders) {
      this._identifyBorder();
    }
  }
  _vertexError(q, point) {
    const x = point.x;
    const y = point.y;
    const z = point.z;
    return q.data[0] * x * x + 2 * q.data[1] * x * y + 2 * q.data[2] * x * z + 2 * q.data[3] * x + q.data[4] * y * y + 2 * q.data[5] * y * z + 2 * q.data[6] * y + q.data[7] * z * z + 2 * q.data[8] * z + q.data[9];
  }
  _calculateError(vertex1, vertex2, pointResult) {
    const q = vertex1.q.add(vertex2.q);
    const border = vertex1.isBorder && vertex2.isBorder;
    let error = 0;
    const qDet = q.det(0, 1, 2, 1, 4, 5, 2, 5, 7);
    if (qDet !== 0 && !border) {
      if (!pointResult) {
        pointResult = Vector3.Zero();
      }
      pointResult.x = -1 / qDet * q.det(1, 2, 3, 4, 5, 6, 5, 7, 8);
      pointResult.y = 1 / qDet * q.det(0, 2, 3, 1, 5, 6, 2, 7, 8);
      pointResult.z = -1 / qDet * q.det(0, 1, 3, 1, 4, 6, 2, 5, 8);
      error = this._vertexError(q, pointResult);
    } else {
      const p3 = vertex1.position.add(vertex2.position).divide(new Vector3(2, 2, 2));
      const error1 = this._vertexError(q, vertex1.position);
      const error2 = this._vertexError(q, vertex2.position);
      const error3 = this._vertexError(q, p3);
      error = Math.min(error1, error2, error3);
      if (error === error1) {
        if (pointResult) {
          pointResult.copyFrom(vertex1.position);
        }
      } else if (error === error2) {
        if (pointResult) {
          pointResult.copyFrom(vertex2.position);
        }
      } else {
        if (pointResult) {
          pointResult.copyFrom(p3);
        }
      }
    }
    return error;
  }
};

// node_modules/@babylonjs/core/Meshes/meshSimplificationSceneComponent.js
Object.defineProperty(Scene.prototype, "simplificationQueue", {
  get: function() {
    if (!this._simplificationQueue) {
      this._simplificationQueue = new SimplificationQueue();
      let component = this._getComponent(SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE);
      if (!component) {
        component = new SimplicationQueueSceneComponent(this);
        this._addComponent(component);
      }
    }
    return this._simplificationQueue;
  },
  set: function(value) {
    this._simplificationQueue = value;
  },
  enumerable: true,
  configurable: true
});
Mesh.prototype.simplify = function(settings, parallelProcessing = true, simplificationType = SimplificationType.QUADRATIC, successCallback) {
  this.getScene().simplificationQueue.addTask({
    settings,
    parallelProcessing,
    mesh: this,
    simplificationType,
    successCallback
  });
  return this;
};
var SimplicationQueueSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE;
    this.scene = scene;
  }
  register() {
    this.scene._beforeCameraUpdateStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE, this, this._beforeCameraUpdate);
  }
  rebuild() {
  }
  dispose() {
  }
  _beforeCameraUpdate() {
    if (this.scene._simplificationQueue && !this.scene._simplificationQueue.running) {
      this.scene._simplificationQueue.executeNext();
    }
  }
};

// node_modules/@babylonjs/core/Navigation/Plugins/recastJSPlugin.js
var RecastJSPlugin = class {
  constructor(recastInjection = Recast) {
    this.bjsRECAST = {};
    this.name = "RecastJSPlugin";
    this._maximumSubStepCount = 10;
    this._timeStep = 1 / 60;
    this._timeFactor = 1;
    this._worker = null;
    if (typeof recastInjection === "function") {
      Logger.Error("RecastJS is not ready. Please make sure you await Recast() before using the plugin.");
    } else {
      this.bjsRECAST = recastInjection;
    }
    if (!this.isSupported()) {
      Logger.Error("RecastJS is not available. Please make sure you included the js file.");
      return;
    }
    this.setTimeStep();
    this._tempVec1 = new this.bjsRECAST.Vec3();
    this._tempVec2 = new this.bjsRECAST.Vec3();
  }
  setWorkerURL(workerURL) {
    if (window && window.Worker) {
      this._worker = new Worker(workerURL);
      return true;
    }
    return false;
  }
  setTimeStep(newTimeStep = 1 / 60) {
    this._timeStep = newTimeStep;
  }
  getTimeStep() {
    return this._timeStep;
  }
  setMaximumSubStepCount(newStepCount = 10) {
    this._maximumSubStepCount = newStepCount;
  }
  getMaximumSubStepCount() {
    return this._maximumSubStepCount;
  }
  set timeFactor(value) {
    this._timeFactor = Math.max(value, 0);
  }
  get timeFactor() {
    return this._timeFactor;
  }
  createNavMesh(meshes, parameters, completion) {
    if (this._worker && !completion) {
      console.warn("A worker is avaible but no completion callback. Defaulting to blocking navmesh creation");
    } else if (!this._worker && completion) {
      console.warn("A completion callback is avaible but no worker. Defaulting to blocking navmesh creation");
    }
    this.navMesh = new this.bjsRECAST.NavMesh();
    let index;
    let tri;
    let pt;
    const indices = [];
    const positions = [];
    let offset = 0;
    for (index = 0; index < meshes.length; index++) {
      if (meshes[index]) {
        const mesh = meshes[index];
        const meshIndices = mesh.getIndices();
        if (!meshIndices) {
          continue;
        }
        const meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);
        if (!meshPositions) {
          continue;
        }
        const worldMatrices = [];
        const worldMatrix = mesh.computeWorldMatrix(true);
        if (mesh.hasThinInstances) {
          const thinMatrices = mesh.thinInstanceGetWorldMatrices();
          for (let instanceIndex = 0; instanceIndex < thinMatrices.length; instanceIndex++) {
            const tmpMatrix2 = new Matrix();
            const thinMatrix = thinMatrices[instanceIndex];
            thinMatrix.multiplyToRef(worldMatrix, tmpMatrix2);
            worldMatrices.push(tmpMatrix2);
          }
        } else {
          worldMatrices.push(worldMatrix);
        }
        for (let matrixIndex = 0; matrixIndex < worldMatrices.length; matrixIndex++) {
          const wm = worldMatrices[matrixIndex];
          for (tri = 0; tri < meshIndices.length; tri++) {
            indices.push(meshIndices[tri] + offset);
          }
          const transformed = Vector3.Zero();
          const position = Vector3.Zero();
          for (pt = 0; pt < meshPositions.length; pt += 3) {
            Vector3.FromArrayToRef(meshPositions, pt, position);
            Vector3.TransformCoordinatesToRef(position, wm, transformed);
            positions.push(transformed.x, transformed.y, transformed.z);
          }
          offset += meshPositions.length / 3;
        }
      }
    }
    if (this._worker && completion) {
      this._worker.postMessage([positions, offset, indices, indices.length, parameters]);
      this._worker.onmessage = function(e) {
        completion(e.data);
      };
    } else {
      const rc = new this.bjsRECAST.rcConfig();
      rc.cs = parameters.cs;
      rc.ch = parameters.ch;
      rc.borderSize = parameters.borderSize ? parameters.borderSize : 0;
      rc.tileSize = parameters.tileSize ? parameters.tileSize : 0;
      rc.walkableSlopeAngle = parameters.walkableSlopeAngle;
      rc.walkableHeight = parameters.walkableHeight;
      rc.walkableClimb = parameters.walkableClimb;
      rc.walkableRadius = parameters.walkableRadius;
      rc.maxEdgeLen = parameters.maxEdgeLen;
      rc.maxSimplificationError = parameters.maxSimplificationError;
      rc.minRegionArea = parameters.minRegionArea;
      rc.mergeRegionArea = parameters.mergeRegionArea;
      rc.maxVertsPerPoly = parameters.maxVertsPerPoly;
      rc.detailSampleDist = parameters.detailSampleDist;
      rc.detailSampleMaxError = parameters.detailSampleMaxError;
      this.navMesh.build(positions, offset, indices, indices.length, rc);
    }
  }
  createDebugNavMesh(scene) {
    let tri;
    let pt;
    const debugNavMesh = this.navMesh.getDebugNavMesh();
    const triangleCount = debugNavMesh.getTriangleCount();
    const indices = [];
    const positions = [];
    for (tri = 0; tri < triangleCount * 3; tri++) {
      indices.push(tri);
    }
    for (tri = 0; tri < triangleCount; tri++) {
      for (pt = 0; pt < 3; pt++) {
        const point = debugNavMesh.getTriangle(tri).getPoint(pt);
        positions.push(point.x, point.y, point.z);
      }
    }
    const mesh = new Mesh("NavMeshDebug", scene);
    const vertexData = new VertexData();
    vertexData.indices = indices;
    vertexData.positions = positions;
    vertexData.applyToMesh(mesh, false);
    return mesh;
  }
  getClosestPoint(position) {
    this._tempVec1.x = position.x;
    this._tempVec1.y = position.y;
    this._tempVec1.z = position.z;
    const ret = this.navMesh.getClosestPoint(this._tempVec1);
    const pr = new Vector3(ret.x, ret.y, ret.z);
    return pr;
  }
  getClosestPointToRef(position, result) {
    this._tempVec1.x = position.x;
    this._tempVec1.y = position.y;
    this._tempVec1.z = position.z;
    const ret = this.navMesh.getClosestPoint(this._tempVec1);
    result.set(ret.x, ret.y, ret.z);
  }
  getRandomPointAround(position, maxRadius) {
    this._tempVec1.x = position.x;
    this._tempVec1.y = position.y;
    this._tempVec1.z = position.z;
    const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);
    const pr = new Vector3(ret.x, ret.y, ret.z);
    return pr;
  }
  getRandomPointAroundToRef(position, maxRadius, result) {
    this._tempVec1.x = position.x;
    this._tempVec1.y = position.y;
    this._tempVec1.z = position.z;
    const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);
    result.set(ret.x, ret.y, ret.z);
  }
  moveAlong(position, destination) {
    this._tempVec1.x = position.x;
    this._tempVec1.y = position.y;
    this._tempVec1.z = position.z;
    this._tempVec2.x = destination.x;
    this._tempVec2.y = destination.y;
    this._tempVec2.z = destination.z;
    const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);
    const pr = new Vector3(ret.x, ret.y, ret.z);
    return pr;
  }
  moveAlongToRef(position, destination, result) {
    this._tempVec1.x = position.x;
    this._tempVec1.y = position.y;
    this._tempVec1.z = position.z;
    this._tempVec2.x = destination.x;
    this._tempVec2.y = destination.y;
    this._tempVec2.z = destination.z;
    const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);
    result.set(ret.x, ret.y, ret.z);
  }
  computePath(start, end) {
    let pt;
    this._tempVec1.x = start.x;
    this._tempVec1.y = start.y;
    this._tempVec1.z = start.z;
    this._tempVec2.x = end.x;
    this._tempVec2.y = end.y;
    this._tempVec2.z = end.z;
    const navPath = this.navMesh.computePath(this._tempVec1, this._tempVec2);
    const pointCount = navPath.getPointCount();
    const positions = [];
    for (pt = 0; pt < pointCount; pt++) {
      const p = navPath.getPoint(pt);
      positions.push(new Vector3(p.x, p.y, p.z));
    }
    return positions;
  }
  createCrowd(maxAgents, maxAgentRadius, scene) {
    const crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);
    return crowd;
  }
  setDefaultQueryExtent(extent) {
    this._tempVec1.x = extent.x;
    this._tempVec1.y = extent.y;
    this._tempVec1.z = extent.z;
    this.navMesh.setDefaultQueryExtent(this._tempVec1);
  }
  getDefaultQueryExtent() {
    const p = this.navMesh.getDefaultQueryExtent();
    return new Vector3(p.x, p.y, p.z);
  }
  buildFromNavmeshData(data) {
    const nDataBytes = data.length * data.BYTES_PER_ELEMENT;
    const dataPtr = this.bjsRECAST._malloc(nDataBytes);
    const dataHeap = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, dataPtr, nDataBytes);
    dataHeap.set(data);
    const buf = new this.bjsRECAST.NavmeshData();
    buf.dataPointer = dataHeap.byteOffset;
    buf.size = data.length;
    this.navMesh = new this.bjsRECAST.NavMesh();
    this.navMesh.buildFromNavmeshData(buf);
    this.bjsRECAST._free(dataHeap.byteOffset);
  }
  getNavmeshData() {
    const navmeshData = this.navMesh.getNavmeshData();
    const arrView = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);
    const ret = new Uint8Array(navmeshData.size);
    ret.set(arrView);
    this.navMesh.freeNavmeshData(navmeshData);
    return ret;
  }
  getDefaultQueryExtentToRef(result) {
    const p = this.navMesh.getDefaultQueryExtent();
    result.set(p.x, p.y, p.z);
  }
  dispose() {
  }
  addCylinderObstacle(position, radius, height) {
    this._tempVec1.x = position.x;
    this._tempVec1.y = position.y;
    this._tempVec1.z = position.z;
    return this.navMesh.addCylinderObstacle(this._tempVec1, radius, height);
  }
  addBoxObstacle(position, extent, angle) {
    this._tempVec1.x = position.x;
    this._tempVec1.y = position.y;
    this._tempVec1.z = position.z;
    this._tempVec2.x = extent.x;
    this._tempVec2.y = extent.y;
    this._tempVec2.z = extent.z;
    return this.navMesh.addBoxObstacle(this._tempVec1, this._tempVec2, angle);
  }
  removeObstacle(obstacle) {
    this.navMesh.removeObstacle(obstacle);
  }
  isSupported() {
    return this.bjsRECAST !== void 0;
  }
};
var RecastJSCrowd = class {
  constructor(plugin, maxAgents, maxAgentRadius, scene) {
    this.recastCrowd = {};
    this.transforms = new Array();
    this.agents = new Array();
    this.reachRadii = new Array();
    this._agentDestinationArmed = new Array();
    this._agentDestination = new Array();
    this._onBeforeAnimationsObserver = null;
    this.onReachTargetObservable = new Observable();
    this.bjsRECASTPlugin = plugin;
    this.recastCrowd = new this.bjsRECASTPlugin.bjsRECAST.Crowd(maxAgents, maxAgentRadius, this.bjsRECASTPlugin.navMesh.getNavMesh());
    this._scene = scene;
    this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {
      this.update(scene.getEngine().getDeltaTime() * 1e-3 * plugin.timeFactor);
    });
  }
  addAgent(pos, parameters, transform) {
    const agentParams = new this.bjsRECASTPlugin.bjsRECAST.dtCrowdAgentParams();
    agentParams.radius = parameters.radius;
    agentParams.height = parameters.height;
    agentParams.maxAcceleration = parameters.maxAcceleration;
    agentParams.maxSpeed = parameters.maxSpeed;
    agentParams.collisionQueryRange = parameters.collisionQueryRange;
    agentParams.pathOptimizationRange = parameters.pathOptimizationRange;
    agentParams.separationWeight = parameters.separationWeight;
    agentParams.updateFlags = 7;
    agentParams.obstacleAvoidanceType = 0;
    agentParams.queryFilterType = 0;
    agentParams.userData = 0;
    const agentIndex = this.recastCrowd.addAgent(new this.bjsRECASTPlugin.bjsRECAST.Vec3(pos.x, pos.y, pos.z), agentParams);
    this.transforms.push(transform);
    this.agents.push(agentIndex);
    this.reachRadii.push(parameters.reachRadius ? parameters.reachRadius : parameters.radius);
    this._agentDestinationArmed.push(false);
    this._agentDestination.push(new Vector3(0, 0, 0));
    return agentIndex;
  }
  getAgentPosition(index) {
    const agentPos = this.recastCrowd.getAgentPosition(index);
    return new Vector3(agentPos.x, agentPos.y, agentPos.z);
  }
  getAgentPositionToRef(index, result) {
    const agentPos = this.recastCrowd.getAgentPosition(index);
    result.set(agentPos.x, agentPos.y, agentPos.z);
  }
  getAgentVelocity(index) {
    const agentVel = this.recastCrowd.getAgentVelocity(index);
    return new Vector3(agentVel.x, agentVel.y, agentVel.z);
  }
  getAgentVelocityToRef(index, result) {
    const agentVel = this.recastCrowd.getAgentVelocity(index);
    result.set(agentVel.x, agentVel.y, agentVel.z);
  }
  getAgentNextTargetPath(index) {
    const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);
    return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);
  }
  getAgentNextTargetPathToRef(index, result) {
    const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);
    result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);
  }
  getAgentState(index) {
    return this.recastCrowd.getAgentState(index);
  }
  overOffmeshConnection(index) {
    return this.recastCrowd.overOffmeshConnection(index);
  }
  agentGoto(index, destination) {
    this.recastCrowd.agentGoto(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));
    const item = this.agents.indexOf(index);
    if (item > -1) {
      this._agentDestinationArmed[item] = true;
      this._agentDestination[item].set(destination.x, destination.y, destination.z);
    }
  }
  agentTeleport(index, destination) {
    this.recastCrowd.agentTeleport(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));
  }
  updateAgentParameters(index, parameters) {
    const agentParams = this.recastCrowd.getAgentParameters(index);
    if (parameters.radius !== void 0) {
      agentParams.radius = parameters.radius;
    }
    if (parameters.height !== void 0) {
      agentParams.height = parameters.height;
    }
    if (parameters.maxAcceleration !== void 0) {
      agentParams.maxAcceleration = parameters.maxAcceleration;
    }
    if (parameters.maxSpeed !== void 0) {
      agentParams.maxSpeed = parameters.maxSpeed;
    }
    if (parameters.collisionQueryRange !== void 0) {
      agentParams.collisionQueryRange = parameters.collisionQueryRange;
    }
    if (parameters.pathOptimizationRange !== void 0) {
      agentParams.pathOptimizationRange = parameters.pathOptimizationRange;
    }
    if (parameters.separationWeight !== void 0) {
      agentParams.separationWeight = parameters.separationWeight;
    }
    this.recastCrowd.setAgentParameters(index, agentParams);
  }
  removeAgent(index) {
    this.recastCrowd.removeAgent(index);
    const item = this.agents.indexOf(index);
    if (item > -1) {
      this.agents.splice(item, 1);
      this.transforms.splice(item, 1);
      this.reachRadii.splice(item, 1);
      this._agentDestinationArmed.splice(item, 1);
      this._agentDestination.splice(item, 1);
    }
  }
  getAgents() {
    return this.agents;
  }
  update(deltaTime) {
    this.bjsRECASTPlugin.navMesh.update();
    if (deltaTime <= Epsilon) {
      return;
    }
    const timeStep = this.bjsRECASTPlugin.getTimeStep();
    const maxStepCount = this.bjsRECASTPlugin.getMaximumSubStepCount();
    if (timeStep <= Epsilon) {
      this.recastCrowd.update(deltaTime);
    } else {
      let iterationCount = Math.floor(deltaTime / timeStep);
      if (maxStepCount && iterationCount > maxStepCount) {
        iterationCount = maxStepCount;
      }
      if (iterationCount < 1) {
        iterationCount = 1;
      }
      const step = deltaTime / iterationCount;
      for (let i = 0; i < iterationCount; i++) {
        this.recastCrowd.update(step);
      }
    }
    for (let index = 0; index < this.agents.length; index++) {
      const agentIndex = this.agents[index];
      const agentPosition = this.getAgentPosition(agentIndex);
      this.transforms[index].position = agentPosition;
      if (this._agentDestinationArmed[index]) {
        const dx = agentPosition.x - this._agentDestination[index].x;
        const dz = agentPosition.z - this._agentDestination[index].z;
        const radius = this.reachRadii[index];
        const groundY = this._agentDestination[index].y - this.reachRadii[index];
        const ceilingY = this._agentDestination[index].y + this.reachRadii[index];
        const distanceXZSquared = dx * dx + dz * dz;
        if (agentPosition.y > groundY && agentPosition.y < ceilingY && distanceXZSquared < radius * radius) {
          this.onReachTargetObservable.notifyObservers({ agentIndex, destination: this._agentDestination[index] });
          this._agentDestinationArmed[index] = false;
        }
      }
    }
  }
  setDefaultQueryExtent(extent) {
    const ext = new this.bjsRECASTPlugin.bjsRECAST.Vec3(extent.x, extent.y, extent.z);
    this.recastCrowd.setDefaultQueryExtent(ext);
  }
  getDefaultQueryExtent() {
    const p = this.recastCrowd.getDefaultQueryExtent();
    return new Vector3(p.x, p.y, p.z);
  }
  getDefaultQueryExtentToRef(result) {
    const p = this.recastCrowd.getDefaultQueryExtent();
    result.set(p.x, p.y, p.z);
  }
  getCorners(index) {
    let pt;
    const navPath = this.recastCrowd.getCorners(index);
    const pointCount = navPath.getPointCount();
    const positions = [];
    for (pt = 0; pt < pointCount; pt++) {
      const p = navPath.getPoint(pt);
      positions.push(new Vector3(p.x, p.y, p.z));
    }
    return positions;
  }
  dispose() {
    this.recastCrowd.destroy();
    this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);
    this._onBeforeAnimationsObserver = null;
    this.onReachTargetObservable.clear();
  }
};

// node_modules/@babylonjs/core/Offline/database.js
Engine.OfflineProviderFactory = (urlToScene, callbackManifestChecked, disableManifestCheck = false) => {
  return new Database(urlToScene, callbackManifestChecked, disableManifestCheck);
};
var Database = class {
  constructor(urlToScene, callbackManifestChecked, disableManifestCheck = false) {
    this._idbFactory = typeof indexedDB !== "undefined" ? indexedDB : void 0;
    this._currentSceneUrl = Database._ReturnFullUrlLocation(urlToScene);
    this._db = null;
    this._enableSceneOffline = false;
    this._enableTexturesOffline = false;
    this._manifestVersionFound = 0;
    this._mustUpdateRessources = false;
    this._hasReachedQuota = false;
    if (!Database.IDBStorageEnabled) {
      callbackManifestChecked(true);
    } else {
      if (disableManifestCheck) {
        this._enableSceneOffline = true;
        this._enableTexturesOffline = true;
        this._manifestVersionFound = 1;
        Tools.SetImmediate(() => {
          callbackManifestChecked(true);
        });
      } else {
        this._checkManifestFile(callbackManifestChecked);
      }
    }
  }
  get enableSceneOffline() {
    return this._enableSceneOffline;
  }
  get enableTexturesOffline() {
    return this._enableTexturesOffline;
  }
  _checkManifestFile(callbackManifestChecked) {
    const noManifestFile = () => {
      this._enableSceneOffline = false;
      this._enableTexturesOffline = false;
      callbackManifestChecked(false);
    };
    const createManifestURL = () => {
      try {
        if (typeof URL === "function" && this._currentSceneUrl.indexOf("http") === 0) {
          const url = new URL(this._currentSceneUrl);
          url.pathname += ".manifest";
          return url.toString();
        }
      } catch (e) {
      }
      return `${this._currentSceneUrl}.manifest`;
    };
    let timeStampUsed = false;
    let manifestURL = createManifestURL();
    const xhr = new WebRequest();
    if (navigator.onLine) {
      timeStampUsed = true;
      manifestURL = manifestURL + (manifestURL.match(/\?/) == null ? "?" : "&") + Date.now();
    }
    xhr.open("GET", manifestURL);
    xhr.addEventListener("load", () => {
      if (xhr.status === 200 || Database._ValidateXHRData(xhr, 1)) {
        try {
          const manifestFile = JSON.parse(xhr.response);
          this._enableSceneOffline = manifestFile.enableSceneOffline;
          this._enableTexturesOffline = manifestFile.enableTexturesOffline && Database._IsUASupportingBlobStorage;
          if (manifestFile.version && !isNaN(parseInt(manifestFile.version))) {
            this._manifestVersionFound = manifestFile.version;
          }
          callbackManifestChecked(true);
        } catch (ex) {
          noManifestFile();
        }
      } else {
        noManifestFile();
      }
    }, false);
    xhr.addEventListener("error", () => {
      if (timeStampUsed) {
        timeStampUsed = false;
        const retryManifestURL = createManifestURL();
        xhr.open("GET", retryManifestURL);
        xhr.send();
      } else {
        noManifestFile();
      }
    }, false);
    try {
      xhr.send();
    } catch (ex) {
      Logger.Error("Error on XHR send request.");
      callbackManifestChecked(false);
    }
  }
  open(successCallback, errorCallback) {
    const handleError = () => {
      this._isSupported = false;
      if (errorCallback) {
        errorCallback();
      }
    };
    if (!this._idbFactory || !(this._enableSceneOffline || this._enableTexturesOffline)) {
      this._isSupported = false;
      if (errorCallback) {
        errorCallback();
      }
    } else {
      if (!this._db) {
        this._hasReachedQuota = false;
        this._isSupported = true;
        const request = this._idbFactory.open("babylonjs", 1);
        request.onerror = () => {
          handleError();
        };
        request.onblocked = () => {
          Logger.Error("IDB request blocked. Please reload the page.");
          handleError();
        };
        request.onsuccess = () => {
          this._db = request.result;
          successCallback();
        };
        request.onupgradeneeded = (event) => {
          this._db = event.target.result;
          if (this._db) {
            try {
              this._db.createObjectStore("scenes", { keyPath: "sceneUrl" });
              this._db.createObjectStore("versions", { keyPath: "sceneUrl" });
              this._db.createObjectStore("textures", { keyPath: "textureUrl" });
            } catch (ex) {
              Logger.Error("Error while creating object stores. Exception: " + ex.message);
              handleError();
            }
          }
        };
      } else {
        if (successCallback) {
          successCallback();
        }
      }
    }
  }
  loadImage(url, image) {
    const completeURL = Database._ReturnFullUrlLocation(url);
    const saveAndLoadImage = () => {
      if (!this._hasReachedQuota && this._db !== null) {
        this._saveImageIntoDBAsync(completeURL, image);
      } else {
        image.src = url;
      }
    };
    if (!this._mustUpdateRessources) {
      this._loadImageFromDBAsync(completeURL, image, saveAndLoadImage);
    } else {
      saveAndLoadImage();
    }
  }
  _loadImageFromDBAsync(url, image, notInDBCallback) {
    if (this._isSupported && this._db !== null) {
      let texture;
      const transaction = this._db.transaction(["textures"]);
      transaction.onabort = () => {
        image.src = url;
      };
      transaction.oncomplete = () => {
        let blobTextureURL;
        if (texture && typeof URL === "function") {
          blobTextureURL = URL.createObjectURL(texture.data);
          image.onerror = () => {
            Logger.Error("Error loading image from blob URL: " + blobTextureURL + " switching back to web url: " + url);
            image.src = url;
          };
          image.src = blobTextureURL;
        } else {
          notInDBCallback();
        }
      };
      const getRequest = transaction.objectStore("textures").get(url);
      getRequest.onsuccess = (event) => {
        texture = event.target.result;
      };
      getRequest.onerror = () => {
        Logger.Error("Error loading texture " + url + " from DB.");
        image.src = url;
      };
    } else {
      Logger.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open.");
      image.src = url;
    }
  }
  _saveImageIntoDBAsync(url, image) {
    let blob;
    if (this._isSupported) {
      const generateBlobUrl = () => {
        let blobTextureURL;
        if (blob && typeof URL === "function") {
          try {
            blobTextureURL = URL.createObjectURL(blob);
          } catch (ex) {
            blobTextureURL = URL.createObjectURL(blob);
          }
        }
        if (blobTextureURL) {
          image.src = blobTextureURL;
        }
      };
      if (Database._IsUASupportingBlobStorage) {
        const xhr = new WebRequest();
        xhr.open("GET", url);
        xhr.responseType = "blob";
        xhr.addEventListener("load", () => {
          if (xhr.status === 200 && this._db) {
            blob = xhr.response;
            const transaction = this._db.transaction(["textures"], "readwrite");
            transaction.onabort = (event) => {
              try {
                const srcElement = event.target;
                const error = srcElement.error;
                if (error && error.name === "QuotaExceededError") {
                  this._hasReachedQuota = true;
                }
              } catch (ex) {
              }
              generateBlobUrl();
            };
            transaction.oncomplete = () => {
              generateBlobUrl();
            };
            const newTexture = { textureUrl: url, data: blob };
            try {
              const addRequest = transaction.objectStore("textures").put(newTexture);
              addRequest.onsuccess = () => {
              };
              addRequest.onerror = () => {
                generateBlobUrl();
              };
            } catch (ex) {
              if (ex.code === 25) {
                Database._IsUASupportingBlobStorage = false;
                this._enableTexturesOffline = false;
              }
              image.src = url;
            }
          } else {
            image.src = url;
          }
        }, false);
        xhr.addEventListener("error", () => {
          Logger.Error("Error in XHR request in BABYLON.Database.");
          image.src = url;
        }, false);
        xhr.send();
      } else {
        image.src = url;
      }
    } else {
      Logger.Error("Error: IndexedDB not supported by your browser or Babylon.js database is not open.");
      image.src = url;
    }
  }
  _checkVersionFromDB(url, versionLoaded) {
    const updateVersion = () => {
      this._saveVersionIntoDBAsync(url, versionLoaded);
    };
    this._loadVersionFromDBAsync(url, versionLoaded, updateVersion);
  }
  _loadVersionFromDBAsync(url, callback, updateInDBCallback) {
    if (this._isSupported && this._db) {
      let version;
      try {
        const transaction = this._db.transaction(["versions"]);
        transaction.oncomplete = () => {
          if (version) {
            if (this._manifestVersionFound !== version.data) {
              this._mustUpdateRessources = true;
              updateInDBCallback();
            } else {
              callback(version.data);
            }
          } else {
            this._mustUpdateRessources = true;
            updateInDBCallback();
          }
        };
        transaction.onabort = () => {
          callback(-1);
        };
        const getRequest = transaction.objectStore("versions").get(url);
        getRequest.onsuccess = (event) => {
          version = event.target.result;
        };
        getRequest.onerror = () => {
          Logger.Error("Error loading version for scene " + url + " from DB.");
          callback(-1);
        };
      } catch (ex) {
        Logger.Error("Error while accessing 'versions' object store (READ OP). Exception: " + ex.message);
        callback(-1);
      }
    } else {
      Logger.Error("Error: IndexedDB not supported by your browser or Babylon.js database is not open.");
      callback(-1);
    }
  }
  _saveVersionIntoDBAsync(url, callback) {
    if (this._isSupported && !this._hasReachedQuota && this._db) {
      try {
        const transaction = this._db.transaction(["versions"], "readwrite");
        transaction.onabort = (event) => {
          try {
            const error = event.target["error"];
            if (error && error.name === "QuotaExceededError") {
              this._hasReachedQuota = true;
            }
          } catch (ex) {
          }
          callback(-1);
        };
        transaction.oncomplete = () => {
          callback(this._manifestVersionFound);
        };
        const newVersion = { sceneUrl: url, data: this._manifestVersionFound };
        const addRequest = transaction.objectStore("versions").put(newVersion);
        addRequest.onsuccess = () => {
        };
        addRequest.onerror = () => {
          Logger.Error("Error in DB add version request in BABYLON.Database.");
        };
      } catch (ex) {
        Logger.Error("Error while accessing 'versions' object store (WRITE OP). Exception: " + ex.message);
        callback(-1);
      }
    } else {
      callback(-1);
    }
  }
  loadFile(url, sceneLoaded, progressCallBack, errorCallback, useArrayBuffer) {
    const completeUrl = Database._ReturnFullUrlLocation(url);
    const saveAndLoadFile = () => {
      this._saveFileAsync(completeUrl, sceneLoaded, progressCallBack, useArrayBuffer, errorCallback);
    };
    this._checkVersionFromDB(completeUrl, (version) => {
      if (version !== -1) {
        if (!this._mustUpdateRessources) {
          this._loadFileAsync(completeUrl, sceneLoaded, saveAndLoadFile);
        } else {
          this._saveFileAsync(completeUrl, sceneLoaded, progressCallBack, useArrayBuffer, errorCallback);
        }
      } else {
        if (errorCallback) {
          errorCallback();
        }
      }
    });
  }
  _loadFileAsync(url, callback, notInDBCallback) {
    if (this._isSupported && this._db) {
      let targetStore;
      if (url.indexOf(".babylon") !== -1) {
        targetStore = "scenes";
      } else {
        targetStore = "textures";
      }
      let file;
      const transaction = this._db.transaction([targetStore]);
      transaction.oncomplete = () => {
        if (file) {
          callback(file.data);
        } else {
          notInDBCallback();
        }
      };
      transaction.onabort = () => {
        notInDBCallback();
      };
      const getRequest = transaction.objectStore(targetStore).get(url);
      getRequest.onsuccess = (event) => {
        file = event.target.result;
      };
      getRequest.onerror = () => {
        Logger.Error("Error loading file " + url + " from DB.");
        notInDBCallback();
      };
    } else {
      Logger.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open.");
      callback();
    }
  }
  _saveFileAsync(url, callback, progressCallback, useArrayBuffer, errorCallback) {
    if (this._isSupported) {
      let targetStore;
      if (url.indexOf(".babylon") !== -1) {
        targetStore = "scenes";
      } else {
        targetStore = "textures";
      }
      const xhr = new WebRequest();
      let fileData;
      xhr.open("GET", url + (url.match(/\?/) == null ? "?" : "&") + Date.now());
      if (useArrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
      if (progressCallback) {
        xhr.onprogress = progressCallback;
      }
      xhr.addEventListener("load", () => {
        if (xhr.status === 200 || xhr.status < 400 && Database._ValidateXHRData(xhr, !useArrayBuffer ? 1 : 6)) {
          fileData = !useArrayBuffer ? xhr.responseText : xhr.response;
          if (!this._hasReachedQuota && this._db) {
            const transaction = this._db.transaction([targetStore], "readwrite");
            transaction.onabort = (event) => {
              try {
                const error = event.target["error"];
                if (error && error.name === "QuotaExceededError") {
                  this._hasReachedQuota = true;
                }
              } catch (ex) {
              }
              callback(fileData);
            };
            transaction.oncomplete = () => {
              callback(fileData);
            };
            let newFile;
            if (targetStore === "scenes") {
              newFile = { sceneUrl: url, data: fileData, version: this._manifestVersionFound };
            } else {
              newFile = { textureUrl: url, data: fileData };
            }
            try {
              const addRequest = transaction.objectStore(targetStore).put(newFile);
              addRequest.onsuccess = () => {
              };
              addRequest.onerror = () => {
                Logger.Error("Error in DB add file request in BABYLON.Database.");
              };
            } catch (ex) {
              callback(fileData);
            }
          } else {
            callback(fileData);
          }
        } else {
          if (xhr.status >= 400 && errorCallback) {
            errorCallback(xhr);
          } else {
            callback();
          }
        }
      }, false);
      xhr.addEventListener("error", () => {
        Logger.Error("error on XHR request.");
        errorCallback && errorCallback();
      }, false);
      xhr.send();
    } else {
      Logger.Error("Error: IndexedDB not supported by your browser or Babylon.js database is not open.");
      errorCallback && errorCallback();
    }
  }
  static _ValidateXHRData(xhr, dataType = 7) {
    try {
      if (dataType & 1) {
        if (xhr.responseText && xhr.responseText.length > 0) {
          return true;
        } else if (dataType === 1) {
          return false;
        }
      }
      if (dataType & 2) {
        const tgaHeader = GetTGAHeader(xhr.response);
        if (tgaHeader.width && tgaHeader.height && tgaHeader.width > 0 && tgaHeader.height > 0) {
          return true;
        } else if (dataType === 2) {
          return false;
        }
      }
      if (dataType & 4) {
        const ddsHeader = new Uint8Array(xhr.response, 0, 3);
        if (ddsHeader[0] === 68 && ddsHeader[1] === 68 && ddsHeader[2] === 83) {
          return true;
        } else {
          return false;
        }
      }
    } catch (e) {
    }
    return false;
  }
};
Database._IsUASupportingBlobStorage = true;
Database.IDBStorageEnabled = false;
Database._ParseURL = (url) => {
  const a = document.createElement("a");
  a.href = url;
  const urlWithoutHash = url.substring(0, url.lastIndexOf("#"));
  const fileName = url.substring(urlWithoutHash.lastIndexOf("/") + 1, url.length);
  const absLocation = url.substring(0, url.indexOf(fileName, 0));
  return absLocation;
};
Database._ReturnFullUrlLocation = (url) => {
  if (url.indexOf("http:/") === -1 && url.indexOf("https:/") === -1 && typeof window !== "undefined") {
    return Database._ParseURL(window.location.href) + url;
  } else {
    return url;
  }
};

// node_modules/@babylonjs/core/Materials/uniformBufferEffectCommonAccessor.js
var UniformBufferEffectCommonAccessor = class {
  constructor(uboOrEffect) {
    if (this._isUbo(uboOrEffect)) {
      this.setMatrix3x3 = uboOrEffect.updateMatrix3x3.bind(uboOrEffect);
      this.setMatrix2x2 = uboOrEffect.updateMatrix2x2.bind(uboOrEffect);
      this.setFloat = uboOrEffect.updateFloat.bind(uboOrEffect);
      this.setFloat2 = uboOrEffect.updateFloat2.bind(uboOrEffect);
      this.setFloat3 = uboOrEffect.updateFloat3.bind(uboOrEffect);
      this.setFloat4 = uboOrEffect.updateFloat4.bind(uboOrEffect);
      this.setFloatArray = uboOrEffect.updateFloatArray.bind(uboOrEffect);
      this.setArray = uboOrEffect.updateArray.bind(uboOrEffect);
      this.setIntArray = uboOrEffect.updateIntArray.bind(uboOrEffect);
      this.setMatrix = uboOrEffect.updateMatrix.bind(uboOrEffect);
      this.setMatrices = uboOrEffect.updateMatrices.bind(uboOrEffect);
      this.setVector3 = uboOrEffect.updateVector3.bind(uboOrEffect);
      this.setVector4 = uboOrEffect.updateVector4.bind(uboOrEffect);
      this.setColor3 = uboOrEffect.updateColor3.bind(uboOrEffect);
      this.setColor4 = uboOrEffect.updateColor4.bind(uboOrEffect);
      this.setDirectColor4 = uboOrEffect.updateDirectColor4.bind(uboOrEffect);
      this.setInt = uboOrEffect.updateInt.bind(uboOrEffect);
      this.setInt2 = uboOrEffect.updateInt2.bind(uboOrEffect);
      this.setInt3 = uboOrEffect.updateInt3.bind(uboOrEffect);
      this.setInt4 = uboOrEffect.updateInt4.bind(uboOrEffect);
    } else {
      this.setMatrix3x3 = uboOrEffect.setMatrix3x3.bind(uboOrEffect);
      this.setMatrix2x2 = uboOrEffect.setMatrix2x2.bind(uboOrEffect);
      this.setFloat = uboOrEffect.setFloat.bind(uboOrEffect);
      this.setFloat2 = uboOrEffect.setFloat2.bind(uboOrEffect);
      this.setFloat3 = uboOrEffect.setFloat3.bind(uboOrEffect);
      this.setFloat4 = uboOrEffect.setFloat4.bind(uboOrEffect);
      this.setFloatArray = uboOrEffect.setFloatArray.bind(uboOrEffect);
      this.setArray = uboOrEffect.setArray.bind(uboOrEffect);
      this.setIntArray = uboOrEffect.setIntArray.bind(uboOrEffect);
      this.setMatrix = uboOrEffect.setMatrix.bind(uboOrEffect);
      this.setMatrices = uboOrEffect.setMatrices.bind(uboOrEffect);
      this.setVector3 = uboOrEffect.setVector3.bind(uboOrEffect);
      this.setVector4 = uboOrEffect.setVector4.bind(uboOrEffect);
      this.setColor3 = uboOrEffect.setColor3.bind(uboOrEffect);
      this.setColor4 = uboOrEffect.setColor4.bind(uboOrEffect);
      this.setDirectColor4 = uboOrEffect.setDirectColor4.bind(uboOrEffect);
      this.setInt = uboOrEffect.setInt.bind(uboOrEffect);
      this.setInt2 = uboOrEffect.setInt2.bind(uboOrEffect);
      this.setInt3 = uboOrEffect.setInt3.bind(uboOrEffect);
      this.setInt4 = uboOrEffect.setInt4.bind(uboOrEffect);
    }
  }
  _isUbo(uboOrEffect) {
    return uboOrEffect.addUniform !== void 0;
  }
};

// node_modules/@babylonjs/core/Shaders/gpuUpdateParticles.fragment.js
var name65 = "gpuUpdateParticlesPixelShader";
var shader65 = `#version 300 es
void main() {
discard;
}
`;
ShaderStore.ShadersStore[name65] = shader65;

// node_modules/@babylonjs/core/Shaders/gpuUpdateParticles.vertex.js
var name66 = "gpuUpdateParticlesVertexShader";
var shader66 = `#version 300 es
#define PI 3.14159
uniform float currentCount;
uniform float timeDelta;
uniform float stopFactor;
#ifndef LOCAL
uniform mat4 emitterWM;
#endif
uniform vec2 lifeTime;
uniform vec2 emitPower;
uniform vec2 sizeRange;
uniform vec4 scaleRange;
#ifndef COLORGRADIENTS
uniform vec4 color1;
uniform vec4 color2;
#endif
uniform vec3 gravity;
uniform sampler2D randomSampler;
uniform sampler2D randomSampler2;
uniform vec4 angleRange;
#ifdef BOXEMITTER
uniform vec3 direction1;
uniform vec3 direction2;
uniform vec3 minEmitBox;
uniform vec3 maxEmitBox;
#endif
#ifdef POINTEMITTER
uniform vec3 direction1;
uniform vec3 direction2;
#endif
#ifdef HEMISPHERICEMITTER
uniform float radius;
uniform float radiusRange;
uniform float directionRandomizer;
#endif
#ifdef SPHEREEMITTER
uniform float radius;
uniform float radiusRange;
#ifdef DIRECTEDSPHEREEMITTER
uniform vec3 direction1;
uniform vec3 direction2;
#else
uniform float directionRandomizer;
#endif
#endif
#ifdef CYLINDEREMITTER
uniform float radius;
uniform float height;
uniform float radiusRange;
#ifdef DIRECTEDCYLINDEREMITTER
uniform vec3 direction1;
uniform vec3 direction2;
#else
uniform float directionRandomizer;
#endif
#endif
#ifdef CONEEMITTER
uniform vec2 radius;
uniform float coneAngle;
uniform vec2 height;
uniform float directionRandomizer;
#endif
in vec3 position;
#ifdef CUSTOMEMITTER
in vec3 initialPosition;
#endif
in float age;
in float life;
in vec4 seed;
in vec3 size;
#ifndef COLORGRADIENTS
in vec4 color;
#endif
in vec3 direction;
#ifndef BILLBOARD
in vec3 initialDirection;
#endif
#ifdef ANGULARSPEEDGRADIENTS
in float angle;
#else
in vec2 angle;
#endif
#ifdef ANIMATESHEET
in float cellIndex;
#ifdef ANIMATESHEETRANDOMSTART
in float cellStartOffset;
#endif
#endif
#ifdef NOISE
in vec3 noiseCoordinates1;
in vec3 noiseCoordinates2;
#endif
out vec3 outPosition;
#ifdef CUSTOMEMITTER
out vec3 outInitialPosition;
#endif
out float outAge;
out float outLife;
out vec4 outSeed;
out vec3 outSize;
#ifndef COLORGRADIENTS
out vec4 outColor;
#endif
out vec3 outDirection;
#ifndef BILLBOARD
out vec3 outInitialDirection;
#endif
#ifdef ANGULARSPEEDGRADIENTS
out float outAngle;
#else
out vec2 outAngle;
#endif
#ifdef ANIMATESHEET
out float outCellIndex;
#ifdef ANIMATESHEETRANDOMSTART
out float outCellStartOffset;
#endif
#endif
#ifdef NOISE
out vec3 outNoiseCoordinates1;
out vec3 outNoiseCoordinates2;
#endif
#ifdef SIZEGRADIENTS
uniform sampler2D sizeGradientSampler;
#endif 
#ifdef ANGULARSPEEDGRADIENTS
uniform sampler2D angularSpeedGradientSampler;
#endif 
#ifdef VELOCITYGRADIENTS
uniform sampler2D velocityGradientSampler;
#endif
#ifdef LIMITVELOCITYGRADIENTS
uniform sampler2D limitVelocityGradientSampler;
uniform float limitVelocityDamping;
#endif
#ifdef DRAGGRADIENTS
uniform sampler2D dragGradientSampler;
#endif
#ifdef NOISE
uniform vec3 noiseStrength;
uniform sampler2D noiseSampler;
#endif
#ifdef ANIMATESHEET
uniform vec4 cellInfos;
#endif
vec3 getRandomVec3(float offset) {
return texture(randomSampler2,vec2(float(gl_VertexID)*offset/currentCount,0)).rgb;
}
vec4 getRandomVec4(float offset) {
return texture(randomSampler,vec2(float(gl_VertexID)*offset/currentCount,0));
}
void main() {
float newAge=age+timeDelta; 
if (newAge>=life && stopFactor != 0.) {
vec3 newPosition;
vec3 newDirection;
vec4 randoms=getRandomVec4(seed.x);
outLife=lifeTime.x+(lifeTime.y-lifeTime.x)*randoms.r;
outAge=newAge-life;
outSeed=seed;
#ifdef SIZEGRADIENTS 
outSize.x=texture(sizeGradientSampler,vec2(0,0)).r;
#else
outSize.x=sizeRange.x+(sizeRange.y-sizeRange.x)*randoms.g;
#endif
outSize.y=scaleRange.x+(scaleRange.y-scaleRange.x)*randoms.b;
outSize.z=scaleRange.z+(scaleRange.w-scaleRange.z)*randoms.a; 
#ifndef COLORGRADIENTS
outColor=color1+(color2-color1)*randoms.b;
#endif
#ifndef ANGULARSPEEDGRADIENTS 
outAngle.y=angleRange.x+(angleRange.y-angleRange.x)*randoms.a;
outAngle.x=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;
#else
outAngle=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;
#endif 
#ifdef POINTEMITTER
vec3 randoms2=getRandomVec3(seed.y);
vec3 randoms3=getRandomVec3(seed.z);
newPosition=vec3(0,0,0);
newDirection=direction1+(direction2-direction1)*randoms3;
#elif defined(BOXEMITTER)
vec3 randoms2=getRandomVec3(seed.y);
vec3 randoms3=getRandomVec3(seed.z);
newPosition=minEmitBox+(maxEmitBox-minEmitBox)*randoms2;
newDirection=direction1+(direction2-direction1)*randoms3; 
#elif defined(HEMISPHERICEMITTER)
vec3 randoms2=getRandomVec3(seed.y);
vec3 randoms3=getRandomVec3(seed.z);
float phi=2.0*PI*randoms2.x;
float theta=acos(2.0*randoms2.y-1.0);
float randX=cos(phi)*sin(theta);
float randY=cos(theta);
float randZ=sin(phi)*sin(theta);
newPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,abs(randY),randZ);
newDirection=newPosition+directionRandomizer*randoms3; 
#elif defined(SPHEREEMITTER)
vec3 randoms2=getRandomVec3(seed.y);
vec3 randoms3=getRandomVec3(seed.z);
float phi=2.0*PI*randoms2.x;
float theta=acos(2.0*randoms2.y-1.0);
float randX=cos(phi)*sin(theta);
float randY=cos(theta);
float randZ=sin(phi)*sin(theta);
newPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,randY,randZ);
#ifdef DIRECTEDSPHEREEMITTER
newDirection=normalize(direction1+(direction2-direction1)*randoms3);
#else
newDirection=normalize(newPosition+directionRandomizer*randoms3);
#endif
#elif defined(CYLINDEREMITTER)
vec3 randoms2=getRandomVec3(seed.y);
vec3 randoms3=getRandomVec3(seed.z);
float yPos=(randoms2.x-0.5)*height;
float angle=randoms2.y*PI*2.;
float inverseRadiusRangeSquared=((1.-radiusRange)*(1.-radiusRange));
float positionRadius=radius*sqrt(inverseRadiusRangeSquared+(randoms2.z*(1.-inverseRadiusRangeSquared)));
float xPos=positionRadius*cos(angle);
float zPos=positionRadius*sin(angle);
newPosition=vec3(xPos,yPos,zPos);
#ifdef DIRECTEDCYLINDEREMITTER
newDirection=direction1+(direction2-direction1)*randoms3;
#else
angle=angle+((randoms3.x-0.5)*PI)*directionRandomizer;
newDirection=vec3(cos(angle),(randoms3.y-0.5)*directionRandomizer,sin(angle));
newDirection=normalize(newDirection);
#endif
#elif defined(CONEEMITTER)
vec3 randoms2=getRandomVec3(seed.y);
float s=2.0*PI*randoms2.x;
#ifdef CONEEMITTERSPAWNPOINT
float h=0.0001;
#else
float h=randoms2.y*height.y;
h=1.-h*h; 
#endif
float lRadius=radius.x-radius.x*randoms2.z*radius.y;
lRadius=lRadius*h;
float randX=lRadius*sin(s);
float randZ=lRadius*cos(s);
float randY=h *height.x;
newPosition=vec3(randX,randY,randZ); 
if (abs(cos(coneAngle))==1.0) {
newDirection=vec3(0.,1.0,0.);
} else {
vec3 randoms3=getRandomVec3(seed.z);
newDirection=normalize(newPosition+directionRandomizer*randoms3); 
}
#elif defined(CUSTOMEMITTER)
newPosition=initialPosition;
outInitialPosition=initialPosition;
#else 
newPosition=vec3(0.,0.,0.);
newDirection=2.0*(getRandomVec3(seed.w)-vec3(0.5,0.5,0.5));
#endif
float power=emitPower.x+(emitPower.y-emitPower.x)*randoms.a;
#ifdef LOCAL
outPosition=newPosition;
#else
outPosition=(emitterWM*vec4(newPosition,1.)).xyz;
#endif
#ifdef CUSTOMEMITTER
outDirection=direction;
#ifndef BILLBOARD 
outInitialDirection=direction;
#endif
#else
#ifdef LOCAL
vec3 initial=newDirection;
#else 
vec3 initial=(emitterWM*vec4(newDirection,0.)).xyz;
#endif
outDirection=initial*power;
#ifndef BILLBOARD 
outInitialDirection=initial;
#endif
#endif
#ifdef ANIMATESHEET 
outCellIndex=cellInfos.x;
#ifdef ANIMATESHEETRANDOMSTART
outCellStartOffset=randoms.a*outLife;
#endif 
#endif
#ifdef NOISE
outNoiseCoordinates1=noiseCoordinates1;
outNoiseCoordinates2=noiseCoordinates2;
#endif
} else {
float directionScale=timeDelta;
outAge=newAge;
float ageGradient=newAge/life;
#ifdef VELOCITYGRADIENTS
directionScale*=texture(velocityGradientSampler,vec2(ageGradient,0)).r;
#endif
#ifdef DRAGGRADIENTS
directionScale*=1.0-texture(dragGradientSampler,vec2(ageGradient,0)).r;
#endif
#if defined(CUSTOMEMITTER)
outPosition=position+(direction-position)*ageGradient; 
outInitialPosition=initialPosition;
#else
outPosition=position+direction*directionScale;
#endif
outLife=life;
outSeed=seed;
#ifndef COLORGRADIENTS 
outColor=color;
#endif
#ifdef SIZEGRADIENTS
outSize.x=texture(sizeGradientSampler,vec2(ageGradient,0)).r;
outSize.yz=size.yz;
#else
outSize=size;
#endif 
#ifndef BILLBOARD 
outInitialDirection=initialDirection;
#endif
#ifdef CUSTOMEMITTER
outDirection=direction;
#else
vec3 updatedDirection=direction+gravity*timeDelta;
#ifdef LIMITVELOCITYGRADIENTS
float limitVelocity=texture(limitVelocityGradientSampler,vec2(ageGradient,0)).r;
float currentVelocity=length(updatedDirection);
if (currentVelocity>limitVelocity) {
updatedDirection=updatedDirection*limitVelocityDamping;
}
#endif
outDirection=updatedDirection;
#ifdef NOISE
float fetchedR=texture(noiseSampler,vec2(noiseCoordinates1.x,noiseCoordinates1.y)*vec2(0.5)+vec2(0.5)).r;
float fetchedG=texture(noiseSampler,vec2(noiseCoordinates1.z,noiseCoordinates2.x)*vec2(0.5)+vec2(0.5)).r;
float fetchedB=texture(noiseSampler,vec2(noiseCoordinates2.y,noiseCoordinates2.z)*vec2(0.5)+vec2(0.5)).r;
vec3 force=vec3(2.*fetchedR-1.,2.*fetchedG-1.,2.*fetchedB-1.)*noiseStrength;
outDirection=outDirection+force*timeDelta;
outNoiseCoordinates1=noiseCoordinates1;
outNoiseCoordinates2=noiseCoordinates2;
#endif 
#endif 
#ifdef ANGULARSPEEDGRADIENTS
float angularSpeed=texture(angularSpeedGradientSampler,vec2(ageGradient,0)).r;
outAngle=angle+angularSpeed*timeDelta;
#else
outAngle=vec2(angle.x+angle.y*timeDelta,angle.y);
#endif
#ifdef ANIMATESHEET 
float offsetAge=outAge;
float dist=cellInfos.y-cellInfos.x;
#ifdef ANIMATESHEETRANDOMSTART
outCellStartOffset=cellStartOffset;
offsetAge+=cellStartOffset;
#else
float cellStartOffset=0.;
#endif 
float ratio=0.;
if (cellInfos.w==1.0) {
ratio=clamp(mod(cellStartOffset+cellInfos.z*offsetAge,life)/life,0.,1.0);
}
else {
ratio=clamp(cellStartOffset+cellInfos.z*offsetAge/life,0.,1.0);
}
outCellIndex=float(int(cellInfos.x+ratio*dist));
#endif
}
}`;
ShaderStore.ShadersStore[name66] = shader66;

// node_modules/@babylonjs/core/Particles/webgl2ParticleSystem.js
var WebGL2ParticleSystem = class {
  constructor(parent, engine) {
    this._renderVAO = [];
    this._updateVAO = [];
    this.alignDataInBuffer = false;
    this._parent = parent;
    this._engine = engine;
    this._updateEffectOptions = {
      attributes: [
        "position",
        "initialPosition",
        "age",
        "life",
        "seed",
        "size",
        "color",
        "direction",
        "initialDirection",
        "angle",
        "cellIndex",
        "cellStartOffset",
        "noiseCoordinates1",
        "noiseCoordinates2"
      ],
      uniformsNames: [
        "currentCount",
        "timeDelta",
        "emitterWM",
        "lifeTime",
        "color1",
        "color2",
        "sizeRange",
        "scaleRange",
        "gravity",
        "emitPower",
        "direction1",
        "direction2",
        "minEmitBox",
        "maxEmitBox",
        "radius",
        "directionRandomizer",
        "height",
        "coneAngle",
        "stopFactor",
        "angleRange",
        "radiusRange",
        "cellInfos",
        "noiseStrength",
        "limitVelocityDamping"
      ],
      uniformBuffersNames: [],
      samplers: [
        "randomSampler",
        "randomSampler2",
        "sizeGradientSampler",
        "angularSpeedGradientSampler",
        "velocityGradientSampler",
        "limitVelocityGradientSampler",
        "noiseSampler",
        "dragGradientSampler"
      ],
      defines: "",
      fallbacks: null,
      onCompiled: null,
      onError: null,
      indexParameters: null,
      maxSimultaneousLights: 0,
      transformFeedbackVaryings: []
    };
  }
  isUpdateBufferCreated() {
    return !!this._updateEffect;
  }
  isUpdateBufferReady() {
    var _a, _b;
    return (_b = (_a = this._updateEffect) === null || _a === void 0 ? void 0 : _a.isReady()) !== null && _b !== void 0 ? _b : false;
  }
  createUpdateBuffer(defines) {
    this._updateEffectOptions.transformFeedbackVaryings = ["outPosition"];
    this._updateEffectOptions.transformFeedbackVaryings.push("outAge");
    this._updateEffectOptions.transformFeedbackVaryings.push("outSize");
    this._updateEffectOptions.transformFeedbackVaryings.push("outLife");
    this._updateEffectOptions.transformFeedbackVaryings.push("outSeed");
    this._updateEffectOptions.transformFeedbackVaryings.push("outDirection");
    if (this._parent.particleEmitterType instanceof CustomParticleEmitter) {
      this._updateEffectOptions.transformFeedbackVaryings.push("outInitialPosition");
    }
    if (!this._parent._colorGradientsTexture) {
      this._updateEffectOptions.transformFeedbackVaryings.push("outColor");
    }
    if (!this._parent._isBillboardBased) {
      this._updateEffectOptions.transformFeedbackVaryings.push("outInitialDirection");
    }
    if (this._parent.noiseTexture) {
      this._updateEffectOptions.transformFeedbackVaryings.push("outNoiseCoordinates1");
      this._updateEffectOptions.transformFeedbackVaryings.push("outNoiseCoordinates2");
    }
    this._updateEffectOptions.transformFeedbackVaryings.push("outAngle");
    if (this._parent.isAnimationSheetEnabled) {
      this._updateEffectOptions.transformFeedbackVaryings.push("outCellIndex");
      if (this._parent.spriteRandomStartCell) {
        this._updateEffectOptions.transformFeedbackVaryings.push("outCellStartOffset");
      }
    }
    this._updateEffectOptions.defines = defines;
    this._updateEffect = new Effect("gpuUpdateParticles", this._updateEffectOptions, this._engine);
    return new UniformBufferEffectCommonAccessor(this._updateEffect);
  }
  createVertexBuffers(updateBuffer, renderVertexBuffers) {
    this._updateVAO.push(this._createUpdateVAO(updateBuffer));
    this._renderVAO.push(this._engine.recordVertexArrayObject(renderVertexBuffers, null, this._parent._getWrapper(this._parent.blendMode).effect));
    this._engine.bindArrayBuffer(null);
  }
  createParticleBuffer(data) {
    return data;
  }
  bindDrawBuffers(index) {
    this._engine.bindVertexArrayObject(this._renderVAO[index], null);
  }
  preUpdateParticleBuffer() {
    const engine = this._engine;
    this._engine.enableEffect(this._updateEffect);
    if (!engine.setState) {
      throw new Error("GPU particles cannot work without a full Engine. ThinEngine is not supported");
    }
  }
  updateParticleBuffer(index, targetBuffer, currentActiveCount) {
    this._updateEffect.setTexture("randomSampler", this._parent._randomTexture);
    this._updateEffect.setTexture("randomSampler2", this._parent._randomTexture2);
    if (this._parent._sizeGradientsTexture) {
      this._updateEffect.setTexture("sizeGradientSampler", this._parent._sizeGradientsTexture);
    }
    if (this._parent._angularSpeedGradientsTexture) {
      this._updateEffect.setTexture("angularSpeedGradientSampler", this._parent._angularSpeedGradientsTexture);
    }
    if (this._parent._velocityGradientsTexture) {
      this._updateEffect.setTexture("velocityGradientSampler", this._parent._velocityGradientsTexture);
    }
    if (this._parent._limitVelocityGradientsTexture) {
      this._updateEffect.setTexture("limitVelocityGradientSampler", this._parent._limitVelocityGradientsTexture);
    }
    if (this._parent._dragGradientsTexture) {
      this._updateEffect.setTexture("dragGradientSampler", this._parent._dragGradientsTexture);
    }
    if (this._parent.noiseTexture) {
      this._updateEffect.setTexture("noiseSampler", this._parent.noiseTexture);
    }
    this._engine.bindVertexArrayObject(this._updateVAO[index], null);
    const engine = this._engine;
    engine.bindTransformFeedbackBuffer(targetBuffer.getBuffer());
    engine.setRasterizerState(false);
    engine.beginTransformFeedback(true);
    engine.drawArraysType(3, 0, currentActiveCount);
    engine.endTransformFeedback();
    engine.setRasterizerState(true);
    engine.bindTransformFeedbackBuffer(null);
  }
  releaseBuffers() {
  }
  releaseVertexBuffers() {
    for (let index = 0; index < this._updateVAO.length; index++) {
      this._engine.releaseVertexArrayObject(this._updateVAO[index]);
    }
    this._updateVAO.length = 0;
    for (let index = 0; index < this._renderVAO.length; index++) {
      this._engine.releaseVertexArrayObject(this._renderVAO[index]);
    }
    this._renderVAO.length = 0;
  }
  _createUpdateVAO(source) {
    const updateVertexBuffers = {};
    updateVertexBuffers["position"] = source.createVertexBuffer("position", 0, 3);
    let offset = 3;
    updateVertexBuffers["age"] = source.createVertexBuffer("age", offset, 1);
    offset += 1;
    updateVertexBuffers["size"] = source.createVertexBuffer("size", offset, 3);
    offset += 3;
    updateVertexBuffers["life"] = source.createVertexBuffer("life", offset, 1);
    offset += 1;
    updateVertexBuffers["seed"] = source.createVertexBuffer("seed", offset, 4);
    offset += 4;
    updateVertexBuffers["direction"] = source.createVertexBuffer("direction", offset, 3);
    offset += 3;
    if (this._parent.particleEmitterType instanceof CustomParticleEmitter) {
      updateVertexBuffers["initialPosition"] = source.createVertexBuffer("initialPosition", offset, 3);
      offset += 3;
    }
    if (!this._parent._colorGradientsTexture) {
      updateVertexBuffers["color"] = source.createVertexBuffer("color", offset, 4);
      offset += 4;
    }
    if (!this._parent._isBillboardBased) {
      updateVertexBuffers["initialDirection"] = source.createVertexBuffer("initialDirection", offset, 3);
      offset += 3;
    }
    if (this._parent.noiseTexture) {
      updateVertexBuffers["noiseCoordinates1"] = source.createVertexBuffer("noiseCoordinates1", offset, 3);
      offset += 3;
      updateVertexBuffers["noiseCoordinates2"] = source.createVertexBuffer("noiseCoordinates2", offset, 3);
      offset += 3;
    }
    if (this._parent._angularSpeedGradientsTexture) {
      updateVertexBuffers["angle"] = source.createVertexBuffer("angle", offset, 1);
      offset += 1;
    } else {
      updateVertexBuffers["angle"] = source.createVertexBuffer("angle", offset, 2);
      offset += 2;
    }
    if (this._parent._isAnimationSheetEnabled) {
      updateVertexBuffers["cellIndex"] = source.createVertexBuffer("cellIndex", offset, 1);
      offset += 1;
      if (this._parent.spriteRandomStartCell) {
        updateVertexBuffers["cellStartOffset"] = source.createVertexBuffer("cellStartOffset", offset, 1);
        offset += 1;
      }
    }
    const vao = this._engine.recordVertexArrayObject(updateVertexBuffers, null, this._updateEffect);
    this._engine.bindArrayBuffer(null);
    return vao;
  }
};
RegisterClass("BABYLON.WebGL2ParticleSystem", WebGL2ParticleSystem);

// node_modules/@babylonjs/core/ShadersWGSL/gpuUpdateParticles.compute.js
var name67 = "gpuUpdateParticlesComputeShader";
var shader67 = `struct Particle {
position : vec3<f32>,
age : f32,
size : vec3<f32>,
life : f32,
seed : vec4<f32>,
direction : vec3<f32>,
dummy0: f32,
#ifdef CUSTOMEMITTER
initialPosition : vec3<f32>,
dummy1: f32,
#endif
#ifndef COLORGRADIENTS
color : vec4<f32>,
#endif
#ifndef BILLBOARD
initialDirection : vec3<f32>,
dummy2: f32,
#endif
#ifdef NOISE
noiseCoordinates1 : vec3<f32>,
dummy3: f32,
noiseCoordinates2 : vec3<f32>,
dummy4: f32,
#endif
#ifdef ANGULARSPEEDGRADIENTS
angle : f32,
#else
angle : vec2<f32>,
#endif
#ifdef ANIMATESHEET
cellIndex : f32,
#ifdef ANIMATESHEETRANDOMSTART
cellStartOffset : f32,
#endif
#endif
};
struct Particles {
particles : array<Particle>,
};
struct SimParams {
currentCount : f32,
timeDelta : f32,
stopFactor : f32,
randomTextureSize: i32,
lifeTime : vec2<f32>,
emitPower : vec2<f32>,
#ifndef COLORGRADIENTS
color1 : vec4<f32>,
color2 : vec4<f32>,
#endif
sizeRange : vec2<f32>,
scaleRange : vec4<f32>,
angleRange : vec4<f32>,
gravity : vec3<f32>,
#ifdef LIMITVELOCITYGRADIENTS
limitVelocityDamping : f32,
#endif
#ifdef ANIMATESHEET
cellInfos : vec4<f32>,
#endif
#ifdef NOISE
noiseStrength : vec3<f32>,
#endif
#ifndef LOCAL
emitterWM : mat4x4<f32>,
#endif
#ifdef BOXEMITTER
direction1 : vec3<f32>,
direction2 : vec3<f32>,
minEmitBox : vec3<f32>,
maxEmitBox : vec3<f32>,
#endif
#ifdef CONEEMITTER
radius : vec2<f32>,
coneAngle : f32,
height : vec2<f32>,
directionRandomizer : f32,
#endif
#ifdef CYLINDEREMITTER
radius : f32,
height : f32,
radiusRange : f32,
#ifdef DIRECTEDCYLINDEREMITTER
direction1 : vec3<f32>,
direction2 : vec3<f32>,
#else
directionRandomizer : f32,
#endif
#endif
#ifdef HEMISPHERICEMITTER
radius : f32,
radiusRange : f32,
directionRandomizer : f32,
#endif
#ifdef POINTEMITTER
direction1 : vec3<f32>,
direction2 : vec3<f32>,
#endif
#ifdef SPHEREEMITTER
radius : f32,
radiusRange : f32,
#ifdef DIRECTEDSPHEREEMITTER
direction1 : vec3<f32>,
direction2 : vec3<f32>,
#else
directionRandomizer : f32,
#endif
#endif
};
@binding(0) @group(0) var<uniform> params : SimParams;
@binding(1) @group(0) var<storage,read> particlesIn : Particles;
@binding(2) @group(0) var<storage,read_write> particlesOut : Particles;
@binding(3) @group(0) var randomTexture : texture_2d<f32>;
@binding(4) @group(0) var randomTexture2 : texture_2d<f32>;
#ifdef SIZEGRADIENTS
@binding(0) @group(1) var sizeGradientSampler : sampler;
@binding(1) @group(1) var sizeGradientTexture : texture_2d<f32>;
#endif 
#ifdef ANGULARSPEEDGRADIENTS
@binding(2) @group(1) var angularSpeedGradientSampler : sampler;
@binding(3) @group(1) var angularSpeedGradientTexture : texture_2d<f32>;
#endif 
#ifdef VELOCITYGRADIENTS
@binding(4) @group(1) var velocityGradientSampler : sampler;
@binding(5) @group(1) var velocityGradientTexture : texture_2d<f32>;
#endif
#ifdef LIMITVELOCITYGRADIENTS
@binding(6) @group(1) var limitVelocityGradientSampler : sampler;
@binding(7) @group(1) var limitVelocityGradientTexture : texture_2d<f32>;
#endif
#ifdef DRAGGRADIENTS
@binding(8) @group(1) var dragGradientSampler : sampler;
@binding(9) @group(1) var dragGradientTexture : texture_2d<f32>;
#endif
#ifdef NOISE
@binding(10) @group(1) var noiseSampler : sampler;
@binding(11) @group(1) var noiseTexture : texture_2d<f32>;
#endif
fn getRandomVec3(offset : f32,vertexID : f32)->vec3<f32> {
return textureLoad(randomTexture2,vec2<i32>(i32(vertexID*offset/params.currentCount*f32(params.randomTextureSize)) % params.randomTextureSize,0),0).rgb;
}
fn getRandomVec4(offset : f32,vertexID : f32)->vec4<f32> {
return textureLoad(randomTexture,vec2<i32>(i32(vertexID*offset/params.currentCount*f32(params.randomTextureSize)) % params.randomTextureSize,0),0);
}
@stage(compute) @workgroup_size(64)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
let index : u32=GlobalInvocationID.x;
let vertexID : f32=f32(index);
if (index>=u32(params.currentCount)) {
return;
}
let PI : f32=3.14159;
let timeDelta : f32=params.timeDelta;
let newAge : f32=particlesIn.particles[index].age+timeDelta;
let life : f32=particlesIn.particles[index].life;
let seed : vec4<f32>=particlesIn.particles[index].seed;
let direction : vec3<f32>=particlesIn.particles[index].direction;
if (newAge>=life && params.stopFactor != 0.) {
var newPosition : vec3<f32>;
var newDirection : vec3<f32>;
let randoms : vec4<f32>=getRandomVec4(seed.x,vertexID);
let outLife : f32=params.lifeTime.x+(params.lifeTime.y-params.lifeTime.x)*randoms.r;
particlesOut.particles[index].life=outLife;
particlesOut.particles[index].age=newAge-life;
particlesOut.particles[index].seed=seed;
var sizex : f32;
#ifdef SIZEGRADIENTS 
sizex=textureSampleLevel(sizeGradientTexture,sizeGradientSampler,vec2<f32>(0.,0.),0.).r;
#else
sizex=params.sizeRange.x+(params.sizeRange.y-params.sizeRange.x)*randoms.g;
#endif
particlesOut.particles[index].size=vec3<f32>(
sizex,
params.scaleRange.x+(params.scaleRange.y-params.scaleRange.x)*randoms.b,
params.scaleRange.z+(params.scaleRange.w-params.scaleRange.z)*randoms.a);
#ifndef COLORGRADIENTS
particlesOut.particles[index].color=params.color1+(params.color2-params.color1)*randoms.b;
#endif
#ifndef ANGULARSPEEDGRADIENTS 
particlesOut.particles[index].angle=vec2<f32>(
params.angleRange.z+(params.angleRange.w-params.angleRange.z)*randoms.r,
params.angleRange.x+(params.angleRange.y-params.angleRange.x)*randoms.a);
#else
particlesOut.particles[index].angle=params.angleRange.z+(params.angleRange.w-params.angleRange.z)*randoms.r;
#endif 
#if defined(POINTEMITTER)
let randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);
let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);
newPosition=vec3<f32>(0.,0.,0.);
newDirection=params.direction1+(params.direction2-params.direction1)*randoms3;
#elif defined(BOXEMITTER)
let randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);
let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);
newPosition=params.minEmitBox+(params.maxEmitBox-params.minEmitBox)*randoms2;
newDirection=params.direction1+(params.direction2-params.direction1)*randoms3; 
#elif defined(HEMISPHERICEMITTER)
let randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);
let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);
let phi : f32=2.0*PI*randoms2.x;
let theta : f32=acos(-1.0+2.0*randoms2.y);
let randX : f32=cos(phi)*sin(theta);
let randY : f32=cos(theta);
let randZ : f32=sin(phi)*sin(theta);
newPosition=(params.radius-(params.radius*params.radiusRange*randoms2.z))*vec3<f32>(randX,abs(randY),randZ);
newDirection=normalize(newPosition+params.directionRandomizer*randoms3);
#elif defined(SPHEREEMITTER)
let randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);
let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);
let phi : f32=2.0*PI*randoms2.x;
let theta : f32=acos(-1.0+2.0*randoms2.y);
let randX : f32=cos(phi)*sin(theta);
let randY : f32=cos(theta);
let randZ : f32=sin(phi)*sin(theta);
newPosition=(params.radius-(params.radius*params.radiusRange*randoms2.z))*vec3<f32>(randX,randY,randZ);
#ifdef DIRECTEDSPHEREEMITTER
newDirection=normalize(params.direction1+(params.direction2-params.direction1)*randoms3);
#else
newDirection=normalize(newPosition+params.directionRandomizer*randoms3);
#endif
#elif defined(CYLINDEREMITTER)
let randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);
let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);
let yPos : f32=(-0.5+randoms2.x)*params.height;
var angle : f32=randoms2.y*PI*2.;
let inverseRadiusRangeSquared : f32=(1.-params.radiusRange)*(1.-params.radiusRange);
let positionRadius : f32=params.radius*sqrt(inverseRadiusRangeSquared+randoms2.z*(1.-inverseRadiusRangeSquared));
let xPos : f32=positionRadius*cos(angle);
let zPos : f32=positionRadius*sin(angle);
newPosition=vec3<f32>(xPos,yPos,zPos);
#ifdef DIRECTEDCYLINDEREMITTER
newDirection=params.direction1+(params.direction2-params.direction1)*randoms3;
#else
angle=angle+(-0.5+randoms3.x)*PI*params.directionRandomizer;
newDirection=vec3<f32>(cos(angle),(-0.5+randoms3.y)*params.directionRandomizer,sin(angle));
newDirection=normalize(newDirection);
#endif
#elif defined(CONEEMITTER)
let randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);
let s : f32=2.0*PI*randoms2.x;
#ifdef CONEEMITTERSPAWNPOINT
let h : f32=0.0001;
#else
var h : f32=randoms2.y*params.height.y;
h=1.-h*h; 
#endif
var lRadius : f32=params.radius.x-params.radius.x*randoms2.z*params.radius.y;
lRadius=lRadius*h;
let randX : f32=lRadius*sin(s);
let randZ : f32=lRadius*cos(s);
let randY : f32=h *params.height.x;
newPosition=vec3<f32>(randX,randY,randZ); 
if (abs(cos(params.coneAngle))==1.0) {
newDirection=vec3<f32>(0.,1.0,0.);
} else {
let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);
newDirection=normalize(newPosition+params.directionRandomizer*randoms3); 
}
#elif defined(CUSTOMEMITTER)
newPosition=particlesIn.particles[index].initialPosition;
particlesOut.particles[index].initialPosition=newPosition;
#else 
newPosition=vec3<f32>(0.,0.,0.);
newDirection=2.0*(getRandomVec3(seed.w,vertexID)-vec3<f32>(0.5,0.5,0.5));
#endif
let power : f32=params.emitPower.x+(params.emitPower.y-params.emitPower.x)*randoms.a;
#ifdef LOCAL
particlesOut.particles[index].position=newPosition;
#else
particlesOut.particles[index].position=(params.emitterWM*vec4<f32>(newPosition,1.)).xyz;
#endif
#ifdef CUSTOMEMITTER
particlesOut.particles[index].direction=direction;
#ifndef BILLBOARD 
particlesOut.particles[index].initialDirection=direction;
#endif
#else
#ifdef LOCAL
let initial : vec3<f32>=newDirection;
#else 
let initial : vec3<f32>=(params.emitterWM*vec4<f32>(newDirection,0.)).xyz;
#endif
particlesOut.particles[index].direction=initial*power;
#ifndef BILLBOARD 
particlesOut.particles[index].initialDirection=initial;
#endif
#endif
#ifdef ANIMATESHEET 
particlesOut.particles[index].cellIndex=params.cellInfos.x;
#ifdef ANIMATESHEETRANDOMSTART
particlesOut.particles[index].cellStartOffset=randoms.a*outLife;
#endif 
#endif
#ifdef NOISE
particlesOut.particles[index].noiseCoordinates1=particlesIn.particles[index].noiseCoordinates1;
particlesOut.particles[index].noiseCoordinates2=particlesIn.particles[index].noiseCoordinates2;
#endif
} else {
var directionScale : f32=timeDelta;
particlesOut.particles[index].age=newAge;
let ageGradient : f32=newAge/life;
#ifdef VELOCITYGRADIENTS
directionScale=directionScale*textureSampleLevel(velocityGradientTexture,velocityGradientSampler,vec2<f32>(ageGradient,0.),0.).r;
#endif
#ifdef DRAGGRADIENTS
directionScale=directionScale*(1.0-textureSampleLevel(dragGradientTexture,dragGradientSampler,vec2<f32>(ageGradient,0.),0.).r);
#endif
let position : vec3<f32>=particlesIn.particles[index].position;
#if defined(CUSTOMEMITTER)
particlesOut.particles[index].position=position+(direction-position)*ageGradient; 
particlesOut.particles[index].initialPosition=particlesIn.particles[index].initialPosition;
#else
particlesOut.particles[index].position=position+direction*directionScale;
#endif
particlesOut.particles[index].life=life;
particlesOut.particles[index].seed=seed;
#ifndef COLORGRADIENTS 
particlesOut.particles[index].color=particlesIn.particles[index].color;
#endif
#ifdef SIZEGRADIENTS
particlesOut.particles[index].size=vec3<f32>(
textureSampleLevel(sizeGradientTexture,sizeGradientSampler,vec2<f32>(ageGradient,0.),0.).r,
particlesIn.particles[index].size.yz);
#else
particlesOut.particles[index].size=particlesIn.particles[index].size;
#endif 
#ifndef BILLBOARD 
particlesOut.particles[index].initialDirection=particlesIn.particles[index].initialDirection;
#endif
#ifdef CUSTOMEMITTER
particlesOut.particles[index].direction=direction;
#else
var updatedDirection : vec3<f32>=direction+params.gravity*timeDelta;
#ifdef LIMITVELOCITYGRADIENTS
let limitVelocity : f32=textureSampleLevel(limitVelocityGradientTexture,limitVelocityGradientSampler,vec2<f32>(ageGradient,0.),0.).r;
let currentVelocity : f32=length(updatedDirection);
if (currentVelocity>limitVelocity) {
updatedDirection=updatedDirection*params.limitVelocityDamping;
}
#endif
particlesOut.particles[index].direction=updatedDirection;
#ifdef NOISE
let noiseCoordinates1 : vec3<f32>=particlesIn.particles[index].noiseCoordinates1;
let noiseCoordinates2 : vec3<f32>=particlesIn.particles[index].noiseCoordinates2;
let fetchedR : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates1.x,noiseCoordinates1.y)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;
let fetchedG : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates1.z,noiseCoordinates2.x)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;
let fetchedB : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates2.y,noiseCoordinates2.z)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;
let force : vec3<f32>=vec3<f32>(-1.+2.*fetchedR,-1.+2.*fetchedG,-1.+2.*fetchedB)*params.noiseStrength;
particlesOut.particles[index].direction=particlesOut.particles[index].direction+force*timeDelta;
particlesOut.particles[index].noiseCoordinates1=noiseCoordinates1;
particlesOut.particles[index].noiseCoordinates2=noiseCoordinates2;
#endif 
#endif 
#ifdef ANGULARSPEEDGRADIENTS
let angularSpeed : f32=textureSampleLevel(angularSpeedGradientTexture,angularSpeedGradientSampler,vec2<f32>(ageGradient,0.),0.).r;
particlesOut.particles[index].angle=particlesIn.particles[index].angle+angularSpeed*timeDelta;
#else
let angle : vec2<f32>=particlesIn.particles[index].angle;
particlesOut.particles[index].angle=vec2<f32>(angle.x+angle.y*timeDelta,angle.y);
#endif
#ifdef ANIMATESHEET 
var offsetAge : f32=particlesOut.particles[index].age;
let dist : f32=params.cellInfos.y-params.cellInfos.x;
#ifdef ANIMATESHEETRANDOMSTART
let cellStartOffset : f32=particlesIn.particles[index].cellStartOffset;
particlesOut.particles[index].cellStartOffset=cellStartOffset;
offsetAge=offsetAge+cellStartOffset;
#else
let cellStartOffset : f32=0.;
#endif 
var ratio : f32;
if (params.cellInfos.w==1.0) {
ratio=clamp(((cellStartOffset+params.cellInfos.z*offsetAge) % life)/life,0.,1.0);
}
else {
ratio=clamp((cellStartOffset+params.cellInfos.z*offsetAge)/life,0.,1.0);
}
particlesOut.particles[index].cellIndex=f32(i32(params.cellInfos.x+ratio*dist));
#endif
}
}
`;
ShaderStore.ShadersStoreWGSL[name67] = shader67;

// node_modules/@babylonjs/core/Particles/computeShaderParticleSystem.js
var ComputeShaderParticleSystem = class {
  constructor(parent, engine) {
    this._bufferComputeShader = [];
    this._renderVertexBuffers = [];
    this.alignDataInBuffer = true;
    this._parent = parent;
    this._engine = engine;
  }
  isUpdateBufferCreated() {
    return !!this._updateComputeShader;
  }
  isUpdateBufferReady() {
    var _a, _b;
    return (_b = (_a = this._updateComputeShader) === null || _a === void 0 ? void 0 : _a.isReady()) !== null && _b !== void 0 ? _b : false;
  }
  createUpdateBuffer(defines) {
    var _a;
    const bindingsMapping = {
      params: { group: 0, binding: 0 },
      particlesIn: { group: 0, binding: 1 },
      particlesOut: { group: 0, binding: 2 },
      randomTexture: { group: 0, binding: 3 },
      randomTexture2: { group: 0, binding: 4 }
    };
    if (this._parent._sizeGradientsTexture) {
      bindingsMapping["sizeGradientTexture"] = { group: 1, binding: 1 };
    }
    if (this._parent._angularSpeedGradientsTexture) {
      bindingsMapping["angularSpeedGradientTexture"] = { group: 1, binding: 3 };
    }
    if (this._parent._velocityGradientsTexture) {
      bindingsMapping["velocityGradientTexture"] = { group: 1, binding: 5 };
    }
    if (this._parent._limitVelocityGradientsTexture) {
      bindingsMapping["limitVelocityGradientTexture"] = { group: 1, binding: 7 };
    }
    if (this._parent._dragGradientsTexture) {
      bindingsMapping["dragGradientTexture"] = { group: 1, binding: 9 };
    }
    if (this._parent.noiseTexture) {
      bindingsMapping["noiseTexture"] = { group: 1, binding: 11 };
    }
    this._updateComputeShader = new ComputeShader("updateParticles", this._engine, "gpuUpdateParticles", { bindingsMapping, defines: defines.split("\n") });
    (_a = this._simParamsComputeShader) === null || _a === void 0 ? void 0 : _a.dispose();
    this._simParamsComputeShader = new UniformBuffer(this._engine);
    this._simParamsComputeShader.addUniform("currentCount", 1);
    this._simParamsComputeShader.addUniform("timeDelta", 1);
    this._simParamsComputeShader.addUniform("stopFactor", 1);
    this._simParamsComputeShader.addUniform("randomTextureSize", 1);
    this._simParamsComputeShader.addUniform("lifeTime", 2);
    this._simParamsComputeShader.addUniform("emitPower", 2);
    if (!this._parent._colorGradientsTexture) {
      this._simParamsComputeShader.addUniform("color1", 4);
      this._simParamsComputeShader.addUniform("color2", 4);
    }
    this._simParamsComputeShader.addUniform("sizeRange", 2);
    this._simParamsComputeShader.addUniform("scaleRange", 4);
    this._simParamsComputeShader.addUniform("angleRange", 4);
    this._simParamsComputeShader.addUniform("gravity", 3);
    if (this._parent._limitVelocityGradientsTexture) {
      this._simParamsComputeShader.addUniform("limitVelocityDamping", 1);
    }
    if (this._parent.isAnimationSheetEnabled) {
      this._simParamsComputeShader.addUniform("cellInfos", 4);
    }
    if (this._parent.noiseTexture) {
      this._simParamsComputeShader.addUniform("noiseStrength", 3);
    }
    if (!this._parent.isLocal) {
      this._simParamsComputeShader.addUniform("emitterWM", 16);
    }
    if (this._parent.particleEmitterType) {
      this._parent.particleEmitterType.buildUniformLayout(this._simParamsComputeShader);
    }
    this._updateComputeShader.setUniformBuffer("params", this._simParamsComputeShader);
    return new UniformBufferEffectCommonAccessor(this._simParamsComputeShader);
  }
  createVertexBuffers(updateBuffer, renderVertexBuffers) {
    this._renderVertexBuffers.push(renderVertexBuffers);
  }
  createParticleBuffer(data) {
    const buffer = new StorageBuffer(this._engine, data.length * 4, 3 | 8);
    buffer.update(data);
    this._bufferComputeShader.push(buffer);
    return buffer.getBuffer();
  }
  bindDrawBuffers(index, effect) {
    this._engine.bindBuffers(this._renderVertexBuffers[index], null, effect);
  }
  preUpdateParticleBuffer() {
  }
  updateParticleBuffer(index, targetBuffer, currentActiveCount) {
    this._simParamsComputeShader.update();
    this._updateComputeShader.setTexture("randomTexture", this._parent._randomTexture, false);
    this._updateComputeShader.setTexture("randomTexture2", this._parent._randomTexture2, false);
    if (this._parent._sizeGradientsTexture) {
      this._updateComputeShader.setTexture("sizeGradientTexture", this._parent._sizeGradientsTexture);
    }
    if (this._parent._angularSpeedGradientsTexture) {
      this._updateComputeShader.setTexture("angularSpeedGradientTexture", this._parent._angularSpeedGradientsTexture);
    }
    if (this._parent._velocityGradientsTexture) {
      this._updateComputeShader.setTexture("velocityGradientTexture", this._parent._velocityGradientsTexture);
    }
    if (this._parent._limitVelocityGradientsTexture) {
      this._updateComputeShader.setTexture("limitVelocityGradientTexture", this._parent._limitVelocityGradientsTexture);
    }
    if (this._parent._dragGradientsTexture) {
      this._updateComputeShader.setTexture("dragGradientTexture", this._parent._dragGradientsTexture);
    }
    if (this._parent.noiseTexture) {
      this._updateComputeShader.setTexture("noiseTexture", this._parent.noiseTexture);
    }
    this._updateComputeShader.setStorageBuffer("particlesIn", this._bufferComputeShader[index]);
    this._updateComputeShader.setStorageBuffer("particlesOut", this._bufferComputeShader[index ^ 1]);
    this._updateComputeShader.dispatch(Math.ceil(currentActiveCount / 64));
  }
  releaseBuffers() {
    var _a;
    for (let i = 0; i < this._bufferComputeShader.length; ++i) {
      this._bufferComputeShader[i].dispose();
    }
    this._bufferComputeShader.length = 0;
    (_a = this._simParamsComputeShader) === null || _a === void 0 ? void 0 : _a.dispose();
    this._simParamsComputeShader = null;
    this._updateComputeShader = null;
  }
  releaseVertexBuffers() {
    this._renderVertexBuffers.length = 0;
  }
};
RegisterClass("BABYLON.ComputeShaderParticleSystem", ComputeShaderParticleSystem);

// node_modules/@babylonjs/core/Misc/gradients.js
var ColorGradient = class {
  constructor(gradient, color1, color2) {
    this.gradient = gradient;
    this.color1 = color1;
    this.color2 = color2;
  }
  getColorToRef(result) {
    if (!this.color2) {
      result.copyFrom(this.color1);
      return;
    }
    Color4.LerpToRef(this.color1, this.color2, Math.random(), result);
  }
};
var Color3Gradient = class {
  constructor(gradient, color) {
    this.gradient = gradient;
    this.color = color;
  }
};
var FactorGradient = class {
  constructor(gradient, factor1, factor2) {
    this.gradient = gradient;
    this.factor1 = factor1;
    this.factor2 = factor2;
  }
  getFactor() {
    if (this.factor2 === void 0 || this.factor2 === this.factor1) {
      return this.factor1;
    }
    return this.factor1 + (this.factor2 - this.factor1) * Math.random();
  }
};
var GradientHelper = class {
  static GetCurrentGradient(ratio, gradients, updateFunc) {
    if (gradients[0].gradient > ratio) {
      updateFunc(gradients[0], gradients[0], 1);
      return;
    }
    for (let gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++) {
      const currentGradient = gradients[gradientIndex];
      const nextGradient = gradients[gradientIndex + 1];
      if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {
        const scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);
        updateFunc(currentGradient, nextGradient, scale);
        return;
      }
    }
    const lastIndex = gradients.length - 1;
    updateFunc(gradients[lastIndex], gradients[lastIndex], 1);
  }
};

// node_modules/@babylonjs/core/Particles/particle.js
var Particle = class {
  constructor(particleSystem) {
    this.particleSystem = particleSystem;
    this.position = Vector3.Zero();
    this.direction = Vector3.Zero();
    this.color = new Color4(0, 0, 0, 0);
    this.colorStep = new Color4(0, 0, 0, 0);
    this.lifeTime = 1;
    this.age = 0;
    this.size = 0;
    this.scale = new Vector2(1, 1);
    this.angle = 0;
    this.angularSpeed = 0;
    this.cellIndex = 0;
    this._attachedSubEmitters = null;
    this._currentColor1 = new Color4(0, 0, 0, 0);
    this._currentColor2 = new Color4(0, 0, 0, 0);
    this._currentSize1 = 0;
    this._currentSize2 = 0;
    this._currentAngularSpeed1 = 0;
    this._currentAngularSpeed2 = 0;
    this._currentVelocity1 = 0;
    this._currentVelocity2 = 0;
    this._currentLimitVelocity1 = 0;
    this._currentLimitVelocity2 = 0;
    this._currentDrag1 = 0;
    this._currentDrag2 = 0;
    this.id = Particle._Count++;
    if (!this.particleSystem.isAnimationSheetEnabled) {
      return;
    }
    this._updateCellInfoFromSystem();
  }
  _updateCellInfoFromSystem() {
    this.cellIndex = this.particleSystem.startSpriteCellID;
  }
  updateCellIndex() {
    let offsetAge = this.age;
    let changeSpeed = this.particleSystem.spriteCellChangeSpeed;
    if (this.particleSystem.spriteRandomStartCell) {
      if (this._randomCellOffset === void 0) {
        this._randomCellOffset = Math.random() * this.lifeTime;
      }
      if (changeSpeed === 0) {
        changeSpeed = 1;
        offsetAge = this._randomCellOffset;
      } else {
        offsetAge += this._randomCellOffset;
      }
    }
    const dist = this._initialEndSpriteCellID - this._initialStartSpriteCellID;
    let ratio;
    if (this._initialSpriteCellLoop) {
      ratio = Scalar.Clamp(offsetAge * changeSpeed % this.lifeTime / this.lifeTime);
    } else {
      ratio = Scalar.Clamp(offsetAge * changeSpeed / this.lifeTime);
    }
    this.cellIndex = this._initialStartSpriteCellID + ratio * dist | 0;
  }
  _inheritParticleInfoToSubEmitter(subEmitter) {
    if (subEmitter.particleSystem.emitter.position) {
      const emitterMesh = subEmitter.particleSystem.emitter;
      emitterMesh.position.copyFrom(this.position);
      if (subEmitter.inheritDirection) {
        const temp = TmpVectors.Vector3[0];
        this.direction.normalizeToRef(temp);
        emitterMesh.setDirection(temp, 0, Math.PI / 2);
      }
    } else {
      const emitterPosition = subEmitter.particleSystem.emitter;
      emitterPosition.copyFrom(this.position);
    }
    this.direction.scaleToRef(subEmitter.inheritedVelocityAmount / 2, TmpVectors.Vector3[0]);
    subEmitter.particleSystem._inheritedVelocityOffset.copyFrom(TmpVectors.Vector3[0]);
  }
  _inheritParticleInfoToSubEmitters() {
    if (this._attachedSubEmitters && this._attachedSubEmitters.length > 0) {
      this._attachedSubEmitters.forEach((subEmitter) => {
        this._inheritParticleInfoToSubEmitter(subEmitter);
      });
    }
  }
  _reset() {
    this.age = 0;
    this.id = Particle._Count++;
    this._currentColorGradient = null;
    this._currentSizeGradient = null;
    this._currentAngularSpeedGradient = null;
    this._currentVelocityGradient = null;
    this._currentLimitVelocityGradient = null;
    this._currentDragGradient = null;
    this.cellIndex = this.particleSystem.startSpriteCellID;
    this._randomCellOffset = void 0;
  }
  copyTo(other) {
    other.position.copyFrom(this.position);
    if (this._initialDirection) {
      if (other._initialDirection) {
        other._initialDirection.copyFrom(this._initialDirection);
      } else {
        other._initialDirection = this._initialDirection.clone();
      }
    } else {
      other._initialDirection = null;
    }
    other.direction.copyFrom(this.direction);
    if (this._localPosition) {
      if (other._localPosition) {
        other._localPosition.copyFrom(this._localPosition);
      } else {
        other._localPosition = this._localPosition.clone();
      }
    }
    other.color.copyFrom(this.color);
    other.colorStep.copyFrom(this.colorStep);
    other.lifeTime = this.lifeTime;
    other.age = this.age;
    other._randomCellOffset = this._randomCellOffset;
    other.size = this.size;
    other.scale.copyFrom(this.scale);
    other.angle = this.angle;
    other.angularSpeed = this.angularSpeed;
    other.particleSystem = this.particleSystem;
    other.cellIndex = this.cellIndex;
    other.id = this.id;
    other._attachedSubEmitters = this._attachedSubEmitters;
    if (this._currentColorGradient) {
      other._currentColorGradient = this._currentColorGradient;
      other._currentColor1.copyFrom(this._currentColor1);
      other._currentColor2.copyFrom(this._currentColor2);
    }
    if (this._currentSizeGradient) {
      other._currentSizeGradient = this._currentSizeGradient;
      other._currentSize1 = this._currentSize1;
      other._currentSize2 = this._currentSize2;
    }
    if (this._currentAngularSpeedGradient) {
      other._currentAngularSpeedGradient = this._currentAngularSpeedGradient;
      other._currentAngularSpeed1 = this._currentAngularSpeed1;
      other._currentAngularSpeed2 = this._currentAngularSpeed2;
    }
    if (this._currentVelocityGradient) {
      other._currentVelocityGradient = this._currentVelocityGradient;
      other._currentVelocity1 = this._currentVelocity1;
      other._currentVelocity2 = this._currentVelocity2;
    }
    if (this._currentLimitVelocityGradient) {
      other._currentLimitVelocityGradient = this._currentLimitVelocityGradient;
      other._currentLimitVelocity1 = this._currentLimitVelocity1;
      other._currentLimitVelocity2 = this._currentLimitVelocity2;
    }
    if (this._currentDragGradient) {
      other._currentDragGradient = this._currentDragGradient;
      other._currentDrag1 = this._currentDrag1;
      other._currentDrag2 = this._currentDrag2;
    }
    if (this.particleSystem.isAnimationSheetEnabled) {
      other._initialStartSpriteCellID = this._initialStartSpriteCellID;
      other._initialEndSpriteCellID = this._initialEndSpriteCellID;
      other._initialSpriteCellLoop = this._initialSpriteCellLoop;
    }
    if (this.particleSystem.useRampGradients) {
      if (other.remapData && this.remapData) {
        other.remapData.copyFrom(this.remapData);
      } else {
        other.remapData = new Vector4(0, 0, 0, 0);
      }
    }
    if (this._randomNoiseCoordinates1) {
      if (other._randomNoiseCoordinates1) {
        other._randomNoiseCoordinates1.copyFrom(this._randomNoiseCoordinates1);
        other._randomNoiseCoordinates2.copyFrom(this._randomNoiseCoordinates2);
      } else {
        other._randomNoiseCoordinates1 = this._randomNoiseCoordinates1.clone();
        other._randomNoiseCoordinates2 = this._randomNoiseCoordinates2.clone();
      }
    }
  }
};
Particle._Count = 0;

// node_modules/@babylonjs/core/Particles/subEmitter.js
var SubEmitterType;
(function(SubEmitterType2) {
  SubEmitterType2[SubEmitterType2["ATTACHED"] = 0] = "ATTACHED";
  SubEmitterType2[SubEmitterType2["END"] = 1] = "END";
})(SubEmitterType || (SubEmitterType = {}));
var SubEmitter = class {
  constructor(particleSystem) {
    this.particleSystem = particleSystem;
    this.type = SubEmitterType.END;
    this.inheritDirection = false;
    this.inheritedVelocityAmount = 0;
    if (!particleSystem.emitter || !particleSystem.emitter.dispose) {
      const internalClass = GetClass("BABYLON.AbstractMesh");
      particleSystem.emitter = new internalClass("SubemitterSystemEmitter", particleSystem.getScene());
      particleSystem._disposeEmitterOnDispose = true;
    }
  }
  clone() {
    let emitter = this.particleSystem.emitter;
    if (!emitter) {
      emitter = new Vector3();
    } else if (emitter instanceof Vector3) {
      emitter = emitter.clone();
    } else if (emitter.getClassName().indexOf("Mesh") !== -1) {
      const internalClass = GetClass("BABYLON.Mesh");
      emitter = new internalClass("", emitter.getScene());
      emitter.isVisible = false;
    }
    const clone = new SubEmitter(this.particleSystem.clone(this.particleSystem.name, emitter));
    clone.particleSystem.name += "Clone";
    clone.type = this.type;
    clone.inheritDirection = this.inheritDirection;
    clone.inheritedVelocityAmount = this.inheritedVelocityAmount;
    clone.particleSystem._disposeEmitterOnDispose = true;
    clone.particleSystem.disposeOnStop = true;
    return clone;
  }
  serialize(serializeTexture = false) {
    const serializationObject = {};
    serializationObject.type = this.type;
    serializationObject.inheritDirection = this.inheritDirection;
    serializationObject.inheritedVelocityAmount = this.inheritedVelocityAmount;
    serializationObject.particleSystem = this.particleSystem.serialize(serializeTexture);
    return serializationObject;
  }
  static _ParseParticleSystem(system, sceneOrEngine, rootUrl, doNotStart = false) {
    throw _WarnImport("ParseParticle");
  }
  static Parse(serializationObject, sceneOrEngine, rootUrl) {
    const system = serializationObject.particleSystem;
    const subEmitter = new SubEmitter(SubEmitter._ParseParticleSystem(system, sceneOrEngine, rootUrl, true));
    subEmitter.type = serializationObject.type;
    subEmitter.inheritDirection = serializationObject.inheritDirection;
    subEmitter.inheritedVelocityAmount = serializationObject.inheritedVelocityAmount;
    subEmitter.particleSystem._isSubEmitter = true;
    return subEmitter;
  }
  dispose() {
    this.particleSystem.dispose();
  }
};

// node_modules/@babylonjs/core/Shaders/particles.fragment.js
var name68 = "particlesPixelShader";
var shader68 = `#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
varying vec2 vUV;
varying vec4 vColor;
uniform vec4 textureMask;
uniform sampler2D diffuseSampler;
#include<clipPlaneFragmentDeclaration>
#include<imageProcessingDeclaration>
#include<logDepthDeclaration>
#include<helperFunctions>
#include<imageProcessingFunctions>
#ifdef RAMPGRADIENT
varying vec4 remapRanges;
uniform sampler2D rampSampler;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec4 textureColor=texture2D(diffuseSampler,vUV);
vec4 baseColor=(textureColor*textureMask+(vec4(1.,1.,1.,1.)-textureMask))*vColor;
#ifdef RAMPGRADIENT
float alpha=baseColor.a;
float remappedColorIndex=clamp((alpha-remapRanges.x)/remapRanges.y,0.0,1.0);
vec4 rampColor=texture2D(rampSampler,vec2(1.0-remappedColorIndex,0.));
baseColor.rgb*=rampColor.rgb;
float finalAlpha=baseColor.a;
baseColor.a=clamp((alpha*rampColor.a-remapRanges.z)/remapRanges.w,0.0,1.0);
#endif
#ifdef BLENDMULTIPLYMODE
float sourceAlpha=vColor.a*textureColor.a;
baseColor.rgb=baseColor.rgb*sourceAlpha+vec3(1.0)*(1.0-sourceAlpha);
#endif
#include<logDepthFragment>
#ifdef IMAGEPROCESSINGPOSTPROCESS
baseColor.rgb=toLinearSpace(baseColor.rgb);
#else
#ifdef IMAGEPROCESSING
baseColor.rgb=toLinearSpace(baseColor.rgb);
baseColor=applyImageProcessing(baseColor);
#endif
#endif
gl_FragColor=baseColor;
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name68] = shader68;

// node_modules/@babylonjs/core/Shaders/particles.vertex.js
var name69 = "particlesVertexShader";
var shader69 = `attribute vec3 position;
attribute vec4 color;
attribute float angle;
attribute vec2 size;
#ifdef ANIMATESHEET
attribute float cellIndex;
#endif
#ifndef BILLBOARD
attribute vec3 direction;
#endif
#ifdef BILLBOARDSTRETCHED
attribute vec3 direction;
#endif
#ifdef RAMPGRADIENT
attribute vec4 remapData;
#endif
attribute vec2 offset;
uniform mat4 view;
uniform mat4 projection;
uniform vec2 translationPivot;
#ifdef ANIMATESHEET
uniform vec3 particlesInfos; 
#endif
varying vec2 vUV;
varying vec4 vColor;
varying vec3 vPositionW;
#ifdef RAMPGRADIENT
varying vec4 remapRanges;
#endif
#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)
uniform mat4 invView;
#endif
#include<clipPlaneVertexDeclaration>
#include<logDepthDeclaration>
#ifdef BILLBOARD
uniform vec3 eyePosition;
#endif
vec3 rotate(vec3 yaxis,vec3 rotatedCorner) {
vec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));
vec3 zaxis=normalize(cross(yaxis,xaxis));
vec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);
vec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);
vec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);
mat3 rotMatrix= mat3(row0,row1,row2);
vec3 alignedCorner=rotMatrix*rotatedCorner;
return position+alignedCorner;
}
#ifdef BILLBOARDSTRETCHED
vec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {
vec3 normalizedToCamera=normalize(toCamera);
vec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));
vec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);
vec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);
#ifdef BILLBOARDSTRETCHED_LOCAL
vec3 row1=direction;
#else
vec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));
vec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);
#endif
mat3 rotMatrix= mat3(row0,row1,row2);
vec3 alignedCorner=rotMatrix*rotatedCorner;
return position+alignedCorner;
}
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec2 cornerPos;
cornerPos=(vec2(offset.x-0.5,offset.y -0.5)-translationPivot)*size+translationPivot;
#ifdef BILLBOARD
vec3 rotatedCorner;
#ifdef BILLBOARDY
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);
rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);
rotatedCorner.y=0.;
vec3 yaxis=position-eyePosition;
yaxis.y=0.;
vPositionW=rotate(normalize(yaxis),rotatedCorner);
vec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;
#elif defined(BILLBOARDSTRETCHED)
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);
rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);
rotatedCorner.z=0.;
vec3 toCamera=position-eyePosition;
vPositionW=rotateAlign(toCamera,rotatedCorner);
vec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;
#else
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);
rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);
rotatedCorner.z=0.;
vec3 viewPos=(view*vec4(position,1.0)).xyz+rotatedCorner;
vPositionW=(invView*vec4(viewPos,1)).xyz;
#endif
#ifdef RAMPGRADIENT
remapRanges=remapData;
#endif
gl_Position=projection*vec4(viewPos,1.0);
#else
vec3 rotatedCorner;
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);
rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);
rotatedCorner.y=0.;
vec3 yaxis=normalize(direction);
vPositionW=rotate(yaxis,rotatedCorner);
gl_Position=projection*view*vec4(vPositionW,1.0);
#endif
vColor=color;
#ifdef ANIMATESHEET
float rowOffset=floor(cellIndex*particlesInfos.z);
float columnOffset=cellIndex-rowOffset/particlesInfos.z;
vec2 uvScale=particlesInfos.xy;
vec2 uvOffset=vec2(offset.x ,1.0-offset.y);
vUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;
#else
vUV=offset;
#endif
#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
vec4 worldPos=vec4(vPositionW,1.0);
#endif
#include<clipPlaneVertex>
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name69] = shader69;

// node_modules/@babylonjs/core/Particles/particleSystem.js
var ParticleSystem = class extends BaseParticleSystem {
  constructor(name137, capacity, sceneOrEngine, customEffect = null, isAnimationSheetEnabled = false, epsilon = 0.01) {
    super(name137);
    this._emitterInverseWorldMatrix = Matrix.Identity();
    this._inheritedVelocityOffset = new Vector3();
    this.onDisposeObservable = new Observable();
    this.onStoppedObservable = new Observable();
    this._particles = new Array();
    this._stockParticles = new Array();
    this._newPartsExcess = 0;
    this._vertexBuffers = {};
    this._scaledColorStep = new Color4(0, 0, 0, 0);
    this._colorDiff = new Color4(0, 0, 0, 0);
    this._scaledDirection = Vector3.Zero();
    this._scaledGravity = Vector3.Zero();
    this._currentRenderId = -1;
    this._useInstancing = false;
    this._started = false;
    this._stopped = false;
    this._actualFrame = 0;
    this._currentEmitRate1 = 0;
    this._currentEmitRate2 = 0;
    this._currentStartSize1 = 0;
    this._currentStartSize2 = 0;
    this.updateInAnimate = true;
    this._rawTextureWidth = 256;
    this._useRampGradients = false;
    this._disposeEmitterOnDispose = false;
    this.isLocal = false;
    this.isGPU = false;
    this._onBeforeDrawParticlesObservable = null;
    this.recycleParticle = (particle) => {
      const lastParticle = this._particles.pop();
      if (lastParticle !== particle) {
        lastParticle.copyTo(particle);
      }
      this._stockParticles.push(lastParticle);
    };
    this._createParticle = () => {
      let particle;
      if (this._stockParticles.length !== 0) {
        particle = this._stockParticles.pop();
        particle._reset();
      } else {
        particle = new Particle(this);
      }
      if (this._subEmitters && this._subEmitters.length > 0) {
        const subEmitters = this._subEmitters[Math.floor(Math.random() * this._subEmitters.length)];
        particle._attachedSubEmitters = [];
        subEmitters.forEach((subEmitter) => {
          if (subEmitter.type === SubEmitterType.ATTACHED) {
            const newEmitter = subEmitter.clone();
            particle._attachedSubEmitters.push(newEmitter);
            newEmitter.particleSystem.start();
          }
        });
      }
      return particle;
    };
    this._emitFromParticle = (particle) => {
      if (!this._subEmitters || this._subEmitters.length === 0) {
        return;
      }
      const templateIndex = Math.floor(Math.random() * this._subEmitters.length);
      this._subEmitters[templateIndex].forEach((subEmitter) => {
        if (subEmitter.type === SubEmitterType.END) {
          const subSystem = subEmitter.clone();
          particle._inheritParticleInfoToSubEmitter(subSystem);
          subSystem.particleSystem._rootParticleSystem = this;
          this.activeSubSystems.push(subSystem.particleSystem);
          subSystem.particleSystem.start();
        }
      });
    };
    this._capacity = capacity;
    this._epsilon = epsilon;
    this._isAnimationSheetEnabled = isAnimationSheetEnabled;
    if (!sceneOrEngine || sceneOrEngine.getClassName() === "Scene") {
      this._scene = sceneOrEngine || EngineStore.LastCreatedScene;
      this._engine = this._scene.getEngine();
      this.uniqueId = this._scene.getUniqueId();
      this._scene.particleSystems.push(this);
    } else {
      this._engine = sceneOrEngine;
      this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);
    }
    if (this._engine.getCaps().vertexArrayObject) {
      this._vertexArrayObject = null;
    }
    this._attachImageProcessingConfiguration(null);
    this._customWrappers = { 0: new DrawWrapper(this._engine) };
    this._customWrappers[0].effect = customEffect;
    this._drawWrappers = [];
    this._useInstancing = this._engine.getCaps().instancedArrays;
    this._createIndexBuffer();
    this._createVertexBuffers();
    this.particleEmitterType = new BoxParticleEmitter();
    let noiseTextureData = null;
    this.updateFunction = (particles) => {
      var _a;
      let noiseTextureSize = null;
      if (this.noiseTexture) {
        noiseTextureSize = this.noiseTexture.getSize();
        (_a = this.noiseTexture.getContent()) === null || _a === void 0 ? void 0 : _a.then((data) => {
          noiseTextureData = data;
        });
      }
      for (let index = 0; index < particles.length; index++) {
        const particle = particles[index];
        let scaledUpdateSpeed = this._scaledUpdateSpeed;
        const previousAge = particle.age;
        particle.age += scaledUpdateSpeed;
        if (particle.age > particle.lifeTime) {
          const diff = particle.age - previousAge;
          const oldDiff = particle.lifeTime - previousAge;
          scaledUpdateSpeed = oldDiff * scaledUpdateSpeed / diff;
          particle.age = particle.lifeTime;
        }
        const ratio = particle.age / particle.lifeTime;
        if (this._colorGradients && this._colorGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {
            if (currentGradient !== particle._currentColorGradient) {
              particle._currentColor1.copyFrom(particle._currentColor2);
              nextGradient.getColorToRef(particle._currentColor2);
              particle._currentColorGradient = currentGradient;
            }
            Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);
          });
        } else {
          particle.colorStep.scaleToRef(scaledUpdateSpeed, this._scaledColorStep);
          particle.color.addInPlace(this._scaledColorStep);
          if (particle.color.a < 0) {
            particle.color.a = 0;
          }
        }
        if (this._angularSpeedGradients && this._angularSpeedGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, this._angularSpeedGradients, (currentGradient, nextGradient, scale) => {
            if (currentGradient !== particle._currentAngularSpeedGradient) {
              particle._currentAngularSpeed1 = particle._currentAngularSpeed2;
              particle._currentAngularSpeed2 = nextGradient.getFactor();
              particle._currentAngularSpeedGradient = currentGradient;
            }
            particle.angularSpeed = Scalar.Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);
          });
        }
        particle.angle += particle.angularSpeed * scaledUpdateSpeed;
        let directionScale = scaledUpdateSpeed;
        if (this._velocityGradients && this._velocityGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, this._velocityGradients, (currentGradient, nextGradient, scale) => {
            if (currentGradient !== particle._currentVelocityGradient) {
              particle._currentVelocity1 = particle._currentVelocity2;
              particle._currentVelocity2 = nextGradient.getFactor();
              particle._currentVelocityGradient = currentGradient;
            }
            directionScale *= Scalar.Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);
          });
        }
        particle.direction.scaleToRef(directionScale, this._scaledDirection);
        if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, this._limitVelocityGradients, (currentGradient, nextGradient, scale) => {
            if (currentGradient !== particle._currentLimitVelocityGradient) {
              particle._currentLimitVelocity1 = particle._currentLimitVelocity2;
              particle._currentLimitVelocity2 = nextGradient.getFactor();
              particle._currentLimitVelocityGradient = currentGradient;
            }
            const limitVelocity = Scalar.Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);
            const currentVelocity = particle.direction.length();
            if (currentVelocity > limitVelocity) {
              particle.direction.scaleInPlace(this.limitVelocityDamping);
            }
          });
        }
        if (this._dragGradients && this._dragGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, this._dragGradients, (currentGradient, nextGradient, scale) => {
            if (currentGradient !== particle._currentDragGradient) {
              particle._currentDrag1 = particle._currentDrag2;
              particle._currentDrag2 = nextGradient.getFactor();
              particle._currentDragGradient = currentGradient;
            }
            const drag = Scalar.Lerp(particle._currentDrag1, particle._currentDrag2, scale);
            this._scaledDirection.scaleInPlace(1 - drag);
          });
        }
        if (this.isLocal && particle._localPosition) {
          particle._localPosition.addInPlace(this._scaledDirection);
          Vector3.TransformCoordinatesToRef(particle._localPosition, this._emitterWorldMatrix, particle.position);
        } else {
          particle.position.addInPlace(this._scaledDirection);
        }
        if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {
          const fetchedColorR = this._fetchR(particle._randomNoiseCoordinates1.x, particle._randomNoiseCoordinates1.y, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
          const fetchedColorG = this._fetchR(particle._randomNoiseCoordinates1.z, particle._randomNoiseCoordinates2.x, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
          const fetchedColorB = this._fetchR(particle._randomNoiseCoordinates2.y, particle._randomNoiseCoordinates2.z, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
          const force = TmpVectors.Vector3[0];
          const scaledForce = TmpVectors.Vector3[1];
          force.copyFromFloats((2 * fetchedColorR - 1) * this.noiseStrength.x, (2 * fetchedColorG - 1) * this.noiseStrength.y, (2 * fetchedColorB - 1) * this.noiseStrength.z);
          force.scaleToRef(scaledUpdateSpeed, scaledForce);
          particle.direction.addInPlace(scaledForce);
        }
        this.gravity.scaleToRef(scaledUpdateSpeed, this._scaledGravity);
        particle.direction.addInPlace(this._scaledGravity);
        if (this._sizeGradients && this._sizeGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, this._sizeGradients, (currentGradient, nextGradient, scale) => {
            if (currentGradient !== particle._currentSizeGradient) {
              particle._currentSize1 = particle._currentSize2;
              particle._currentSize2 = nextGradient.getFactor();
              particle._currentSizeGradient = currentGradient;
            }
            particle.size = Scalar.Lerp(particle._currentSize1, particle._currentSize2, scale);
          });
        }
        if (this._useRampGradients) {
          if (this._colorRemapGradients && this._colorRemapGradients.length > 0) {
            GradientHelper.GetCurrentGradient(ratio, this._colorRemapGradients, (currentGradient, nextGradient, scale) => {
              const min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);
              const max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);
              particle.remapData.x = min;
              particle.remapData.y = max - min;
            });
          }
          if (this._alphaRemapGradients && this._alphaRemapGradients.length > 0) {
            GradientHelper.GetCurrentGradient(ratio, this._alphaRemapGradients, (currentGradient, nextGradient, scale) => {
              const min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);
              const max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);
              particle.remapData.z = min;
              particle.remapData.w = max - min;
            });
          }
        }
        if (this._isAnimationSheetEnabled) {
          particle.updateCellIndex();
        }
        particle._inheritParticleInfoToSubEmitters();
        if (particle.age >= particle.lifeTime) {
          this._emitFromParticle(particle);
          if (particle._attachedSubEmitters) {
            particle._attachedSubEmitters.forEach((subEmitter) => {
              subEmitter.particleSystem.disposeOnStop = true;
              subEmitter.particleSystem.stop();
            });
            particle._attachedSubEmitters = null;
          }
          this.recycleParticle(particle);
          index--;
          continue;
        }
      }
    };
  }
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  get useRampGradients() {
    return this._useRampGradients;
  }
  set useRampGradients(value) {
    if (this._useRampGradients === value) {
      return;
    }
    this._useRampGradients = value;
    this._resetEffect();
  }
  get particles() {
    return this._particles;
  }
  getActiveCount() {
    return this._particles.length;
  }
  getClassName() {
    return "ParticleSystem";
  }
  isStopping() {
    return this._stopped && this.isAlive();
  }
  getCustomEffect(blendMode = 0) {
    var _a, _b;
    return (_b = (_a = this._customWrappers[blendMode]) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : this._customWrappers[0].effect;
  }
  _getCustomDrawWrapper(blendMode = 0) {
    var _a;
    return (_a = this._customWrappers[blendMode]) !== null && _a !== void 0 ? _a : this._customWrappers[0];
  }
  setCustomEffect(effect, blendMode = 0) {
    this._customWrappers[blendMode] = new DrawWrapper(this._engine);
    this._customWrappers[blendMode].effect = effect;
    if (this._customWrappers[blendMode].drawContext) {
      this._customWrappers[blendMode].drawContext.useInstancing = this._useInstancing;
    }
  }
  get onBeforeDrawParticlesObservable() {
    if (!this._onBeforeDrawParticlesObservable) {
      this._onBeforeDrawParticlesObservable = new Observable();
    }
    return this._onBeforeDrawParticlesObservable;
  }
  get vertexShaderName() {
    return "particles";
  }
  get vertexBuffers() {
    return this._vertexBuffers;
  }
  get indexBuffer() {
    return this._indexBuffer;
  }
  _addFactorGradient(factorGradients, gradient, factor, factor2) {
    const newGradient = new FactorGradient(gradient, factor, factor2);
    factorGradients.push(newGradient);
    factorGradients.sort((a, b) => {
      if (a.gradient < b.gradient) {
        return -1;
      } else if (a.gradient > b.gradient) {
        return 1;
      }
      return 0;
    });
  }
  _removeFactorGradient(factorGradients, gradient) {
    if (!factorGradients) {
      return;
    }
    let index = 0;
    for (const factorGradient of factorGradients) {
      if (factorGradient.gradient === gradient) {
        factorGradients.splice(index, 1);
        break;
      }
      index++;
    }
  }
  addLifeTimeGradient(gradient, factor, factor2) {
    if (!this._lifeTimeGradients) {
      this._lifeTimeGradients = [];
    }
    this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);
    return this;
  }
  removeLifeTimeGradient(gradient) {
    this._removeFactorGradient(this._lifeTimeGradients, gradient);
    return this;
  }
  addSizeGradient(gradient, factor, factor2) {
    if (!this._sizeGradients) {
      this._sizeGradients = [];
    }
    this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);
    return this;
  }
  removeSizeGradient(gradient) {
    this._removeFactorGradient(this._sizeGradients, gradient);
    return this;
  }
  addColorRemapGradient(gradient, min, max) {
    if (!this._colorRemapGradients) {
      this._colorRemapGradients = [];
    }
    this._addFactorGradient(this._colorRemapGradients, gradient, min, max);
    return this;
  }
  removeColorRemapGradient(gradient) {
    this._removeFactorGradient(this._colorRemapGradients, gradient);
    return this;
  }
  addAlphaRemapGradient(gradient, min, max) {
    if (!this._alphaRemapGradients) {
      this._alphaRemapGradients = [];
    }
    this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);
    return this;
  }
  removeAlphaRemapGradient(gradient) {
    this._removeFactorGradient(this._alphaRemapGradients, gradient);
    return this;
  }
  addAngularSpeedGradient(gradient, factor, factor2) {
    if (!this._angularSpeedGradients) {
      this._angularSpeedGradients = [];
    }
    this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);
    return this;
  }
  removeAngularSpeedGradient(gradient) {
    this._removeFactorGradient(this._angularSpeedGradients, gradient);
    return this;
  }
  addVelocityGradient(gradient, factor, factor2) {
    if (!this._velocityGradients) {
      this._velocityGradients = [];
    }
    this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);
    return this;
  }
  removeVelocityGradient(gradient) {
    this._removeFactorGradient(this._velocityGradients, gradient);
    return this;
  }
  addLimitVelocityGradient(gradient, factor, factor2) {
    if (!this._limitVelocityGradients) {
      this._limitVelocityGradients = [];
    }
    this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);
    return this;
  }
  removeLimitVelocityGradient(gradient) {
    this._removeFactorGradient(this._limitVelocityGradients, gradient);
    return this;
  }
  addDragGradient(gradient, factor, factor2) {
    if (!this._dragGradients) {
      this._dragGradients = [];
    }
    this._addFactorGradient(this._dragGradients, gradient, factor, factor2);
    return this;
  }
  removeDragGradient(gradient) {
    this._removeFactorGradient(this._dragGradients, gradient);
    return this;
  }
  addEmitRateGradient(gradient, factor, factor2) {
    if (!this._emitRateGradients) {
      this._emitRateGradients = [];
    }
    this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);
    return this;
  }
  removeEmitRateGradient(gradient) {
    this._removeFactorGradient(this._emitRateGradients, gradient);
    return this;
  }
  addStartSizeGradient(gradient, factor, factor2) {
    if (!this._startSizeGradients) {
      this._startSizeGradients = [];
    }
    this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);
    return this;
  }
  removeStartSizeGradient(gradient) {
    this._removeFactorGradient(this._startSizeGradients, gradient);
    return this;
  }
  _createRampGradientTexture() {
    if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {
      return;
    }
    const data = new Uint8Array(this._rawTextureWidth * 4);
    const tmpColor = TmpColors.Color3[0];
    for (let x = 0; x < this._rawTextureWidth; x++) {
      const ratio = x / this._rawTextureWidth;
      GradientHelper.GetCurrentGradient(ratio, this._rampGradients, (currentGradient, nextGradient, scale) => {
        Color3.LerpToRef(currentGradient.color, nextGradient.color, scale, tmpColor);
        data[x * 4] = tmpColor.r * 255;
        data[x * 4 + 1] = tmpColor.g * 255;
        data[x * 4 + 2] = tmpColor.b * 255;
        data[x * 4 + 3] = 255;
      });
    }
    this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);
  }
  getRampGradients() {
    return this._rampGradients;
  }
  forceRefreshGradients() {
    this._syncRampGradientTexture();
  }
  _syncRampGradientTexture() {
    if (!this._rampGradients) {
      return;
    }
    this._rampGradients.sort((a, b) => {
      if (a.gradient < b.gradient) {
        return -1;
      } else if (a.gradient > b.gradient) {
        return 1;
      }
      return 0;
    });
    if (this._rampGradientsTexture) {
      this._rampGradientsTexture.dispose();
      this._rampGradientsTexture = null;
    }
    this._createRampGradientTexture();
  }
  addRampGradient(gradient, color) {
    if (!this._rampGradients) {
      this._rampGradients = [];
    }
    const rampGradient = new Color3Gradient(gradient, color);
    this._rampGradients.push(rampGradient);
    this._syncRampGradientTexture();
    return this;
  }
  removeRampGradient(gradient) {
    this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);
    this._rampGradientsTexture = null;
    if (this._rampGradients && this._rampGradients.length > 0) {
      this._createRampGradientTexture();
    }
    return this;
  }
  addColorGradient(gradient, color1, color2) {
    if (!this._colorGradients) {
      this._colorGradients = [];
    }
    const colorGradient = new ColorGradient(gradient, color1, color2);
    this._colorGradients.push(colorGradient);
    this._colorGradients.sort((a, b) => {
      if (a.gradient < b.gradient) {
        return -1;
      } else if (a.gradient > b.gradient) {
        return 1;
      }
      return 0;
    });
    return this;
  }
  removeColorGradient(gradient) {
    if (!this._colorGradients) {
      return this;
    }
    let index = 0;
    for (const colorGradient of this._colorGradients) {
      if (colorGradient.gradient === gradient) {
        this._colorGradients.splice(index, 1);
        break;
      }
      index++;
    }
    return this;
  }
  resetDrawCache() {
    for (const drawWrappers of this._drawWrappers) {
      if (drawWrappers) {
        for (const drawWrapper of drawWrappers) {
          drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();
        }
      }
    }
    this._drawWrappers = [];
  }
  _fetchR(u, v, width, height, pixels) {
    u = Math.abs(u) * 0.5 + 0.5;
    v = Math.abs(v) * 0.5 + 0.5;
    const wrappedU = u * width % width | 0;
    const wrappedV = v * height % height | 0;
    const position = (wrappedU + wrappedV * width) * 4;
    return pixels[position] / 255;
  }
  _reset() {
    this._resetEffect();
  }
  _resetEffect() {
    if (this._vertexBuffer) {
      this._vertexBuffer.dispose();
      this._vertexBuffer = null;
    }
    if (this._spriteBuffer) {
      this._spriteBuffer.dispose();
      this._spriteBuffer = null;
    }
    if (this._vertexArrayObject) {
      this._engine.releaseVertexArrayObject(this._vertexArrayObject);
      this._vertexArrayObject = null;
    }
    this._createVertexBuffers();
  }
  _createVertexBuffers() {
    this._vertexBufferSize = this._useInstancing ? 10 : 12;
    if (this._isAnimationSheetEnabled) {
      this._vertexBufferSize += 1;
    }
    if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {
      this._vertexBufferSize += 3;
    }
    if (this._useRampGradients) {
      this._vertexBufferSize += 4;
    }
    const engine = this._engine;
    const vertexSize = this._vertexBufferSize * (this._useInstancing ? 1 : 4);
    this._vertexData = new Float32Array(this._capacity * vertexSize);
    this._vertexBuffer = new Buffer(engine, this._vertexData, true, vertexSize);
    let dataOffset = 0;
    const positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers[VertexBuffer.PositionKind] = positions;
    dataOffset += 3;
    const colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers[VertexBuffer.ColorKind] = colors;
    dataOffset += 4;
    const options = this._vertexBuffer.createVertexBuffer("angle", dataOffset, 1, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers["angle"] = options;
    dataOffset += 1;
    const size = this._vertexBuffer.createVertexBuffer("size", dataOffset, 2, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers["size"] = size;
    dataOffset += 2;
    if (this._isAnimationSheetEnabled) {
      const cellIndexBuffer = this._vertexBuffer.createVertexBuffer("cellIndex", dataOffset, 1, this._vertexBufferSize, this._useInstancing);
      this._vertexBuffers["cellIndex"] = cellIndexBuffer;
      dataOffset += 1;
    }
    if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {
      const directionBuffer = this._vertexBuffer.createVertexBuffer("direction", dataOffset, 3, this._vertexBufferSize, this._useInstancing);
      this._vertexBuffers["direction"] = directionBuffer;
      dataOffset += 3;
    }
    if (this._useRampGradients) {
      const rampDataBuffer = this._vertexBuffer.createVertexBuffer("remapData", dataOffset, 4, this._vertexBufferSize, this._useInstancing);
      this._vertexBuffers["remapData"] = rampDataBuffer;
      dataOffset += 4;
    }
    let offsets;
    if (this._useInstancing) {
      const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);
      offsets = this._spriteBuffer.createVertexBuffer("offset", 0, 2);
    } else {
      offsets = this._vertexBuffer.createVertexBuffer("offset", dataOffset, 2, this._vertexBufferSize, this._useInstancing);
      dataOffset += 2;
    }
    this._vertexBuffers["offset"] = offsets;
    this.resetDrawCache();
  }
  _createIndexBuffer() {
    if (this._useInstancing) {
      return;
    }
    const indices = [];
    let index = 0;
    for (let count = 0; count < this._capacity; count++) {
      indices.push(index);
      indices.push(index + 1);
      indices.push(index + 2);
      indices.push(index);
      indices.push(index + 2);
      indices.push(index + 3);
      index += 4;
    }
    this._indexBuffer = this._engine.createIndexBuffer(indices);
  }
  getCapacity() {
    return this._capacity;
  }
  isAlive() {
    return this._alive;
  }
  isStarted() {
    return this._started;
  }
  _prepareSubEmitterInternalArray() {
    this._subEmitters = new Array();
    if (this.subEmitters) {
      this.subEmitters.forEach((subEmitter) => {
        if (subEmitter instanceof ParticleSystem) {
          this._subEmitters.push([new SubEmitter(subEmitter)]);
        } else if (subEmitter instanceof SubEmitter) {
          this._subEmitters.push([subEmitter]);
        } else if (subEmitter instanceof Array) {
          this._subEmitters.push(subEmitter);
        }
      });
    }
  }
  start(delay = this.startDelay) {
    var _a;
    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {
      throw "Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set";
    }
    if (delay) {
      setTimeout(() => {
        this.start(0);
      }, delay);
      return;
    }
    this._prepareSubEmitterInternalArray();
    this._started = true;
    this._stopped = false;
    this._actualFrame = 0;
    if (this._subEmitters && this._subEmitters.length != 0) {
      this.activeSubSystems = new Array();
    }
    if (this._emitRateGradients) {
      if (this._emitRateGradients.length > 0) {
        this._currentEmitRateGradient = this._emitRateGradients[0];
        this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();
        this._currentEmitRate2 = this._currentEmitRate1;
      }
      if (this._emitRateGradients.length > 1) {
        this._currentEmitRate2 = this._emitRateGradients[1].getFactor();
      }
    }
    if (this._startSizeGradients) {
      if (this._startSizeGradients.length > 0) {
        this._currentStartSizeGradient = this._startSizeGradients[0];
        this._currentStartSize1 = this._currentStartSizeGradient.getFactor();
        this._currentStartSize2 = this._currentStartSize1;
      }
      if (this._startSizeGradients.length > 1) {
        this._currentStartSize2 = this._startSizeGradients[1].getFactor();
      }
    }
    if (this.preWarmCycles) {
      if (((_a = this.emitter) === null || _a === void 0 ? void 0 : _a.getClassName().indexOf("Mesh")) !== -1) {
        this.emitter.computeWorldMatrix(true);
      }
      const noiseTextureAsProcedural = this.noiseTexture;
      if (noiseTextureAsProcedural && noiseTextureAsProcedural.onGeneratedObservable) {
        noiseTextureAsProcedural.onGeneratedObservable.addOnce(() => {
          setTimeout(() => {
            for (let index = 0; index < this.preWarmCycles; index++) {
              this.animate(true);
              noiseTextureAsProcedural.render();
            }
          });
        });
      } else {
        for (let index = 0; index < this.preWarmCycles; index++) {
          this.animate(true);
        }
      }
    }
    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {
      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);
    }
  }
  stop(stopSubEmitters = true) {
    if (this._stopped) {
      return;
    }
    this.onStoppedObservable.notifyObservers(this);
    this._stopped = true;
    if (stopSubEmitters) {
      this._stopSubEmitters();
    }
  }
  reset() {
    this._stockParticles.length = 0;
    this._particles.length = 0;
  }
  _appendParticleVertex(index, particle, offsetX, offsetY) {
    let offset = index * this._vertexBufferSize;
    this._vertexData[offset++] = particle.position.x + this.worldOffset.x;
    this._vertexData[offset++] = particle.position.y + this.worldOffset.y;
    this._vertexData[offset++] = particle.position.z + this.worldOffset.z;
    this._vertexData[offset++] = particle.color.r;
    this._vertexData[offset++] = particle.color.g;
    this._vertexData[offset++] = particle.color.b;
    this._vertexData[offset++] = particle.color.a;
    this._vertexData[offset++] = particle.angle;
    this._vertexData[offset++] = particle.scale.x * particle.size;
    this._vertexData[offset++] = particle.scale.y * particle.size;
    if (this._isAnimationSheetEnabled) {
      this._vertexData[offset++] = particle.cellIndex;
    }
    if (!this._isBillboardBased) {
      if (particle._initialDirection) {
        let initialDirection = particle._initialDirection;
        if (this.isLocal) {
          Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);
          initialDirection = TmpVectors.Vector3[0];
        }
        if (initialDirection.x === 0 && initialDirection.z === 0) {
          initialDirection.x = 1e-3;
        }
        this._vertexData[offset++] = initialDirection.x;
        this._vertexData[offset++] = initialDirection.y;
        this._vertexData[offset++] = initialDirection.z;
      } else {
        let direction = particle.direction;
        if (this.isLocal) {
          Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);
          direction = TmpVectors.Vector3[0];
        }
        if (direction.x === 0 && direction.z === 0) {
          direction.x = 1e-3;
        }
        this._vertexData[offset++] = direction.x;
        this._vertexData[offset++] = direction.y;
        this._vertexData[offset++] = direction.z;
      }
    } else if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {
      this._vertexData[offset++] = particle.direction.x;
      this._vertexData[offset++] = particle.direction.y;
      this._vertexData[offset++] = particle.direction.z;
    }
    if (this._useRampGradients && particle.remapData) {
      this._vertexData[offset++] = particle.remapData.x;
      this._vertexData[offset++] = particle.remapData.y;
      this._vertexData[offset++] = particle.remapData.z;
      this._vertexData[offset++] = particle.remapData.w;
    }
    if (!this._useInstancing) {
      if (this._isAnimationSheetEnabled) {
        if (offsetX === 0) {
          offsetX = this._epsilon;
        } else if (offsetX === 1) {
          offsetX = 1 - this._epsilon;
        }
        if (offsetY === 0) {
          offsetY = this._epsilon;
        } else if (offsetY === 1) {
          offsetY = 1 - this._epsilon;
        }
      }
      this._vertexData[offset++] = offsetX;
      this._vertexData[offset++] = offsetY;
    }
  }
  _stopSubEmitters() {
    if (!this.activeSubSystems) {
      return;
    }
    this.activeSubSystems.forEach((subSystem) => {
      subSystem.stop(true);
    });
    this.activeSubSystems = new Array();
  }
  _removeFromRoot() {
    if (!this._rootParticleSystem) {
      return;
    }
    const index = this._rootParticleSystem.activeSubSystems.indexOf(this);
    if (index !== -1) {
      this._rootParticleSystem.activeSubSystems.splice(index, 1);
    }
    this._rootParticleSystem = null;
  }
  _update(newParticles) {
    this._alive = this._particles.length > 0;
    if (this.emitter.position) {
      const emitterMesh = this.emitter;
      this._emitterWorldMatrix = emitterMesh.getWorldMatrix();
    } else {
      const emitterPosition = this.emitter;
      this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);
    }
    this._emitterWorldMatrix.invertToRef(this._emitterInverseWorldMatrix);
    this.updateFunction(this._particles);
    let particle;
    for (let index = 0; index < newParticles; index++) {
      if (this._particles.length === this._capacity) {
        break;
      }
      particle = this._createParticle();
      this._particles.push(particle);
      if (this.targetStopDuration && this._lifeTimeGradients && this._lifeTimeGradients.length > 0) {
        const ratio = Scalar.Clamp(this._actualFrame / this.targetStopDuration);
        GradientHelper.GetCurrentGradient(ratio, this._lifeTimeGradients, (currentGradient, nextGradient) => {
          const factorGradient1 = currentGradient;
          const factorGradient2 = nextGradient;
          const lifeTime1 = factorGradient1.getFactor();
          const lifeTime2 = factorGradient2.getFactor();
          const gradient = (ratio - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);
          particle.lifeTime = Scalar.Lerp(lifeTime1, lifeTime2, gradient);
        });
      } else {
        particle.lifeTime = Scalar.RandomRange(this.minLifeTime, this.maxLifeTime);
      }
      const emitPower = Scalar.RandomRange(this.minEmitPower, this.maxEmitPower);
      if (this.startPositionFunction) {
        this.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);
      } else {
        this.particleEmitterType.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);
      }
      if (this.isLocal) {
        if (!particle._localPosition) {
          particle._localPosition = particle.position.clone();
        } else {
          particle._localPosition.copyFrom(particle.position);
        }
        Vector3.TransformCoordinatesToRef(particle._localPosition, this._emitterWorldMatrix, particle.position);
      }
      if (this.startDirectionFunction) {
        this.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal);
      } else {
        this.particleEmitterType.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal, this._emitterInverseWorldMatrix);
      }
      if (emitPower === 0) {
        if (!particle._initialDirection) {
          particle._initialDirection = particle.direction.clone();
        } else {
          particle._initialDirection.copyFrom(particle.direction);
        }
      } else {
        particle._initialDirection = null;
      }
      particle.direction.scaleInPlace(emitPower);
      if (!this._sizeGradients || this._sizeGradients.length === 0) {
        particle.size = Scalar.RandomRange(this.minSize, this.maxSize);
      } else {
        particle._currentSizeGradient = this._sizeGradients[0];
        particle._currentSize1 = particle._currentSizeGradient.getFactor();
        particle.size = particle._currentSize1;
        if (this._sizeGradients.length > 1) {
          particle._currentSize2 = this._sizeGradients[1].getFactor();
        } else {
          particle._currentSize2 = particle._currentSize1;
        }
      }
      particle.scale.copyFromFloats(Scalar.RandomRange(this.minScaleX, this.maxScaleX), Scalar.RandomRange(this.minScaleY, this.maxScaleY));
      if (this._startSizeGradients && this._startSizeGradients[0] && this.targetStopDuration) {
        const ratio = this._actualFrame / this.targetStopDuration;
        GradientHelper.GetCurrentGradient(ratio, this._startSizeGradients, (currentGradient, nextGradient, scale) => {
          if (currentGradient !== this._currentStartSizeGradient) {
            this._currentStartSize1 = this._currentStartSize2;
            this._currentStartSize2 = nextGradient.getFactor();
            this._currentStartSizeGradient = currentGradient;
          }
          const value = Scalar.Lerp(this._currentStartSize1, this._currentStartSize2, scale);
          particle.scale.scaleInPlace(value);
        });
      }
      if (!this._angularSpeedGradients || this._angularSpeedGradients.length === 0) {
        particle.angularSpeed = Scalar.RandomRange(this.minAngularSpeed, this.maxAngularSpeed);
      } else {
        particle._currentAngularSpeedGradient = this._angularSpeedGradients[0];
        particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();
        particle._currentAngularSpeed1 = particle.angularSpeed;
        if (this._angularSpeedGradients.length > 1) {
          particle._currentAngularSpeed2 = this._angularSpeedGradients[1].getFactor();
        } else {
          particle._currentAngularSpeed2 = particle._currentAngularSpeed1;
        }
      }
      particle.angle = Scalar.RandomRange(this.minInitialRotation, this.maxInitialRotation);
      if (this._velocityGradients && this._velocityGradients.length > 0) {
        particle._currentVelocityGradient = this._velocityGradients[0];
        particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();
        if (this._velocityGradients.length > 1) {
          particle._currentVelocity2 = this._velocityGradients[1].getFactor();
        } else {
          particle._currentVelocity2 = particle._currentVelocity1;
        }
      }
      if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {
        particle._currentLimitVelocityGradient = this._limitVelocityGradients[0];
        particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();
        if (this._limitVelocityGradients.length > 1) {
          particle._currentLimitVelocity2 = this._limitVelocityGradients[1].getFactor();
        } else {
          particle._currentLimitVelocity2 = particle._currentLimitVelocity1;
        }
      }
      if (this._dragGradients && this._dragGradients.length > 0) {
        particle._currentDragGradient = this._dragGradients[0];
        particle._currentDrag1 = particle._currentDragGradient.getFactor();
        if (this._dragGradients.length > 1) {
          particle._currentDrag2 = this._dragGradients[1].getFactor();
        } else {
          particle._currentDrag2 = particle._currentDrag1;
        }
      }
      if (!this._colorGradients || this._colorGradients.length === 0) {
        const step = Scalar.RandomRange(0, 1);
        Color4.LerpToRef(this.color1, this.color2, step, particle.color);
        this.colorDead.subtractToRef(particle.color, this._colorDiff);
        this._colorDiff.scaleToRef(1 / particle.lifeTime, particle.colorStep);
      } else {
        particle._currentColorGradient = this._colorGradients[0];
        particle._currentColorGradient.getColorToRef(particle.color);
        particle._currentColor1.copyFrom(particle.color);
        if (this._colorGradients.length > 1) {
          this._colorGradients[1].getColorToRef(particle._currentColor2);
        } else {
          particle._currentColor2.copyFrom(particle.color);
        }
      }
      if (this._isAnimationSheetEnabled) {
        particle._initialStartSpriteCellID = this.startSpriteCellID;
        particle._initialEndSpriteCellID = this.endSpriteCellID;
        particle._initialSpriteCellLoop = this.spriteCellLoop;
      }
      particle.direction.addInPlace(this._inheritedVelocityOffset);
      if (this._useRampGradients) {
        particle.remapData = new Vector4(0, 1, 0, 1);
      }
      if (this.noiseTexture) {
        if (particle._randomNoiseCoordinates1) {
          particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());
          particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());
        } else {
          particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());
          particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());
        }
      }
      particle._inheritParticleInfoToSubEmitters();
    }
  }
  static _GetAttributeNamesOrOptions(isAnimationSheetEnabled = false, isBillboardBased = false, useRampGradients = false) {
    const attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, "angle", "offset", "size"];
    if (isAnimationSheetEnabled) {
      attributeNamesOrOptions.push("cellIndex");
    }
    if (!isBillboardBased) {
      attributeNamesOrOptions.push("direction");
    }
    if (useRampGradients) {
      attributeNamesOrOptions.push("remapData");
    }
    return attributeNamesOrOptions;
  }
  static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false) {
    const effectCreationOption = ["invView", "view", "projection", "textureMask", "translationPivot", "eyePosition"];
    addClipPlaneUniforms(effectCreationOption);
    if (isAnimationSheetEnabled) {
      effectCreationOption.push("particlesInfos");
    }
    if (useLogarithmicDepth) {
      effectCreationOption.push("logarithmicDepthConstant");
    }
    return effectCreationOption;
  }
  fillDefines(defines, blendMode) {
    if (this._scene) {
      prepareDefinesForClipPlanes(this, this._scene, defines);
    }
    if (this._isAnimationSheetEnabled) {
      defines.push("#define ANIMATESHEET");
    }
    if (this.useLogarithmicDepth) {
      defines.push("#define LOGARITHMICDEPTH");
    }
    if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {
      defines.push("#define BLENDMULTIPLYMODE");
    }
    if (this._useRampGradients) {
      defines.push("#define RAMPGRADIENT");
    }
    if (this._isBillboardBased) {
      defines.push("#define BILLBOARD");
      switch (this.billboardMode) {
        case ParticleSystem.BILLBOARDMODE_Y:
          defines.push("#define BILLBOARDY");
          break;
        case ParticleSystem.BILLBOARDMODE_STRETCHED:
        case ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL:
          defines.push("#define BILLBOARDSTRETCHED");
          if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {
            defines.push("#define BILLBOARDSTRETCHED_LOCAL");
          }
          break;
        case ParticleSystem.BILLBOARDMODE_ALL:
          defines.push("#define BILLBOARDMODE_ALL");
          break;
        default:
          break;
      }
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);
      defines.push(this._imageProcessingConfigurationDefines.toString());
    }
  }
  fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers) {
    attributes.push(...ParticleSystem._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled, this._isBillboardBased && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL, this._useRampGradients));
    uniforms.push(...ParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth));
    samplers.push("diffuseSampler", "rampSampler");
    if (this._imageProcessingConfiguration) {
      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);
      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);
    }
  }
  _getWrapper(blendMode) {
    const customWrapper = this._getCustomDrawWrapper(blendMode);
    if (customWrapper === null || customWrapper === void 0 ? void 0 : customWrapper.effect) {
      return customWrapper;
    }
    const defines = [];
    this.fillDefines(defines, blendMode);
    const currentRenderPassId = this._engine._features.supportRenderPasses ? this._engine.currentRenderPassId : 0;
    let drawWrappers = this._drawWrappers[currentRenderPassId];
    if (!drawWrappers) {
      drawWrappers = this._drawWrappers[currentRenderPassId] = [];
    }
    let drawWrapper = drawWrappers[blendMode];
    if (!drawWrapper) {
      drawWrapper = new DrawWrapper(this._engine);
      if (drawWrapper.drawContext) {
        drawWrapper.drawContext.useInstancing = this._useInstancing;
      }
      drawWrappers[blendMode] = drawWrapper;
    }
    const join = defines.join("\n");
    if (drawWrapper.defines !== join) {
      const attributesNamesOrOptions = [];
      const effectCreationOption = [];
      const samplers = [];
      this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);
      drawWrapper.setEffect(this._engine.createEffect("particles", attributesNamesOrOptions, effectCreationOption, samplers, join), join);
    }
    return drawWrapper;
  }
  animate(preWarmOnly = false) {
    var _a;
    if (!this._started) {
      return;
    }
    if (!preWarmOnly && this._scene) {
      if (!this.isReady()) {
        return;
      }
      if (this._currentRenderId === this._scene.getFrameId()) {
        return;
      }
      this._currentRenderId = this._scene.getFrameId();
    }
    this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getAnimationRatio()) || 1);
    let newParticles;
    if (this.manualEmitCount > -1) {
      newParticles = this.manualEmitCount;
      this._newPartsExcess = 0;
      this.manualEmitCount = 0;
    } else {
      let rate = this.emitRate;
      if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {
        const ratio = this._actualFrame / this.targetStopDuration;
        GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, (currentGradient, nextGradient, scale) => {
          if (currentGradient !== this._currentEmitRateGradient) {
            this._currentEmitRate1 = this._currentEmitRate2;
            this._currentEmitRate2 = nextGradient.getFactor();
            this._currentEmitRateGradient = currentGradient;
          }
          rate = Scalar.Lerp(this._currentEmitRate1, this._currentEmitRate2, scale);
        });
      }
      newParticles = rate * this._scaledUpdateSpeed >> 0;
      this._newPartsExcess += rate * this._scaledUpdateSpeed - newParticles;
    }
    if (this._newPartsExcess > 1) {
      newParticles += this._newPartsExcess >> 0;
      this._newPartsExcess -= this._newPartsExcess >> 0;
    }
    this._alive = false;
    if (!this._stopped) {
      this._actualFrame += this._scaledUpdateSpeed;
      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {
        this.stop();
      }
    } else {
      newParticles = 0;
    }
    this._update(newParticles);
    if (this._stopped) {
      if (!this._alive) {
        this._started = false;
        if (this.onAnimationEnd) {
          this.onAnimationEnd();
        }
        if (this.disposeOnStop && this._scene) {
          this._scene._toBeDisposed.push(this);
        }
      }
    }
    if (!preWarmOnly) {
      let offset = 0;
      for (let index = 0; index < this._particles.length; index++) {
        const particle = this._particles[index];
        this._appendParticleVertices(offset, particle);
        offset += this._useInstancing ? 1 : 4;
      }
      if (this._vertexBuffer) {
        this._vertexBuffer.updateDirectly(this._vertexData, 0, this._particles.length);
      }
    }
    if (this.manualEmitCount === 0 && this.disposeOnStop) {
      this.stop();
    }
  }
  _appendParticleVertices(offset, particle) {
    this._appendParticleVertex(offset++, particle, 0, 0);
    if (!this._useInstancing) {
      this._appendParticleVertex(offset++, particle, 1, 0);
      this._appendParticleVertex(offset++, particle, 1, 1);
      this._appendParticleVertex(offset++, particle, 0, 1);
    }
  }
  rebuild() {
    var _a, _b;
    if (this._engine.getCaps().vertexArrayObject) {
      this._vertexArrayObject = null;
    }
    this._createIndexBuffer();
    (_a = this._spriteBuffer) === null || _a === void 0 ? void 0 : _a._rebuild();
    (_b = this._vertexBuffer) === null || _b === void 0 ? void 0 : _b._rebuild();
    for (const key in this._vertexBuffers) {
      this._vertexBuffers[key]._rebuild();
    }
    this.resetDrawCache();
  }
  isReady() {
    if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {
      return false;
    }
    if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {
      if (!this._getWrapper(this.blendMode).effect.isReady()) {
        return false;
      }
    } else {
      if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect.isReady()) {
        return false;
      }
      if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect.isReady()) {
        return false;
      }
    }
    return true;
  }
  _render(blendMode) {
    var _a, _b;
    const drawWrapper = this._getWrapper(blendMode);
    const effect = drawWrapper.effect;
    const engine = this._engine;
    engine.enableEffect(drawWrapper);
    const viewMatrix = (_a = this.defaultViewMatrix) !== null && _a !== void 0 ? _a : this._scene.getViewMatrix();
    effect.setTexture("diffuseSampler", this.particleTexture);
    effect.setMatrix("view", viewMatrix);
    effect.setMatrix("projection", (_b = this.defaultProjectionMatrix) !== null && _b !== void 0 ? _b : this._scene.getProjectionMatrix());
    if (this._isAnimationSheetEnabled && this.particleTexture) {
      const baseSize = this.particleTexture.getBaseSize();
      effect.setFloat3("particlesInfos", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);
    }
    effect.setVector2("translationPivot", this.translationPivot);
    effect.setFloat4("textureMask", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);
    if (this._isBillboardBased && this._scene) {
      const camera = this._scene.activeCamera;
      effect.setVector3("eyePosition", camera.globalPosition);
    }
    if (this._rampGradientsTexture) {
      if (!this._rampGradients || !this._rampGradients.length) {
        this._rampGradientsTexture.dispose();
        this._rampGradientsTexture = null;
      }
      effect.setTexture("rampSampler", this._rampGradientsTexture);
    }
    const defines = effect.defines;
    if (this._scene) {
      bindClipPlane(effect, this, this._scene);
    }
    if (defines.indexOf("#define BILLBOARDMODE_ALL") >= 0) {
      viewMatrix.invertToRef(TmpVectors.Matrix[0]);
      effect.setMatrix("invView", TmpVectors.Matrix[0]);
    }
    if (this._vertexArrayObject !== void 0) {
      if (!this._vertexArrayObject) {
        this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);
      }
      this._engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);
    } else {
      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
    }
    if (this.useLogarithmicDepth && this._scene) {
      MaterialHelper.BindLogDepth(defines, effect, this._scene);
    }
    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
      this._imageProcessingConfiguration.bind(effect);
    }
    switch (blendMode) {
      case ParticleSystem.BLENDMODE_ADD:
        engine.setAlphaMode(1);
        break;
      case ParticleSystem.BLENDMODE_ONEONE:
        engine.setAlphaMode(6);
        break;
      case ParticleSystem.BLENDMODE_STANDARD:
        engine.setAlphaMode(2);
        break;
      case ParticleSystem.BLENDMODE_MULTIPLY:
        engine.setAlphaMode(4);
        break;
    }
    if (this._onBeforeDrawParticlesObservable) {
      this._onBeforeDrawParticlesObservable.notifyObservers(effect);
    }
    if (this._useInstancing) {
      engine.drawArraysType(7, 0, 4, this._particles.length);
    } else {
      engine.drawElementsType(0, 0, this._particles.length * 6);
    }
    return this._particles.length;
  }
  render() {
    if (!this.isReady() || !this._particles.length) {
      return 0;
    }
    const engine = this._engine;
    if (engine.setState) {
      engine.setState(false);
      if (this.forceDepthWrite) {
        engine.setDepthWrite(true);
      }
    }
    let outparticles = 0;
    if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {
      outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY) + this._render(ParticleSystem.BLENDMODE_ADD);
    } else {
      outparticles = this._render(this.blendMode);
    }
    this._engine.unbindInstanceAttributes();
    this._engine.setAlphaMode(0);
    return outparticles;
  }
  dispose(disposeTexture = true) {
    this.resetDrawCache();
    if (this._vertexBuffer) {
      this._vertexBuffer.dispose();
      this._vertexBuffer = null;
    }
    if (this._spriteBuffer) {
      this._spriteBuffer.dispose();
      this._spriteBuffer = null;
    }
    if (this._indexBuffer) {
      this._engine._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    if (this._vertexArrayObject) {
      this._engine.releaseVertexArrayObject(this._vertexArrayObject);
      this._vertexArrayObject = null;
    }
    if (disposeTexture && this.particleTexture) {
      this.particleTexture.dispose();
      this.particleTexture = null;
    }
    if (disposeTexture && this.noiseTexture) {
      this.noiseTexture.dispose();
      this.noiseTexture = null;
    }
    if (this._rampGradientsTexture) {
      this._rampGradientsTexture.dispose();
      this._rampGradientsTexture = null;
    }
    this._removeFromRoot();
    if (this.subEmitters && !this._subEmitters) {
      this._prepareSubEmitterInternalArray();
    }
    if (this._subEmitters && this._subEmitters.length) {
      for (let index = 0; index < this._subEmitters.length; index++) {
        for (const subEmitter of this._subEmitters[index]) {
          subEmitter.dispose();
        }
      }
      this._subEmitters = [];
      this.subEmitters = [];
    }
    if (this._disposeEmitterOnDispose && this.emitter && this.emitter.dispose) {
      this.emitter.dispose(true);
    }
    if (this._onBeforeDrawParticlesObservable) {
      this._onBeforeDrawParticlesObservable.clear();
    }
    if (this._scene) {
      const index = this._scene.particleSystems.indexOf(this);
      if (index > -1) {
        this._scene.particleSystems.splice(index, 1);
      }
      this._scene._activeParticleSystems.dispose();
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onStoppedObservable.clear();
    this.reset();
  }
  clone(name137, newEmitter, cloneTexture = false) {
    const custom = { ...this._customWrappers };
    let program = null;
    const engine = this._engine;
    if (engine.createEffectForParticles) {
      if (this.customShader != null) {
        program = this.customShader;
        const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
        const effect = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);
        if (!custom[0]) {
          this.setCustomEffect(effect, 0);
        } else {
          custom[0].effect = effect;
        }
      }
    }
    const serialization = this.serialize(cloneTexture);
    const result = ParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);
    result.name = name137;
    result.customShader = program;
    result._customWrappers = custom;
    if (newEmitter === void 0) {
      newEmitter = this.emitter;
    }
    if (this.noiseTexture) {
      result.noiseTexture = this.noiseTexture.clone();
    }
    result.emitter = newEmitter;
    if (!this.preventAutoStart) {
      result.start();
    }
    return result;
  }
  serialize(serializeTexture = false) {
    const serializationObject = {};
    ParticleSystem._Serialize(serializationObject, this, serializeTexture);
    serializationObject.textureMask = this.textureMask.asArray();
    serializationObject.customShader = this.customShader;
    serializationObject.preventAutoStart = this.preventAutoStart;
    if (this.subEmitters) {
      serializationObject.subEmitters = [];
      if (!this._subEmitters) {
        this._prepareSubEmitterInternalArray();
      }
      for (const subs of this._subEmitters) {
        const cell = [];
        for (const sub of subs) {
          cell.push(sub.serialize(serializeTexture));
        }
        serializationObject.subEmitters.push(cell);
      }
    }
    return serializationObject;
  }
  static _Serialize(serializationObject, particleSystem, serializeTexture) {
    serializationObject.name = particleSystem.name;
    serializationObject.id = particleSystem.id;
    serializationObject.capacity = particleSystem.getCapacity();
    serializationObject.disposeOnStop = particleSystem.disposeOnStop;
    serializationObject.manualEmitCount = particleSystem.manualEmitCount;
    if (particleSystem.emitter.position) {
      const emitterMesh = particleSystem.emitter;
      serializationObject.emitterId = emitterMesh.id;
    } else {
      const emitterPosition = particleSystem.emitter;
      serializationObject.emitter = emitterPosition.asArray();
    }
    if (particleSystem.particleEmitterType) {
      serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();
    }
    if (particleSystem.particleTexture) {
      if (serializeTexture) {
        serializationObject.texture = particleSystem.particleTexture.serialize();
      } else {
        serializationObject.textureName = particleSystem.particleTexture.name;
        serializationObject.invertY = !!particleSystem.particleTexture._invertY;
      }
    }
    serializationObject.isLocal = particleSystem.isLocal;
    SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);
    serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;
    serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;
    serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;
    serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop;
    serializationObject.startDelay = particleSystem.startDelay;
    serializationObject.renderingGroupId = particleSystem.renderingGroupId;
    serializationObject.isBillboardBased = particleSystem.isBillboardBased;
    serializationObject.billboardMode = particleSystem.billboardMode;
    serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;
    serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;
    serializationObject.minSize = particleSystem.minSize;
    serializationObject.maxSize = particleSystem.maxSize;
    serializationObject.minScaleX = particleSystem.minScaleX;
    serializationObject.maxScaleX = particleSystem.maxScaleX;
    serializationObject.minScaleY = particleSystem.minScaleY;
    serializationObject.maxScaleY = particleSystem.maxScaleY;
    serializationObject.minEmitPower = particleSystem.minEmitPower;
    serializationObject.maxEmitPower = particleSystem.maxEmitPower;
    serializationObject.minLifeTime = particleSystem.minLifeTime;
    serializationObject.maxLifeTime = particleSystem.maxLifeTime;
    serializationObject.emitRate = particleSystem.emitRate;
    serializationObject.gravity = particleSystem.gravity.asArray();
    serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();
    serializationObject.color1 = particleSystem.color1.asArray();
    serializationObject.color2 = particleSystem.color2.asArray();
    serializationObject.colorDead = particleSystem.colorDead.asArray();
    serializationObject.updateSpeed = particleSystem.updateSpeed;
    serializationObject.targetStopDuration = particleSystem.targetStopDuration;
    serializationObject.blendMode = particleSystem.blendMode;
    serializationObject.preWarmCycles = particleSystem.preWarmCycles;
    serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;
    serializationObject.minInitialRotation = particleSystem.minInitialRotation;
    serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;
    serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;
    serializationObject.spriteCellLoop = particleSystem.spriteCellLoop;
    serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;
    serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;
    serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;
    serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;
    serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;
    serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;
    serializationObject.useLogarithmicDepth = particleSystem.useLogarithmicDepth;
    const colorGradients = particleSystem.getColorGradients();
    if (colorGradients) {
      serializationObject.colorGradients = [];
      for (const colorGradient of colorGradients) {
        const serializedGradient = {
          gradient: colorGradient.gradient,
          color1: colorGradient.color1.asArray()
        };
        if (colorGradient.color2) {
          serializedGradient.color2 = colorGradient.color2.asArray();
        } else {
          serializedGradient.color2 = colorGradient.color1.asArray();
        }
        serializationObject.colorGradients.push(serializedGradient);
      }
    }
    const rampGradients = particleSystem.getRampGradients();
    if (rampGradients) {
      serializationObject.rampGradients = [];
      for (const rampGradient of rampGradients) {
        const serializedGradient = {
          gradient: rampGradient.gradient,
          color: rampGradient.color.asArray()
        };
        serializationObject.rampGradients.push(serializedGradient);
      }
      serializationObject.useRampGradients = particleSystem.useRampGradients;
    }
    const colorRemapGradients = particleSystem.getColorRemapGradients();
    if (colorRemapGradients) {
      serializationObject.colorRemapGradients = [];
      for (const colorRemapGradient of colorRemapGradients) {
        const serializedGradient = {
          gradient: colorRemapGradient.gradient,
          factor1: colorRemapGradient.factor1
        };
        if (colorRemapGradient.factor2 !== void 0) {
          serializedGradient.factor2 = colorRemapGradient.factor2;
        } else {
          serializedGradient.factor2 = colorRemapGradient.factor1;
        }
        serializationObject.colorRemapGradients.push(serializedGradient);
      }
    }
    const alphaRemapGradients = particleSystem.getAlphaRemapGradients();
    if (alphaRemapGradients) {
      serializationObject.alphaRemapGradients = [];
      for (const alphaRemapGradient of alphaRemapGradients) {
        const serializedGradient = {
          gradient: alphaRemapGradient.gradient,
          factor1: alphaRemapGradient.factor1
        };
        if (alphaRemapGradient.factor2 !== void 0) {
          serializedGradient.factor2 = alphaRemapGradient.factor2;
        } else {
          serializedGradient.factor2 = alphaRemapGradient.factor1;
        }
        serializationObject.alphaRemapGradients.push(serializedGradient);
      }
    }
    const sizeGradients = particleSystem.getSizeGradients();
    if (sizeGradients) {
      serializationObject.sizeGradients = [];
      for (const sizeGradient of sizeGradients) {
        const serializedGradient = {
          gradient: sizeGradient.gradient,
          factor1: sizeGradient.factor1
        };
        if (sizeGradient.factor2 !== void 0) {
          serializedGradient.factor2 = sizeGradient.factor2;
        } else {
          serializedGradient.factor2 = sizeGradient.factor1;
        }
        serializationObject.sizeGradients.push(serializedGradient);
      }
    }
    const angularSpeedGradients = particleSystem.getAngularSpeedGradients();
    if (angularSpeedGradients) {
      serializationObject.angularSpeedGradients = [];
      for (const angularSpeedGradient of angularSpeedGradients) {
        const serializedGradient = {
          gradient: angularSpeedGradient.gradient,
          factor1: angularSpeedGradient.factor1
        };
        if (angularSpeedGradient.factor2 !== void 0) {
          serializedGradient.factor2 = angularSpeedGradient.factor2;
        } else {
          serializedGradient.factor2 = angularSpeedGradient.factor1;
        }
        serializationObject.angularSpeedGradients.push(serializedGradient);
      }
    }
    const velocityGradients = particleSystem.getVelocityGradients();
    if (velocityGradients) {
      serializationObject.velocityGradients = [];
      for (const velocityGradient of velocityGradients) {
        const serializedGradient = {
          gradient: velocityGradient.gradient,
          factor1: velocityGradient.factor1
        };
        if (velocityGradient.factor2 !== void 0) {
          serializedGradient.factor2 = velocityGradient.factor2;
        } else {
          serializedGradient.factor2 = velocityGradient.factor1;
        }
        serializationObject.velocityGradients.push(serializedGradient);
      }
    }
    const dragGradients = particleSystem.getDragGradients();
    if (dragGradients) {
      serializationObject.dragGradients = [];
      for (const dragGradient of dragGradients) {
        const serializedGradient = {
          gradient: dragGradient.gradient,
          factor1: dragGradient.factor1
        };
        if (dragGradient.factor2 !== void 0) {
          serializedGradient.factor2 = dragGradient.factor2;
        } else {
          serializedGradient.factor2 = dragGradient.factor1;
        }
        serializationObject.dragGradients.push(serializedGradient);
      }
    }
    const emitRateGradients = particleSystem.getEmitRateGradients();
    if (emitRateGradients) {
      serializationObject.emitRateGradients = [];
      for (const emitRateGradient of emitRateGradients) {
        const serializedGradient = {
          gradient: emitRateGradient.gradient,
          factor1: emitRateGradient.factor1
        };
        if (emitRateGradient.factor2 !== void 0) {
          serializedGradient.factor2 = emitRateGradient.factor2;
        } else {
          serializedGradient.factor2 = emitRateGradient.factor1;
        }
        serializationObject.emitRateGradients.push(serializedGradient);
      }
    }
    const startSizeGradients = particleSystem.getStartSizeGradients();
    if (startSizeGradients) {
      serializationObject.startSizeGradients = [];
      for (const startSizeGradient of startSizeGradients) {
        const serializedGradient = {
          gradient: startSizeGradient.gradient,
          factor1: startSizeGradient.factor1
        };
        if (startSizeGradient.factor2 !== void 0) {
          serializedGradient.factor2 = startSizeGradient.factor2;
        } else {
          serializedGradient.factor2 = startSizeGradient.factor1;
        }
        serializationObject.startSizeGradients.push(serializedGradient);
      }
    }
    const lifeTimeGradients = particleSystem.getLifeTimeGradients();
    if (lifeTimeGradients) {
      serializationObject.lifeTimeGradients = [];
      for (const lifeTimeGradient of lifeTimeGradients) {
        const serializedGradient = {
          gradient: lifeTimeGradient.gradient,
          factor1: lifeTimeGradient.factor1
        };
        if (lifeTimeGradient.factor2 !== void 0) {
          serializedGradient.factor2 = lifeTimeGradient.factor2;
        } else {
          serializedGradient.factor2 = lifeTimeGradient.factor1;
        }
        serializationObject.lifeTimeGradients.push(serializedGradient);
      }
    }
    const limitVelocityGradients = particleSystem.getLimitVelocityGradients();
    if (limitVelocityGradients) {
      serializationObject.limitVelocityGradients = [];
      for (const limitVelocityGradient of limitVelocityGradients) {
        const serializedGradient = {
          gradient: limitVelocityGradient.gradient,
          factor1: limitVelocityGradient.factor1
        };
        if (limitVelocityGradient.factor2 !== void 0) {
          serializedGradient.factor2 = limitVelocityGradient.factor2;
        } else {
          serializedGradient.factor2 = limitVelocityGradient.factor1;
        }
        serializationObject.limitVelocityGradients.push(serializedGradient);
      }
      serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;
    }
    if (particleSystem.noiseTexture) {
      serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();
    }
  }
  static _Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl) {
    var _a, _b, _c;
    let scene;
    if (sceneOrEngine instanceof ThinEngine) {
      scene = null;
    } else {
      scene = sceneOrEngine;
    }
    const internalClass = GetClass("BABYLON.Texture");
    if (internalClass && scene) {
      if (parsedParticleSystem.texture) {
        particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl);
      } else if (parsedParticleSystem.textureName) {
        particleSystem.particleTexture = new internalClass(rootUrl + parsedParticleSystem.textureName, scene, false, parsedParticleSystem.invertY !== void 0 ? parsedParticleSystem.invertY : true);
        particleSystem.particleTexture.name = parsedParticleSystem.textureName;
      }
    }
    if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === void 0) {
      particleSystem.emitter = Vector3.Zero();
    } else if (parsedParticleSystem.emitterId && scene) {
      particleSystem.emitter = scene.getLastMeshById(parsedParticleSystem.emitterId);
    } else {
      particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);
    }
    particleSystem.isLocal = !!parsedParticleSystem.isLocal;
    if (parsedParticleSystem.renderingGroupId !== void 0) {
      particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;
    }
    if (parsedParticleSystem.isBillboardBased !== void 0) {
      particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;
    }
    if (parsedParticleSystem.billboardMode !== void 0) {
      particleSystem.billboardMode = parsedParticleSystem.billboardMode;
    }
    if (parsedParticleSystem.useLogarithmicDepth !== void 0) {
      particleSystem.useLogarithmicDepth = parsedParticleSystem.useLogarithmicDepth;
    }
    if (parsedParticleSystem.animations) {
      for (let animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {
        const parsedAnimation = parsedParticleSystem.animations[animationIndex];
        const internalClass2 = GetClass("BABYLON.Animation");
        if (internalClass2) {
          particleSystem.animations.push(internalClass2.Parse(parsedAnimation));
        }
      }
      particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;
      particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;
      particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;
      particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;
    }
    if (parsedParticleSystem.autoAnimate && scene) {
      scene.beginAnimation(particleSystem, parsedParticleSystem.autoAnimateFrom, parsedParticleSystem.autoAnimateTo, parsedParticleSystem.autoAnimateLoop, parsedParticleSystem.autoAnimateSpeed || 1);
    }
    particleSystem.startDelay = parsedParticleSystem.startDelay | 0;
    particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;
    particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;
    particleSystem.minSize = parsedParticleSystem.minSize;
    particleSystem.maxSize = parsedParticleSystem.maxSize;
    if (parsedParticleSystem.minScaleX) {
      particleSystem.minScaleX = parsedParticleSystem.minScaleX;
      particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;
      particleSystem.minScaleY = parsedParticleSystem.minScaleY;
      particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;
    }
    if (parsedParticleSystem.preWarmCycles !== void 0) {
      particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;
      particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;
    }
    if (parsedParticleSystem.minInitialRotation !== void 0) {
      particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;
      particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;
    }
    particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;
    particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;
    particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;
    particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;
    particleSystem.emitRate = parsedParticleSystem.emitRate;
    particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);
    if (parsedParticleSystem.noiseStrength) {
      particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);
    }
    particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);
    particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);
    particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);
    particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;
    particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;
    particleSystem.blendMode = parsedParticleSystem.blendMode;
    if (parsedParticleSystem.colorGradients) {
      for (const colorGradient of parsedParticleSystem.colorGradients) {
        particleSystem.addColorGradient(colorGradient.gradient, Color4.FromArray(colorGradient.color1), colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : void 0);
      }
    }
    if (parsedParticleSystem.rampGradients) {
      for (const rampGradient of parsedParticleSystem.rampGradients) {
        particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));
      }
      particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;
    }
    if (parsedParticleSystem.colorRemapGradients) {
      for (const colorRemapGradient of parsedParticleSystem.colorRemapGradients) {
        particleSystem.addColorRemapGradient(colorRemapGradient.gradient, colorRemapGradient.factor1 !== void 0 ? colorRemapGradient.factor1 : colorRemapGradient.factor, colorRemapGradient.factor2);
      }
    }
    if (parsedParticleSystem.alphaRemapGradients) {
      for (const alphaRemapGradient of parsedParticleSystem.alphaRemapGradients) {
        particleSystem.addAlphaRemapGradient(alphaRemapGradient.gradient, alphaRemapGradient.factor1 !== void 0 ? alphaRemapGradient.factor1 : alphaRemapGradient.factor, alphaRemapGradient.factor2);
      }
    }
    if (parsedParticleSystem.sizeGradients) {
      for (const sizeGradient of parsedParticleSystem.sizeGradients) {
        particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== void 0 ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);
      }
    }
    if (parsedParticleSystem.angularSpeedGradients) {
      for (const angularSpeedGradient of parsedParticleSystem.angularSpeedGradients) {
        particleSystem.addAngularSpeedGradient(angularSpeedGradient.gradient, angularSpeedGradient.factor1 !== void 0 ? angularSpeedGradient.factor1 : angularSpeedGradient.factor, angularSpeedGradient.factor2);
      }
    }
    if (parsedParticleSystem.velocityGradients) {
      for (const velocityGradient of parsedParticleSystem.velocityGradients) {
        particleSystem.addVelocityGradient(velocityGradient.gradient, velocityGradient.factor1 !== void 0 ? velocityGradient.factor1 : velocityGradient.factor, velocityGradient.factor2);
      }
    }
    if (parsedParticleSystem.dragGradients) {
      for (const dragGradient of parsedParticleSystem.dragGradients) {
        particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== void 0 ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);
      }
    }
    if (parsedParticleSystem.emitRateGradients) {
      for (const emitRateGradient of parsedParticleSystem.emitRateGradients) {
        particleSystem.addEmitRateGradient(emitRateGradient.gradient, emitRateGradient.factor1 !== void 0 ? emitRateGradient.factor1 : emitRateGradient.factor, emitRateGradient.factor2);
      }
    }
    if (parsedParticleSystem.startSizeGradients) {
      for (const startSizeGradient of parsedParticleSystem.startSizeGradients) {
        particleSystem.addStartSizeGradient(startSizeGradient.gradient, startSizeGradient.factor1 !== void 0 ? startSizeGradient.factor1 : startSizeGradient.factor, startSizeGradient.factor2);
      }
    }
    if (parsedParticleSystem.lifeTimeGradients) {
      for (const lifeTimeGradient of parsedParticleSystem.lifeTimeGradients) {
        particleSystem.addLifeTimeGradient(lifeTimeGradient.gradient, lifeTimeGradient.factor1 !== void 0 ? lifeTimeGradient.factor1 : lifeTimeGradient.factor, lifeTimeGradient.factor2);
      }
    }
    if (parsedParticleSystem.limitVelocityGradients) {
      for (const limitVelocityGradient of parsedParticleSystem.limitVelocityGradients) {
        particleSystem.addLimitVelocityGradient(limitVelocityGradient.gradient, limitVelocityGradient.factor1 !== void 0 ? limitVelocityGradient.factor1 : limitVelocityGradient.factor, limitVelocityGradient.factor2);
      }
      particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;
    }
    if (parsedParticleSystem.noiseTexture && scene) {
      const internalClass2 = GetClass("BABYLON.ProceduralTexture");
      particleSystem.noiseTexture = internalClass2.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);
    }
    let emitterType;
    if (parsedParticleSystem.particleEmitterType) {
      switch (parsedParticleSystem.particleEmitterType.type) {
        case "SphereParticleEmitter":
          emitterType = new SphereParticleEmitter();
          break;
        case "SphereDirectedParticleEmitter":
          emitterType = new SphereDirectedParticleEmitter();
          break;
        case "ConeEmitter":
        case "ConeParticleEmitter":
          emitterType = new ConeParticleEmitter();
          break;
        case "CylinderParticleEmitter":
          emitterType = new CylinderParticleEmitter();
          break;
        case "CylinderDirectedParticleEmitter":
          emitterType = new CylinderDirectedParticleEmitter();
          break;
        case "HemisphericParticleEmitter":
          emitterType = new HemisphericParticleEmitter();
          break;
        case "PointParticleEmitter":
          emitterType = new PointParticleEmitter();
          break;
        case "MeshParticleEmitter":
          emitterType = new MeshParticleEmitter();
          break;
        case "BoxEmitter":
        case "BoxParticleEmitter":
        default:
          emitterType = new BoxParticleEmitter();
          break;
      }
      emitterType.parse(parsedParticleSystem.particleEmitterType, scene);
    } else {
      emitterType = new BoxParticleEmitter();
      emitterType.parse(parsedParticleSystem, scene);
    }
    particleSystem.particleEmitterType = emitterType;
    particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;
    particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;
    particleSystem.spriteCellLoop = (_a = parsedParticleSystem.spriteCellLoop) !== null && _a !== void 0 ? _a : true;
    particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;
    particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;
    particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;
    particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;
    particleSystem.disposeOnStop = (_b = parsedParticleSystem.disposeOnStop) !== null && _b !== void 0 ? _b : false;
    particleSystem.manualEmitCount = (_c = parsedParticleSystem.manualEmitCount) !== null && _c !== void 0 ? _c : -1;
  }
  static Parse(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart = false, capacity) {
    const name137 = parsedParticleSystem.name;
    let custom = null;
    let program = null;
    let engine;
    let scene;
    if (sceneOrEngine instanceof ThinEngine) {
      engine = sceneOrEngine;
    } else {
      scene = sceneOrEngine;
      engine = scene.getEngine();
    }
    if (parsedParticleSystem.customShader && engine.createEffectForParticles) {
      program = parsedParticleSystem.customShader;
      const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
      custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);
    }
    const particleSystem = new ParticleSystem(name137, capacity || parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);
    particleSystem.customShader = program;
    particleSystem._rootUrl = rootUrl;
    if (parsedParticleSystem.id) {
      particleSystem.id = parsedParticleSystem.id;
    }
    if (parsedParticleSystem.subEmitters) {
      particleSystem.subEmitters = [];
      for (const cell of parsedParticleSystem.subEmitters) {
        const cellArray = [];
        for (const sub of cell) {
          cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));
        }
        particleSystem.subEmitters.push(cellArray);
      }
    }
    ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);
    if (parsedParticleSystem.textureMask) {
      particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);
    }
    if (parsedParticleSystem.preventAutoStart) {
      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;
    }
    if (!doNotStart && !particleSystem.preventAutoStart) {
      particleSystem.start();
    }
    return particleSystem;
  }
};
ParticleSystem.BILLBOARDMODE_Y = 2;
ParticleSystem.BILLBOARDMODE_ALL = 7;
ParticleSystem.BILLBOARDMODE_STRETCHED = 8;
ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL = 9;
SubEmitter._ParseParticleSystem = ParticleSystem.Parse;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration2.js
var name70 = "clipPlaneFragmentDeclaration2";
var shader70 = `#ifdef CLIPPLANE
in float fClipDistance;
#endif
#ifdef CLIPPLANE2
in float fClipDistance2;
#endif
#ifdef CLIPPLANE3
in float fClipDistance3;
#endif
#ifdef CLIPPLANE4
in float fClipDistance4;
#endif
#ifdef CLIPPLANE5
in float fClipDistance5;
#endif
#ifdef CLIPPLANE6
in float fClipDistance6;
#endif
`;
ShaderStore.IncludesShadersStore[name70] = shader70;

// node_modules/@babylonjs/core/Shaders/gpuRenderParticles.fragment.js
var name71 = "gpuRenderParticlesPixelShader";
var shader71 = `precision highp float;
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
uniform sampler2D diffuseSampler;
varying vec2 vUV;
varying vec4 vColor;
#include<clipPlaneFragmentDeclaration2> 
#include<imageProcessingDeclaration>
#include<logDepthDeclaration>
#include<helperFunctions>
#include<imageProcessingFunctions>
void main() {
#include<clipPlaneFragment> 
vec4 textureColor=texture2D(diffuseSampler,vUV);
gl_FragColor=textureColor*vColor;
#ifdef BLENDMULTIPLYMODE
float alpha=vColor.a*textureColor.a;
gl_FragColor.rgb=gl_FragColor.rgb*alpha+vec3(1.0)*(1.0-alpha);
#endif 
#include<logDepthFragment>
#ifdef IMAGEPROCESSINGPOSTPROCESS
gl_FragColor.rgb=toLinearSpace(gl_FragColor.rgb);
#else
#ifdef IMAGEPROCESSING
gl_FragColor.rgb=toLinearSpace(gl_FragColor.rgb);
gl_FragColor=applyImageProcessing(gl_FragColor);
#endif
#endif
}
`;
ShaderStore.ShadersStore[name71] = shader71;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration2.js
var name72 = "clipPlaneVertexDeclaration2";
var shader72 = `#ifdef CLIPPLANE
uniform vec4 vClipPlane;
out float fClipDistance;
#endif
#ifdef CLIPPLANE2
uniform vec4 vClipPlane2;
out float fClipDistance2;
#endif
#ifdef CLIPPLANE3
uniform vec4 vClipPlane3;
out float fClipDistance3;
#endif
#ifdef CLIPPLANE4
uniform vec4 vClipPlane4;
out float fClipDistance4;
#endif
#ifdef CLIPPLANE5
uniform vec4 vClipPlane5;
out float fClipDistance5;
#endif
#ifdef CLIPPLANE6
uniform vec4 vClipPlane6;
out float fClipDistance6;
#endif
`;
ShaderStore.IncludesShadersStore[name72] = shader72;

// node_modules/@babylonjs/core/Shaders/gpuRenderParticles.vertex.js
var name73 = "gpuRenderParticlesVertexShader";
var shader73 = `precision highp float;
uniform mat4 view;
uniform mat4 projection;
uniform vec2 translationPivot;
uniform vec3 worldOffset;
#ifdef LOCAL
uniform mat4 emitterWM;
#endif
attribute vec3 position;
attribute float age;
attribute float life;
attribute vec3 size;
#ifndef BILLBOARD
attribute vec3 initialDirection;
#endif
#ifdef BILLBOARDSTRETCHED
attribute vec3 direction;
#endif
attribute float angle;
#ifdef ANIMATESHEET
attribute float cellIndex;
#endif
attribute vec2 offset;
attribute vec2 uv;
varying vec2 vUV;
varying vec4 vColor;
varying vec3 vPositionW;
#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)
uniform mat4 invView;
#endif
#include<clipPlaneVertexDeclaration2>
#include<logDepthDeclaration>
#ifdef COLORGRADIENTS
uniform sampler2D colorGradientSampler;
#else
uniform vec4 colorDead;
attribute vec4 color;
#endif
#ifdef ANIMATESHEET
uniform vec3 sheetInfos;
#endif
#ifdef BILLBOARD
uniform vec3 eyePosition;
#endif
vec3 rotate(vec3 yaxis,vec3 rotatedCorner) {
vec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));
vec3 zaxis=normalize(cross(yaxis,xaxis));
vec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);
vec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);
vec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);
mat3 rotMatrix= mat3(row0,row1,row2);
vec3 alignedCorner=rotMatrix*rotatedCorner;
#ifdef LOCAL
return ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;
#else
return (position+worldOffset)+alignedCorner;
#endif
}
#ifdef BILLBOARDSTRETCHED
vec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {
vec3 normalizedToCamera=normalize(toCamera);
vec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));
vec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));
vec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);
vec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);
vec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);
mat3 rotMatrix= mat3(row0,row1,row2);
vec3 alignedCorner=rotMatrix*rotatedCorner;
#ifdef LOCAL
return ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;
#else
return (position+worldOffset)+alignedCorner;
#endif
}
#endif
void main() {
#ifdef ANIMATESHEET
float rowOffset=floor(cellIndex/sheetInfos.z);
float columnOffset=cellIndex-rowOffset*sheetInfos.z;
vec2 uvScale=sheetInfos.xy;
vec2 uvOffset=vec2(uv.x ,1.0-uv.y);
vUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;
#else
vUV=uv;
#endif
float ratio=age/life;
#ifdef COLORGRADIENTS
vColor=texture2D(colorGradientSampler,vec2(ratio,0));
#else
vColor=color*vec4(1.0-ratio)+colorDead*vec4(ratio);
#endif
vec2 cornerPos=(offset-translationPivot)*size.yz*size.x+translationPivot;
#ifdef BILLBOARD
vec4 rotatedCorner;
rotatedCorner.w=0.;
#ifdef BILLBOARDY
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);
rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);
rotatedCorner.y=0.;
vec3 yaxis=(position+worldOffset)-eyePosition;
yaxis.y=0.;
vPositionW=rotate(normalize(yaxis),rotatedCorner.xyz);
vec4 viewPosition=(view*vec4(vPositionW,1.0));
#elif defined(BILLBOARDSTRETCHED)
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);
rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);
rotatedCorner.z=0.;
vec3 toCamera=(position+worldOffset)-eyePosition;
vPositionW=rotateAlign(toCamera,rotatedCorner.xyz);
vec4 viewPosition=(view*vec4(vPositionW,1.0));
#else
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);
rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);
rotatedCorner.z=0.;
#ifdef LOCAL
vec4 viewPosition=view*vec4(((emitterWM*vec4(position,1.0)).xyz+worldOffset),1.0)+rotatedCorner;
#else
vec4 viewPosition=view*vec4((position+worldOffset),1.0)+rotatedCorner;
#endif
vPositionW=(invView*viewPosition).xyz;
#endif
#else
vec3 rotatedCorner;
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);
rotatedCorner.y=0.;
rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);
vec3 yaxis=normalize(initialDirection);
vPositionW=rotate(yaxis,rotatedCorner);
vec4 viewPosition=view*vec4(vPositionW,1.0);
#endif
gl_Position=projection*viewPosition;
#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
vec4 worldPos=vec4(vPositionW,1.0);
#endif
#include<clipPlaneVertex>
#include<logDepthVertex>
}`;
ShaderStore.ShadersStore[name73] = shader73;

// node_modules/@babylonjs/core/Particles/gpuParticleSystem.js
var GPUParticleSystem = class extends BaseParticleSystem {
  constructor(name137, options, sceneOrEngine, customEffect = null, isAnimationSheetEnabled = false) {
    super(name137);
    this.layerMask = 268435455;
    this._accumulatedCount = 0;
    this._renderVertexBuffers = [];
    this._targetIndex = 0;
    this._currentRenderId = -1;
    this._currentRenderingCameraUniqueId = -1;
    this._started = false;
    this._stopped = false;
    this._timeDelta = 0;
    this.updateInAnimate = false;
    this._actualFrame = 0;
    this._rawTextureWidth = 256;
    this.onDisposeObservable = new Observable();
    this.onStoppedObservable = new Observable();
    this.forceDepthWrite = false;
    this._preWarmDone = false;
    this.isLocal = false;
    this.isGPU = true;
    this._onBeforeDrawParticlesObservable = null;
    if (!sceneOrEngine || sceneOrEngine.getClassName() === "Scene") {
      this._scene = sceneOrEngine || EngineStore.LastCreatedScene;
      this._engine = this._scene.getEngine();
      this.uniqueId = this._scene.getUniqueId();
      this._scene.particleSystems.push(this);
    } else {
      this._engine = sceneOrEngine;
      this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);
    }
    if (this._engine.getCaps().supportComputeShaders) {
      if (!GetClass("BABYLON.ComputeShaderParticleSystem")) {
        throw new Error("The ComputeShaderParticleSystem class is not available! Make sure you have imported it.");
      }
      this._platform = new (GetClass("BABYLON.ComputeShaderParticleSystem"))(this, this._engine);
    } else {
      if (!GetClass("BABYLON.WebGL2ParticleSystem")) {
        throw new Error("The WebGL2ParticleSystem class is not available! Make sure you have imported it.");
      }
      this._platform = new (GetClass("BABYLON.WebGL2ParticleSystem"))(this, this._engine);
    }
    this._customWrappers = { 0: new DrawWrapper(this._engine) };
    this._customWrappers[0].effect = customEffect;
    this._drawWrappers = { 0: new DrawWrapper(this._engine) };
    if (this._drawWrappers[0].drawContext) {
      this._drawWrappers[0].drawContext.useInstancing = true;
    }
    this._attachImageProcessingConfiguration(null);
    options = options !== null && options !== void 0 ? options : {};
    if (!options.randomTextureSize) {
      delete options.randomTextureSize;
    }
    const fullOptions = {
      capacity: 5e4,
      randomTextureSize: this._engine.getCaps().maxTextureSize,
      ...options
    };
    const optionsAsNumber = options;
    if (isFinite(optionsAsNumber)) {
      fullOptions.capacity = optionsAsNumber;
    }
    this._capacity = fullOptions.capacity;
    this._activeCount = fullOptions.capacity;
    this._currentActiveCount = 0;
    this._isAnimationSheetEnabled = isAnimationSheetEnabled;
    this.particleEmitterType = new BoxParticleEmitter();
    const maxTextureSize = Math.min(this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);
    let d = [];
    for (let i = 0; i < maxTextureSize; ++i) {
      d.push(Math.random());
      d.push(Math.random());
      d.push(Math.random());
      d.push(Math.random());
    }
    this._randomTexture = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);
    this._randomTexture.name = "GPUParticleSystem_random1";
    this._randomTexture.wrapU = 1;
    this._randomTexture.wrapV = 1;
    d = [];
    for (let i = 0; i < maxTextureSize; ++i) {
      d.push(Math.random());
      d.push(Math.random());
      d.push(Math.random());
      d.push(Math.random());
    }
    this._randomTexture2 = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);
    this._randomTexture2.name = "GPUParticleSystem_random2";
    this._randomTexture2.wrapU = 1;
    this._randomTexture2.wrapV = 1;
    this._randomTextureSize = maxTextureSize;
  }
  static get IsSupported() {
    if (!EngineStore.LastCreatedEngine) {
      return false;
    }
    const caps = EngineStore.LastCreatedEngine.getCaps();
    return caps.supportTransformFeedbacks || caps.supportComputeShaders;
  }
  getCapacity() {
    return this._capacity;
  }
  get activeParticleCount() {
    return this._activeCount;
  }
  set activeParticleCount(value) {
    this._activeCount = Math.min(value, this._capacity);
  }
  isReady() {
    if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {
      return false;
    }
    if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {
      if (!this._getWrapper(this.blendMode).effect.isReady()) {
        return false;
      }
    } else {
      if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect.isReady()) {
        return false;
      }
      if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect.isReady()) {
        return false;
      }
    }
    if (!this._platform.isUpdateBufferCreated()) {
      this._recreateUpdateEffect();
      return false;
    }
    return this._platform.isUpdateBufferReady();
  }
  isStarted() {
    return this._started;
  }
  isStopped() {
    return this._stopped;
  }
  isStopping() {
    return false;
  }
  getActiveCount() {
    return this._currentActiveCount;
  }
  start(delay = this.startDelay) {
    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {
      throw "Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set";
    }
    if (delay) {
      setTimeout(() => {
        this.start(0);
      }, delay);
      return;
    }
    this._started = true;
    this._stopped = false;
    this._preWarmDone = false;
    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {
      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);
    }
  }
  stop() {
    if (this._stopped) {
      return;
    }
    this._stopped = true;
  }
  reset() {
    this._releaseBuffers();
    this._platform.releaseVertexBuffers();
    this._currentActiveCount = 0;
    this._targetIndex = 0;
  }
  getClassName() {
    return "GPUParticleSystem";
  }
  getCustomEffect(blendMode = 0) {
    var _a, _b;
    return (_b = (_a = this._customWrappers[blendMode]) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : this._customWrappers[0].effect;
  }
  _getCustomDrawWrapper(blendMode = 0) {
    var _a;
    return (_a = this._customWrappers[blendMode]) !== null && _a !== void 0 ? _a : this._customWrappers[0];
  }
  setCustomEffect(effect, blendMode = 0) {
    this._customWrappers[blendMode] = new DrawWrapper(this._engine);
    this._customWrappers[blendMode].effect = effect;
  }
  get onBeforeDrawParticlesObservable() {
    if (!this._onBeforeDrawParticlesObservable) {
      this._onBeforeDrawParticlesObservable = new Observable();
    }
    return this._onBeforeDrawParticlesObservable;
  }
  get vertexShaderName() {
    return "gpuRenderParticles";
  }
  get vertexBuffers() {
    return this._renderVertexBuffers[this._targetIndex ^ 1];
  }
  get indexBuffer() {
    return null;
  }
  _removeGradientAndTexture(gradient, gradients, texture) {
    super._removeGradientAndTexture(gradient, gradients, texture);
    this._releaseBuffers();
    return this;
  }
  addColorGradient(gradient, color1) {
    if (!this._colorGradients) {
      this._colorGradients = [];
    }
    const colorGradient = new ColorGradient(gradient, color1);
    this._colorGradients.push(colorGradient);
    this._refreshColorGradient(true);
    this._releaseBuffers();
    return this;
  }
  _refreshColorGradient(reorder = false) {
    if (this._colorGradients) {
      if (reorder) {
        this._colorGradients.sort((a, b) => {
          if (a.gradient < b.gradient) {
            return -1;
          } else if (a.gradient > b.gradient) {
            return 1;
          }
          return 0;
        });
      }
      if (this._colorGradientsTexture) {
        this._colorGradientsTexture.dispose();
        this._colorGradientsTexture = null;
      }
    }
  }
  forceRefreshGradients() {
    this._refreshColorGradient();
    this._refreshFactorGradient(this._sizeGradients, "_sizeGradientsTexture");
    this._refreshFactorGradient(this._angularSpeedGradients, "_angularSpeedGradientsTexture");
    this._refreshFactorGradient(this._velocityGradients, "_velocityGradientsTexture");
    this._refreshFactorGradient(this._limitVelocityGradients, "_limitVelocityGradientsTexture");
    this._refreshFactorGradient(this._dragGradients, "_dragGradientsTexture");
    this.reset();
  }
  removeColorGradient(gradient) {
    this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);
    this._colorGradientsTexture = null;
    return this;
  }
  resetDrawCache() {
    var _a;
    for (const blendMode in this._drawWrappers) {
      const drawWrapper = this._drawWrappers[blendMode];
      (_a = drawWrapper.drawContext) === null || _a === void 0 ? void 0 : _a.reset();
    }
  }
  _addFactorGradient(factorGradients, gradient, factor) {
    const valueGradient = new FactorGradient(gradient, factor);
    factorGradients.push(valueGradient);
    this._releaseBuffers();
  }
  addSizeGradient(gradient, factor) {
    if (!this._sizeGradients) {
      this._sizeGradients = [];
    }
    this._addFactorGradient(this._sizeGradients, gradient, factor);
    this._refreshFactorGradient(this._sizeGradients, "_sizeGradientsTexture", true);
    this._releaseBuffers();
    return this;
  }
  removeSizeGradient(gradient) {
    this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);
    this._sizeGradientsTexture = null;
    return this;
  }
  _refreshFactorGradient(factorGradients, textureName, reorder = false) {
    if (!factorGradients) {
      return;
    }
    if (reorder) {
      factorGradients.sort((a, b) => {
        if (a.gradient < b.gradient) {
          return -1;
        } else if (a.gradient > b.gradient) {
          return 1;
        }
        return 0;
      });
    }
    const that = this;
    if (that[textureName]) {
      that[textureName].dispose();
      that[textureName] = null;
    }
  }
  addAngularSpeedGradient(gradient, factor) {
    if (!this._angularSpeedGradients) {
      this._angularSpeedGradients = [];
    }
    this._addFactorGradient(this._angularSpeedGradients, gradient, factor);
    this._refreshFactorGradient(this._angularSpeedGradients, "_angularSpeedGradientsTexture", true);
    this._releaseBuffers();
    return this;
  }
  removeAngularSpeedGradient(gradient) {
    this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);
    this._angularSpeedGradientsTexture = null;
    return this;
  }
  addVelocityGradient(gradient, factor) {
    if (!this._velocityGradients) {
      this._velocityGradients = [];
    }
    this._addFactorGradient(this._velocityGradients, gradient, factor);
    this._refreshFactorGradient(this._velocityGradients, "_velocityGradientsTexture", true);
    this._releaseBuffers();
    return this;
  }
  removeVelocityGradient(gradient) {
    this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);
    this._velocityGradientsTexture = null;
    return this;
  }
  addLimitVelocityGradient(gradient, factor) {
    if (!this._limitVelocityGradients) {
      this._limitVelocityGradients = [];
    }
    this._addFactorGradient(this._limitVelocityGradients, gradient, factor);
    this._refreshFactorGradient(this._limitVelocityGradients, "_limitVelocityGradientsTexture", true);
    this._releaseBuffers();
    return this;
  }
  removeLimitVelocityGradient(gradient) {
    this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);
    this._limitVelocityGradientsTexture = null;
    return this;
  }
  addDragGradient(gradient, factor) {
    if (!this._dragGradients) {
      this._dragGradients = [];
    }
    this._addFactorGradient(this._dragGradients, gradient, factor);
    this._refreshFactorGradient(this._dragGradients, "_dragGradientsTexture", true);
    this._releaseBuffers();
    return this;
  }
  removeDragGradient(gradient) {
    this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);
    this._dragGradientsTexture = null;
    return this;
  }
  addEmitRateGradient() {
    return this;
  }
  removeEmitRateGradient() {
    return this;
  }
  addStartSizeGradient() {
    return this;
  }
  removeStartSizeGradient() {
    return this;
  }
  addColorRemapGradient() {
    return this;
  }
  removeColorRemapGradient() {
    return this;
  }
  addAlphaRemapGradient() {
    return this;
  }
  removeAlphaRemapGradient() {
    return this;
  }
  addRampGradient() {
    return this;
  }
  removeRampGradient() {
    return this;
  }
  getRampGradients() {
    return null;
  }
  get useRampGradients() {
    return false;
  }
  set useRampGradients(value) {
  }
  addLifeTimeGradient() {
    return this;
  }
  removeLifeTimeGradient() {
    return this;
  }
  _reset() {
    this._releaseBuffers();
  }
  _createVertexBuffers(updateBuffer, renderBuffer, spriteSource) {
    const renderVertexBuffers = {};
    renderVertexBuffers["position"] = renderBuffer.createVertexBuffer("position", 0, 3, this._attributesStrideSize, true);
    let offset = 3;
    renderVertexBuffers["age"] = renderBuffer.createVertexBuffer("age", offset, 1, this._attributesStrideSize, true);
    offset += 1;
    renderVertexBuffers["size"] = renderBuffer.createVertexBuffer("size", offset, 3, this._attributesStrideSize, true);
    offset += 3;
    renderVertexBuffers["life"] = renderBuffer.createVertexBuffer("life", offset, 1, this._attributesStrideSize, true);
    offset += 1;
    offset += 4;
    if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {
      renderVertexBuffers["direction"] = renderBuffer.createVertexBuffer("direction", offset, 3, this._attributesStrideSize, true);
    }
    offset += 3;
    if (this._platform.alignDataInBuffer) {
      offset += 1;
    }
    if (this.particleEmitterType instanceof CustomParticleEmitter) {
      offset += 3;
      if (this._platform.alignDataInBuffer) {
        offset += 1;
      }
    }
    if (!this._colorGradientsTexture) {
      renderVertexBuffers["color"] = renderBuffer.createVertexBuffer("color", offset, 4, this._attributesStrideSize, true);
      offset += 4;
    }
    if (!this._isBillboardBased) {
      renderVertexBuffers["initialDirection"] = renderBuffer.createVertexBuffer("initialDirection", offset, 3, this._attributesStrideSize, true);
      offset += 3;
      if (this._platform.alignDataInBuffer) {
        offset += 1;
      }
    }
    if (this.noiseTexture) {
      renderVertexBuffers["noiseCoordinates1"] = renderBuffer.createVertexBuffer("noiseCoordinates1", offset, 3, this._attributesStrideSize, true);
      offset += 3;
      if (this._platform.alignDataInBuffer) {
        offset += 1;
      }
      renderVertexBuffers["noiseCoordinates2"] = renderBuffer.createVertexBuffer("noiseCoordinates2", offset, 3, this._attributesStrideSize, true);
      offset += 3;
      if (this._platform.alignDataInBuffer) {
        offset += 1;
      }
    }
    renderVertexBuffers["angle"] = renderBuffer.createVertexBuffer("angle", offset, 1, this._attributesStrideSize, true);
    if (this._angularSpeedGradientsTexture) {
      offset++;
    } else {
      offset += 2;
    }
    if (this._isAnimationSheetEnabled) {
      renderVertexBuffers["cellIndex"] = renderBuffer.createVertexBuffer("cellIndex", offset, 1, this._attributesStrideSize, true);
      offset += 1;
      if (this.spriteRandomStartCell) {
        renderVertexBuffers["cellStartOffset"] = renderBuffer.createVertexBuffer("cellStartOffset", offset, 1, this._attributesStrideSize, true);
        offset += 1;
      }
    }
    renderVertexBuffers["offset"] = spriteSource.createVertexBuffer("offset", 0, 2);
    renderVertexBuffers["uv"] = spriteSource.createVertexBuffer("uv", 2, 2);
    this._renderVertexBuffers.push(renderVertexBuffers);
    this._platform.createVertexBuffers(updateBuffer, renderVertexBuffers);
    this.resetDrawCache();
  }
  _initialize(force = false) {
    if (this._buffer0 && !force) {
      return;
    }
    const engine = this._engine;
    const data = new Array();
    this._attributesStrideSize = 21;
    this._targetIndex = 0;
    if (this._platform.alignDataInBuffer) {
      this._attributesStrideSize += 1;
    }
    if (this.particleEmitterType instanceof CustomParticleEmitter) {
      this._attributesStrideSize += 3;
      if (this._platform.alignDataInBuffer) {
        this._attributesStrideSize += 1;
      }
    }
    if (!this.isBillboardBased) {
      this._attributesStrideSize += 3;
      if (this._platform.alignDataInBuffer) {
        this._attributesStrideSize += 1;
      }
    }
    if (this._colorGradientsTexture) {
      this._attributesStrideSize -= 4;
    }
    if (this._angularSpeedGradientsTexture) {
      this._attributesStrideSize -= 1;
    }
    if (this._isAnimationSheetEnabled) {
      this._attributesStrideSize += 1;
      if (this.spriteRandomStartCell) {
        this._attributesStrideSize += 1;
      }
    }
    if (this.noiseTexture) {
      this._attributesStrideSize += 6;
      if (this._platform.alignDataInBuffer) {
        this._attributesStrideSize += 2;
      }
    }
    if (this._platform.alignDataInBuffer) {
      this._attributesStrideSize += 3 - (this._attributesStrideSize + 3 & 3);
    }
    const usingCustomEmitter = this.particleEmitterType instanceof CustomParticleEmitter;
    const tmpVector = TmpVectors.Vector3[0];
    let offset = 0;
    for (let particleIndex = 0; particleIndex < this._capacity; particleIndex++) {
      data.push(0);
      data.push(0);
      data.push(0);
      data.push(0);
      data.push(0);
      data.push(0);
      data.push(0);
      data.push(0);
      data.push(Math.random());
      data.push(Math.random());
      data.push(Math.random());
      data.push(Math.random());
      if (usingCustomEmitter) {
        this.particleEmitterType.particleDestinationGenerator(particleIndex, null, tmpVector);
        data.push(tmpVector.x);
        data.push(tmpVector.y);
        data.push(tmpVector.z);
      } else {
        data.push(0);
        data.push(0);
        data.push(0);
      }
      if (this._platform.alignDataInBuffer) {
        data.push(0);
      }
      offset += 16;
      if (usingCustomEmitter) {
        this.particleEmitterType.particlePositionGenerator(particleIndex, null, tmpVector);
        data.push(tmpVector.x);
        data.push(tmpVector.y);
        data.push(tmpVector.z);
        if (this._platform.alignDataInBuffer) {
          data.push(0);
        }
        offset += 4;
      }
      if (!this._colorGradientsTexture) {
        data.push(0);
        data.push(0);
        data.push(0);
        data.push(0);
        offset += 4;
      }
      if (!this.isBillboardBased) {
        data.push(0);
        data.push(0);
        data.push(0);
        if (this._platform.alignDataInBuffer) {
          data.push(0);
        }
        offset += 4;
      }
      if (this.noiseTexture) {
        data.push(Math.random());
        data.push(Math.random());
        data.push(Math.random());
        if (this._platform.alignDataInBuffer) {
          data.push(0);
        }
        data.push(Math.random());
        data.push(Math.random());
        data.push(Math.random());
        if (this._platform.alignDataInBuffer) {
          data.push(0);
        }
        offset += 8;
      }
      data.push(0);
      offset += 1;
      if (!this._angularSpeedGradientsTexture) {
        data.push(0);
        offset += 1;
      }
      if (this._isAnimationSheetEnabled) {
        data.push(0);
        offset += 1;
        if (this.spriteRandomStartCell) {
          data.push(0);
          offset += 1;
        }
      }
      if (this._platform.alignDataInBuffer) {
        let numDummies = 3 - (offset + 3 & 3);
        offset += numDummies;
        while (numDummies-- > 0) {
          data.push(0);
        }
      }
    }
    const spriteData = new Float32Array([0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1, 0.5, -0.5, 1, 0, -0.5, -0.5, 0, 0]);
    const bufferData1 = this._platform.createParticleBuffer(data);
    const bufferData2 = this._platform.createParticleBuffer(data);
    this._buffer0 = new Buffer(engine, bufferData1, false, this._attributesStrideSize);
    this._buffer1 = new Buffer(engine, bufferData2, false, this._attributesStrideSize);
    this._spriteBuffer = new Buffer(engine, spriteData, false, 4);
    this._renderVertexBuffers = [];
    this._createVertexBuffers(this._buffer0, this._buffer1, this._spriteBuffer);
    this._createVertexBuffers(this._buffer1, this._buffer0, this._spriteBuffer);
    this._sourceBuffer = this._buffer0;
    this._targetBuffer = this._buffer1;
  }
  _recreateUpdateEffect() {
    let defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : "";
    if (this._isBillboardBased) {
      defines += "\n#define BILLBOARD";
    }
    if (this._colorGradientsTexture) {
      defines += "\n#define COLORGRADIENTS";
    }
    if (this._sizeGradientsTexture) {
      defines += "\n#define SIZEGRADIENTS";
    }
    if (this._angularSpeedGradientsTexture) {
      defines += "\n#define ANGULARSPEEDGRADIENTS";
    }
    if (this._velocityGradientsTexture) {
      defines += "\n#define VELOCITYGRADIENTS";
    }
    if (this._limitVelocityGradientsTexture) {
      defines += "\n#define LIMITVELOCITYGRADIENTS";
    }
    if (this._dragGradientsTexture) {
      defines += "\n#define DRAGGRADIENTS";
    }
    if (this.isAnimationSheetEnabled) {
      defines += "\n#define ANIMATESHEET";
      if (this.spriteRandomStartCell) {
        defines += "\n#define ANIMATESHEETRANDOMSTART";
      }
    }
    if (this.noiseTexture) {
      defines += "\n#define NOISE";
    }
    if (this.isLocal) {
      defines += "\n#define LOCAL";
    }
    if (this._platform.isUpdateBufferCreated() && this._cachedUpdateDefines === defines) {
      return;
    }
    this._cachedUpdateDefines = defines;
    this._updateBuffer = this._platform.createUpdateBuffer(defines);
  }
  _getWrapper(blendMode) {
    const customWrapper = this._getCustomDrawWrapper(blendMode);
    if (customWrapper === null || customWrapper === void 0 ? void 0 : customWrapper.effect) {
      return customWrapper;
    }
    const defines = [];
    this.fillDefines(defines, blendMode);
    let drawWrapper = this._drawWrappers[blendMode];
    if (!drawWrapper) {
      drawWrapper = new DrawWrapper(this._engine);
      if (drawWrapper.drawContext) {
        drawWrapper.drawContext.useInstancing = true;
      }
      this._drawWrappers[blendMode] = drawWrapper;
    }
    const join = defines.join("\n");
    if (drawWrapper.defines !== join) {
      const attributes = [];
      const uniforms = [];
      const samplers = [];
      this.fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers);
      drawWrapper.setEffect(this._engine.createEffect("gpuRenderParticles", attributes, uniforms, samplers, join), join);
    }
    return drawWrapper;
  }
  static _GetAttributeNamesOrOptions(hasColorGradients = false, isAnimationSheetEnabled = false, isBillboardBased = false, isBillboardStretched = false) {
    const attributeNamesOrOptions = [VertexBuffer.PositionKind, "age", "life", "size", "angle"];
    if (!hasColorGradients) {
      attributeNamesOrOptions.push(VertexBuffer.ColorKind);
    }
    if (isAnimationSheetEnabled) {
      attributeNamesOrOptions.push("cellIndex");
    }
    if (!isBillboardBased) {
      attributeNamesOrOptions.push("initialDirection");
    }
    if (!isBillboardStretched) {
      attributeNamesOrOptions.push("direction");
    }
    attributeNamesOrOptions.push("offset", VertexBuffer.UVKind);
    return attributeNamesOrOptions;
  }
  static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false) {
    const effectCreationOption = ["emitterWM", "worldOffset", "view", "projection", "colorDead", "invView", "translationPivot", "eyePosition"];
    addClipPlaneUniforms(effectCreationOption);
    if (isAnimationSheetEnabled) {
      effectCreationOption.push("sheetInfos");
    }
    if (useLogarithmicDepth) {
      effectCreationOption.push("logarithmicDepthConstant");
    }
    return effectCreationOption;
  }
  fillDefines(defines, blendMode = 0) {
    if (this._scene) {
      prepareDefinesForClipPlanes(this, this._scene, defines);
    }
    if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {
      defines.push("#define BLENDMULTIPLYMODE");
    }
    if (this.isLocal) {
      defines.push("#define LOCAL");
    }
    if (this.useLogarithmicDepth) {
      defines.push("#define LOGARITHMICDEPTH");
    }
    if (this._isBillboardBased) {
      defines.push("#define BILLBOARD");
      switch (this.billboardMode) {
        case ParticleSystem.BILLBOARDMODE_Y:
          defines.push("#define BILLBOARDY");
          break;
        case ParticleSystem.BILLBOARDMODE_STRETCHED:
          defines.push("#define BILLBOARDSTRETCHED");
          break;
        case ParticleSystem.BILLBOARDMODE_ALL:
          defines.push("#define BILLBOARDMODE_ALL");
          break;
        default:
          break;
      }
    }
    if (this._colorGradientsTexture) {
      defines.push("#define COLORGRADIENTS");
    }
    if (this.isAnimationSheetEnabled) {
      defines.push("#define ANIMATESHEET");
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);
      defines.push("" + this._imageProcessingConfigurationDefines.toString());
    }
  }
  fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers) {
    attributes.push(...GPUParticleSystem._GetAttributeNamesOrOptions(!!this._colorGradientsTexture, this._isAnimationSheetEnabled, this._isBillboardBased, this._isBillboardBased && this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED));
    uniforms.push(...GPUParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth));
    samplers.push("diffuseSampler", "colorGradientSampler");
    if (this._imageProcessingConfiguration) {
      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);
      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);
    }
  }
  animate(preWarm = false) {
    var _a;
    this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getAnimationRatio()) || 1);
    this._actualFrame += this._timeDelta;
    if (!this._stopped) {
      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {
        this.stop();
      }
    }
    if (this.updateInAnimate) {
      this._update();
    }
  }
  _createFactorGradientTexture(factorGradients, textureName) {
    const texture = this[textureName];
    if (!factorGradients || !factorGradients.length || texture) {
      return;
    }
    const data = new Float32Array(this._rawTextureWidth);
    for (let x = 0; x < this._rawTextureWidth; x++) {
      const ratio = x / this._rawTextureWidth;
      GradientHelper.GetCurrentGradient(ratio, factorGradients, (currentGradient, nextGradient, scale) => {
        data[x] = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);
      });
    }
    this[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene || this._engine, false, false, 1);
  }
  _createSizeGradientTexture() {
    this._createFactorGradientTexture(this._sizeGradients, "_sizeGradientsTexture");
  }
  _createAngularSpeedGradientTexture() {
    this._createFactorGradientTexture(this._angularSpeedGradients, "_angularSpeedGradientsTexture");
  }
  _createVelocityGradientTexture() {
    this._createFactorGradientTexture(this._velocityGradients, "_velocityGradientsTexture");
  }
  _createLimitVelocityGradientTexture() {
    this._createFactorGradientTexture(this._limitVelocityGradients, "_limitVelocityGradientsTexture");
  }
  _createDragGradientTexture() {
    this._createFactorGradientTexture(this._dragGradients, "_dragGradientsTexture");
  }
  _createColorGradientTexture() {
    if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {
      return;
    }
    const data = new Uint8Array(this._rawTextureWidth * 4);
    const tmpColor = TmpColors.Color4[0];
    for (let x = 0; x < this._rawTextureWidth; x++) {
      const ratio = x / this._rawTextureWidth;
      GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {
        Color4.LerpToRef(currentGradient.color1, nextGradient.color1, scale, tmpColor);
        data[x * 4] = tmpColor.r * 255;
        data[x * 4 + 1] = tmpColor.g * 255;
        data[x * 4 + 2] = tmpColor.b * 255;
        data[x * 4 + 3] = tmpColor.a * 255;
      });
    }
    this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);
  }
  _render(blendMode, emitterWM) {
    var _a, _b;
    const drawWrapper = this._getWrapper(blendMode);
    const effect = drawWrapper.effect;
    this._engine.enableEffect(drawWrapper);
    const viewMatrix = ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getViewMatrix()) || Matrix.IdentityReadOnly;
    effect.setMatrix("view", viewMatrix);
    effect.setMatrix("projection", (_b = this.defaultProjectionMatrix) !== null && _b !== void 0 ? _b : this._scene.getProjectionMatrix());
    effect.setTexture("diffuseSampler", this.particleTexture);
    effect.setVector2("translationPivot", this.translationPivot);
    effect.setVector3("worldOffset", this.worldOffset);
    if (this.isLocal) {
      effect.setMatrix("emitterWM", emitterWM);
    }
    if (this._colorGradientsTexture) {
      effect.setTexture("colorGradientSampler", this._colorGradientsTexture);
    } else {
      effect.setDirectColor4("colorDead", this.colorDead);
    }
    if (this._isAnimationSheetEnabled && this.particleTexture) {
      const baseSize = this.particleTexture.getBaseSize();
      effect.setFloat3("sheetInfos", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);
    }
    if (this._isBillboardBased && this._scene) {
      const camera = this._scene.activeCamera;
      effect.setVector3("eyePosition", camera.globalPosition);
    }
    const defines = effect.defines;
    if (this._scene) {
      bindClipPlane(effect, this, this._scene);
    }
    if (defines.indexOf("#define BILLBOARDMODE_ALL") >= 0) {
      const invView = viewMatrix.clone();
      invView.invert();
      effect.setMatrix("invView", invView);
    }
    if (this.useLogarithmicDepth && this._scene) {
      MaterialHelper.BindLogDepth(defines, effect, this._scene);
    }
    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
      this._imageProcessingConfiguration.bind(effect);
    }
    switch (blendMode) {
      case ParticleSystem.BLENDMODE_ADD:
        this._engine.setAlphaMode(1);
        break;
      case ParticleSystem.BLENDMODE_ONEONE:
        this._engine.setAlphaMode(6);
        break;
      case ParticleSystem.BLENDMODE_STANDARD:
        this._engine.setAlphaMode(2);
        break;
      case ParticleSystem.BLENDMODE_MULTIPLY:
        this._engine.setAlphaMode(4);
        break;
    }
    this._platform.bindDrawBuffers(this._targetIndex, effect);
    if (this._onBeforeDrawParticlesObservable) {
      this._onBeforeDrawParticlesObservable.notifyObservers(effect);
    }
    this._engine.drawArraysType(7, 0, 4, this._currentActiveCount);
    this._engine.setAlphaMode(0);
    return this._currentActiveCount;
  }
  _update(emitterWM) {
    if (!this.emitter) {
      return;
    }
    this._recreateUpdateEffect();
    if (this.emitter.position) {
      const emitterMesh = this.emitter;
      emitterWM = emitterMesh.getWorldMatrix();
    } else {
      const emitterPosition = this.emitter;
      emitterWM = TmpVectors.Matrix[0];
      Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);
    }
    this._platform.preUpdateParticleBuffer();
    this._updateBuffer.setFloat("currentCount", this._currentActiveCount);
    this._updateBuffer.setFloat("timeDelta", this._timeDelta);
    this._updateBuffer.setFloat("stopFactor", this._stopped ? 0 : 1);
    this._updateBuffer.setInt("randomTextureSize", this._randomTextureSize);
    this._updateBuffer.setFloat2("lifeTime", this.minLifeTime, this.maxLifeTime);
    this._updateBuffer.setFloat2("emitPower", this.minEmitPower, this.maxEmitPower);
    if (!this._colorGradientsTexture) {
      this._updateBuffer.setDirectColor4("color1", this.color1);
      this._updateBuffer.setDirectColor4("color2", this.color2);
    }
    this._updateBuffer.setFloat2("sizeRange", this.minSize, this.maxSize);
    this._updateBuffer.setFloat4("scaleRange", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);
    this._updateBuffer.setFloat4("angleRange", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);
    this._updateBuffer.setVector3("gravity", this.gravity);
    if (this._limitVelocityGradientsTexture) {
      this._updateBuffer.setFloat("limitVelocityDamping", this.limitVelocityDamping);
    }
    if (this.particleEmitterType) {
      this.particleEmitterType.applyToShader(this._updateBuffer);
    }
    if (this._isAnimationSheetEnabled) {
      this._updateBuffer.setFloat4("cellInfos", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed, this.spriteCellLoop ? 1 : 0);
    }
    if (this.noiseTexture) {
      this._updateBuffer.setVector3("noiseStrength", this.noiseStrength);
    }
    if (!this.isLocal) {
      this._updateBuffer.setMatrix("emitterWM", emitterWM);
    }
    this._platform.updateParticleBuffer(this._targetIndex, this._targetBuffer, this._currentActiveCount);
    this._targetIndex++;
    if (this._targetIndex === 2) {
      this._targetIndex = 0;
    }
    const tmpBuffer = this._sourceBuffer;
    this._sourceBuffer = this._targetBuffer;
    this._targetBuffer = tmpBuffer;
  }
  render(preWarm = false, forceUpdateOnly = false) {
    if (!this._started) {
      return 0;
    }
    this._createColorGradientTexture();
    this._createSizeGradientTexture();
    this._createAngularSpeedGradientTexture();
    this._createVelocityGradientTexture();
    this._createLimitVelocityGradientTexture();
    this._createDragGradientTexture();
    if (!this.isReady()) {
      return 0;
    }
    if (!preWarm && this._scene) {
      if (!this._preWarmDone && this.preWarmCycles) {
        for (let index = 0; index < this.preWarmCycles; index++) {
          this.animate(true);
          this.render(true, true);
        }
        this._preWarmDone = true;
      }
      if (this._currentRenderId === this._scene.getFrameId() && (!this._scene.activeCamera || this._scene.activeCamera && this._currentRenderingCameraUniqueId === this._scene.activeCamera.uniqueId)) {
        return 0;
      }
      this._currentRenderId = this._scene.getFrameId();
      if (this._scene.activeCamera) {
        this._currentRenderingCameraUniqueId = this._scene.activeCamera.uniqueId;
      }
    }
    this._initialize();
    this._accumulatedCount += this.emitRate * this._timeDelta;
    if (this._accumulatedCount > 1) {
      const intPart = this._accumulatedCount | 0;
      this._accumulatedCount -= intPart;
      this._currentActiveCount = Math.min(this._activeCount, this._currentActiveCount + intPart);
    }
    if (!this._currentActiveCount) {
      return 0;
    }
    let emitterWM;
    if (this.emitter.position) {
      const emitterMesh = this.emitter;
      emitterWM = emitterMesh.getWorldMatrix();
    } else {
      const emitterPosition = this.emitter;
      emitterWM = TmpVectors.Matrix[0];
      Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);
    }
    const engine = this._engine;
    if (!this.updateInAnimate) {
      this._update(emitterWM);
    }
    let outparticles = 0;
    if (!preWarm && !forceUpdateOnly) {
      engine.setState(false);
      if (this.forceDepthWrite) {
        engine.setDepthWrite(true);
      }
      if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {
        outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY, emitterWM) + this._render(ParticleSystem.BLENDMODE_ADD, emitterWM);
      } else {
        outparticles = this._render(this.blendMode, emitterWM);
      }
      this._engine.setAlphaMode(0);
    }
    return outparticles;
  }
  rebuild() {
    this._initialize(true);
  }
  _releaseBuffers() {
    if (this._buffer0) {
      this._buffer0.dispose();
      this._buffer0 = null;
    }
    if (this._buffer1) {
      this._buffer1.dispose();
      this._buffer1 = null;
    }
    if (this._spriteBuffer) {
      this._spriteBuffer.dispose();
      this._spriteBuffer = null;
    }
    this._platform.releaseBuffers();
  }
  dispose(disposeTexture = true) {
    for (const blendMode in this._drawWrappers) {
      const drawWrapper = this._drawWrappers[blendMode];
      drawWrapper.dispose();
    }
    this._drawWrappers = {};
    if (this._scene) {
      const index = this._scene.particleSystems.indexOf(this);
      if (index > -1) {
        this._scene.particleSystems.splice(index, 1);
      }
    }
    this._releaseBuffers();
    this._platform.releaseVertexBuffers();
    for (let i = 0; i < this._renderVertexBuffers.length; ++i) {
      const rvb = this._renderVertexBuffers[i];
      for (const key in rvb) {
        rvb[key].dispose();
      }
    }
    this._renderVertexBuffers = [];
    if (this._colorGradientsTexture) {
      this._colorGradientsTexture.dispose();
      this._colorGradientsTexture = null;
    }
    if (this._sizeGradientsTexture) {
      this._sizeGradientsTexture.dispose();
      this._sizeGradientsTexture = null;
    }
    if (this._angularSpeedGradientsTexture) {
      this._angularSpeedGradientsTexture.dispose();
      this._angularSpeedGradientsTexture = null;
    }
    if (this._velocityGradientsTexture) {
      this._velocityGradientsTexture.dispose();
      this._velocityGradientsTexture = null;
    }
    if (this._limitVelocityGradientsTexture) {
      this._limitVelocityGradientsTexture.dispose();
      this._limitVelocityGradientsTexture = null;
    }
    if (this._dragGradientsTexture) {
      this._dragGradientsTexture.dispose();
      this._dragGradientsTexture = null;
    }
    if (this._randomTexture) {
      this._randomTexture.dispose();
      this._randomTexture = null;
    }
    if (this._randomTexture2) {
      this._randomTexture2.dispose();
      this._randomTexture2 = null;
    }
    if (disposeTexture && this.particleTexture) {
      this.particleTexture.dispose();
      this.particleTexture = null;
    }
    if (disposeTexture && this.noiseTexture) {
      this.noiseTexture.dispose();
      this.noiseTexture = null;
    }
    this.onStoppedObservable.clear();
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
  }
  clone(name137, newEmitter, cloneTexture = false) {
    const custom = { ...this._customWrappers };
    let program = null;
    const engine = this._engine;
    if (engine.createEffectForParticles) {
      if (this.customShader != null) {
        program = this.customShader;
        const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
        custom[0] = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines, void 0, void 0, void 0, this);
      }
    }
    const serialization = this.serialize(cloneTexture);
    const result = GPUParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);
    result.name = name137;
    result.customShader = program;
    result._customWrappers = custom;
    if (newEmitter === void 0) {
      newEmitter = this.emitter;
    }
    if (this.noiseTexture) {
      result.noiseTexture = this.noiseTexture.clone();
    }
    result.emitter = newEmitter;
    return result;
  }
  serialize(serializeTexture = false) {
    const serializationObject = {};
    ParticleSystem._Serialize(serializationObject, this, serializeTexture);
    serializationObject.activeParticleCount = this.activeParticleCount;
    serializationObject.randomTextureSize = this._randomTextureSize;
    serializationObject.customShader = this.customShader;
    return serializationObject;
  }
  static Parse(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart = false, capacity) {
    const name137 = parsedParticleSystem.name;
    let engine;
    let scene;
    if (sceneOrEngine instanceof ThinEngine) {
      engine = sceneOrEngine;
    } else {
      scene = sceneOrEngine;
      engine = scene.getEngine();
    }
    const particleSystem = new GPUParticleSystem(name137, { capacity: capacity || parsedParticleSystem.capacity, randomTextureSize: parsedParticleSystem.randomTextureSize }, sceneOrEngine, null, parsedParticleSystem.isAnimationSheetEnabled);
    particleSystem._rootUrl = rootUrl;
    if (parsedParticleSystem.customShader && engine.createEffectForParticles) {
      const program = parsedParticleSystem.customShader;
      const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
      const custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines, void 0, void 0, void 0, particleSystem);
      particleSystem.setCustomEffect(custom, 0);
      particleSystem.customShader = program;
    }
    if (parsedParticleSystem.id) {
      particleSystem.id = parsedParticleSystem.id;
    }
    if (parsedParticleSystem.activeParticleCount) {
      particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;
    }
    ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);
    if (parsedParticleSystem.preventAutoStart) {
      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;
    }
    if (!doNotStart && !particleSystem.preventAutoStart) {
      particleSystem.start();
    }
    return particleSystem;
  }
};

// node_modules/@babylonjs/core/Particles/particleSystemSet.js
var ParticleSystemSet = class {
  constructor() {
    this._emitterNodeIsOwned = true;
    this.systems = new Array();
  }
  get emitterNode() {
    return this._emitterNode;
  }
  set emitterNode(value) {
    if (this._emitterNodeIsOwned && this._emitterNode) {
      if (this._emitterNode.dispose) {
        this._emitterNode.dispose();
      }
      this._emitterNodeIsOwned = false;
    }
    for (const system of this.systems) {
      system.emitter = value;
    }
    this._emitterNode = value;
  }
  setEmitterAsSphere(options, renderingGroupId, scene) {
    if (this._emitterNodeIsOwned && this._emitterNode) {
      if (this._emitterNode.dispose) {
        this._emitterNode.dispose();
      }
    }
    this._emitterNodeIsOwned = true;
    this._emitterCreationOptions = {
      kind: "Sphere",
      options,
      renderingGroupId
    };
    const emitterMesh = CreateSphere("emitterSphere", { diameter: options.diameter, segments: options.segments }, scene);
    emitterMesh.renderingGroupId = renderingGroupId;
    const material = new StandardMaterial("emitterSphereMaterial", scene);
    material.emissiveColor = options.color;
    emitterMesh.material = material;
    for (const system of this.systems) {
      system.emitter = emitterMesh;
    }
    this._emitterNode = emitterMesh;
  }
  start(emitter) {
    for (const system of this.systems) {
      if (emitter) {
        system.emitter = emitter;
      }
      system.start();
    }
  }
  dispose() {
    for (const system of this.systems) {
      system.dispose();
    }
    this.systems.length = 0;
    if (this._emitterNode) {
      if (this._emitterNode.dispose) {
        this._emitterNode.dispose();
      }
      this._emitterNode = null;
    }
  }
  serialize(serializeTexture = false) {
    const result = {};
    result.systems = [];
    for (const system of this.systems) {
      result.systems.push(system.serialize(serializeTexture));
    }
    if (this._emitterNode) {
      result.emitter = this._emitterCreationOptions;
    }
    return result;
  }
  static Parse(data, scene, gpu = false, capacity) {
    const result = new ParticleSystemSet();
    const rootUrl = this.BaseAssetsUrl + "/textures/";
    scene = scene || EngineStore.LastCreatedScene;
    for (const system of data.systems) {
      result.systems.push(gpu ? GPUParticleSystem.Parse(system, scene, rootUrl, true, capacity) : ParticleSystem.Parse(system, scene, rootUrl, true, capacity));
    }
    if (data.emitter) {
      const options = data.emitter.options;
      switch (data.emitter.kind) {
        case "Sphere":
          result.setEmitterAsSphere({
            diameter: options.diameter,
            segments: options.segments,
            color: Color3.FromArray(options.color)
          }, data.emitter.renderingGroupId, scene);
          break;
      }
    }
    return result;
  }
};
ParticleSystemSet.BaseAssetsUrl = "https://assets.babylonjs.com/particles";

// node_modules/@babylonjs/core/Particles/particleHelper.js
var ParticleHelper = class {
  static CreateDefault(emitter, capacity = 500, scene, useGPU = false) {
    let system;
    if (useGPU) {
      system = new GPUParticleSystem("default system", { capacity }, scene);
    } else {
      system = new ParticleSystem("default system", capacity, scene);
    }
    system.emitter = emitter;
    system.particleTexture = new Texture("https://assets.babylonjs.com/textures/flare.png", system.getScene());
    system.createConeEmitter(0.1, Math.PI / 4);
    system.color1 = new Color4(1, 1, 1, 1);
    system.color2 = new Color4(1, 1, 1, 1);
    system.colorDead = new Color4(1, 1, 1, 0);
    system.minSize = 0.1;
    system.maxSize = 0.1;
    system.minEmitPower = 2;
    system.maxEmitPower = 2;
    system.updateSpeed = 1 / 60;
    system.emitRate = 30;
    return system;
  }
  static CreateAsync(type, scene, gpu = false, capacity) {
    if (!scene) {
      scene = EngineStore.LastCreatedScene;
    }
    const token = {};
    scene.addPendingData(token);
    return new Promise((resolve, reject) => {
      if (gpu && !GPUParticleSystem.IsSupported) {
        scene.removePendingData(token);
        return reject("Particle system with GPU is not supported.");
      }
      Tools.LoadFile(`${ParticleHelper.BaseAssetsUrl}/systems/${type}.json`, (data) => {
        scene.removePendingData(token);
        const newData = JSON.parse(data.toString());
        return resolve(ParticleSystemSet.Parse(newData, scene, gpu, capacity));
      }, void 0, void 0, void 0, () => {
        scene.removePendingData(token);
        return reject(`An error occurred with the creation of your particle system. Check if your type '${type}' exists.`);
      });
    });
  }
  static ExportSet(systems) {
    const set = new ParticleSystemSet();
    for (const system of systems) {
      set.systems.push(system);
    }
    return set;
  }
  static ParseFromFileAsync(name137, url, scene, gpu = false, rootUrl = "", capacity) {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const serializationObject = JSON.parse(request.responseText);
            let output;
            if (gpu) {
              output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);
            } else {
              output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);
            }
            if (name137) {
              output.name = name137;
            }
            resolve(output);
          } else {
            reject("Unable to load the particle system");
          }
        }
      });
      request.open("GET", url);
      request.send();
    });
  }
  static ParseFromSnippetAsync(snippetId, scene, gpu = false, rootUrl = "", capacity) {
    if (snippetId === "_BLANK") {
      const system = this.CreateDefault(null);
      system.start();
      return Promise.resolve(system);
    }
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            const serializationObject = JSON.parse(snippet.particleSystem);
            let output;
            if (gpu) {
              output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);
            } else {
              output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);
            }
            output.snippetId = snippetId;
            resolve(output);
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  }
};
ParticleHelper.BaseAssetsUrl = ParticleSystemSet.BaseAssetsUrl;
ParticleHelper.SnippetUrl = `https://snippet.babylonjs.com`;
ParticleHelper.CreateFromSnippetAsync = ParticleHelper.ParseFromSnippetAsync;

// node_modules/@babylonjs/core/Particles/particleSystemComponent.js
AbstractScene.AddParser(SceneComponentConstants.NAME_PARTICLESYSTEM, (parsedData, scene, container, rootUrl) => {
  const individualParser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);
  if (!individualParser) {
    return;
  }
  if (parsedData.particleSystems !== void 0 && parsedData.particleSystems !== null) {
    for (let index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {
      const parsedParticleSystem = parsedData.particleSystems[index];
      container.particleSystems.push(individualParser(parsedParticleSystem, scene, rootUrl));
    }
  }
});
AbstractScene.AddIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM, (parsedParticleSystem, scene, rootUrl) => {
  if (parsedParticleSystem.activeParticleCount) {
    const ps = GPUParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);
    return ps;
  } else {
    const ps = ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);
    return ps;
  }
});
Engine.prototype.createEffectForParticles = function(fragmentName, uniformsNames = [], samplers = [], defines = "", fallbacks, onCompiled, onError, particleSystem) {
  var _a;
  let attributesNamesOrOptions = [];
  let effectCreationOption = [];
  const allSamplers = [];
  if (particleSystem) {
    particleSystem.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, allSamplers);
  } else {
    attributesNamesOrOptions = ParticleSystem._GetAttributeNamesOrOptions();
    effectCreationOption = ParticleSystem._GetEffectCreationOptions();
  }
  if (defines.indexOf(" BILLBOARD") === -1) {
    defines += "\n#define BILLBOARD\n";
  }
  if (samplers.indexOf("diffuseSampler") === -1) {
    samplers.push("diffuseSampler");
  }
  return this.createEffect({
    vertex: (_a = particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.vertexShaderName) !== null && _a !== void 0 ? _a : "particles",
    fragmentElement: fragmentName
  }, attributesNamesOrOptions, effectCreationOption.concat(uniformsNames), allSamplers.concat(samplers), defines, fallbacks, onCompiled, onError);
};
Mesh.prototype.getEmittedParticleSystems = function() {
  const results = new Array();
  for (let index = 0; index < this.getScene().particleSystems.length; index++) {
    const particleSystem = this.getScene().particleSystems[index];
    if (particleSystem.emitter === this) {
      results.push(particleSystem);
    }
  }
  return results;
};
Mesh.prototype.getHierarchyEmittedParticleSystems = function() {
  const results = new Array();
  const descendants = this.getDescendants();
  descendants.push(this);
  for (let index = 0; index < this.getScene().particleSystems.length; index++) {
    const particleSystem = this.getScene().particleSystems[index];
    const emitter = particleSystem.emitter;
    if (emitter.position && descendants.indexOf(emitter) !== -1) {
      results.push(particleSystem);
    }
  }
  return results;
};

// node_modules/@babylonjs/core/Particles/solidParticle.js
var SolidParticle = class {
  constructor(particleIndex, particleId, positionIndex, indiceIndex, model, shapeId, idxInShape, sps, modelBoundingInfo = null, materialIndex = null) {
    this.idx = 0;
    this.id = 0;
    this.color = new Color4(1, 1, 1, 1);
    this.position = Vector3.Zero();
    this.rotation = Vector3.Zero();
    this.scaling = Vector3.One();
    this.uvs = new Vector4(0, 0, 1, 1);
    this.velocity = Vector3.Zero();
    this.pivot = Vector3.Zero();
    this.translateFromPivot = false;
    this.alive = true;
    this.isVisible = true;
    this._pos = 0;
    this._ind = 0;
    this.shapeId = 0;
    this.idxInShape = 0;
    this._stillInvisible = false;
    this._rotationMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    this.parentId = null;
    this.materialIndex = null;
    this.props = null;
    this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
    this._globalPosition = Vector3.Zero();
    this.idx = particleIndex;
    this.id = particleId;
    this._pos = positionIndex;
    this._ind = indiceIndex;
    this._model = model;
    this.shapeId = shapeId;
    this.idxInShape = idxInShape;
    this._sps = sps;
    if (modelBoundingInfo) {
      this._modelBoundingInfo = modelBoundingInfo;
      this._boundingInfo = new BoundingInfo(modelBoundingInfo.minimum, modelBoundingInfo.maximum);
    }
    if (materialIndex !== null) {
      this.materialIndex = materialIndex;
    }
  }
  getBoundingInfo() {
    return this._boundingInfo;
  }
  get hasBoundingInfo() {
    return this._boundingInfo !== null;
  }
  copyToRef(target) {
    target.position.copyFrom(this.position);
    target.rotation.copyFrom(this.rotation);
    if (this.rotationQuaternion) {
      if (target.rotationQuaternion) {
        target.rotationQuaternion.copyFrom(this.rotationQuaternion);
      } else {
        target.rotationQuaternion = this.rotationQuaternion.clone();
      }
    }
    target.scaling.copyFrom(this.scaling);
    if (this.color) {
      if (target.color) {
        target.color.copyFrom(this.color);
      } else {
        target.color = this.color.clone();
      }
    }
    target.uvs.copyFrom(this.uvs);
    target.velocity.copyFrom(this.velocity);
    target.pivot.copyFrom(this.pivot);
    target.translateFromPivot = this.translateFromPivot;
    target.alive = this.alive;
    target.isVisible = this.isVisible;
    target.parentId = this.parentId;
    target.cullingStrategy = this.cullingStrategy;
    if (this.materialIndex !== null) {
      target.materialIndex = this.materialIndex;
    }
    return this;
  }
  get scale() {
    return this.scaling;
  }
  set scale(scale) {
    this.scaling = scale;
  }
  get quaternion() {
    return this.rotationQuaternion;
  }
  set quaternion(q) {
    this.rotationQuaternion = q;
  }
  intersectsMesh(target) {
    if (!this._boundingInfo || !target.hasBoundingInfo) {
      return false;
    }
    if (this._sps._bSphereOnly) {
      return BoundingSphere.Intersects(this._boundingInfo.boundingSphere, target.getBoundingInfo().boundingSphere);
    }
    return this._boundingInfo.intersects(target.getBoundingInfo(), false);
  }
  isInFrustum(frustumPlanes) {
    return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);
  }
  getRotationMatrix(m) {
    let quaternion;
    if (this.rotationQuaternion) {
      quaternion = this.rotationQuaternion;
    } else {
      quaternion = TmpVectors.Quaternion[0];
      const rotation = this.rotation;
      Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);
    }
    quaternion.toRotationMatrix(m);
  }
};
var ModelShape = class {
  constructor(id, shape, indices, normals, colors, shapeUV, posFunction, vtxFunction, material) {
    this._indicesLength = 0;
    this.shapeId = id;
    this._shape = shape;
    this._indices = indices;
    this._indicesLength = indices.length;
    this._shapeUV = shapeUV;
    this._shapeColors = colors;
    this._normals = normals;
    this._positionFunction = posFunction;
    this._vertexFunction = vtxFunction;
    this._material = material;
  }
  get shapeID() {
    return this.shapeId;
  }
  set shapeID(shapeID) {
    this.shapeId = shapeID;
  }
};
var DepthSortedParticle = class {
  constructor(idx, ind, indLength, materialIndex) {
    this.idx = 0;
    this.ind = 0;
    this.indicesLength = 0;
    this.sqDistance = 0;
    this.materialIndex = 0;
    this.idx = idx;
    this.ind = ind;
    this.indicesLength = indLength;
    this.materialIndex = materialIndex;
  }
};
var SolidParticleVertex = class {
  constructor() {
    this.position = Vector3.Zero();
    this.color = new Color4(1, 1, 1, 1);
    this.uv = Vector2.Zero();
  }
  get x() {
    return this.position.x;
  }
  set x(val) {
    this.position.x = val;
  }
  get y() {
    return this.position.y;
  }
  set y(val) {
    this.position.y = val;
  }
  get z() {
    return this.position.z;
  }
  set z(val) {
    this.position.z = val;
  }
};

// node_modules/@babylonjs/core/Particles/solidParticleSystem.js
var SolidParticleSystem = class {
  constructor(name137, scene, options) {
    this.particles = new Array();
    this.nbParticles = 0;
    this.billboard = false;
    this.recomputeNormals = false;
    this.counter = 0;
    this.vars = {};
    this._bSphereOnly = false;
    this._bSphereRadiusFactor = 1;
    this._positions = new Array();
    this._indices = new Array();
    this._normals = new Array();
    this._colors = new Array();
    this._uvs = new Array();
    this._index = 0;
    this._updatable = true;
    this._pickable = false;
    this._isVisibilityBoxLocked = false;
    this._alwaysVisible = false;
    this._depthSort = false;
    this._expandable = false;
    this._shapeCounter = 0;
    this._copy = new SolidParticle(0, 0, 0, 0, null, 0, 0, this);
    this._color = new Color4(0, 0, 0, 0);
    this._computeParticleColor = true;
    this._computeParticleTexture = true;
    this._computeParticleRotation = true;
    this._computeParticleVertex = false;
    this._computeBoundingBox = false;
    this._autoFixFaceOrientation = false;
    this._depthSortParticles = true;
    this._mustUnrotateFixedNormals = false;
    this._particlesIntersect = false;
    this._needs32Bits = false;
    this._isNotBuilt = true;
    this._lastParticleId = 0;
    this._idxOfId = [];
    this._multimaterialEnabled = false;
    this._useModelMaterial = false;
    this._depthSortFunction = (p1, p2) => p2.sqDistance - p1.sqDistance;
    this._materialSortFunction = (p1, p2) => p1.materialIndex - p2.materialIndex;
    this._autoUpdateSubMeshes = false;
    this._recomputeInvisibles = false;
    this.name = name137;
    this._scene = scene || EngineStore.LastCreatedScene;
    this._camera = scene.activeCamera;
    this._pickable = options ? options.isPickable : false;
    this._depthSort = options ? options.enableDepthSort : false;
    this._multimaterialEnabled = options ? options.enableMultiMaterial : false;
    this._useModelMaterial = options ? options.useModelMaterial : false;
    this._multimaterialEnabled = this._useModelMaterial ? true : this._multimaterialEnabled;
    this._expandable = options ? options.expandable : false;
    this._particlesIntersect = options ? options.particleIntersection : false;
    this._bSphereOnly = options ? options.boundingSphereOnly : false;
    this._bSphereRadiusFactor = options && options.bSphereRadiusFactor ? options.bSphereRadiusFactor : 1;
    this._computeBoundingBox = (options === null || options === void 0 ? void 0 : options.computeBoundingBox) ? options.computeBoundingBox : false;
    this._autoFixFaceOrientation = (options === null || options === void 0 ? void 0 : options.autoFixFaceOrientation) ? options.autoFixFaceOrientation : false;
    if (options && options.updatable !== void 0) {
      this._updatable = options.updatable;
    } else {
      this._updatable = true;
    }
    if (this._pickable) {
      this.pickedBySubMesh = [[]];
      this.pickedParticles = this.pickedBySubMesh[0];
    }
    if (this._depthSort || this._multimaterialEnabled) {
      this.depthSortedParticles = [];
    }
    if (this._multimaterialEnabled) {
      this._multimaterial = new MultiMaterial(this.name + "MultiMaterial", this._scene);
      this._materials = [];
      this._materialIndexesById = {};
    }
    this._tmpVertex = new SolidParticleVertex();
  }
  buildMesh() {
    if (!this._isNotBuilt && this.mesh) {
      return this.mesh;
    }
    if (this.nbParticles === 0 && !this.mesh) {
      const triangle = CreateDisc("", { radius: 1, tessellation: 3 }, this._scene);
      this.addShape(triangle, 1);
      triangle.dispose();
    }
    this._indices32 = this._needs32Bits ? new Uint32Array(this._indices) : new Uint16Array(this._indices);
    this._positions32 = new Float32Array(this._positions);
    this._uvs32 = new Float32Array(this._uvs);
    this._colors32 = new Float32Array(this._colors);
    if (!this.mesh) {
      const mesh = new Mesh(this.name, this._scene);
      this.mesh = mesh;
    }
    if (!this._updatable && this._multimaterialEnabled) {
      this._sortParticlesByMaterial();
    }
    if (this.recomputeNormals) {
      VertexData.ComputeNormals(this._positions32, this._indices32, this._normals);
    }
    this._normals32 = new Float32Array(this._normals);
    this._fixedNormal32 = new Float32Array(this._normals);
    if (this._mustUnrotateFixedNormals) {
      this._unrotateFixedNormals();
    }
    const vertexData = new VertexData();
    vertexData.indices = this._depthSort ? this._indices : this._indices32;
    vertexData.set(this._positions32, VertexBuffer.PositionKind);
    vertexData.set(this._normals32, VertexBuffer.NormalKind);
    if (this._uvs32.length > 0) {
      vertexData.set(this._uvs32, VertexBuffer.UVKind);
    }
    if (this._colors32.length > 0) {
      vertexData.set(this._colors32, VertexBuffer.ColorKind);
    }
    vertexData.applyToMesh(this.mesh, this._updatable);
    this.mesh.isPickable = this._pickable;
    if (this._pickable) {
      let faceId = 0;
      for (let p = 0; p < this.nbParticles; p++) {
        const part = this.particles[p];
        const lind = part._model._indicesLength;
        for (let i = 0; i < lind; i++) {
          const f = i % 3;
          if (f == 0) {
            const pickedData = { idx: part.idx, faceId };
            this.pickedParticles[faceId] = pickedData;
            faceId++;
          }
        }
      }
    }
    if (this._multimaterialEnabled) {
      this.setMultiMaterial(this._materials);
    }
    if (!this._expandable) {
      if (!this._depthSort && !this._multimaterialEnabled && !this._autoFixFaceOrientation) {
        this._indices = null;
      }
      this._positions = null;
      this._normals = null;
      this._uvs = null;
      this._colors = null;
      if (!this._updatable) {
        this.particles.length = 0;
      }
    }
    this._isNotBuilt = false;
    this.recomputeNormals = false;
    this._recomputeInvisibles = true;
    return this.mesh;
  }
  digest(mesh, options) {
    let size = options && options.facetNb || 1;
    let number = options && options.number || 0;
    let delta = options && options.delta || 0;
    const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);
    const meshInd = mesh.getIndices();
    const meshUV = mesh.getVerticesData(VertexBuffer.UVKind);
    const meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);
    const meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);
    const storage = options && options.storage ? options.storage : null;
    let f = 0;
    const totalFacets = meshInd.length / 3;
    if (number) {
      number = number > totalFacets ? totalFacets : number;
      size = Math.round(totalFacets / number);
      delta = 0;
    } else {
      size = size > totalFacets ? totalFacets : size;
    }
    const facetPos = [];
    const facetNor = [];
    const facetInd = [];
    const facetUV = [];
    const facetCol = [];
    const barycenter = Vector3.Zero();
    const sizeO = size;
    while (f < totalFacets) {
      size = sizeO + Math.floor((1 + delta) * Math.random());
      if (f > totalFacets - size) {
        size = totalFacets - f;
      }
      facetPos.length = 0;
      facetNor.length = 0;
      facetInd.length = 0;
      facetUV.length = 0;
      facetCol.length = 0;
      let fi = 0;
      for (let j = f * 3; j < (f + size) * 3; j++) {
        facetInd.push(fi);
        const i = meshInd[j];
        const i3 = i * 3;
        facetPos.push(meshPos[i3], meshPos[i3 + 1], meshPos[i3 + 2]);
        facetNor.push(meshNor[i3], meshNor[i3 + 1], meshNor[i3 + 2]);
        if (meshUV) {
          const i2 = i * 2;
          facetUV.push(meshUV[i2], meshUV[i2 + 1]);
        }
        if (meshCol) {
          const i4 = i * 4;
          facetCol.push(meshCol[i4], meshCol[i4 + 1], meshCol[i4 + 2], meshCol[i4 + 3]);
        }
        fi++;
      }
      let idx = this.nbParticles;
      const shape = this._posToShape(facetPos);
      const shapeUV = this._uvsToShapeUV(facetUV);
      const shapeInd = facetInd.slice();
      const shapeCol = facetCol.slice();
      const shapeNor = facetNor.slice();
      barycenter.copyFromFloats(0, 0, 0);
      let v;
      for (v = 0; v < shape.length; v++) {
        barycenter.addInPlace(shape[v]);
      }
      barycenter.scaleInPlace(1 / shape.length);
      const minimum = new Vector3(Infinity, Infinity, Infinity);
      const maximum = new Vector3(-Infinity, -Infinity, -Infinity);
      for (v = 0; v < shape.length; v++) {
        shape[v].subtractInPlace(barycenter);
        minimum.minimizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);
        maximum.maximizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);
      }
      let bInfo;
      if (this._particlesIntersect) {
        bInfo = new BoundingInfo(minimum, maximum);
      }
      let material = null;
      if (this._useModelMaterial) {
        material = mesh.material ? mesh.material : this._setDefaultMaterial();
      }
      const modelShape = new ModelShape(this._shapeCounter, shape, shapeInd, shapeNor, shapeCol, shapeUV, null, null, material);
      const currentPos = this._positions.length;
      const currentInd = this._indices.length;
      this._meshBuilder(this._index, currentInd, shape, this._positions, shapeInd, this._indices, facetUV, this._uvs, shapeCol, this._colors, shapeNor, this._normals, idx, 0, null, modelShape);
      this._addParticle(idx, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, 0, bInfo, storage);
      this.particles[this.nbParticles].position.addInPlace(barycenter);
      if (!storage) {
        this._index += shape.length;
        idx++;
        this.nbParticles++;
        this._lastParticleId++;
      }
      this._shapeCounter++;
      f += size;
    }
    this._isNotBuilt = true;
    return this;
  }
  _unrotateFixedNormals() {
    let index = 0;
    let idx = 0;
    const tmpNormal = TmpVectors.Vector3[0];
    const quaternion = TmpVectors.Quaternion[0];
    const invertedRotMatrix = TmpVectors.Matrix[0];
    for (let p = 0; p < this.particles.length; p++) {
      const particle = this.particles[p];
      const shape = particle._model._shape;
      if (particle.rotationQuaternion) {
        particle.rotationQuaternion.conjugateToRef(quaternion);
      } else {
        const rotation = particle.rotation;
        Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);
        quaternion.conjugateInPlace();
      }
      quaternion.toRotationMatrix(invertedRotMatrix);
      for (let pt = 0; pt < shape.length; pt++) {
        idx = index + pt * 3;
        Vector3.TransformNormalFromFloatsToRef(this._normals32[idx], this._normals32[idx + 1], this._normals32[idx + 2], invertedRotMatrix, tmpNormal);
        tmpNormal.toArray(this._fixedNormal32, idx);
      }
      index = idx + 3;
    }
  }
  _resetCopy() {
    const copy = this._copy;
    copy.position.setAll(0);
    copy.rotation.setAll(0);
    copy.rotationQuaternion = null;
    copy.scaling.setAll(1);
    copy.uvs.copyFromFloats(0, 0, 1, 1);
    copy.color = null;
    copy.translateFromPivot = false;
    copy.shapeId = 0;
    copy.materialIndex = null;
  }
  _meshBuilder(p, ind, shape, positions, meshInd, indices, meshUV, uvs, meshCol, colors, meshNor, normals, idx, idxInShape, options, model) {
    let i;
    let u = 0;
    let c = 0;
    let n = 0;
    this._resetCopy();
    const copy = this._copy;
    const storeApart = options && options.storage ? true : false;
    copy.idx = idx;
    copy.idxInShape = idxInShape;
    copy.shapeId = model.shapeId;
    if (this._useModelMaterial) {
      const materialId = model._material.uniqueId;
      const materialIndexesById = this._materialIndexesById;
      if (!Object.prototype.hasOwnProperty.call(materialIndexesById, materialId)) {
        materialIndexesById[materialId] = this._materials.length;
        this._materials.push(model._material);
      }
      const matIdx = materialIndexesById[materialId];
      copy.materialIndex = matIdx;
    }
    if (options && options.positionFunction) {
      options.positionFunction(copy, idx, idxInShape);
      this._mustUnrotateFixedNormals = true;
    }
    if (storeApart) {
      return copy;
    }
    const rotMatrix = TmpVectors.Matrix[0];
    const tmpVertex = this._tmpVertex;
    const tmpVector = tmpVertex.position;
    const tmpColor = tmpVertex.color;
    const tmpUV = tmpVertex.uv;
    const tmpRotated = TmpVectors.Vector3[1];
    const pivotBackTranslation = TmpVectors.Vector3[2];
    const scaledPivot = TmpVectors.Vector3[3];
    Matrix.IdentityToRef(rotMatrix);
    copy.getRotationMatrix(rotMatrix);
    copy.pivot.multiplyToRef(copy.scaling, scaledPivot);
    if (copy.translateFromPivot) {
      pivotBackTranslation.setAll(0);
    } else {
      pivotBackTranslation.copyFrom(scaledPivot);
    }
    const someVertexFunction = options && options.vertexFunction;
    for (i = 0; i < shape.length; i++) {
      tmpVector.copyFrom(shape[i]);
      if (copy.color) {
        tmpColor.copyFrom(copy.color);
      }
      if (meshUV) {
        tmpUV.copyFromFloats(meshUV[u], meshUV[u + 1]);
      }
      if (someVertexFunction) {
        options.vertexFunction(copy, tmpVertex, i);
      }
      tmpVector.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);
      Vector3.TransformCoordinatesToRef(tmpVector, rotMatrix, tmpRotated);
      tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position);
      positions.push(tmpRotated.x, tmpRotated.y, tmpRotated.z);
      if (meshUV) {
        const copyUvs = copy.uvs;
        uvs.push((copyUvs.z - copyUvs.x) * tmpUV.x + copyUvs.x, (copyUvs.w - copyUvs.y) * tmpUV.y + copyUvs.y);
        u += 2;
      }
      if (copy.color) {
        this._color.copyFrom(tmpColor);
      } else {
        const color = this._color;
        if (meshCol && meshCol[c] !== void 0) {
          color.r = meshCol[c];
          color.g = meshCol[c + 1];
          color.b = meshCol[c + 2];
          color.a = meshCol[c + 3];
        } else {
          color.r = 1;
          color.g = 1;
          color.b = 1;
          color.a = 1;
        }
      }
      colors.push(this._color.r, this._color.g, this._color.b, this._color.a);
      c += 4;
      if (!this.recomputeNormals && meshNor) {
        Vector3.TransformNormalFromFloatsToRef(meshNor[n], meshNor[n + 1], meshNor[n + 2], rotMatrix, tmpVector);
        normals.push(tmpVector.x, tmpVector.y, tmpVector.z);
        n += 3;
      }
    }
    for (i = 0; i < meshInd.length; i++) {
      const current_ind = p + meshInd[i];
      indices.push(current_ind);
      if (current_ind > 65535) {
        this._needs32Bits = true;
      }
    }
    if (this._depthSort || this._multimaterialEnabled) {
      const matIndex = copy.materialIndex !== null ? copy.materialIndex : 0;
      this.depthSortedParticles.push(new DepthSortedParticle(idx, ind, meshInd.length, matIndex));
    }
    return copy;
  }
  _posToShape(positions) {
    const shape = [];
    for (let i = 0; i < positions.length; i += 3) {
      shape.push(Vector3.FromArray(positions, i));
    }
    return shape;
  }
  _uvsToShapeUV(uvs) {
    const shapeUV = [];
    if (uvs) {
      for (let i = 0; i < uvs.length; i++) {
        shapeUV.push(uvs[i]);
      }
    }
    return shapeUV;
  }
  _addParticle(idx, id, idxpos, idxind, model, shapeId, idxInShape, bInfo = null, storage = null) {
    const sp = new SolidParticle(idx, id, idxpos, idxind, model, shapeId, idxInShape, this, bInfo);
    const target = storage ? storage : this.particles;
    target.push(sp);
    return sp;
  }
  addShape(mesh, nb, options) {
    const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);
    const meshInd = mesh.getIndices();
    const meshUV = mesh.getVerticesData(VertexBuffer.UVKind);
    const meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);
    const meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);
    this.recomputeNormals = meshNor ? false : true;
    const indices = Array.from(meshInd);
    const shapeNormals = Array.from(meshNor);
    const shapeColors = meshCol ? Array.from(meshCol) : [];
    const storage = options && options.storage ? options.storage : null;
    let bbInfo = null;
    if (this._particlesIntersect) {
      bbInfo = mesh.getBoundingInfo();
    }
    const shape = this._posToShape(meshPos);
    const shapeUV = this._uvsToShapeUV(meshUV);
    const posfunc = options ? options.positionFunction : null;
    const vtxfunc = options ? options.vertexFunction : null;
    let material = null;
    if (this._useModelMaterial) {
      material = mesh.material ? mesh.material : this._setDefaultMaterial();
    }
    const modelShape = new ModelShape(this._shapeCounter, shape, indices, shapeNormals, shapeColors, shapeUV, posfunc, vtxfunc, material);
    for (let i = 0; i < nb; i++) {
      this._insertNewParticle(this.nbParticles, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options);
    }
    this._shapeCounter++;
    this._isNotBuilt = true;
    return this._shapeCounter - 1;
  }
  _rebuildParticle(particle, reset = false) {
    this._resetCopy();
    const copy = this._copy;
    if (particle._model._positionFunction) {
      particle._model._positionFunction(copy, particle.idx, particle.idxInShape);
    }
    const rotMatrix = TmpVectors.Matrix[0];
    const tmpVertex = TmpVectors.Vector3[0];
    const tmpRotated = TmpVectors.Vector3[1];
    const pivotBackTranslation = TmpVectors.Vector3[2];
    const scaledPivot = TmpVectors.Vector3[3];
    copy.getRotationMatrix(rotMatrix);
    particle.pivot.multiplyToRef(particle.scaling, scaledPivot);
    if (copy.translateFromPivot) {
      pivotBackTranslation.copyFromFloats(0, 0, 0);
    } else {
      pivotBackTranslation.copyFrom(scaledPivot);
    }
    const shape = particle._model._shape;
    for (let pt = 0; pt < shape.length; pt++) {
      tmpVertex.copyFrom(shape[pt]);
      if (particle._model._vertexFunction) {
        particle._model._vertexFunction(copy, tmpVertex, pt);
      }
      tmpVertex.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);
      Vector3.TransformCoordinatesToRef(tmpVertex, rotMatrix, tmpRotated);
      tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position).toArray(this._positions32, particle._pos + pt * 3);
    }
    if (reset) {
      particle.position.setAll(0);
      particle.rotation.setAll(0);
      particle.rotationQuaternion = null;
      particle.scaling.setAll(1);
      particle.uvs.setAll(0);
      particle.pivot.setAll(0);
      particle.translateFromPivot = false;
      particle.parentId = null;
    }
  }
  rebuildMesh(reset = false) {
    for (let p = 0; p < this.particles.length; p++) {
      this._rebuildParticle(this.particles[p], reset);
    }
    this.mesh.updateVerticesData(VertexBuffer.PositionKind, this._positions32, false, false);
    return this;
  }
  removeParticles(start, end) {
    const nb = end - start + 1;
    if (!this._expandable || nb <= 0 || nb >= this.nbParticles || !this._updatable) {
      return [];
    }
    const particles = this.particles;
    const currentNb = this.nbParticles;
    if (end < currentNb - 1) {
      const firstRemaining = end + 1;
      const shiftPos = particles[firstRemaining]._pos - particles[start]._pos;
      const shifInd = particles[firstRemaining]._ind - particles[start]._ind;
      for (let i = firstRemaining; i < currentNb; i++) {
        const part = particles[i];
        part._pos -= shiftPos;
        part._ind -= shifInd;
      }
    }
    const removed = particles.splice(start, nb);
    this._positions.length = 0;
    this._indices.length = 0;
    this._colors.length = 0;
    this._uvs.length = 0;
    this._normals.length = 0;
    this._index = 0;
    this._idxOfId.length = 0;
    if (this._depthSort || this._multimaterialEnabled) {
      this.depthSortedParticles = [];
    }
    let ind = 0;
    const particlesLength = particles.length;
    for (let p = 0; p < particlesLength; p++) {
      const particle = particles[p];
      const model = particle._model;
      const shape = model._shape;
      const modelIndices = model._indices;
      const modelNormals = model._normals;
      const modelColors = model._shapeColors;
      const modelUVs = model._shapeUV;
      particle.idx = p;
      this._idxOfId[particle.id] = p;
      this._meshBuilder(this._index, ind, shape, this._positions, modelIndices, this._indices, modelUVs, this._uvs, modelColors, this._colors, modelNormals, this._normals, particle.idx, particle.idxInShape, null, model);
      this._index += shape.length;
      ind += modelIndices.length;
    }
    this.nbParticles -= nb;
    this._isNotBuilt = true;
    return removed;
  }
  insertParticlesFromArray(solidParticleArray) {
    if (!this._expandable) {
      return this;
    }
    let idxInShape = 0;
    let currentShapeId = solidParticleArray[0].shapeId;
    const nb = solidParticleArray.length;
    for (let i = 0; i < nb; i++) {
      const sp = solidParticleArray[i];
      const model = sp._model;
      const shape = model._shape;
      const meshInd = model._indices;
      const meshUV = model._shapeUV;
      const meshCol = model._shapeColors;
      const meshNor = model._normals;
      const noNor = meshNor ? false : true;
      this.recomputeNormals = noNor || this.recomputeNormals;
      const bbInfo = sp.getBoundingInfo();
      const newPart = this._insertNewParticle(this.nbParticles, idxInShape, model, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, null, null);
      sp.copyToRef(newPart);
      idxInShape++;
      if (currentShapeId != sp.shapeId) {
        currentShapeId = sp.shapeId;
        idxInShape = 0;
      }
    }
    this._isNotBuilt = true;
    return this;
  }
  _insertNewParticle(idx, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options) {
    const currentPos = this._positions.length;
    const currentInd = this._indices.length;
    const currentCopy = this._meshBuilder(this._index, currentInd, shape, this._positions, meshInd, this._indices, meshUV, this._uvs, meshCol, this._colors, meshNor, this._normals, idx, i, options, modelShape);
    let sp = null;
    if (this._updatable) {
      sp = this._addParticle(this.nbParticles, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, i, bbInfo, storage);
      sp.position.copyFrom(currentCopy.position);
      sp.rotation.copyFrom(currentCopy.rotation);
      if (currentCopy.rotationQuaternion) {
        if (sp.rotationQuaternion) {
          sp.rotationQuaternion.copyFrom(currentCopy.rotationQuaternion);
        } else {
          sp.rotationQuaternion = currentCopy.rotationQuaternion.clone();
        }
      }
      if (currentCopy.color) {
        if (sp.color) {
          sp.color.copyFrom(currentCopy.color);
        } else {
          sp.color = currentCopy.color.clone();
        }
      }
      sp.scaling.copyFrom(currentCopy.scaling);
      sp.uvs.copyFrom(currentCopy.uvs);
      if (currentCopy.materialIndex !== null) {
        sp.materialIndex = currentCopy.materialIndex;
      }
      if (this.expandable) {
        this._idxOfId[sp.id] = sp.idx;
      }
    }
    if (!storage) {
      this._index += shape.length;
      this.nbParticles++;
      this._lastParticleId++;
    }
    return sp;
  }
  setParticles(start = 0, end = this.nbParticles - 1, update = true) {
    if (!this._updatable || this._isNotBuilt) {
      return this;
    }
    this.beforeUpdateParticles(start, end, update);
    const rotMatrix = TmpVectors.Matrix[0];
    const invertedMatrix = TmpVectors.Matrix[1];
    const mesh = this.mesh;
    const colors32 = this._colors32;
    const positions32 = this._positions32;
    const normals32 = this._normals32;
    const uvs32 = this._uvs32;
    const indices32 = this._indices32;
    const indices = this._indices;
    const fixedNormal32 = this._fixedNormal32;
    const depthSortParticles = this._depthSort && this._depthSortParticles;
    const tempVectors = TmpVectors.Vector3;
    const camAxisX = tempVectors[5].copyFromFloats(1, 0, 0);
    const camAxisY = tempVectors[6].copyFromFloats(0, 1, 0);
    const camAxisZ = tempVectors[7].copyFromFloats(0, 0, 1);
    const minimum = tempVectors[8].setAll(Number.MAX_VALUE);
    const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);
    const camInvertedPosition = tempVectors[10].setAll(0);
    const tmpVertex = this._tmpVertex;
    const tmpVector = tmpVertex.position;
    const tmpColor = tmpVertex.color;
    const tmpUV = tmpVertex.uv;
    if (this.billboard || this._depthSort) {
      this.mesh.computeWorldMatrix(true);
      this.mesh._worldMatrix.invertToRef(invertedMatrix);
    }
    if (this.billboard) {
      const tmpVector0 = tempVectors[0];
      this._camera.getDirectionToRef(Axis.Z, tmpVector0);
      Vector3.TransformNormalToRef(tmpVector0, invertedMatrix, camAxisZ);
      camAxisZ.normalize();
      const view = this._camera.getViewMatrix(true);
      Vector3.TransformNormalFromFloatsToRef(view.m[1], view.m[5], view.m[9], invertedMatrix, camAxisY);
      Vector3.CrossToRef(camAxisY, camAxisZ, camAxisX);
      camAxisY.normalize();
      camAxisX.normalize();
    }
    if (this._depthSort) {
      Vector3.TransformCoordinatesToRef(this._camera.globalPosition, invertedMatrix, camInvertedPosition);
    }
    Matrix.IdentityToRef(rotMatrix);
    let idx = 0;
    let index = 0;
    let colidx = 0;
    let colorIndex = 0;
    let uvidx = 0;
    let uvIndex = 0;
    let pt = 0;
    if (this.mesh.isFacetDataEnabled) {
      this._computeBoundingBox = true;
    }
    end = end >= this.nbParticles ? this.nbParticles - 1 : end;
    if (this._computeBoundingBox) {
      if (start != 0 || end != this.nbParticles - 1) {
        const boundingInfo = this.mesh.getBoundingInfo();
        if (boundingInfo) {
          minimum.copyFrom(boundingInfo.minimum);
          maximum.copyFrom(boundingInfo.maximum);
        }
      }
    }
    index = this.particles[start]._pos;
    const vpos = index / 3 | 0;
    colorIndex = vpos * 4;
    uvIndex = vpos * 2;
    for (let p = start; p <= end; p++) {
      const particle = this.particles[p];
      this.updateParticle(particle);
      const shape = particle._model._shape;
      const shapeUV = particle._model._shapeUV;
      const particleRotationMatrix = particle._rotationMatrix;
      const particlePosition = particle.position;
      const particleRotation = particle.rotation;
      const particleScaling = particle.scaling;
      const particleGlobalPosition = particle._globalPosition;
      if (depthSortParticles) {
        const dsp = this.depthSortedParticles[p];
        dsp.idx = particle.idx;
        dsp.ind = particle._ind;
        dsp.indicesLength = particle._model._indicesLength;
        dsp.sqDistance = Vector3.DistanceSquared(particle.position, camInvertedPosition);
      }
      if (!particle.alive || particle._stillInvisible && !particle.isVisible && !this._recomputeInvisibles) {
        pt = shape.length;
        index += pt * 3;
        colorIndex += pt * 4;
        uvIndex += pt * 2;
        continue;
      }
      if (particle.isVisible) {
        particle._stillInvisible = false;
        const scaledPivot = tempVectors[12];
        particle.pivot.multiplyToRef(particleScaling, scaledPivot);
        if (this.billboard) {
          particleRotation.x = 0;
          particleRotation.y = 0;
        }
        if (this._computeParticleRotation || this.billboard) {
          particle.getRotationMatrix(rotMatrix);
        }
        const particleHasParent = particle.parentId !== null;
        if (particleHasParent) {
          const parent = this.getParticleById(particle.parentId);
          if (parent) {
            const parentRotationMatrix = parent._rotationMatrix;
            const parentGlobalPosition = parent._globalPosition;
            const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];
            const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];
            const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];
            particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;
            particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;
            particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;
            if (this._computeParticleRotation || this.billboard) {
              const rotMatrixValues = rotMatrix.m;
              particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];
              particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];
              particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];
              particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];
              particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];
              particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];
              particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];
              particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];
              particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];
            }
          } else {
            particle.parentId = null;
          }
        } else {
          particleGlobalPosition.x = particlePosition.x;
          particleGlobalPosition.y = particlePosition.y;
          particleGlobalPosition.z = particlePosition.z;
          if (this._computeParticleRotation || this.billboard) {
            const rotMatrixValues = rotMatrix.m;
            particleRotationMatrix[0] = rotMatrixValues[0];
            particleRotationMatrix[1] = rotMatrixValues[1];
            particleRotationMatrix[2] = rotMatrixValues[2];
            particleRotationMatrix[3] = rotMatrixValues[4];
            particleRotationMatrix[4] = rotMatrixValues[5];
            particleRotationMatrix[5] = rotMatrixValues[6];
            particleRotationMatrix[6] = rotMatrixValues[8];
            particleRotationMatrix[7] = rotMatrixValues[9];
            particleRotationMatrix[8] = rotMatrixValues[10];
          }
        }
        const pivotBackTranslation = tempVectors[11];
        if (particle.translateFromPivot) {
          pivotBackTranslation.setAll(0);
        } else {
          pivotBackTranslation.copyFrom(scaledPivot);
        }
        for (pt = 0; pt < shape.length; pt++) {
          idx = index + pt * 3;
          colidx = colorIndex + pt * 4;
          uvidx = uvIndex + pt * 2;
          const iu = 2 * pt;
          const iv = iu + 1;
          tmpVector.copyFrom(shape[pt]);
          if (this._computeParticleColor && particle.color) {
            tmpColor.copyFrom(particle.color);
          }
          if (this._computeParticleTexture) {
            tmpUV.copyFromFloats(shapeUV[iu], shapeUV[iv]);
          }
          if (this._computeParticleVertex) {
            this.updateParticleVertex(particle, tmpVertex, pt);
          }
          const vertexX = tmpVector.x * particleScaling.x - scaledPivot.x;
          const vertexY = tmpVector.y * particleScaling.y - scaledPivot.y;
          const vertexZ = tmpVector.z * particleScaling.z - scaledPivot.z;
          let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];
          let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];
          let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];
          rotatedX += pivotBackTranslation.x;
          rotatedY += pivotBackTranslation.y;
          rotatedZ += pivotBackTranslation.z;
          const px = positions32[idx] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;
          const py = positions32[idx + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;
          const pz = positions32[idx + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;
          if (this._computeBoundingBox) {
            minimum.minimizeInPlaceFromFloats(px, py, pz);
            maximum.maximizeInPlaceFromFloats(px, py, pz);
          }
          if (!this._computeParticleVertex) {
            const normalx = fixedNormal32[idx];
            const normaly = fixedNormal32[idx + 1];
            const normalz = fixedNormal32[idx + 2];
            const rotatedx = normalx * particleRotationMatrix[0] + normaly * particleRotationMatrix[3] + normalz * particleRotationMatrix[6];
            const rotatedy = normalx * particleRotationMatrix[1] + normaly * particleRotationMatrix[4] + normalz * particleRotationMatrix[7];
            const rotatedz = normalx * particleRotationMatrix[2] + normaly * particleRotationMatrix[5] + normalz * particleRotationMatrix[8];
            normals32[idx] = camAxisX.x * rotatedx + camAxisY.x * rotatedy + camAxisZ.x * rotatedz;
            normals32[idx + 1] = camAxisX.y * rotatedx + camAxisY.y * rotatedy + camAxisZ.y * rotatedz;
            normals32[idx + 2] = camAxisX.z * rotatedx + camAxisY.z * rotatedy + camAxisZ.z * rotatedz;
          }
          if (this._computeParticleColor && particle.color) {
            const colors322 = this._colors32;
            colors322[colidx] = tmpColor.r;
            colors322[colidx + 1] = tmpColor.g;
            colors322[colidx + 2] = tmpColor.b;
            colors322[colidx + 3] = tmpColor.a;
          }
          if (this._computeParticleTexture) {
            const uvs = particle.uvs;
            uvs32[uvidx] = tmpUV.x * (uvs.z - uvs.x) + uvs.x;
            uvs32[uvidx + 1] = tmpUV.y * (uvs.w - uvs.y) + uvs.y;
          }
        }
      } else {
        particle._stillInvisible = true;
        for (pt = 0; pt < shape.length; pt++) {
          idx = index + pt * 3;
          colidx = colorIndex + pt * 4;
          uvidx = uvIndex + pt * 2;
          positions32[idx] = positions32[idx + 1] = positions32[idx + 2] = 0;
          normals32[idx] = normals32[idx + 1] = normals32[idx + 2] = 0;
          if (this._computeParticleColor && particle.color) {
            const color = particle.color;
            colors32[colidx] = color.r;
            colors32[colidx + 1] = color.g;
            colors32[colidx + 2] = color.b;
            colors32[colidx + 3] = color.a;
          }
          if (this._computeParticleTexture) {
            const uvs = particle.uvs;
            uvs32[uvidx] = shapeUV[pt * 2] * (uvs.z - uvs.x) + uvs.x;
            uvs32[uvidx + 1] = shapeUV[pt * 2 + 1] * (uvs.w - uvs.y) + uvs.y;
          }
        }
      }
      if (this._particlesIntersect) {
        const bInfo = particle.getBoundingInfo();
        const bBox = bInfo.boundingBox;
        const bSphere = bInfo.boundingSphere;
        const modelBoundingInfo = particle._modelBoundingInfo;
        if (!this._bSphereOnly) {
          const modelBoundingInfoVectors = modelBoundingInfo.boundingBox.vectors;
          const tempMin = tempVectors[1];
          const tempMax = tempVectors[2];
          tempMin.setAll(Number.MAX_VALUE);
          tempMax.setAll(-Number.MAX_VALUE);
          for (let b = 0; b < 8; b++) {
            const scaledX = modelBoundingInfoVectors[b].x * particleScaling.x;
            const scaledY = modelBoundingInfoVectors[b].y * particleScaling.y;
            const scaledZ = modelBoundingInfoVectors[b].z * particleScaling.z;
            const rotatedX = scaledX * particleRotationMatrix[0] + scaledY * particleRotationMatrix[3] + scaledZ * particleRotationMatrix[6];
            const rotatedY = scaledX * particleRotationMatrix[1] + scaledY * particleRotationMatrix[4] + scaledZ * particleRotationMatrix[7];
            const rotatedZ = scaledX * particleRotationMatrix[2] + scaledY * particleRotationMatrix[5] + scaledZ * particleRotationMatrix[8];
            const x = particlePosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;
            const y = particlePosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;
            const z = particlePosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;
            tempMin.minimizeInPlaceFromFloats(x, y, z);
            tempMax.maximizeInPlaceFromFloats(x, y, z);
          }
          bBox.reConstruct(tempMin, tempMax, mesh._worldMatrix);
        }
        const minBbox = modelBoundingInfo.minimum.multiplyToRef(particleScaling, tempVectors[1]);
        const maxBbox = modelBoundingInfo.maximum.multiplyToRef(particleScaling, tempVectors[2]);
        const bSphereCenter = maxBbox.addToRef(minBbox, tempVectors[3]).scaleInPlace(0.5).addInPlace(particleGlobalPosition);
        const halfDiag = maxBbox.subtractToRef(minBbox, tempVectors[4]).scaleInPlace(0.5 * this._bSphereRadiusFactor);
        const bSphereMinBbox = bSphereCenter.subtractToRef(halfDiag, tempVectors[1]);
        const bSphereMaxBbox = bSphereCenter.addToRef(halfDiag, tempVectors[2]);
        bSphere.reConstruct(bSphereMinBbox, bSphereMaxBbox, mesh._worldMatrix);
      }
      index = idx + 3;
      colorIndex = colidx + 4;
      uvIndex = uvidx + 2;
    }
    if (update) {
      if (this._computeParticleColor) {
        const vb = mesh.getVertexBuffer(VertexBuffer.ColorKind);
        if (vb && !mesh.isPickable) {
          vb.updateDirectly(colors32, 0);
        } else {
          mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);
        }
      }
      if (this._computeParticleTexture) {
        const vb = mesh.getVertexBuffer(VertexBuffer.UVKind);
        if (vb && !mesh.isPickable) {
          vb.updateDirectly(uvs32, 0);
        } else {
          mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);
        }
      }
      const vbp = mesh.getVertexBuffer(VertexBuffer.PositionKind);
      if (vbp && !mesh.isPickable) {
        vbp.updateDirectly(positions32, 0);
      } else {
        mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);
      }
      if (!mesh.areNormalsFrozen || mesh.isFacetDataEnabled) {
        if (this._computeParticleVertex || mesh.isFacetDataEnabled) {
          const params = mesh.isFacetDataEnabled ? mesh.getFacetDataParameters() : null;
          VertexData.ComputeNormals(positions32, indices32, normals32, params);
          for (let i = 0; i < normals32.length; i++) {
            fixedNormal32[i] = normals32[i];
          }
        }
        if (!mesh.areNormalsFrozen) {
          const vb = mesh.getVertexBuffer(VertexBuffer.NormalKind);
          if (vb && !mesh.isPickable) {
            vb.updateDirectly(normals32, 0);
          } else {
            mesh.updateVerticesData(VertexBuffer.NormalKind, normals32, false, false);
          }
        }
      }
      if (depthSortParticles) {
        const depthSortedParticles = this.depthSortedParticles;
        depthSortedParticles.sort(this._depthSortFunction);
        const dspl = depthSortedParticles.length;
        let sid = 0;
        let faceId = 0;
        for (let sorted = 0; sorted < dspl; sorted++) {
          const sortedParticle = depthSortedParticles[sorted];
          const lind = sortedParticle.indicesLength;
          const sind = sortedParticle.ind;
          for (let i = 0; i < lind; i++) {
            indices32[sid] = indices[sind + i];
            sid++;
            if (this._pickable) {
              const f = i % 3;
              if (f == 0) {
                const pickedData = this.pickedParticles[faceId];
                pickedData.idx = sortedParticle.idx;
                pickedData.faceId = faceId;
                faceId++;
              }
            }
          }
        }
      }
      if (this._autoFixFaceOrientation) {
        let particleInd = 0;
        for (let particleIdx = 0; particleIdx < this.particles.length; particleIdx++) {
          const particle = depthSortParticles ? this.particles[this.depthSortedParticles[particleIdx].idx] : this.particles[particleIdx];
          const flipFaces = particle.scale.x * particle.scale.y * particle.scale.z < 0;
          if (flipFaces) {
            for (let faceInd = 0; faceInd < particle._model._indicesLength; faceInd += 3) {
              const tmp = indices[particle._ind + faceInd];
              indices32[particleInd + faceInd] = indices[particle._ind + faceInd + 1];
              indices32[particleInd + faceInd + 1] = tmp;
            }
          }
          particleInd += particle._model._indicesLength;
        }
      }
      if (depthSortParticles || this._autoFixFaceOrientation) {
        mesh.updateIndices(indices32);
      }
    }
    if (this._computeBoundingBox) {
      if (mesh.hasBoundingInfo) {
        mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);
      } else {
        mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);
      }
    }
    if (this._autoUpdateSubMeshes) {
      this.computeSubMeshes();
    }
    this._recomputeInvisibles = false;
    this.afterUpdateParticles(start, end, update);
    return this;
  }
  dispose() {
    this.mesh.dispose();
    this.vars = null;
    this._positions = null;
    this._indices = null;
    this._normals = null;
    this._uvs = null;
    this._colors = null;
    this._indices32 = null;
    this._positions32 = null;
    this._normals32 = null;
    this._fixedNormal32 = null;
    this._uvs32 = null;
    this._colors32 = null;
    this.pickedParticles = null;
    this.pickedBySubMesh = null;
    this._materials = null;
    this._materialIndexes = null;
    this._indicesByMaterial = null;
    this._idxOfId = null;
  }
  pickedParticle(pickingInfo) {
    if (pickingInfo.hit) {
      const subMesh = pickingInfo.subMeshId;
      const faceId = pickingInfo.faceId - this.mesh.subMeshes[subMesh].indexStart / 3;
      const picked = this.pickedBySubMesh;
      if (picked[subMesh] && picked[subMesh][faceId]) {
        return picked[subMesh][faceId];
      }
    }
    return null;
  }
  getParticleById(id) {
    const p = this.particles[id];
    if (p && p.id == id) {
      return p;
    }
    const particles = this.particles;
    const idx = this._idxOfId[id];
    if (idx !== void 0) {
      return particles[idx];
    }
    let i = 0;
    const nb = this.nbParticles;
    while (i < nb) {
      const particle = particles[i];
      if (particle.id == id) {
        return particle;
      }
      i++;
    }
    return null;
  }
  getParticlesByShapeId(shapeId) {
    const ref = [];
    this.getParticlesByShapeIdToRef(shapeId, ref);
    return ref;
  }
  getParticlesByShapeIdToRef(shapeId, ref) {
    ref.length = 0;
    for (let i = 0; i < this.nbParticles; i++) {
      const p = this.particles[i];
      if (p.shapeId == shapeId) {
        ref.push(p);
      }
    }
    return this;
  }
  computeSubMeshes() {
    if (!this.mesh || !this._multimaterialEnabled) {
      return this;
    }
    const depthSortedParticles = this.depthSortedParticles;
    if (this.particles.length > 0) {
      for (let p = 0; p < this.particles.length; p++) {
        const part = this.particles[p];
        if (!part.materialIndex) {
          part.materialIndex = 0;
        }
        const sortedPart = depthSortedParticles[p];
        sortedPart.materialIndex = part.materialIndex;
        sortedPart.ind = part._ind;
        sortedPart.indicesLength = part._model._indicesLength;
        sortedPart.idx = part.idx;
      }
    }
    this._sortParticlesByMaterial();
    const indicesByMaterial = this._indicesByMaterial;
    const materialIndexes = this._materialIndexes;
    const mesh = this.mesh;
    mesh.subMeshes = [];
    const vcount = mesh.getTotalVertices();
    for (let m = 0; m < materialIndexes.length; m++) {
      const start = indicesByMaterial[m];
      const count = indicesByMaterial[m + 1] - start;
      const matIndex = materialIndexes[m];
      new SubMesh(matIndex, 0, vcount, start, count, mesh);
    }
    return this;
  }
  _sortParticlesByMaterial() {
    const indicesByMaterial = [0];
    this._indicesByMaterial = indicesByMaterial;
    const materialIndexes = [];
    this._materialIndexes = materialIndexes;
    const depthSortedParticles = this.depthSortedParticles;
    depthSortedParticles.sort(this._materialSortFunction);
    const length = depthSortedParticles.length;
    const indices32 = this._indices32;
    const indices = this._indices;
    let subMeshIndex = 0;
    let subMeshFaceId = 0;
    let sid = 0;
    let lastMatIndex = depthSortedParticles[0].materialIndex;
    materialIndexes.push(lastMatIndex);
    if (this._pickable) {
      this.pickedBySubMesh = [[]];
      this.pickedParticles = this.pickedBySubMesh[0];
    }
    for (let sorted = 0; sorted < length; sorted++) {
      const sortedPart = depthSortedParticles[sorted];
      const lind = sortedPart.indicesLength;
      const sind = sortedPart.ind;
      if (sortedPart.materialIndex !== lastMatIndex) {
        lastMatIndex = sortedPart.materialIndex;
        indicesByMaterial.push(sid);
        materialIndexes.push(lastMatIndex);
        if (this._pickable) {
          subMeshIndex++;
          this.pickedBySubMesh[subMeshIndex] = [];
          subMeshFaceId = 0;
        }
      }
      let faceId = 0;
      for (let i = 0; i < lind; i++) {
        indices32[sid] = indices[sind + i];
        if (this._pickable) {
          const f = i % 3;
          if (f == 0) {
            const pickedData = this.pickedBySubMesh[subMeshIndex][subMeshFaceId];
            if (pickedData) {
              pickedData.idx = sortedPart.idx;
              pickedData.faceId = faceId;
            } else {
              this.pickedBySubMesh[subMeshIndex][subMeshFaceId] = { idx: sortedPart.idx, faceId };
            }
            subMeshFaceId++;
            faceId++;
          }
        }
        sid++;
      }
    }
    indicesByMaterial.push(indices32.length);
    if (this._updatable) {
      this.mesh.updateIndices(indices32);
    }
    return this;
  }
  _setMaterialIndexesById() {
    this._materialIndexesById = {};
    for (let i = 0; i < this._materials.length; i++) {
      const id = this._materials[i].uniqueId;
      this._materialIndexesById[id] = i;
    }
  }
  _filterUniqueMaterialId(array) {
    const filtered = array.filter(function(value, index, self2) {
      return self2.indexOf(value) === index;
    });
    return filtered;
  }
  _setDefaultMaterial() {
    if (!this._defaultMaterial) {
      this._defaultMaterial = new StandardMaterial(this.name + "DefaultMaterial", this._scene);
    }
    return this._defaultMaterial;
  }
  refreshVisibleSize() {
    if (!this._isVisibilityBoxLocked) {
      this.mesh.refreshBoundingInfo();
    }
    return this;
  }
  setVisibilityBox(size) {
    const vis = size / 2;
    this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));
  }
  get isAlwaysVisible() {
    return this._alwaysVisible;
  }
  set isAlwaysVisible(val) {
    this._alwaysVisible = val;
    this.mesh.alwaysSelectAsActiveMesh = val;
  }
  set isVisibilityBoxLocked(val) {
    this._isVisibilityBoxLocked = val;
    const boundingInfo = this.mesh.getBoundingInfo();
    boundingInfo.isLocked = val;
  }
  get isVisibilityBoxLocked() {
    return this._isVisibilityBoxLocked;
  }
  set computeParticleRotation(val) {
    this._computeParticleRotation = val;
  }
  set computeParticleColor(val) {
    this._computeParticleColor = val;
  }
  set computeParticleTexture(val) {
    this._computeParticleTexture = val;
  }
  set computeParticleVertex(val) {
    this._computeParticleVertex = val;
  }
  set computeBoundingBox(val) {
    this._computeBoundingBox = val;
  }
  set depthSortParticles(val) {
    this._depthSortParticles = val;
  }
  get computeParticleRotation() {
    return this._computeParticleRotation;
  }
  get computeParticleColor() {
    return this._computeParticleColor;
  }
  get computeParticleTexture() {
    return this._computeParticleTexture;
  }
  get computeParticleVertex() {
    return this._computeParticleVertex;
  }
  get computeBoundingBox() {
    return this._computeBoundingBox;
  }
  get depthSortParticles() {
    return this._depthSortParticles;
  }
  get expandable() {
    return this._expandable;
  }
  get multimaterialEnabled() {
    return this._multimaterialEnabled;
  }
  get useModelMaterial() {
    return this._useModelMaterial;
  }
  get materials() {
    return this._materials;
  }
  setMultiMaterial(materials) {
    this._materials = this._filterUniqueMaterialId(materials);
    this._setMaterialIndexesById();
    if (this._multimaterial) {
      this._multimaterial.dispose();
    }
    this._multimaterial = new MultiMaterial(this.name + "MultiMaterial", this._scene);
    for (let m = 0; m < this._materials.length; m++) {
      this._multimaterial.subMaterials.push(this._materials[m]);
    }
    this.computeSubMeshes();
    this.mesh.material = this._multimaterial;
  }
  get multimaterial() {
    return this._multimaterial;
  }
  set multimaterial(mm) {
    this._multimaterial = mm;
  }
  get autoUpdateSubMeshes() {
    return this._autoUpdateSubMeshes;
  }
  set autoUpdateSubMeshes(val) {
    this._autoUpdateSubMeshes = val;
  }
  initParticles() {
  }
  recycleParticle(particle) {
    return particle;
  }
  updateParticle(particle) {
    return particle;
  }
  updateParticleVertex(particle, vertex, pt) {
    return this;
  }
  beforeUpdateParticles(start, stop, update) {
  }
  afterUpdateParticles(start, stop, update) {
  }
};

// node_modules/@babylonjs/core/Particles/cloudPoint.js
var CloudPoint = class {
  constructor(particleIndex, group, groupId, idxInGroup, pcs) {
    this.idx = 0;
    this.color = new Color4(1, 1, 1, 1);
    this.position = Vector3.Zero();
    this.rotation = Vector3.Zero();
    this.uv = new Vector2(0, 0);
    this.velocity = Vector3.Zero();
    this.pivot = Vector3.Zero();
    this.translateFromPivot = false;
    this._pos = 0;
    this._ind = 0;
    this.groupId = 0;
    this.idxInGroup = 0;
    this._stillInvisible = false;
    this._rotationMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    this.parentId = null;
    this._globalPosition = Vector3.Zero();
    this.idx = particleIndex;
    this._group = group;
    this.groupId = groupId;
    this.idxInGroup = idxInGroup;
    this._pcs = pcs;
  }
  get size() {
    return this.size;
  }
  set size(scale) {
    this.size = scale;
  }
  get quaternion() {
    return this.rotationQuaternion;
  }
  set quaternion(q) {
    this.rotationQuaternion = q;
  }
  intersectsMesh(target, isSphere) {
    if (!target.hasBoundingInfo) {
      return false;
    }
    if (!this._pcs.mesh) {
      throw new Error("Point Cloud System doesnt contain the Mesh");
    }
    if (isSphere) {
      return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));
    }
    const bbox = target.getBoundingInfo().boundingBox;
    const maxX = bbox.maximumWorld.x;
    const minX = bbox.minimumWorld.x;
    const maxY = bbox.maximumWorld.y;
    const minY = bbox.minimumWorld.y;
    const maxZ = bbox.maximumWorld.z;
    const minZ = bbox.minimumWorld.z;
    const x = this.position.x + this._pcs.mesh.position.x;
    const y = this.position.y + this._pcs.mesh.position.y;
    const z = this.position.z + this._pcs.mesh.position.z;
    return minX <= x && x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;
  }
  getRotationMatrix(m) {
    let quaternion;
    if (this.rotationQuaternion) {
      quaternion = this.rotationQuaternion;
    } else {
      quaternion = TmpVectors.Quaternion[0];
      const rotation = this.rotation;
      Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);
    }
    quaternion.toRotationMatrix(m);
  }
};
var PointsGroup = class {
  constructor(id, posFunction) {
    this.groupId = id;
    this._positionFunction = posFunction;
  }
  get groupID() {
    return this.groupId;
  }
  set groupID(groupID) {
    this.groupId = groupID;
  }
};

// node_modules/@babylonjs/core/Particles/pointsCloudSystem.js
var PointColor;
(function(PointColor2) {
  PointColor2[PointColor2["Color"] = 2] = "Color";
  PointColor2[PointColor2["UV"] = 1] = "UV";
  PointColor2[PointColor2["Random"] = 0] = "Random";
  PointColor2[PointColor2["Stated"] = 3] = "Stated";
})(PointColor || (PointColor = {}));
var PointsCloudSystem = class {
  constructor(name137, pointSize, scene, options) {
    this.particles = new Array();
    this.nbParticles = 0;
    this.counter = 0;
    this.vars = {};
    this._promises = [];
    this._positions = new Array();
    this._indices = new Array();
    this._normals = new Array();
    this._colors = new Array();
    this._uvs = new Array();
    this._updatable = true;
    this._isVisibilityBoxLocked = false;
    this._alwaysVisible = false;
    this._groups = new Array();
    this._groupCounter = 0;
    this._computeParticleColor = true;
    this._computeParticleTexture = true;
    this._computeParticleRotation = true;
    this._computeBoundingBox = false;
    this._isReady = false;
    this.name = name137;
    this._size = pointSize;
    this._scene = scene || EngineStore.LastCreatedScene;
    if (options && options.updatable !== void 0) {
      this._updatable = options.updatable;
    } else {
      this._updatable = true;
    }
  }
  get positions() {
    return this._positions32;
  }
  get colors() {
    return this._colors32;
  }
  get uvs() {
    return this._uvs32;
  }
  buildMeshAsync(material) {
    return Promise.all(this._promises).then(() => {
      this._isReady = true;
      return this._buildMesh(material);
    });
  }
  _buildMesh(material) {
    if (this.nbParticles === 0) {
      this.addPoints(1);
    }
    this._positions32 = new Float32Array(this._positions);
    this._uvs32 = new Float32Array(this._uvs);
    this._colors32 = new Float32Array(this._colors);
    const vertexData = new VertexData();
    vertexData.set(this._positions32, VertexBuffer.PositionKind);
    if (this._uvs32.length > 0) {
      vertexData.set(this._uvs32, VertexBuffer.UVKind);
    }
    let ec = 0;
    if (this._colors32.length > 0) {
      ec = 1;
      vertexData.set(this._colors32, VertexBuffer.ColorKind);
    }
    const mesh = new Mesh(this.name, this._scene);
    vertexData.applyToMesh(mesh, this._updatable);
    this.mesh = mesh;
    this._positions = null;
    this._uvs = null;
    this._colors = null;
    if (!this._updatable) {
      this.particles.length = 0;
    }
    let mat = material;
    if (!mat) {
      mat = new StandardMaterial("point cloud material", this._scene);
      mat.emissiveColor = new Color3(ec, ec, ec);
      mat.disableLighting = true;
      mat.pointsCloud = true;
      mat.pointSize = this._size;
    }
    mesh.material = mat;
    return new Promise((resolve) => resolve(mesh));
  }
  _addParticle(idx, group, groupId, idxInGroup) {
    const cp = new CloudPoint(idx, group, groupId, idxInGroup, this);
    this.particles.push(cp);
    return cp;
  }
  _randomUnitVector(particle) {
    particle.position = new Vector3(Math.random(), Math.random(), Math.random());
    particle.color = new Color4(1, 1, 1, 1);
  }
  _getColorIndicesForCoord(pointsGroup, x, y, width) {
    const imageData = pointsGroup._groupImageData;
    const color = y * (width * 4) + x * 4;
    const colorIndices = [color, color + 1, color + 2, color + 3];
    const redIndex = colorIndices[0];
    const greenIndex = colorIndices[1];
    const blueIndex = colorIndices[2];
    const alphaIndex = colorIndices[3];
    const redForCoord = imageData[redIndex];
    const greenForCoord = imageData[greenIndex];
    const blueForCoord = imageData[blueIndex];
    const alphaForCoord = imageData[alphaIndex];
    return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);
  }
  _setPointsColorOrUV(mesh, pointsGroup, isVolume, colorFromTexture, hasTexture, color, range) {
    if (isVolume) {
      mesh.updateFacetData();
    }
    const boundInfo = mesh.getBoundingInfo();
    const diameter = 2 * boundInfo.boundingSphere.radius;
    let meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);
    const meshInd = mesh.getIndices();
    const meshUV = mesh.getVerticesData(VertexBuffer.UVKind);
    const meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);
    const place = Vector3.Zero();
    mesh.computeWorldMatrix();
    const meshMatrix = mesh.getWorldMatrix();
    if (!meshMatrix.isIdentity()) {
      meshPos = meshPos.slice(0);
      for (let p = 0; p < meshPos.length / 3; p++) {
        Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);
        meshPos[3 * p] = place.x;
        meshPos[3 * p + 1] = place.y;
        meshPos[3 * p + 2] = place.z;
      }
    }
    let idxPoints = 0;
    let id0 = 0;
    let id1 = 0;
    let id2 = 0;
    let v0X = 0;
    let v0Y = 0;
    let v0Z = 0;
    let v1X = 0;
    let v1Y = 0;
    let v1Z = 0;
    let v2X = 0;
    let v2Y = 0;
    let v2Z = 0;
    const vertex0 = Vector3.Zero();
    const vertex1 = Vector3.Zero();
    const vertex2 = Vector3.Zero();
    const vec0 = Vector3.Zero();
    const vec1 = Vector3.Zero();
    let uv0X = 0;
    let uv0Y = 0;
    let uv1X = 0;
    let uv1Y = 0;
    let uv2X = 0;
    let uv2Y = 0;
    const uv0 = Vector2.Zero();
    const uv1 = Vector2.Zero();
    const uv2 = Vector2.Zero();
    const uvec0 = Vector2.Zero();
    const uvec1 = Vector2.Zero();
    let col0X = 0;
    let col0Y = 0;
    let col0Z = 0;
    let col0A = 0;
    let col1X = 0;
    let col1Y = 0;
    let col1Z = 0;
    let col1A = 0;
    let col2X = 0;
    let col2Y = 0;
    let col2Z = 0;
    let col2A = 0;
    const col0 = Vector4.Zero();
    const col1 = Vector4.Zero();
    const col2 = Vector4.Zero();
    const colvec0 = Vector4.Zero();
    const colvec1 = Vector4.Zero();
    let lamda = 0;
    let mu = 0;
    range = range ? range : 0;
    let facetPoint;
    let uvPoint;
    let colPoint = new Vector4(0, 0, 0, 0);
    let norm = Vector3.Zero();
    let tang = Vector3.Zero();
    let biNorm = Vector3.Zero();
    let angle = 0;
    let facetPlaneVec = Vector3.Zero();
    let gap = 0;
    let distance = 0;
    const ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));
    let pickInfo;
    let direction = Vector3.Zero();
    for (let index = 0; index < meshInd.length / 3; index++) {
      id0 = meshInd[3 * index];
      id1 = meshInd[3 * index + 1];
      id2 = meshInd[3 * index + 2];
      v0X = meshPos[3 * id0];
      v0Y = meshPos[3 * id0 + 1];
      v0Z = meshPos[3 * id0 + 2];
      v1X = meshPos[3 * id1];
      v1Y = meshPos[3 * id1 + 1];
      v1Z = meshPos[3 * id1 + 2];
      v2X = meshPos[3 * id2];
      v2Y = meshPos[3 * id2 + 1];
      v2Z = meshPos[3 * id2 + 2];
      vertex0.set(v0X, v0Y, v0Z);
      vertex1.set(v1X, v1Y, v1Z);
      vertex2.set(v2X, v2Y, v2Z);
      vertex1.subtractToRef(vertex0, vec0);
      vertex2.subtractToRef(vertex1, vec1);
      if (meshUV) {
        uv0X = meshUV[2 * id0];
        uv0Y = meshUV[2 * id0 + 1];
        uv1X = meshUV[2 * id1];
        uv1Y = meshUV[2 * id1 + 1];
        uv2X = meshUV[2 * id2];
        uv2Y = meshUV[2 * id2 + 1];
        uv0.set(uv0X, uv0Y);
        uv1.set(uv1X, uv1Y);
        uv2.set(uv2X, uv2Y);
        uv1.subtractToRef(uv0, uvec0);
        uv2.subtractToRef(uv1, uvec1);
      }
      if (meshCol && colorFromTexture) {
        col0X = meshCol[4 * id0];
        col0Y = meshCol[4 * id0 + 1];
        col0Z = meshCol[4 * id0 + 2];
        col0A = meshCol[4 * id0 + 3];
        col1X = meshCol[4 * id1];
        col1Y = meshCol[4 * id1 + 1];
        col1Z = meshCol[4 * id1 + 2];
        col1A = meshCol[4 * id1 + 3];
        col2X = meshCol[4 * id2];
        col2Y = meshCol[4 * id2 + 1];
        col2Z = meshCol[4 * id2 + 2];
        col2A = meshCol[4 * id2 + 3];
        col0.set(col0X, col0Y, col0Z, col0A);
        col1.set(col1X, col1Y, col1Z, col1A);
        col2.set(col2X, col2Y, col2Z, col2A);
        col1.subtractToRef(col0, colvec0);
        col2.subtractToRef(col1, colvec1);
      }
      let width;
      let height;
      let deltaS;
      let deltaV;
      let h;
      let s;
      let v;
      let hsvCol;
      const statedColor = new Color3(0, 0, 0);
      const colPoint3 = new Color3(0, 0, 0);
      let pointColors;
      let particle;
      for (let i = 0; i < pointsGroup._groupDensity[index]; i++) {
        idxPoints = this.particles.length;
        this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);
        particle = this.particles[idxPoints];
        lamda = Scalar.RandomRange(0, 1);
        mu = Scalar.RandomRange(0, 1);
        facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));
        if (isVolume) {
          norm = mesh.getFacetNormal(index).normalize().scale(-1);
          tang = vec0.clone().normalize();
          biNorm = Vector3.Cross(norm, tang);
          angle = Scalar.RandomRange(0, 2 * Math.PI);
          facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));
          angle = Scalar.RandomRange(0.1, Math.PI / 2);
          direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));
          ray.origin = facetPoint.add(direction.scale(1e-5));
          ray.direction = direction;
          ray.length = diameter;
          pickInfo = ray.intersectsMesh(mesh);
          if (pickInfo.hit) {
            distance = pickInfo.pickedPoint.subtract(facetPoint).length();
            gap = Scalar.RandomRange(0, 1) * distance;
            facetPoint.addInPlace(direction.scale(gap));
          }
        }
        particle.position = facetPoint.clone();
        this._positions.push(particle.position.x, particle.position.y, particle.position.z);
        if (colorFromTexture !== void 0) {
          if (meshUV) {
            uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));
            if (colorFromTexture) {
              if (hasTexture && pointsGroup._groupImageData !== null) {
                width = pointsGroup._groupImgWidth;
                height = pointsGroup._groupImgHeight;
                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);
                particle.color = pointColors;
                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);
              } else {
                if (meshCol) {
                  colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));
                  particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);
                  this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);
                } else {
                  colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);
                  particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);
                  this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);
                }
              }
            } else {
              particle.uv = uvPoint.clone();
              this._uvs.push(particle.uv.x, particle.uv.y);
            }
          }
        } else {
          if (color) {
            statedColor.set(color.r, color.g, color.b);
            deltaS = Scalar.RandomRange(-range, range);
            deltaV = Scalar.RandomRange(-range, range);
            hsvCol = statedColor.toHSV();
            h = hsvCol.r;
            s = hsvCol.g + deltaS;
            v = hsvCol.b + deltaV;
            if (s < 0) {
              s = 0;
            }
            if (s > 1) {
              s = 1;
            }
            if (v < 0) {
              v = 0;
            }
            if (v > 1) {
              v = 1;
            }
            Color3.HSVtoRGBToRef(h, s, v, colPoint3);
            colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);
          } else {
            colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);
          }
          particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);
          this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);
        }
      }
    }
  }
  _colorFromTexture(mesh, pointsGroup, isVolume) {
    if (mesh.material === null) {
      Logger.Warn(mesh.name + "has no material.");
      pointsGroup._groupImageData = null;
      this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);
      return;
    }
    const mat = mesh.material;
    const textureList = mat.getActiveTextures();
    if (textureList.length === 0) {
      Logger.Warn(mesh.name + "has no usable texture.");
      pointsGroup._groupImageData = null;
      this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);
      return;
    }
    const clone = mesh.clone();
    clone.setEnabled(false);
    this._promises.push(new Promise((resolve) => {
      BaseTexture.WhenAllReady(textureList, () => {
        let n = pointsGroup._textureNb;
        if (n < 0) {
          n = 0;
        }
        if (n > textureList.length - 1) {
          n = textureList.length - 1;
        }
        const finalize = () => {
          pointsGroup._groupImgWidth = textureList[n].getSize().width;
          pointsGroup._groupImgHeight = textureList[n].getSize().height;
          this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true);
          clone.dispose();
          resolve();
        };
        pointsGroup._groupImageData = null;
        const dataPromise = textureList[n].readPixels();
        if (!dataPromise) {
          finalize();
        } else {
          dataPromise.then((data) => {
            pointsGroup._groupImageData = data;
            finalize();
          });
        }
      });
    }));
  }
  _calculateDensity(nbPoints, positions, indices) {
    let density = new Array();
    let id0;
    let id1;
    let id2;
    let v0X;
    let v0Y;
    let v0Z;
    let v1X;
    let v1Y;
    let v1Z;
    let v2X;
    let v2Y;
    let v2Z;
    const vertex0 = Vector3.Zero();
    const vertex1 = Vector3.Zero();
    const vertex2 = Vector3.Zero();
    const vec0 = Vector3.Zero();
    const vec1 = Vector3.Zero();
    const vec2 = Vector3.Zero();
    let a;
    let b;
    let c;
    let p;
    let area;
    const areas = new Array();
    let surfaceArea = 0;
    const nbFacets = indices.length / 3;
    for (let index = 0; index < nbFacets; index++) {
      id0 = indices[3 * index];
      id1 = indices[3 * index + 1];
      id2 = indices[3 * index + 2];
      v0X = positions[3 * id0];
      v0Y = positions[3 * id0 + 1];
      v0Z = positions[3 * id0 + 2];
      v1X = positions[3 * id1];
      v1Y = positions[3 * id1 + 1];
      v1Z = positions[3 * id1 + 2];
      v2X = positions[3 * id2];
      v2Y = positions[3 * id2 + 1];
      v2Z = positions[3 * id2 + 2];
      vertex0.set(v0X, v0Y, v0Z);
      vertex1.set(v1X, v1Y, v1Z);
      vertex2.set(v2X, v2Y, v2Z);
      vertex1.subtractToRef(vertex0, vec0);
      vertex2.subtractToRef(vertex1, vec1);
      vertex2.subtractToRef(vertex0, vec2);
      a = vec0.length();
      b = vec1.length();
      c = vec2.length();
      p = (a + b + c) / 2;
      area = Math.sqrt(p * (p - a) * (p - b) * (p - c));
      surfaceArea += area;
      areas[index] = area;
    }
    let pointCount = 0;
    for (let index = 0; index < nbFacets; index++) {
      density[index] = Math.floor(nbPoints * areas[index] / surfaceArea);
      pointCount += density[index];
    }
    const diff = nbPoints - pointCount;
    const pointsPerFacet = Math.floor(diff / nbFacets);
    const extraPoints = diff % nbFacets;
    if (pointsPerFacet > 0) {
      density = density.map((x) => x + pointsPerFacet);
    }
    for (let index = 0; index < extraPoints; index++) {
      density[index] += 1;
    }
    return density;
  }
  addPoints(nb, pointFunction = this._randomUnitVector) {
    const pointsGroup = new PointsGroup(this._groupCounter, pointFunction);
    let cp;
    let idx = this.nbParticles;
    for (let i = 0; i < nb; i++) {
      cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);
      if (pointsGroup && pointsGroup._positionFunction) {
        pointsGroup._positionFunction(cp, idx, i);
      }
      this._positions.push(cp.position.x, cp.position.y, cp.position.z);
      if (cp.color) {
        this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);
      }
      if (cp.uv) {
        this._uvs.push(cp.uv.x, cp.uv.y);
      }
      idx++;
    }
    this.nbParticles += nb;
    this._groupCounter++;
    return this._groupCounter;
  }
  addSurfacePoints(mesh, nb, colorWith, color, range) {
    let colored = colorWith ? colorWith : PointColor.Random;
    if (isNaN(colored) || colored < 0 || colored > 3) {
      colored = PointColor.Random;
    }
    const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);
    const meshInd = mesh.getIndices();
    this._groups.push(this._groupCounter);
    const pointsGroup = new PointsGroup(this._groupCounter, null);
    pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);
    if (colored === PointColor.Color) {
      pointsGroup._textureNb = color ? color : 0;
    } else {
      color = color ? color : new Color4(1, 1, 1, 1);
    }
    switch (colored) {
      case PointColor.Color:
        this._colorFromTexture(mesh, pointsGroup, false);
        break;
      case PointColor.UV:
        this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);
        break;
      case PointColor.Random:
        this._setPointsColorOrUV(mesh, pointsGroup, false);
        break;
      case PointColor.Stated:
        this._setPointsColorOrUV(mesh, pointsGroup, false, void 0, void 0, color, range);
        break;
    }
    this.nbParticles += nb;
    this._groupCounter++;
    return this._groupCounter - 1;
  }
  addVolumePoints(mesh, nb, colorWith, color, range) {
    let colored = colorWith ? colorWith : PointColor.Random;
    if (isNaN(colored) || colored < 0 || colored > 3) {
      colored = PointColor.Random;
    }
    const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);
    const meshInd = mesh.getIndices();
    this._groups.push(this._groupCounter);
    const pointsGroup = new PointsGroup(this._groupCounter, null);
    pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);
    if (colored === PointColor.Color) {
      pointsGroup._textureNb = color ? color : 0;
    } else {
      color = color ? color : new Color4(1, 1, 1, 1);
    }
    switch (colored) {
      case PointColor.Color:
        this._colorFromTexture(mesh, pointsGroup, true);
        break;
      case PointColor.UV:
        this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);
        break;
      case PointColor.Random:
        this._setPointsColorOrUV(mesh, pointsGroup, true);
        break;
      case PointColor.Stated:
        this._setPointsColorOrUV(mesh, pointsGroup, true, void 0, void 0, color, range);
        break;
    }
    this.nbParticles += nb;
    this._groupCounter++;
    return this._groupCounter - 1;
  }
  setParticles(start = 0, end = this.nbParticles - 1, update = true) {
    var _a, _b;
    if (!this._updatable || !this._isReady) {
      return this;
    }
    this.beforeUpdateParticles(start, end, update);
    const rotMatrix = TmpVectors.Matrix[0];
    const mesh = this.mesh;
    const colors32 = this._colors32;
    const positions32 = this._positions32;
    const uvs32 = this._uvs32;
    const tempVectors = TmpVectors.Vector3;
    const camAxisX = tempVectors[5].copyFromFloats(1, 0, 0);
    const camAxisY = tempVectors[6].copyFromFloats(0, 1, 0);
    const camAxisZ = tempVectors[7].copyFromFloats(0, 0, 1);
    const minimum = tempVectors[8].setAll(Number.MAX_VALUE);
    const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);
    Matrix.IdentityToRef(rotMatrix);
    let idx = 0;
    if ((_a = this.mesh) === null || _a === void 0 ? void 0 : _a.isFacetDataEnabled) {
      this._computeBoundingBox = true;
    }
    end = end >= this.nbParticles ? this.nbParticles - 1 : end;
    if (this._computeBoundingBox) {
      if (start != 0 || end != this.nbParticles - 1) {
        const boundingInfo = (_b = this.mesh) === null || _b === void 0 ? void 0 : _b.getBoundingInfo();
        if (boundingInfo) {
          minimum.copyFrom(boundingInfo.minimum);
          maximum.copyFrom(boundingInfo.maximum);
        }
      }
    }
    idx = 0;
    let pindex = 0;
    let cindex = 0;
    let uindex = 0;
    for (let p = start; p <= end; p++) {
      const particle = this.particles[p];
      idx = particle.idx;
      pindex = 3 * idx;
      cindex = 4 * idx;
      uindex = 2 * idx;
      this.updateParticle(particle);
      const particleRotationMatrix = particle._rotationMatrix;
      const particlePosition = particle.position;
      const particleGlobalPosition = particle._globalPosition;
      if (this._computeParticleRotation) {
        particle.getRotationMatrix(rotMatrix);
      }
      const particleHasParent = particle.parentId !== null;
      if (particleHasParent) {
        const parent = this.particles[particle.parentId];
        const parentRotationMatrix = parent._rotationMatrix;
        const parentGlobalPosition = parent._globalPosition;
        const rotatedY2 = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];
        const rotatedX2 = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];
        const rotatedZ2 = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];
        particleGlobalPosition.x = parentGlobalPosition.x + rotatedX2;
        particleGlobalPosition.y = parentGlobalPosition.y + rotatedY2;
        particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ2;
        if (this._computeParticleRotation) {
          const rotMatrixValues = rotMatrix.m;
          particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];
          particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];
          particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];
          particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];
          particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];
          particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];
          particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];
          particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];
          particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];
        }
      } else {
        particleGlobalPosition.x = 0;
        particleGlobalPosition.y = 0;
        particleGlobalPosition.z = 0;
        if (this._computeParticleRotation) {
          const rotMatrixValues = rotMatrix.m;
          particleRotationMatrix[0] = rotMatrixValues[0];
          particleRotationMatrix[1] = rotMatrixValues[1];
          particleRotationMatrix[2] = rotMatrixValues[2];
          particleRotationMatrix[3] = rotMatrixValues[4];
          particleRotationMatrix[4] = rotMatrixValues[5];
          particleRotationMatrix[5] = rotMatrixValues[6];
          particleRotationMatrix[6] = rotMatrixValues[8];
          particleRotationMatrix[7] = rotMatrixValues[9];
          particleRotationMatrix[8] = rotMatrixValues[10];
        }
      }
      const pivotBackTranslation = tempVectors[11];
      if (particle.translateFromPivot) {
        pivotBackTranslation.setAll(0);
      } else {
        pivotBackTranslation.copyFrom(particle.pivot);
      }
      const tmpVertex = tempVectors[0];
      tmpVertex.copyFrom(particle.position);
      const vertexX = tmpVertex.x - particle.pivot.x;
      const vertexY = tmpVertex.y - particle.pivot.y;
      const vertexZ = tmpVertex.z - particle.pivot.z;
      let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];
      let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];
      let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];
      rotatedX += pivotBackTranslation.x;
      rotatedY += pivotBackTranslation.y;
      rotatedZ += pivotBackTranslation.z;
      const px = positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;
      const py = positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;
      const pz = positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;
      if (this._computeBoundingBox) {
        minimum.minimizeInPlaceFromFloats(px, py, pz);
        maximum.maximizeInPlaceFromFloats(px, py, pz);
      }
      if (this._computeParticleColor && particle.color) {
        const color = particle.color;
        const colors322 = this._colors32;
        colors322[cindex] = color.r;
        colors322[cindex + 1] = color.g;
        colors322[cindex + 2] = color.b;
        colors322[cindex + 3] = color.a;
      }
      if (this._computeParticleTexture && particle.uv) {
        const uv = particle.uv;
        const uvs322 = this._uvs32;
        uvs322[uindex] = uv.x;
        uvs322[uindex + 1] = uv.y;
      }
    }
    if (mesh) {
      if (update) {
        if (this._computeParticleColor) {
          mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);
        }
        if (this._computeParticleTexture) {
          mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);
        }
        mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);
      }
      if (this._computeBoundingBox) {
        if (mesh.hasBoundingInfo) {
          mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);
        } else {
          mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);
        }
      }
    }
    this.afterUpdateParticles(start, end, update);
    return this;
  }
  dispose() {
    var _a;
    (_a = this.mesh) === null || _a === void 0 ? void 0 : _a.dispose();
    this.vars = null;
    this._positions = null;
    this._indices = null;
    this._normals = null;
    this._uvs = null;
    this._colors = null;
    this._indices32 = null;
    this._positions32 = null;
    this._uvs32 = null;
    this._colors32 = null;
  }
  refreshVisibleSize() {
    var _a;
    if (!this._isVisibilityBoxLocked) {
      (_a = this.mesh) === null || _a === void 0 ? void 0 : _a.refreshBoundingInfo();
    }
    return this;
  }
  setVisibilityBox(size) {
    if (!this.mesh) {
      return;
    }
    const vis = size / 2;
    this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));
  }
  get isAlwaysVisible() {
    return this._alwaysVisible;
  }
  set isAlwaysVisible(val) {
    if (!this.mesh) {
      return;
    }
    this._alwaysVisible = val;
    this.mesh.alwaysSelectAsActiveMesh = val;
  }
  set computeParticleRotation(val) {
    this._computeParticleRotation = val;
  }
  set computeParticleColor(val) {
    this._computeParticleColor = val;
  }
  set computeParticleTexture(val) {
    this._computeParticleTexture = val;
  }
  get computeParticleColor() {
    return this._computeParticleColor;
  }
  get computeParticleTexture() {
    return this._computeParticleTexture;
  }
  set computeBoundingBox(val) {
    this._computeBoundingBox = val;
  }
  get computeBoundingBox() {
    return this._computeBoundingBox;
  }
  initParticles() {
  }
  recycleParticle(particle) {
    return particle;
  }
  updateParticle(particle) {
    return particle;
  }
  beforeUpdateParticles(start, stop, update) {
  }
  afterUpdateParticles(start, stop, update) {
  }
};

// node_modules/@babylonjs/core/Physics/v1/physicsEngineComponent.js
Object.defineProperty(AbstractMesh.prototype, "physicsImpostor", {
  get: function() {
    return this._physicsImpostor;
  },
  set: function(value) {
    if (this._physicsImpostor === value) {
      return;
    }
    if (this._disposePhysicsObserver) {
      this.onDisposeObservable.remove(this._disposePhysicsObserver);
    }
    this._physicsImpostor = value;
    if (value) {
      this._disposePhysicsObserver = this.onDisposeObservable.add(() => {
        if (this.physicsImpostor) {
          this.physicsImpostor.dispose();
          this.physicsImpostor = null;
        }
      });
    }
  },
  enumerable: true,
  configurable: true
});
AbstractMesh.prototype.getPhysicsImpostor = function() {
  return this.physicsImpostor;
};
AbstractMesh.prototype.applyImpulse = function(force, contactPoint) {
  if (!this.physicsImpostor) {
    return this;
  }
  this.physicsImpostor.applyImpulse(force, contactPoint);
  return this;
};
AbstractMesh.prototype.setPhysicsLinkWith = function(otherMesh, pivot1, pivot2, options) {
  if (!this.physicsImpostor || !otherMesh.physicsImpostor) {
    return this;
  }
  this.physicsImpostor.createJoint(otherMesh.physicsImpostor, PhysicsJoint.HingeJoint, {
    mainPivot: pivot1,
    connectedPivot: pivot2,
    nativeParams: options
  });
  return this;
};

// node_modules/@babylonjs/core/Physics/v1/physicsHelper.js
var PhysicsHelper = class {
  constructor(scene) {
    this._scene = scene;
    this._physicsEngine = this._scene.getPhysicsEngine();
    if (!this._physicsEngine) {
      Logger.Warn("Physics engine not enabled. Please enable the physics before you can use the methods.");
      return;
    }
  }
  applyRadialExplosionImpulse(origin, radiusOrEventOptions, strength, falloff) {
    if (!this._physicsEngine) {
      Logger.Warn("Physics engine not enabled. Please enable the physics before you call this method.");
      return null;
    }
    const impostors = this._physicsEngine.getImpostors();
    if (impostors.length === 0) {
      return null;
    }
    if (typeof radiusOrEventOptions === "number") {
      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();
      radiusOrEventOptions.radius = radiusOrEventOptions;
      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;
      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;
    }
    const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);
    const affectedImpostorsWithData = Array();
    impostors.forEach((impostor) => {
      const impostorHitData = event.getImpostorHitData(impostor, origin);
      if (!impostorHitData) {
        return;
      }
      impostor.applyImpulse(impostorHitData.force, impostorHitData.contactPoint);
      affectedImpostorsWithData.push({
        impostor,
        hitData: impostorHitData
      });
    });
    event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);
    event.dispose(false);
    return event;
  }
  applyRadialExplosionForce(origin, radiusOrEventOptions, strength, falloff) {
    if (!this._physicsEngine) {
      Logger.Warn("Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.");
      return null;
    }
    const impostors = this._physicsEngine.getImpostors();
    if (impostors.length === 0) {
      return null;
    }
    if (typeof radiusOrEventOptions === "number") {
      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();
      radiusOrEventOptions.radius = radiusOrEventOptions;
      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;
      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;
    }
    const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);
    const affectedImpostorsWithData = Array();
    impostors.forEach((impostor) => {
      const impostorHitData = event.getImpostorHitData(impostor, origin);
      if (!impostorHitData) {
        return;
      }
      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);
      affectedImpostorsWithData.push({
        impostor,
        hitData: impostorHitData
      });
    });
    event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);
    event.dispose(false);
    return event;
  }
  gravitationalField(origin, radiusOrEventOptions, strength, falloff) {
    if (!this._physicsEngine) {
      Logger.Warn("Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.");
      return null;
    }
    const impostors = this._physicsEngine.getImpostors();
    if (impostors.length === 0) {
      return null;
    }
    if (typeof radiusOrEventOptions === "number") {
      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();
      radiusOrEventOptions.radius = radiusOrEventOptions;
      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;
      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;
    }
    const event = new PhysicsGravitationalFieldEvent(this, this._scene, origin, radiusOrEventOptions);
    event.dispose(false);
    return event;
  }
  updraft(origin, radiusOrEventOptions, strength, height, updraftMode) {
    if (!this._physicsEngine) {
      Logger.Warn("Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.");
      return null;
    }
    if (this._physicsEngine.getImpostors().length === 0) {
      return null;
    }
    if (typeof radiusOrEventOptions === "number") {
      radiusOrEventOptions = new PhysicsUpdraftEventOptions();
      radiusOrEventOptions.radius = radiusOrEventOptions;
      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;
      radiusOrEventOptions.height = height || radiusOrEventOptions.height;
      radiusOrEventOptions.updraftMode = updraftMode || radiusOrEventOptions.updraftMode;
    }
    const event = new PhysicsUpdraftEvent(this._scene, origin, radiusOrEventOptions);
    event.dispose(false);
    return event;
  }
  vortex(origin, radiusOrEventOptions, strength, height) {
    if (!this._physicsEngine) {
      Logger.Warn("Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.");
      return null;
    }
    if (this._physicsEngine.getImpostors().length === 0) {
      return null;
    }
    if (typeof radiusOrEventOptions === "number") {
      radiusOrEventOptions = new PhysicsVortexEventOptions();
      radiusOrEventOptions.radius = radiusOrEventOptions;
      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;
      radiusOrEventOptions.height = height || radiusOrEventOptions.height;
    }
    const event = new PhysicsVortexEvent(this._scene, origin, radiusOrEventOptions);
    event.dispose(false);
    return event;
  }
};
var PhysicsRadialExplosionEvent = class {
  constructor(_scene, _options) {
    this._scene = _scene;
    this._options = _options;
    this._dataFetched = false;
    this._options = { ...new PhysicsRadialExplosionEventOptions(), ...this._options };
  }
  getData() {
    this._dataFetched = true;
    return {
      sphere: this._sphere
    };
  }
  getImpostorHitData(impostor, origin) {
    if (impostor.mass === 0) {
      return null;
    }
    if (!this._intersectsWithSphere(impostor, origin, this._options.radius)) {
      return null;
    }
    if (impostor.object.getClassName() !== "Mesh" && impostor.object.getClassName() !== "InstancedMesh") {
      return null;
    }
    const impostorObjectCenter = impostor.getObjectCenter();
    const direction = impostorObjectCenter.subtract(origin);
    const ray = new Ray(origin, direction, this._options.radius);
    const hit = ray.intersectsMesh(impostor.object);
    const contactPoint = hit.pickedPoint;
    if (!contactPoint) {
      return null;
    }
    const distanceFromOrigin = Vector3.Distance(origin, contactPoint);
    if (distanceFromOrigin > this._options.radius) {
      return null;
    }
    const multiplier = this._options.falloff === PhysicsRadialImpulseFalloff.Constant ? this._options.strength : this._options.strength * (1 - distanceFromOrigin / this._options.radius);
    const force = direction.multiplyByFloats(multiplier, multiplier, multiplier);
    return { force, contactPoint, distanceFromOrigin };
  }
  triggerAffectedImpostorsCallback(affectedImpostorsWithData) {
    if (this._options.affectedImpostorsCallback) {
      this._options.affectedImpostorsCallback(affectedImpostorsWithData);
    }
  }
  dispose(force = true) {
    if (force) {
      this._sphere.dispose();
    } else {
      setTimeout(() => {
        if (!this._dataFetched) {
          this._sphere.dispose();
        }
      }, 0);
    }
  }
  _prepareSphere() {
    if (!this._sphere) {
      this._sphere = CreateSphere("radialExplosionEventSphere", this._options.sphere, this._scene);
      this._sphere.isVisible = false;
    }
  }
  _intersectsWithSphere(impostor, origin, radius) {
    const impostorObject = impostor.object;
    this._prepareSphere();
    this._sphere.position = origin;
    this._sphere.scaling = new Vector3(radius * 2, radius * 2, radius * 2);
    this._sphere._updateBoundingInfo();
    this._sphere.computeWorldMatrix(true);
    return this._sphere.intersectsMesh(impostorObject, true);
  }
};
var PhysicsGravitationalFieldEvent = class {
  constructor(_physicsHelper, _scene, _origin, _options) {
    this._physicsHelper = _physicsHelper;
    this._scene = _scene;
    this._origin = _origin;
    this._options = _options;
    this._dataFetched = false;
    this._options = { ...new PhysicsRadialExplosionEventOptions(), ...this._options };
    this._tickCallback = this._tick.bind(this);
    this._options.strength = this._options.strength * -1;
  }
  getData() {
    this._dataFetched = true;
    return {
      sphere: this._sphere
    };
  }
  enable() {
    this._tickCallback.call(this);
    this._scene.registerBeforeRender(this._tickCallback);
  }
  disable() {
    this._scene.unregisterBeforeRender(this._tickCallback);
  }
  dispose(force = true) {
    if (force) {
      this._sphere.dispose();
    } else {
      setTimeout(() => {
        if (!this._dataFetched) {
          this._sphere.dispose();
        }
      }, 0);
    }
  }
  _tick() {
    if (this._sphere) {
      this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);
    } else {
      const radialExplosionEvent = this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);
      if (radialExplosionEvent) {
        this._sphere = radialExplosionEvent.getData().sphere.clone("radialExplosionEventSphereClone");
      }
    }
  }
};
var PhysicsUpdraftEvent = class {
  constructor(_scene, _origin, _options) {
    this._scene = _scene;
    this._origin = _origin;
    this._options = _options;
    this._originTop = Vector3.Zero();
    this._originDirection = Vector3.Zero();
    this._cylinderPosition = Vector3.Zero();
    this._dataFetched = false;
    this._physicsEngine = this._scene.getPhysicsEngine();
    this._options = { ...new PhysicsUpdraftEventOptions(), ...this._options };
    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);
    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);
    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {
      this._originDirection = this._origin.subtract(this._originTop).normalize();
    }
    this._tickCallback = this._tick.bind(this);
    this._prepareCylinder();
  }
  getData() {
    this._dataFetched = true;
    return {
      cylinder: this._cylinder
    };
  }
  enable() {
    this._tickCallback.call(this);
    this._scene.registerBeforeRender(this._tickCallback);
  }
  disable() {
    this._scene.unregisterBeforeRender(this._tickCallback);
  }
  dispose(force = true) {
    if (!this._cylinder) {
      return;
    }
    if (force) {
      this._cylinder.dispose();
    } else {
      setTimeout(() => {
        if (!this._dataFetched) {
          this._cylinder.dispose();
        }
      }, 0);
    }
  }
  _getImpostorHitData(impostor) {
    if (impostor.mass === 0) {
      return null;
    }
    if (!this._intersectsWithCylinder(impostor)) {
      return null;
    }
    const impostorObjectCenter = impostor.getObjectCenter();
    let direction;
    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {
      direction = this._originDirection;
    } else {
      direction = impostorObjectCenter.subtract(this._originTop);
    }
    const distanceFromOrigin = Vector3.Distance(this._origin, impostorObjectCenter);
    const multiplier = this._options.strength * -1;
    const force = direction.multiplyByFloats(multiplier, multiplier, multiplier);
    return { force, contactPoint: impostorObjectCenter, distanceFromOrigin };
  }
  _tick() {
    this._physicsEngine.getImpostors().forEach((impostor) => {
      const impostorHitData = this._getImpostorHitData(impostor);
      if (!impostorHitData) {
        return;
      }
      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);
    });
  }
  _prepareCylinder() {
    if (!this._cylinder) {
      this._cylinder = CreateCylinder("updraftEventCylinder", {
        height: this._options.height,
        diameter: this._options.radius * 2
      }, this._scene);
      this._cylinder.isVisible = false;
    }
  }
  _intersectsWithCylinder(impostor) {
    const impostorObject = impostor.object;
    this._cylinder.position = this._cylinderPosition;
    return this._cylinder.intersectsMesh(impostorObject, true);
  }
};
var PhysicsVortexEvent = class {
  constructor(_scene, _origin, _options) {
    this._scene = _scene;
    this._origin = _origin;
    this._options = _options;
    this._originTop = Vector3.Zero();
    this._cylinderPosition = Vector3.Zero();
    this._dataFetched = false;
    this._physicsEngine = this._scene.getPhysicsEngine();
    this._options = { ...new PhysicsVortexEventOptions(), ...this._options };
    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);
    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);
    this._tickCallback = this._tick.bind(this);
    this._prepareCylinder();
  }
  getData() {
    this._dataFetched = true;
    return {
      cylinder: this._cylinder
    };
  }
  enable() {
    this._tickCallback.call(this);
    this._scene.registerBeforeRender(this._tickCallback);
  }
  disable() {
    this._scene.unregisterBeforeRender(this._tickCallback);
  }
  dispose(force = true) {
    if (force) {
      this._cylinder.dispose();
    } else {
      setTimeout(() => {
        if (!this._dataFetched) {
          this._cylinder.dispose();
        }
      }, 0);
    }
  }
  _getImpostorHitData(impostor) {
    if (impostor.mass === 0) {
      return null;
    }
    if (!this._intersectsWithCylinder(impostor)) {
      return null;
    }
    if (impostor.object.getClassName() !== "Mesh" && impostor.object.getClassName() !== "InstancedMesh") {
      return null;
    }
    const impostorObjectCenter = impostor.getObjectCenter();
    const originOnPlane = new Vector3(this._origin.x, impostorObjectCenter.y, this._origin.z);
    const originToImpostorDirection = impostorObjectCenter.subtract(originOnPlane);
    const ray = new Ray(originOnPlane, originToImpostorDirection, this._options.radius);
    const hit = ray.intersectsMesh(impostor.object);
    const contactPoint = hit.pickedPoint;
    if (!contactPoint) {
      return null;
    }
    const absoluteDistanceFromOrigin = hit.distance / this._options.radius;
    let directionToOrigin = contactPoint.normalize();
    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {
      directionToOrigin = directionToOrigin.negate();
    }
    let forceX;
    let forceY;
    let forceZ;
    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {
      forceX = directionToOrigin.x * this._options.centripetalForceMultiplier;
      forceY = directionToOrigin.y * this._options.updraftForceMultiplier;
      forceZ = directionToOrigin.z * this._options.centripetalForceMultiplier;
    } else {
      const perpendicularDirection = Vector3.Cross(originOnPlane, impostorObjectCenter).normalize();
      forceX = (perpendicularDirection.x + directionToOrigin.x) * this._options.centrifugalForceMultiplier;
      forceY = this._originTop.y * this._options.updraftForceMultiplier;
      forceZ = (perpendicularDirection.z + directionToOrigin.z) * this._options.centrifugalForceMultiplier;
    }
    let force = new Vector3(forceX, forceY, forceZ);
    force = force.multiplyByFloats(this._options.strength, this._options.strength, this._options.strength);
    return { force, contactPoint: impostorObjectCenter, distanceFromOrigin: absoluteDistanceFromOrigin };
  }
  _tick() {
    this._physicsEngine.getImpostors().forEach((impostor) => {
      const impostorHitData = this._getImpostorHitData(impostor);
      if (!impostorHitData) {
        return;
      }
      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);
    });
  }
  _prepareCylinder() {
    if (!this._cylinder) {
      this._cylinder = CreateCylinder("vortexEventCylinder", {
        height: this._options.height,
        diameter: this._options.radius * 2
      }, this._scene);
      this._cylinder.isVisible = false;
    }
  }
  _intersectsWithCylinder(impostor) {
    const impostorObject = impostor.object;
    this._cylinder.position = this._cylinderPosition;
    return this._cylinder.intersectsMesh(impostorObject, true);
  }
};
var PhysicsRadialExplosionEventOptions = class {
  constructor() {
    this.radius = 5;
    this.strength = 10;
    this.falloff = PhysicsRadialImpulseFalloff.Constant;
    this.sphere = { segments: 32, diameter: 1 };
  }
};
var PhysicsUpdraftEventOptions = class {
  constructor() {
    this.radius = 5;
    this.strength = 10;
    this.height = 10;
    this.updraftMode = PhysicsUpdraftMode.Center;
  }
};
var PhysicsVortexEventOptions = class {
  constructor() {
    this.radius = 5;
    this.strength = 10;
    this.height = 10;
    this.centripetalForceThreshold = 0.7;
    this.centripetalForceMultiplier = 5;
    this.centrifugalForceMultiplier = 0.5;
    this.updraftForceMultiplier = 0.02;
  }
};
var PhysicsRadialImpulseFalloff;
(function(PhysicsRadialImpulseFalloff2) {
  PhysicsRadialImpulseFalloff2[PhysicsRadialImpulseFalloff2["Constant"] = 0] = "Constant";
  PhysicsRadialImpulseFalloff2[PhysicsRadialImpulseFalloff2["Linear"] = 1] = "Linear";
})(PhysicsRadialImpulseFalloff || (PhysicsRadialImpulseFalloff = {}));
var PhysicsUpdraftMode;
(function(PhysicsUpdraftMode2) {
  PhysicsUpdraftMode2[PhysicsUpdraftMode2["Center"] = 0] = "Center";
  PhysicsUpdraftMode2[PhysicsUpdraftMode2["Perpendicular"] = 1] = "Perpendicular";
})(PhysicsUpdraftMode || (PhysicsUpdraftMode = {}));

// node_modules/@babylonjs/core/Physics/v2/physicsEngine.js
var PhysicsEngine2 = class {
  constructor(gravity, _physicsPlugin = PhysicsEngine2.DefaultPluginFactory()) {
    this._physicsPlugin = _physicsPlugin;
    this._physicsBodies = [];
    this._subTimeStep = 0;
    gravity = gravity || new Vector3(0, -9.807, 0);
    this.setGravity(gravity);
    this.setTimeStep();
  }
  getPluginVersion() {
    return this._physicsPlugin.getPluginVersion();
  }
  static DefaultPluginFactory() {
    throw _WarnImport("");
  }
  setGravity(gravity) {
    this.gravity = gravity;
    this._physicsPlugin.setGravity(this.gravity);
  }
  setTimeStep(newTimeStep = 1 / 60) {
    this._physicsPlugin.setTimeStep(newTimeStep);
  }
  getTimeStep() {
    return this._physicsPlugin.getTimeStep();
  }
  setSubTimeStep(subTimeStep = 0) {
    this._subTimeStep = subTimeStep;
  }
  getSubTimeStep() {
    return this._subTimeStep;
  }
  dispose() {
    this._physicsPlugin.dispose();
  }
  getPhysicsPluginName() {
    return this._physicsPlugin.name;
  }
  _step(delta) {
    if (delta > 0.1) {
      delta = 0.1;
    } else if (delta <= 0) {
      delta = 1 / 60;
    }
    this._physicsPlugin.executeStep(delta, this._physicsBodies);
  }
  addBody(physicsBody) {
    this._physicsBodies.push(physicsBody);
  }
  removeBody(physicsBody) {
    const index = this._physicsBodies.indexOf(physicsBody);
    if (index > -1) {
      this._physicsBodies.splice(index, 1);
    }
  }
  getPhysicsPlugin() {
    return this._physicsPlugin;
  }
  raycastToRef(from, to, result) {
    this._physicsPlugin.raycast(from, to, result);
  }
  raycast(from, to) {
    const result = new PhysicsRaycastResult();
    this._physicsPlugin.raycast(from, to, result);
    return result;
  }
};

// node_modules/@babylonjs/core/Physics/v2/physicsBody.js
var PhysicsBody = class {
  constructor(node, scene) {
    this._pluginData = void 0;
    this._pluginDataInstances = [];
    if (!scene) {
      return;
    }
    const physicsEngine = scene.getPhysicsEngine();
    if (!physicsEngine) {
      throw new Error("No Physics Engine available.");
    }
    if (physicsEngine.getPluginVersion() != 2) {
      throw new Error("Plugin version is incorrect. Expected version 2.");
    }
    const physicsPlugin = physicsEngine.getPhysicsPlugin();
    if (!physicsPlugin) {
      throw new Error("No Physics Plugin available.");
    }
    this._physicsPlugin = physicsPlugin;
    if (!node.rotationQuaternion) {
      node.rotationQuaternion = Quaternion.FromEulerAngles(node.rotation.x, node.rotation.y, node.rotation.z);
    }
    const m = node;
    if (m.hasThinInstances) {
      this._physicsPlugin.initBodyInstances(this, m);
    } else {
      this._physicsPlugin.initBody(this, node.position, node.rotationQuaternion);
    }
    this.node = node;
    physicsEngine.addBody(this);
  }
  setShape(shape) {
    this._physicsPlugin.setShape(this, shape);
  }
  getShape() {
    return this._physicsPlugin.getShape(this);
  }
  setFilterGroup(group) {
    this._physicsPlugin.setFilterGroup(this, group);
  }
  getFilterGroup() {
    return this._physicsPlugin.getFilterGroup(this);
  }
  setEventMask(eventMask) {
    this._physicsPlugin.setEventMask(this, eventMask);
  }
  getEventMask() {
    return this._physicsPlugin.getEventMask(this);
  }
  setMassProperties(massProps) {
    this._physicsPlugin.setMassProperties(this, massProps);
  }
  getMassProperties() {
    return this._physicsPlugin.getMassProperties(this);
  }
  setLinearDamping(damping) {
    this._physicsPlugin.setLinearDamping(this, damping);
  }
  getLinearDamping() {
    return this._physicsPlugin.getLinearDamping(this);
  }
  setAngularDamping(damping) {
    this._physicsPlugin.setAngularDamping(this, damping);
  }
  getAngularDamping() {
    return this._physicsPlugin.getAngularDamping(this);
  }
  setLinearVelocity(linVel) {
    this._physicsPlugin.setLinearVelocity(this, linVel);
  }
  getLinearVelocityToRef(linVel) {
    return this._physicsPlugin.getLinearVelocityToRef(this, linVel);
  }
  setAngularVelocity(angVel) {
    this._physicsPlugin.setAngularVelocity(this, angVel);
  }
  getAngularVelocityToRef(angVel) {
    return this._physicsPlugin.getAngularVelocityToRef(this, angVel);
  }
  applyImpulse(location, impulse) {
    this._physicsPlugin.applyImpulse(this, location, impulse);
  }
  getGeometry() {
    return this._physicsPlugin.getBodyGeometry(this);
  }
  dispose() {
    this._physicsPlugin.disposeBody(this);
  }
};

// node_modules/@babylonjs/core/Physics/v2/IPhysicsEnginePlugin.js
var ConstraintAxisLimitMode;
(function(ConstraintAxisLimitMode2) {
  ConstraintAxisLimitMode2[ConstraintAxisLimitMode2["FREE"] = 0] = "FREE";
  ConstraintAxisLimitMode2[ConstraintAxisLimitMode2["LIMITED"] = 1] = "LIMITED";
  ConstraintAxisLimitMode2[ConstraintAxisLimitMode2["LOCKED"] = 2] = "LOCKED";
  ConstraintAxisLimitMode2[ConstraintAxisLimitMode2["NONE"] = 3] = "NONE";
})(ConstraintAxisLimitMode || (ConstraintAxisLimitMode = {}));
var ConstraintAxis;
(function(ConstraintAxis2) {
  ConstraintAxis2[ConstraintAxis2["LINEAR_X"] = 0] = "LINEAR_X";
  ConstraintAxis2[ConstraintAxis2["LINEAR_Y"] = 1] = "LINEAR_Y";
  ConstraintAxis2[ConstraintAxis2["LINEAR_Z"] = 2] = "LINEAR_Z";
  ConstraintAxis2[ConstraintAxis2["ANGULAR_X"] = 3] = "ANGULAR_X";
  ConstraintAxis2[ConstraintAxis2["ANGULAR_Y"] = 4] = "ANGULAR_Y";
  ConstraintAxis2[ConstraintAxis2["ANGULAR_Z"] = 5] = "ANGULAR_Z";
  ConstraintAxis2[ConstraintAxis2["LINEAR_DISTANCE"] = 6] = "LINEAR_DISTANCE";
})(ConstraintAxis || (ConstraintAxis = {}));
var ConstraintType;
(function(ConstraintType2) {
  ConstraintType2[ConstraintType2["BALL_AND_SOCKET"] = 0] = "BALL_AND_SOCKET";
  ConstraintType2[ConstraintType2["DISTANCE"] = 1] = "DISTANCE";
  ConstraintType2[ConstraintType2["HINGE"] = 2] = "HINGE";
  ConstraintType2[ConstraintType2["SLIDER"] = 3] = "SLIDER";
  ConstraintType2[ConstraintType2["LOCK"] = 4] = "LOCK";
})(ConstraintType || (ConstraintType = {}));
var ShapeType;
(function(ShapeType2) {
  ShapeType2[ShapeType2["SPHERE"] = 0] = "SPHERE";
  ShapeType2[ShapeType2["CAPSULE"] = 1] = "CAPSULE";
  ShapeType2[ShapeType2["CYLINDER"] = 2] = "CYLINDER";
  ShapeType2[ShapeType2["BOX"] = 3] = "BOX";
  ShapeType2[ShapeType2["CONVEX_HULL"] = 4] = "CONVEX_HULL";
  ShapeType2[ShapeType2["CONTAINER"] = 5] = "CONTAINER";
  ShapeType2[ShapeType2["MESH"] = 6] = "MESH";
  ShapeType2[ShapeType2["HEIGHTFIELD"] = 7] = "HEIGHTFIELD";
})(ShapeType || (ShapeType = {}));
var ConstraintMotorType;
(function(ConstraintMotorType2) {
  ConstraintMotorType2[ConstraintMotorType2["NONE"] = 0] = "NONE";
  ConstraintMotorType2[ConstraintMotorType2["VELOCITY"] = 1] = "VELOCITY";
  ConstraintMotorType2[ConstraintMotorType2["POSITION"] = 2] = "POSITION";
})(ConstraintMotorType || (ConstraintMotorType = {}));

// node_modules/@babylonjs/core/Physics/v2/physicsShape.js
var PhysicsShape = class {
  constructor(type, options = {}, scene) {
    this._pluginData = void 0;
    this._type = type;
    if (!scene) {
      return;
    }
    const physicsEngine = scene.getPhysicsEngine();
    if (!physicsEngine) {
      throw new Error("No Physics Engine available.");
    }
    if (physicsEngine.getPluginVersion() != 2) {
      throw new Error("Plugin version is incorrect. Expected version 2.");
    }
    const physicsPlugin = physicsEngine.getPhysicsPlugin();
    if (!physicsPlugin) {
      throw new Error("No Physics Plugin available.");
    }
    this._physicsPlugin = physicsPlugin;
    this._physicsPlugin.initShape(this, type, options);
  }
  get type() {
    return this._type;
  }
  setFilterLayer(layer) {
    this._physicsPlugin.setFilterLayer(this, layer);
  }
  getFilterLayer() {
    return this._physicsPlugin.getFilterLayer(this);
  }
  setMaterial(material) {
    this._physicsPlugin.setMaterial(this, material);
  }
  getMaterial() {
    return this._physicsPlugin.getMaterial(this);
  }
  setDensity(density) {
    this._physicsPlugin.setDensity(this, density);
  }
  getDensity() {
    return this._physicsPlugin.getDensity(this);
  }
  addChild(newChild, childTransform) {
    this._physicsPlugin.addChild(this, newChild, childTransform);
  }
  removeChild(childIndex) {
    this._physicsPlugin.removeChild(this, childIndex);
  }
  getNumChildren() {
    return this._physicsPlugin.getNumChildren(this);
  }
  getBoundingBox() {
    return this._physicsPlugin.getBoundingBox(this);
  }
  dispose() {
    this._physicsPlugin.disposeShape(this);
  }
};
var PhysicsShapeSphere = class extends PhysicsShape {
  constructor(center, radius, scene) {
    super(ShapeType.SPHERE, { center, radius }, scene);
  }
};
var PhysicsShapeCapsule = class extends PhysicsShape {
  constructor(pointA, pointB, radius, scene) {
    super(ShapeType.CAPSULE, { pointA, pointB, radius }, scene);
  }
};
var PhysicsShapeCylinder = class extends PhysicsShape {
  constructor(pointA, pointB, radius, scene) {
    super(ShapeType.CYLINDER, { pointA, pointB, radius }, scene);
  }
};
var PhysicsShapeShapeBox = class extends PhysicsShape {
  constructor(center, rotation, extents, scene) {
    super(ShapeType.BOX, { center, rotation, extents }, scene);
  }
};
var PhysicsShapeShapeConvexHull = class extends PhysicsShape {
  constructor(mesh, scene) {
    super(ShapeType.CONVEX_HULL, { mesh }, scene);
  }
};
var PhysicsShapeShapeMesh = class extends PhysicsShape {
  constructor(mesh, scene) {
    super(ShapeType.MESH, { mesh }, scene);
  }
};
var PhysicsShapeShapeContainer = class extends PhysicsShape {
  constructor(mesh, scene) {
    super(ShapeType.CONTAINER, {}, scene);
  }
};

// node_modules/@babylonjs/core/Physics/v2/physicsConstraint.js
var PhysicsConstraint = class {
  constructor(type, options, scene) {
    this._pluginData = void 0;
    if (!scene) {
      return;
    }
    const physicsEngine = scene.getPhysicsEngine();
    if (!physicsEngine) {
      throw new Error("No Physics Engine available.");
    }
    if (physicsEngine.getPluginVersion() != 2) {
      throw new Error("Plugin version is incorrect. Expected version 2.");
    }
    const physicsPlugin = physicsEngine.getPhysicsPlugin();
    if (!physicsPlugin) {
      throw new Error("No Physics Plugin available.");
    }
    this._physicsPlugin = physicsPlugin;
    this._physicsPlugin.initConstraint(this, type, options);
  }
  setParentBody(body) {
    this._physicsPlugin.setParentBody(this, body);
  }
  getParentBody() {
    return this._physicsPlugin.getParentBody(this);
  }
  setChildBody(body) {
    this._physicsPlugin.setChildBody(this, body);
  }
  getChildBody() {
    return this._physicsPlugin.getChildBody(this);
  }
  setAnchorInParent(pivot, axisX, axisY) {
    this._physicsPlugin.setAnchorInParent(this, pivot, axisX, axisY);
  }
  setAnchorInChild(pivot, axisX, axisY) {
    this._physicsPlugin.setAnchorInChild(this, pivot, axisX, axisY);
  }
  setEnabled(isEnabled) {
    this._physicsPlugin.setEnabled(this, isEnabled);
  }
  getEnabled() {
    return this._physicsPlugin.getEnabled(this);
  }
  setCollisionsEnabled(isEnabled) {
    this._physicsPlugin.setCollisionsEnabled(this, isEnabled);
  }
  getCollisionsEnabled() {
    return this._physicsPlugin.getCollisionsEnabled(this);
  }
  setAxisFriction(axis, friction) {
    this._physicsPlugin.setAxisFriction(this, axis, friction);
  }
  getAxisFriction(axis) {
    return this._physicsPlugin.getAxisFriction(this, axis);
  }
  setAxisMode(axis, limitMode) {
    this._physicsPlugin.setAxisMode(this, axis, limitMode);
  }
  getAxisMode(axis) {
    return this._physicsPlugin.getAxisMode(this, axis);
  }
  setAxisMinLimit(axis, minLimit) {
    this._physicsPlugin.setAxisMinLimit(this, axis, minLimit);
  }
  getAxisMinLimit(axis) {
    return this._physicsPlugin.getAxisMinLimit(this, axis);
  }
  setAxisMaxLimit(axis, limit) {
    this._physicsPlugin.setAxisMaxLimit(this, axis, limit);
  }
  getAxisMaxLimit(axis) {
    return this._physicsPlugin.getAxisMaxLimit(this, axis);
  }
  setAxisMotorType(axis, motorType) {
    this._physicsPlugin.setAxisMotorType(this, axis, motorType);
  }
  getAxisMotorType(axis) {
    return this._physicsPlugin.getAxisMotorType(this, axis);
  }
  setAxisMotorTarget(axis, target) {
    this._physicsPlugin.setAxisMotorTarget(this, axis, target);
  }
  getAxisMotorTarget(axis) {
    return this._physicsPlugin.getAxisMotorTarget(this, axis);
  }
  setAxisMotorMaxForce(axis, maxForce) {
    this._physicsPlugin.setAxisMotorMaxForce(this, axis, maxForce);
  }
  getAxisMotorMaxForce(axis) {
    return this._physicsPlugin.getAxisMotorMaxForce(this, axis);
  }
  dispose() {
    this._physicsPlugin.disposeConstraint(this);
  }
};
var PhysicsConstraintBallAndSocket = class extends PhysicsConstraint {
  constructor(pivotA, pivotB, axisA, axisB, scene) {
    super(ConstraintType.BALL_AND_SOCKET, { pivotA, pivotB, axisA, axisB }, scene);
  }
};
var PhysicsConstraintDistance = class extends PhysicsConstraint {
  constructor(pivotA, pivotB, axisA, axisB, scene) {
    super(ConstraintType.DISTANCE, { pivotA, pivotB, axisA, axisB }, scene);
  }
};
var PhysicsConstraintHinge = class extends PhysicsConstraint {
  constructor(pivotA, pivotB, axisA, axisB, scene) {
    super(ConstraintType.HINGE, { pivotA, pivotB, axisA, axisB }, scene);
  }
};
var PhysicsConstraintSlider = class extends PhysicsConstraint {
  constructor(pivotA, pivotB, axisA, axisB, scene) {
    super(ConstraintType.SLIDER, { pivotA, pivotB, axisA, axisB }, scene);
  }
};
var PhysicsConstraintLock = class extends PhysicsConstraint {
  constructor(pivotA, pivotB, axisA, axisB, scene) {
    super(ConstraintType.LOCK, { pivotA, pivotB, axisA, axisB }, scene);
  }
};

// node_modules/@babylonjs/core/Physics/v2/physicsMaterial.js
var PhysicsMaterial = class {
  constructor(friction, restitution, scene) {
    this._pluginData = void 0;
    const physicsEngine = scene.getPhysicsEngine();
    if (!physicsEngine) {
      throw new Error("No Physics Engine available.");
    }
    if (physicsEngine.getPluginVersion() != 2) {
      throw new Error("Plugin version is incorrect. Expected version 2.");
    }
    const physicsPlugin = physicsEngine.getPhysicsPlugin();
    if (!physicsPlugin) {
      throw new Error("No Physics Plugin available.");
    }
    this._physicsPlugin = physicsPlugin;
    this._physicsPlugin.initMaterial(this);
  }
  setFriction(friction) {
    this._physicsPlugin.setFriction(this, friction);
  }
  getFriction() {
    return this._physicsPlugin.getFriction(this);
  }
  setRestitution(restitution) {
    this._physicsPlugin.setRestitution(this, restitution);
  }
  getRestitution() {
    return this._physicsPlugin.getRestitution(this);
  }
  dispose() {
    this._physicsPlugin.disposeMaterial(this);
  }
};

// node_modules/@babylonjs/core/Physics/v2/physicsAggregate.js
var PhysicsAggregate = class {
  constructor(transformNode, type, _options = { mass: 0 }, _scene) {
    this.transformNode = transformNode;
    this.type = type;
    this._options = _options;
    this._scene = _scene;
    if (!this.transformNode) {
      Logger.Error("No object was provided. A physics object is obligatory");
      return;
    }
    if (this.transformNode.parent && this._options.mass !== 0) {
      Logger.Warn("A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur.");
    }
    if (!this._scene && transformNode.getScene) {
      this._scene = transformNode.getScene();
    }
    if (!this._scene) {
      return;
    }
    this.material = new PhysicsMaterial(this._options.friction ? this._options.friction : 0, this._options.restitution ? this._options.restitution : 0, this._scene);
  }
  dispose() {
    this.body.dispose();
    this.material.dispose();
    this.shape.dispose();
  }
};

// node_modules/@babylonjs/core/Physics/physicsEngineComponent.js
Scene.prototype.getPhysicsEngine = function() {
  return this._physicsEngine;
};
Scene.prototype.enablePhysics = function(gravity = null, plugin) {
  if (this._physicsEngine) {
    return true;
  }
  let component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE);
  if (!component) {
    component = new PhysicsEngineSceneComponent(this);
    this._addComponent(component);
  }
  try {
    if (!plugin || (plugin === null || plugin === void 0 ? void 0 : plugin.getPluginVersion()) === 1) {
      this._physicsEngine = new PhysicsEngine(gravity, plugin);
    } else if ((plugin === null || plugin === void 0 ? void 0 : plugin.getPluginVersion()) === 2) {
      this._physicsEngine = new PhysicsEngine2(gravity, plugin);
    } else {
      throw new Error("Unsupported Physics plugin version.");
    }
    this._physicsTimeAccumulator = 0;
    return true;
  } catch (e) {
    Logger.Error(e.message);
    return false;
  }
};
Scene.prototype.disablePhysicsEngine = function() {
  if (!this._physicsEngine) {
    return;
  }
  this._physicsEngine.dispose();
  this._physicsEngine = null;
};
Scene.prototype.isPhysicsEnabled = function() {
  return this._physicsEngine !== void 0;
};
Scene.prototype.deleteCompoundImpostor = function(compound) {
  const mesh = compound.parts[0].mesh;
  if (mesh.physicsImpostor) {
    mesh.physicsImpostor.dispose();
    mesh.physicsImpostor = null;
  }
};
Scene.prototype._advancePhysicsEngineStep = function(step) {
  if (this._physicsEngine) {
    const subTime = this._physicsEngine.getSubTimeStep();
    if (subTime > 0) {
      this._physicsTimeAccumulator += step;
      while (this._physicsTimeAccumulator > subTime) {
        this.onBeforePhysicsObservable.notifyObservers(this);
        this._physicsEngine._step(subTime / 1e3);
        this.onAfterPhysicsObservable.notifyObservers(this);
        this._physicsTimeAccumulator -= subTime;
      }
    } else {
      this.onBeforePhysicsObservable.notifyObservers(this);
      this._physicsEngine._step(step / 1e3);
      this.onAfterPhysicsObservable.notifyObservers(this);
    }
  }
};
var PhysicsEngineSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_PHYSICSENGINE;
    this.scene = scene;
    this.scene.onBeforePhysicsObservable = new Observable();
    this.scene.onAfterPhysicsObservable = new Observable();
    this.scene.getDeterministicFrameTime = () => {
      if (this.scene._physicsEngine) {
        return this.scene._physicsEngine.getTimeStep() * 1e3;
      }
      return 1e3 / 60;
    };
  }
  register() {
  }
  rebuild() {
  }
  dispose() {
    this.scene.onBeforePhysicsObservable.clear();
    this.scene.onAfterPhysicsObservable.clear();
    if (this.scene._physicsEngine) {
      this.scene.disablePhysicsEngine();
    }
  }
};

// node_modules/@babylonjs/core/Shaders/blackAndWhite.fragment.js
var name74 = "blackAndWhitePixelShader";
var shader74 = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform float degree;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{
vec3 color=texture2D(textureSampler,vUV).rgb;
float luminance=dot(color,vec3(0.3,0.59,0.11)); 
vec3 blackAndWhite=vec3(luminance,luminance,luminance);
gl_FragColor=vec4(color-((color-blackAndWhite)*degree),1.0);
}`;
ShaderStore.ShadersStore[name74] = shader74;

// node_modules/@babylonjs/core/PostProcesses/blackAndWhitePostProcess.js
var BlackAndWhitePostProcess = class extends PostProcess {
  constructor(name137, options, camera, samplingMode, engine, reusable) {
    super(name137, "blackAndWhite", ["degree"], null, options, camera, samplingMode, engine, reusable);
    this.degree = 1;
    this.onApplyObservable.add((effect) => {
      effect.setFloat("degree", this.degree);
    });
  }
  getClassName() {
    return "BlackAndWhitePostProcess";
  }
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new BlackAndWhitePostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  }
};
__decorate([
  serialize()
], BlackAndWhitePostProcess.prototype, "degree", void 0);
RegisterClass("BABYLON.BlackAndWhitePostProcess", BlackAndWhitePostProcess);

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderEffect.js
var PostProcessRenderEffect = class {
  constructor(engine, name137, getPostProcesses, singleInstance) {
    this._name = name137;
    this._singleInstance = singleInstance || true;
    this._getPostProcesses = getPostProcesses;
    this._cameras = {};
    this._indicesForCamera = {};
    this._postProcesses = {};
  }
  get isSupported() {
    for (const index in this._postProcesses) {
      if (Object.prototype.hasOwnProperty.call(this._postProcesses, index)) {
        const pps = this._postProcesses[index];
        for (let ppIndex = 0; ppIndex < pps.length; ppIndex++) {
          if (!pps[ppIndex].isSupported) {
            return false;
          }
        }
      }
    }
    return true;
  }
  _update() {
  }
  _attachCameras(cameras) {
    let cameraKey;
    const cams = Tools.MakeArray(cameras || this._cameras);
    if (!cams) {
      return;
    }
    for (let i = 0; i < cams.length; i++) {
      const camera = cams[i];
      if (!camera) {
        continue;
      }
      const cameraName = camera.name;
      if (this._singleInstance) {
        cameraKey = 0;
      } else {
        cameraKey = cameraName;
      }
      if (!this._postProcesses[cameraKey]) {
        const postProcess = this._getPostProcesses();
        if (postProcess) {
          this._postProcesses[cameraKey] = Array.isArray(postProcess) ? postProcess : [postProcess];
        }
      }
      if (!this._indicesForCamera[cameraName]) {
        this._indicesForCamera[cameraName] = [];
      }
      this._postProcesses[cameraKey].forEach((postProcess) => {
        const index = camera.attachPostProcess(postProcess);
        this._indicesForCamera[cameraName].push(index);
      });
      if (!this._cameras[cameraName]) {
        this._cameras[cameraName] = camera;
      }
    }
  }
  _detachCameras(cameras) {
    const cams = Tools.MakeArray(cameras || this._cameras);
    if (!cams) {
      return;
    }
    for (let i = 0; i < cams.length; i++) {
      const camera = cams[i];
      const cameraName = camera.name;
      const postProcesses = this._postProcesses[this._singleInstance ? 0 : cameraName];
      if (postProcesses) {
        postProcesses.forEach((postProcess) => {
          camera.detachPostProcess(postProcess);
        });
      }
      if (this._cameras[cameraName]) {
        this._cameras[cameraName] = null;
      }
    }
  }
  _enable(cameras) {
    const cams = Tools.MakeArray(cameras || this._cameras);
    if (!cams) {
      return;
    }
    for (let i = 0; i < cams.length; i++) {
      const camera = cams[i];
      const cameraName = camera.name;
      for (let j = 0; j < this._indicesForCamera[cameraName].length; j++) {
        if (camera._postProcesses[this._indicesForCamera[cameraName][j]] === void 0 || camera._postProcesses[this._indicesForCamera[cameraName][j]] === null) {
          this._postProcesses[this._singleInstance ? 0 : cameraName].forEach((postProcess) => {
            cams[i].attachPostProcess(postProcess, this._indicesForCamera[cameraName][j]);
          });
        }
      }
    }
  }
  _disable(cameras) {
    const cams = Tools.MakeArray(cameras || this._cameras);
    if (!cams) {
      return;
    }
    for (let i = 0; i < cams.length; i++) {
      const camera = cams[i];
      const cameraName = camera.name;
      this._postProcesses[this._singleInstance ? 0 : cameraName].forEach((postProcess) => {
        camera.detachPostProcess(postProcess);
      });
    }
  }
  getPostProcesses(camera) {
    if (this._singleInstance) {
      return this._postProcesses[0];
    } else {
      if (!camera) {
        return null;
      }
      return this._postProcesses[camera.name];
    }
  }
};

// node_modules/@babylonjs/core/Shaders/extractHighlights.fragment.js
var name75 = "extractHighlightsPixelShader";
var shader75 = `#include<helperFunctions>
varying vec2 vUV;
uniform sampler2D textureSampler;
uniform float threshold;
uniform float exposure;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{
gl_FragColor=texture2D(textureSampler,vUV);
float luma=dot(LuminanceEncodeApprox,gl_FragColor.rgb*exposure);
gl_FragColor.rgb=step(threshold,luma)*gl_FragColor.rgb;
}`;
ShaderStore.ShadersStore[name75] = shader75;

// node_modules/@babylonjs/core/PostProcesses/extractHighlightsPostProcess.js
var ExtractHighlightsPostProcess = class extends PostProcess {
  constructor(name137, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
    super(name137, "extractHighlights", ["threshold", "exposure"], null, options, camera, samplingMode, engine, reusable, null, textureType, void 0, null, blockCompilation);
    this.threshold = 0.9;
    this._exposure = 1;
    this._inputPostProcess = null;
    this.onApplyObservable.add((effect) => {
      this.externalTextureSamplerBinding = !!this._inputPostProcess;
      if (this._inputPostProcess) {
        effect.setTextureFromPostProcess("textureSampler", this._inputPostProcess);
      }
      effect.setFloat("threshold", Math.pow(this.threshold, ToGammaSpace));
      effect.setFloat("exposure", this._exposure);
    });
  }
  getClassName() {
    return "ExtractHighlightsPostProcess";
  }
};
__decorate([
  serialize()
], ExtractHighlightsPostProcess.prototype, "threshold", void 0);
RegisterClass("BABYLON.ExtractHighlightsPostProcess", ExtractHighlightsPostProcess);

// node_modules/@babylonjs/core/Shaders/bloomMerge.fragment.js
var name76 = "bloomMergePixelShader";
var shader76 = `uniform sampler2D textureSampler;
uniform sampler2D bloomBlur;
varying vec2 vUV;
uniform float bloomWeight;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
gl_FragColor=texture2D(textureSampler,vUV);
vec3 blurred=texture2D(bloomBlur,vUV).rgb;
gl_FragColor.rgb=gl_FragColor.rgb+(blurred.rgb*bloomWeight); 
}
`;
ShaderStore.ShadersStore[name76] = shader76;

// node_modules/@babylonjs/core/PostProcesses/bloomMergePostProcess.js
var BloomMergePostProcess = class extends PostProcess {
  constructor(name137, originalFromInput, blurred, weight, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
    super(name137, "bloomMerge", ["bloomWeight"], ["bloomBlur"], options, camera, samplingMode, engine, reusable, null, textureType, void 0, null, true);
    this.weight = 1;
    this.weight = weight;
    this.externalTextureSamplerBinding = true;
    this.onApplyObservable.add((effect) => {
      effect.setTextureFromPostProcess("textureSampler", originalFromInput);
      effect.setTextureFromPostProcessOutput("bloomBlur", blurred);
      effect.setFloat("bloomWeight", this.weight);
    });
    if (!blockCompilation) {
      this.updateEffect();
    }
  }
  getClassName() {
    return "BloomMergePostProcess";
  }
};
__decorate([
  serialize()
], BloomMergePostProcess.prototype, "weight", void 0);
RegisterClass("BABYLON.BloomMergePostProcess", BloomMergePostProcess);

// node_modules/@babylonjs/core/PostProcesses/bloomEffect.js
var BloomEffect = class extends PostProcessRenderEffect {
  constructor(scene, _bloomScale, bloomWeight, bloomKernel, pipelineTextureType = 0, blockCompilation = false) {
    super(scene.getEngine(), "bloom", () => {
      return this._effects;
    }, true);
    this._bloomScale = _bloomScale;
    this._effects = [];
    this._downscale = new ExtractHighlightsPostProcess("highlights", 1, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);
    this._blurX = new BlurPostProcess("horizontal blur", new Vector2(1, 0), 10, _bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, void 0, blockCompilation);
    this._blurX.alwaysForcePOT = true;
    this._blurX.autoClear = false;
    this._blurY = new BlurPostProcess("vertical blur", new Vector2(0, 1), 10, _bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, void 0, blockCompilation);
    this._blurY.alwaysForcePOT = true;
    this._blurY.autoClear = false;
    this.kernel = bloomKernel;
    this._effects = [this._downscale, this._blurX, this._blurY];
    this._merge = new BloomMergePostProcess("bloomMerge", this._downscale, this._blurY, bloomWeight, _bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);
    this._merge.autoClear = false;
    this._effects.push(this._merge);
  }
  get threshold() {
    return this._downscale.threshold;
  }
  set threshold(value) {
    this._downscale.threshold = value;
  }
  get weight() {
    return this._merge.weight;
  }
  set weight(value) {
    this._merge.weight = value;
  }
  get kernel() {
    return this._blurX.kernel / this._bloomScale;
  }
  set kernel(value) {
    this._blurX.kernel = value * this._bloomScale;
    this._blurY.kernel = value * this._bloomScale;
  }
  disposeEffects(camera) {
    for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
      this._effects[effectIndex].dispose(camera);
    }
  }
  _updateEffects() {
    for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
      this._effects[effectIndex].updateEffect();
    }
  }
  _isReady() {
    for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
      if (!this._effects[effectIndex].isReady()) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/@babylonjs/core/Shaders/chromaticAberration.fragment.js
var name77 = "chromaticAberrationPixelShader";
var shader77 = `uniform sampler2D textureSampler; 
uniform float chromatic_aberration;
uniform float radialIntensity;
uniform vec2 direction;
uniform vec2 centerPosition;
uniform float screen_width;
uniform float screen_height;
varying vec2 vUV;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
vec2 centered_screen_pos=vec2(vUV.x-centerPosition.x,vUV.y-centerPosition.y);
vec2 directionOfEffect=direction;
if(directionOfEffect.x==0. && directionOfEffect.y==0.){
directionOfEffect=normalize(centered_screen_pos);
}
float radius2=centered_screen_pos.x*centered_screen_pos.x
+ centered_screen_pos.y*centered_screen_pos.y;
float radius=sqrt(radius2);
vec4 original=texture2D(textureSampler,vUV);
vec3 ref_indices=vec3(-0.3,0.0,0.3);
float ref_shiftX=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.x/screen_width;
float ref_shiftY=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.y/screen_height;
vec2 ref_coords_r=vec2(vUV.x+ref_indices.r*ref_shiftX,vUV.y+ref_indices.r*ref_shiftY*0.5);
vec2 ref_coords_g=vec2(vUV.x+ref_indices.g*ref_shiftX,vUV.y+ref_indices.g*ref_shiftY*0.5);
vec2 ref_coords_b=vec2(vUV.x+ref_indices.b*ref_shiftX,vUV.y+ref_indices.b*ref_shiftY*0.5);
original.r=texture2D(textureSampler,ref_coords_r).r;
original.g=texture2D(textureSampler,ref_coords_g).g;
original.b=texture2D(textureSampler,ref_coords_b).b;
original.a=clamp(texture2D(textureSampler,ref_coords_r).a+texture2D(textureSampler,ref_coords_g).a+texture2D(textureSampler,ref_coords_b).a,0.,1.);
gl_FragColor=original;
}`;
ShaderStore.ShadersStore[name77] = shader77;

// node_modules/@babylonjs/core/PostProcesses/chromaticAberrationPostProcess.js
var ChromaticAberrationPostProcess = class extends PostProcess {
  constructor(name137, screenWidth, screenHeight, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
    super(name137, "chromaticAberration", ["chromatic_aberration", "screen_width", "screen_height", "direction", "radialIntensity", "centerPosition"], [], options, camera, samplingMode, engine, reusable, null, textureType, void 0, null, blockCompilation);
    this.aberrationAmount = 30;
    this.radialIntensity = 0;
    this.direction = new Vector2(0.707, 0.707);
    this.centerPosition = new Vector2(0.5, 0.5);
    this.screenWidth = screenWidth;
    this.screenHeight = screenHeight;
    this.onApplyObservable.add((effect) => {
      effect.setFloat("chromatic_aberration", this.aberrationAmount);
      effect.setFloat("screen_width", screenWidth);
      effect.setFloat("screen_height", screenHeight);
      effect.setFloat("radialIntensity", this.radialIntensity);
      effect.setFloat2("direction", this.direction.x, this.direction.y);
      effect.setFloat2("centerPosition", this.centerPosition.x, this.centerPosition.y);
    });
  }
  getClassName() {
    return "ChromaticAberrationPostProcess";
  }
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new ChromaticAberrationPostProcess(parsedPostProcess.name, parsedPostProcess.screenWidth, parsedPostProcess.screenHeight, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, false);
    }, parsedPostProcess, scene, rootUrl);
  }
};
__decorate([
  serialize()
], ChromaticAberrationPostProcess.prototype, "aberrationAmount", void 0);
__decorate([
  serialize()
], ChromaticAberrationPostProcess.prototype, "radialIntensity", void 0);
__decorate([
  serialize()
], ChromaticAberrationPostProcess.prototype, "direction", void 0);
__decorate([
  serialize()
], ChromaticAberrationPostProcess.prototype, "centerPosition", void 0);
__decorate([
  serialize()
], ChromaticAberrationPostProcess.prototype, "screenWidth", void 0);
__decorate([
  serialize()
], ChromaticAberrationPostProcess.prototype, "screenHeight", void 0);
RegisterClass("BABYLON.ChromaticAberrationPostProcess", ChromaticAberrationPostProcess);

// node_modules/@babylonjs/core/Shaders/circleOfConfusion.fragment.js
var name78 = "circleOfConfusionPixelShader";
var shader78 = `uniform sampler2D depthSampler;
varying vec2 vUV;
uniform vec2 cameraMinMaxZ;
uniform float focusDistance;
uniform float cocPrecalculation;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
float depth=texture2D(depthSampler,vUV).r;
#define CUSTOM_COC_DEPTH
float pixelDistance=(cameraMinMaxZ.x+cameraMinMaxZ.y*depth)*1000.0; 
#define CUSTOM_COC_PIXELDISTANCE
float coc=abs(cocPrecalculation*((focusDistance-pixelDistance)/pixelDistance));
coc=clamp(coc,0.0,1.0);
gl_FragColor=vec4(coc,coc,coc,1.0);
}
`;
ShaderStore.ShadersStore[name78] = shader78;

// node_modules/@babylonjs/core/PostProcesses/circleOfConfusionPostProcess.js
var CircleOfConfusionPostProcess = class extends PostProcess {
  constructor(name137, depthTexture, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
    super(name137, "circleOfConfusion", ["cameraMinMaxZ", "focusDistance", "cocPrecalculation"], ["depthSampler"], options, camera, samplingMode, engine, reusable, null, textureType, void 0, null, blockCompilation);
    this.lensSize = 50;
    this.fStop = 1.4;
    this.focusDistance = 2e3;
    this.focalLength = 50;
    this._depthTexture = null;
    this._depthTexture = depthTexture;
    this.onApplyObservable.add((effect) => {
      if (!this._depthTexture) {
        Logger.Warn("No depth texture set on CircleOfConfusionPostProcess");
        return;
      }
      effect.setTexture("depthSampler", this._depthTexture);
      const aperture = this.lensSize / this.fStop;
      const cocPrecalculation = aperture * this.focalLength / (this.focusDistance - this.focalLength);
      effect.setFloat("focusDistance", this.focusDistance);
      effect.setFloat("cocPrecalculation", cocPrecalculation);
      const activeCamera = this._depthTexture.activeCamera;
      effect.setFloat2("cameraMinMaxZ", activeCamera.minZ, activeCamera.maxZ - activeCamera.minZ);
    });
  }
  getClassName() {
    return "CircleOfConfusionPostProcess";
  }
  set depthTexture(value) {
    this._depthTexture = value;
  }
};
__decorate([
  serialize()
], CircleOfConfusionPostProcess.prototype, "lensSize", void 0);
__decorate([
  serialize()
], CircleOfConfusionPostProcess.prototype, "fStop", void 0);
__decorate([
  serialize()
], CircleOfConfusionPostProcess.prototype, "focusDistance", void 0);
__decorate([
  serialize()
], CircleOfConfusionPostProcess.prototype, "focalLength", void 0);
RegisterClass("BABYLON.CircleOfConfusionPostProcess", CircleOfConfusionPostProcess);

// node_modules/@babylonjs/core/Shaders/colorCorrection.fragment.js
var name79 = "colorCorrectionPixelShader";
var shader79 = `uniform sampler2D textureSampler; 
uniform sampler2D colorTable; 
varying vec2 vUV;
const float SLICE_COUNT=16.0; 
vec4 sampleAs3DTexture(sampler2D textureSampler,vec3 uv,float width) {
float sliceSize=1.0/width; 
float slicePixelSize=sliceSize/width; 
float sliceInnerSize=slicePixelSize*(width-1.0); 
float zSlice0=min(floor(uv.z*width),width-1.0);
float zSlice1=min(zSlice0+1.0,width-1.0);
float xOffset=slicePixelSize*0.5+uv.x*sliceInnerSize;
float s0=xOffset+(zSlice0*sliceSize);
float s1=xOffset+(zSlice1*sliceSize);
vec4 slice0Color=texture2D(textureSampler,vec2(s0,uv.y));
vec4 slice1Color=texture2D(textureSampler,vec2(s1,uv.y));
float zOffset=mod(uv.z*width,1.0);
vec4 result=mix(slice0Color,slice1Color,zOffset);
return result;
}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
vec4 screen_color=texture2D(textureSampler,vUV);
gl_FragColor=sampleAs3DTexture(colorTable,screen_color.rgb,SLICE_COUNT);
}`;
ShaderStore.ShadersStore[name79] = shader79;

// node_modules/@babylonjs/core/PostProcesses/colorCorrectionPostProcess.js
var ColorCorrectionPostProcess = class extends PostProcess {
  constructor(name137, colorTableUrl, options, camera, samplingMode, engine, reusable) {
    super(name137, "colorCorrection", null, ["colorTable"], options, camera, samplingMode, engine, reusable);
    const scene = (camera === null || camera === void 0 ? void 0 : camera.getScene()) || null;
    this._colorTableTexture = new Texture(colorTableUrl, scene, true, false, Texture.TRILINEAR_SAMPLINGMODE);
    this._colorTableTexture.anisotropicFilteringLevel = 1;
    this._colorTableTexture.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._colorTableTexture.wrapV = Texture.CLAMP_ADDRESSMODE;
    this.colorTableUrl = colorTableUrl;
    this.onApply = (effect) => {
      effect.setTexture("colorTable", this._colorTableTexture);
    };
  }
  getClassName() {
    return "ColorCorrectionPostProcess";
  }
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new ColorCorrectionPostProcess(parsedPostProcess.name, parsedPostProcess.colorTableUrl, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  }
};
__decorate([
  serialize()
], ColorCorrectionPostProcess.prototype, "colorTableUrl", void 0);
RegisterClass("BABYLON.ColorCorrectionPostProcess", ColorCorrectionPostProcess);

// node_modules/@babylonjs/core/Shaders/convolution.fragment.js
var name80 = "convolutionPixelShader";
var shader80 = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform vec2 screenSize;
uniform float kernel[9];
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
vec2 onePixel=vec2(1.0,1.0)/screenSize;
vec4 colorSum =
texture2D(textureSampler,vUV+onePixel*vec2(-1,-1))*kernel[0] +
texture2D(textureSampler,vUV+onePixel*vec2(0,-1))*kernel[1] +
texture2D(textureSampler,vUV+onePixel*vec2(1,-1))*kernel[2] +
texture2D(textureSampler,vUV+onePixel*vec2(-1,0))*kernel[3] +
texture2D(textureSampler,vUV+onePixel*vec2(0,0))*kernel[4] +
texture2D(textureSampler,vUV+onePixel*vec2(1,0))*kernel[5] +
texture2D(textureSampler,vUV+onePixel*vec2(-1,1))*kernel[6] +
texture2D(textureSampler,vUV+onePixel*vec2(0,1))*kernel[7] +
texture2D(textureSampler,vUV+onePixel*vec2(1,1))*kernel[8];
float kernelWeight =
kernel[0] +
kernel[1] +
kernel[2] +
kernel[3] +
kernel[4] +
kernel[5] +
kernel[6] +
kernel[7] +
kernel[8];
if (kernelWeight<=0.0) {
kernelWeight=1.0;
}
gl_FragColor=vec4((colorSum/kernelWeight).rgb,1);
}`;
ShaderStore.ShadersStore[name80] = shader80;

// node_modules/@babylonjs/core/PostProcesses/convolutionPostProcess.js
var ConvolutionPostProcess = class extends PostProcess {
  constructor(name137, kernel, options, camera, samplingMode, engine, reusable, textureType = 0) {
    super(name137, "convolution", ["kernel", "screenSize"], null, options, camera, samplingMode, engine, reusable, null, textureType);
    this.kernel = kernel;
    this.onApply = (effect) => {
      effect.setFloat2("screenSize", this.width, this.height);
      effect.setArray("kernel", this.kernel);
    };
  }
  getClassName() {
    return "ConvolutionPostProcess";
  }
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new ConvolutionPostProcess(parsedPostProcess.name, parsedPostProcess.kernel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType);
    }, parsedPostProcess, scene, rootUrl);
  }
};
ConvolutionPostProcess.EdgeDetect0Kernel = [1, 0, -1, 0, 0, 0, -1, 0, 1];
ConvolutionPostProcess.EdgeDetect1Kernel = [0, 1, 0, 1, -4, 1, 0, 1, 0];
ConvolutionPostProcess.EdgeDetect2Kernel = [-1, -1, -1, -1, 8, -1, -1, -1, -1];
ConvolutionPostProcess.SharpenKernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
ConvolutionPostProcess.EmbossKernel = [-2, -1, 0, -1, 1, 1, 0, 1, 2];
ConvolutionPostProcess.GaussianKernel = [0, 1, 0, 1, 1, 1, 0, 1, 0];
__decorate([
  serialize()
], ConvolutionPostProcess.prototype, "kernel", void 0);
RegisterClass("BABYLON.ConvolutionPostProcess", ConvolutionPostProcess);

// node_modules/@babylonjs/core/PostProcesses/depthOfFieldBlurPostProcess.js
var DepthOfFieldBlurPostProcess = class extends BlurPostProcess {
  constructor(name137, scene, direction, kernel, options, camera, circleOfConfusion, imageToBlur = null, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable, textureType = 0, blockCompilation = false, textureFormat = 5) {
    super(
      name137,
      direction,
      kernel,
      options,
      camera,
      samplingMode = 2,
      engine,
      reusable,
      textureType,
      `#define DOF 1\r
`,
      blockCompilation,
      textureFormat
    );
    this.direction = direction;
    this.externalTextureSamplerBinding = !!imageToBlur;
    this.onApplyObservable.add((effect) => {
      if (imageToBlur != null) {
        effect.setTextureFromPostProcess("textureSampler", imageToBlur);
      }
      effect.setTextureFromPostProcessOutput("circleOfConfusionSampler", circleOfConfusion);
    });
  }
  getClassName() {
    return "DepthOfFieldBlurPostProcess";
  }
};
__decorate([
  serialize()
], DepthOfFieldBlurPostProcess.prototype, "direction", void 0);
RegisterClass("BABYLON.DepthOfFieldBlurPostProcess", DepthOfFieldBlurPostProcess);

// node_modules/@babylonjs/core/Shaders/depthOfFieldMerge.fragment.js
var name81 = "depthOfFieldMergePixelShader";
var shader81 = `uniform sampler2D textureSampler;
varying vec2 vUV;
uniform sampler2D circleOfConfusionSampler;
uniform sampler2D blurStep0;
#if BLUR_LEVEL>0
uniform sampler2D blurStep1;
#endif
#if BLUR_LEVEL>1
uniform sampler2D blurStep2;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
float coc=texture2D(circleOfConfusionSampler,vUV).r;
#if BLUR_LEVEL==0
vec4 original=texture2D(textureSampler,vUV);
vec4 blurred0=texture2D(blurStep0,vUV);
gl_FragColor=mix(original,blurred0,coc);
#endif
#if BLUR_LEVEL==1
if(coc<0.5){
vec4 original=texture2D(textureSampler,vUV);
vec4 blurred1=texture2D(blurStep1,vUV);
gl_FragColor=mix(original,blurred1,coc/0.5);
}else{
vec4 blurred0=texture2D(blurStep0,vUV);
vec4 blurred1=texture2D(blurStep1,vUV);
gl_FragColor=mix(blurred1,blurred0,(coc-0.5)/0.5);
}
#endif
#if BLUR_LEVEL==2
if(coc<0.33){
vec4 original=texture2D(textureSampler,vUV);
vec4 blurred2=texture2D(blurStep2,vUV);
gl_FragColor=mix(original,blurred2,coc/0.33);
}else if(coc<0.66){
vec4 blurred1=texture2D(blurStep1,vUV);
vec4 blurred2=texture2D(blurStep2,vUV);
gl_FragColor=mix(blurred2,blurred1,(coc-0.33)/0.33);
}else{
vec4 blurred0=texture2D(blurStep0,vUV);
vec4 blurred1=texture2D(blurStep1,vUV);
gl_FragColor=mix(blurred1,blurred0,(coc-0.66)/0.34);
}
#endif
}
`;
ShaderStore.ShadersStore[name81] = shader81;

// node_modules/@babylonjs/core/PostProcesses/depthOfFieldMergePostProcess.js
var DepthOfFieldMergePostProcessOptions = class {
};
var DepthOfFieldMergePostProcess = class extends PostProcess {
  constructor(name137, originalFromInput, circleOfConfusion, _blurSteps, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
    super(name137, "depthOfFieldMerge", [], ["circleOfConfusionSampler", "blurStep0", "blurStep1", "blurStep2"], options, camera, samplingMode, engine, reusable, null, textureType, void 0, null, true);
    this._blurSteps = _blurSteps;
    this.externalTextureSamplerBinding = true;
    this.onApplyObservable.add((effect) => {
      effect.setTextureFromPostProcess("textureSampler", originalFromInput);
      effect.setTextureFromPostProcessOutput("circleOfConfusionSampler", circleOfConfusion);
      _blurSteps.forEach((step, index) => {
        effect.setTextureFromPostProcessOutput("blurStep" + (_blurSteps.length - index - 1), step);
      });
    });
    if (!blockCompilation) {
      this.updateEffect();
    }
  }
  getClassName() {
    return "DepthOfFieldMergePostProcess";
  }
  updateEffect(defines = null, uniforms = null, samplers = null, indexParameters, onCompiled, onError) {
    if (!defines) {
      defines = "";
      defines += "#define BLUR_LEVEL " + (this._blurSteps.length - 1) + "\n";
    }
    super.updateEffect(defines, uniforms, samplers, indexParameters, onCompiled, onError);
  }
};

// node_modules/@babylonjs/core/PostProcesses/depthOfFieldEffect.js
var DepthOfFieldEffectBlurLevel;
(function(DepthOfFieldEffectBlurLevel2) {
  DepthOfFieldEffectBlurLevel2[DepthOfFieldEffectBlurLevel2["Low"] = 0] = "Low";
  DepthOfFieldEffectBlurLevel2[DepthOfFieldEffectBlurLevel2["Medium"] = 1] = "Medium";
  DepthOfFieldEffectBlurLevel2[DepthOfFieldEffectBlurLevel2["High"] = 2] = "High";
})(DepthOfFieldEffectBlurLevel || (DepthOfFieldEffectBlurLevel = {}));
var DepthOfFieldEffect = class extends PostProcessRenderEffect {
  constructor(scene, depthTexture, blurLevel = DepthOfFieldEffectBlurLevel.Low, pipelineTextureType = 0, blockCompilation = false) {
    super(scene.getEngine(), "depth of field", () => {
      return this._effects;
    }, true);
    this._effects = [];
    const engine = scene.getEngine();
    const circleOfConfusionTextureFormat = engine.isWebGPU || engine.webGLVersion > 1 ? 6 : 5;
    this._circleOfConfusion = new CircleOfConfusionPostProcess("circleOfConfusion", depthTexture, 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, pipelineTextureType, blockCompilation);
    this._depthOfFieldBlurY = [];
    this._depthOfFieldBlurX = [];
    let blurCount = 1;
    let kernelSize = 15;
    switch (blurLevel) {
      case DepthOfFieldEffectBlurLevel.High: {
        blurCount = 3;
        kernelSize = 51;
        break;
      }
      case DepthOfFieldEffectBlurLevel.Medium: {
        blurCount = 2;
        kernelSize = 31;
        break;
      }
      default: {
        kernelSize = 15;
        blurCount = 1;
        break;
      }
    }
    const adjustedKernelSize = kernelSize / Math.pow(2, blurCount - 1);
    let ratio = 1;
    for (let i = 0; i < blurCount; i++) {
      const blurY = new DepthOfFieldBlurPostProcess("vertical blur", scene, new Vector2(0, 1), adjustedKernelSize, ratio, null, this._circleOfConfusion, i == 0 ? this._circleOfConfusion : null, Texture.BILINEAR_SAMPLINGMODE, engine, false, pipelineTextureType, blockCompilation, i == 0 ? circleOfConfusionTextureFormat : 5);
      blurY.autoClear = false;
      ratio = 0.75 / Math.pow(2, i);
      const blurX = new DepthOfFieldBlurPostProcess("horizontal blur", scene, new Vector2(1, 0), adjustedKernelSize, ratio, null, this._circleOfConfusion, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, pipelineTextureType, blockCompilation);
      blurX.autoClear = false;
      this._depthOfFieldBlurY.push(blurY);
      this._depthOfFieldBlurX.push(blurX);
    }
    this._effects = [this._circleOfConfusion];
    for (let i = 0; i < this._depthOfFieldBlurX.length; i++) {
      this._effects.push(this._depthOfFieldBlurY[i]);
      this._effects.push(this._depthOfFieldBlurX[i]);
    }
    this._dofMerge = new DepthOfFieldMergePostProcess("dofMerge", this._circleOfConfusion, this._circleOfConfusion, this._depthOfFieldBlurX, ratio, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, pipelineTextureType, blockCompilation);
    this._dofMerge.autoClear = false;
    this._effects.push(this._dofMerge);
  }
  set focalLength(value) {
    this._circleOfConfusion.focalLength = value;
  }
  get focalLength() {
    return this._circleOfConfusion.focalLength;
  }
  set fStop(value) {
    this._circleOfConfusion.fStop = value;
  }
  get fStop() {
    return this._circleOfConfusion.fStop;
  }
  set focusDistance(value) {
    this._circleOfConfusion.focusDistance = value;
  }
  get focusDistance() {
    return this._circleOfConfusion.focusDistance;
  }
  set lensSize(value) {
    this._circleOfConfusion.lensSize = value;
  }
  get lensSize() {
    return this._circleOfConfusion.lensSize;
  }
  getClassName() {
    return "DepthOfFieldEffect";
  }
  set depthTexture(value) {
    this._circleOfConfusion.depthTexture = value;
  }
  disposeEffects(camera) {
    for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
      this._effects[effectIndex].dispose(camera);
    }
  }
  _updateEffects() {
    for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
      this._effects[effectIndex].updateEffect();
    }
  }
  _isReady() {
    for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
      if (!this._effects[effectIndex].isReady()) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/@babylonjs/core/Shaders/displayPass.fragment.js
var name82 = "displayPassPixelShader";
var shader82 = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform sampler2D passSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
gl_FragColor=texture2D(passSampler,vUV);
}`;
ShaderStore.ShadersStore[name82] = shader82;

// node_modules/@babylonjs/core/PostProcesses/displayPassPostProcess.js
var DisplayPassPostProcess = class extends PostProcess {
  getClassName() {
    return "DisplayPassPostProcess";
  }
  constructor(name137, options, camera, samplingMode, engine, reusable) {
    super(name137, "displayPass", ["passSampler"], ["passSampler"], options, camera, samplingMode, engine, reusable);
  }
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new DisplayPassPostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  }
};
RegisterClass("BABYLON.DisplayPassPostProcess", DisplayPassPostProcess);

// node_modules/@babylonjs/core/Shaders/filter.fragment.js
var name83 = "filterPixelShader";
var shader83 = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform mat4 kernelMatrix;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
vec3 baseColor=texture2D(textureSampler,vUV).rgb;
vec3 updatedColor=(kernelMatrix*vec4(baseColor,1.0)).rgb;
gl_FragColor=vec4(updatedColor,1.0);
}`;
ShaderStore.ShadersStore[name83] = shader83;

// node_modules/@babylonjs/core/PostProcesses/filterPostProcess.js
var FilterPostProcess = class extends PostProcess {
  constructor(name137, kernelMatrix, options, camera, samplingMode, engine, reusable) {
    super(name137, "filter", ["kernelMatrix"], null, options, camera, samplingMode, engine, reusable);
    this.kernelMatrix = kernelMatrix;
    this.onApply = (effect) => {
      effect.setMatrix("kernelMatrix", this.kernelMatrix);
    };
  }
  getClassName() {
    return "FilterPostProcess";
  }
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new FilterPostProcess(parsedPostProcess.name, parsedPostProcess.kernelMatrix, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  }
};
__decorate([
  serializeAsMatrix()
], FilterPostProcess.prototype, "kernelMatrix", void 0);
RegisterClass("BABYLON.FilterPostProcess", FilterPostProcess);

// node_modules/@babylonjs/core/Shaders/fxaa.fragment.js
var name84 = "fxaaPixelShader";
var shader84 = `#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)
#else
#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)
#endif
uniform sampler2D textureSampler;
uniform vec2 texelSize;
varying vec2 vUV;
varying vec2 sampleCoordS;
varying vec2 sampleCoordE;
varying vec2 sampleCoordN;
varying vec2 sampleCoordW;
varying vec2 sampleCoordNW;
varying vec2 sampleCoordSE;
varying vec2 sampleCoordNE;
varying vec2 sampleCoordSW;
const float fxaaQualitySubpix=1.0;
const float fxaaQualityEdgeThreshold=0.166;
const float fxaaQualityEdgeThresholdMin=0.0833;
const vec3 kLumaCoefficients=vec3(0.2126,0.7152,0.0722);
#define FxaaLuma(rgba) dot(rgba.rgb,kLumaCoefficients)
void main(){
vec2 posM;
posM.x=vUV.x;
posM.y=vUV.y;
vec4 rgbyM=TEXTUREFUNC(textureSampler,vUV,0.0);
float lumaM=FxaaLuma(rgbyM);
float lumaS=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordS,0.0));
float lumaE=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordE,0.0));
float lumaN=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordN,0.0));
float lumaW=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordW,0.0));
float maxSM=max(lumaS,lumaM);
float minSM=min(lumaS,lumaM);
float maxESM=max(lumaE,maxSM);
float minESM=min(lumaE,minSM);
float maxWN=max(lumaN,lumaW);
float minWN=min(lumaN,lumaW);
float rangeMax=max(maxWN,maxESM);
float rangeMin=min(minWN,minESM);
float rangeMaxScaled=rangeMax*fxaaQualityEdgeThreshold;
float range=rangeMax-rangeMin;
float rangeMaxClamped=max(fxaaQualityEdgeThresholdMin,rangeMaxScaled);
#ifndef MALI
if(range<rangeMaxClamped) 
{
gl_FragColor=rgbyM;
return;
}
#endif
float lumaNW=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordNW,0.0));
float lumaSE=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordSE,0.0));
float lumaNE=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordNE,0.0));
float lumaSW=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordSW,0.0));
float lumaNS=lumaN+lumaS;
float lumaWE=lumaW+lumaE;
float subpixRcpRange=1.0/range;
float subpixNSWE=lumaNS+lumaWE;
float edgeHorz1=(-2.0*lumaM)+lumaNS;
float edgeVert1=(-2.0*lumaM)+lumaWE;
float lumaNESE=lumaNE+lumaSE;
float lumaNWNE=lumaNW+lumaNE;
float edgeHorz2=(-2.0*lumaE)+lumaNESE;
float edgeVert2=(-2.0*lumaN)+lumaNWNE;
float lumaNWSW=lumaNW+lumaSW;
float lumaSWSE=lumaSW+lumaSE;
float edgeHorz4=(abs(edgeHorz1)*2.0)+abs(edgeHorz2);
float edgeVert4=(abs(edgeVert1)*2.0)+abs(edgeVert2);
float edgeHorz3=(-2.0*lumaW)+lumaNWSW;
float edgeVert3=(-2.0*lumaS)+lumaSWSE;
float edgeHorz=abs(edgeHorz3)+edgeHorz4;
float edgeVert=abs(edgeVert3)+edgeVert4;
float subpixNWSWNESE=lumaNWSW+lumaNESE;
float lengthSign=texelSize.x;
bool horzSpan=edgeHorz>=edgeVert;
float subpixA=subpixNSWE*2.0+subpixNWSWNESE;
if (!horzSpan)
{
lumaN=lumaW;
}
if (!horzSpan) 
{
lumaS=lumaE;
}
if (horzSpan) 
{
lengthSign=texelSize.y;
}
float subpixB=(subpixA*(1.0/12.0))-lumaM;
float gradientN=lumaN-lumaM;
float gradientS=lumaS-lumaM;
float lumaNN=lumaN+lumaM;
float lumaSS=lumaS+lumaM;
bool pairN=abs(gradientN)>=abs(gradientS);
float gradient=max(abs(gradientN),abs(gradientS));
if (pairN)
{
lengthSign=-lengthSign;
}
float subpixC=clamp(abs(subpixB)*subpixRcpRange,0.0,1.0);
vec2 posB;
posB.x=posM.x;
posB.y=posM.y;
vec2 offNP;
offNP.x=(!horzSpan) ? 0.0 : texelSize.x;
offNP.y=(horzSpan) ? 0.0 : texelSize.y;
if (!horzSpan) 
{
posB.x+=lengthSign*0.5;
}
if (horzSpan)
{
posB.y+=lengthSign*0.5;
}
vec2 posN;
posN.x=posB.x-offNP.x*1.5;
posN.y=posB.y-offNP.y*1.5;
vec2 posP;
posP.x=posB.x+offNP.x*1.5;
posP.y=posB.y+offNP.y*1.5;
float subpixD=((-2.0)*subpixC)+3.0;
float lumaEndN=FxaaLuma(TEXTUREFUNC(textureSampler,posN,0.0));
float subpixE=subpixC*subpixC;
float lumaEndP=FxaaLuma(TEXTUREFUNC(textureSampler,posP,0.0));
if (!pairN) 
{
lumaNN=lumaSS;
}
float gradientScaled=gradient*1.0/4.0;
float lumaMM=lumaM-lumaNN*0.5;
float subpixF=subpixD*subpixE;
bool lumaMLTZero=lumaMM<0.0;
lumaEndN-=lumaNN*0.5;
lumaEndP-=lumaNN*0.5;
bool doneN=abs(lumaEndN)>=gradientScaled;
bool doneP=abs(lumaEndP)>=gradientScaled;
if (!doneN) 
{
posN.x-=offNP.x*3.0;
}
if (!doneN) 
{
posN.y-=offNP.y*3.0;
}
bool doneNP=(!doneN) || (!doneP);
if (!doneP) 
{
posP.x+=offNP.x*3.0;
}
if (!doneP)
{
posP.y+=offNP.y*3.0;
}
if (doneNP)
{
if (!doneN) lumaEndN=FxaaLuma(TEXTUREFUNC(textureSampler,posN.xy,0.0));
if (!doneP) lumaEndP=FxaaLuma(TEXTUREFUNC(textureSampler,posP.xy,0.0));
if (!doneN) lumaEndN=lumaEndN-lumaNN*0.5;
if (!doneP) lumaEndP=lumaEndP-lumaNN*0.5;
doneN=abs(lumaEndN)>=gradientScaled;
doneP=abs(lumaEndP)>=gradientScaled;
if (!doneN) posN.x-=offNP.x*12.0;
if (!doneN) posN.y-=offNP.y*12.0;
doneNP=(!doneN) || (!doneP);
if (!doneP) posP.x+=offNP.x*12.0;
if (!doneP) posP.y+=offNP.y*12.0;
}
float dstN=posM.x-posN.x;
float dstP=posP.x-posM.x;
if (!horzSpan)
{
dstN=posM.y-posN.y;
}
if (!horzSpan) 
{
dstP=posP.y-posM.y;
}
bool goodSpanN=(lumaEndN<0.0) != lumaMLTZero;
float spanLength=(dstP+dstN);
bool goodSpanP=(lumaEndP<0.0) != lumaMLTZero;
float spanLengthRcp=1.0/spanLength;
bool directionN=dstN<dstP;
float dst=min(dstN,dstP);
bool goodSpan=directionN ? goodSpanN : goodSpanP;
float subpixG=subpixF*subpixF;
float pixelOffset=(dst*(-spanLengthRcp))+0.5;
float subpixH=subpixG*fxaaQualitySubpix;
float pixelOffsetGood=goodSpan ? pixelOffset : 0.0;
float pixelOffsetSubpix=max(pixelOffsetGood,subpixH);
if (!horzSpan)
{
posM.x+=pixelOffsetSubpix*lengthSign;
}
if (horzSpan)
{
posM.y+=pixelOffsetSubpix*lengthSign;
}
#ifdef MALI
if(range<rangeMaxClamped) 
{
gl_FragColor=rgbyM;
}
else
{
gl_FragColor=TEXTUREFUNC(textureSampler,posM,0.0);
}
#else
gl_FragColor=TEXTUREFUNC(textureSampler,posM,0.0);
#endif
}`;
ShaderStore.ShadersStore[name84] = shader84;

// node_modules/@babylonjs/core/Shaders/fxaa.vertex.js
var name85 = "fxaaVertexShader";
var shader85 = `attribute vec2 position;
uniform vec2 texelSize;
varying vec2 vUV;
varying vec2 sampleCoordS;
varying vec2 sampleCoordE;
varying vec2 sampleCoordN;
varying vec2 sampleCoordW;
varying vec2 sampleCoordNW;
varying vec2 sampleCoordSE;
varying vec2 sampleCoordNE;
varying vec2 sampleCoordSW;
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=(position*madd+madd);
sampleCoordS=vUV+vec2( 0.0,1.0)*texelSize;
sampleCoordE=vUV+vec2( 1.0,0.0)*texelSize;
sampleCoordN=vUV+vec2( 0.0,-1.0)*texelSize;
sampleCoordW=vUV+vec2(-1.0,0.0)*texelSize;
sampleCoordNW=vUV+vec2(-1.0,-1.0)*texelSize;
sampleCoordSE=vUV+vec2( 1.0,1.0)*texelSize;
sampleCoordNE=vUV+vec2( 1.0,-1.0)*texelSize;
sampleCoordSW=vUV+vec2(-1.0,1.0)*texelSize;
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name85] = shader85;

// node_modules/@babylonjs/core/PostProcesses/fxaaPostProcess.js
var FxaaPostProcess = class extends PostProcess {
  getClassName() {
    return "FxaaPostProcess";
  }
  constructor(name137, options, camera = null, samplingMode, engine, reusable, textureType = 0) {
    super(name137, "fxaa", ["texelSize"], null, options, camera, samplingMode || Texture.BILINEAR_SAMPLINGMODE, engine, reusable, null, textureType, "fxaa", void 0, true);
    const defines = this._getDefines();
    this.updateEffect(defines);
    this.onApplyObservable.add((effect) => {
      const texelSize = this.texelSize;
      effect.setFloat2("texelSize", texelSize.x, texelSize.y);
    });
  }
  _getDefines() {
    const engine = this.getEngine();
    if (!engine) {
      return null;
    }
    const glInfo = engine.getGlInfo();
    if (glInfo && glInfo.renderer && glInfo.renderer.toLowerCase().indexOf("mali") > -1) {
      return "#define MALI 1\n";
    }
    return null;
  }
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new FxaaPostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  }
};
RegisterClass("BABYLON.FxaaPostProcess", FxaaPostProcess);

// node_modules/@babylonjs/core/Shaders/grain.fragment.js
var name86 = "grainPixelShader";
var shader86 = `#include<helperFunctions>
uniform sampler2D textureSampler; 
uniform float intensity;
uniform float animatedSeed;
varying vec2 vUV;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
gl_FragColor=texture2D(textureSampler,vUV);
vec2 seed=vUV*(animatedSeed);
float grain=dither(seed,intensity);
float lum=getLuminance(gl_FragColor.rgb);
float grainAmount=(cos(-PI+(lum*PI*2.))+1.)/2.;
gl_FragColor.rgb+=grain*grainAmount;
gl_FragColor.rgb=max(gl_FragColor.rgb,0.0);
}`;
ShaderStore.ShadersStore[name86] = shader86;

// node_modules/@babylonjs/core/PostProcesses/grainPostProcess.js
var GrainPostProcess = class extends PostProcess {
  constructor(name137, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
    super(name137, "grain", ["intensity", "animatedSeed"], [], options, camera, samplingMode, engine, reusable, null, textureType, void 0, null, blockCompilation);
    this.intensity = 30;
    this.animated = false;
    this.onApplyObservable.add((effect) => {
      effect.setFloat("intensity", this.intensity);
      effect.setFloat("animatedSeed", this.animated ? Math.random() + 1 : 1);
    });
  }
  getClassName() {
    return "GrainPostProcess";
  }
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new GrainPostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  }
};
__decorate([
  serialize()
], GrainPostProcess.prototype, "intensity", void 0);
__decorate([
  serialize()
], GrainPostProcess.prototype, "animated", void 0);
RegisterClass("BABYLON.GrainPostProcess", GrainPostProcess);

// node_modules/@babylonjs/core/Shaders/highlights.fragment.js
var name87 = "highlightsPixelShader";
var shader87 = `varying vec2 vUV;
uniform sampler2D textureSampler;
const vec3 RGBLuminanceCoefficients=vec3(0.2126,0.7152,0.0722);
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{
vec4 tex=texture2D(textureSampler,vUV);
vec3 c=tex.rgb;
float luma=dot(c.rgb,RGBLuminanceCoefficients);
gl_FragColor=vec4(pow(c,vec3(25.0-luma*15.0)),tex.a); 
}`;
ShaderStore.ShadersStore[name87] = shader87;

// node_modules/@babylonjs/core/PostProcesses/highlightsPostProcess.js
var HighlightsPostProcess = class extends PostProcess {
  getClassName() {
    return "HighlightsPostProcess";
  }
  constructor(name137, options, camera, samplingMode, engine, reusable, textureType = 0) {
    super(name137, "highlights", null, null, options, camera, samplingMode, engine, reusable, null, textureType);
  }
};

// node_modules/@babylonjs/core/Shaders/ShadersInclude/mrtFragmentDeclaration.js
var name88 = "mrtFragmentDeclaration";
var shader88 = `#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
layout(location=0) out vec4 glFragData[{X}];
#endif
`;
ShaderStore.IncludesShadersStore[name88] = shader88;

// node_modules/@babylonjs/core/Shaders/geometry.fragment.js
var name89 = "geometryPixelShader";
var shader89 = `#extension GL_EXT_draw_buffers : require
#if defined(BUMP) || !defined(NORMAL)
#extension GL_OES_standard_derivatives : enable
#endif
precision highp float;
#ifdef BUMP
varying mat4 vWorldView;
varying vec3 vNormalW;
#else
varying vec3 vNormalV;
#endif
varying vec4 vViewPos;
#if defined(POSITION) || defined(BUMP)
varying vec3 vPositionW;
#endif
#ifdef VELOCITY
varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;
#endif
#ifdef NEED_UV
varying vec2 vUV;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;
uniform vec2 vTangentSpaceParams;
#endif
#if defined(REFLECTIVITY)
#if defined(ORMTEXTURE) || defined(SPECULARGLOSSINESSTEXTURE) || defined(REFLECTIVITYTEXTURE)
uniform sampler2D reflectivitySampler;
varying vec2 vReflectivityUV;
#endif
#ifdef ALBEDOTEXTURE
varying vec2 vAlbedoUV;
uniform sampler2D albedoSampler;
#endif
#ifdef REFLECTIVITYCOLOR
uniform vec3 reflectivityColor;
#endif
#ifdef ALBEDOCOLOR
uniform vec3 albedoColor;
#endif
#ifdef METALLIC
uniform float metallic;
#endif
#ifdef ROUGHNESS
uniform float glossiness;
#endif
#endif
#ifdef ALPHATEST
uniform sampler2D diffuseSampler;
#endif
#include<mrtFragmentDeclaration>[RENDER_TARGET_COUNT]
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#include<helperFunctions>
void main() {
#ifdef ALPHATEST
if (texture2D(diffuseSampler,vUV).a<0.4)
discard;
#endif
vec3 normalOutput;
#ifdef BUMP
vec3 normalW=normalize(vNormalW);
#include<bumpFragment>
normalOutput=normalize(vec3(vWorldView*vec4(normalW,0.0)));
#else
normalOutput=normalize(vNormalV);
#endif
#ifdef PREPASS
#ifdef PREPASS_DEPTH
gl_FragData[DEPTH_INDEX]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);
#endif
#ifdef PREPASS_NORMAL
gl_FragData[NORMAL_INDEX]=vec4(normalOutput,1.0);
#endif
#else
gl_FragData[0]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);
gl_FragData[1]=vec4(normalOutput,1.0);
#endif
#ifdef POSITION
gl_FragData[POSITION_INDEX]=vec4(vPositionW,1.0);
#endif
#ifdef VELOCITY
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;
vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;
vec2 velocity=abs(a-b);
velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;
gl_FragData[VELOCITY_INDEX]=vec4(velocity,0.0,1.0);
#endif
#ifdef REFLECTIVITY
vec4 reflectivity=vec4(1.0,1.0,1.0,1.0);
#ifdef METALLICWORKFLOW
float metal=1.0;
float roughness=1.0;
#ifdef ORMTEXTURE
metal*=texture2D(reflectivitySampler,vReflectivityUV).b;
roughness*=texture2D(reflectivitySampler,vReflectivityUV).g;
#endif
#ifdef METALLIC
metal*=metallic;
#endif
#ifdef ROUGHNESS
roughness*=(1.0-glossiness); 
#endif
reflectivity.a-=roughness;
vec3 color=vec3(1.0);
#ifdef ALBEDOTEXTURE
color=texture2D(albedoSampler,vAlbedoUV).rgb;
#ifdef GAMMAALBEDO
color=toLinearSpace(color);
#endif
#endif
#ifdef ALBEDOCOLOR
color*=albedoColor.xyz;
#endif
reflectivity.rgb=mix(vec3(0.04),color,metal);
#else
#ifdef SPECULARGLOSSINESSTEXTURE
reflectivity=texture2D(reflectivitySampler,vReflectivityUV);
#ifdef GAMMAREFLECTIVITYTEXTURE
reflectivity.rgb=toLinearSpace(reflectivity.rgb);
#endif
#ifdef GLOSSINESSS
reflectivity.a*=glossiness;
#endif
#else 
#ifdef REFLECTIVITYTEXTURE
reflectivity.rbg=texture2D(reflectivitySampler,vReflectivityUV).rbg;
#ifdef GAMMAREFLECTIVITYTEXTURE
reflectivity.rgb=toLinearSpace(reflectivity.rgb);
#endif
#else
#ifdef REFLECTIVITYCOLOR
reflectivity.rgb=reflectivityColor.xyz;
reflectivity.a=1.0;
#endif
#endif 
#ifdef GLOSSINESSS
reflectivity.a=glossiness; 
#else
reflectivity.a=1.0; 
#endif
#endif
#endif
reflectivity.rgb=toGammaSpace(reflectivity.rgb); 
gl_FragData[REFLECTIVITY_INDEX]=reflectivity;
#endif
}
`;
ShaderStore.ShadersStore[name89] = shader89;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/geometryVertexDeclaration.js
var name90 = "geometryVertexDeclaration";
var shader90 = `uniform mat4 viewProjection;
uniform mat4 view;`;
ShaderStore.IncludesShadersStore[name90] = shader90;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/geometryUboDeclaration.js
var name91 = "geometryUboDeclaration";
var shader91 = `#include<sceneUboDeclaration>
`;
ShaderStore.IncludesShadersStore[name91] = shader91;

// node_modules/@babylonjs/core/Shaders/geometry.vertex.js
var name92 = "geometryVertexShader";
var shader92 = `precision highp float;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<instancesDeclaration>
#include<__decl__geometryVertex>
attribute vec3 position;
attribute vec3 normal;
#ifdef NEED_UV
varying vec2 vUV;
#ifdef ALPHATEST
uniform mat4 diffuseMatrix;
#endif
#ifdef BUMP
uniform mat4 bumpMatrix;
varying vec2 vBumpUV;
#endif
#ifdef REFLECTIVITY
uniform mat4 reflectivityMatrix;
uniform mat4 albedoMatrix;
varying vec2 vReflectivityUV;
varying vec2 vAlbedoUV;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#ifdef BUMP
varying mat4 vWorldView;
#endif
#ifdef BUMP
varying vec3 vNormalW;
#else
varying vec3 vNormalV;
#endif
varying vec4 vViewPos;
#if defined(POSITION) || defined(BUMP)
varying vec3 vPositionW;
#endif
#ifdef VELOCITY
uniform mat4 previousViewProjection;
varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{
vec3 positionUpdated=position;
vec3 normalUpdated=normal;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#if defined(VELOCITY) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 pos=vec4(finalWorld*vec4(positionUpdated,1.0));
#ifdef BUMP
vWorldView=view*finalWorld;
vNormalW=normalUpdated;
#else
vNormalV=normalize(vec3((view*finalWorld)*vec4(normalUpdated,0.0)));
#endif
vViewPos=view*pos;
#if defined(VELOCITY) && defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);
#if NUM_BONE_INFLUENCERS>0
mat4 previousInfluence;
previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);
#else
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#endif
#if defined(POSITION) || defined(BUMP)
vPositionW=pos.xyz/pos.w;
#endif
gl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);
#ifdef NEED_UV
#ifdef UV1
#if defined(ALPHATEST) && defined(ALPHATEST_UV1)
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#else
vUV=uv;
#endif
#ifdef BUMP_UV1
vBumpUV=vec2(bumpMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef REFLECTIVITY_UV1
vReflectivityUV=vec2(reflectivityMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef ALBEDO_UV1
vAlbedoUV=vec2(albedoMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#endif
#ifdef UV2
#if defined(ALPHATEST) && defined(ALPHATEST_UV2)
vUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#else
vUV=uv2;
#endif
#ifdef BUMP_UV2
vBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));
#endif
#ifdef REFLECTIVITY_UV2
vReflectivityUV=vec2(reflectivityMatrix*vec4(uv2,1.0,0.0));
#endif
#ifdef ALBEDO_UV2
vAlbedoUV=vec2(albedoMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
#endif
#include<bumpVertex>
}
`;
ShaderStore.ShadersStore[name92] = shader92;

// node_modules/@babylonjs/core/Rendering/geometryBufferRenderer.js
var GeometryBufferRenderer = class {
  constructor(scene, ratio = 1, depthFormat = 15) {
    this._previousTransformationMatrices = {};
    this._previousBonesTransformationMatrices = {};
    this.excludedSkinnedMeshesFromVelocity = [];
    this.renderTransparentMeshes = true;
    this._resizeObserver = null;
    this._enablePosition = false;
    this._enableVelocity = false;
    this._enableReflectivity = false;
    this._positionIndex = -1;
    this._velocityIndex = -1;
    this._reflectivityIndex = -1;
    this._depthIndex = -1;
    this._normalIndex = -1;
    this._linkedWithPrePass = false;
    this._scene = scene;
    this._ratio = ratio;
    this._useUbo = scene.getEngine().supportsUniformBuffers;
    this._depthFormat = depthFormat;
    GeometryBufferRenderer._SceneComponentInitialization(this._scene);
    this._createRenderTargets();
  }
  _linkPrePassRenderer(prePassRenderer) {
    this._linkedWithPrePass = true;
    this._prePassRenderer = prePassRenderer;
    if (this._multiRenderTarget) {
      this._multiRenderTarget.onClearObservable.clear();
      this._multiRenderTarget.onClearObservable.add(() => {
      });
    }
  }
  _unlinkPrePassRenderer() {
    this._linkedWithPrePass = false;
    this._createRenderTargets();
  }
  _resetLayout() {
    this._enablePosition = false;
    this._enableReflectivity = false;
    this._enableVelocity = false;
    this._attachments = [];
  }
  _forceTextureType(geometryBufferType, index) {
    if (geometryBufferType === GeometryBufferRenderer.POSITION_TEXTURE_TYPE) {
      this._positionIndex = index;
      this._enablePosition = true;
    } else if (geometryBufferType === GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE) {
      this._velocityIndex = index;
      this._enableVelocity = true;
    } else if (geometryBufferType === GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE) {
      this._reflectivityIndex = index;
      this._enableReflectivity = true;
    } else if (geometryBufferType === GeometryBufferRenderer.DEPTH_TEXTURE_TYPE) {
      this._depthIndex = index;
    } else if (geometryBufferType === GeometryBufferRenderer.NORMAL_TEXTURE_TYPE) {
      this._normalIndex = index;
    }
  }
  _setAttachments(attachments) {
    this._attachments = attachments;
  }
  _linkInternalTexture(internalTexture) {
    this._multiRenderTarget.setInternalTexture(internalTexture, 0, false);
  }
  get renderList() {
    return this._multiRenderTarget.renderList;
  }
  set renderList(meshes) {
    this._multiRenderTarget.renderList = meshes;
  }
  get isSupported() {
    return this._multiRenderTarget.isSupported;
  }
  getTextureIndex(textureType) {
    switch (textureType) {
      case GeometryBufferRenderer.POSITION_TEXTURE_TYPE:
        return this._positionIndex;
      case GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE:
        return this._velocityIndex;
      case GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE:
        return this._reflectivityIndex;
      default:
        return -1;
    }
  }
  get enablePosition() {
    return this._enablePosition;
  }
  set enablePosition(enable) {
    this._enablePosition = enable;
    if (!this._linkedWithPrePass) {
      this.dispose();
      this._createRenderTargets();
    }
  }
  get enableVelocity() {
    return this._enableVelocity;
  }
  set enableVelocity(enable) {
    this._enableVelocity = enable;
    if (!enable) {
      this._previousTransformationMatrices = {};
    }
    if (!this._linkedWithPrePass) {
      this.dispose();
      this._createRenderTargets();
    }
    this._scene.needsPreviousWorldMatrices = enable;
  }
  get enableReflectivity() {
    return this._enableReflectivity;
  }
  set enableReflectivity(enable) {
    this._enableReflectivity = enable;
    if (!this._linkedWithPrePass) {
      this.dispose();
      this._createRenderTargets();
    }
  }
  get scene() {
    return this._scene;
  }
  get ratio() {
    return this._ratio;
  }
  isReady(subMesh, useInstances) {
    const material = subMesh.getMaterial();
    if (material && material.disableDepthWrite) {
      return false;
    }
    const defines = [];
    const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];
    const mesh = subMesh.getMesh();
    if (material) {
      let needUv = false;
      if (material.needAlphaTesting() && material.getAlphaTestTexture()) {
        defines.push("#define ALPHATEST");
        defines.push(`#define ALPHATEST_UV${material.getAlphaTestTexture().coordinatesIndex + 1}`);
        needUv = true;
      }
      if (material.bumpTexture && MaterialFlags.BumpTextureEnabled) {
        defines.push("#define BUMP");
        defines.push(`#define BUMP_UV${material.bumpTexture.coordinatesIndex + 1}`);
        needUv = true;
      }
      if (this._enableReflectivity) {
        let metallicWorkflow = false;
        if (material.getClassName() === "PBRMetallicRoughnessMaterial") {
          if (material.metallicRoughnessTexture !== null) {
            defines.push("#define ORMTEXTURE");
            defines.push(`#define REFLECTIVITY_UV${material.metallicRoughnessTexture.coordinatesIndex + 1}`);
            defines.push("#define METALLICWORKFLOW");
            needUv = true;
            metallicWorkflow = true;
          }
          if (material.metallic !== null) {
            defines.push("#define METALLIC");
            defines.push("#define METALLICWORKFLOW");
            metallicWorkflow = true;
          }
          if (material.roughness !== null) {
            defines.push("#define ROUGHNESS");
            defines.push("#define METALLICWORKFLOW");
            metallicWorkflow = true;
          }
          if (metallicWorkflow) {
            if (material.baseTexture !== null) {
              defines.push("#define ALBEDOTEXTURE");
              defines.push(`#define ALBEDO_UV${material.baseTexture.coordinatesIndex + 1}`);
              if (material.baseTexture.gammaSpace) {
                defines.push("#define GAMMAALBEDO");
              }
              needUv = true;
            }
            if (material.baseColor !== null) {
              defines.push("#define ALBEDOCOLOR");
            }
          }
        } else if (material.getClassName() === "PBRSpecularGlossinessMaterial") {
          if (material.specularGlossinessTexture !== null) {
            defines.push("#define SPECULARGLOSSINESSTEXTURE");
            defines.push(`#define REFLECTIVITY_UV${material.specularGlossinessTexture.coordinatesIndex + 1}`);
            needUv = true;
            if (material.specularGlossinessTexture.gammaSpace) {
              defines.push("#define GAMMAREFLECTIVITYTEXTURE");
            }
          } else {
            if (material.specularColor !== null) {
              defines.push("#define REFLECTIVITYCOLOR");
            }
          }
          if (material.glossiness !== null) {
            defines.push("#define GLOSSINESSS");
          }
        } else if (material.getClassName() === "PBRMaterial") {
          if (material.metallicTexture !== null) {
            defines.push("#define ORMTEXTURE");
            defines.push(`#define REFLECTIVITY_UV${material.metallicTexture.coordinatesIndex + 1}`);
            defines.push("#define METALLICWORKFLOW");
            needUv = true;
            metallicWorkflow = true;
          }
          if (material.metallic !== null) {
            defines.push("#define METALLIC");
            defines.push("#define METALLICWORKFLOW");
            metallicWorkflow = true;
          }
          if (material.roughness !== null) {
            defines.push("#define ROUGHNESS");
            defines.push("#define METALLICWORKFLOW");
            metallicWorkflow = true;
          }
          if (metallicWorkflow) {
            if (material.albedoTexture !== null) {
              defines.push("#define ALBEDOTEXTURE");
              defines.push(`#define ALBEDO_UV${material.albedoTexture.coordinatesIndex + 1}`);
              if (material.albedoTexture.gammaSpace) {
                defines.push("#define GAMMAALBEDO");
              }
              needUv = true;
            }
            if (material.albedoColor !== null) {
              defines.push("#define ALBEDOCOLOR");
            }
          } else {
            if (material.reflectivityTexture !== null) {
              defines.push("#define SPECULARGLOSSINESSTEXTURE");
              defines.push(`#define REFLECTIVITY_UV${material.reflectivityTexture.coordinatesIndex + 1}`);
              if (material.reflectivityTexture.gammaSpace) {
                defines.push("#define GAMMAREFLECTIVITYTEXTURE");
              }
              needUv = true;
            } else if (material.reflectivityColor !== null) {
              defines.push("#define REFLECTIVITYCOLOR");
            }
            if (material.microSurface !== null) {
              defines.push("#define GLOSSINESSS");
            }
          }
        } else if (material.getClassName() === "StandardMaterial") {
          if (material.specularTexture !== null) {
            defines.push("#define REFLECTIVITYTEXTURE");
            defines.push(`#define REFLECTIVITY_UV${material.specularTexture.coordinatesIndex + 1}`);
            if (material.specularTexture.gammaSpace) {
              defines.push("#define GAMMAREFLECTIVITYTEXTURE");
            }
            needUv = true;
          }
          if (material.specularColor !== null) {
            defines.push("#define REFLECTIVITYCOLOR");
          }
        }
      }
      if (needUv) {
        defines.push("#define NEED_UV");
        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
          attribs.push(VertexBuffer.UVKind);
          defines.push("#define UV1");
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
          attribs.push(VertexBuffer.UV2Kind);
          defines.push("#define UV2");
        }
      }
    }
    if (this._linkedWithPrePass) {
      defines.push("#define PREPASS");
      if (this._depthIndex !== -1) {
        defines.push("#define DEPTH_INDEX " + this._depthIndex);
        defines.push("#define PREPASS_DEPTH");
      }
      if (this._normalIndex !== -1) {
        defines.push("#define NORMAL_INDEX " + this._normalIndex);
        defines.push("#define PREPASS_NORMAL");
      }
    }
    if (this._enablePosition) {
      defines.push("#define POSITION");
      defines.push("#define POSITION_INDEX " + this._positionIndex);
    }
    if (this._enableVelocity) {
      defines.push("#define VELOCITY");
      defines.push("#define VELOCITY_INDEX " + this._velocityIndex);
      if (this.excludedSkinnedMeshesFromVelocity.indexOf(mesh) === -1) {
        defines.push("#define BONES_VELOCITY_ENABLED");
      }
    }
    if (this._enableReflectivity) {
      defines.push("#define REFLECTIVITY");
      defines.push("#define REFLECTIVITY_INDEX " + this._reflectivityIndex);
    }
    if (mesh.useBones && mesh.computeBonesUsingShaders) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      defines.push("#define BonesPerMesh " + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    const morphTargetManager = mesh.morphTargetManager;
    let numMorphInfluencers = 0;
    if (morphTargetManager) {
      if (morphTargetManager.numInfluencers > 0) {
        numMorphInfluencers = morphTargetManager.numInfluencers;
        defines.push("#define MORPHTARGETS");
        defines.push("#define NUM_MORPH_INFLUENCERS " + numMorphInfluencers);
        if (morphTargetManager.isUsingTextureForTargets) {
          defines.push("#define MORPHTARGETS_TEXTURE");
        }
        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);
      }
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      MaterialHelper.PushAttributesForInstances(attribs, this._enableVelocity);
      if (subMesh.getRenderingMesh().hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
      }
    }
    if (this._linkedWithPrePass) {
      defines.push("#define RENDER_TARGET_COUNT " + this._attachments.length);
    } else {
      defines.push("#define RENDER_TARGET_COUNT " + this._multiRenderTarget.textures.length);
    }
    const engine = this._scene.getEngine();
    const drawWrapper = subMesh._getDrawWrapper(void 0, true);
    const cachedDefines = drawWrapper.defines;
    const join = defines.join("\n");
    if (cachedDefines !== join) {
      drawWrapper.setEffect(engine.createEffect("geometry", {
        attributes: attribs,
        uniformsNames: [
          "world",
          "mBones",
          "viewProjection",
          "diffuseMatrix",
          "view",
          "previousWorld",
          "previousViewProjection",
          "mPreviousBones",
          "bumpMatrix",
          "reflectivityMatrix",
          "albedoMatrix",
          "reflectivityColor",
          "albedoColor",
          "metallic",
          "glossiness",
          "vTangentSpaceParams",
          "vBumpInfos",
          "morphTargetInfluences",
          "morphTargetTextureInfo",
          "morphTargetTextureIndices"
        ],
        samplers: ["diffuseSampler", "bumpSampler", "reflectivitySampler", "albedoSampler", "morphTargets"],
        defines: join,
        onCompiled: null,
        fallbacks: null,
        onError: null,
        uniformBuffersNames: ["Scene"],
        indexParameters: { buffersCount: this._multiRenderTarget.textures.length - 1, maxSimultaneousMorphTargets: numMorphInfluencers }
      }, engine), join);
    }
    return drawWrapper.effect.isReady();
  }
  getGBuffer() {
    return this._multiRenderTarget;
  }
  get samples() {
    return this._multiRenderTarget.samples;
  }
  set samples(value) {
    this._multiRenderTarget.samples = value;
  }
  dispose() {
    if (this._resizeObserver) {
      const engine = this._scene.getEngine();
      engine.onResizeObservable.remove(this._resizeObserver);
      this._resizeObserver = null;
    }
    this.getGBuffer().dispose();
  }
  _assignRenderTargetIndices() {
    const textureNames = [];
    let count = 2;
    textureNames.push("gBuffer_Depth", "gBuffer_Normal");
    if (this._enablePosition) {
      this._positionIndex = count;
      count++;
      textureNames.push("gBuffer_Position");
    }
    if (this._enableVelocity) {
      this._velocityIndex = count;
      count++;
      textureNames.push("gBuffer_Velocity");
    }
    if (this._enableReflectivity) {
      this._reflectivityIndex = count;
      count++;
      textureNames.push("gBuffer_Reflectivity");
    }
    return [count, textureNames];
  }
  _createRenderTargets() {
    const engine = this._scene.getEngine();
    const [count, textureNames] = this._assignRenderTargetIndices();
    let type = 0;
    if (engine._caps.textureFloat && engine._caps.textureFloatLinearFiltering) {
      type = 1;
    } else if (engine._caps.textureHalfFloat && engine._caps.textureHalfFloatLinearFiltering) {
      type = 2;
    }
    this._multiRenderTarget = new MultiRenderTarget("gBuffer", { width: engine.getRenderWidth() * this._ratio, height: engine.getRenderHeight() * this._ratio }, count, this._scene, { generateMipMaps: false, generateDepthTexture: true, defaultType: type, depthTextureFormat: this._depthFormat }, textureNames.concat("gBuffer_DepthBuffer"));
    if (!this.isSupported) {
      return;
    }
    this._multiRenderTarget.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._multiRenderTarget.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._multiRenderTarget.refreshRate = 1;
    this._multiRenderTarget.renderParticles = false;
    this._multiRenderTarget.renderList = null;
    this._multiRenderTarget.onClearObservable.add((engine2) => {
      engine2.clear(new Color4(0, 0, 0, 0), true, true, true);
    });
    this._resizeObserver = engine.onResizeObservable.add(() => {
      if (this._multiRenderTarget) {
        this._multiRenderTarget.resize({ width: engine.getRenderWidth() * this._ratio, height: engine.getRenderHeight() * this._ratio });
      }
    });
    const renderSubMesh = (subMesh) => {
      const renderingMesh = subMesh.getRenderingMesh();
      const effectiveMesh = subMesh.getEffectiveMesh();
      const scene = this._scene;
      const engine2 = scene.getEngine();
      const material = subMesh.getMaterial();
      if (!material) {
        return;
      }
      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
      if (this._enableVelocity && !this._previousTransformationMatrices[effectiveMesh.uniqueId]) {
        this._previousTransformationMatrices[effectiveMesh.uniqueId] = {
          world: Matrix.Identity(),
          viewProjection: scene.getTransformMatrix()
        };
        if (renderingMesh.skeleton) {
          const bonesTransformations = renderingMesh.skeleton.getTransformMatrices(renderingMesh);
          this._previousBonesTransformationMatrices[renderingMesh.uniqueId] = this._copyBonesTransformationMatrices(bonesTransformations, new Float32Array(bonesTransformations.length));
        }
      }
      const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
      if (batch.mustReturn) {
        return;
      }
      const hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);
      const world = effectiveMesh.getWorldMatrix();
      if (this.isReady(subMesh, hardwareInstancedRendering)) {
        const drawWrapper = subMesh._getDrawWrapper();
        if (!drawWrapper) {
          return;
        }
        const effect = drawWrapper.effect;
        engine2.enableEffect(drawWrapper);
        if (!hardwareInstancedRendering) {
          renderingMesh._bind(subMesh, effect, material.fillMode);
        }
        if (!this._useUbo) {
          effect.setMatrix("viewProjection", scene.getTransformMatrix());
          effect.setMatrix("view", scene.getViewMatrix());
        } else {
          MaterialHelper.BindSceneUniformBuffer(effect, this._scene.getSceneUniformBuffer());
          this._scene.finalizeSceneUbo();
        }
        if (material) {
          let sideOrientation;
          const instanceDataStorage = renderingMesh._instanceDataStorage;
          if (!instanceDataStorage.isFrozen && (material.backFaceCulling || renderingMesh.overrideMaterialSideOrientation !== null)) {
            const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();
            sideOrientation = renderingMesh.overrideMaterialSideOrientation;
            if (sideOrientation === null) {
              sideOrientation = material.sideOrientation;
            }
            if (mainDeterminant < 0) {
              sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
            }
          } else {
            sideOrientation = instanceDataStorage.sideOrientation;
          }
          material._preBind(drawWrapper, sideOrientation);
          if (material.needAlphaTesting()) {
            const alphaTexture = material.getAlphaTestTexture();
            if (alphaTexture) {
              effect.setTexture("diffuseSampler", alphaTexture);
              effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
            }
          }
          if (material.bumpTexture && scene.getEngine().getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled) {
            effect.setFloat3("vBumpInfos", material.bumpTexture.coordinatesIndex, 1 / material.bumpTexture.level, material.parallaxScaleBias);
            effect.setMatrix("bumpMatrix", material.bumpTexture.getTextureMatrix());
            effect.setTexture("bumpSampler", material.bumpTexture);
            effect.setFloat2("vTangentSpaceParams", material.invertNormalMapX ? -1 : 1, material.invertNormalMapY ? -1 : 1);
          }
          if (this._enableReflectivity) {
            if (material.getClassName() === "PBRMetallicRoughnessMaterial") {
              if (material.metallicRoughnessTexture !== null) {
                effect.setTexture("reflectivitySampler", material.metallicRoughnessTexture);
                effect.setMatrix("reflectivityMatrix", material.metallicRoughnessTexture.getTextureMatrix());
              }
              if (material.metallic !== null) {
                effect.setFloat("metallic", material.metallic);
              }
              if (material.roughness !== null) {
                effect.setFloat("glossiness", 1 - material.roughness);
              }
              if (material.baseTexture !== null) {
                effect.setTexture("albedoSampler", material.baseTexture);
                effect.setMatrix("albedoMatrix", material.baseTexture.getTextureMatrix());
              }
              if (material.baseColor !== null) {
                effect.setColor3("albedoColor", material.baseColor);
              }
            } else if (material.getClassName() === "PBRSpecularGlossinessMaterial") {
              if (material.specularGlossinessTexture !== null) {
                effect.setTexture("reflectivitySampler", material.specularGlossinessTexture);
                effect.setMatrix("reflectivityMatrix", material.specularGlossinessTexture.getTextureMatrix());
              } else {
                if (material.specularColor !== null) {
                  effect.setColor3("reflectivityColor", material.specularColor);
                }
              }
              if (material.glossiness !== null) {
                effect.setFloat("glossiness", material.glossiness);
              }
            } else if (material.getClassName() === "PBRMaterial") {
              if (material.metallicTexture !== null) {
                effect.setTexture("reflectivitySampler", material.metallicTexture);
                effect.setMatrix("reflectivityMatrix", material.metallicTexture.getTextureMatrix());
              }
              if (material.metallic !== null) {
                effect.setFloat("metallic", material.metallic);
              }
              if (material.roughness !== null) {
                effect.setFloat("glossiness", 1 - material.roughness);
              }
              if (material.roughness !== null || material.metallic !== null || material.metallicTexture !== null) {
                if (material.albedoTexture !== null) {
                  effect.setTexture("albedoSampler", material.albedoTexture);
                  effect.setMatrix("albedoMatrix", material.albedoTexture.getTextureMatrix());
                }
                if (material.albedoColor !== null) {
                  effect.setColor3("albedoColor", material.albedoColor);
                }
              } else {
                if (material.reflectivityTexture !== null) {
                  effect.setTexture("reflectivitySampler", material.reflectivityTexture);
                  effect.setMatrix("reflectivityMatrix", material.reflectivityTexture.getTextureMatrix());
                } else if (material.reflectivityColor !== null) {
                  effect.setColor3("reflectivityColor", material.reflectivityColor);
                }
                if (material.microSurface !== null) {
                  effect.setFloat("glossiness", material.microSurface);
                }
              }
            } else if (material.getClassName() === "StandardMaterial") {
              if (material.specularTexture !== null) {
                effect.setTexture("reflectivitySampler", material.specularTexture);
                effect.setMatrix("reflectivityMatrix", material.specularTexture.getTextureMatrix());
              }
              if (material.specularColor !== null) {
                effect.setColor3("reflectivityColor", material.specularColor);
              }
            }
          }
        }
        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
          effect.setMatrices("mBones", renderingMesh.skeleton.getTransformMatrices(renderingMesh));
          if (this._enableVelocity) {
            effect.setMatrices("mPreviousBones", this._previousBonesTransformationMatrices[renderingMesh.uniqueId]);
          }
        }
        MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);
        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
          renderingMesh.morphTargetManager._bind(effect);
        }
        if (this._enableVelocity) {
          effect.setMatrix("previousWorld", this._previousTransformationMatrices[effectiveMesh.uniqueId].world);
          effect.setMatrix("previousViewProjection", this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection);
        }
        if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {
          effect.setMatrix("world", world);
        }
        renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, w) => {
          if (!isInstance) {
            effect.setMatrix("world", w);
          }
        });
      }
      if (this._enableVelocity) {
        this._previousTransformationMatrices[effectiveMesh.uniqueId].world = world.clone();
        this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection = this._scene.getTransformMatrix().clone();
        if (renderingMesh.skeleton) {
          this._copyBonesTransformationMatrices(renderingMesh.skeleton.getTransformMatrices(renderingMesh), this._previousBonesTransformationMatrices[effectiveMesh.uniqueId]);
        }
      }
    };
    this._multiRenderTarget.customIsReadyFunction = (mesh, refreshRate, preWarm) => {
      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {
        for (let i = 0; i < mesh.subMeshes.length; ++i) {
          const subMesh = mesh.subMeshes[i];
          const material = subMesh.getMaterial();
          const renderingMesh = subMesh.getRenderingMesh();
          if (!material) {
            continue;
          }
          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
          const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);
          if (!this.isReady(subMesh, hardwareInstancedRendering)) {
            return false;
          }
        }
      }
      return true;
    };
    this._multiRenderTarget.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {
      let index;
      if (this._linkedWithPrePass) {
        if (!this._prePassRenderer.enabled) {
          return;
        }
        this._scene.getEngine().bindAttachments(this._attachments);
      }
      if (depthOnlySubMeshes.length) {
        engine.setColorWrite(false);
        for (index = 0; index < depthOnlySubMeshes.length; index++) {
          renderSubMesh(depthOnlySubMeshes.data[index]);
        }
        engine.setColorWrite(true);
      }
      for (index = 0; index < opaqueSubMeshes.length; index++) {
        renderSubMesh(opaqueSubMeshes.data[index]);
      }
      engine.setDepthWrite(false);
      for (index = 0; index < alphaTestSubMeshes.length; index++) {
        renderSubMesh(alphaTestSubMeshes.data[index]);
      }
      if (this.renderTransparentMeshes) {
        for (index = 0; index < transparentSubMeshes.length; index++) {
          renderSubMesh(transparentSubMeshes.data[index]);
        }
      }
      engine.setDepthWrite(true);
    };
  }
  _copyBonesTransformationMatrices(source, target) {
    for (let i = 0; i < source.length; i++) {
      target[i] = source[i];
    }
    return target;
  }
};
GeometryBufferRenderer.DEPTH_TEXTURE_TYPE = 0;
GeometryBufferRenderer.NORMAL_TEXTURE_TYPE = 1;
GeometryBufferRenderer.POSITION_TEXTURE_TYPE = 2;
GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE = 3;
GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE = 4;
GeometryBufferRenderer._SceneComponentInitialization = (_) => {
  throw _WarnImport("GeometryBufferRendererSceneComponent");
};

// node_modules/@babylonjs/core/Rendering/motionBlurConfiguration.js
var MotionBlurConfiguration = class {
  constructor() {
    this.enabled = false;
    this.name = "motionBlur";
    this.texturesRequired = [2];
  }
};

// node_modules/@babylonjs/core/Rendering/geometryBufferRendererSceneComponent.js
Object.defineProperty(Scene.prototype, "geometryBufferRenderer", {
  get: function() {
    return this._geometryBufferRenderer;
  },
  set: function(value) {
    if (value && value.isSupported) {
      this._geometryBufferRenderer = value;
    }
  },
  enumerable: true,
  configurable: true
});
Scene.prototype.enableGeometryBufferRenderer = function(ratio = 1, depthFormat = 15) {
  if (this._geometryBufferRenderer) {
    return this._geometryBufferRenderer;
  }
  this._geometryBufferRenderer = new GeometryBufferRenderer(this, ratio, depthFormat);
  if (!this._geometryBufferRenderer.isSupported) {
    this._geometryBufferRenderer = null;
  }
  return this._geometryBufferRenderer;
};
Scene.prototype.disableGeometryBufferRenderer = function() {
  if (!this._geometryBufferRenderer) {
    return;
  }
  this._geometryBufferRenderer.dispose();
  this._geometryBufferRenderer = null;
};
var GeometryBufferRendererSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER;
    this.scene = scene;
  }
  register() {
    this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER, this, this._gatherRenderTargets);
  }
  rebuild() {
  }
  dispose() {
  }
  _gatherRenderTargets(renderTargets) {
    if (this.scene._geometryBufferRenderer) {
      renderTargets.push(this.scene._geometryBufferRenderer.getGBuffer());
    }
  }
};
GeometryBufferRenderer._SceneComponentInitialization = (scene) => {
  let component = scene._getComponent(SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER);
  if (!component) {
    component = new GeometryBufferRendererSceneComponent(scene);
    scene._addComponent(component);
  }
};

// node_modules/@babylonjs/core/Shaders/motionBlur.fragment.js
var name93 = "motionBlurPixelShader";
var shader93 = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform float motionStrength;
uniform float motionScale;
uniform vec2 screenSize;
#ifdef OBJECT_BASED
uniform sampler2D velocitySampler;
#else
uniform sampler2D depthSampler;
uniform mat4 inverseViewProjection;
uniform mat4 prevViewProjection;
uniform mat4 projection;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#ifdef GEOMETRY_SUPPORTED
#ifdef OBJECT_BASED
vec2 texelSize=1.0/screenSize;
vec4 velocityColor=texture2D(velocitySampler,vUV);
velocityColor.rg=velocityColor.rg*2.0-vec2(1.0);
vec2 velocity=vec2(pow(velocityColor.r,3.0),pow(velocityColor.g,3.0))*velocityColor.a;
velocity*=motionScale*motionStrength;
float speed=length(velocity/texelSize);
int samplesCount=int(clamp(speed,1.0,SAMPLES));
velocity=normalize(velocity)*texelSize;
float hlim=float(-samplesCount)*0.5+0.5;
vec4 result=texture2D(textureSampler,vUV);
for (int i=1; i<int(SAMPLES); ++i)
{
if (i>=samplesCount)
break;
vec2 offset=vUV+velocity*(hlim+float(i));
result+=texture2D(textureSampler,offset);
}
gl_FragColor=result/float(samplesCount);
gl_FragColor.a=1.0;
#else
vec2 texelSize=1.0/screenSize;
float depth=texture2D(depthSampler,vUV).r;
depth=projection[2].z+projection[3].z/depth; 
vec4 cpos=vec4(vUV*2.0-1.0,depth,1.0);
cpos=inverseViewProjection*cpos;
cpos/=cpos.w;
vec4 ppos=prevViewProjection*cpos;
ppos/=ppos.w;
ppos.xy=ppos.xy*0.5+0.5;
vec2 velocity=(ppos.xy-vUV)*motionScale*motionStrength;
float speed=length(velocity/texelSize);
int nSamples=int(clamp(speed,1.0,SAMPLES));
vec4 result=texture2D(textureSampler,vUV);
for (int i=1; i<int(SAMPLES); ++i) {
if (i>=nSamples)
break;
vec2 offset1=vUV+velocity*(float(i)/float(nSamples-1)-0.5);
result+=texture2D(textureSampler,offset1);
}
gl_FragColor=result/float(nSamples);
#endif
#else
gl_FragColor=texture2D(textureSampler,vUV);
#endif
}
`;
ShaderStore.ShadersStore[name93] = shader93;

// node_modules/@babylonjs/core/PostProcesses/motionBlurPostProcess.js
var MotionBlurPostProcess = class extends PostProcess {
  constructor(name137, scene, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false, forceGeometryBuffer = false) {
    super(name137, "motionBlur", ["motionStrength", "motionScale", "screenSize", "inverseViewProjection", "prevViewProjection", "projection"], ["velocitySampler", "depthSampler"], options, camera, samplingMode, engine, reusable, "#define GEOMETRY_SUPPORTED\n#define SAMPLES 64.0\n#define OBJECT_BASED", textureType, void 0, null, blockCompilation);
    this.motionStrength = 1;
    this._motionBlurSamples = 32;
    this._isObjectBased = true;
    this._forceGeometryBuffer = false;
    this._invViewProjection = null;
    this._previousViewProjection = null;
    this._forceGeometryBuffer = forceGeometryBuffer;
    if (this._forceGeometryBuffer) {
      scene.enableGeometryBufferRenderer();
      if (this._geometryBufferRenderer) {
        this._geometryBufferRenderer.enableVelocity = true;
      }
    } else {
      scene.enablePrePassRenderer();
      if (this._prePassRenderer) {
        this._prePassRenderer.markAsDirty();
        this._prePassEffectConfiguration = new MotionBlurConfiguration();
      }
    }
    this._applyMode();
  }
  get motionBlurSamples() {
    return this._motionBlurSamples;
  }
  set motionBlurSamples(samples) {
    this._motionBlurSamples = samples;
    this._updateEffect();
  }
  get isObjectBased() {
    return this._isObjectBased;
  }
  set isObjectBased(value) {
    if (this._isObjectBased === value) {
      return;
    }
    this._isObjectBased = value;
    this._applyMode();
  }
  get _geometryBufferRenderer() {
    if (!this._forceGeometryBuffer) {
      return null;
    }
    return this._scene.geometryBufferRenderer;
  }
  get _prePassRenderer() {
    if (this._forceGeometryBuffer) {
      return null;
    }
    return this._scene.prePassRenderer;
  }
  getClassName() {
    return "MotionBlurPostProcess";
  }
  excludeSkinnedMesh(skinnedMesh) {
    if (skinnedMesh.skeleton) {
      let list;
      if (this._geometryBufferRenderer) {
        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;
      } else if (this._prePassRenderer) {
        list = this._prePassRenderer.excludedSkinnedMesh;
      } else {
        return;
      }
      list.push(skinnedMesh);
    }
  }
  removeExcludedSkinnedMesh(skinnedMesh) {
    if (skinnedMesh.skeleton) {
      let list;
      if (this._geometryBufferRenderer) {
        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;
      } else if (this._prePassRenderer) {
        list = this._prePassRenderer.excludedSkinnedMesh;
      } else {
        return;
      }
      const index = list.indexOf(skinnedMesh);
      if (index !== -1) {
        list.splice(index, 1);
      }
    }
  }
  dispose(camera) {
    if (this._geometryBufferRenderer) {
      this._geometryBufferRenderer._previousTransformationMatrices = {};
      this._geometryBufferRenderer._previousBonesTransformationMatrices = {};
      this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];
    }
    super.dispose(camera);
  }
  _applyMode() {
    if (!this._geometryBufferRenderer && !this._prePassRenderer) {
      Logger.Warn("Multiple Render Target support needed to compute object based motion blur");
      return this.updateEffect();
    }
    this._updateEffect();
    this._invViewProjection = null;
    this._previousViewProjection = null;
    if (this.isObjectBased) {
      if (this._prePassRenderer && this._prePassEffectConfiguration) {
        this._prePassEffectConfiguration.texturesRequired[0] = 2;
      }
      this.onApply = (effect) => this._onApplyObjectBased(effect);
    } else {
      this._invViewProjection = Matrix.Identity();
      this._previousViewProjection = this._scene.getTransformMatrix().clone();
      if (this._prePassRenderer && this._prePassEffectConfiguration) {
        this._prePassEffectConfiguration.texturesRequired[0] = 5;
      }
      this.onApply = (effect) => this._onApplyScreenBased(effect);
    }
  }
  _onApplyObjectBased(effect) {
    effect.setVector2("screenSize", new Vector2(this.width, this.height));
    effect.setFloat("motionScale", this._scene.getAnimationRatio());
    effect.setFloat("motionStrength", this.motionStrength);
    if (this._geometryBufferRenderer) {
      const velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);
      effect.setTexture("velocitySampler", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);
    } else if (this._prePassRenderer) {
      const velocityIndex = this._prePassRenderer.getIndex(2);
      effect.setTexture("velocitySampler", this._prePassRenderer.getRenderTarget().textures[velocityIndex]);
    }
  }
  _onApplyScreenBased(effect) {
    const viewProjection = TmpVectors.Matrix[0];
    viewProjection.copyFrom(this._scene.getTransformMatrix());
    viewProjection.invertToRef(this._invViewProjection);
    effect.setMatrix("inverseViewProjection", this._invViewProjection);
    effect.setMatrix("prevViewProjection", this._previousViewProjection);
    this._previousViewProjection.copyFrom(viewProjection);
    effect.setMatrix("projection", this._scene.getProjectionMatrix());
    effect.setVector2("screenSize", new Vector2(this.width, this.height));
    effect.setFloat("motionScale", this._scene.getAnimationRatio());
    effect.setFloat("motionStrength", this.motionStrength);
    if (this._geometryBufferRenderer) {
      const depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.DEPTH_TEXTURE_TYPE);
      effect.setTexture("depthSampler", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);
    } else if (this._prePassRenderer) {
      const depthIndex = this._prePassRenderer.getIndex(5);
      effect.setTexture("depthSampler", this._prePassRenderer.getRenderTarget().textures[depthIndex]);
    }
  }
  _updateEffect() {
    if (this._geometryBufferRenderer || this._prePassRenderer) {
      const defines = [
        "#define GEOMETRY_SUPPORTED",
        "#define SAMPLES " + this._motionBlurSamples.toFixed(1),
        this._isObjectBased ? "#define OBJECT_BASED" : "#define SCREEN_BASED"
      ];
      this.updateEffect(defines.join("\n"));
    }
  }
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new MotionBlurPostProcess(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, false);
    }, parsedPostProcess, scene, rootUrl);
  }
};
__decorate([
  serialize()
], MotionBlurPostProcess.prototype, "motionStrength", void 0);
__decorate([
  serialize()
], MotionBlurPostProcess.prototype, "motionBlurSamples", null);
__decorate([
  serialize()
], MotionBlurPostProcess.prototype, "isObjectBased", null);
RegisterClass("BABYLON.MotionBlurPostProcess", MotionBlurPostProcess);

// node_modules/@babylonjs/core/Shaders/refraction.fragment.js
var name94 = "refractionPixelShader";
var shader94 = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform sampler2D refractionSampler;
uniform vec3 baseColor;
uniform float depth;
uniform float colorLevel;
void main() {
float ref=1.0-texture2D(refractionSampler,vUV).r;
vec2 uv=vUV-vec2(0.5);
vec2 offset=uv*depth*ref;
vec3 sourceColor=texture2D(textureSampler,vUV-offset).rgb;
gl_FragColor=vec4(sourceColor+sourceColor*ref*colorLevel,1.0);
}`;
ShaderStore.ShadersStore[name94] = shader94;

// node_modules/@babylonjs/core/PostProcesses/refractionPostProcess.js
var RefractionPostProcess = class extends PostProcess {
  constructor(name137, refractionTextureUrl, color, depth, colorLevel, options, camera, samplingMode, engine, reusable) {
    super(name137, "refraction", ["baseColor", "depth", "colorLevel"], ["refractionSampler"], options, camera, samplingMode, engine, reusable);
    this._ownRefractionTexture = true;
    this.color = color;
    this.depth = depth;
    this.colorLevel = colorLevel;
    this.refractionTextureUrl = refractionTextureUrl;
    this.onActivateObservable.add((cam) => {
      this._refTexture = this._refTexture || new Texture(refractionTextureUrl, cam.getScene());
    });
    this.onApplyObservable.add((effect) => {
      effect.setColor3("baseColor", this.color);
      effect.setFloat("depth", this.depth);
      effect.setFloat("colorLevel", this.colorLevel);
      effect.setTexture("refractionSampler", this._refTexture);
    });
  }
  get refractionTexture() {
    return this._refTexture;
  }
  set refractionTexture(value) {
    if (this._refTexture && this._ownRefractionTexture) {
      this._refTexture.dispose();
    }
    this._refTexture = value;
    this._ownRefractionTexture = false;
  }
  getClassName() {
    return "RefractionPostProcess";
  }
  dispose(camera) {
    if (this._refTexture && this._ownRefractionTexture) {
      this._refTexture.dispose();
      this._refTexture = null;
    }
    super.dispose(camera);
  }
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new RefractionPostProcess(parsedPostProcess.name, parsedPostProcess.refractionTextureUrl, parsedPostProcess.color, parsedPostProcess.depth, parsedPostProcess.colorLevel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  }
};
__decorate([
  serialize()
], RefractionPostProcess.prototype, "color", void 0);
__decorate([
  serialize()
], RefractionPostProcess.prototype, "depth", void 0);
__decorate([
  serialize()
], RefractionPostProcess.prototype, "colorLevel", void 0);
__decorate([
  serialize()
], RefractionPostProcess.prototype, "refractionTextureUrl", void 0);
RegisterClass("BABYLON.RefractionPostProcess", RefractionPostProcess);

// node_modules/@babylonjs/core/Shaders/sharpen.fragment.js
var name95 = "sharpenPixelShader";
var shader95 = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform vec2 screenSize;
uniform vec2 sharpnessAmounts;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
vec2 onePixel=vec2(1.0,1.0)/screenSize;
vec4 color=texture2D(textureSampler,vUV);
vec4 edgeDetection=texture2D(textureSampler,vUV+onePixel*vec2(0,-1)) +
texture2D(textureSampler,vUV+onePixel*vec2(-1,0)) +
texture2D(textureSampler,vUV+onePixel*vec2(1,0)) +
texture2D(textureSampler,vUV+onePixel*vec2(0,1)) -
color*4.0;
gl_FragColor=max(vec4(color.rgb*sharpnessAmounts.y,color.a)-(sharpnessAmounts.x*vec4(edgeDetection.rgb,0)),0.);
}`;
ShaderStore.ShadersStore[name95] = shader95;

// node_modules/@babylonjs/core/PostProcesses/sharpenPostProcess.js
var SharpenPostProcess = class extends PostProcess {
  constructor(name137, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
    super(name137, "sharpen", ["sharpnessAmounts", "screenSize"], null, options, camera, samplingMode, engine, reusable, null, textureType, void 0, null, blockCompilation);
    this.colorAmount = 1;
    this.edgeAmount = 0.3;
    this.onApply = (effect) => {
      effect.setFloat2("screenSize", this.width, this.height);
      effect.setFloat2("sharpnessAmounts", this.edgeAmount, this.colorAmount);
    };
  }
  getClassName() {
    return "SharpenPostProcess";
  }
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new SharpenPostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.textureType, parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  }
};
__decorate([
  serialize()
], SharpenPostProcess.prototype, "colorAmount", void 0);
__decorate([
  serialize()
], SharpenPostProcess.prototype, "edgeAmount", void 0);
RegisterClass("BABYLON.SharpenPostProcess", SharpenPostProcess);

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipeline.js
var PostProcessRenderPipeline = class {
  constructor(_engine, name137) {
    this._engine = _engine;
    this._name = name137;
    this._renderEffects = {};
    this._renderEffectsForIsolatedPass = new Array();
    this._cameras = [];
  }
  get name() {
    return this._name;
  }
  get cameras() {
    return this._cameras;
  }
  getClassName() {
    return "PostProcessRenderPipeline";
  }
  get isSupported() {
    for (const renderEffectName in this._renderEffects) {
      if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {
        if (!this._renderEffects[renderEffectName].isSupported) {
          return false;
        }
      }
    }
    return true;
  }
  addEffect(renderEffect) {
    this._renderEffects[renderEffect._name] = renderEffect;
  }
  _rebuild() {
  }
  _enableEffect(renderEffectName, cameras) {
    const renderEffects = this._renderEffects[renderEffectName];
    if (!renderEffects) {
      return;
    }
    renderEffects._enable(Tools.MakeArray(cameras || this._cameras));
  }
  _disableEffect(renderEffectName, cameras) {
    const renderEffects = this._renderEffects[renderEffectName];
    if (!renderEffects) {
      return;
    }
    renderEffects._disable(Tools.MakeArray(cameras || this._cameras));
  }
  _attachCameras(cameras, unique) {
    const cams = Tools.MakeArray(cameras || this._cameras);
    if (!cams) {
      return;
    }
    const indicesToDelete = [];
    let i;
    for (i = 0; i < cams.length; i++) {
      const camera = cams[i];
      if (!camera) {
        continue;
      }
      if (this._cameras.indexOf(camera) === -1) {
        this._cameras.push(camera);
      } else if (unique) {
        indicesToDelete.push(i);
      }
    }
    for (i = 0; i < indicesToDelete.length; i++) {
      cams.splice(indicesToDelete[i], 1);
    }
    for (const renderEffectName in this._renderEffects) {
      if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {
        this._renderEffects[renderEffectName]._attachCameras(cams);
      }
    }
  }
  _detachCameras(cameras) {
    const cams = Tools.MakeArray(cameras || this._cameras);
    if (!cams) {
      return;
    }
    for (const renderEffectName in this._renderEffects) {
      if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {
        this._renderEffects[renderEffectName]._detachCameras(cams);
      }
    }
    for (let i = 0; i < cams.length; i++) {
      this._cameras.splice(this._cameras.indexOf(cams[i]), 1);
    }
  }
  _update() {
    for (const renderEffectName in this._renderEffects) {
      if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {
        this._renderEffects[renderEffectName]._update();
      }
    }
    for (let i = 0; i < this._cameras.length; i++) {
      if (!this._cameras[i]) {
        continue;
      }
      const cameraName = this._cameras[i].name;
      if (this._renderEffectsForIsolatedPass[cameraName]) {
        this._renderEffectsForIsolatedPass[cameraName]._update();
      }
    }
  }
  _reset() {
    this._renderEffects = {};
    this._renderEffectsForIsolatedPass = new Array();
  }
  _enableMSAAOnFirstPostProcess(sampleCount) {
    if (!this._engine._features.supportMSAA) {
      return false;
    }
    const effectKeys = Object.keys(this._renderEffects);
    if (effectKeys.length > 0) {
      const postProcesses = this._renderEffects[effectKeys[0]].getPostProcesses();
      if (postProcesses) {
        postProcesses[0].samples = sampleCount;
      }
    }
    return true;
  }
  setPrePassRenderer(prePassRenderer) {
    return false;
  }
  dispose() {
  }
};
__decorate([
  serialize()
], PostProcessRenderPipeline.prototype, "_name", void 0);

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipelineManager.js
var PostProcessRenderPipelineManager = class {
  constructor() {
    this._renderPipelines = {};
  }
  get supportedPipelines() {
    const result = [];
    for (const renderPipelineName in this._renderPipelines) {
      if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {
        const pipeline = this._renderPipelines[renderPipelineName];
        if (pipeline.isSupported) {
          result.push(pipeline);
        }
      }
    }
    return result;
  }
  addPipeline(renderPipeline) {
    this._renderPipelines[renderPipeline._name] = renderPipeline;
  }
  attachCamerasToRenderPipeline(renderPipelineName, cameras, unique = false) {
    const renderPipeline = this._renderPipelines[renderPipelineName];
    if (!renderPipeline) {
      return;
    }
    renderPipeline._attachCameras(cameras, unique);
  }
  detachCamerasFromRenderPipeline(renderPipelineName, cameras) {
    const renderPipeline = this._renderPipelines[renderPipelineName];
    if (!renderPipeline) {
      return;
    }
    renderPipeline._detachCameras(cameras);
  }
  enableEffectInPipeline(renderPipelineName, renderEffectName, cameras) {
    const renderPipeline = this._renderPipelines[renderPipelineName];
    if (!renderPipeline) {
      return;
    }
    renderPipeline._enableEffect(renderEffectName, cameras);
  }
  disableEffectInPipeline(renderPipelineName, renderEffectName, cameras) {
    const renderPipeline = this._renderPipelines[renderPipelineName];
    if (!renderPipeline) {
      return;
    }
    renderPipeline._disableEffect(renderEffectName, cameras);
  }
  update() {
    for (const renderPipelineName in this._renderPipelines) {
      if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {
        const pipeline = this._renderPipelines[renderPipelineName];
        if (!pipeline.isSupported) {
          pipeline.dispose();
          delete this._renderPipelines[renderPipelineName];
        } else {
          pipeline._update();
        }
      }
    }
  }
  _rebuild() {
    for (const renderPipelineName in this._renderPipelines) {
      if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {
        const pipeline = this._renderPipelines[renderPipelineName];
        pipeline._rebuild();
      }
    }
  }
  dispose() {
    for (const renderPipelineName in this._renderPipelines) {
      if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {
        const pipeline = this._renderPipelines[renderPipelineName];
        pipeline.dispose();
      }
    }
  }
};

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.js
Object.defineProperty(Scene.prototype, "postProcessRenderPipelineManager", {
  get: function() {
    if (!this._postProcessRenderPipelineManager) {
      let component = this._getComponent(SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER);
      if (!component) {
        component = new PostProcessRenderPipelineManagerSceneComponent(this);
        this._addComponent(component);
      }
      this._postProcessRenderPipelineManager = new PostProcessRenderPipelineManager();
    }
    return this._postProcessRenderPipelineManager;
  },
  enumerable: true,
  configurable: true
});
var PostProcessRenderPipelineManagerSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER;
    this.scene = scene;
  }
  register() {
    this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER, this, this._gatherRenderTargets);
  }
  rebuild() {
    if (this.scene._postProcessRenderPipelineManager) {
      this.scene._postProcessRenderPipelineManager._rebuild();
    }
  }
  dispose() {
    if (this.scene._postProcessRenderPipelineManager) {
      this.scene._postProcessRenderPipelineManager.dispose();
    }
  }
  _gatherRenderTargets() {
    if (this.scene._postProcessRenderPipelineManager) {
      this.scene._postProcessRenderPipelineManager.update();
    }
  }
};

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/defaultRenderingPipeline.js
var DefaultRenderingPipeline = class extends PostProcessRenderPipeline {
  constructor(name137 = "", hdr = true, scene = EngineStore.LastCreatedScene, cameras, automaticBuild = true) {
    super(scene.getEngine(), name137);
    this._camerasToBeAttached = [];
    this.SharpenPostProcessId = "SharpenPostProcessEffect";
    this.ImageProcessingPostProcessId = "ImageProcessingPostProcessEffect";
    this.FxaaPostProcessId = "FxaaPostProcessEffect";
    this.ChromaticAberrationPostProcessId = "ChromaticAberrationPostProcessEffect";
    this.GrainPostProcessId = "GrainPostProcessEffect";
    this._glowLayer = null;
    this.animations = [];
    this._imageProcessingConfigurationObserver = null;
    this._sharpenEnabled = false;
    this._bloomEnabled = false;
    this._depthOfFieldEnabled = false;
    this._depthOfFieldBlurLevel = DepthOfFieldEffectBlurLevel.Low;
    this._fxaaEnabled = false;
    this._imageProcessingEnabled = true;
    this._bloomScale = 0.5;
    this._chromaticAberrationEnabled = false;
    this._grainEnabled = false;
    this._buildAllowed = true;
    this.onBuildObservable = new Observable();
    this._resizeObserver = null;
    this._hardwareScaleLevel = 1;
    this._bloomKernel = 64;
    this._bloomWeight = 0.15;
    this._bloomThreshold = 0.9;
    this._samples = 1;
    this._hasCleared = false;
    this._prevPostProcess = null;
    this._prevPrevPostProcess = null;
    this._depthOfFieldSceneObserver = null;
    this._activeCameraChangedObserver = null;
    this._activeCamerasChangedObserver = null;
    this._cameras = cameras || scene.cameras;
    this._cameras = this._cameras.slice();
    this._camerasToBeAttached = this._cameras.slice();
    this._buildAllowed = automaticBuild;
    this._scene = scene;
    const caps = this._scene.getEngine().getCaps();
    this._hdr = hdr && (caps.textureHalfFloatRender || caps.textureFloatRender);
    if (this._hdr) {
      if (caps.textureHalfFloatRender) {
        this._defaultPipelineTextureType = 2;
      } else if (caps.textureFloatRender) {
        this._defaultPipelineTextureType = 1;
      }
    } else {
      this._defaultPipelineTextureType = 0;
    }
    scene.postProcessRenderPipelineManager.addPipeline(this);
    const engine = this._scene.getEngine();
    this.sharpen = new SharpenPostProcess("sharpen", 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);
    this._sharpenEffect = new PostProcessRenderEffect(engine, this.SharpenPostProcessId, () => {
      return this.sharpen;
    }, true);
    this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, true);
    this._hardwareScaleLevel = engine.getHardwareScalingLevel();
    this._resizeObserver = engine.onResizeObservable.add(() => {
      this._hardwareScaleLevel = engine.getHardwareScalingLevel();
      this.bloomKernel = this._bloomKernel;
    });
    this.bloom = new BloomEffect(this._scene, this._bloomScale, this._bloomWeight, this.bloomKernel / this._hardwareScaleLevel, this._defaultPipelineTextureType, true);
    this.chromaticAberration = new ChromaticAberrationPostProcess("ChromaticAberration", engine.getRenderWidth(), engine.getRenderHeight(), 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);
    this._chromaticAberrationEffect = new PostProcessRenderEffect(engine, this.ChromaticAberrationPostProcessId, () => {
      return this.chromaticAberration;
    }, true);
    this.grain = new GrainPostProcess("Grain", 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);
    this._grainEffect = new PostProcessRenderEffect(engine, this.GrainPostProcessId, () => {
      return this.grain;
    }, true);
    this._imageProcessingConfigurationObserver = this._scene.imageProcessingConfiguration.onUpdateParameters.add(() => {
      this.bloom._downscale._exposure = this._scene.imageProcessingConfiguration.exposure;
      if (this.imageProcessingEnabled !== this._scene.imageProcessingConfiguration.isEnabled) {
        this._imageProcessingEnabled = this._scene.imageProcessingConfiguration.isEnabled;
        this._buildPipeline();
      }
    });
    this._buildPipeline();
  }
  get automaticBuild() {
    return this._buildAllowed;
  }
  set automaticBuild(value) {
    this._buildAllowed = value;
  }
  get scene() {
    return this._scene;
  }
  set sharpenEnabled(enabled) {
    if (this._sharpenEnabled === enabled) {
      return;
    }
    this._sharpenEnabled = enabled;
    this._buildPipeline();
  }
  get sharpenEnabled() {
    return this._sharpenEnabled;
  }
  get bloomKernel() {
    return this._bloomKernel;
  }
  set bloomKernel(value) {
    this._bloomKernel = value;
    this.bloom.kernel = value / this._hardwareScaleLevel;
  }
  set bloomWeight(value) {
    if (this._bloomWeight === value) {
      return;
    }
    this.bloom.weight = value;
    this._bloomWeight = value;
  }
  get bloomWeight() {
    return this._bloomWeight;
  }
  set bloomThreshold(value) {
    if (this._bloomThreshold === value) {
      return;
    }
    this.bloom.threshold = value;
    this._bloomThreshold = value;
  }
  get bloomThreshold() {
    return this._bloomThreshold;
  }
  set bloomScale(value) {
    if (this._bloomScale === value) {
      return;
    }
    this._bloomScale = value;
    this._rebuildBloom();
    this._buildPipeline();
  }
  get bloomScale() {
    return this._bloomScale;
  }
  set bloomEnabled(enabled) {
    if (this._bloomEnabled === enabled) {
      return;
    }
    this._bloomEnabled = enabled;
    this._buildPipeline();
  }
  get bloomEnabled() {
    return this._bloomEnabled;
  }
  _rebuildBloom() {
    const oldBloom = this.bloom;
    this.bloom = new BloomEffect(this._scene, this.bloomScale, this._bloomWeight, this.bloomKernel / this._hardwareScaleLevel, this._defaultPipelineTextureType, false);
    this.bloom.threshold = oldBloom.threshold;
    for (let i = 0; i < this._cameras.length; i++) {
      oldBloom.disposeEffects(this._cameras[i]);
    }
  }
  get depthOfFieldEnabled() {
    return this._depthOfFieldEnabled;
  }
  set depthOfFieldEnabled(enabled) {
    if (this._depthOfFieldEnabled === enabled) {
      return;
    }
    this._depthOfFieldEnabled = enabled;
    this._buildPipeline();
  }
  get depthOfFieldBlurLevel() {
    return this._depthOfFieldBlurLevel;
  }
  set depthOfFieldBlurLevel(value) {
    if (this._depthOfFieldBlurLevel === value) {
      return;
    }
    this._depthOfFieldBlurLevel = value;
    const oldDof = this.depthOfField;
    this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, false);
    this.depthOfField.focalLength = oldDof.focalLength;
    this.depthOfField.focusDistance = oldDof.focusDistance;
    this.depthOfField.fStop = oldDof.fStop;
    this.depthOfField.lensSize = oldDof.lensSize;
    for (let i = 0; i < this._cameras.length; i++) {
      oldDof.disposeEffects(this._cameras[i]);
    }
    this._buildPipeline();
  }
  set fxaaEnabled(enabled) {
    if (this._fxaaEnabled === enabled) {
      return;
    }
    this._fxaaEnabled = enabled;
    this._buildPipeline();
  }
  get fxaaEnabled() {
    return this._fxaaEnabled;
  }
  set samples(sampleCount) {
    if (this._samples === sampleCount) {
      return;
    }
    this._samples = sampleCount;
    this._buildPipeline();
  }
  get samples() {
    return this._samples;
  }
  set imageProcessingEnabled(enabled) {
    if (this._imageProcessingEnabled === enabled) {
      return;
    }
    this._scene.imageProcessingConfiguration.isEnabled = enabled;
  }
  get imageProcessingEnabled() {
    return this._imageProcessingEnabled;
  }
  set glowLayerEnabled(enabled) {
    if (enabled && !this._glowLayer) {
      this._glowLayer = new GlowLayer("", this._scene);
    } else if (!enabled && this._glowLayer) {
      this._glowLayer.dispose();
      this._glowLayer = null;
    }
  }
  get glowLayerEnabled() {
    return this._glowLayer != null;
  }
  get glowLayer() {
    return this._glowLayer;
  }
  set chromaticAberrationEnabled(enabled) {
    if (this._chromaticAberrationEnabled === enabled) {
      return;
    }
    this._chromaticAberrationEnabled = enabled;
    this._buildPipeline();
  }
  get chromaticAberrationEnabled() {
    return this._chromaticAberrationEnabled;
  }
  set grainEnabled(enabled) {
    if (this._grainEnabled === enabled) {
      return;
    }
    this._grainEnabled = enabled;
    this._buildPipeline();
  }
  get grainEnabled() {
    return this._grainEnabled;
  }
  getClassName() {
    return "DefaultRenderingPipeline";
  }
  prepare() {
    const previousState = this._buildAllowed;
    this._buildAllowed = true;
    this._buildPipeline();
    this._buildAllowed = previousState;
  }
  _setAutoClearAndTextureSharing(postProcess, skipTextureSharing = false) {
    if (this._hasCleared) {
      postProcess.autoClear = false;
    } else {
      postProcess.autoClear = true;
      this._scene.autoClear = false;
      this._hasCleared = true;
    }
    if (!skipTextureSharing) {
      if (this._prevPrevPostProcess) {
        postProcess.shareOutputWith(this._prevPrevPostProcess);
      } else {
        postProcess.useOwnOutput();
      }
      if (this._prevPostProcess) {
        this._prevPrevPostProcess = this._prevPostProcess;
      }
      this._prevPostProcess = postProcess;
    }
  }
  _buildPipeline() {
    if (!this._buildAllowed) {
      return;
    }
    this._scene.autoClear = true;
    const engine = this._scene.getEngine();
    this._disposePostProcesses();
    if (this._cameras !== null) {
      this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
      this._cameras = this._camerasToBeAttached.slice();
    }
    this._reset();
    this._prevPostProcess = null;
    this._prevPrevPostProcess = null;
    this._hasCleared = false;
    if (this.depthOfFieldEnabled) {
      if (this._cameras.length > 1) {
        for (const camera of this._cameras) {
          const depthRenderer = this._scene.enableDepthRenderer(camera);
          depthRenderer.useOnlyInActiveCamera = true;
        }
        this._depthOfFieldSceneObserver = this._scene.onAfterRenderTargetsRenderObservable.add((scene) => {
          if (this._cameras.indexOf(scene.activeCamera) > -1) {
            this.depthOfField.depthTexture = scene.enableDepthRenderer(scene.activeCamera).getDepthMap();
          }
        });
      } else {
        this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);
        const depthRenderer = this._scene.enableDepthRenderer(this._cameras[0]);
        this.depthOfField.depthTexture = depthRenderer.getDepthMap();
      }
      if (!this.depthOfField._isReady()) {
        this.depthOfField._updateEffects();
      }
      this.addEffect(this.depthOfField);
      this._setAutoClearAndTextureSharing(this.depthOfField._effects[0], true);
    } else {
      this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);
    }
    if (this.bloomEnabled) {
      if (!this.bloom._isReady()) {
        this.bloom._updateEffects();
      }
      this.addEffect(this.bloom);
      this._setAutoClearAndTextureSharing(this.bloom._effects[0], true);
    }
    if (this._imageProcessingEnabled) {
      this.imageProcessing = new ImageProcessingPostProcess("imageProcessing", 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, this.scene.imageProcessingConfiguration);
      if (this._hdr) {
        this.addEffect(new PostProcessRenderEffect(engine, this.ImageProcessingPostProcessId, () => {
          return this.imageProcessing;
        }, true));
        this._setAutoClearAndTextureSharing(this.imageProcessing);
      } else {
        this._scene.imageProcessingConfiguration.applyByPostProcess = false;
      }
      if (!this._cameras || this._cameras.length === 0) {
        this._scene.imageProcessingConfiguration.applyByPostProcess = false;
      }
      if (!this.imageProcessing.getEffect()) {
        this.imageProcessing._updateParameters();
      }
    }
    if (this.sharpenEnabled) {
      if (!this.sharpen.isReady()) {
        this.sharpen.updateEffect();
      }
      this.addEffect(this._sharpenEffect);
      this._setAutoClearAndTextureSharing(this.sharpen);
    }
    if (this.grainEnabled) {
      if (!this.grain.isReady()) {
        this.grain.updateEffect();
      }
      this.addEffect(this._grainEffect);
      this._setAutoClearAndTextureSharing(this.grain);
    }
    if (this.chromaticAberrationEnabled) {
      if (!this.chromaticAberration.isReady()) {
        this.chromaticAberration.updateEffect();
      }
      this.addEffect(this._chromaticAberrationEffect);
      this._setAutoClearAndTextureSharing(this.chromaticAberration);
    }
    if (this.fxaaEnabled) {
      this.fxaa = new FxaaPostProcess("fxaa", 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);
      this.addEffect(new PostProcessRenderEffect(engine, this.FxaaPostProcessId, () => {
        return this.fxaa;
      }, true));
      this._setAutoClearAndTextureSharing(this.fxaa, true);
    }
    if (this._cameras !== null) {
      this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);
    }
    if (this._scene.activeCameras && this._scene.activeCameras.length > 1 || this._scene.activeCamera && this._cameras.indexOf(this._scene.activeCamera) === -1) {
      this._scene.autoClear = true;
    }
    if (!this._activeCameraChangedObserver) {
      this._activeCameraChangedObserver = this._scene.onActiveCameraChanged.add(() => {
        if (this._scene.activeCamera && this._cameras.indexOf(this._scene.activeCamera) === -1) {
          this._scene.autoClear = true;
        }
      });
    }
    if (!this._activeCamerasChangedObserver) {
      this._activeCamerasChangedObserver = this._scene.onActiveCamerasChanged.add(() => {
        if (this._scene.activeCameras && this._scene.activeCameras.length > 1) {
          this._scene.autoClear = true;
        }
      });
    }
    if (!this._enableMSAAOnFirstPostProcess(this.samples) && this.samples > 1) {
      Logger.Warn("MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0");
    }
    this.onBuildObservable.notifyObservers(this);
  }
  _disposePostProcesses(disposeNonRecreated = false) {
    for (let i = 0; i < this._cameras.length; i++) {
      const camera = this._cameras[i];
      if (this.imageProcessing) {
        this.imageProcessing.dispose(camera);
      }
      if (this.fxaa) {
        this.fxaa.dispose(camera);
      }
      if (disposeNonRecreated) {
        if (this.sharpen) {
          this.sharpen.dispose(camera);
        }
        if (this.depthOfField) {
          this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);
          this.depthOfField.disposeEffects(camera);
        }
        if (this.bloom) {
          this.bloom.disposeEffects(camera);
        }
        if (this.chromaticAberration) {
          this.chromaticAberration.dispose(camera);
        }
        if (this.grain) {
          this.grain.dispose(camera);
        }
        if (this._glowLayer) {
          this._glowLayer.dispose();
        }
      }
    }
    this.imageProcessing = null;
    this.fxaa = null;
    if (disposeNonRecreated) {
      this.sharpen = null;
      this._sharpenEffect = null;
      this.depthOfField = null;
      this.bloom = null;
      this.chromaticAberration = null;
      this._chromaticAberrationEffect = null;
      this.grain = null;
      this._grainEffect = null;
      this._glowLayer = null;
    }
  }
  addCamera(camera) {
    this._camerasToBeAttached.push(camera);
    this._buildPipeline();
  }
  removeCamera(camera) {
    const index = this._camerasToBeAttached.indexOf(camera);
    this._camerasToBeAttached.splice(index, 1);
    this._buildPipeline();
  }
  dispose() {
    this.onBuildObservable.clear();
    this._disposePostProcesses(true);
    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
    this._scene.autoClear = true;
    if (this._resizeObserver) {
      this._scene.getEngine().onResizeObservable.remove(this._resizeObserver);
      this._resizeObserver = null;
    }
    this._scene.onActiveCameraChanged.remove(this._activeCameraChangedObserver);
    this._scene.onActiveCamerasChanged.remove(this._activeCamerasChangedObserver);
    this._scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigurationObserver);
    super.dispose();
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "DefaultRenderingPipeline";
    return serializationObject;
  }
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new DefaultRenderingPipeline(source._name, source._name._hdr, scene), source, scene, rootUrl);
  }
};
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "sharpenEnabled", null);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "bloomKernel", null);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "_bloomWeight", void 0);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "_bloomThreshold", void 0);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "_hdr", void 0);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "bloomWeight", null);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "bloomThreshold", null);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "bloomScale", null);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "bloomEnabled", null);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "depthOfFieldEnabled", null);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "depthOfFieldBlurLevel", null);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "fxaaEnabled", null);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "samples", null);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "imageProcessingEnabled", null);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "glowLayerEnabled", null);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "chromaticAberrationEnabled", null);
__decorate([
  serialize()
], DefaultRenderingPipeline.prototype, "grainEnabled", null);
RegisterClass("BABYLON.DefaultRenderingPipeline", DefaultRenderingPipeline);

// node_modules/@babylonjs/core/Shaders/lensHighlights.fragment.js
var name96 = "lensHighlightsPixelShader";
var shader96 = `uniform sampler2D textureSampler; 
uniform float gain;
uniform float threshold;
uniform float screen_width;
uniform float screen_height;
varying vec2 vUV;
vec4 highlightColor(vec4 color) {
vec4 highlight=color;
float luminance=dot(highlight.rgb,vec3(0.2125,0.7154,0.0721));
float lum_threshold;
if (threshold>1.0) { lum_threshold=0.94+0.01*threshold; }
else { lum_threshold=0.5+0.44*threshold; }
luminance=clamp((luminance-lum_threshold)*(1.0/(1.0-lum_threshold)),0.0,1.0);
highlight*=luminance*gain;
highlight.a=1.0;
return highlight;
}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
vec4 original=texture2D(textureSampler,vUV);
if (gain==-1.0) {
gl_FragColor=vec4(0.0,0.0,0.0,1.0);
return;
}
float w=2.0/screen_width;
float h=2.0/screen_height;
float weight=1.0;
vec4 blurred=vec4(0.0,0.0,0.0,0.0);
#ifdef PENTAGON
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.84*w,0.43*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.48*w,-1.29*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.61*w,1.51*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.55*w,-0.74*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.71*w,-0.52*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.94*w,1.59*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.40*w,-1.87*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.62*w,1.16*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.09*w,0.25*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.46*w,-1.71*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.08*w,2.42*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.85*w,-1.89*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.89*w,0.16*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.29*w,1.88*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.40*w,-2.81*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.54*w,2.26*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.60*w,-0.61*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.31*w,-1.30*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.83*w,2.53*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.12*w,-2.48*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.60*w,1.11*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.99*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.50*w,-2.81*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.85*w,3.33*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.94*w,-1.92*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.27*w,-0.53*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.95*w,2.48*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.23*w,-3.04*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.17*w,2.05*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.97*w,-0.04*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.25*w,-2.00*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.31*w,3.08*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.94*w,-2.59*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.37*w,0.64*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.13*w,1.93*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.03*w,-3.65*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.60*w,3.17*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.14*w,-1.19*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.00*w,-1.19*h)));
#else
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.85*w,0.36*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.52*w,-1.14*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.46*w,1.42*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.46*w,-0.83*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.79*w,-0.42*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.11*w,1.62*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.29*w,-2.07*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.69*w,1.39*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.28*w,0.12*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.65*w,-1.69*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.08*w,2.44*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.63*w,-1.90*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.55*w,0.31*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.13*w,1.52*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.56*w,-2.61*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.38*w,2.34*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.64*w,-0.81*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.53*w,-1.21*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.06*w,2.63*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.00*w,-2.69*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.59*w,1.32*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.78*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.57*w,-2.50*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.54*w,2.93*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.39*w,-1.81*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,-0.28*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.04*w,2.25*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.02*w,-3.05*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.09*w,2.25*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.07*w,-0.25*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.44*w,-1.90*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.52*w,3.05*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.68*w,-2.61*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,0.79*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.76*w,1.46*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.05*w,-2.94*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.21*w,2.88*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.84*w,-1.30*h)));
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.98*w,-0.96*h)));
#endif
blurred/=39.0;
gl_FragColor=blurred;
}`;
ShaderStore.ShadersStore[name96] = shader96;

// node_modules/@babylonjs/core/Shaders/depthOfField.fragment.js
var name97 = "depthOfFieldPixelShader";
var shader97 = `uniform sampler2D textureSampler;
uniform sampler2D highlightsSampler;
uniform sampler2D depthSampler;
uniform sampler2D grainSampler;
uniform float grain_amount;
uniform bool blur_noise;
uniform float screen_width;
uniform float screen_height;
uniform float distortion;
uniform bool dof_enabled;
uniform float screen_distance; 
uniform float aperture;
uniform float darken;
uniform float edge_blur;
uniform bool highlights;
uniform float near;
uniform float far;
varying vec2 vUV;
#define PI 3.14159265
#define TWOPI 6.28318530
#define inverse_focal_length 0.1 
vec2 centered_screen_pos;
vec2 distorted_coords;
float radius2;
float radius;
vec2 rand(vec2 co)
{
float noise1=(fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453));
float noise2=(fract(sin(dot(co,vec2(12.9898,78.233)*2.0))*43758.5453));
return clamp(vec2(noise1,noise2),0.0,1.0);
}
vec2 getDistortedCoords(vec2 coords) {
if (distortion==0.0) { return coords; }
vec2 direction=1.0*normalize(centered_screen_pos);
vec2 dist_coords=vec2(0.5,0.5);
dist_coords.x=0.5+direction.x*radius2*1.0;
dist_coords.y=0.5+direction.y*radius2*1.0;
float dist_amount=clamp(distortion*0.23,0.0,1.0);
dist_coords=mix(coords,dist_coords,dist_amount);
return dist_coords;
}
float sampleScreen(inout vec4 color,in vec2 offset,in float weight) {
vec2 coords=distorted_coords;
float angle=rand(coords*100.0).x*TWOPI;
coords+=vec2(offset.x*cos(angle)-offset.y*sin(angle),offset.x*sin(angle)+offset.y*cos(angle));
color+=texture2D(textureSampler,coords)*weight;
return weight;
}
float getBlurLevel(float size) {
return min(3.0,ceil(size/1.0));
}
vec4 getBlurColor(float size) {
vec4 col=texture2D(textureSampler,distorted_coords);
float blur_level=getBlurLevel(size);
float w=(size/screen_width);
float h=(size/screen_height);
float total_weight=1.0;
vec2 sample_coords;
total_weight+=sampleScreen(col,vec2(-0.50*w,0.24*h),0.93);
total_weight+=sampleScreen(col,vec2(0.30*w,-0.75*h),0.90);
total_weight+=sampleScreen(col,vec2(0.36*w,0.96*h),0.87);
total_weight+=sampleScreen(col,vec2(-1.08*w,-0.55*h),0.85);
total_weight+=sampleScreen(col,vec2(1.33*w,-0.37*h),0.83);
total_weight+=sampleScreen(col,vec2(-0.82*w,1.31*h),0.80);
total_weight+=sampleScreen(col,vec2(-0.31*w,-1.67*h),0.78);
total_weight+=sampleScreen(col,vec2(1.47*w,1.11*h),0.76);
total_weight+=sampleScreen(col,vec2(-1.97*w,0.19*h),0.74);
total_weight+=sampleScreen(col,vec2(1.42*w,-1.57*h),0.72);
if (blur_level>1.0) {
total_weight+=sampleScreen(col,vec2(0.01*w,2.25*h),0.70);
total_weight+=sampleScreen(col,vec2(-1.62*w,-1.74*h),0.67);
total_weight+=sampleScreen(col,vec2(2.49*w,0.20*h),0.65);
total_weight+=sampleScreen(col,vec2(-2.07*w,1.61*h),0.63);
total_weight+=sampleScreen(col,vec2(0.46*w,-2.70*h),0.61);
total_weight+=sampleScreen(col,vec2(1.55*w,2.40*h),0.59);
total_weight+=sampleScreen(col,vec2(-2.88*w,-0.75*h),0.56);
total_weight+=sampleScreen(col,vec2(2.73*w,-1.44*h),0.54);
total_weight+=sampleScreen(col,vec2(-1.08*w,3.02*h),0.52);
total_weight+=sampleScreen(col,vec2(-1.28*w,-3.05*h),0.49);
}
if (blur_level>2.0) {
total_weight+=sampleScreen(col,vec2(3.11*w,1.43*h),0.46);
total_weight+=sampleScreen(col,vec2(-3.36*w,1.08*h),0.44);
total_weight+=sampleScreen(col,vec2(1.80*w,-3.16*h),0.41);
total_weight+=sampleScreen(col,vec2(0.83*w,3.65*h),0.38);
total_weight+=sampleScreen(col,vec2(-3.16*w,-2.19*h),0.34);
total_weight+=sampleScreen(col,vec2(3.92*w,-0.53*h),0.31);
total_weight+=sampleScreen(col,vec2(-2.59*w,3.12*h),0.26);
total_weight+=sampleScreen(col,vec2(-0.20*w,-4.15*h),0.22);
total_weight+=sampleScreen(col,vec2(3.02*w,3.00*h),0.15);
}
col/=total_weight; 
if (darken>0.0) {
col.rgb*=clamp(0.3,1.0,1.05-size*0.5*darken);
}
return col;
}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
centered_screen_pos=vec2(vUV.x-0.5,vUV.y-0.5);
radius2=centered_screen_pos.x*centered_screen_pos.x+centered_screen_pos.y*centered_screen_pos.y;
radius=sqrt(radius2);
distorted_coords=getDistortedCoords(vUV); 
vec2 texels_coords=vec2(vUV.x*screen_width,vUV.y*screen_height); 
float depth=texture2D(depthSampler,distorted_coords).r; 
float distance=near+(far-near)*depth; 
vec4 color=texture2D(textureSampler,vUV); 
float coc=abs(aperture*(screen_distance*(inverse_focal_length-1.0/distance)-1.0));
if (dof_enabled==false || coc<0.07) { coc=0.0; }
float edge_blur_amount=0.0;
if (edge_blur>0.0) {
edge_blur_amount=clamp((radius*2.0-1.0+0.15*edge_blur)*1.5,0.0,1.0)*1.3;
}
float blur_amount=max(edge_blur_amount,coc);
if (blur_amount==0.0) {
gl_FragColor=texture2D(textureSampler,distorted_coords);
}
else {
gl_FragColor=getBlurColor(blur_amount*1.7);
if (highlights) {
gl_FragColor.rgb+=clamp(coc,0.0,1.0)*texture2D(highlightsSampler,distorted_coords).rgb;
}
if (blur_noise) {
vec2 noise=rand(distorted_coords)*0.01*blur_amount;
vec2 blurred_coord=vec2(distorted_coords.x+noise.x,distorted_coords.y+noise.y);
gl_FragColor=0.04*texture2D(textureSampler,blurred_coord)+0.96*gl_FragColor;
}
}
if (grain_amount>0.0) {
vec4 grain_color=texture2D(grainSampler,texels_coords*0.003);
gl_FragColor.rgb+=(-0.5+grain_color.rgb)*0.30*grain_amount;
}
}
`;
ShaderStore.ShadersStore[name97] = shader97;

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/lensRenderingPipeline.js
var LensRenderingPipeline = class extends PostProcessRenderPipeline {
  constructor(name137, parameters, scene, ratio = 1, cameras) {
    super(scene.getEngine(), name137);
    this.LensChromaticAberrationEffect = "LensChromaticAberrationEffect";
    this.HighlightsEnhancingEffect = "HighlightsEnhancingEffect";
    this.LensDepthOfFieldEffect = "LensDepthOfFieldEffect";
    this._pentagonBokehIsEnabled = false;
    this._scene = scene;
    this._depthTexture = scene.enableDepthRenderer().getDepthMap();
    if (parameters.grain_texture) {
      this._grainTexture = parameters.grain_texture;
    } else {
      this._createGrainTexture();
    }
    this._edgeBlur = parameters.edge_blur ? parameters.edge_blur : 0;
    this._grainAmount = parameters.grain_amount ? parameters.grain_amount : 0;
    this._chromaticAberration = parameters.chromatic_aberration ? parameters.chromatic_aberration : 0;
    this._distortion = parameters.distortion ? parameters.distortion : 0;
    this._highlightsGain = parameters.dof_gain !== void 0 ? parameters.dof_gain : -1;
    this._highlightsThreshold = parameters.dof_threshold ? parameters.dof_threshold : 1;
    this._dofDistance = parameters.dof_focus_distance !== void 0 ? parameters.dof_focus_distance : -1;
    this._dofAperture = parameters.dof_aperture ? parameters.dof_aperture : 1;
    this._dofDarken = parameters.dof_darken ? parameters.dof_darken : 0;
    this._dofPentagon = parameters.dof_pentagon !== void 0 ? parameters.dof_pentagon : true;
    this._blurNoise = parameters.blur_noise !== void 0 ? parameters.blur_noise : true;
    this._createChromaticAberrationPostProcess(ratio);
    this._createHighlightsPostProcess(ratio);
    this._createDepthOfFieldPostProcess(ratio / 4);
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.LensChromaticAberrationEffect, () => {
      return this._chromaticAberrationPostProcess;
    }, true));
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.HighlightsEnhancingEffect, () => {
      return this._highlightsPostProcess;
    }, true));
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.LensDepthOfFieldEffect, () => {
      return this._depthOfFieldPostProcess;
    }, true));
    if (this._highlightsGain === -1) {
      this._disableEffect(this.HighlightsEnhancingEffect, null);
    }
    scene.postProcessRenderPipelineManager.addPipeline(this);
    if (cameras) {
      scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name137, cameras);
    }
  }
  getClassName() {
    return "LensRenderingPipeline";
  }
  get scene() {
    return this._scene;
  }
  get edgeBlur() {
    return this._edgeBlur;
  }
  set edgeBlur(value) {
    this.setEdgeBlur(value);
  }
  get grainAmount() {
    return this._grainAmount;
  }
  set grainAmount(value) {
    this.setGrainAmount(value);
  }
  get chromaticAberration() {
    return this._chromaticAberration;
  }
  set chromaticAberration(value) {
    this.setChromaticAberration(value);
  }
  get dofAperture() {
    return this._dofAperture;
  }
  set dofAperture(value) {
    this.setAperture(value);
  }
  get edgeDistortion() {
    return this._distortion;
  }
  set edgeDistortion(value) {
    this.setEdgeDistortion(value);
  }
  get dofDistortion() {
    return this._dofDistance;
  }
  set dofDistortion(value) {
    this.setFocusDistance(value);
  }
  get darkenOutOfFocus() {
    return this._dofDarken;
  }
  set darkenOutOfFocus(value) {
    this.setDarkenOutOfFocus(value);
  }
  get blurNoise() {
    return this._blurNoise;
  }
  set blurNoise(value) {
    this._blurNoise = value;
  }
  get pentagonBokeh() {
    return this._pentagonBokehIsEnabled;
  }
  set pentagonBokeh(value) {
    if (value) {
      this.enablePentagonBokeh();
    } else {
      this.disablePentagonBokeh();
    }
  }
  get highlightsGain() {
    return this._highlightsGain;
  }
  set highlightsGain(value) {
    this.setHighlightsGain(value);
  }
  get highlightsThreshold() {
    return this._highlightsThreshold;
  }
  set highlightsThreshold(value) {
    this.setHighlightsThreshold(value);
  }
  setEdgeBlur(amount) {
    this._edgeBlur = amount;
  }
  disableEdgeBlur() {
    this._edgeBlur = 0;
  }
  setGrainAmount(amount) {
    this._grainAmount = amount;
  }
  disableGrain() {
    this._grainAmount = 0;
  }
  setChromaticAberration(amount) {
    this._chromaticAberration = amount;
  }
  disableChromaticAberration() {
    this._chromaticAberration = 0;
  }
  setEdgeDistortion(amount) {
    this._distortion = amount;
  }
  disableEdgeDistortion() {
    this._distortion = 0;
  }
  setFocusDistance(amount) {
    this._dofDistance = amount;
  }
  disableDepthOfField() {
    this._dofDistance = -1;
  }
  setAperture(amount) {
    this._dofAperture = amount;
  }
  setDarkenOutOfFocus(amount) {
    this._dofDarken = amount;
  }
  enablePentagonBokeh() {
    this._highlightsPostProcess.updateEffect("#define PENTAGON\n");
    this._pentagonBokehIsEnabled = true;
  }
  disablePentagonBokeh() {
    this._pentagonBokehIsEnabled = false;
    this._highlightsPostProcess.updateEffect();
  }
  enableNoiseBlur() {
    this._blurNoise = true;
  }
  disableNoiseBlur() {
    this._blurNoise = false;
  }
  setHighlightsGain(amount) {
    this._highlightsGain = amount;
  }
  setHighlightsThreshold(amount) {
    if (this._highlightsGain === -1) {
      this._highlightsGain = 1;
    }
    this._highlightsThreshold = amount;
  }
  disableHighlights() {
    this._highlightsGain = -1;
  }
  dispose(disableDepthRender = false) {
    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);
    this._chromaticAberrationPostProcess = null;
    this._highlightsPostProcess = null;
    this._depthOfFieldPostProcess = null;
    this._grainTexture.dispose();
    if (disableDepthRender) {
      this._scene.disableDepthRenderer();
    }
  }
  _createChromaticAberrationPostProcess(ratio) {
    this._chromaticAberrationPostProcess = new PostProcess(
      "LensChromaticAberration",
      "chromaticAberration",
      ["chromatic_aberration", "screen_width", "screen_height", "direction", "radialIntensity", "centerPosition"],
      [],
      ratio,
      null,
      Texture.TRILINEAR_SAMPLINGMODE,
      this._scene.getEngine(),
      false
    );
    this._chromaticAberrationPostProcess.onApply = (effect) => {
      effect.setFloat("chromatic_aberration", this._chromaticAberration);
      effect.setFloat("screen_width", this._scene.getEngine().getRenderWidth());
      effect.setFloat("screen_height", this._scene.getEngine().getRenderHeight());
      effect.setFloat("radialIntensity", 1);
      effect.setFloat2("direction", 17, 17);
      effect.setFloat2("centerPosition", 0.5, 0.5);
    };
  }
  _createHighlightsPostProcess(ratio) {
    this._highlightsPostProcess = new PostProcess(
      "LensHighlights",
      "lensHighlights",
      ["gain", "threshold", "screen_width", "screen_height"],
      [],
      ratio,
      null,
      Texture.TRILINEAR_SAMPLINGMODE,
      this._scene.getEngine(),
      false,
      this._dofPentagon ? "#define PENTAGON\n" : ""
    );
    this._highlightsPostProcess.externalTextureSamplerBinding = true;
    this._highlightsPostProcess.onApply = (effect) => {
      effect.setFloat("gain", this._highlightsGain);
      effect.setFloat("threshold", this._highlightsThreshold);
      effect.setTextureFromPostProcess("textureSampler", this._chromaticAberrationPostProcess);
      effect.setFloat("screen_width", this._scene.getEngine().getRenderWidth());
      effect.setFloat("screen_height", this._scene.getEngine().getRenderHeight());
    };
  }
  _createDepthOfFieldPostProcess(ratio) {
    this._depthOfFieldPostProcess = new PostProcess("LensDepthOfField", "depthOfField", [
      "grain_amount",
      "blur_noise",
      "screen_width",
      "screen_height",
      "distortion",
      "dof_enabled",
      "screen_distance",
      "aperture",
      "darken",
      "edge_blur",
      "highlights",
      "near",
      "far"
    ], ["depthSampler", "grainSampler", "highlightsSampler"], ratio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);
    this._depthOfFieldPostProcess.externalTextureSamplerBinding = true;
    this._depthOfFieldPostProcess.onApply = (effect) => {
      effect.setTexture("depthSampler", this._depthTexture);
      effect.setTexture("grainSampler", this._grainTexture);
      effect.setTextureFromPostProcess("textureSampler", this._highlightsPostProcess);
      effect.setTextureFromPostProcess("highlightsSampler", this._depthOfFieldPostProcess);
      effect.setFloat("grain_amount", this._grainAmount);
      effect.setBool("blur_noise", this._blurNoise);
      effect.setFloat("screen_width", this._scene.getEngine().getRenderWidth());
      effect.setFloat("screen_height", this._scene.getEngine().getRenderHeight());
      effect.setFloat("distortion", this._distortion);
      effect.setBool("dof_enabled", this._dofDistance !== -1);
      effect.setFloat("screen_distance", 1 / (0.1 - 1 / this._dofDistance));
      effect.setFloat("aperture", this._dofAperture);
      effect.setFloat("darken", this._dofDarken);
      effect.setFloat("edge_blur", this._edgeBlur);
      effect.setBool("highlights", this._highlightsGain !== -1);
      if (this._scene.activeCamera) {
        effect.setFloat("near", this._scene.activeCamera.minZ);
        effect.setFloat("far", this._scene.activeCamera.maxZ);
      }
    };
  }
  _createGrainTexture() {
    const size = 512;
    this._grainTexture = new DynamicTexture("LensNoiseTexture", size, this._scene, false, Texture.BILINEAR_SAMPLINGMODE);
    this._grainTexture.wrapU = Texture.WRAP_ADDRESSMODE;
    this._grainTexture.wrapV = Texture.WRAP_ADDRESSMODE;
    const context = this._grainTexture.getContext();
    const rand = (min, max) => {
      return Math.random() * (max - min) + min;
    };
    let value;
    for (let x = 0; x < size; x++) {
      for (let y = 0; y < size; y++) {
        value = Math.floor(rand(0.42, 0.58) * 255);
        context.fillStyle = "rgb(" + value + ", " + value + ", " + value + ")";
        context.fillRect(x, y, 1, 1);
      }
    }
    this._grainTexture.update(false);
  }
};

// node_modules/@babylonjs/core/Rendering/ssao2Configuration.js
var SSAO2Configuration = class {
  constructor() {
    this.enabled = false;
    this.name = "ssao2";
    this.texturesRequired = [6, 5];
  }
};

// node_modules/@babylonjs/core/Shaders/ssao2.fragment.js
var name98 = "ssao2PixelShader";
var shader98 = `precision highp float;
uniform sampler2D textureSampler;
uniform float near;
uniform float far;
uniform float radius;
float scales[16]=float[16](
0.1,
0.11406250000000001,
0.131640625,
0.15625,
0.187890625,
0.2265625,
0.272265625,
0.325,
0.384765625,
0.4515625,
0.525390625,
0.60625,
0.694140625,
0.7890625,
0.891015625,
1.0
);
varying vec2 vUV;
float perspectiveDepthToViewZ(in float invClipZ,in float near,in float far ) {
return ( near*far )/( ( far-near )*invClipZ-far );
}
float viewZToPerspectiveDepth( in float viewZ,in float near,in float far ) {
return ( near*far/viewZ+far)/( far-near );
}
float viewZToOrthographicDepth( in float viewZ,in float near,in float far ) {
return ( viewZ+near )/( near-far );
}
#ifdef SSAO
uniform sampler2D randomSampler;
uniform sampler2D depthSampler;
uniform sampler2D normalSampler;
uniform float randTextureTiles;
uniform float samplesFactor;
uniform vec3 sampleSphere[SAMPLES];
uniform float totalStrength;
uniform float base;
uniform float xViewport;
uniform float yViewport;
uniform mat3 depthProjection;
uniform float maxZ;
uniform float minZAspect;
uniform vec2 texelSize;
uniform mat4 projection;
void main()
{
vec3 random=texture2D(randomSampler,vUV*randTextureTiles).rgb;
float depth=texture2D(depthSampler,vUV).r;
float depthSign=depth/abs(depth);
depth=depth*depthSign;
vec3 normal=texture2D(normalSampler,vUV).rgb;
float occlusion=0.0;
float correctedRadius=min(radius,minZAspect*depth/near);
vec3 vViewRay=vec3((vUV.x*2.0-1.0)*xViewport,(vUV.y*2.0-1.0)*yViewport,depthSign);
vec3 vDepthFactor=depthProjection*vec3(1.0,1.0,depth);
vec3 origin=vViewRay*vDepthFactor;
vec3 rvec=random*2.0-1.0;
rvec.z=0.0;
float dotProduct=dot(rvec,normal);
rvec=1.0-abs(dotProduct)>1e-2 ? rvec : vec3(-rvec.y,0.0,rvec.x);
vec3 tangent=normalize(rvec-normal*dot(rvec,normal));
vec3 bitangent=cross(normal,tangent);
mat3 tbn=mat3(tangent,bitangent,normal);
float difference;
for (int i=0; i<SAMPLES; ++i) {
vec3 samplePosition=scales[(i+int(random.x*16.0)) % 16]*tbn*sampleSphere[(i+int(random.y*16.0)) % 16];
samplePosition=samplePosition*correctedRadius+origin;
vec4 offset=vec4(samplePosition,1.0);
offset=projection*offset;
offset.xyz/=offset.w;
offset.xy=offset.xy*0.5+0.5;
if (offset.x<0.0 || offset.y<0.0 || offset.x>1.0 || offset.y>1.0) {
continue;
}
float sampleDepth=abs(texture2D(depthSampler,offset.xy).r);
difference=depthSign*samplePosition.z-sampleDepth;
float rangeCheck=1.0-smoothstep(correctedRadius*0.5,correctedRadius,difference);
occlusion+=(difference>=0.0 ? 1.0 : 0.0)*rangeCheck;
}
occlusion=occlusion*(1.0-smoothstep(maxZ*0.75,maxZ,depth));
float ao=1.0-totalStrength*occlusion*samplesFactor;
float result=clamp(ao+base,0.0,1.0);
gl_FragColor=vec4(vec3(result),1.0);
}
#endif
#ifdef BILATERAL_BLUR
uniform sampler2D depthSampler;
uniform float outSize;
uniform float samplerOffsets[SAMPLES];
vec4 blur9(sampler2D image,vec2 uv,float resolution,vec2 direction) {
vec4 color=vec4(0.0);
vec2 off1=vec2(1.3846153846)*direction;
vec2 off2=vec2(3.2307692308)*direction;
color+=texture2D(image,uv)*0.2270270270;
color+=texture2D(image,uv+(off1/resolution))*0.3162162162;
color+=texture2D(image,uv-(off1/resolution))*0.3162162162;
color+=texture2D(image,uv+(off2/resolution))*0.0702702703;
color+=texture2D(image,uv-(off2/resolution))*0.0702702703;
return color;
}
vec4 blur13(sampler2D image,vec2 uv,float resolution,vec2 direction) {
vec4 color=vec4(0.0);
vec2 off1=vec2(1.411764705882353)*direction;
vec2 off2=vec2(3.2941176470588234)*direction;
vec2 off3=vec2(5.176470588235294)*direction;
color+=texture2D(image,uv)*0.1964825501511404;
color+=texture2D(image,uv+(off1/resolution))*0.2969069646728344;
color+=texture2D(image,uv-(off1/resolution))*0.2969069646728344;
color+=texture2D(image,uv+(off2/resolution))*0.09447039785044732;
color+=texture2D(image,uv-(off2/resolution))*0.09447039785044732;
color+=texture2D(image,uv+(off3/resolution))*0.010381362401148057;
color+=texture2D(image,uv-(off3/resolution))*0.010381362401148057;
return color;
}
vec4 blur13Bilateral(sampler2D image,vec2 uv,float resolution,vec2 direction) {
vec4 color=vec4(0.0);
vec2 off1=vec2(1.411764705882353)*direction;
vec2 off2=vec2(3.2941176470588234)*direction;
vec2 off3=vec2(5.176470588235294)*direction;
float compareDepth=abs(texture2D(depthSampler,uv).r);
float sampleDepth;
float weight;
float weightSum=30.0;
color+=texture2D(image,uv)*30.0;
sampleDepth=abs(texture2D(depthSampler,uv+(off1/resolution)).r);
weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);
weightSum+= weight;
color+=texture2D(image,uv+(off1/resolution))*weight;
sampleDepth=abs(texture2D(depthSampler,uv-(off1/resolution)).r);
weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);
weightSum+= weight;
color+=texture2D(image,uv-(off1/resolution))*weight;
sampleDepth=abs(texture2D(depthSampler,uv+(off2/resolution)).r);
weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);
weightSum+=weight;
color+=texture2D(image,uv+(off2/resolution))*weight;
sampleDepth=abs(texture2D(depthSampler,uv-(off2/resolution)).r);
weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);
weightSum+=weight;
color+=texture2D(image,uv-(off2/resolution))*weight;
sampleDepth=abs(texture2D(depthSampler,uv+(off3/resolution)).r);
weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);
weightSum+=weight;
color+=texture2D(image,uv+(off3/resolution))*weight;
sampleDepth=abs(texture2D(depthSampler,uv-(off3/resolution)).r);
weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);
weightSum+=weight;
color+=texture2D(image,uv-(off3/resolution))*weight;
return color/weightSum;
}
void main()
{
#if EXPENSIVE
float compareDepth=abs(texture2D(depthSampler,vUV).r);
float texelsize=1.0/outSize;
float result=0.0;
float weightSum=0.0;
for (int i=0; i<SAMPLES; ++i)
{
#ifdef BILATERAL_BLUR_H
vec2 direction=vec2(1.0,0.0);
vec2 sampleOffset=vec2(texelsize*samplerOffsets[i],0.0);
#else
vec2 direction=vec2(0.0,1.0);
vec2 sampleOffset=vec2(0.0,texelsize*samplerOffsets[i]);
#endif
vec2 samplePos=vUV+sampleOffset;
float sampleDepth=abs(texture2D(depthSampler,samplePos).r);
float weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30000.0);
result+=texture2D(textureSampler,samplePos).r*weight;
weightSum+=weight;
}
result/=weightSum;
gl_FragColor.rgb=vec3(result);
gl_FragColor.a=1.0;
#else
vec4 color;
#ifdef BILATERAL_BLUR_H
vec2 direction=vec2(1.0,0.0);
color=blur13Bilateral(textureSampler,vUV,outSize,direction);
#else
vec2 direction=vec2(0.0,1.0);
color=blur13Bilateral(textureSampler,vUV,outSize,direction);
#endif
gl_FragColor.rgb=vec3(color.r);
gl_FragColor.a=1.0;
#endif
}
#endif
`;
ShaderStore.ShadersStore[name98] = shader98;

// node_modules/@babylonjs/core/Shaders/ssaoCombine.fragment.js
var name99 = "ssaoCombinePixelShader";
var shader99 = `uniform sampler2D textureSampler;
uniform sampler2D originalColor;
uniform vec4 viewport;
varying vec2 vUV;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec4 ssaoColor=texture2D(textureSampler,viewport.xy+vUV*viewport.zw);
vec4 sceneColor=texture2D(originalColor,vUV);
gl_FragColor=sceneColor*ssaoColor;
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
ShaderStore.ShadersStore[name99] = shader99;

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssao2RenderingPipeline.js
var SSAO2RenderingPipeline = class extends PostProcessRenderPipeline {
  constructor(name137, scene, ratio, cameras, forceGeometryBuffer = false, textureType = 0) {
    super(scene.getEngine(), name137);
    this.SSAOOriginalSceneColorEffect = "SSAOOriginalSceneColorEffect";
    this.SSAORenderEffect = "SSAORenderEffect";
    this.SSAOBlurHRenderEffect = "SSAOBlurHRenderEffect";
    this.SSAOBlurVRenderEffect = "SSAOBlurVRenderEffect";
    this.SSAOCombineRenderEffect = "SSAOCombineRenderEffect";
    this.totalStrength = 1;
    this.maxZ = 100;
    this.minZAspect = 0.2;
    this._samples = 8;
    this._textureSamples = 1;
    this._forceGeometryBuffer = false;
    this._expensiveBlur = true;
    this.radius = 2;
    this.base = 0;
    this._bits = new Uint32Array(1);
    this._scene = scene;
    this._ratio = ratio;
    this._forceGeometryBuffer = forceGeometryBuffer;
    if (!this.isSupported) {
      Logger.Error("The current engine does not support SSAO 2.");
      return;
    }
    const ssaoRatio = this._ratio.ssaoRatio || ratio;
    const blurRatio = this._ratio.blurRatio || ratio;
    if (this._forceGeometryBuffer) {
      scene.enableGeometryBufferRenderer();
    } else {
      scene.enablePrePassRenderer();
    }
    this._createRandomTexture();
    this._originalColorPostProcess = new PassPostProcess("SSAOOriginalSceneColor", 1, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), void 0, textureType);
    this._originalColorPostProcess.samples = this.textureSamples;
    this._createSSAOPostProcess(1, textureType);
    this._createBlurPostProcess(ssaoRatio, blurRatio, textureType);
    this._createSSAOCombinePostProcess(blurRatio, textureType);
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOOriginalSceneColorEffect, () => {
      return this._originalColorPostProcess;
    }, true));
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAORenderEffect, () => {
      return this._ssaoPostProcess;
    }, true));
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOBlurHRenderEffect, () => {
      return this._blurHPostProcess;
    }, true));
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOBlurVRenderEffect, () => {
      return this._blurVPostProcess;
    }, true));
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOCombineRenderEffect, () => {
      return this._ssaoCombinePostProcess;
    }, true));
    scene.postProcessRenderPipelineManager.addPipeline(this);
    if (cameras) {
      scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name137, cameras);
    }
  }
  set samples(n) {
    this._samples = n;
    this._ssaoPostProcess.updateEffect(this._getDefinesForSSAO());
    this._sampleSphere = this._generateHemisphere();
  }
  get samples() {
    return this._samples;
  }
  set textureSamples(n) {
    this._textureSamples = n;
    if (this._prePassRenderer) {
      this._prePassRenderer.samples = n;
    } else {
      this._originalColorPostProcess.samples = n;
    }
  }
  get textureSamples() {
    return this._textureSamples;
  }
  get _geometryBufferRenderer() {
    if (!this._forceGeometryBuffer) {
      return null;
    }
    return this._scene.geometryBufferRenderer;
  }
  get _prePassRenderer() {
    if (this._forceGeometryBuffer) {
      return null;
    }
    return this._scene.prePassRenderer;
  }
  set expensiveBlur(b) {
    this._blurHPostProcess.updateEffect("#define BILATERAL_BLUR\n#define BILATERAL_BLUR_H\n#define SAMPLES 16\n#define EXPENSIVE " + (b ? "1" : "0") + "\n", null, [
      "textureSampler",
      "depthSampler"
    ]);
    this._blurVPostProcess.updateEffect("#define BILATERAL_BLUR\n#define SAMPLES 16\n#define EXPENSIVE " + (b ? "1" : "0") + "\n", null, ["textureSampler", "depthSampler"]);
    this._expensiveBlur = b;
  }
  get expensiveBlur() {
    return this._expensiveBlur;
  }
  static get IsSupported() {
    const engine = EngineStore.LastCreatedEngine;
    if (!engine) {
      return false;
    }
    return engine._features.supportSSAO2;
  }
  get scene() {
    return this._scene;
  }
  getClassName() {
    return "SSAO2RenderingPipeline";
  }
  dispose(disableGeometryBufferRenderer = false) {
    for (let i = 0; i < this._scene.cameras.length; i++) {
      const camera = this._scene.cameras[i];
      this._originalColorPostProcess.dispose(camera);
      this._ssaoPostProcess.dispose(camera);
      this._blurHPostProcess.dispose(camera);
      this._blurVPostProcess.dispose(camera);
      this._ssaoCombinePostProcess.dispose(camera);
    }
    this._randomTexture.dispose();
    if (disableGeometryBufferRenderer) {
      this._scene.disableGeometryBufferRenderer();
    }
    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);
    super.dispose();
  }
  _createBlurPostProcess(ssaoRatio, blurRatio, textureType) {
    this._samplerOffsets = [];
    const expensive = this.expensiveBlur;
    for (let i = -8; i < 8; i++) {
      this._samplerOffsets.push(i * 2 + 0.5);
    }
    this._blurHPostProcess = new PostProcess("BlurH", "ssao2", ["outSize", "samplerOffsets", "near", "far", "radius"], ["depthSampler"], ssaoRatio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, "#define BILATERAL_BLUR\n#define BILATERAL_BLUR_H\n#define SAMPLES 16\n#define EXPENSIVE " + (expensive ? "1" : "0") + "\n", textureType);
    this._blurHPostProcess.onApply = (effect) => {
      if (!this._scene.activeCamera) {
        return;
      }
      effect.setFloat("outSize", this._ssaoCombinePostProcess.width > 0 ? this._ssaoCombinePostProcess.width : this._originalColorPostProcess.width);
      effect.setFloat("near", this._scene.activeCamera.minZ);
      effect.setFloat("far", this._scene.activeCamera.maxZ);
      effect.setFloat("radius", this.radius);
      if (this._geometryBufferRenderer) {
        effect.setTexture("depthSampler", this._geometryBufferRenderer.getGBuffer().textures[0]);
      } else if (this._prePassRenderer) {
        effect.setTexture("depthSampler", this._prePassRenderer.getRenderTarget().textures[this._prePassRenderer.getIndex(5)]);
      }
      effect.setArray("samplerOffsets", this._samplerOffsets);
    };
    this._blurVPostProcess = new PostProcess("BlurV", "ssao2", ["outSize", "samplerOffsets", "near", "far", "radius"], ["depthSampler"], blurRatio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, "#define BILATERAL_BLUR\n#define BILATERAL_BLUR_V\n#define SAMPLES 16\n#define EXPENSIVE " + (expensive ? "1" : "0") + "\n", textureType);
    this._blurVPostProcess.onApply = (effect) => {
      if (!this._scene.activeCamera) {
        return;
      }
      effect.setFloat("outSize", this._ssaoCombinePostProcess.height > 0 ? this._ssaoCombinePostProcess.height : this._originalColorPostProcess.height);
      effect.setFloat("near", this._scene.activeCamera.minZ);
      effect.setFloat("far", this._scene.activeCamera.maxZ);
      effect.setFloat("radius", this.radius);
      if (this._geometryBufferRenderer) {
        effect.setTexture("depthSampler", this._geometryBufferRenderer.getGBuffer().textures[0]);
      } else if (this._prePassRenderer) {
        effect.setTexture("depthSampler", this._prePassRenderer.getRenderTarget().textures[this._prePassRenderer.getIndex(5)]);
      }
      effect.setArray("samplerOffsets", this._samplerOffsets);
    };
    this._blurHPostProcess.samples = this.textureSamples;
    this._blurVPostProcess.samples = this.textureSamples;
  }
  _rebuild() {
    super._rebuild();
  }
  _radicalInverse_VdC(i) {
    this._bits[0] = i;
    this._bits[0] = (this._bits[0] << 16 | this._bits[0] >> 16) >>> 0;
    this._bits[0] = (this._bits[0] & 1431655765) << 1 | (this._bits[0] & 2863311530) >>> 1 >>> 0;
    this._bits[0] = (this._bits[0] & 858993459) << 2 | (this._bits[0] & 3435973836) >>> 2 >>> 0;
    this._bits[0] = (this._bits[0] & 252645135) << 4 | (this._bits[0] & 4042322160) >>> 4 >>> 0;
    this._bits[0] = (this._bits[0] & 16711935) << 8 | (this._bits[0] & 4278255360) >>> 8 >>> 0;
    return this._bits[0] * 23283064365386963e-26;
  }
  _hammersley(i, n) {
    return [i / n, this._radicalInverse_VdC(i)];
  }
  _hemisphereSample_uniform(u, v) {
    const phi = v * 2 * Math.PI;
    const cosTheta = 1 - u * 0.85;
    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
    return new Vector3(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta);
  }
  _generateHemisphere() {
    const numSamples = this.samples;
    const result = [];
    let vector;
    let i = 0;
    while (i < numSamples) {
      if (numSamples < 16) {
        vector = this._hemisphereSample_uniform(Math.random(), Math.random());
      } else {
        const rand = this._hammersley(i, numSamples);
        vector = this._hemisphereSample_uniform(rand[0], rand[1]);
      }
      result.push(vector.x, vector.y, vector.z);
      i++;
    }
    return result;
  }
  _getDefinesForSSAO() {
    const defines = "#define SAMPLES " + this.samples + "\n#define SSAO";
    return defines;
  }
  _createSSAOPostProcess(ratio, textureType) {
    this._sampleSphere = this._generateHemisphere();
    const defines = this._getDefinesForSSAO();
    const samplers = ["randomSampler", "depthSampler", "normalSampler"];
    this._ssaoPostProcess = new PostProcess("ssao2", "ssao2", [
      "sampleSphere",
      "samplesFactor",
      "randTextureTiles",
      "totalStrength",
      "radius",
      "base",
      "range",
      "projection",
      "near",
      "far",
      "texelSize",
      "xViewport",
      "yViewport",
      "maxZ",
      "minZAspect",
      "depthProjection"
    ], samplers, ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, defines, textureType);
    this._ssaoPostProcess.onApply = (effect) => {
      var _a, _b, _c, _d;
      if (!this._scene.activeCamera) {
        return;
      }
      effect.setArray3("sampleSphere", this._sampleSphere);
      effect.setFloat("randTextureTiles", 32);
      effect.setFloat("samplesFactor", 1 / this.samples);
      effect.setFloat("totalStrength", this.totalStrength);
      effect.setFloat2("texelSize", 1 / this._ssaoPostProcess.width, 1 / this._ssaoPostProcess.height);
      effect.setFloat("radius", this.radius);
      effect.setFloat("maxZ", this.maxZ);
      effect.setFloat("minZAspect", this.minZAspect);
      effect.setFloat("base", this.base);
      effect.setFloat("near", this._scene.activeCamera.minZ);
      effect.setFloat("far", this._scene.activeCamera.maxZ);
      if (this._scene.activeCamera.mode === Camera.PERSPECTIVE_CAMERA) {
        effect.setMatrix3x3("depthProjection", SSAO2RenderingPipeline.PERSPECTIVE_DEPTH_PROJECTION);
        effect.setFloat("xViewport", Math.tan(this._scene.activeCamera.fov / 2) * this._scene.getEngine().getAspectRatio(this._scene.activeCamera, true));
        effect.setFloat("yViewport", Math.tan(this._scene.activeCamera.fov / 2));
      } else {
        const halfWidth = this._scene.getEngine().getRenderWidth() / 2;
        const halfHeight = this._scene.getEngine().getRenderHeight() / 2;
        const orthoLeft = (_a = this._scene.activeCamera.orthoLeft) !== null && _a !== void 0 ? _a : -halfWidth;
        const orthoRight = (_b = this._scene.activeCamera.orthoRight) !== null && _b !== void 0 ? _b : halfWidth;
        const orthoBottom = (_c = this._scene.activeCamera.orthoBottom) !== null && _c !== void 0 ? _c : -halfHeight;
        const orthoTop = (_d = this._scene.activeCamera.orthoTop) !== null && _d !== void 0 ? _d : halfHeight;
        effect.setMatrix3x3("depthProjection", SSAO2RenderingPipeline.ORTHO_DEPTH_PROJECTION);
        effect.setFloat("xViewport", (orthoRight - orthoLeft) * 0.5);
        effect.setFloat("yViewport", (orthoTop - orthoBottom) * 0.5);
      }
      effect.setMatrix("projection", this._scene.getProjectionMatrix());
      if (this._geometryBufferRenderer) {
        effect.setTexture("depthSampler", this._geometryBufferRenderer.getGBuffer().textures[0]);
        effect.setTexture("normalSampler", this._geometryBufferRenderer.getGBuffer().textures[1]);
      } else if (this._prePassRenderer) {
        effect.setTexture("depthSampler", this._prePassRenderer.getRenderTarget().textures[this._prePassRenderer.getIndex(5)]);
        effect.setTexture("normalSampler", this._prePassRenderer.getRenderTarget().textures[this._prePassRenderer.getIndex(6)]);
      }
      effect.setTexture("randomSampler", this._randomTexture);
    };
    this._ssaoPostProcess.samples = this.textureSamples;
    if (!this._forceGeometryBuffer) {
      this._ssaoPostProcess._prePassEffectConfiguration = new SSAO2Configuration();
    }
  }
  _createSSAOCombinePostProcess(ratio, textureType) {
    this._ssaoCombinePostProcess = new PostProcess("ssaoCombine", "ssaoCombine", [], ["originalColor", "viewport"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, void 0, textureType);
    this._ssaoCombinePostProcess.onApply = (effect) => {
      const viewport = this._scene.activeCamera.viewport;
      effect.setVector4("viewport", TmpVectors.Vector4[0].copyFromFloats(viewport.x, viewport.y, viewport.width, viewport.height));
      effect.setTextureFromPostProcessOutput("originalColor", this._originalColorPostProcess);
    };
    this._ssaoCombinePostProcess.samples = this.textureSamples;
  }
  _createRandomTexture() {
    const size = 128;
    this._randomTexture = new DynamicTexture("SSAORandomTexture", size, this._scene, false, Texture.TRILINEAR_SAMPLINGMODE);
    this._randomTexture.wrapU = Texture.WRAP_ADDRESSMODE;
    this._randomTexture.wrapV = Texture.WRAP_ADDRESSMODE;
    const context = this._randomTexture.getContext();
    const rand = (min, max) => {
      return Math.random() * (max - min) + min;
    };
    const randVector = Vector3.Zero();
    for (let x = 0; x < size; x++) {
      for (let y = 0; y < size; y++) {
        randVector.x = rand(0, 1);
        randVector.y = rand(0, 1);
        randVector.z = 0;
        randVector.normalize();
        randVector.scaleInPlace(255);
        randVector.x = Math.floor(randVector.x);
        randVector.y = Math.floor(randVector.y);
        context.fillStyle = "rgb(" + randVector.x + ", " + randVector.y + ", " + randVector.z + ")";
        context.fillRect(x, y, 1, 1);
      }
    }
    this._randomTexture.update(false);
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "SSAO2RenderingPipeline";
    return serializationObject;
  }
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new SSAO2RenderingPipeline(source._name, scene, source._ratio), source, scene, rootUrl);
  }
};
SSAO2RenderingPipeline.ORTHO_DEPTH_PROJECTION = [1, 0, 0, 0, 1, 0, 0, 0, 1];
SSAO2RenderingPipeline.PERSPECTIVE_DEPTH_PROJECTION = [0, 0, 0, 0, 0, 0, 1, 1, 1];
__decorate([
  serialize()
], SSAO2RenderingPipeline.prototype, "totalStrength", void 0);
__decorate([
  serialize()
], SSAO2RenderingPipeline.prototype, "maxZ", void 0);
__decorate([
  serialize()
], SSAO2RenderingPipeline.prototype, "minZAspect", void 0);
__decorate([
  serialize("samples")
], SSAO2RenderingPipeline.prototype, "_samples", void 0);
__decorate([
  serialize("textureSamples")
], SSAO2RenderingPipeline.prototype, "_textureSamples", void 0);
__decorate([
  serialize()
], SSAO2RenderingPipeline.prototype, "_ratio", void 0);
__decorate([
  serialize("expensiveBlur")
], SSAO2RenderingPipeline.prototype, "_expensiveBlur", void 0);
__decorate([
  serialize()
], SSAO2RenderingPipeline.prototype, "radius", void 0);
__decorate([
  serialize()
], SSAO2RenderingPipeline.prototype, "base", void 0);
RegisterClass("BABYLON.SSAO2RenderingPipeline", SSAO2RenderingPipeline);

// node_modules/@babylonjs/core/Shaders/ssao.fragment.js
var name100 = "ssaoPixelShader";
var shader100 = `uniform sampler2D textureSampler;
varying vec2 vUV;
#ifdef SSAO
uniform sampler2D randomSampler;
uniform float randTextureTiles;
uniform float samplesFactor;
uniform vec3 sampleSphere[SAMPLES];
uniform float totalStrength;
uniform float radius;
uniform float area;
uniform float fallOff;
uniform float base;
vec3 normalFromDepth(float depth,vec2 coords)
{
vec2 offset1=vec2(0.0,radius);
vec2 offset2=vec2(radius,0.0);
float depth1=texture2D(textureSampler,coords+offset1).r;
float depth2=texture2D(textureSampler,coords+offset2).r;
vec3 p1=vec3(offset1,depth1-depth);
vec3 p2=vec3(offset2,depth2-depth);
vec3 normal=cross(p1,p2);
normal.z=-normal.z;
return normalize(normal);
}
void main()
{
vec3 random=normalize(texture2D(randomSampler,vUV*randTextureTiles).rgb);
float depth=texture2D(textureSampler,vUV).r;
vec3 position=vec3(vUV,depth);
vec3 normal=normalFromDepth(depth,vUV);
float radiusDepth=radius/depth;
float occlusion=0.0;
vec3 ray;
vec3 hemiRay;
float occlusionDepth;
float difference;
for (int i=0; i<SAMPLES; i++)
{
ray=radiusDepth*reflect(sampleSphere[i],random);
hemiRay=position+sign(dot(ray,normal))*ray;
occlusionDepth=texture2D(textureSampler,clamp(hemiRay.xy,vec2(0.001,0.001),vec2(0.999,0.999))).r;
difference=depth-occlusionDepth;
occlusion+=step(fallOff,difference)*(1.0-smoothstep(fallOff,area,difference));
}
float ao=1.0-totalStrength*occlusion*samplesFactor;
float result=clamp(ao+base,0.0,1.0);
gl_FragColor.r=result;
gl_FragColor.g=result;
gl_FragColor.b=result;
gl_FragColor.a=1.0;
}
#endif
`;
ShaderStore.ShadersStore[name100] = shader100;

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssaoRenderingPipeline.js
var SSAORenderingPipeline = class extends PostProcessRenderPipeline {
  constructor(name137, scene, ratio, cameras) {
    super(scene.getEngine(), name137);
    this.SSAOOriginalSceneColorEffect = "SSAOOriginalSceneColorEffect";
    this.SSAORenderEffect = "SSAORenderEffect";
    this.SSAOBlurHRenderEffect = "SSAOBlurHRenderEffect";
    this.SSAOBlurVRenderEffect = "SSAOBlurVRenderEffect";
    this.SSAOCombineRenderEffect = "SSAOCombineRenderEffect";
    this.totalStrength = 1;
    this.radius = 1e-4;
    this.area = 75e-4;
    this.fallOff = 1e-6;
    this.base = 0.5;
    this._firstUpdate = true;
    this._scene = scene;
    this._createRandomTexture();
    const ssaoRatio = ratio.ssaoRatio || ratio;
    const combineRatio = ratio.combineRatio || ratio;
    this._originalColorPostProcess = new PassPostProcess("SSAOOriginalSceneColor", combineRatio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false);
    this._createSSAOPostProcess(ssaoRatio);
    this._createBlurPostProcess(ssaoRatio);
    this._createSSAOCombinePostProcess(combineRatio);
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOOriginalSceneColorEffect, () => {
      return this._originalColorPostProcess;
    }, true));
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAORenderEffect, () => {
      return this._ssaoPostProcess;
    }, true));
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOBlurHRenderEffect, () => {
      return this._blurHPostProcess;
    }, true));
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOBlurVRenderEffect, () => {
      return this._blurVPostProcess;
    }, true));
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOCombineRenderEffect, () => {
      return this._ssaoCombinePostProcess;
    }, true));
    scene.postProcessRenderPipelineManager.addPipeline(this);
    if (cameras) {
      scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name137, cameras);
    }
  }
  get scene() {
    return this._scene;
  }
  _attachCameras(cameras, unique) {
    super._attachCameras(cameras, unique);
    for (const camera of this._cameras) {
      this._scene.enableDepthRenderer(camera).getDepthMap();
    }
  }
  getClassName() {
    return "SSAORenderingPipeline";
  }
  dispose(disableDepthRender = false) {
    for (let i = 0; i < this._scene.cameras.length; i++) {
      const camera = this._scene.cameras[i];
      this._originalColorPostProcess.dispose(camera);
      this._ssaoPostProcess.dispose(camera);
      this._blurHPostProcess.dispose(camera);
      this._blurVPostProcess.dispose(camera);
      this._ssaoCombinePostProcess.dispose(camera);
    }
    this._randomTexture.dispose();
    if (disableDepthRender) {
      this._scene.disableDepthRenderer();
    }
    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);
    super.dispose();
  }
  _createBlurPostProcess(ratio) {
    const size = 16;
    this._blurHPostProcess = new BlurPostProcess("BlurH", new Vector2(1, 0), size, ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, 0);
    this._blurVPostProcess = new BlurPostProcess("BlurV", new Vector2(0, 1), size, ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, 0);
    this._blurHPostProcess.onActivateObservable.add(() => {
      const dw = this._blurHPostProcess.width / this._scene.getEngine().getRenderWidth();
      this._blurHPostProcess.kernel = size * dw;
    });
    this._blurVPostProcess.onActivateObservable.add(() => {
      const dw = this._blurVPostProcess.height / this._scene.getEngine().getRenderHeight();
      this._blurVPostProcess.kernel = size * dw;
    });
  }
  _rebuild() {
    this._firstUpdate = true;
    super._rebuild();
  }
  _createSSAOPostProcess(ratio) {
    const numSamples = 16;
    const sampleSphere = [
      0.5381,
      0.1856,
      -0.4319,
      0.1379,
      0.2486,
      0.443,
      0.3371,
      0.5679,
      -57e-4,
      -0.6999,
      -0.0451,
      -19e-4,
      0.0689,
      -0.1598,
      -0.8547,
      0.056,
      69e-4,
      -0.1843,
      -0.0146,
      0.1402,
      0.0762,
      0.01,
      -0.1924,
      -0.0344,
      -0.3577,
      -0.5301,
      -0.4358,
      -0.3169,
      0.1063,
      0.0158,
      0.0103,
      -0.5869,
      46e-4,
      -0.0897,
      -0.494,
      0.3287,
      0.7119,
      -0.0154,
      -0.0918,
      -0.0533,
      0.0596,
      -0.5411,
      0.0352,
      -0.0631,
      0.546,
      -0.4776,
      0.2847,
      -0.0271
    ];
    const samplesFactor = 1 / numSamples;
    this._ssaoPostProcess = new PostProcess("ssao", "ssao", ["sampleSphere", "samplesFactor", "randTextureTiles", "totalStrength", "radius", "area", "fallOff", "base", "range", "viewport"], ["randomSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, "#define SAMPLES " + numSamples + "\n#define SSAO");
    this._ssaoPostProcess.externalTextureSamplerBinding = true;
    this._ssaoPostProcess.onApply = (effect) => {
      if (this._firstUpdate) {
        effect.setArray3("sampleSphere", sampleSphere);
        effect.setFloat("samplesFactor", samplesFactor);
        effect.setFloat("randTextureTiles", 4);
      }
      effect.setFloat("totalStrength", this.totalStrength);
      effect.setFloat("radius", this.radius);
      effect.setFloat("area", this.area);
      effect.setFloat("fallOff", this.fallOff);
      effect.setFloat("base", this.base);
      effect.setTexture("textureSampler", this._scene.enableDepthRenderer(this._scene.activeCamera).getDepthMap());
      effect.setTexture("randomSampler", this._randomTexture);
    };
  }
  _createSSAOCombinePostProcess(ratio) {
    this._ssaoCombinePostProcess = new PostProcess("ssaoCombine", "ssaoCombine", [], ["originalColor", "viewport"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);
    this._ssaoCombinePostProcess.onApply = (effect) => {
      effect.setVector4("viewport", TmpVectors.Vector4[0].copyFromFloats(0, 0, 1, 1));
      effect.setTextureFromPostProcess("originalColor", this._originalColorPostProcess);
    };
  }
  _createRandomTexture() {
    const size = 512;
    this._randomTexture = new DynamicTexture("SSAORandomTexture", size, this._scene, false, Texture.TRILINEAR_SAMPLINGMODE);
    this._randomTexture.wrapU = Texture.WRAP_ADDRESSMODE;
    this._randomTexture.wrapV = Texture.WRAP_ADDRESSMODE;
    const context = this._randomTexture.getContext();
    const rand = (min, max) => {
      return Math.random() * (max - min) + min;
    };
    const randVector = Vector3.Zero();
    for (let x = 0; x < size; x++) {
      for (let y = 0; y < size; y++) {
        randVector.x = Math.floor(Math.max(0, rand(-1, 1)) * 255);
        randVector.y = Math.floor(Math.max(0, rand(-1, 1)) * 255);
        randVector.z = Math.floor(Math.max(0, rand(-1, 1)) * 255);
        context.fillStyle = "rgb(" + randVector.x + ", " + randVector.y + ", " + randVector.z + ")";
        context.fillRect(x, y, 1, 1);
      }
    }
    this._randomTexture.update(false);
  }
};
__decorate([
  serialize()
], SSAORenderingPipeline.prototype, "totalStrength", void 0);
__decorate([
  serialize()
], SSAORenderingPipeline.prototype, "radius", void 0);
__decorate([
  serialize()
], SSAORenderingPipeline.prototype, "area", void 0);
__decorate([
  serialize()
], SSAORenderingPipeline.prototype, "fallOff", void 0);
__decorate([
  serialize()
], SSAORenderingPipeline.prototype, "base", void 0);

// node_modules/@babylonjs/core/Rendering/screenSpaceReflectionsConfiguration.js
var ScreenSpaceReflectionsConfiguration = class {
  constructor() {
    this.enabled = false;
    this.name = "screenSpaceReflections";
    this.texturesRequired = [6, 3, 1];
  }
};

// node_modules/@babylonjs/core/Shaders/screenSpaceReflection.fragment.js
var name101 = "screenSpaceReflectionPixelShader";
var shader101 = `uniform sampler2D textureSampler;
#ifdef SSR_SUPPORTED
uniform sampler2D reflectivitySampler;
uniform sampler2D normalSampler;
uniform sampler2D positionSampler;
#endif
uniform mat4 view;
uniform mat4 projection;
uniform float stepSize;
uniform float strength;
uniform float threshold;
uniform float roughnessFactor;
uniform float reflectionSpecularFalloffExponent;
varying vec2 vUV;
#ifdef SSR_SUPPORTED
struct ReflectionInfo {
vec3 color;
vec4 coords;
};
/**
* According to specular,see https:
*/
vec3 fresnelSchlick(float cosTheta,vec3 F0)
{
return F0+(1.0-F0)*pow(1.0-cosTheta,5.0);
}
/**
* Once the pixel's coordinates has been found,let's adjust (smooth) a little bit
* by sampling multiple reflection pixels.
*/
ReflectionInfo smoothReflectionInfo(vec3 dir,vec3 hitCoord)
{
ReflectionInfo info;
info.color=vec3(0.0);
vec4 projectedCoord;
float sampledDepth;
for(int i=0; i<SMOOTH_STEPS; i++)
{
projectedCoord=projection*vec4(hitCoord,1.0);
projectedCoord.xy/=projectedCoord.w;
projectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);
sampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;
float depth=sampledDepth-hitCoord.z;
dir*=0.5;
if(depth>0.0)
hitCoord-=dir;
else
hitCoord+=dir;
info.color+=texture2D(textureSampler,projectedCoord.xy).rgb;
}
projectedCoord=projection*vec4(hitCoord,1.0);
projectedCoord.xy/=projectedCoord.w;
projectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);
info.coords=vec4(projectedCoord.xy,sampledDepth,1.0);
info.color+=texture2D(textureSampler,projectedCoord.xy).rgb;
info.color/=float(SMOOTH_STEPS+1);
return info;
}
/**
* Tests the given world position (hitCoord) according to the given reflection vector (dir)
* until it finds a collision (means that depth is enough close to say "it's the pixel to sample!").
*/
ReflectionInfo getReflectionInfo(vec3 dir,vec3 hitCoord)
{
ReflectionInfo info;
vec4 projectedCoord;
float sampledDepth;
dir*=stepSize;
for(int i=0; i<REFLECTION_SAMPLES; i++)
{
hitCoord+=dir;
projectedCoord=projection*vec4(hitCoord,1.0);
projectedCoord.xy/=projectedCoord.w;
projectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);
sampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;
float depth=sampledDepth-hitCoord.z;
#ifdef RIGHT_HANDED_SCENE
depth*=-1.0;
#endif
if(((depth-dir.z)<threshold) && depth<=0.0)
{
#ifdef ENABLE_SMOOTH_REFLECTIONS
return smoothReflectionInfo(dir,hitCoord);
#else
info.color=texture2D(textureSampler,projectedCoord.xy).rgb;
info.coords=vec4(projectedCoord.xy,sampledDepth,0.0);
return info;
#endif
}
}
info.color=texture2D(textureSampler,projectedCoord.xy).rgb;
info.coords=vec4(projectedCoord.xy,sampledDepth,0.0);
return info;
}
vec3 hash(vec3 a)
{
a=fract(a*0.8);
a+=dot(a,a.yxz+19.19);
return fract((a.xxy+a.yxx)*a.zyx);
}
#endif
void main()
{
#ifdef SSR_SUPPORTED
vec4 albedoFull=texture2D(textureSampler,vUV);
vec3 albedo=albedoFull.rgb;
float spec=texture2D(reflectivitySampler,vUV).r;
if (spec==0.0) {
gl_FragColor=albedoFull;
return;
}
vec3 normal=(texture2D(normalSampler,vUV)).xyz;
vec3 position=(view*texture2D(positionSampler,vUV)).xyz;
vec3 reflected=normalize(reflect(normalize(position),normalize(normal)));
float roughness=1.0-texture2D(reflectivitySampler,vUV).a;
vec3 jitt=mix(vec3(0.0),hash(position),roughness)*roughnessFactor;
ReflectionInfo info=getReflectionInfo(jitt+reflected,position);
vec2 dCoords=smoothstep(0.2,0.6,abs(vec2(0.5,0.5)-info.coords.xy));
float screenEdgefactor=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);
vec3 F0=vec3(0.04);
F0 =mix(F0,albedo,spec);
vec3 fresnel=fresnelSchlick(max(dot(normalize(normal),normalize(position)),0.0),F0);
#ifdef RIGHT_HANDED_SCENE
reflected.z*=-1.0;
#endif
float reflectionMultiplier=clamp(pow(spec*strength,reflectionSpecularFalloffExponent)*screenEdgefactor*reflected.z,0.0,0.9);
float albedoMultiplier=1.0-reflectionMultiplier;
vec3 SSR=info.color*fresnel;
gl_FragColor=vec4((albedo*albedoMultiplier)+(SSR*reflectionMultiplier),albedoFull.a);
#else
gl_FragColor=texture2D(textureSampler,vUV);
#endif
}
`;
ShaderStore.ShadersStore[name101] = shader101;

// node_modules/@babylonjs/core/PostProcesses/screenSpaceReflectionPostProcess.js
var ScreenSpaceReflectionPostProcess = class extends PostProcess {
  constructor(name137, scene, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false, forceGeometryBuffer = false) {
    super(name137, "screenSpaceReflection", ["projection", "view", "threshold", "reflectionSpecularFalloffExponent", "strength", "stepSize", "roughnessFactor"], ["textureSampler", "normalSampler", "positionSampler", "reflectivitySampler"], options, camera, samplingMode, engine, reusable, "#define SSR_SUPPORTED\n#define REFLECTION_SAMPLES 64\n#define SMOOTH_STEPS 5\n", textureType, void 0, null, blockCompilation);
    this.threshold = 1.2;
    this.strength = 1;
    this.reflectionSpecularFalloffExponent = 3;
    this.step = 1;
    this.roughnessFactor = 0.2;
    this._forceGeometryBuffer = false;
    this._enableSmoothReflections = false;
    this._reflectionSamples = 64;
    this._smoothSteps = 5;
    this._forceGeometryBuffer = forceGeometryBuffer;
    if (this._forceGeometryBuffer) {
      const geometryBufferRenderer = scene.enableGeometryBufferRenderer();
      if (geometryBufferRenderer) {
        if (geometryBufferRenderer.isSupported) {
          geometryBufferRenderer.enablePosition = true;
          geometryBufferRenderer.enableReflectivity = true;
        }
      }
    } else {
      const prePassRenderer = scene.enablePrePassRenderer();
      prePassRenderer === null || prePassRenderer === void 0 ? void 0 : prePassRenderer.markAsDirty();
      this._prePassEffectConfiguration = new ScreenSpaceReflectionsConfiguration();
    }
    this._updateEffectDefines();
    this.onApply = (effect) => {
      const geometryBufferRenderer = this._geometryBufferRenderer;
      const prePassRenderer = this._prePassRenderer;
      if (!prePassRenderer && !geometryBufferRenderer) {
        return;
      }
      if (geometryBufferRenderer) {
        const positionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);
        const roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);
        effect.setTexture("normalSampler", geometryBufferRenderer.getGBuffer().textures[1]);
        effect.setTexture("positionSampler", geometryBufferRenderer.getGBuffer().textures[positionIndex]);
        effect.setTexture("reflectivitySampler", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);
      } else if (prePassRenderer) {
        const positionIndex = prePassRenderer.getIndex(1);
        const roughnessIndex = prePassRenderer.getIndex(3);
        const normalIndex = prePassRenderer.getIndex(6);
        effect.setTexture("normalSampler", prePassRenderer.getRenderTarget().textures[normalIndex]);
        effect.setTexture("positionSampler", prePassRenderer.getRenderTarget().textures[positionIndex]);
        effect.setTexture("reflectivitySampler", prePassRenderer.getRenderTarget().textures[roughnessIndex]);
      }
      const camera2 = scene.activeCamera;
      if (!camera2) {
        return;
      }
      const viewMatrix = camera2.getViewMatrix(true);
      const projectionMatrix = camera2.getProjectionMatrix(true);
      effect.setMatrix("projection", projectionMatrix);
      effect.setMatrix("view", viewMatrix);
      effect.setFloat("threshold", this.threshold);
      effect.setFloat("reflectionSpecularFalloffExponent", this.reflectionSpecularFalloffExponent);
      effect.setFloat("strength", this.strength);
      effect.setFloat("stepSize", this.step);
      effect.setFloat("roughnessFactor", this.roughnessFactor);
    };
    this._isSceneRightHanded = scene.useRightHandedSystem;
  }
  get _geometryBufferRenderer() {
    if (!this._forceGeometryBuffer) {
      return null;
    }
    return this._scene.geometryBufferRenderer;
  }
  get _prePassRenderer() {
    if (this._forceGeometryBuffer) {
      return null;
    }
    return this._scene.prePassRenderer;
  }
  getClassName() {
    return "ScreenSpaceReflectionPostProcess";
  }
  get enableSmoothReflections() {
    return this._enableSmoothReflections;
  }
  set enableSmoothReflections(enabled) {
    if (enabled === this._enableSmoothReflections) {
      return;
    }
    this._enableSmoothReflections = enabled;
    this._updateEffectDefines();
  }
  get reflectionSamples() {
    return this._reflectionSamples;
  }
  set reflectionSamples(samples) {
    if (samples === this._reflectionSamples) {
      return;
    }
    this._reflectionSamples = samples;
    this._updateEffectDefines();
  }
  get smoothSteps() {
    return this._smoothSteps;
  }
  set smoothSteps(steps) {
    if (steps === this._smoothSteps) {
      return;
    }
    this._smoothSteps = steps;
    this._updateEffectDefines();
  }
  _updateEffectDefines() {
    const defines = [];
    if (this._geometryBufferRenderer || this._prePassRenderer) {
      defines.push("#define SSR_SUPPORTED");
    }
    if (this._enableSmoothReflections) {
      defines.push("#define ENABLE_SMOOTH_REFLECTIONS");
    }
    if (this._isSceneRightHanded) {
      defines.push("#define RIGHT_HANDED_SCENE");
    }
    defines.push("#define REFLECTION_SAMPLES " + (this._reflectionSamples >> 0));
    defines.push("#define SMOOTH_STEPS " + (this._smoothSteps >> 0));
    this.updateEffect(defines.join("\n"));
  }
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new ScreenSpaceReflectionPostProcess(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.textureType, parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  }
};
__decorate([
  serialize()
], ScreenSpaceReflectionPostProcess.prototype, "threshold", void 0);
__decorate([
  serialize()
], ScreenSpaceReflectionPostProcess.prototype, "strength", void 0);
__decorate([
  serialize()
], ScreenSpaceReflectionPostProcess.prototype, "reflectionSpecularFalloffExponent", void 0);
__decorate([
  serialize()
], ScreenSpaceReflectionPostProcess.prototype, "step", void 0);
__decorate([
  serialize()
], ScreenSpaceReflectionPostProcess.prototype, "roughnessFactor", void 0);
__decorate([
  serialize()
], ScreenSpaceReflectionPostProcess.prototype, "enableSmoothReflections", null);
__decorate([
  serialize()
], ScreenSpaceReflectionPostProcess.prototype, "reflectionSamples", null);
__decorate([
  serialize()
], ScreenSpaceReflectionPostProcess.prototype, "smoothSteps", null);
RegisterClass("BABYLON.ScreenSpaceReflectionPostProcess", ScreenSpaceReflectionPostProcess);

// node_modules/@babylonjs/core/Shaders/standard.fragment.js
var name102 = "standardPixelShader";
var shader102 = `uniform sampler2D textureSampler;
varying vec2 vUV;
#define CUSTOM_FRAGMENT_DEFINITIONS
#if defined(PASS_POST_PROCESS)
void main(void)
{
vec4 color=texture2D(textureSampler,vUV);
gl_FragColor=color;
}
#endif
#if defined(DOWN_SAMPLE_X4)
uniform vec2 dsOffsets[16];
void main(void)
{
vec4 average=vec4(0.0,0.0,0.0,0.0);
average=texture2D(textureSampler,vUV+dsOffsets[0]);
average+=texture2D(textureSampler,vUV+dsOffsets[1]);
average+=texture2D(textureSampler,vUV+dsOffsets[2]);
average+=texture2D(textureSampler,vUV+dsOffsets[3]);
average+=texture2D(textureSampler,vUV+dsOffsets[4]);
average+=texture2D(textureSampler,vUV+dsOffsets[5]);
average+=texture2D(textureSampler,vUV+dsOffsets[6]);
average+=texture2D(textureSampler,vUV+dsOffsets[7]);
average+=texture2D(textureSampler,vUV+dsOffsets[8]);
average+=texture2D(textureSampler,vUV+dsOffsets[9]);
average+=texture2D(textureSampler,vUV+dsOffsets[10]);
average+=texture2D(textureSampler,vUV+dsOffsets[11]);
average+=texture2D(textureSampler,vUV+dsOffsets[12]);
average+=texture2D(textureSampler,vUV+dsOffsets[13]);
average+=texture2D(textureSampler,vUV+dsOffsets[14]);
average+=texture2D(textureSampler,vUV+dsOffsets[15]);
average/=16.0;
gl_FragColor=average;
}
#endif
#if defined(BRIGHT_PASS)
uniform vec2 dsOffsets[4];
uniform float brightThreshold;
void main(void)
{
vec4 average=vec4(0.0,0.0,0.0,0.0);
average=texture2D(textureSampler,vUV+vec2(dsOffsets[0].x,dsOffsets[0].y));
average+=texture2D(textureSampler,vUV+vec2(dsOffsets[1].x,dsOffsets[1].y));
average+=texture2D(textureSampler,vUV+vec2(dsOffsets[2].x,dsOffsets[2].y));
average+=texture2D(textureSampler,vUV+vec2(dsOffsets[3].x,dsOffsets[3].y));
average*=0.25;
float luminance=length(average.rgb);
if (luminance<brightThreshold) {
average=vec4(0.0,0.0,0.0,1.0);
}
gl_FragColor=average;
}
#endif
#if defined(TEXTURE_ADDER)
uniform sampler2D otherSampler;
uniform sampler2D lensSampler;
uniform float exposure;
void main(void)
{
vec3 colour=texture2D(textureSampler,vUV).rgb;
colour*=exposure;
vec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);
vec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);
colour=retColor*retColor;
colour+=colour*texture2D(lensSampler,vUV).rgb;
vec4 finalColor=vec4(colour.rgb,1.0)+texture2D(otherSampler,vUV);
gl_FragColor=finalColor;
}
#endif
#if defined(VLS)
#define PI 3.1415926535897932384626433832795
uniform mat4 shadowViewProjection;
uniform mat4 lightWorld;
uniform vec3 cameraPosition;
uniform vec3 sunDirection;
uniform vec3 sunColor;
uniform vec2 depthValues;
uniform float scatteringCoefficient;
uniform float scatteringPower;
uniform sampler2D shadowMapSampler;
uniform sampler2D positionSampler;
float computeScattering(float lightDotView)
{
float result=1.0-scatteringCoefficient*scatteringCoefficient;
result/=(4.0*PI*pow(1.0+scatteringCoefficient*scatteringCoefficient-(2.0*scatteringCoefficient)*lightDotView,1.5));
return result;
}
void main(void)
{
vec3 worldPos=texture2D(positionSampler,vUV).rgb;
vec3 startPosition=cameraPosition;
vec3 rayVector=worldPos-startPosition;
float rayLength=length(rayVector);
vec3 rayDirection=rayVector/rayLength;
float stepLength=rayLength/NB_STEPS;
vec3 stepL=rayDirection*stepLength;
vec3 currentPosition=startPosition;
vec3 accumFog=vec3(0.0);
for (int i=0; i<int(NB_STEPS); i++)
{
vec4 worldInShadowCameraSpace=shadowViewProjection*vec4(currentPosition,1.0);
float depthMetric= (worldInShadowCameraSpace.z+depthValues.x)/(depthValues.y);
float shadowPixelDepth=clamp(depthMetric,0.0,1.0);
worldInShadowCameraSpace.xyz/=worldInShadowCameraSpace.w;
worldInShadowCameraSpace.xyz=0.5*worldInShadowCameraSpace.xyz+vec3(0.5);
float shadowMapValue=texture2D(shadowMapSampler,worldInShadowCameraSpace.xy).r;
if (shadowMapValue>shadowPixelDepth)
accumFog+=sunColor*computeScattering(dot(rayDirection,sunDirection));
currentPosition+=stepL;
}
accumFog/=NB_STEPS;
vec3 color=accumFog*scatteringPower;
gl_FragColor=vec4(color*exp(color) ,1.0);
}
#endif
#if defined(VLSMERGE)
uniform sampler2D originalSampler;
void main(void)
{
gl_FragColor=texture2D(originalSampler,vUV)+texture2D(textureSampler,vUV);
}
#endif
#if defined(LUMINANCE)
uniform vec2 lumOffsets[4];
void main()
{
float average=0.0;
vec4 color=vec4(0.0);
float maximum=-1e20;
vec3 weight=vec3(0.299,0.587,0.114);
for (int i=0; i<4; i++)
{
color=texture2D(textureSampler,vUV+ lumOffsets[i]);
float GreyValue=dot(color.rgb,vec3(0.33,0.33,0.33));
#ifdef WEIGHTED_AVERAGE
float GreyValue=dot(color.rgb,weight);
#endif
#ifdef BRIGHTNESS
float GreyValue=max(color.r,max(color.g,color.b));
#endif
#ifdef HSL_COMPONENT
float GreyValue=0.5*(max(color.r,max(color.g,color.b))+min(color.r,min(color.g,color.b)));
#endif
#ifdef MAGNITUDE
float GreyValue=length(color.rgb);
#endif
maximum=max(maximum,GreyValue);
average+=(0.25*log(1e-5+GreyValue));
}
average=exp(average);
gl_FragColor=vec4(average,maximum,0.0,1.0);
}
#endif
#if defined(LUMINANCE_DOWN_SAMPLE)
uniform vec2 dsOffsets[9];
uniform float halfDestPixelSize;
#ifdef FINAL_DOWN_SAMPLER
#include<packingFunctions>
#endif
void main()
{
vec4 color=vec4(0.0);
float average=0.0;
for (int i=0; i<9; i++)
{
color=texture2D(textureSampler,vUV+vec2(halfDestPixelSize,halfDestPixelSize)+dsOffsets[i]);
average+=color.r;
}
average/=9.0;
#ifdef FINAL_DOWN_SAMPLER
gl_FragColor=pack(average);
#else
gl_FragColor=vec4(average,average,0.0,1.0);
#endif
}
#endif
#if defined(HDR)
uniform sampler2D textureAdderSampler;
uniform float averageLuminance;
void main()
{
vec4 color=texture2D(textureAdderSampler,vUV);
#ifndef AUTO_EXPOSURE
vec4 adjustedColor=color/averageLuminance;
color=adjustedColor;
color.a=1.0;
#endif
gl_FragColor=color;
}
#endif
#if defined(LENS_FLARE)
#define GHOSTS 3
uniform sampler2D lensColorSampler;
uniform float strength;
uniform float ghostDispersal;
uniform float haloWidth;
uniform vec2 resolution;
uniform float distortionStrength;
float hash(vec2 p)
{
float h=dot(p,vec2(127.1,311.7));
return -1.0+2.0*fract(sin(h)*43758.5453123);
}
float noise(in vec2 p)
{
vec2 i=floor(p);
vec2 f=fract(p);
vec2 u=f*f*(3.0-2.0*f);
return mix(mix(hash(i+vec2(0.0,0.0)),
hash(i+vec2(1.0,0.0)),u.x),
mix(hash(i+vec2(0.0,1.0)),
hash(i+vec2(1.0,1.0)),u.x),u.y);
}
float fbm(vec2 p)
{
float f=0.0;
f+=0.5000*noise(p); p*=2.02;
f+=0.2500*noise(p); p*=2.03;
f+=0.1250*noise(p); p*=2.01;
f+=0.0625*noise(p); p*=2.04;
f/=0.9375;
return f;
}
vec3 pattern(vec2 uv)
{
vec2 p=-1.0+2.0*uv;
float p2=dot(p,p);
float f=fbm(vec2(15.0*p2))/2.0;
float r=0.2+0.6*sin(12.5*length(uv-vec2(0.5)));
float g=0.2+0.6*sin(20.5*length(uv-vec2(0.5)));
float b=0.2+0.6*sin(17.2*length(uv-vec2(0.5)));
return (1.0-f)*vec3(r,g,b);
}
float luminance(vec3 color)
{
return dot(color.rgb,vec3(0.2126,0.7152,0.0722));
}
vec4 textureDistorted(sampler2D tex,vec2 texcoord,vec2 direction,vec3 distortion)
{
return vec4(
texture2D(tex,texcoord+direction*distortion.r).r,
texture2D(tex,texcoord+direction*distortion.g).g,
texture2D(tex,texcoord+direction*distortion.b).b,
1.0
);
}
void main(void)
{
vec2 uv=-vUV+vec2(1.0);
vec2 ghostDir=(vec2(0.5)-uv)*ghostDispersal;
vec2 texelSize=1.0/resolution;
vec3 distortion=vec3(-texelSize.x*distortionStrength,0.0,texelSize.x*distortionStrength);
vec4 result=vec4(0.0);
float ghostIndice=1.0;
for (int i=0; i<GHOSTS; ++i)
{
vec2 offset=fract(uv+ghostDir*ghostIndice);
float weight=length(vec2(0.5)-offset)/length(vec2(0.5));
weight=pow(1.0-weight,10.0);
result+=textureDistorted(textureSampler,offset,normalize(ghostDir),distortion)*weight*strength;
ghostIndice+=1.0;
}
vec2 haloVec=normalize(ghostDir)*haloWidth;
float weight=length(vec2(0.5)-fract(uv+haloVec))/length(vec2(0.5));
weight=pow(1.0-weight,10.0);
result+=textureDistorted(textureSampler,fract(uv+haloVec),normalize(ghostDir),distortion)*weight*strength;
result*=texture2D(lensColorSampler,vec2(length(vec2(0.5)-uv)/length(vec2(0.5))));
gl_FragColor=result;
}
#endif
#if defined(LENS_FLARE_COMPOSE)
uniform sampler2D otherSampler;
uniform sampler2D lensDirtSampler;
uniform sampler2D lensStarSampler;
uniform mat4 lensStarMatrix;
void main(void)
{
vec2 lensFlareCoords=(lensStarMatrix*vec4(vUV,1.0,1.0)).xy;
vec4 lensMod=texture2D(lensDirtSampler,vUV);
lensMod+=texture2D(lensStarSampler,vUV/*lensFlareCoords*/);
vec4 result=texture2D(textureSampler,vUV)*lensMod;
gl_FragColor=texture2D(otherSampler,vUV)+result;
}
#endif
#if defined(DEPTH_OF_FIELD)
uniform sampler2D otherSampler;
uniform sampler2D depthSampler;
uniform float distance;
void main(void)
{
vec4 sharp=texture2D(otherSampler,vUV);
vec4 blur=texture2D(textureSampler,vUV);
float dist=clamp(texture2D(depthSampler,vUV).r*distance,0.0,1.0);
float factor=0.0;
if (dist<0.05)
factor=1.0;
else if (dist<0.1)
factor=20.0*(0.1-dist);
else if (dist<0.5)
factor=0.0;
else
factor=2.0*(dist-0.5);
factor=clamp(factor,0.0,0.90);
gl_FragColor=mix(sharp,blur,factor);
}
#endif
#if defined(MOTION_BLUR)
uniform mat4 inverseViewProjection;
uniform mat4 prevViewProjection;
uniform vec2 screenSize;
uniform float motionScale;
uniform float motionStrength;
uniform sampler2D depthSampler;
void main(void)
{
vec2 texelSize=1.0/screenSize;
float depth=texture2D(depthSampler,vUV).r;
vec4 cpos=vec4(vUV*2.0-1.0,depth,1.0);
cpos=cpos*inverseViewProjection;
vec4 ppos=cpos*prevViewProjection;
ppos.xyz/=ppos.w;
ppos.xy=ppos.xy*0.5+0.5;
vec2 velocity=(ppos.xy-vUV)*motionScale*motionStrength;
float speed=length(velocity/texelSize);
int nSamples=int(clamp(speed,1.0,MAX_MOTION_SAMPLES));
vec4 result=texture2D(textureSampler,vUV);
for (int i=1; i<int(MAX_MOTION_SAMPLES); ++i) {
if (i>=nSamples)
break;
vec2 offset1=vUV+velocity*(float(i)/float(nSamples-1)-0.5);
result+=texture2D(textureSampler,offset1);
}
gl_FragColor=result/float(nSamples);
}
#endif
`;
ShaderStore.ShadersStore[name102] = shader102;

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/standardRenderingPipeline.js
var StandardRenderingPipeline = class extends PostProcessRenderPipeline {
  constructor(name137, scene, ratio, originalPostProcess = null, cameras) {
    super(scene.getEngine(), name137);
    this.downSampleX4PostProcess = null;
    this.brightPassPostProcess = null;
    this.blurHPostProcesses = [];
    this.blurVPostProcesses = [];
    this.textureAdderPostProcess = null;
    this.volumetricLightPostProcess = null;
    this.volumetricLightSmoothXPostProcess = null;
    this.volumetricLightSmoothYPostProcess = null;
    this.volumetricLightMergePostProces = null;
    this.volumetricLightFinalPostProcess = null;
    this.luminancePostProcess = null;
    this.luminanceDownSamplePostProcesses = [];
    this.hdrPostProcess = null;
    this.textureAdderFinalPostProcess = null;
    this.lensFlareFinalPostProcess = null;
    this.hdrFinalPostProcess = null;
    this.lensFlarePostProcess = null;
    this.lensFlareComposePostProcess = null;
    this.motionBlurPostProcess = null;
    this.depthOfFieldPostProcess = null;
    this.fxaaPostProcess = null;
    this.screenSpaceReflectionPostProcess = null;
    this.brightThreshold = 1;
    this.blurWidth = 512;
    this.horizontalBlur = false;
    this.lensTexture = null;
    this.volumetricLightCoefficient = 0.2;
    this.volumetricLightPower = 4;
    this.volumetricLightBlurScale = 64;
    this.sourceLight = null;
    this.hdrMinimumLuminance = 1;
    this.hdrDecreaseRate = 0.5;
    this.hdrIncreaseRate = 0.5;
    this.lensColorTexture = null;
    this.lensFlareStrength = 20;
    this.lensFlareGhostDispersal = 1.4;
    this.lensFlareHaloWidth = 0.7;
    this.lensFlareDistortionStrength = 16;
    this.lensFlareBlurWidth = 512;
    this.lensStarTexture = null;
    this.lensFlareDirtTexture = null;
    this.depthOfFieldDistance = 10;
    this.depthOfFieldBlurWidth = 64;
    this.animations = [];
    this._currentDepthOfFieldSource = null;
    this._fixedExposure = 1;
    this._currentExposure = 1;
    this._hdrAutoExposure = false;
    this._hdrCurrentLuminance = 1;
    this._motionStrength = 1;
    this._isObjectBasedMotionBlur = false;
    this._camerasToBeAttached = [];
    this._bloomEnabled = false;
    this._depthOfFieldEnabled = false;
    this._vlsEnabled = false;
    this._lensFlareEnabled = false;
    this._hdrEnabled = false;
    this._motionBlurEnabled = false;
    this._fxaaEnabled = false;
    this._screenSpaceReflectionsEnabled = false;
    this._motionBlurSamples = 64;
    this._volumetricLightStepsCount = 50;
    this._samples = 1;
    this._cameras = cameras || scene.cameras;
    this._cameras = this._cameras.slice();
    this._camerasToBeAttached = this._cameras.slice();
    this._scene = scene;
    this._basePostProcess = originalPostProcess;
    this._ratio = ratio;
    this._floatTextureType = scene.getEngine().getCaps().textureFloatRender ? 1 : 2;
    scene.postProcessRenderPipelineManager.addPipeline(this);
    this._buildPipeline();
  }
  get exposure() {
    return this._fixedExposure;
  }
  set exposure(value) {
    this._fixedExposure = value;
    this._currentExposure = value;
  }
  get hdrAutoExposure() {
    return this._hdrAutoExposure;
  }
  set hdrAutoExposure(value) {
    this._hdrAutoExposure = value;
    if (this.hdrPostProcess) {
      const defines = ["#define HDR"];
      if (value) {
        defines.push("#define AUTO_EXPOSURE");
      }
      this.hdrPostProcess.updateEffect(defines.join("\n"));
    }
  }
  get motionStrength() {
    return this._motionStrength;
  }
  set motionStrength(strength) {
    this._motionStrength = strength;
    if (this._isObjectBasedMotionBlur && this.motionBlurPostProcess) {
      this.motionBlurPostProcess.motionStrength = strength;
    }
  }
  get objectBasedMotionBlur() {
    return this._isObjectBasedMotionBlur;
  }
  set objectBasedMotionBlur(value) {
    const shouldRebuild = this._isObjectBasedMotionBlur !== value;
    this._isObjectBasedMotionBlur = value;
    if (shouldRebuild) {
      this._buildPipeline();
    }
  }
  get BloomEnabled() {
    return this._bloomEnabled;
  }
  set BloomEnabled(enabled) {
    if (this._bloomEnabled === enabled) {
      return;
    }
    this._bloomEnabled = enabled;
    this._buildPipeline();
  }
  get DepthOfFieldEnabled() {
    return this._depthOfFieldEnabled;
  }
  set DepthOfFieldEnabled(enabled) {
    if (this._depthOfFieldEnabled === enabled) {
      return;
    }
    this._depthOfFieldEnabled = enabled;
    this._buildPipeline();
  }
  get LensFlareEnabled() {
    return this._lensFlareEnabled;
  }
  set LensFlareEnabled(enabled) {
    if (this._lensFlareEnabled === enabled) {
      return;
    }
    this._lensFlareEnabled = enabled;
    this._buildPipeline();
  }
  get HDREnabled() {
    return this._hdrEnabled;
  }
  set HDREnabled(enabled) {
    if (this._hdrEnabled === enabled) {
      return;
    }
    this._hdrEnabled = enabled;
    this._buildPipeline();
  }
  get VLSEnabled() {
    return this._vlsEnabled;
  }
  set VLSEnabled(enabled) {
    if (this._vlsEnabled === enabled) {
      return;
    }
    if (enabled) {
      const geometry = this._scene.enableGeometryBufferRenderer();
      if (!geometry) {
        Logger.Warn("Geometry renderer is not supported, cannot create volumetric lights in Standard Rendering Pipeline");
        return;
      }
    }
    this._vlsEnabled = enabled;
    this._buildPipeline();
  }
  get MotionBlurEnabled() {
    return this._motionBlurEnabled;
  }
  set MotionBlurEnabled(enabled) {
    if (this._motionBlurEnabled === enabled) {
      return;
    }
    this._motionBlurEnabled = enabled;
    this._buildPipeline();
  }
  get fxaaEnabled() {
    return this._fxaaEnabled;
  }
  set fxaaEnabled(enabled) {
    if (this._fxaaEnabled === enabled) {
      return;
    }
    this._fxaaEnabled = enabled;
    this._buildPipeline();
  }
  get screenSpaceReflectionsEnabled() {
    return this._screenSpaceReflectionsEnabled;
  }
  set screenSpaceReflectionsEnabled(enabled) {
    if (this._screenSpaceReflectionsEnabled === enabled) {
      return;
    }
    this._screenSpaceReflectionsEnabled = enabled;
    this._buildPipeline();
  }
  get volumetricLightStepsCount() {
    return this._volumetricLightStepsCount;
  }
  set volumetricLightStepsCount(count) {
    if (this.volumetricLightPostProcess) {
      this.volumetricLightPostProcess.updateEffect("#define VLS\n#define NB_STEPS " + count.toFixed(1));
    }
    this._volumetricLightStepsCount = count;
  }
  get motionBlurSamples() {
    return this._motionBlurSamples;
  }
  set motionBlurSamples(samples) {
    if (this.motionBlurPostProcess) {
      if (this._isObjectBasedMotionBlur) {
        this.motionBlurPostProcess.motionBlurSamples = samples;
      } else {
        this.motionBlurPostProcess.updateEffect("#define MOTION_BLUR\n#define MAX_MOTION_SAMPLES " + samples.toFixed(1));
      }
    }
    this._motionBlurSamples = samples;
  }
  get samples() {
    return this._samples;
  }
  set samples(sampleCount) {
    if (this._samples === sampleCount) {
      return;
    }
    this._samples = sampleCount;
    this._buildPipeline();
  }
  _buildPipeline() {
    const ratio = this._ratio;
    const scene = this._scene;
    this._disposePostProcesses();
    if (this._cameras !== null) {
      this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
      this._cameras = this._camerasToBeAttached.slice();
    }
    this._reset();
    if (this._screenSpaceReflectionsEnabled) {
      this.screenSpaceReflectionPostProcess = new ScreenSpaceReflectionPostProcess("HDRPass", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);
      this.screenSpaceReflectionPostProcess.onApplyObservable.add(() => {
        this._currentDepthOfFieldSource = this.screenSpaceReflectionPostProcess;
      });
      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRScreenSpaceReflections", () => this.screenSpaceReflectionPostProcess, true));
    }
    if (!this._basePostProcess) {
      this.originalPostProcess = new PostProcess("HDRPass", "standard", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define PASS_POST_PROCESS", this._floatTextureType);
    } else {
      this.originalPostProcess = this._basePostProcess;
    }
    this.originalPostProcess.autoClear = !this.screenSpaceReflectionPostProcess;
    this.originalPostProcess.onApplyObservable.add(() => {
      this._currentDepthOfFieldSource = this.originalPostProcess;
    });
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRPassPostProcess", () => this.originalPostProcess, true));
    if (this._bloomEnabled) {
      this._createDownSampleX4PostProcess(scene, ratio / 4);
      this._createBrightPassPostProcess(scene, ratio / 4);
      this._createBlurPostProcesses(scene, ratio / 4, 1);
      this._createTextureAdderPostProcess(scene, ratio);
      this.textureAdderFinalPostProcess = new PostProcess("HDRDepthOfFieldSource", "standard", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define PASS_POST_PROCESS", 0);
      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRBaseDepthOfFieldSource", () => {
        return this.textureAdderFinalPostProcess;
      }, true));
    }
    if (this._vlsEnabled) {
      this._createVolumetricLightPostProcess(scene, ratio);
      this.volumetricLightFinalPostProcess = new PostProcess("HDRVLSFinal", "standard", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define PASS_POST_PROCESS", 0);
      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRVLSFinal", () => {
        return this.volumetricLightFinalPostProcess;
      }, true));
    }
    if (this._lensFlareEnabled) {
      this._createLensFlarePostProcess(scene, ratio);
      this.lensFlareFinalPostProcess = new PostProcess("HDRPostLensFlareDepthOfFieldSource", "standard", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define PASS_POST_PROCESS", 0);
      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRPostLensFlareDepthOfFieldSource", () => {
        return this.lensFlareFinalPostProcess;
      }, true));
    }
    if (this._hdrEnabled) {
      this._createLuminancePostProcesses(scene, this._floatTextureType);
      this._createHdrPostProcess(scene, ratio);
      this.hdrFinalPostProcess = new PostProcess("HDRPostHDReDepthOfFieldSource", "standard", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define PASS_POST_PROCESS", 0);
      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRPostHDReDepthOfFieldSource", () => {
        return this.hdrFinalPostProcess;
      }, true));
    }
    if (this._depthOfFieldEnabled) {
      this._createBlurPostProcesses(scene, ratio / 2, 3, "depthOfFieldBlurWidth");
      this._createDepthOfFieldPostProcess(scene, ratio);
    }
    if (this._motionBlurEnabled) {
      this._createMotionBlurPostProcess(scene, ratio);
    }
    if (this._fxaaEnabled) {
      this.fxaaPostProcess = new FxaaPostProcess("fxaa", 1, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, 0);
      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRFxaa", () => {
        return this.fxaaPostProcess;
      }, true));
    }
    if (this._cameras !== null) {
      this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);
    }
    if (!this._enableMSAAOnFirstPostProcess(this._samples) && this._samples > 1) {
      Logger.Warn("MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0");
    }
  }
  _createDownSampleX4PostProcess(scene, ratio) {
    const downSampleX4Offsets = new Array(32);
    this.downSampleX4PostProcess = new PostProcess("HDRDownSampleX4", "standard", ["dsOffsets"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define DOWN_SAMPLE_X4", this._floatTextureType);
    this.downSampleX4PostProcess.onApply = (effect) => {
      let id = 0;
      const width = this.downSampleX4PostProcess.width;
      const height = this.downSampleX4PostProcess.height;
      for (let i = -2; i < 2; i++) {
        for (let j = -2; j < 2; j++) {
          downSampleX4Offsets[id] = (i + 0.5) * (1 / width);
          downSampleX4Offsets[id + 1] = (j + 0.5) * (1 / height);
          id += 2;
        }
      }
      effect.setArray2("dsOffsets", downSampleX4Offsets);
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRDownSampleX4", () => {
      return this.downSampleX4PostProcess;
    }, true));
  }
  _createBrightPassPostProcess(scene, ratio) {
    const brightOffsets = new Array(8);
    this.brightPassPostProcess = new PostProcess("HDRBrightPass", "standard", ["dsOffsets", "brightThreshold"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define BRIGHT_PASS", this._floatTextureType);
    this.brightPassPostProcess.onApply = (effect) => {
      const sU = 1 / this.brightPassPostProcess.width;
      const sV = 1 / this.brightPassPostProcess.height;
      brightOffsets[0] = -0.5 * sU;
      brightOffsets[1] = 0.5 * sV;
      brightOffsets[2] = 0.5 * sU;
      brightOffsets[3] = 0.5 * sV;
      brightOffsets[4] = -0.5 * sU;
      brightOffsets[5] = -0.5 * sV;
      brightOffsets[6] = 0.5 * sU;
      brightOffsets[7] = -0.5 * sV;
      effect.setArray2("dsOffsets", brightOffsets);
      effect.setFloat("brightThreshold", this.brightThreshold);
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRBrightPass", () => {
      return this.brightPassPostProcess;
    }, true));
  }
  _createBlurPostProcesses(scene, ratio, indice, blurWidthKey = "blurWidth") {
    const engine = scene.getEngine();
    const blurX = new BlurPostProcess("HDRBlurH_" + indice, new Vector2(1, 0), this[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);
    const blurY = new BlurPostProcess("HDRBlurV_" + indice, new Vector2(0, 1), this[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);
    blurX.onActivateObservable.add(() => {
      const dw = blurX.width / engine.getRenderWidth();
      blurX.kernel = this[blurWidthKey] * dw;
    });
    blurY.onActivateObservable.add(() => {
      const dw = blurY.height / engine.getRenderHeight();
      blurY.kernel = this.horizontalBlur ? 64 * dw : this[blurWidthKey] * dw;
    });
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRBlurH" + indice, () => {
      return blurX;
    }, true));
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRBlurV" + indice, () => {
      return blurY;
    }, true));
    this.blurHPostProcesses.push(blurX);
    this.blurVPostProcesses.push(blurY);
  }
  _createTextureAdderPostProcess(scene, ratio) {
    this.textureAdderPostProcess = new PostProcess("HDRTextureAdder", "standard", ["exposure"], ["otherSampler", "lensSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define TEXTURE_ADDER", this._floatTextureType);
    this.textureAdderPostProcess.onApply = (effect) => {
      effect.setTextureFromPostProcess("otherSampler", this._vlsEnabled ? this._currentDepthOfFieldSource : this.originalPostProcess);
      effect.setTexture("lensSampler", this.lensTexture);
      effect.setFloat("exposure", this._currentExposure);
      this._currentDepthOfFieldSource = this.textureAdderFinalPostProcess;
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRTextureAdder", () => {
      return this.textureAdderPostProcess;
    }, true));
  }
  _createVolumetricLightPostProcess(scene, ratio) {
    const geometryRenderer = scene.enableGeometryBufferRenderer();
    geometryRenderer.enablePosition = true;
    const geometry = geometryRenderer.getGBuffer();
    this.volumetricLightPostProcess = new PostProcess("HDRVLS", "standard", ["shadowViewProjection", "cameraPosition", "sunDirection", "sunColor", "scatteringCoefficient", "scatteringPower", "depthValues"], ["shadowMapSampler", "positionSampler"], ratio / 8, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define VLS\n#define NB_STEPS " + this._volumetricLightStepsCount.toFixed(1));
    const depthValues = Vector2.Zero();
    this.volumetricLightPostProcess.onApply = (effect) => {
      if (this.sourceLight && this.sourceLight.getShadowGenerator() && this._scene.activeCamera) {
        const generator = this.sourceLight.getShadowGenerator();
        effect.setTexture("shadowMapSampler", generator.getShadowMap());
        effect.setTexture("positionSampler", geometry.textures[2]);
        effect.setColor3("sunColor", this.sourceLight.diffuse);
        effect.setVector3("sunDirection", this.sourceLight.getShadowDirection());
        effect.setVector3("cameraPosition", this._scene.activeCamera.globalPosition);
        effect.setMatrix("shadowViewProjection", generator.getTransformMatrix());
        effect.setFloat("scatteringCoefficient", this.volumetricLightCoefficient);
        effect.setFloat("scatteringPower", this.volumetricLightPower);
        depthValues.x = this.sourceLight.getDepthMinZ(this._scene.activeCamera);
        depthValues.y = this.sourceLight.getDepthMaxZ(this._scene.activeCamera);
        effect.setVector2("depthValues", depthValues);
      }
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRVLS", () => {
      return this.volumetricLightPostProcess;
    }, true));
    this._createBlurPostProcesses(scene, ratio / 4, 0, "volumetricLightBlurScale");
    this.volumetricLightMergePostProces = new PostProcess("HDRVLSMerge", "standard", [], ["originalSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define VLSMERGE");
    this.volumetricLightMergePostProces.onApply = (effect) => {
      effect.setTextureFromPostProcess("originalSampler", this._bloomEnabled ? this.textureAdderFinalPostProcess : this.originalPostProcess);
      this._currentDepthOfFieldSource = this.volumetricLightFinalPostProcess;
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRVLSMerge", () => {
      return this.volumetricLightMergePostProces;
    }, true));
  }
  _createLuminancePostProcesses(scene, textureType) {
    let size = Math.pow(3, StandardRenderingPipeline.LuminanceSteps);
    this.luminancePostProcess = new PostProcess("HDRLuminance", "standard", ["lumOffsets"], [], { width: size, height: size }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define LUMINANCE", textureType);
    const offsets = [];
    this.luminancePostProcess.onApply = (effect) => {
      const sU = 1 / this.luminancePostProcess.width;
      const sV = 1 / this.luminancePostProcess.height;
      offsets[0] = -0.5 * sU;
      offsets[1] = 0.5 * sV;
      offsets[2] = 0.5 * sU;
      offsets[3] = 0.5 * sV;
      offsets[4] = -0.5 * sU;
      offsets[5] = -0.5 * sV;
      offsets[6] = 0.5 * sU;
      offsets[7] = -0.5 * sV;
      effect.setArray2("lumOffsets", offsets);
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRLuminance", () => {
      return this.luminancePostProcess;
    }, true));
    for (let i = StandardRenderingPipeline.LuminanceSteps - 1; i >= 0; i--) {
      size = Math.pow(3, i);
      let defines = "#define LUMINANCE_DOWN_SAMPLE\n";
      if (i === 0) {
        defines += "#define FINAL_DOWN_SAMPLER";
      }
      const postProcess = new PostProcess("HDRLuminanceDownSample" + i, "standard", ["dsOffsets", "halfDestPixelSize"], [], { width: size, height: size }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines, textureType);
      this.luminanceDownSamplePostProcesses.push(postProcess);
    }
    let lastLuminance = this.luminancePostProcess;
    this.luminanceDownSamplePostProcesses.forEach((pp, index) => {
      const downSampleOffsets = new Array(18);
      pp.onApply = (effect) => {
        if (!lastLuminance) {
          return;
        }
        let id = 0;
        for (let x = -1; x < 2; x++) {
          for (let y = -1; y < 2; y++) {
            downSampleOffsets[id] = x / lastLuminance.width;
            downSampleOffsets[id + 1] = y / lastLuminance.height;
            id += 2;
          }
        }
        effect.setArray2("dsOffsets", downSampleOffsets);
        effect.setFloat("halfDestPixelSize", 0.5 / lastLuminance.width);
        if (index === this.luminanceDownSamplePostProcesses.length - 1) {
          lastLuminance = this.luminancePostProcess;
        } else {
          lastLuminance = pp;
        }
      };
      if (index === this.luminanceDownSamplePostProcesses.length - 1) {
        pp.onAfterRender = () => {
          const pixel = scene.getEngine().readPixels(0, 0, 1, 1);
          const bit_shift = new Vector4(1 / (255 * 255 * 255), 1 / (255 * 255), 1 / 255, 1);
          pixel.then((pixel2) => {
            const data = new Uint8Array(pixel2.buffer);
            this._hdrCurrentLuminance = (data[0] * bit_shift.x + data[1] * bit_shift.y + data[2] * bit_shift.z + data[3] * bit_shift.w) / 100;
          });
        };
      }
      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRLuminanceDownSample" + index, () => {
        return pp;
      }, true));
    });
  }
  _createHdrPostProcess(scene, ratio) {
    const defines = ["#define HDR"];
    if (this._hdrAutoExposure) {
      defines.push("#define AUTO_EXPOSURE");
    }
    this.hdrPostProcess = new PostProcess("HDR", "standard", ["averageLuminance"], ["textureAdderSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines.join("\n"), 0);
    let outputLiminance = 1;
    let time = 0;
    let lastTime = 0;
    this.hdrPostProcess.onApply = (effect) => {
      effect.setTextureFromPostProcess("textureAdderSampler", this._currentDepthOfFieldSource);
      time += scene.getEngine().getDeltaTime();
      if (outputLiminance < 0) {
        outputLiminance = this._hdrCurrentLuminance;
      } else {
        const dt = (lastTime - time) / 1e3;
        if (this._hdrCurrentLuminance < outputLiminance + this.hdrDecreaseRate * dt) {
          outputLiminance += this.hdrDecreaseRate * dt;
        } else if (this._hdrCurrentLuminance > outputLiminance - this.hdrIncreaseRate * dt) {
          outputLiminance -= this.hdrIncreaseRate * dt;
        } else {
          outputLiminance = this._hdrCurrentLuminance;
        }
      }
      if (this.hdrAutoExposure) {
        this._currentExposure = this._fixedExposure / outputLiminance;
      } else {
        outputLiminance = Scalar.Clamp(outputLiminance, this.hdrMinimumLuminance, 1e20);
        effect.setFloat("averageLuminance", outputLiminance);
      }
      lastTime = time;
      this._currentDepthOfFieldSource = this.hdrFinalPostProcess;
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDR", () => {
      return this.hdrPostProcess;
    }, true));
  }
  _createLensFlarePostProcess(scene, ratio) {
    this.lensFlarePostProcess = new PostProcess("HDRLensFlare", "standard", ["strength", "ghostDispersal", "haloWidth", "resolution", "distortionStrength"], ["lensColorSampler"], ratio / 2, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define LENS_FLARE", 0);
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRLensFlare", () => {
      return this.lensFlarePostProcess;
    }, true));
    this._createBlurPostProcesses(scene, ratio / 4, 2, "lensFlareBlurWidth");
    this.lensFlareComposePostProcess = new PostProcess("HDRLensFlareCompose", "standard", ["lensStarMatrix"], ["otherSampler", "lensDirtSampler", "lensStarSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define LENS_FLARE_COMPOSE", 0);
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRLensFlareCompose", () => {
      return this.lensFlareComposePostProcess;
    }, true));
    const resolution = new Vector2(0, 0);
    this.lensFlarePostProcess.externalTextureSamplerBinding = true;
    this.lensFlarePostProcess.onApply = (effect) => {
      effect.setTextureFromPostProcess("textureSampler", this._bloomEnabled ? this.blurHPostProcesses[0] : this.originalPostProcess);
      effect.setTexture("lensColorSampler", this.lensColorTexture);
      effect.setFloat("strength", this.lensFlareStrength);
      effect.setFloat("ghostDispersal", this.lensFlareGhostDispersal);
      effect.setFloat("haloWidth", this.lensFlareHaloWidth);
      resolution.x = this.lensFlarePostProcess.width;
      resolution.y = this.lensFlarePostProcess.height;
      effect.setVector2("resolution", resolution);
      effect.setFloat("distortionStrength", this.lensFlareDistortionStrength);
    };
    const scaleBias1 = Matrix.FromValues(2, 0, -1, 0, 0, 2, -1, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    const scaleBias2 = Matrix.FromValues(0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    this.lensFlareComposePostProcess.onApply = (effect) => {
      if (!this._scene.activeCamera) {
        return;
      }
      effect.setTextureFromPostProcess("otherSampler", this.lensFlarePostProcess);
      effect.setTexture("lensDirtSampler", this.lensFlareDirtTexture);
      effect.setTexture("lensStarSampler", this.lensStarTexture);
      const camerax = this._scene.activeCamera.getViewMatrix().getRow(0);
      const cameraz = this._scene.activeCamera.getViewMatrix().getRow(2);
      let camRot = Vector3.Dot(camerax.toVector3(), new Vector3(1, 0, 0)) + Vector3.Dot(cameraz.toVector3(), new Vector3(0, 0, 1));
      camRot *= 4;
      const starRotation = Matrix.FromValues(Math.cos(camRot) * 0.5, -Math.sin(camRot), 0, 0, Math.sin(camRot), Math.cos(camRot) * 0.5, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      const lensStarMatrix = scaleBias2.multiply(starRotation).multiply(scaleBias1);
      effect.setMatrix("lensStarMatrix", lensStarMatrix);
      this._currentDepthOfFieldSource = this.lensFlareFinalPostProcess;
    };
  }
  _createDepthOfFieldPostProcess(scene, ratio) {
    this.depthOfFieldPostProcess = new PostProcess("HDRDepthOfField", "standard", ["distance"], ["otherSampler", "depthSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define DEPTH_OF_FIELD", 0);
    this.depthOfFieldPostProcess.onApply = (effect) => {
      effect.setTextureFromPostProcess("otherSampler", this._currentDepthOfFieldSource);
      effect.setTexture("depthSampler", this._getDepthTexture());
      effect.setFloat("distance", this.depthOfFieldDistance);
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRDepthOfField", () => {
      return this.depthOfFieldPostProcess;
    }, true));
  }
  _createMotionBlurPostProcess(scene, ratio) {
    if (this._isObjectBasedMotionBlur) {
      const mb = new MotionBlurPostProcess("HDRMotionBlur", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, 0);
      mb.motionStrength = this.motionStrength;
      mb.motionBlurSamples = this.motionBlurSamples;
      this.motionBlurPostProcess = mb;
    } else {
      this.motionBlurPostProcess = new PostProcess("HDRMotionBlur", "standard", ["inverseViewProjection", "prevViewProjection", "screenSize", "motionScale", "motionStrength"], ["depthSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define MOTION_BLUR\n#define MAX_MOTION_SAMPLES " + this.motionBlurSamples.toFixed(1), 0);
      let motionScale = 0;
      let prevViewProjection = Matrix.Identity();
      const invViewProjection = Matrix.Identity();
      let viewProjection = Matrix.Identity();
      const screenSize = Vector2.Zero();
      this.motionBlurPostProcess.onApply = (effect) => {
        viewProjection = scene.getProjectionMatrix().multiply(scene.getViewMatrix());
        viewProjection.invertToRef(invViewProjection);
        effect.setMatrix("inverseViewProjection", invViewProjection);
        effect.setMatrix("prevViewProjection", prevViewProjection);
        prevViewProjection = viewProjection;
        screenSize.x = this.motionBlurPostProcess.width;
        screenSize.y = this.motionBlurPostProcess.height;
        effect.setVector2("screenSize", screenSize);
        motionScale = scene.getEngine().getFps() / 60;
        effect.setFloat("motionScale", motionScale);
        effect.setFloat("motionStrength", this.motionStrength);
        effect.setTexture("depthSampler", this._getDepthTexture());
      };
    }
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRMotionBlur", () => {
      return this.motionBlurPostProcess;
    }, true));
  }
  _getDepthTexture() {
    if (this._scene.getEngine().getCaps().drawBuffersExtension) {
      const renderer = this._scene.enableGeometryBufferRenderer();
      return renderer.getGBuffer().textures[0];
    }
    return this._scene.enableDepthRenderer().getDepthMap();
  }
  _disposePostProcesses() {
    for (let i = 0; i < this._cameras.length; i++) {
      const camera = this._cameras[i];
      if (this.originalPostProcess) {
        this.originalPostProcess.dispose(camera);
      }
      if (this.screenSpaceReflectionPostProcess) {
        this.screenSpaceReflectionPostProcess.dispose(camera);
      }
      if (this.downSampleX4PostProcess) {
        this.downSampleX4PostProcess.dispose(camera);
      }
      if (this.brightPassPostProcess) {
        this.brightPassPostProcess.dispose(camera);
      }
      if (this.textureAdderPostProcess) {
        this.textureAdderPostProcess.dispose(camera);
      }
      if (this.volumetricLightPostProcess) {
        this.volumetricLightPostProcess.dispose(camera);
      }
      if (this.volumetricLightSmoothXPostProcess) {
        this.volumetricLightSmoothXPostProcess.dispose(camera);
      }
      if (this.volumetricLightSmoothYPostProcess) {
        this.volumetricLightSmoothYPostProcess.dispose(camera);
      }
      if (this.volumetricLightMergePostProces) {
        this.volumetricLightMergePostProces.dispose(camera);
      }
      if (this.volumetricLightFinalPostProcess) {
        this.volumetricLightFinalPostProcess.dispose(camera);
      }
      if (this.lensFlarePostProcess) {
        this.lensFlarePostProcess.dispose(camera);
      }
      if (this.lensFlareComposePostProcess) {
        this.lensFlareComposePostProcess.dispose(camera);
      }
      for (let j = 0; j < this.luminanceDownSamplePostProcesses.length; j++) {
        this.luminanceDownSamplePostProcesses[j].dispose(camera);
      }
      if (this.luminancePostProcess) {
        this.luminancePostProcess.dispose(camera);
      }
      if (this.hdrPostProcess) {
        this.hdrPostProcess.dispose(camera);
      }
      if (this.hdrFinalPostProcess) {
        this.hdrFinalPostProcess.dispose(camera);
      }
      if (this.depthOfFieldPostProcess) {
        this.depthOfFieldPostProcess.dispose(camera);
      }
      if (this.motionBlurPostProcess) {
        this.motionBlurPostProcess.dispose(camera);
      }
      if (this.fxaaPostProcess) {
        this.fxaaPostProcess.dispose(camera);
      }
      for (let j = 0; j < this.blurHPostProcesses.length; j++) {
        this.blurHPostProcesses[j].dispose(camera);
      }
      for (let j = 0; j < this.blurVPostProcesses.length; j++) {
        this.blurVPostProcesses[j].dispose(camera);
      }
    }
    this.originalPostProcess = null;
    this.downSampleX4PostProcess = null;
    this.brightPassPostProcess = null;
    this.textureAdderPostProcess = null;
    this.textureAdderFinalPostProcess = null;
    this.volumetricLightPostProcess = null;
    this.volumetricLightSmoothXPostProcess = null;
    this.volumetricLightSmoothYPostProcess = null;
    this.volumetricLightMergePostProces = null;
    this.volumetricLightFinalPostProcess = null;
    this.lensFlarePostProcess = null;
    this.lensFlareComposePostProcess = null;
    this.luminancePostProcess = null;
    this.hdrPostProcess = null;
    this.hdrFinalPostProcess = null;
    this.depthOfFieldPostProcess = null;
    this.motionBlurPostProcess = null;
    this.fxaaPostProcess = null;
    this.screenSpaceReflectionPostProcess = null;
    this.luminanceDownSamplePostProcesses.length = 0;
    this.blurHPostProcesses.length = 0;
    this.blurVPostProcesses.length = 0;
  }
  dispose() {
    this._disposePostProcesses();
    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
    super.dispose();
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    if (this.sourceLight) {
      serializationObject.sourceLightId = this.sourceLight.id;
    }
    if (this.screenSpaceReflectionPostProcess) {
      serializationObject.screenSpaceReflectionPostProcess = SerializationHelper.Serialize(this.screenSpaceReflectionPostProcess);
    }
    serializationObject.customType = "StandardRenderingPipeline";
    return serializationObject;
  }
  static Parse(source, scene, rootUrl) {
    const p = SerializationHelper.Parse(() => new StandardRenderingPipeline(source._name, scene, source._ratio), source, scene, rootUrl);
    if (source.sourceLightId) {
      p.sourceLight = scene.getLightById(source.sourceLightId);
    }
    if (source.screenSpaceReflectionPostProcess) {
      SerializationHelper.Parse(() => p.screenSpaceReflectionPostProcess, source.screenSpaceReflectionPostProcess, scene, rootUrl);
    }
    return p;
  }
};
StandardRenderingPipeline.LuminanceSteps = 6;
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "brightThreshold", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "blurWidth", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "horizontalBlur", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "exposure", null);
__decorate([
  serializeAsTexture("lensTexture")
], StandardRenderingPipeline.prototype, "lensTexture", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "volumetricLightCoefficient", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "volumetricLightPower", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "volumetricLightBlurScale", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "hdrMinimumLuminance", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "hdrDecreaseRate", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "hdrIncreaseRate", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "hdrAutoExposure", null);
__decorate([
  serializeAsTexture("lensColorTexture")
], StandardRenderingPipeline.prototype, "lensColorTexture", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "lensFlareStrength", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "lensFlareGhostDispersal", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "lensFlareHaloWidth", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "lensFlareDistortionStrength", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "lensFlareBlurWidth", void 0);
__decorate([
  serializeAsTexture("lensStarTexture")
], StandardRenderingPipeline.prototype, "lensStarTexture", void 0);
__decorate([
  serializeAsTexture("lensFlareDirtTexture")
], StandardRenderingPipeline.prototype, "lensFlareDirtTexture", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "depthOfFieldDistance", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "depthOfFieldBlurWidth", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "motionStrength", null);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "objectBasedMotionBlur", null);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "_ratio", void 0);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "BloomEnabled", null);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "DepthOfFieldEnabled", null);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "LensFlareEnabled", null);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "HDREnabled", null);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "VLSEnabled", null);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "MotionBlurEnabled", null);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "fxaaEnabled", null);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "screenSpaceReflectionsEnabled", null);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "volumetricLightStepsCount", null);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "motionBlurSamples", null);
__decorate([
  serialize()
], StandardRenderingPipeline.prototype, "samples", null);
RegisterClass("BABYLON.StandardRenderingPipeline", StandardRenderingPipeline);

// node_modules/@babylonjs/core/Shaders/tonemap.fragment.js
var name103 = "tonemapPixelShader";
var shader103 = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform float _ExposureAdjustment;
#if defined(HABLE_TONEMAPPING)
const float A=0.15;
const float B=0.50;
const float C=0.10;
const float D=0.20;
const float E=0.02;
const float F=0.30;
const float W=11.2;
#endif
float Luminance(vec3 c)
{
return dot(c,vec3(0.22,0.707,0.071));
}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{
vec3 colour=texture2D(textureSampler,vUV).rgb;
#if defined(REINHARD_TONEMAPPING)
float lum=Luminance(colour.rgb); 
float lumTm=lum*_ExposureAdjustment;
float scale=lumTm/(1.0+lumTm); 
colour*=scale/lum;
#elif defined(HABLE_TONEMAPPING)
colour*=_ExposureAdjustment;
const float ExposureBias=2.0;
vec3 x=ExposureBias*colour;
vec3 curr=((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
x=vec3(W,W,W);
vec3 whiteScale=1.0/(((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F);
colour=curr*whiteScale;
#elif defined(OPTIMIZED_HEJIDAWSON_TONEMAPPING)
colour*=_ExposureAdjustment;
vec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);
vec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);
colour=retColor*retColor;
#elif defined(PHOTOGRAPHIC_TONEMAPPING)
colour= vec3(1.0,1.0,1.0)-exp2(-_ExposureAdjustment*colour);
#endif
gl_FragColor=vec4(colour.rgb,1.0);
}`;
ShaderStore.ShadersStore[name103] = shader103;

// node_modules/@babylonjs/core/PostProcesses/tonemapPostProcess.js
var TonemappingOperator;
(function(TonemappingOperator2) {
  TonemappingOperator2[TonemappingOperator2["Hable"] = 0] = "Hable";
  TonemappingOperator2[TonemappingOperator2["Reinhard"] = 1] = "Reinhard";
  TonemappingOperator2[TonemappingOperator2["HejiDawson"] = 2] = "HejiDawson";
  TonemappingOperator2[TonemappingOperator2["Photographic"] = 3] = "Photographic";
})(TonemappingOperator || (TonemappingOperator = {}));
var TonemapPostProcess = class extends PostProcess {
  constructor(name137, _operator, exposureAdjustment, camera, samplingMode = 2, engine, textureFormat = 0, reusable) {
    super(name137, "tonemap", ["_ExposureAdjustment"], null, 1, camera, samplingMode, engine, reusable, null, textureFormat);
    this._operator = _operator;
    this.exposureAdjustment = exposureAdjustment;
    let defines = "#define ";
    if (this._operator === TonemappingOperator.Hable) {
      defines += "HABLE_TONEMAPPING";
    } else if (this._operator === TonemappingOperator.Reinhard) {
      defines += "REINHARD_TONEMAPPING";
    } else if (this._operator === TonemappingOperator.HejiDawson) {
      defines += "OPTIMIZED_HEJIDAWSON_TONEMAPPING";
    } else if (this._operator === TonemappingOperator.Photographic) {
      defines += "PHOTOGRAPHIC_TONEMAPPING";
    }
    this.updateEffect(defines);
    this.onApply = (effect) => {
      effect.setFloat("_ExposureAdjustment", this.exposureAdjustment);
    };
  }
  getClassName() {
    return "TonemapPostProcess";
  }
};

// node_modules/@babylonjs/core/Shaders/volumetricLightScattering.fragment.js
var name104 = "volumetricLightScatteringPixelShader";
var shader104 = `uniform sampler2D textureSampler;
uniform sampler2D lightScatteringSampler;
uniform float decay;
uniform float exposure;
uniform float weight;
uniform float density;
uniform vec2 meshPositionOnScreen;
varying vec2 vUV;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec2 tc=vUV;
vec2 deltaTexCoord=(tc-meshPositionOnScreen.xy);
deltaTexCoord*=1.0/float(NUM_SAMPLES)*density;
float illuminationDecay=1.0;
vec4 color=texture2D(lightScatteringSampler,tc)*0.4;
for(int i=0; i<NUM_SAMPLES; i++) {
tc-=deltaTexCoord;
vec4 dataSample=texture2D(lightScatteringSampler,tc)*0.4;
dataSample*=illuminationDecay*weight;
color+=dataSample;
illuminationDecay*=decay;
}
vec4 realColor=texture2D(textureSampler,vUV);
gl_FragColor=((vec4((vec3(color.r,color.g,color.b)*exposure),1))+(realColor*(1.5-0.4)));
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
ShaderStore.ShadersStore[name104] = shader104;

// node_modules/@babylonjs/core/Shaders/volumetricLightScatteringPass.vertex.js
var name105 = "volumetricLightScatteringPassVertexShader";
var shader105 = `attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<instancesDeclaration>
uniform mat4 viewProjection;
uniform vec2 depthValues;
#if defined(ALPHATEST) || defined(NEED_UV)
varying vec2 vUV;
uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{
vec3 positionUpdated=position;
#if (defined(ALPHATEST) || defined(NEED_UV)) && defined(UV1)
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
gl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);
#if defined(ALPHATEST) || defined(BASIC_RENDER)
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
}
`;
ShaderStore.ShadersStore[name105] = shader105;

// node_modules/@babylonjs/core/Shaders/volumetricLightScatteringPass.fragment.js
var name106 = "volumetricLightScatteringPassPixelShader";
var shader106 = `#if defined(ALPHATEST) || defined(NEED_UV)
varying vec2 vUV;
#endif
#if defined(ALPHATEST)
uniform sampler2D diffuseSampler;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#if defined(ALPHATEST)
vec4 diffuseColor=texture2D(diffuseSampler,vUV);
if (diffuseColor.a<0.4)
discard;
#endif
gl_FragColor=vec4(0.0,0.0,0.0,1.0);
}
`;
ShaderStore.ShadersStore[name106] = shader106;

// node_modules/@babylonjs/core/PostProcesses/volumetricLightScatteringPostProcess.js
var VolumetricLightScatteringPostProcess = class extends PostProcess {
  constructor(name137, ratio, camera, mesh, samples = 100, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable, scene) {
    var _a, _b;
    super(name137, "volumetricLightScattering", ["decay", "exposure", "weight", "meshPositionOnScreen", "density"], ["lightScatteringSampler"], ratio.postProcessRatio || ratio, camera, samplingMode, engine, reusable, "#define NUM_SAMPLES " + samples);
    this._screenCoordinates = Vector2.Zero();
    this.customMeshPosition = Vector3.Zero();
    this.useCustomMeshPosition = false;
    this.invert = true;
    this.excludedMeshes = new Array();
    this.includedMeshes = new Array();
    this.exposure = 0.3;
    this.decay = 0.96815;
    this.weight = 0.58767;
    this.density = 0.926;
    scene = (_b = (_a = camera === null || camera === void 0 ? void 0 : camera.getScene()) !== null && _a !== void 0 ? _a : scene) !== null && _b !== void 0 ? _b : this._scene;
    engine = scene.getEngine();
    this._viewPort = new Viewport(0, 0, 1, 1).toGlobal(engine.getRenderWidth(), engine.getRenderHeight());
    this.mesh = mesh !== null && mesh !== void 0 ? mesh : VolumetricLightScatteringPostProcess.CreateDefaultMesh("VolumetricLightScatteringMesh", scene);
    this._createPass(scene, ratio.passRatio || ratio);
    this.onActivate = (camera2) => {
      if (!this.isSupported) {
        this.dispose(camera2);
      }
      this.onActivate = null;
    };
    this.onApplyObservable.add((effect) => {
      this._updateMeshScreenCoordinates(scene);
      effect.setTexture("lightScatteringSampler", this._volumetricLightScatteringRTT);
      effect.setFloat("exposure", this.exposure);
      effect.setFloat("decay", this.decay);
      effect.setFloat("weight", this.weight);
      effect.setFloat("density", this.density);
      effect.setVector2("meshPositionOnScreen", this._screenCoordinates);
    });
  }
  get useDiffuseColor() {
    Logger.Warn("VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead");
    return false;
  }
  set useDiffuseColor(useDiffuseColor) {
    Logger.Warn("VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead");
  }
  getClassName() {
    return "VolumetricLightScatteringPostProcess";
  }
  _isReady(subMesh, useInstances) {
    var _a;
    const mesh = subMesh.getMesh();
    if (mesh === this.mesh && mesh.material) {
      return mesh.material.isReady(mesh);
    }
    const renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[this._scene.getEngine().currentRenderPassId];
    if (renderingMaterial) {
      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);
    }
    const defines = [];
    const attribs = [VertexBuffer.PositionKind];
    const material = subMesh.getMaterial();
    if (material) {
      if (material.needAlphaTesting()) {
        defines.push("#define ALPHATEST");
      }
      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
        attribs.push(VertexBuffer.UVKind);
        defines.push("#define UV1");
      }
      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
        attribs.push(VertexBuffer.UV2Kind);
        defines.push("#define UV2");
      }
    }
    if (mesh.useBones && mesh.computeBonesUsingShaders) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      defines.push("#define BonesPerMesh " + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      MaterialHelper.PushAttributesForInstances(attribs);
      if (subMesh.getRenderingMesh().hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
      }
    }
    const drawWrapper = subMesh._getDrawWrapper(void 0, true);
    const cachedDefines = drawWrapper.defines;
    const join = defines.join("\n");
    if (cachedDefines !== join) {
      drawWrapper.setEffect(mesh.getScene().getEngine().createEffect("volumetricLightScatteringPass", attribs, ["world", "mBones", "viewProjection", "diffuseMatrix"], ["diffuseSampler"], join, void 0, void 0, void 0, { maxSimultaneousMorphTargets: mesh.numBoneInfluencers }), join);
    }
    return drawWrapper.effect.isReady();
  }
  setCustomMeshPosition(position) {
    this.customMeshPosition = position;
  }
  getCustomMeshPosition() {
    return this.customMeshPosition;
  }
  dispose(camera) {
    const rttIndex = camera.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);
    if (rttIndex !== -1) {
      camera.getScene().customRenderTargets.splice(rttIndex, 1);
    }
    this._volumetricLightScatteringRTT.dispose();
    super.dispose(camera);
  }
  getPass() {
    return this._volumetricLightScatteringRTT;
  }
  _meshExcluded(mesh) {
    if (this.includedMeshes.length > 0 && this.includedMeshes.indexOf(mesh) === -1 || this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {
      return true;
    }
    return false;
  }
  _createPass(scene, ratio) {
    const engine = scene.getEngine();
    this._volumetricLightScatteringRTT = new RenderTargetTexture("volumetricLightScatteringMap", { width: engine.getRenderWidth() * ratio, height: engine.getRenderHeight() * ratio }, scene, false, true, 0);
    this._volumetricLightScatteringRTT.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._volumetricLightScatteringRTT.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._volumetricLightScatteringRTT.renderList = null;
    this._volumetricLightScatteringRTT.renderParticles = false;
    this._volumetricLightScatteringRTT.ignoreCameraViewport = true;
    const camera = this.getCamera();
    if (camera) {
      camera.customRenderTargets.push(this._volumetricLightScatteringRTT);
    } else {
      scene.customRenderTargets.push(this._volumetricLightScatteringRTT);
    }
    const renderSubMesh = (subMesh) => {
      var _a;
      const renderingMesh = subMesh.getRenderingMesh();
      const effectiveMesh = subMesh.getEffectiveMesh();
      if (this._meshExcluded(renderingMesh)) {
        return;
      }
      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
      const material = subMesh.getMaterial();
      if (!material) {
        return;
      }
      const scene2 = renderingMesh.getScene();
      const engine2 = scene2.getEngine();
      engine2.setState(material.backFaceCulling, void 0, void 0, void 0, material.cullBackFaces);
      const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
      if (batch.mustReturn) {
        return;
      }
      const hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);
      if (this._isReady(subMesh, hardwareInstancedRendering)) {
        const renderingMaterial = (_a = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[engine2.currentRenderPassId];
        let drawWrapper = subMesh._getDrawWrapper();
        if (renderingMesh === this.mesh && !drawWrapper) {
          drawWrapper = material._getDrawWrapper();
        }
        if (!drawWrapper) {
          return;
        }
        const effect = drawWrapper.effect;
        engine2.enableEffect(drawWrapper);
        if (!hardwareInstancedRendering) {
          renderingMesh._bind(subMesh, effect, material.fillMode);
        }
        if (renderingMesh === this.mesh) {
          material.bind(effectiveMesh.getWorldMatrix(), renderingMesh);
        } else if (renderingMaterial) {
          renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);
        } else {
          effect.setMatrix("viewProjection", scene2.getTransformMatrix());
          if (material && material.needAlphaTesting()) {
            const alphaTexture = material.getAlphaTestTexture();
            effect.setTexture("diffuseSampler", alphaTexture);
            if (alphaTexture) {
              effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
            }
          }
          if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
            effect.setMatrices("mBones", renderingMesh.skeleton.getTransformMatrices(renderingMesh));
          }
        }
        if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {
          effect.setMatrix("world", effectiveMesh.getWorldMatrix());
        }
        renderingMesh._processRendering(effectiveMesh, subMesh, effect, Material.TriangleFillMode, batch, hardwareInstancedRendering, (isInstance, world) => {
          if (!isInstance) {
            effect.setMatrix("world", world);
          }
        });
      }
    };
    let savedSceneClearColor;
    const sceneClearColor = new Color4(0, 0, 0, 1);
    this._volumetricLightScatteringRTT.onBeforeRenderObservable.add(() => {
      savedSceneClearColor = scene.clearColor;
      scene.clearColor = sceneClearColor;
    });
    this._volumetricLightScatteringRTT.onAfterRenderObservable.add(() => {
      scene.clearColor = savedSceneClearColor;
    });
    this._volumetricLightScatteringRTT.customIsReadyFunction = (mesh, refreshRate, preWarm) => {
      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {
        for (let i = 0; i < mesh.subMeshes.length; ++i) {
          const subMesh = mesh.subMeshes[i];
          const material = subMesh.getMaterial();
          const renderingMesh = subMesh.getRenderingMesh();
          if (!material) {
            continue;
          }
          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
          const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);
          if (!this._isReady(subMesh, hardwareInstancedRendering)) {
            return false;
          }
        }
      }
      return true;
    };
    this._volumetricLightScatteringRTT.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {
      const engine2 = scene.getEngine();
      let index;
      if (depthOnlySubMeshes.length) {
        engine2.setColorWrite(false);
        for (index = 0; index < depthOnlySubMeshes.length; index++) {
          renderSubMesh(depthOnlySubMeshes.data[index]);
        }
        engine2.setColorWrite(true);
      }
      for (index = 0; index < opaqueSubMeshes.length; index++) {
        renderSubMesh(opaqueSubMeshes.data[index]);
      }
      for (index = 0; index < alphaTestSubMeshes.length; index++) {
        renderSubMesh(alphaTestSubMeshes.data[index]);
      }
      if (transparentSubMeshes.length) {
        for (index = 0; index < transparentSubMeshes.length; index++) {
          const submesh = transparentSubMeshes.data[index];
          const boundingInfo = submesh.getBoundingInfo();
          if (boundingInfo && scene.activeCamera) {
            submesh._alphaIndex = submesh.getMesh().alphaIndex;
            submesh._distanceToCamera = boundingInfo.boundingSphere.centerWorld.subtract(scene.activeCamera.position).length();
          }
        }
        const sortedArray = transparentSubMeshes.data.slice(0, transparentSubMeshes.length);
        sortedArray.sort((a, b) => {
          if (a._alphaIndex > b._alphaIndex) {
            return 1;
          }
          if (a._alphaIndex < b._alphaIndex) {
            return -1;
          }
          if (a._distanceToCamera < b._distanceToCamera) {
            return 1;
          }
          if (a._distanceToCamera > b._distanceToCamera) {
            return -1;
          }
          return 0;
        });
        engine2.setAlphaMode(2);
        for (index = 0; index < sortedArray.length; index++) {
          renderSubMesh(sortedArray[index]);
        }
        engine2.setAlphaMode(0);
      }
    };
  }
  _updateMeshScreenCoordinates(scene) {
    const transform = scene.getTransformMatrix();
    let meshPosition;
    if (this.useCustomMeshPosition) {
      meshPosition = this.customMeshPosition;
    } else if (this.attachedNode) {
      meshPosition = this.attachedNode.position;
    } else {
      meshPosition = this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;
    }
    const pos = Vector3.Project(meshPosition, Matrix.Identity(), transform, this._viewPort);
    this._screenCoordinates.x = pos.x / this._viewPort.width;
    this._screenCoordinates.y = pos.y / this._viewPort.height;
    if (this.invert) {
      this._screenCoordinates.y = 1 - this._screenCoordinates.y;
    }
  }
  static CreateDefaultMesh(name137, scene) {
    const mesh = CreatePlane(name137, { size: 1 }, scene);
    mesh.billboardMode = AbstractMesh.BILLBOARDMODE_ALL;
    const material = new StandardMaterial(name137 + "Material", scene);
    material.emissiveColor = new Color3(1, 1, 1);
    mesh.material = material;
    return mesh;
  }
};
__decorate([
  serializeAsVector3()
], VolumetricLightScatteringPostProcess.prototype, "customMeshPosition", void 0);
__decorate([
  serialize()
], VolumetricLightScatteringPostProcess.prototype, "useCustomMeshPosition", void 0);
__decorate([
  serialize()
], VolumetricLightScatteringPostProcess.prototype, "invert", void 0);
__decorate([
  serializeAsMeshReference()
], VolumetricLightScatteringPostProcess.prototype, "mesh", void 0);
__decorate([
  serialize()
], VolumetricLightScatteringPostProcess.prototype, "excludedMeshes", void 0);
__decorate([
  serialize()
], VolumetricLightScatteringPostProcess.prototype, "includedMeshes", void 0);
__decorate([
  serialize()
], VolumetricLightScatteringPostProcess.prototype, "exposure", void 0);
__decorate([
  serialize()
], VolumetricLightScatteringPostProcess.prototype, "decay", void 0);
__decorate([
  serialize()
], VolumetricLightScatteringPostProcess.prototype, "weight", void 0);
__decorate([
  serialize()
], VolumetricLightScatteringPostProcess.prototype, "density", void 0);
RegisterClass("BABYLON.VolumetricLightScatteringPostProcess", VolumetricLightScatteringPostProcess);

// node_modules/@babylonjs/core/Shaders/screenSpaceCurvature.fragment.js
var name107 = "screenSpaceCurvaturePixelShader";
var shader107 = `precision highp float;
varying vec2 vUV;
uniform sampler2D textureSampler;
uniform sampler2D normalSampler;
uniform float curvature_ridge;
uniform float curvature_valley;
#ifndef CURVATURE_OFFSET
#define CURVATURE_OFFSET 1
#endif
float curvature_soft_clamp(float curvature,float control)
{
if (curvature<0.5/control)
return curvature*(1.0-curvature*control);
return 0.25/control;
}
float calculate_curvature(ivec2 texel,float ridge,float valley)
{
vec2 normal_up =texelFetch(normalSampler,texel+ivec2(0, CURVATURE_OFFSET),0).rb;
vec2 normal_down =texelFetch(normalSampler,texel+ivec2(0,-CURVATURE_OFFSET),0).rb;
vec2 normal_left =texelFetch(normalSampler,texel+ivec2(-CURVATURE_OFFSET,0),0).rb;
vec2 normal_right=texelFetch(normalSampler,texel+ivec2( CURVATURE_OFFSET,0),0).rb;
float normal_diff=((normal_up.g-normal_down.g)+(normal_right.r-normal_left.r));
if (normal_diff<0.0)
return -2.0*curvature_soft_clamp(-normal_diff,valley);
return 2.0*curvature_soft_clamp(normal_diff,ridge);
}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{
ivec2 texel=ivec2(gl_FragCoord.xy);
vec4 baseColor=texture2D(textureSampler,vUV);
float curvature=calculate_curvature(texel,curvature_ridge,curvature_valley);
baseColor.rgb*=curvature+1.0;
gl_FragColor=baseColor;
}`;
ShaderStore.ShadersStore[name107] = shader107;

// node_modules/@babylonjs/core/PostProcesses/screenSpaceCurvaturePostProcess.js
var ScreenSpaceCurvaturePostProcess = class extends PostProcess {
  constructor(name137, scene, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
    super(name137, "screenSpaceCurvature", ["curvature_ridge", "curvature_valley"], ["textureSampler", "normalSampler"], options, camera, samplingMode, engine, reusable, void 0, textureType, void 0, null, blockCompilation);
    this.ridge = 1;
    this.valley = 1;
    this._geometryBufferRenderer = scene.enableGeometryBufferRenderer();
    if (!this._geometryBufferRenderer) {
      Logger.Error("Multiple Render Target support needed for screen space curvature post process. Please use IsSupported test first.");
    } else {
      this.onApply = (effect) => {
        effect.setFloat("curvature_ridge", 0.5 / Math.max(this.ridge * this.ridge, 1e-4));
        effect.setFloat("curvature_valley", 0.7 / Math.max(this.valley * this.valley, 1e-4));
        const normalTexture = this._geometryBufferRenderer.getGBuffer().textures[1];
        effect.setTexture("normalSampler", normalTexture);
      };
    }
  }
  getClassName() {
    return "ScreenSpaceCurvaturePostProcess";
  }
  static get IsSupported() {
    const engine = EngineStore.LastCreatedEngine;
    if (!engine) {
      return false;
    }
    return engine.getCaps().drawBuffersExtension;
  }
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new ScreenSpaceCurvaturePostProcess(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.textureType, parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  }
};
__decorate([
  serialize()
], ScreenSpaceCurvaturePostProcess.prototype, "ridge", void 0);
__decorate([
  serialize()
], ScreenSpaceCurvaturePostProcess.prototype, "valley", void 0);
RegisterClass("BABYLON.ScreenSpaceCurvaturePostProcess", ScreenSpaceCurvaturePostProcess);

// node_modules/@babylonjs/core/Shaders/ShadersInclude/boundingBoxRendererFragmentDeclaration.js
var name108 = "boundingBoxRendererFragmentDeclaration";
var shader108 = `uniform vec4 color;
`;
ShaderStore.IncludesShadersStore[name108] = shader108;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/boundingBoxRendererUboDeclaration.js
var name109 = "boundingBoxRendererUboDeclaration";
var shader109 = `#ifdef WEBGL2
uniform vec4 color;
uniform mat4 world;
uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
#else
layout(std140,column_major) uniform;
uniform BoundingBoxRenderer {
vec4 color;
mat4 world;
mat4 viewProjection;
mat4 viewProjectionR;
};
#endif
`;
ShaderStore.IncludesShadersStore[name109] = shader109;

// node_modules/@babylonjs/core/Shaders/boundingBoxRenderer.fragment.js
var name110 = "boundingBoxRendererPixelShader";
var shader110 = `#include<__decl__boundingBoxRendererFragment>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
gl_FragColor=color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name110] = shader110;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/boundingBoxRendererVertexDeclaration.js
var name111 = "boundingBoxRendererVertexDeclaration";
var shader111 = `uniform mat4 world;
uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
`;
ShaderStore.IncludesShadersStore[name111] = shader111;

// node_modules/@babylonjs/core/Shaders/boundingBoxRenderer.vertex.js
var name112 = "boundingBoxRendererVertexShader";
var shader112 = `attribute vec3 position;
#include<__decl__boundingBoxRendererVertex>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec4 worldPos=world*vec4(position,1.0);
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {
gl_Position=viewProjection*worldPos;
} else {
gl_Position=viewProjectionR*worldPos;
}
#else
gl_Position=viewProjection*worldPos;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name112] = shader112;

// node_modules/@babylonjs/core/Rendering/boundingBoxRenderer.js
Object.defineProperty(Scene.prototype, "forceShowBoundingBoxes", {
  get: function() {
    return this._forceShowBoundingBoxes || false;
  },
  set: function(value) {
    this._forceShowBoundingBoxes = value;
    if (value) {
      this.getBoundingBoxRenderer();
    }
  },
  enumerable: true,
  configurable: true
});
Scene.prototype.getBoundingBoxRenderer = function() {
  if (!this._boundingBoxRenderer) {
    this._boundingBoxRenderer = new BoundingBoxRenderer(this);
  }
  return this._boundingBoxRenderer;
};
Object.defineProperty(AbstractMesh.prototype, "showBoundingBox", {
  get: function() {
    return this._showBoundingBox || false;
  },
  set: function(value) {
    this._showBoundingBox = value;
    if (value) {
      this.getScene().getBoundingBoxRenderer();
    }
  },
  enumerable: true,
  configurable: true
});
var BoundingBoxRenderer = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_BOUNDINGBOXRENDERER;
    this.frontColor = new Color3(1, 1, 1);
    this.backColor = new Color3(0.1, 0.1, 0.1);
    this.showBackLines = true;
    this.onBeforeBoxRenderingObservable = new Observable();
    this.onAfterBoxRenderingObservable = new Observable();
    this.onResourcesReadyObservable = new Observable();
    this.enabled = true;
    this.renderList = new SmartArray(32);
    this._vertexBuffers = {};
    this._fillIndexBuffer = null;
    this._fillIndexData = null;
    this.scene = scene;
    scene._addComponent(this);
    this._uniformBufferFront = new UniformBuffer(this.scene.getEngine(), void 0, void 0, "BoundingBoxRendererFront", !this.scene.getEngine().isWebGPU);
    this._buildUniformLayout(this._uniformBufferFront);
    this._uniformBufferBack = new UniformBuffer(this.scene.getEngine(), void 0, void 0, "BoundingBoxRendererBack", !this.scene.getEngine().isWebGPU);
    this._buildUniformLayout(this._uniformBufferBack);
  }
  _buildUniformLayout(ubo) {
    ubo.addUniform("color", 4);
    ubo.addUniform("world", 16);
    ubo.addUniform("viewProjection", 16);
    ubo.addUniform("viewProjectionR", 16);
    ubo.create();
  }
  register() {
    this.scene._beforeEvaluateActiveMeshStage.registerStep(SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset);
    this.scene._preActiveMeshStage.registerStep(SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER, this, this._preActiveMesh);
    this.scene._evaluateSubMeshStage.registerStep(SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh);
    this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);
  }
  _evaluateSubMesh(mesh, subMesh) {
    if (mesh.showSubMeshesBoundingBox) {
      const boundingInfo = subMesh.getBoundingInfo();
      if (boundingInfo !== null && boundingInfo !== void 0) {
        boundingInfo.boundingBox._tag = mesh.renderingGroupId;
        this.renderList.push(boundingInfo.boundingBox);
      }
    }
  }
  _preActiveMesh(mesh) {
    if (mesh.showBoundingBox || this.scene.forceShowBoundingBoxes) {
      const boundingInfo = mesh.getBoundingInfo();
      boundingInfo.boundingBox._tag = mesh.renderingGroupId;
      this.renderList.push(boundingInfo.boundingBox);
    }
  }
  _prepareResources() {
    if (this._colorShader) {
      return;
    }
    this._colorShader = new ShaderMaterial("colorShader", this.scene, "boundingBoxRenderer", {
      attributes: [VertexBuffer.PositionKind],
      uniforms: ["world", "viewProjection", "viewProjectionR", "color"],
      uniformBuffers: ["BoundingBoxRenderer"]
    }, false);
    this._colorShader.doNotSerialize = true;
    this._colorShader.reservedDataStore = {
      hidden: true
    };
    this._colorShaderForOcclusionQuery = new ShaderMaterial("colorShaderOccQuery", this.scene, "boundingBoxRenderer", {
      attributes: [VertexBuffer.PositionKind],
      uniforms: ["world", "viewProjection", "viewProjectionR", "color"],
      uniformBuffers: ["BoundingBoxRenderer"]
    }, true);
    this._colorShaderForOcclusionQuery.doNotSerialize = true;
    this._colorShaderForOcclusionQuery.reservedDataStore = {
      hidden: true
    };
    const engine = this.scene.getEngine();
    const boxdata = CreateBoxVertexData({ size: 1 });
    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, boxdata.positions, VertexBuffer.PositionKind, false);
    this._createIndexBuffer();
    this._fillIndexData = boxdata.indices;
    this.onResourcesReadyObservable.notifyObservers(this);
  }
  _createIndexBuffer() {
    const engine = this.scene.getEngine();
    this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);
  }
  rebuild() {
    const vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vb) {
      vb._rebuild();
    }
    this._createIndexBuffer();
  }
  reset() {
    this.renderList.reset();
  }
  render(renderingGroupId) {
    var _a, _b;
    if (this.renderList.length === 0 || !this.enabled) {
      return;
    }
    this._prepareResources();
    if (!this._colorShader.isReady()) {
      return;
    }
    const engine = this.scene.getEngine();
    engine.setDepthWrite(false);
    const frontColor = this.frontColor.toColor4();
    const backColor = this.backColor.toColor4();
    const transformMatrix = this.scene.getTransformMatrix();
    for (let boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {
      const boundingBox = this.renderList.data[boundingBoxIndex];
      if (boundingBox._tag !== renderingGroupId) {
        continue;
      }
      this._createWrappersForBoundingBox(boundingBox);
      this.onBeforeBoxRenderingObservable.notifyObservers(boundingBox);
      const min = boundingBox.minimum;
      const max = boundingBox.maximum;
      const diff = max.subtract(min);
      const median = min.add(diff.scale(0.5));
      const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());
      const useReverseDepthBuffer = engine.useReverseDepthBuffer;
      if (this.showBackLines) {
        const drawWrapperBack = (_a = boundingBox._drawWrapperBack) !== null && _a !== void 0 ? _a : this._colorShader._getDrawWrapper();
        this._colorShader._preBind(drawWrapperBack);
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());
        if (useReverseDepthBuffer) {
          engine.setDepthFunctionToLessOrEqual();
        } else {
          engine.setDepthFunctionToGreaterOrEqual();
        }
        this._uniformBufferBack.bindToEffect(drawWrapperBack.effect, "BoundingBoxRenderer");
        this._uniformBufferBack.updateDirectColor4("color", backColor);
        this._uniformBufferBack.updateMatrix("world", worldMatrix);
        this._uniformBufferBack.updateMatrix("viewProjection", transformMatrix);
        this._uniformBufferBack.update();
        engine.drawElementsType(Material.LineListDrawMode, 0, 24);
      }
      const drawWrapperFront = (_b = boundingBox._drawWrapperFront) !== null && _b !== void 0 ? _b : this._colorShader._getDrawWrapper();
      this._colorShader._preBind(drawWrapperFront);
      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());
      if (useReverseDepthBuffer) {
        engine.setDepthFunctionToGreater();
      } else {
        engine.setDepthFunctionToLess();
      }
      this._uniformBufferFront.bindToEffect(drawWrapperFront.effect, "BoundingBoxRenderer");
      this._uniformBufferFront.updateDirectColor4("color", frontColor);
      this._uniformBufferFront.updateMatrix("world", worldMatrix);
      this._uniformBufferFront.updateMatrix("viewProjection", transformMatrix);
      this._uniformBufferFront.update();
      engine.drawElementsType(Material.LineListDrawMode, 0, 24);
      this.onAfterBoxRenderingObservable.notifyObservers(boundingBox);
    }
    this._colorShader.unbind();
    engine.setDepthFunctionToLessOrEqual();
    engine.setDepthWrite(true);
  }
  _createWrappersForBoundingBox(boundingBox) {
    if (!boundingBox._drawWrapperFront) {
      const engine = this.scene.getEngine();
      boundingBox._drawWrapperFront = new DrawWrapper(engine);
      boundingBox._drawWrapperBack = new DrawWrapper(engine);
      boundingBox._drawWrapperFront.setEffect(this._colorShader.getEffect());
      boundingBox._drawWrapperBack.setEffect(this._colorShader.getEffect());
    }
  }
  renderOcclusionBoundingBox(mesh) {
    const engine = this.scene.getEngine();
    if (this._renderPassIdForOcclusionQuery === void 0) {
      this._renderPassIdForOcclusionQuery = engine.createRenderPassId(`Render pass for occlusion query`);
    }
    const currentRenderPassId = engine.currentRenderPassId;
    engine.currentRenderPassId = this._renderPassIdForOcclusionQuery;
    this._prepareResources();
    const subMesh = mesh.subMeshes[0];
    if (!this._colorShaderForOcclusionQuery.isReady(mesh, void 0, subMesh) || !mesh.hasBoundingInfo) {
      engine.currentRenderPassId = currentRenderPassId;
      return;
    }
    if (!this._fillIndexBuffer) {
      this._fillIndexBuffer = engine.createIndexBuffer(this._fillIndexData);
    }
    const useReverseDepthBuffer = engine.useReverseDepthBuffer;
    engine.setDepthWrite(false);
    engine.setColorWrite(false);
    const boundingBox = mesh.getBoundingInfo().boundingBox;
    const min = boundingBox.minimum;
    const max = boundingBox.maximum;
    const diff = max.subtract(min);
    const median = min.add(diff.scale(0.5));
    const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());
    const drawWrapper = subMesh._drawWrapper;
    this._colorShaderForOcclusionQuery._preBind(drawWrapper);
    engine.bindBuffers(this._vertexBuffers, this._fillIndexBuffer, drawWrapper.effect);
    if (useReverseDepthBuffer) {
      engine.setDepthFunctionToGreater();
    } else {
      engine.setDepthFunctionToLess();
    }
    this.scene.resetCachedMaterial();
    this._uniformBufferFront.bindToEffect(drawWrapper.effect, "BoundingBoxRenderer");
    this._uniformBufferFront.updateMatrix("world", worldMatrix);
    this._uniformBufferFront.updateMatrix("viewProjection", this.scene.getTransformMatrix());
    this._uniformBufferFront.update();
    engine.drawElementsType(Material.TriangleFillMode, 0, 36);
    this._colorShaderForOcclusionQuery.unbind();
    engine.setDepthFunctionToLessOrEqual();
    engine.setDepthWrite(true);
    engine.setColorWrite(true);
    engine.currentRenderPassId = currentRenderPassId;
  }
  dispose() {
    if (this._renderPassIdForOcclusionQuery !== void 0) {
      this.scene.getEngine().releaseRenderPassId(this._renderPassIdForOcclusionQuery);
      this._renderPassIdForOcclusionQuery = void 0;
    }
    if (!this._colorShader) {
      return;
    }
    this.onBeforeBoxRenderingObservable.clear();
    this.onAfterBoxRenderingObservable.clear();
    this.onResourcesReadyObservable.clear();
    this.renderList.dispose();
    this._colorShader.dispose();
    this._colorShaderForOcclusionQuery.dispose();
    this._uniformBufferFront.dispose();
    this._uniformBufferBack.dispose();
    const buffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (buffer) {
      buffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    this.scene.getEngine()._releaseBuffer(this._indexBuffer);
    if (this._fillIndexBuffer) {
      this.scene.getEngine()._releaseBuffer(this._fillIndexBuffer);
      this._fillIndexBuffer = null;
    }
  }
};

// node_modules/@babylonjs/core/Rendering/depthRendererSceneComponent.js
Scene.prototype.enableDepthRenderer = function(camera, storeNonLinearDepth = false, force32bitsFloat = false, samplingMode = 3) {
  camera = camera || this.activeCamera;
  if (!camera) {
    throw "No camera available to enable depth renderer";
  }
  if (!this._depthRenderer) {
    this._depthRenderer = {};
  }
  if (!this._depthRenderer[camera.id]) {
    const supportFullfloat = !!this.getEngine().getCaps().textureFloatRender;
    let textureType = 0;
    if (this.getEngine().getCaps().textureHalfFloatRender && (!force32bitsFloat || !supportFullfloat)) {
      textureType = 2;
    } else if (supportFullfloat) {
      textureType = 1;
    } else {
      textureType = 0;
    }
    this._depthRenderer[camera.id] = new DepthRenderer(this, textureType, camera, storeNonLinearDepth, samplingMode);
  }
  return this._depthRenderer[camera.id];
};
Scene.prototype.disableDepthRenderer = function(camera) {
  camera = camera || this.activeCamera;
  if (!camera || !this._depthRenderer || !this._depthRenderer[camera.id]) {
    return;
  }
  this._depthRenderer[camera.id].dispose();
};
var DepthRendererSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_DEPTHRENDERER;
    this.scene = scene;
  }
  register() {
    this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_DEPTHRENDERER, this, this._gatherRenderTargets);
    this.scene._gatherActiveCameraRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER, this, this._gatherActiveCameraRenderTargets);
  }
  rebuild() {
  }
  dispose() {
    for (const key in this.scene._depthRenderer) {
      this.scene._depthRenderer[key].dispose();
    }
  }
  _gatherRenderTargets(renderTargets) {
    if (this.scene._depthRenderer) {
      for (const key in this.scene._depthRenderer) {
        const depthRenderer = this.scene._depthRenderer[key];
        if (depthRenderer.enabled && !depthRenderer.useOnlyInActiveCamera) {
          renderTargets.push(depthRenderer.getDepthMap());
        }
      }
    }
  }
  _gatherActiveCameraRenderTargets(renderTargets) {
    if (this.scene._depthRenderer) {
      for (const key in this.scene._depthRenderer) {
        const depthRenderer = this.scene._depthRenderer[key];
        if (depthRenderer.enabled && depthRenderer.useOnlyInActiveCamera && this.scene.activeCamera.id === key) {
          renderTargets.push(depthRenderer.getDepthMap());
        }
      }
    }
  }
};
DepthRenderer._SceneComponentInitialization = (scene) => {
  let component = scene._getComponent(SceneComponentConstants.NAME_DEPTHRENDERER);
  if (!component) {
    component = new DepthRendererSceneComponent(scene);
    scene._addComponent(component);
  }
};

// node_modules/@babylonjs/core/Shaders/oitFinal.fragment.js
var name113 = "oitFinalPixelShader";
var shader113 = `precision highp float;
uniform sampler2D uFrontColor;
uniform sampler2D uBackColor;
void main() {
ivec2 fragCoord=ivec2(gl_FragCoord.xy);
vec4 frontColor=texelFetch(uFrontColor,fragCoord,0);
vec4 backColor=texelFetch(uBackColor,fragCoord,0);
float alphaMultiplier=1.0-frontColor.a;
glFragColor=vec4(
frontColor.rgb+alphaMultiplier*backColor.rgb,
frontColor.a+backColor.a
);
}`;
ShaderStore.ShadersStore[name113] = shader113;

// node_modules/@babylonjs/core/Shaders/oitBackBlend.fragment.js
var name114 = "oitBackBlendPixelShader";
var shader114 = `precision highp float;
uniform sampler2D uBackColor;
void main() {
glFragColor=texelFetch(uBackColor,ivec2(gl_FragCoord.xy),0);
if (glFragColor.a==0.0) { 
discard;
}
}`;
ShaderStore.ShadersStore[name114] = shader114;

// node_modules/@babylonjs/core/Rendering/depthPeelingRenderer.js
var DepthPeelingEffectConfiguration = class {
  constructor() {
    this.enabled = true;
    this.name = "depthPeeling";
    this.texturesRequired = [4];
  }
};
var DepthPeelingRenderer = class {
  constructor(scene, passCount = 5) {
    this._thinTextures = [];
    this._currentPingPongState = 0;
    this._layoutCacheFormat = [[true], [true, true], [true, true, true]];
    this._layoutCache = [];
    this._candidateSubMeshes = new SmartArray(10);
    this._excludedSubMeshes = new SmartArray(10);
    this._excludedMeshes = [];
    this._colorCache = [
      new Color4(DepthPeelingRenderer._DEPTH_CLEAR_VALUE, DepthPeelingRenderer._DEPTH_CLEAR_VALUE, 0, 0),
      new Color4(-DepthPeelingRenderer._MIN_DEPTH, DepthPeelingRenderer._MAX_DEPTH, 0, 0),
      new Color4(0, 0, 0, 0)
    ];
    this._scene = scene;
    this._engine = scene.getEngine();
    this._passCount = passCount;
    if (!scene.enablePrePassRenderer()) {
      Logger.Warn("Depth peeling for order independant transparency could not enable PrePass, aborting.");
      return;
    }
    for (let i = 0; i < this._layoutCacheFormat.length; ++i) {
      this._layoutCache[i] = this._engine.buildTextureLayout(this._layoutCacheFormat[i]);
    }
    this._renderPassIds = [];
    this.useRenderPasses = false;
    this._prePassEffectConfiguration = new DepthPeelingEffectConfiguration();
    this._createTextures();
    this._createEffects();
  }
  get passCount() {
    return this._passCount;
  }
  set passCount(count) {
    if (this._passCount === count) {
      return;
    }
    this._passCount = count;
    this._createRenderPassIds();
  }
  get useRenderPasses() {
    return this._useRenderPasses;
  }
  set useRenderPasses(usePasses) {
    if (this._useRenderPasses === usePasses) {
      return;
    }
    this._useRenderPasses = usePasses;
    this._createRenderPassIds();
  }
  addExcludedMesh(mesh) {
    if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {
      this._excludedMeshes.push(mesh.uniqueId);
    }
  }
  removeExcludedMesh(mesh) {
    const index = this._excludedMeshes.indexOf(mesh.uniqueId);
    if (index !== -1) {
      this._excludedMeshes.splice(index, 1);
    }
  }
  _createRenderPassIds() {
    this._releaseRenderPassIds();
    if (this._useRenderPasses) {
      for (let i = 0; i < this._passCount + 1; ++i) {
        if (!this._renderPassIds[i]) {
          this._renderPassIds[i] = this._engine.createRenderPassId(`DepthPeelingRenderer - pass #${i}`);
        }
      }
    }
  }
  _releaseRenderPassIds() {
    for (let i = 0; i < this._renderPassIds.length; ++i) {
      this._engine.releaseRenderPassId(this._renderPassIds[i]);
    }
    this._renderPassIds = [];
  }
  _createTextures() {
    const size = {
      width: this._engine.getRenderWidth(),
      height: this._engine.getRenderHeight()
    };
    this._depthMrts = [new MultiRenderTarget("depthPeelingDepth0", size, 3, this._scene), new MultiRenderTarget("depthPeelingDepth1", size, 3, this._scene)];
    this._colorMrts = [
      new MultiRenderTarget("depthPeelingColor0", size, 2, this._scene, { generateDepthBuffer: false }),
      new MultiRenderTarget("depthPeelingColor1", size, 2, this._scene, { generateDepthBuffer: false })
    ];
    this._blendBackMrt = new MultiRenderTarget("depthPeelingBack", size, 1, this._scene, { generateDepthBuffer: false });
    this._outputRT = new RenderTargetTexture("depthPeelingOutput", size, this._scene, false);
    const optionsArray = [
      {
        format: 7,
        samplingMode: 1,
        type: this._engine.getCaps().textureFloatLinearFiltering ? 1 : 2
      },
      {
        format: 5,
        samplingMode: 1,
        type: 2
      }
    ];
    for (let i = 0; i < 2; i++) {
      const depthTexture = this._engine._createInternalTexture(size, optionsArray[0], false);
      const frontColorTexture = this._engine._createInternalTexture(size, optionsArray[1], false);
      const backColorTexture = this._engine._createInternalTexture(size, optionsArray[1], false);
      this._depthMrts[i].setInternalTexture(depthTexture, 0);
      this._depthMrts[i].setInternalTexture(frontColorTexture, 1);
      this._depthMrts[i].setInternalTexture(backColorTexture, 2);
      this._colorMrts[i].setInternalTexture(frontColorTexture, 0);
      this._colorMrts[i].setInternalTexture(backColorTexture, 1);
      this._thinTextures.push(new ThinTexture(depthTexture), new ThinTexture(frontColorTexture), new ThinTexture(backColorTexture));
    }
  }
  _disposeTextures() {
    for (let i = 0; i < this._thinTextures.length; i++) {
      if (i === 6) {
        continue;
      }
      this._thinTextures[i].dispose();
    }
    for (let i = 0; i < 2; i++) {
      this._depthMrts[i].dispose(true);
      this._colorMrts[i].dispose(true);
      this._blendBackMrt.dispose(true);
    }
    this._outputRT.dispose();
    this._thinTextures = [];
    this._colorMrts = [];
    this._depthMrts = [];
  }
  _updateTextures() {
    if (this._depthMrts[0].getSize().width !== this._engine.getRenderWidth() || this._depthMrts[0].getSize().height !== this._engine.getRenderHeight()) {
      this._disposeTextures();
      this._createTextures();
    }
    return this._updateTextureReferences();
  }
  _updateTextureReferences() {
    var _a;
    const prePassRenderer = this._scene.prePassRenderer;
    if (!prePassRenderer) {
      return false;
    }
    const textureIndex = prePassRenderer.getIndex(4);
    const prePassTexture = ((_a = prePassRenderer.defaultRT.textures) === null || _a === void 0 ? void 0 : _a.length) ? prePassRenderer.defaultRT.textures[textureIndex].getInternalTexture() : null;
    if (!prePassTexture) {
      return false;
    }
    if (this._blendBackTexture !== prePassTexture) {
      this._blendBackTexture = prePassTexture;
      this._blendBackMrt.setInternalTexture(this._blendBackTexture, 0);
      if (this._thinTextures[6]) {
        this._thinTextures[6].dispose();
      }
      this._thinTextures[6] = new ThinTexture(this._blendBackTexture);
      prePassRenderer.defaultRT.renderTarget._shareDepth(this._depthMrts[0].renderTarget);
    }
    return true;
  }
  _createEffects() {
    this._blendBackEffectWrapper = new EffectWrapper({
      fragmentShader: "oitBackBlend",
      useShaderStore: true,
      engine: this._engine,
      samplerNames: ["uBackColor"],
      uniformNames: []
    });
    this._blendBackEffectWrapperPingPong = new EffectWrapper({
      fragmentShader: "oitBackBlend",
      useShaderStore: true,
      engine: this._engine,
      samplerNames: ["uBackColor"],
      uniformNames: []
    });
    this._finalEffectWrapper = new EffectWrapper({
      fragmentShader: "oitFinal",
      useShaderStore: true,
      engine: this._engine,
      samplerNames: ["uFrontColor", "uBackColor"],
      uniformNames: []
    });
    this._effectRenderer = new EffectRenderer(this._engine);
  }
  setPrePassRenderer(prePassRenderer) {
    prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);
  }
  bind(effect) {
    effect.setTexture("oitDepthSampler", this._thinTextures[this._currentPingPongState * 3]);
    effect.setTexture("oitFrontColorSampler", this._thinTextures[this._currentPingPongState * 3 + 1]);
  }
  _renderSubMeshes(transparentSubMeshes) {
    let mapMaterialContext;
    if (this._useRenderPasses) {
      mapMaterialContext = {};
    }
    for (let j = 0; j < transparentSubMeshes.length; j++) {
      const material = transparentSubMeshes.data[j].getMaterial();
      let previousShaderHotSwapping = true;
      let previousBFC = false;
      const subMesh = transparentSubMeshes.data[j];
      let drawWrapper;
      let firstDraw = false;
      if (this._useRenderPasses) {
        drawWrapper = subMesh._getDrawWrapper();
        firstDraw = !drawWrapper;
      }
      if (material) {
        previousShaderHotSwapping = material.allowShaderHotSwapping;
        previousBFC = material.backFaceCulling;
        material.allowShaderHotSwapping = false;
        material.backFaceCulling = false;
      }
      subMesh.render(false);
      if (firstDraw) {
        drawWrapper = subMesh._getDrawWrapper();
        if (drawWrapper.materialContext) {
          let newMaterialContext = mapMaterialContext[drawWrapper.materialContext.uniqueId];
          if (!newMaterialContext) {
            newMaterialContext = mapMaterialContext[drawWrapper.materialContext.uniqueId] = this._engine.createMaterialContext();
          }
          subMesh._getDrawWrapper().materialContext = newMaterialContext;
        }
      }
      if (material) {
        material.allowShaderHotSwapping = previousShaderHotSwapping;
        material.backFaceCulling = previousBFC;
      }
    }
  }
  _finalCompose(writeId) {
    var _a;
    const output = (_a = this._scene.prePassRenderer) === null || _a === void 0 ? void 0 : _a.setCustomOutput(this._outputRT);
    if (output) {
      this._engine.bindFramebuffer(this._outputRT.renderTarget);
    } else {
      this._engine.restoreDefaultFramebuffer();
    }
    this._engine.setAlphaMode(0);
    this._engine.applyStates();
    this._engine.enableEffect(this._finalEffectWrapper._drawWrapper);
    this._finalEffectWrapper.effect.setTexture("uFrontColor", this._thinTextures[writeId * 3 + 1]);
    this._finalEffectWrapper.effect.setTexture("uBackColor", this._thinTextures[6]);
    this._effectRenderer.render(this._finalEffectWrapper);
  }
  render(transparentSubMeshes) {
    this._candidateSubMeshes.length = 0;
    this._excludedSubMeshes.length = 0;
    if (!this._blendBackEffectWrapper.effect.isReady() || !this._blendBackEffectWrapperPingPong.effect.isReady() || !this._finalEffectWrapper.effect.isReady() || !this._updateTextures()) {
      return this._excludedSubMeshes;
    }
    for (let i = 0; i < transparentSubMeshes.length; i++) {
      const subMesh = transparentSubMeshes.data[i];
      const material = subMesh.getMaterial();
      if (material && (material.fillMode === Material.TriangleFanDrawMode || material.fillMode === Material.TriangleFillMode || material.fillMode === Material.TriangleStripDrawMode) && this._excludedMeshes.indexOf(subMesh.getMesh().uniqueId) === -1) {
        this._candidateSubMeshes.push(subMesh);
      } else {
        this._excludedSubMeshes.push(subMesh);
      }
    }
    if (!this._candidateSubMeshes.length) {
      this._engine.bindFramebuffer(this._colorMrts[1].renderTarget);
      this._engine.bindAttachments(this._layoutCache[1]);
      this._engine.clear(this._colorCache[2], true, false, false);
      this._engine.unBindFramebuffer(this._colorMrts[1].renderTarget);
      this._finalCompose(1);
      return this._excludedSubMeshes;
    }
    const currentRenderPassId = this._engine.currentRenderPassId;
    this._scene.prePassRenderer._enabled = false;
    if (this._useRenderPasses) {
      this._engine.currentRenderPassId = this._renderPassIds[0];
    }
    this._engine.bindFramebuffer(this._depthMrts[0].renderTarget);
    this._engine.bindAttachments(this._layoutCache[0]);
    this._engine.clear(this._colorCache[0], true, false, false);
    this._engine.unBindFramebuffer(this._depthMrts[0].renderTarget);
    this._engine.bindFramebuffer(this._depthMrts[1].renderTarget);
    this._engine.bindAttachments(this._layoutCache[0]);
    this._engine.clear(this._colorCache[1], true, false, false);
    this._engine.unBindFramebuffer(this._depthMrts[1].renderTarget);
    this._engine.bindFramebuffer(this._colorMrts[0].renderTarget);
    this._engine.bindAttachments(this._layoutCache[1]);
    this._engine.clear(this._colorCache[2], true, false, false);
    this._engine.unBindFramebuffer(this._colorMrts[0].renderTarget);
    this._engine.bindFramebuffer(this._colorMrts[1].renderTarget);
    this._engine.bindAttachments(this._layoutCache[1]);
    this._engine.clear(this._colorCache[2], true, false, false);
    this._engine.unBindFramebuffer(this._colorMrts[1].renderTarget);
    this._engine.bindFramebuffer(this._depthMrts[0].renderTarget);
    this._engine.bindAttachments(this._layoutCache[0]);
    this._engine.setAlphaMode(11);
    this._engine.setAlphaEquation(3);
    this._engine.depthCullingState.depthMask = false;
    this._engine.depthCullingState.depthTest = true;
    this._engine.applyStates();
    this._currentPingPongState = 1;
    this._renderSubMeshes(this._candidateSubMeshes);
    this._engine.unBindFramebuffer(this._depthMrts[0].renderTarget);
    this._scene.resetCachedMaterial();
    let readId = 0;
    let writeId = 0;
    for (let i = 0; i < this._passCount; i++) {
      readId = i % 2;
      writeId = 1 - readId;
      this._currentPingPongState = readId;
      if (this._useRenderPasses) {
        this._engine.currentRenderPassId = this._renderPassIds[i + 1];
      }
      this._engine.bindFramebuffer(this._depthMrts[writeId].renderTarget);
      this._engine.bindAttachments(this._layoutCache[0]);
      this._engine.clear(this._colorCache[0], true, false, false);
      this._engine.unBindFramebuffer(this._depthMrts[writeId].renderTarget);
      this._engine.bindFramebuffer(this._colorMrts[writeId].renderTarget);
      this._engine.bindAttachments(this._layoutCache[1]);
      this._engine.clear(this._colorCache[2], true, false, false);
      this._engine.unBindFramebuffer(this._colorMrts[writeId].renderTarget);
      this._engine.bindFramebuffer(this._depthMrts[writeId].renderTarget);
      this._engine.bindAttachments(this._layoutCache[2]);
      this._engine.setAlphaMode(11);
      this._engine.setAlphaEquation(3);
      this._engine.depthCullingState.depthTest = false;
      this._engine.applyStates();
      this._renderSubMeshes(this._candidateSubMeshes);
      this._engine.unBindFramebuffer(this._depthMrts[writeId].renderTarget);
      this._scene.resetCachedMaterial();
      this._engine.bindFramebuffer(this._blendBackMrt.renderTarget);
      this._engine.bindAttachments(this._layoutCache[0]);
      this._engine.setAlphaEquation(0);
      this._engine.setAlphaMode(17);
      this._engine.applyStates();
      const blendBackEffectWrapper = writeId === 0 || !this._useRenderPasses ? this._blendBackEffectWrapper : this._blendBackEffectWrapperPingPong;
      this._engine.enableEffect(blendBackEffectWrapper._drawWrapper);
      blendBackEffectWrapper.effect.setTexture("uBackColor", this._thinTextures[writeId * 3 + 2]);
      this._effectRenderer.render(blendBackEffectWrapper);
      this._engine.unBindFramebuffer(this._blendBackMrt.renderTarget);
    }
    this._engine.currentRenderPassId = currentRenderPassId;
    this._finalCompose(writeId);
    this._scene.prePassRenderer._enabled = true;
    this._engine.depthCullingState.depthMask = true;
    this._engine.depthCullingState.depthTest = true;
    return this._excludedSubMeshes;
  }
  dispose() {
    this._disposeTextures();
    this._blendBackEffectWrapper.dispose();
    this._finalEffectWrapper.dispose();
    this._effectRenderer.dispose();
    this._releaseRenderPassIds();
  }
};
DepthPeelingRenderer._DEPTH_CLEAR_VALUE = -99999;
DepthPeelingRenderer._MIN_DEPTH = 0;
DepthPeelingRenderer._MAX_DEPTH = 1;

// node_modules/@babylonjs/core/Rendering/depthPeelingSceneComponent.js
Object.defineProperty(Scene.prototype, "depthPeelingRenderer", {
  get: function() {
    if (!this._depthPeelingRenderer) {
      let component = this._getComponent(SceneComponentConstants.NAME_DEPTHPEELINGRENDERER);
      if (!component) {
        component = new DepthPeelingSceneComponent(this);
        this._addComponent(component);
      }
    }
    return this._depthPeelingRenderer;
  },
  set: function(value) {
    this._depthPeelingRenderer = value;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(Scene.prototype, "useOrderIndependentTransparency", {
  get: function() {
    return this._useOrderIndependentTransparency;
  },
  set: function(value) {
    var _a;
    if (this._useOrderIndependentTransparency === value) {
      return;
    }
    this._useOrderIndependentTransparency = value;
    this.markAllMaterialsAsDirty(63);
    (_a = this.prePassRenderer) === null || _a === void 0 ? void 0 : _a.markAsDirty();
  },
  enumerable: true,
  configurable: true
});
var DepthPeelingSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_DEPTHPEELINGRENDERER;
    this.scene = scene;
    scene.depthPeelingRenderer = new DepthPeelingRenderer(scene);
  }
  register() {
  }
  rebuild() {
  }
  dispose() {
    var _a;
    (_a = this.scene.depthPeelingRenderer) === null || _a === void 0 ? void 0 : _a.dispose();
    this.scene.depthPeelingRenderer = null;
  }
};

// node_modules/@babylonjs/core/Shaders/line.fragment.js
var name115 = "linePixelShader";
var shader115 = `#include<clipPlaneFragmentDeclaration>
uniform vec4 color;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
gl_FragColor=color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name115] = shader115;

// node_modules/@babylonjs/core/Shaders/line.vertex.js
var name116 = "lineVertexShader";
var shader116 = `#include<instancesDeclaration>
#include<clipPlaneVertexDeclaration>
attribute vec3 position;
attribute vec4 normal;
uniform mat4 viewProjection;
uniform float width;
uniform float aspectRatio;
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
mat4 worldViewProjection=viewProjection*finalWorld;
vec4 viewPosition=worldViewProjection*vec4(position,1.0);
vec4 viewPositionNext=worldViewProjection*vec4(normal.xyz,1.0);
vec2 currentScreen=viewPosition.xy/viewPosition.w;
vec2 nextScreen=viewPositionNext.xy/viewPositionNext.w;
currentScreen.x*=aspectRatio;
nextScreen.x*=aspectRatio;
vec2 dir=normalize(nextScreen-currentScreen);
vec2 normalDir=vec2(-dir.y,dir.x);
normalDir*=width/2.0;
normalDir.x/=aspectRatio;
vec4 offset=vec4(normalDir*normal.w,0.0,0.0);
gl_Position=viewPosition+offset;
#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
vec4 worldPos=finalWorld*vec4(position,1.0);
#include<clipPlaneVertex>
#endif
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name116] = shader116;

// node_modules/@babylonjs/core/Rendering/edgesRenderer.js
AbstractMesh.prototype.disableEdgesRendering = function() {
  if (this._edgesRenderer) {
    this._edgesRenderer.dispose();
    this._edgesRenderer = null;
  }
  return this;
};
AbstractMesh.prototype.enableEdgesRendering = function(epsilon = 0.95, checkVerticesInsteadOfIndices = false, options) {
  this.disableEdgesRendering();
  this._edgesRenderer = new EdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices, true, options);
  return this;
};
Object.defineProperty(AbstractMesh.prototype, "edgesRenderer", {
  get: function() {
    return this._edgesRenderer;
  },
  enumerable: true,
  configurable: true
});
LinesMesh.prototype.enableEdgesRendering = function(epsilon = 0.95, checkVerticesInsteadOfIndices = false) {
  this.disableEdgesRendering();
  this._edgesRenderer = new LineEdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices);
  return this;
};
InstancedLinesMesh.prototype.enableEdgesRendering = function(epsilon = 0.95, checkVerticesInsteadOfIndices = false) {
  LinesMesh.prototype.enableEdgesRendering.apply(this, arguments);
  return this;
};
var FaceAdjacencies = class {
  constructor() {
    this.edges = new Array();
    this.edgesConnectedCount = 0;
  }
};
var EdgesRenderer = class {
  constructor(source, epsilon = 0.95, checkVerticesInsteadOfIndices = false, generateEdgesLines = true, options) {
    var _a;
    this.edgesWidthScalerForOrthographic = 1e3;
    this.edgesWidthScalerForPerspective = 50;
    this._linesPositions = new Array();
    this._linesNormals = new Array();
    this._linesIndices = new Array();
    this._buffers = {};
    this._buffersForInstances = {};
    this._checkVerticesInsteadOfIndices = false;
    this.isEnabled = true;
    this.customInstances = new SmartArray(32);
    this._source = source;
    this._checkVerticesInsteadOfIndices = checkVerticesInsteadOfIndices;
    this._options = options !== null && options !== void 0 ? options : null;
    this._epsilon = epsilon;
    if (this._source.getScene().getEngine().isWebGPU) {
      this._drawWrapper = new DrawWrapper(source.getEngine());
    }
    this._prepareRessources();
    if (generateEdgesLines) {
      if ((_a = options === null || options === void 0 ? void 0 : options.useAlternateEdgeFinder) !== null && _a !== void 0 ? _a : true) {
        this._generateEdgesLinesAlternate();
      } else {
        this._generateEdgesLines();
      }
    }
    this._meshRebuildObserver = this._source.onRebuildObservable.add(() => {
      this._rebuild();
    });
    this._meshDisposeObserver = this._source.onDisposeObservable.add(() => {
      this.dispose();
    });
  }
  get linesPositions() {
    return this._linesPositions;
  }
  get linesNormals() {
    return this._linesNormals;
  }
  get linesIndices() {
    return this._linesIndices;
  }
  get lineShader() {
    return this._lineShader;
  }
  set lineShader(shader137) {
    this._lineShader = shader137;
  }
  static _GetShader(scene) {
    if (!scene._edgeRenderLineShader) {
      const shader137 = new ShaderMaterial("lineShader", scene, "line", {
        attributes: ["position", "normal"],
        uniforms: ["world", "viewProjection", "color", "width", "aspectRatio"]
      }, false);
      shader137.disableDepthWrite = true;
      shader137.backFaceCulling = false;
      shader137.checkReadyOnEveryCall = scene.getEngine().isWebGPU;
      scene._edgeRenderLineShader = shader137;
    }
    return scene._edgeRenderLineShader;
  }
  _prepareRessources() {
    if (this._lineShader) {
      return;
    }
    this._lineShader = EdgesRenderer._GetShader(this._source.getScene());
  }
  _rebuild() {
    let buffer = this._buffers[VertexBuffer.PositionKind];
    if (buffer) {
      buffer._rebuild();
    }
    buffer = this._buffers[VertexBuffer.NormalKind];
    if (buffer) {
      buffer._rebuild();
    }
    const scene = this._source.getScene();
    const engine = scene.getEngine();
    this._ib = engine.createIndexBuffer(this._linesIndices);
  }
  dispose() {
    var _a;
    this._source.onRebuildObservable.remove(this._meshRebuildObserver);
    this._source.onDisposeObservable.remove(this._meshDisposeObserver);
    let buffer = this._buffers[VertexBuffer.PositionKind];
    if (buffer) {
      buffer.dispose();
      this._buffers[VertexBuffer.PositionKind] = null;
    }
    buffer = this._buffers[VertexBuffer.NormalKind];
    if (buffer) {
      buffer.dispose();
      this._buffers[VertexBuffer.NormalKind] = null;
    }
    if (this._ib) {
      this._source.getScene().getEngine()._releaseBuffer(this._ib);
    }
    this._lineShader.dispose();
    (_a = this._drawWrapper) === null || _a === void 0 ? void 0 : _a.dispose();
  }
  _processEdgeForAdjacencies(pa, pb, p0, p1, p2) {
    if (pa === p0 && pb === p1 || pa === p1 && pb === p0) {
      return 0;
    }
    if (pa === p1 && pb === p2 || pa === p2 && pb === p1) {
      return 1;
    }
    if (pa === p2 && pb === p0 || pa === p0 && pb === p2) {
      return 2;
    }
    return -1;
  }
  _processEdgeForAdjacenciesWithVertices(pa, pb, p0, p1, p2) {
    const eps = 1e-10;
    if (pa.equalsWithEpsilon(p0, eps) && pb.equalsWithEpsilon(p1, eps) || pa.equalsWithEpsilon(p1, eps) && pb.equalsWithEpsilon(p0, eps)) {
      return 0;
    }
    if (pa.equalsWithEpsilon(p1, eps) && pb.equalsWithEpsilon(p2, eps) || pa.equalsWithEpsilon(p2, eps) && pb.equalsWithEpsilon(p1, eps)) {
      return 1;
    }
    if (pa.equalsWithEpsilon(p2, eps) && pb.equalsWithEpsilon(p0, eps) || pa.equalsWithEpsilon(p0, eps) && pb.equalsWithEpsilon(p2, eps)) {
      return 2;
    }
    return -1;
  }
  _checkEdge(faceIndex, edge, faceNormals, p0, p1) {
    let needToCreateLine;
    if (edge === void 0) {
      needToCreateLine = true;
    } else {
      const dotProduct = Vector3.Dot(faceNormals[faceIndex], faceNormals[edge]);
      needToCreateLine = dotProduct < this._epsilon;
    }
    if (needToCreateLine) {
      this.createLine(p0, p1, this._linesPositions.length / 3);
    }
  }
  createLine(p0, p1, offset) {
    this._linesPositions.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p1.x, p1.y, p1.z);
    this._linesNormals.push(p1.x, p1.y, p1.z, -1, p1.x, p1.y, p1.z, 1, p0.x, p0.y, p0.z, -1, p0.x, p0.y, p0.z, 1);
    this._linesIndices.push(offset, offset + 1, offset + 2, offset, offset + 2, offset + 3);
  }
  _tessellateTriangle(edgePoints, indexTriangle, indices, remapVertexIndices) {
    const makePointList = (edgePoints2, pointIndices, firstIndex) => {
      if (firstIndex >= 0) {
        pointIndices.push(firstIndex);
      }
      for (let i = 0; i < edgePoints2.length; ++i) {
        pointIndices.push(edgePoints2[i][0]);
      }
    };
    let startEdge = 0;
    if (edgePoints[1].length >= edgePoints[0].length && edgePoints[1].length >= edgePoints[2].length) {
      startEdge = 1;
    } else if (edgePoints[2].length >= edgePoints[0].length && edgePoints[2].length >= edgePoints[1].length) {
      startEdge = 2;
    }
    for (let e = 0; e < 3; ++e) {
      if (e === startEdge) {
        edgePoints[e].sort((a, b) => a[1] < b[1] ? -1 : a[1] > b[1] ? 1 : 0);
      } else {
        edgePoints[e].sort((a, b) => a[1] > b[1] ? -1 : a[1] < b[1] ? 1 : 0);
      }
    }
    const mainPointIndices = [], otherPointIndices = [];
    makePointList(edgePoints[startEdge], mainPointIndices, -1);
    const numMainPoints = mainPointIndices.length;
    for (let i = startEdge + 2; i >= startEdge + 1; --i) {
      makePointList(edgePoints[i % 3], otherPointIndices, i !== startEdge + 2 ? remapVertexIndices[indices[indexTriangle + (i + 1) % 3]] : -1);
    }
    const numOtherPoints = otherPointIndices.length;
    const idxMain = 0;
    const idxOther = 0;
    indices.push(remapVertexIndices[indices[indexTriangle + startEdge]], mainPointIndices[0], otherPointIndices[0]);
    indices.push(remapVertexIndices[indices[indexTriangle + (startEdge + 1) % 3]], otherPointIndices[numOtherPoints - 1], mainPointIndices[numMainPoints - 1]);
    const bucketIsMain = numMainPoints <= numOtherPoints;
    const bucketStep = bucketIsMain ? numMainPoints : numOtherPoints;
    const bucketLimit = bucketIsMain ? numOtherPoints : numMainPoints;
    const bucketIdxLimit = bucketIsMain ? numMainPoints - 1 : numOtherPoints - 1;
    const winding = bucketIsMain ? 0 : 1;
    let numTris = numMainPoints + numOtherPoints - 2;
    let bucketIdx = bucketIsMain ? idxMain : idxOther;
    let nbucketIdx = bucketIsMain ? idxOther : idxMain;
    const bucketPoints = bucketIsMain ? mainPointIndices : otherPointIndices;
    const nbucketPoints = bucketIsMain ? otherPointIndices : mainPointIndices;
    let bucket = 0;
    while (numTris-- > 0) {
      if (winding) {
        indices.push(bucketPoints[bucketIdx], nbucketPoints[nbucketIdx]);
      } else {
        indices.push(nbucketPoints[nbucketIdx], bucketPoints[bucketIdx]);
      }
      bucket += bucketStep;
      let lastIdx;
      if (bucket >= bucketLimit && bucketIdx < bucketIdxLimit) {
        lastIdx = bucketPoints[++bucketIdx];
        bucket -= bucketLimit;
      } else {
        lastIdx = nbucketPoints[++nbucketIdx];
      }
      indices.push(lastIdx);
    }
    indices[indexTriangle + 0] = indices[indices.length - 3];
    indices[indexTriangle + 1] = indices[indices.length - 2];
    indices[indexTriangle + 2] = indices[indices.length - 1];
    indices.length = indices.length - 3;
  }
  _generateEdgesLinesAlternate() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const positions = this._source.getVerticesData(VertexBuffer.PositionKind);
    let indices = this._source.getIndices();
    if (!indices || !positions) {
      return;
    }
    if (!Array.isArray(indices)) {
      indices = Array.from(indices);
    }
    const useFastVertexMerger = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.useFastVertexMerger) !== null && _b !== void 0 ? _b : true;
    const epsVertexMerge = useFastVertexMerger ? Math.round(-Math.log((_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.epsilonVertexMerge) !== null && _d !== void 0 ? _d : 1e-6) / Math.log(10)) : (_f = (_e = this._options) === null || _e === void 0 ? void 0 : _e.epsilonVertexMerge) !== null && _f !== void 0 ? _f : 1e-6;
    const remapVertexIndices = [];
    const uniquePositions = [];
    if (useFastVertexMerger) {
      const mapVertices = {};
      for (let v1 = 0; v1 < positions.length; v1 += 3) {
        const x1 = positions[v1 + 0], y1 = positions[v1 + 1], z1 = positions[v1 + 2];
        const key = x1.toFixed(epsVertexMerge) + "|" + y1.toFixed(epsVertexMerge) + "|" + z1.toFixed(epsVertexMerge);
        if (mapVertices[key] !== void 0) {
          remapVertexIndices.push(mapVertices[key]);
        } else {
          const idx = v1 / 3;
          mapVertices[key] = idx;
          remapVertexIndices.push(idx);
          uniquePositions.push(idx);
        }
      }
    } else {
      for (let v1 = 0; v1 < positions.length; v1 += 3) {
        const x1 = positions[v1 + 0], y1 = positions[v1 + 1], z1 = positions[v1 + 2];
        let found = false;
        for (let v2 = 0; v2 < v1 && !found; v2 += 3) {
          const x2 = positions[v2 + 0], y2 = positions[v2 + 1], z2 = positions[v2 + 2];
          if (Math.abs(x1 - x2) < epsVertexMerge && Math.abs(y1 - y2) < epsVertexMerge && Math.abs(z1 - z2) < epsVertexMerge) {
            remapVertexIndices.push(v2 / 3);
            found = true;
            break;
          }
        }
        if (!found) {
          remapVertexIndices.push(v1 / 3);
          uniquePositions.push(v1 / 3);
        }
      }
    }
    if ((_g = this._options) === null || _g === void 0 ? void 0 : _g.applyTessellation) {
      const epsVertexAligned = (_j = (_h = this._options) === null || _h === void 0 ? void 0 : _h.epsilonVertexAligned) !== null && _j !== void 0 ? _j : 1e-6;
      const mustTesselate = [];
      for (let index = 0; index < indices.length; index += 3) {
        let triangleToTessellate;
        for (let i = 0; i < 3; ++i) {
          const p0Index = remapVertexIndices[indices[index + i]];
          const p1Index = remapVertexIndices[indices[index + (i + 1) % 3]];
          const p2Index = remapVertexIndices[indices[index + (i + 2) % 3]];
          if (p0Index === p1Index) {
            continue;
          }
          const p0x = positions[p0Index * 3 + 0], p0y = positions[p0Index * 3 + 1], p0z = positions[p0Index * 3 + 2];
          const p1x = positions[p1Index * 3 + 0], p1y = positions[p1Index * 3 + 1], p1z = positions[p1Index * 3 + 2];
          const p0p1 = Math.sqrt((p1x - p0x) * (p1x - p0x) + (p1y - p0y) * (p1y - p0y) + (p1z - p0z) * (p1z - p0z));
          for (let v = 0; v < uniquePositions.length - 1; v++) {
            const vIndex = uniquePositions[v];
            if (vIndex === p0Index || vIndex === p1Index || vIndex === p2Index) {
              continue;
            }
            const x = positions[vIndex * 3 + 0], y = positions[vIndex * 3 + 1], z = positions[vIndex * 3 + 2];
            const p0p = Math.sqrt((x - p0x) * (x - p0x) + (y - p0y) * (y - p0y) + (z - p0z) * (z - p0z));
            const pp1 = Math.sqrt((x - p1x) * (x - p1x) + (y - p1y) * (y - p1y) + (z - p1z) * (z - p1z));
            if (Math.abs(p0p + pp1 - p0p1) < epsVertexAligned) {
              if (!triangleToTessellate) {
                triangleToTessellate = {
                  index,
                  edgesPoints: [[], [], []]
                };
                mustTesselate.push(triangleToTessellate);
              }
              triangleToTessellate.edgesPoints[i].push([vIndex, p0p]);
            }
          }
        }
      }
      for (let t = 0; t < mustTesselate.length; ++t) {
        const triangle = mustTesselate[t];
        this._tessellateTriangle(triangle.edgesPoints, triangle.index, indices, remapVertexIndices);
      }
      mustTesselate.length = 0;
    }
    const edges = {};
    for (let index = 0; index < indices.length; index += 3) {
      let faceNormal;
      for (let i = 0; i < 3; ++i) {
        let p0Index = remapVertexIndices[indices[index + i]];
        let p1Index = remapVertexIndices[indices[index + (i + 1) % 3]];
        const p2Index = remapVertexIndices[indices[index + (i + 2) % 3]];
        if (p0Index === p1Index || (p0Index === p2Index || p1Index === p2Index) && ((_k = this._options) === null || _k === void 0 ? void 0 : _k.removeDegeneratedTriangles)) {
          continue;
        }
        TmpVectors.Vector3[0].copyFromFloats(positions[p0Index * 3 + 0], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);
        TmpVectors.Vector3[1].copyFromFloats(positions[p1Index * 3 + 0], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);
        TmpVectors.Vector3[2].copyFromFloats(positions[p2Index * 3 + 0], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);
        if (!faceNormal) {
          TmpVectors.Vector3[1].subtractToRef(TmpVectors.Vector3[0], TmpVectors.Vector3[3]);
          TmpVectors.Vector3[2].subtractToRef(TmpVectors.Vector3[1], TmpVectors.Vector3[4]);
          faceNormal = Vector3.Cross(TmpVectors.Vector3[3], TmpVectors.Vector3[4]);
          faceNormal.normalize();
        }
        if (p0Index > p1Index) {
          const tmp = p0Index;
          p0Index = p1Index;
          p1Index = tmp;
        }
        const key = p0Index + "_" + p1Index;
        const ei = edges[key];
        if (ei) {
          if (!ei.done) {
            const dotProduct = Vector3.Dot(faceNormal, ei.normal);
            if (dotProduct < this._epsilon) {
              this.createLine(TmpVectors.Vector3[0], TmpVectors.Vector3[1], this._linesPositions.length / 3);
            }
            ei.done = true;
          }
        } else {
          edges[key] = { normal: faceNormal, done: false, index, i };
        }
      }
    }
    for (const key in edges) {
      const ei = edges[key];
      if (!ei.done) {
        const p0Index = remapVertexIndices[indices[ei.index + ei.i]];
        const p1Index = remapVertexIndices[indices[ei.index + (ei.i + 1) % 3]];
        TmpVectors.Vector3[0].copyFromFloats(positions[p0Index * 3 + 0], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);
        TmpVectors.Vector3[1].copyFromFloats(positions[p1Index * 3 + 0], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);
        this.createLine(TmpVectors.Vector3[0], TmpVectors.Vector3[1], this._linesPositions.length / 3);
      }
    }
    const engine = this._source.getScene().getEngine();
    this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);
    this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);
    this._buffersForInstances[VertexBuffer.PositionKind] = this._buffers[VertexBuffer.PositionKind];
    this._buffersForInstances[VertexBuffer.NormalKind] = this._buffers[VertexBuffer.NormalKind];
    this._ib = engine.createIndexBuffer(this._linesIndices);
    this._indicesCount = this._linesIndices.length;
  }
  _generateEdgesLines() {
    const positions = this._source.getVerticesData(VertexBuffer.PositionKind);
    const indices = this._source.getIndices();
    if (!indices || !positions) {
      return;
    }
    const adjacencies = new Array();
    const faceNormals = new Array();
    let index;
    let faceAdjacencies;
    for (index = 0; index < indices.length; index += 3) {
      faceAdjacencies = new FaceAdjacencies();
      const p0Index = indices[index];
      const p1Index = indices[index + 1];
      const p2Index = indices[index + 2];
      faceAdjacencies.p0 = new Vector3(positions[p0Index * 3], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);
      faceAdjacencies.p1 = new Vector3(positions[p1Index * 3], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);
      faceAdjacencies.p2 = new Vector3(positions[p2Index * 3], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);
      const faceNormal = Vector3.Cross(faceAdjacencies.p1.subtract(faceAdjacencies.p0), faceAdjacencies.p2.subtract(faceAdjacencies.p1));
      faceNormal.normalize();
      faceNormals.push(faceNormal);
      adjacencies.push(faceAdjacencies);
    }
    for (index = 0; index < adjacencies.length; index++) {
      faceAdjacencies = adjacencies[index];
      for (let otherIndex = index + 1; otherIndex < adjacencies.length; otherIndex++) {
        const otherFaceAdjacencies = adjacencies[otherIndex];
        if (faceAdjacencies.edgesConnectedCount === 3) {
          break;
        }
        if (otherFaceAdjacencies.edgesConnectedCount === 3) {
          continue;
        }
        const otherP0 = indices[otherIndex * 3];
        const otherP1 = indices[otherIndex * 3 + 1];
        const otherP2 = indices[otherIndex * 3 + 2];
        for (let edgeIndex = 0; edgeIndex < 3; edgeIndex++) {
          let otherEdgeIndex = 0;
          if (faceAdjacencies.edges[edgeIndex] !== void 0) {
            continue;
          }
          switch (edgeIndex) {
            case 0:
              if (this._checkVerticesInsteadOfIndices) {
                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p0, faceAdjacencies.p1, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);
              } else {
                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3], indices[index * 3 + 1], otherP0, otherP1, otherP2);
              }
              break;
            case 1:
              if (this._checkVerticesInsteadOfIndices) {
                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p1, faceAdjacencies.p2, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);
              } else {
                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 1], indices[index * 3 + 2], otherP0, otherP1, otherP2);
              }
              break;
            case 2:
              if (this._checkVerticesInsteadOfIndices) {
                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p2, faceAdjacencies.p0, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);
              } else {
                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 2], indices[index * 3], otherP0, otherP1, otherP2);
              }
              break;
          }
          if (otherEdgeIndex === -1) {
            continue;
          }
          faceAdjacencies.edges[edgeIndex] = otherIndex;
          otherFaceAdjacencies.edges[otherEdgeIndex] = index;
          faceAdjacencies.edgesConnectedCount++;
          otherFaceAdjacencies.edgesConnectedCount++;
          if (faceAdjacencies.edgesConnectedCount === 3) {
            break;
          }
        }
      }
    }
    for (index = 0; index < adjacencies.length; index++) {
      const current = adjacencies[index];
      this._checkEdge(index, current.edges[0], faceNormals, current.p0, current.p1);
      this._checkEdge(index, current.edges[1], faceNormals, current.p1, current.p2);
      this._checkEdge(index, current.edges[2], faceNormals, current.p2, current.p0);
    }
    const engine = this._source.getScene().getEngine();
    this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);
    this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);
    this._buffersForInstances[VertexBuffer.PositionKind] = this._buffers[VertexBuffer.PositionKind];
    this._buffersForInstances[VertexBuffer.NormalKind] = this._buffers[VertexBuffer.NormalKind];
    this._ib = engine.createIndexBuffer(this._linesIndices);
    this._indicesCount = this._linesIndices.length;
  }
  isReady() {
    return this._lineShader.isReady(this._source, this._source.hasInstances && this.customInstances.length > 0 || this._source.hasThinInstances);
  }
  render() {
    const scene = this._source.getScene();
    const currentDrawWrapper = this._lineShader._getDrawWrapper();
    if (this._drawWrapper) {
      this._lineShader._setDrawWrapper(this._drawWrapper);
    }
    if (!this.isReady() || !scene.activeCamera) {
      this._lineShader._setDrawWrapper(currentDrawWrapper);
      return;
    }
    const hasInstances = this._source.hasInstances && this.customInstances.length > 0;
    const useBuffersWithInstances = hasInstances || this._source.hasThinInstances;
    let instanceCount = 0;
    if (useBuffersWithInstances) {
      this._buffersForInstances["world0"] = this._source.getVertexBuffer("world0");
      this._buffersForInstances["world1"] = this._source.getVertexBuffer("world1");
      this._buffersForInstances["world2"] = this._source.getVertexBuffer("world2");
      this._buffersForInstances["world3"] = this._source.getVertexBuffer("world3");
      if (hasInstances) {
        const instanceStorage = this._source._instanceDataStorage;
        instanceCount = this.customInstances.length;
        if (!instanceStorage.instancesData) {
          if (!this._source.getScene()._activeMeshesFrozen) {
            this.customInstances.reset();
          }
          return;
        }
        if (!instanceStorage.isFrozen) {
          let offset = 0;
          for (let i = 0; i < instanceCount; ++i) {
            this.customInstances.data[i].copyToArray(instanceStorage.instancesData, offset);
            offset += 16;
          }
          instanceStorage.instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instanceCount);
        }
      } else {
        instanceCount = this._source.thinInstanceCount;
      }
    }
    const engine = scene.getEngine();
    this._lineShader._preBind();
    if (this._source.edgesColor.a !== 1) {
      engine.setAlphaMode(2);
    } else {
      engine.setAlphaMode(0);
    }
    engine.bindBuffers(useBuffersWithInstances ? this._buffersForInstances : this._buffers, this._ib, this._lineShader.getEffect());
    scene.resetCachedMaterial();
    this._lineShader.setColor4("color", this._source.edgesColor);
    if (scene.activeCamera.mode === Camera.ORTHOGRAPHIC_CAMERA) {
      this._lineShader.setFloat("width", this._source.edgesWidth / this.edgesWidthScalerForOrthographic);
    } else {
      this._lineShader.setFloat("width", this._source.edgesWidth / this.edgesWidthScalerForPerspective);
    }
    this._lineShader.setFloat("aspectRatio", engine.getAspectRatio(scene.activeCamera));
    this._lineShader.bind(this._source.getWorldMatrix());
    engine.drawElementsType(Material.TriangleFillMode, 0, this._indicesCount, instanceCount);
    this._lineShader.unbind();
    if (useBuffersWithInstances) {
      engine.unbindInstanceAttributes();
    }
    if (!this._source.getScene()._activeMeshesFrozen) {
      this.customInstances.reset();
    }
    this._lineShader._setDrawWrapper(currentDrawWrapper);
  }
};
var LineEdgesRenderer = class extends EdgesRenderer {
  constructor(source, epsilon = 0.95, checkVerticesInsteadOfIndices = false) {
    super(source, epsilon, checkVerticesInsteadOfIndices, false);
    this._generateEdgesLines();
  }
  _generateEdgesLines() {
    const positions = this._source.getVerticesData(VertexBuffer.PositionKind);
    const indices = this._source.getIndices();
    if (!indices || !positions) {
      return;
    }
    const p0 = TmpVectors.Vector3[0];
    const p1 = TmpVectors.Vector3[1];
    const len = indices.length - 1;
    for (let i = 0, offset = 0; i < len; i += 2, offset += 4) {
      Vector3.FromArrayToRef(positions, 3 * indices[i], p0);
      Vector3.FromArrayToRef(positions, 3 * indices[i + 1], p1);
      this.createLine(p0, p1, offset);
    }
    const engine = this._source.getScene().getEngine();
    this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);
    this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);
    this._ib = engine.createIndexBuffer(this._linesIndices);
    this._indicesCount = this._linesIndices.length;
  }
};

// node_modules/@babylonjs/core/Materials/Textures/prePassRenderTarget.js
var PrePassRenderTarget = class extends MultiRenderTarget {
  constructor(name137, renderTargetTexture, size, count, scene, options) {
    super(name137, size, count, scene, options);
    this._beforeCompositionPostProcesses = [];
    this._internalTextureDirty = false;
    this.enabled = false;
    this.renderTargetTexture = null;
    this.renderTargetTexture = renderTargetTexture;
  }
  _createCompositionEffect() {
    this.imageProcessingPostProcess = new ImageProcessingPostProcess("prePassComposition", 1, null, void 0, this._engine);
    this.imageProcessingPostProcess._updateParameters();
  }
  _checkSize() {
    const requiredWidth = this._engine.getRenderWidth(true);
    const requiredHeight = this._engine.getRenderHeight(true);
    const width = this.getRenderWidth();
    const height = this.getRenderHeight();
    if (width !== requiredWidth || height !== requiredHeight) {
      this.resize({ width: requiredWidth, height: requiredHeight });
      this._internalTextureDirty = true;
    }
  }
  updateCount(count, options, textureNames) {
    super.updateCount(count, options, textureNames);
    this._internalTextureDirty = true;
  }
  _resetPostProcessChain() {
    this._beforeCompositionPostProcesses.length = 0;
  }
  dispose() {
    const scene = this._scene;
    super.dispose();
    if (scene && scene.prePassRenderer) {
      const index = scene.prePassRenderer.renderTargets.indexOf(this);
      if (index !== -1) {
        scene.prePassRenderer.renderTargets.splice(index, 1);
      }
    }
    if (this.imageProcessingPostProcess) {
      this.imageProcessingPostProcess.dispose();
    }
    if (this.renderTargetTexture) {
      this.renderTargetTexture._prePassRenderTarget = null;
    }
    if (this._outputPostProcess) {
      this._outputPostProcess.autoClear = true;
      this._outputPostProcess.restoreDefaultInputTexture();
    }
  }
};

// node_modules/@babylonjs/core/Rendering/prePassRenderer.js
var PrePassRenderer = class {
  constructor(scene) {
    this.excludedSkinnedMesh = [];
    this.excludedMaterials = [];
    this.mrtCount = 0;
    this._mrtFormats = [];
    this._mrtLayout = [];
    this._mrtNames = [];
    this._textureIndices = [];
    this._isDirty = true;
    this._effectConfigurations = [];
    this.doNotUseGeometryRendererFallback = true;
    this.renderTargets = [];
    this._clearColor = new Color4(0, 0, 0, 0);
    this._enabled = false;
    this._needsCompositionForThisPass = false;
    this.disableGammaTransform = false;
    this._scene = scene;
    this._engine = scene.getEngine();
    PrePassRenderer._SceneComponentInitialization(this._scene);
    this.defaultRT = this._createRenderTarget("sceneprePassRT", null);
    this._currentTarget = this.defaultRT;
  }
  getIndex(type) {
    return this._textureIndices[type];
  }
  get samples() {
    return this.defaultRT.samples;
  }
  set samples(n) {
    this.defaultRT.samples = n;
  }
  getRenderTarget() {
    return this._currentTarget;
  }
  _setRenderTarget(prePassRenderTarget) {
    if (prePassRenderTarget) {
      this._currentTarget = prePassRenderTarget;
    } else {
      this._currentTarget = this.defaultRT;
      this._engine.currentRenderPassId = this._currentTarget.renderPassId;
    }
  }
  get currentRTisSceneRT() {
    return this._currentTarget === this.defaultRT;
  }
  _refreshGeometryBufferRendererLink() {
    if (!this.doNotUseGeometryRendererFallback) {
      this._geometryBuffer = this._scene.enableGeometryBufferRenderer();
      if (!this._geometryBuffer) {
        this.doNotUseGeometryRendererFallback = true;
        return;
      }
      this._geometryBuffer._linkPrePassRenderer(this);
    } else {
      if (this._geometryBuffer) {
        this._geometryBuffer._unlinkPrePassRenderer();
      }
      this._geometryBuffer = null;
      this._scene.disableGeometryBufferRenderer();
    }
  }
  get enabled() {
    return this._enabled;
  }
  _createRenderTarget(name137, renderTargetTexture) {
    const rt = new PrePassRenderTarget(name137, renderTargetTexture, { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, 0, this._scene, {
      generateMipMaps: false,
      generateStencilBuffer: this._engine.isStencilEnable,
      defaultType: 0,
      types: [],
      drawOnlyOnFirstAttachmentByDefault: true
    });
    this.renderTargets.push(rt);
    return rt;
  }
  get isSupported() {
    return this._scene.getEngine().getCaps().drawBuffersExtension;
  }
  bindAttachmentsForEffect(effect, subMesh) {
    const material = subMesh.getMaterial();
    const isPrePassCapable = material && material.isPrePassCapable;
    const excluded = material && this.excludedMaterials.indexOf(material) !== -1;
    if (this.enabled && this._currentTarget.enabled) {
      if (effect._multiTarget && isPrePassCapable && !excluded) {
        this._engine.bindAttachments(this._multiRenderAttachments);
      } else {
        if (this._engine._currentRenderTarget) {
          this._engine.bindAttachments(this._defaultAttachments);
        } else {
          this._engine.restoreSingleAttachment();
        }
        if (this._geometryBuffer && this.currentRTisSceneRT && !excluded) {
          this._geometryBuffer.renderList.push(subMesh.getRenderingMesh());
        }
      }
    }
  }
  _reinitializeAttachments() {
    const multiRenderLayout = [];
    const clearLayout = [false];
    const defaultLayout = [true];
    for (let i = 0; i < this.mrtCount; i++) {
      multiRenderLayout.push(true);
      if (i > 0) {
        clearLayout.push(true);
        defaultLayout.push(false);
      }
    }
    this._multiRenderAttachments = this._engine.buildTextureLayout(multiRenderLayout);
    this._clearAttachments = this._engine.buildTextureLayout(clearLayout);
    this._defaultAttachments = this._engine.buildTextureLayout(defaultLayout);
  }
  _resetLayout() {
    for (let i = 0; i < PrePassRenderer._TextureFormats.length; i++) {
      this._textureIndices[PrePassRenderer._TextureFormats[i].type] = -1;
    }
    this._textureIndices[4] = 0;
    this._mrtLayout = [4];
    this._mrtFormats = [PrePassRenderer._TextureFormats[4].format];
    this._mrtNames = [PrePassRenderer._TextureFormats[4].name];
    this.mrtCount = 1;
  }
  _updateGeometryBufferLayout() {
    this._refreshGeometryBufferRendererLink();
    if (this._geometryBuffer) {
      this._geometryBuffer._resetLayout();
      const texturesActivated = [];
      for (let i = 0; i < this._mrtLayout.length; i++) {
        texturesActivated.push(false);
      }
      this._geometryBuffer._linkInternalTexture(this.defaultRT.getInternalTexture());
      const matches = [
        {
          prePassConstant: 5,
          geometryBufferConstant: GeometryBufferRenderer.DEPTH_TEXTURE_TYPE
        },
        {
          prePassConstant: 6,
          geometryBufferConstant: GeometryBufferRenderer.NORMAL_TEXTURE_TYPE
        },
        {
          prePassConstant: 1,
          geometryBufferConstant: GeometryBufferRenderer.POSITION_TEXTURE_TYPE
        },
        {
          prePassConstant: 3,
          geometryBufferConstant: GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE
        },
        {
          prePassConstant: 2,
          geometryBufferConstant: GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE
        }
      ];
      for (let i = 0; i < matches.length; i++) {
        const index = this._mrtLayout.indexOf(matches[i].prePassConstant);
        if (index !== -1) {
          this._geometryBuffer._forceTextureType(matches[i].geometryBufferConstant, index);
          texturesActivated[index] = true;
        }
      }
      this._geometryBuffer._setAttachments(this._engine.buildTextureLayout(texturesActivated));
    }
  }
  restoreAttachments() {
    if (this.enabled && this._currentTarget.enabled && this._defaultAttachments) {
      if (this._engine._currentRenderTarget) {
        this._engine.bindAttachments(this._defaultAttachments);
      } else {
        this._engine.restoreSingleAttachment();
      }
    }
  }
  _beforeDraw(camera, faceIndex, layer) {
    if (this._isDirty) {
      this._update();
    }
    if (!this._enabled || !this._currentTarget.enabled) {
      return;
    }
    if (this._geometryBuffer) {
      this._geometryBuffer.renderList = [];
    }
    this._setupOutputForThisPass(this._currentTarget, camera);
  }
  _prepareFrame(prePassRenderTarget, faceIndex, layer) {
    if (prePassRenderTarget.renderTargetTexture) {
      prePassRenderTarget.renderTargetTexture._prepareFrame(this._scene, faceIndex, layer, prePassRenderTarget.renderTargetTexture.useCameraPostProcesses);
    } else if (this._postProcessesSourceForThisPass.length) {
      this._scene.postProcessManager._prepareFrame();
    } else {
      this._engine.restoreDefaultFramebuffer();
    }
  }
  setCustomOutput(rt) {
    const firstPP = this._postProcessesSourceForThisPass[0];
    if (!firstPP) {
      return false;
    }
    firstPP.inputTexture = rt.renderTarget;
    return true;
  }
  _renderPostProcesses(prePassRenderTarget, faceIndex) {
    var _a;
    const firstPP = this._postProcessesSourceForThisPass[0];
    const outputTexture = firstPP ? firstPP.inputTexture : prePassRenderTarget.renderTargetTexture ? prePassRenderTarget.renderTargetTexture.renderTarget : null;
    let postProcessChain = this._currentTarget._beforeCompositionPostProcesses;
    if (this._needsCompositionForThisPass) {
      postProcessChain = postProcessChain.concat([this._currentTarget.imageProcessingPostProcess]);
    }
    if (postProcessChain.length) {
      this._scene.postProcessManager._prepareFrame((_a = this._currentTarget.renderTarget) === null || _a === void 0 ? void 0 : _a.texture, postProcessChain);
      this._scene.postProcessManager.directRender(postProcessChain, outputTexture, false, faceIndex);
    }
  }
  _afterDraw(faceIndex, layer) {
    if (this._enabled && this._currentTarget.enabled) {
      this._prepareFrame(this._currentTarget, faceIndex, layer);
      this._renderPostProcesses(this._currentTarget, faceIndex);
    }
  }
  _clear() {
    if (this._enabled && this._currentTarget.enabled) {
      this._bindFrameBuffer(this._currentTarget);
      this._engine.bindAttachments(this._clearAttachments);
      this._engine.clear(this._clearColor, true, false, false);
      this._engine.bindAttachments(this._defaultAttachments);
    }
  }
  _bindFrameBuffer(prePassRenderTarget) {
    if (this._enabled && this._currentTarget.enabled) {
      this._currentTarget._checkSize();
      const internalTexture = this._currentTarget.renderTarget;
      if (internalTexture) {
        this._engine.bindFramebuffer(internalTexture);
      }
    }
  }
  _setEnabled(enabled) {
    this._enabled = enabled;
  }
  _setRenderTargetEnabled(prePassRenderTarget, enabled) {
    prePassRenderTarget.enabled = enabled;
    if (!enabled) {
      this._unlinkInternalTexture(prePassRenderTarget);
    }
  }
  addEffectConfiguration(cfg) {
    for (let i = 0; i < this._effectConfigurations.length; i++) {
      if (this._effectConfigurations[i].name === cfg.name) {
        return this._effectConfigurations[i];
      }
    }
    this._effectConfigurations.push(cfg);
    return cfg;
  }
  _enable() {
    const previousMrtCount = this.mrtCount;
    for (let i = 0; i < this._effectConfigurations.length; i++) {
      if (this._effectConfigurations[i].enabled) {
        this._enableTextures(this._effectConfigurations[i].texturesRequired);
      }
    }
    for (let i = 0; i < this.renderTargets.length; i++) {
      if (this.mrtCount !== previousMrtCount || this.renderTargets[i].count !== this.mrtCount) {
        this.renderTargets[i].updateCount(this.mrtCount, { types: this._mrtFormats }, this._mrtNames.concat("prePass_DepthBuffer"));
      }
      this.renderTargets[i]._resetPostProcessChain();
      for (let j = 0; j < this._effectConfigurations.length; j++) {
        if (this._effectConfigurations[j].enabled) {
          if (!this._effectConfigurations[j].postProcess && this._effectConfigurations[j].createPostProcess) {
            this._effectConfigurations[j].createPostProcess();
          }
          if (this._effectConfigurations[j].postProcess) {
            this.renderTargets[i]._beforeCompositionPostProcesses.push(this._effectConfigurations[j].postProcess);
          }
        }
      }
    }
    this._reinitializeAttachments();
    this._setEnabled(true);
    this._updateGeometryBufferLayout();
  }
  _disable() {
    this._setEnabled(false);
    for (let i = 0; i < this.renderTargets.length; i++) {
      this._setRenderTargetEnabled(this.renderTargets[i], false);
    }
    this._resetLayout();
    for (let i = 0; i < this._effectConfigurations.length; i++) {
      this._effectConfigurations[i].enabled = false;
    }
  }
  _getPostProcessesSource(prePassRenderTarget, camera) {
    if (camera) {
      return camera._postProcesses;
    } else if (prePassRenderTarget.renderTargetTexture) {
      if (prePassRenderTarget.renderTargetTexture.useCameraPostProcesses) {
        const camera2 = prePassRenderTarget.renderTargetTexture.activeCamera ? prePassRenderTarget.renderTargetTexture.activeCamera : this._scene.activeCamera;
        return camera2 ? camera2._postProcesses : [];
      } else if (prePassRenderTarget.renderTargetTexture.postProcesses) {
        return prePassRenderTarget.renderTargetTexture.postProcesses;
      } else {
        return [];
      }
    } else {
      return this._scene.activeCamera ? this._scene.activeCamera._postProcesses : [];
    }
  }
  _setupOutputForThisPass(prePassRenderTarget, camera) {
    const secondaryCamera = camera && this._scene.activeCameras && !!this._scene.activeCameras.length && this._scene.activeCameras.indexOf(camera) !== 0;
    this._postProcessesSourceForThisPass = this._getPostProcessesSource(prePassRenderTarget, camera);
    this._postProcessesSourceForThisPass = this._postProcessesSourceForThisPass.filter((pp) => {
      return pp != null;
    });
    this._scene.autoClear = true;
    const cameraHasImageProcessing = this._hasImageProcessing(this._postProcessesSourceForThisPass);
    this._needsCompositionForThisPass = !cameraHasImageProcessing && !this.disableGammaTransform && this._needsImageProcessing() && !secondaryCamera;
    const firstCameraPP = this._getFirstPostProcess(this._postProcessesSourceForThisPass);
    const firstPrePassPP = prePassRenderTarget._beforeCompositionPostProcesses && prePassRenderTarget._beforeCompositionPostProcesses[0];
    let firstPP = null;
    this._scene.imageProcessingConfiguration.applyByPostProcess = this._needsCompositionForThisPass || cameraHasImageProcessing;
    if (this._needsCompositionForThisPass && !prePassRenderTarget.imageProcessingPostProcess) {
      prePassRenderTarget._createCompositionEffect();
    }
    if (firstPrePassPP) {
      firstPP = firstPrePassPP;
    } else if (this._needsCompositionForThisPass) {
      firstPP = prePassRenderTarget.imageProcessingPostProcess;
    } else if (firstCameraPP) {
      firstPP = firstCameraPP;
    }
    this._bindFrameBuffer(prePassRenderTarget);
    this._linkInternalTexture(prePassRenderTarget, firstPP);
  }
  _linkInternalTexture(prePassRenderTarget, postProcess) {
    if (postProcess) {
      postProcess.autoClear = false;
      postProcess.inputTexture = prePassRenderTarget.renderTarget;
    }
    if (prePassRenderTarget._outputPostProcess !== postProcess) {
      if (prePassRenderTarget._outputPostProcess) {
        this._unlinkInternalTexture(prePassRenderTarget);
      }
      prePassRenderTarget._outputPostProcess = postProcess;
    }
    if (prePassRenderTarget._internalTextureDirty) {
      this._updateGeometryBufferLayout();
      prePassRenderTarget._internalTextureDirty = false;
    }
  }
  _unlinkInternalTexture(prePassRenderTarget) {
    if (prePassRenderTarget._outputPostProcess) {
      prePassRenderTarget._outputPostProcess.autoClear = true;
      prePassRenderTarget._outputPostProcess.restoreDefaultInputTexture();
      prePassRenderTarget._outputPostProcess = null;
    }
  }
  _needsImageProcessing() {
    for (let i = 0; i < this._effectConfigurations.length; i++) {
      if (this._effectConfigurations[i].enabled && this._effectConfigurations[i].needsImageProcessing) {
        return true;
      }
    }
    return false;
  }
  _hasImageProcessing(postProcesses) {
    var _a;
    let isIPPAlreadyPresent = false;
    if (postProcesses) {
      for (let i = 0; i < postProcesses.length; i++) {
        if (((_a = postProcesses[i]) === null || _a === void 0 ? void 0 : _a.getClassName()) === "ImageProcessingPostProcess") {
          isIPPAlreadyPresent = true;
          break;
        }
      }
    }
    return isIPPAlreadyPresent;
  }
  _getFirstPostProcess(postProcesses) {
    for (let ppIndex = 0; ppIndex < postProcesses.length; ppIndex++) {
      if (postProcesses[ppIndex] !== null) {
        return postProcesses[ppIndex];
      }
    }
    return null;
  }
  markAsDirty() {
    this._isDirty = true;
  }
  _enableTextures(types) {
    this._scene.needsPreviousWorldMatrices = false;
    for (let i = 0; i < types.length; i++) {
      const type = types[i];
      if (this._textureIndices[type] === -1) {
        this._textureIndices[type] = this._mrtLayout.length;
        this._mrtLayout.push(type);
        this._mrtFormats.push(PrePassRenderer._TextureFormats[type].format);
        this._mrtNames.push(PrePassRenderer._TextureFormats[type].name);
        this.mrtCount++;
      }
      if (type === 2) {
        this._scene.needsPreviousWorldMatrices = true;
      }
    }
  }
  _update() {
    this._disable();
    let enablePrePass = false;
    this._scene.imageProcessingConfiguration.applyByPostProcess = false;
    if (this._scene._depthPeelingRenderer && this._scene.useOrderIndependentTransparency) {
      this._scene._depthPeelingRenderer.setPrePassRenderer(this);
      enablePrePass = true;
    }
    for (let i = 0; i < this._scene.materials.length; i++) {
      if (this._scene.materials[i].setPrePassRenderer(this)) {
        enablePrePass = true;
      }
    }
    if (enablePrePass) {
      this._setRenderTargetEnabled(this.defaultRT, true);
    }
    let postProcesses;
    for (let i = 0; i < this.renderTargets.length; i++) {
      if (this.renderTargets[i].renderTargetTexture) {
        postProcesses = this._getPostProcessesSource(this.renderTargets[i]);
      } else {
        const camera = this._scene.activeCamera;
        if (!camera) {
          continue;
        }
        postProcesses = camera._postProcesses;
      }
      if (!postProcesses) {
        continue;
      }
      postProcesses = postProcesses.filter((pp) => {
        return pp != null;
      });
      if (postProcesses) {
        for (let j = 0; j < postProcesses.length; j++) {
          if (postProcesses[j].setPrePassRenderer(this)) {
            this._setRenderTargetEnabled(this.renderTargets[i], true);
            enablePrePass = true;
          }
        }
        if (this._hasImageProcessing(postProcesses)) {
          this._scene.imageProcessingConfiguration.applyByPostProcess = true;
        }
      }
    }
    this._markAllMaterialsAsPrePassDirty();
    this._isDirty = false;
    if (enablePrePass) {
      this._enable();
    }
  }
  _markAllMaterialsAsPrePassDirty() {
    const materials = this._scene.materials;
    for (let i = 0; i < materials.length; i++) {
      materials[i].markAsDirty(Material.PrePassDirtyFlag);
    }
  }
  dispose() {
    for (let i = this.renderTargets.length - 1; i >= 0; i--) {
      this.renderTargets[i].dispose();
    }
    for (let i = 0; i < this._effectConfigurations.length; i++) {
      if (this._effectConfigurations[i].dispose) {
        this._effectConfigurations[i].dispose();
      }
    }
  }
};
PrePassRenderer._SceneComponentInitialization = (_) => {
  throw _WarnImport("PrePassRendererSceneComponent");
};
PrePassRenderer._TextureFormats = [
  {
    type: 0,
    format: 2,
    name: "prePass_Irradiance"
  },
  {
    type: 1,
    format: 2,
    name: "prePass_Position"
  },
  {
    type: 2,
    format: 0,
    name: "prePass_Velocity"
  },
  {
    type: 3,
    format: 0,
    name: "prePass_Reflectivity"
  },
  {
    type: 4,
    format: 2,
    name: "prePass_Color"
  },
  {
    type: 5,
    format: 2,
    name: "prePass_Depth"
  },
  {
    type: 6,
    format: 2,
    name: "prePass_Normal"
  },
  {
    type: 7,
    format: 0,
    name: "prePass_Albedo"
  }
];

// node_modules/@babylonjs/core/Rendering/prePassRendererSceneComponent.js
Object.defineProperty(Scene.prototype, "prePassRenderer", {
  get: function() {
    return this._prePassRenderer;
  },
  set: function(value) {
    if (value && value.isSupported) {
      this._prePassRenderer = value;
    }
  },
  enumerable: true,
  configurable: true
});
Scene.prototype.enablePrePassRenderer = function() {
  if (this._prePassRenderer) {
    return this._prePassRenderer;
  }
  this._prePassRenderer = new PrePassRenderer(this);
  if (!this._prePassRenderer.isSupported) {
    this._prePassRenderer = null;
    Logger.Error("PrePassRenderer needs WebGL 2 support.\nMaybe you tried to use the following features that need the PrePassRenderer :\n + Subsurface Scattering");
  }
  return this._prePassRenderer;
};
Scene.prototype.disablePrePassRenderer = function() {
  if (!this._prePassRenderer) {
    return;
  }
  this._prePassRenderer.dispose();
  this._prePassRenderer = null;
};
var PrePassRendererSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_PREPASSRENDERER;
    this.scene = scene;
  }
  register() {
    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS, this, this._beforeCameraDraw);
    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterCameraDraw);
    this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS, this, this._beforeRenderTargetDraw);
    this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterRenderTargetDraw);
    this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PREPASS, this, this._beforeClearStage);
    this.scene._beforeRenderTargetClearStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETCLEAR_PREPASS, this, this._beforeRenderTargetClearStage);
    this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS, this, this._beforeRenderingMeshStage);
    this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS, this, this._afterRenderingMeshStage);
  }
  _beforeRenderTargetDraw(renderTarget, faceIndex, layer) {
    if (this.scene.prePassRenderer) {
      this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);
      this.scene.prePassRenderer._beforeDraw(void 0, faceIndex, layer);
    }
  }
  _afterRenderTargetDraw(renderTarget, faceIndex, layer) {
    if (this.scene.prePassRenderer) {
      this.scene.prePassRenderer._afterDraw(faceIndex, layer);
    }
  }
  _beforeRenderTargetClearStage(renderTarget) {
    if (this.scene.prePassRenderer) {
      if (!renderTarget._prePassRenderTarget) {
        renderTarget._prePassRenderTarget = this.scene.prePassRenderer._createRenderTarget(renderTarget.name + "_prePassRTT", renderTarget);
      }
      this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);
      this.scene.prePassRenderer._clear();
    }
  }
  _beforeCameraDraw(camera) {
    if (this.scene.prePassRenderer) {
      this.scene.prePassRenderer._setRenderTarget(null);
      this.scene.prePassRenderer._beforeDraw(camera);
    }
  }
  _afterCameraDraw() {
    if (this.scene.prePassRenderer) {
      this.scene.prePassRenderer._afterDraw();
    }
  }
  _beforeClearStage() {
    if (this.scene.prePassRenderer) {
      this.scene.prePassRenderer._setRenderTarget(null);
      this.scene.prePassRenderer._clear();
    }
  }
  _beforeRenderingMeshStage(mesh, subMesh, batch, effect) {
    if (!effect) {
      return;
    }
    const scene = mesh.getScene();
    if (scene.prePassRenderer) {
      scene.prePassRenderer.bindAttachmentsForEffect(effect, subMesh);
    }
  }
  _afterRenderingMeshStage(mesh) {
    const scene = mesh.getScene();
    if (scene.prePassRenderer) {
      scene.prePassRenderer.restoreAttachments();
    }
  }
  rebuild() {
    this.scene.disablePrePassRenderer();
    this.scene.enablePrePassRenderer();
  }
  dispose() {
    this.scene.disablePrePassRenderer();
  }
};
PrePassRenderer._SceneComponentInitialization = (scene) => {
  let component = scene._getComponent(SceneComponentConstants.NAME_PREPASSRENDERER);
  if (!component) {
    component = new PrePassRendererSceneComponent(scene);
    scene._addComponent(component);
  }
};

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fibonacci.js
var name117 = "fibonacci";
var shader117 = `#define rcp(x) 1./x
#define GOLDEN_RATIO 1.618033988749895
#define TWO_PI 6.2831855
vec2 Golden2dSeq(int i,float n)
{
return vec2(float(i)/n+(0.5/n),fract(float(i)*rcp(GOLDEN_RATIO)));
}
vec2 SampleDiskGolden(int i,int sampleCount)
{
vec2 f=Golden2dSeq(i,float(sampleCount));
return vec2(sqrt(f.x),TWO_PI*f.y);
}`;
ShaderStore.IncludesShadersStore[name117] = shader117;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/diffusionProfile.js
var name118 = "diffusionProfile";
var shader118 = `uniform vec3 diffusionS[5];
uniform float diffusionD[5];
uniform float filterRadii[5];`;
ShaderStore.IncludesShadersStore[name118] = shader118;

// node_modules/@babylonjs/core/Shaders/subSurfaceScattering.fragment.js
var name119 = "subSurfaceScatteringPixelShader";
var shader119 = `#include<fibonacci>
#include<helperFunctions>
#include<subSurfaceScatteringFunctions>
#include<diffusionProfile>
varying vec2 vUV;
uniform vec2 texelSize;
uniform sampler2D textureSampler;
uniform sampler2D irradianceSampler;
uniform sampler2D depthSampler;
uniform sampler2D albedoSampler;
uniform vec2 viewportSize;
uniform float metersPerUnit;
const float LOG2_E=1.4426950408889634;
const float SSS_PIXELS_PER_SAMPLE=4.;
const int _SssSampleBudget=40;
#define rcp(x) 1./x
#define Sq(x) x*x
#define SSS_BILATERAL_FILTER true
vec3 EvalBurleyDiffusionProfile(float r,vec3 S)
{
vec3 exp_13=exp2(((LOG2_E*(-1.0/3.0))*r)*S); 
vec3 expSum=exp_13*(1.+exp_13*exp_13); 
return (S*rcp(8.*PI))*expSum; 
}
vec2 SampleBurleyDiffusionProfile(float u,float rcpS)
{
u=1.-u; 
float g=1.+(4.*u)*(2.*u+sqrt(1.+(4.*u)*u));
float n=exp2(log2(g)*(-1.0/3.0)); 
float p=(g*n)*n; 
float c=1.+p+n; 
float d=(3./LOG2_E*2.)+(3./LOG2_E)*log2(u); 
float x=(3./LOG2_E)*log2(c)-d; 
float rcpExp=((c*c)*c)*rcp((4.*u)*((c*c)+(4.*u)*(4.*u)));
float r=x*rcpS;
float rcpPdf=(8.*PI*rcpS)*rcpExp; 
return vec2(r,rcpPdf);
}
vec3 ComputeBilateralWeight(float xy2,float z,float mmPerUnit,vec3 S,float rcpPdf)
{
#ifndef SSS_BILATERAL_FILTER
z=0.;
#endif
float r=sqrt(xy2+(z*mmPerUnit)*(z*mmPerUnit));
float area=rcpPdf;
#if SSS_CLAMP_ARTIFACT
return clamp(EvalBurleyDiffusionProfile(r,S)*area,0.0,1.0);
#else
return EvalBurleyDiffusionProfile(r,S)*area;
#endif
}
void EvaluateSample(int i,int n,vec3 S,float d,vec3 centerPosVS,float mmPerUnit,float pixelsPerMm,
float phase,inout vec3 totalIrradiance,inout vec3 totalWeight)
{
float scale =rcp(float(n));
float offset=rcp(float(n))*0.5;
float sinPhase,cosPhase;
sinPhase=sin(phase);
cosPhase=cos(phase);
vec2 bdp=SampleBurleyDiffusionProfile(float(i)*scale+offset,d);
float r=bdp.x;
float rcpPdf=bdp.y;
float phi=SampleDiskGolden(i,n).y;
float sinPhi,cosPhi;
sinPhi=sin(phi);
cosPhi=cos(phi);
float sinPsi=cosPhase*sinPhi+sinPhase*cosPhi; 
float cosPsi=cosPhase*cosPhi-sinPhase*sinPhi; 
vec2 vec=r*vec2(cosPsi,sinPsi);
vec2 position; 
float xy2;
position=vUV+round((pixelsPerMm*r)*vec2(cosPsi,sinPsi))*texelSize;
xy2 =r*r;
vec4 textureSample=texture2D(irradianceSampler,position);
float viewZ=texture2D(depthSampler,position).r;
vec3 irradiance =textureSample.rgb;
if (testLightingForSSS(textureSample.a))
{
float relZ=viewZ-centerPosVS.z;
vec3 weight=ComputeBilateralWeight(xy2,relZ,mmPerUnit,S,rcpPdf);
totalIrradiance+=weight*irradiance;
totalWeight +=weight;
}
else
{
}
}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{
vec4 irradianceAndDiffusionProfile =texture2D(irradianceSampler,vUV);
vec3 centerIrradiance=irradianceAndDiffusionProfile.rgb;
int diffusionProfileIndex=int(round(irradianceAndDiffusionProfile.a*255.));
float centerDepth =0.;
vec4 inputColor=texture2D(textureSampler,vUV);
bool passedStencilTest=testLightingForSSS(irradianceAndDiffusionProfile.a);
if (passedStencilTest)
{
centerDepth=texture2D(depthSampler,vUV).r;
}
if (!passedStencilTest) { 
gl_FragColor=inputColor;
return;
}
float distScale =1.;
vec3 S =diffusionS[diffusionProfileIndex];
float d =diffusionD[diffusionProfileIndex];
float filterRadius=filterRadii[diffusionProfileIndex];
vec2 centerPosNDC=vUV;
vec2 cornerPosNDC=vUV+0.5*texelSize;
vec3 centerPosVS =vec3(centerPosNDC*viewportSize,1.0)*centerDepth; 
vec3 cornerPosVS =vec3(cornerPosNDC*viewportSize,1.0)*centerDepth; 
float mmPerUnit =1000.*(metersPerUnit*rcp(distScale));
float unitsPerMm=rcp(mmPerUnit);
float unitsPerPixel=2.*abs(cornerPosVS.x-centerPosVS.x);
float pixelsPerMm =rcp(unitsPerPixel)*unitsPerMm;
float filterArea =PI*Sq(filterRadius*pixelsPerMm);
int sampleCount =int(filterArea*rcp(SSS_PIXELS_PER_SAMPLE));
int sampleBudget=_SssSampleBudget;
int texturingMode=0;
vec3 albedo =texture2D(albedoSampler,vUV).rgb;
if (distScale==0. || sampleCount<1)
{
#ifdef DEBUG_SSS_SAMPLES
vec3 green=vec3(0.,1.,0.);
gl_FragColor=vec4(green,1.0);
return;
#endif
gl_FragColor=vec4(inputColor.rgb+albedo*centerIrradiance,1.0);
return;
}
#ifdef DEBUG_SSS_SAMPLES
vec3 red =vec3(1.,0.,0.);
vec3 blue=vec3(0.,0.,1.);
gl_FragColor=vec4(mix(blue,red,clamp(float(sampleCount)/float(sampleBudget),0.0,1.0)),1.0);
return;
#endif
float phase=0.;
int n=min(sampleCount,sampleBudget);
vec3 centerWeight =vec3(0.); 
vec3 totalIrradiance=vec3(0.);
vec3 totalWeight =vec3(0.);
for (int i=0; i<n; i++)
{
EvaluateSample(i,n,S,d,centerPosVS,mmPerUnit,pixelsPerMm,
phase,totalIrradiance,totalWeight);
}
totalWeight=max(totalWeight,HALF_MIN);
gl_FragColor=vec4(inputColor.rgb+albedo*max(totalIrradiance/totalWeight,vec3(0.0)),1.);
}`;
ShaderStore.ShadersStore[name119] = shader119;

// node_modules/@babylonjs/core/PostProcesses/subSurfaceScatteringPostProcess.js
var SubSurfaceScatteringPostProcess = class extends PostProcess {
  getClassName() {
    return "SubSurfaceScatteringPostProcess";
  }
  constructor(name137, scene, options, camera = null, samplingMode, engine, reusable, textureType = 0) {
    super(name137, "subSurfaceScattering", ["texelSize", "viewportSize", "metersPerUnit"], ["diffusionS", "diffusionD", "filterRadii", "irradianceSampler", "depthSampler", "albedoSampler"], options, camera, samplingMode || Texture.BILINEAR_SAMPLINGMODE, engine, reusable, null, textureType, "postprocess", void 0, true);
    this._scene = scene;
    this.updateEffect();
    this.onApplyObservable.add((effect) => {
      if (!scene.prePassRenderer || !scene.subSurfaceConfiguration) {
        Logger.Error("PrePass and subsurface configuration needs to be enabled for subsurface scattering.");
        return;
      }
      const texelSize = this.texelSize;
      effect.setFloat("metersPerUnit", scene.subSurfaceConfiguration.metersPerUnit);
      effect.setFloat2("texelSize", texelSize.x, texelSize.y);
      effect.setTexture("irradianceSampler", scene.prePassRenderer.getRenderTarget().textures[scene.prePassRenderer.getIndex(0)]);
      effect.setTexture("depthSampler", scene.prePassRenderer.getRenderTarget().textures[scene.prePassRenderer.getIndex(5)]);
      effect.setTexture("albedoSampler", scene.prePassRenderer.getRenderTarget().textures[scene.prePassRenderer.getIndex(7)]);
      effect.setFloat2("viewportSize", Math.tan(scene.activeCamera.fov / 2) * scene.getEngine().getAspectRatio(scene.activeCamera, true), Math.tan(scene.activeCamera.fov / 2));
      effect.setArray3("diffusionS", scene.subSurfaceConfiguration.ssDiffusionS);
      effect.setArray("diffusionD", scene.subSurfaceConfiguration.ssDiffusionD);
      effect.setArray("filterRadii", scene.subSurfaceConfiguration.ssFilterRadii);
    });
  }
};

// node_modules/@babylonjs/core/Rendering/subSurfaceConfiguration.js
var SubSurfaceConfiguration = class {
  constructor(scene) {
    this._ssDiffusionS = [];
    this._ssFilterRadii = [];
    this._ssDiffusionD = [];
    this.enabled = false;
    this.needsImageProcessing = true;
    this.name = SceneComponentConstants.NAME_SUBSURFACE;
    this.ssDiffusionProfileColors = [];
    this.metersPerUnit = 1;
    this.texturesRequired = [
      5,
      7,
      4,
      0
    ];
    this.addDiffusionProfile(new Color3(1, 1, 1));
    this._scene = scene;
    SubSurfaceConfiguration._SceneComponentInitialization(this._scene);
  }
  get ssDiffusionS() {
    return this._ssDiffusionS;
  }
  get ssDiffusionD() {
    return this._ssDiffusionD;
  }
  get ssFilterRadii() {
    return this._ssFilterRadii;
  }
  addDiffusionProfile(color) {
    if (this.ssDiffusionD.length >= 5) {
      Logger.Error("You already reached the maximum number of diffusion profiles.");
      return 0;
    }
    for (let i = 0; i < this._ssDiffusionS.length / 3; i++) {
      if (this._ssDiffusionS[i * 3] === color.r && this._ssDiffusionS[i * 3 + 1] === color.g && this._ssDiffusionS[i * 3 + 2] === color.b) {
        return i;
      }
    }
    this._ssDiffusionS.push(color.r, color.b, color.g);
    this._ssDiffusionD.push(Math.max(Math.max(color.r, color.b), color.g));
    this._ssFilterRadii.push(this.getDiffusionProfileParameters(color));
    this.ssDiffusionProfileColors.push(color);
    return this._ssDiffusionD.length - 1;
  }
  createPostProcess() {
    this.postProcess = new SubSurfaceScatteringPostProcess("subSurfaceScattering", this._scene, 1, null, void 0, this._scene.getEngine());
    this.postProcess.autoClear = false;
    return this.postProcess;
  }
  clearAllDiffusionProfiles() {
    this._ssDiffusionD = [];
    this._ssDiffusionS = [];
    this._ssFilterRadii = [];
    this.ssDiffusionProfileColors = [];
  }
  dispose() {
    this.clearAllDiffusionProfiles();
    if (this.postProcess) {
      this.postProcess.dispose();
    }
  }
  getDiffusionProfileParameters(color) {
    const cdf = 0.997;
    const maxScatteringDistance = Math.max(color.r, color.g, color.b);
    return this._sampleBurleyDiffusionProfile(cdf, maxScatteringDistance);
  }
  _sampleBurleyDiffusionProfile(u, rcpS) {
    u = 1 - u;
    const g = 1 + 4 * u * (2 * u + Math.sqrt(1 + 4 * u * u));
    const n = Math.pow(g, -1 / 3);
    const p = g * n * n;
    const c = 1 + p + n;
    const x = 3 * Math.log(c / (4 * u));
    return x * rcpS;
  }
};
SubSurfaceConfiguration._SceneComponentInitialization = (_) => {
  throw _WarnImport("SubSurfaceSceneComponent");
};

// node_modules/@babylonjs/core/Rendering/subSurfaceSceneComponent.js
AbstractScene.AddParser(SceneComponentConstants.NAME_SUBSURFACE, (parsedData, scene) => {
  if (parsedData.ssDiffusionProfileColors !== void 0 && parsedData.ssDiffusionProfileColors !== null) {
    scene.enableSubSurfaceForPrePass();
    if (scene.subSurfaceConfiguration) {
      for (let index = 0, cache = parsedData.ssDiffusionProfileColors.length; index < cache; index++) {
        const color = parsedData.ssDiffusionProfileColors[index];
        scene.subSurfaceConfiguration.addDiffusionProfile(new Color3(color.r, color.g, color.b));
      }
    }
  }
});
Object.defineProperty(Scene.prototype, "subSurfaceConfiguration", {
  get: function() {
    return this._subSurfaceConfiguration;
  },
  set: function(value) {
    if (value) {
      if (this.enablePrePassRenderer()) {
        this._subSurfaceConfiguration = value;
      }
    }
  },
  enumerable: true,
  configurable: true
});
Scene.prototype.enableSubSurfaceForPrePass = function() {
  if (this._subSurfaceConfiguration) {
    return this._subSurfaceConfiguration;
  }
  const prePassRenderer = this.enablePrePassRenderer();
  if (prePassRenderer) {
    this._subSurfaceConfiguration = new SubSurfaceConfiguration(this);
    prePassRenderer.addEffectConfiguration(this._subSurfaceConfiguration);
    return this._subSurfaceConfiguration;
  }
  return null;
};
Scene.prototype.disableSubSurfaceForPrePass = function() {
  if (!this._subSurfaceConfiguration) {
    return;
  }
  this._subSurfaceConfiguration.dispose();
  this._subSurfaceConfiguration = null;
};
var SubSurfaceSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_PREPASSRENDERER;
    this.scene = scene;
  }
  register() {
  }
  serialize(serializationObject) {
    if (!this.scene.subSurfaceConfiguration) {
      return;
    }
    const ssDiffusionProfileColors = this.scene.subSurfaceConfiguration.ssDiffusionProfileColors;
    serializationObject.ssDiffusionProfileColors = [];
    for (let i = 0; i < ssDiffusionProfileColors.length; i++) {
      serializationObject.ssDiffusionProfileColors.push({
        r: ssDiffusionProfileColors[i].r,
        g: ssDiffusionProfileColors[i].g,
        b: ssDiffusionProfileColors[i].b
      });
    }
  }
  addFromContainer() {
  }
  removeFromContainer() {
    if (!this.scene.prePassRenderer) {
      return;
    }
    if (this.scene.subSurfaceConfiguration) {
      this.scene.subSurfaceConfiguration.clearAllDiffusionProfiles();
    }
  }
  rebuild() {
  }
  dispose() {
  }
};
SubSurfaceConfiguration._SceneComponentInitialization = (scene) => {
  let component = scene._getComponent(SceneComponentConstants.NAME_SUBSURFACE);
  if (!component) {
    component = new SubSurfaceSceneComponent(scene);
    scene._addComponent(component);
  }
};

// node_modules/@babylonjs/core/Shaders/outline.fragment.js
var name120 = "outlinePixelShader";
var shader120 = `#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
uniform vec4 color;
#ifdef ALPHATEST
varying vec2 vUV;
uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#ifdef ALPHATEST
if (texture2D(diffuseSampler,vUV).a<0.4)
discard;
#endif
#include<logDepthFragment>
gl_FragColor=color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name120] = shader120;

// node_modules/@babylonjs/core/Shaders/outline.vertex.js
var name121 = "outlineVertexShader";
var shader121 = `attribute vec3 position;
attribute vec3 normal;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
uniform float offset;
#include<instancesDeclaration>
uniform mat4 viewProjection;
#ifdef ALPHATEST
varying vec2 vUV;
uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{
vec3 positionUpdated=position;
vec3 normalUpdated=normal;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
vec3 offsetPosition=positionUpdated+(normalUpdated*offset);
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(offsetPosition,1.0);
gl_Position=viewProjection*worldPos;
#ifdef ALPHATEST
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
#include<clipPlaneVertex>
#include<logDepthVertex>
}
`;
ShaderStore.ShadersStore[name121] = shader121;

// node_modules/@babylonjs/core/Rendering/outlineRenderer.js
Scene.prototype.getOutlineRenderer = function() {
  if (!this._outlineRenderer) {
    this._outlineRenderer = new OutlineRenderer(this);
  }
  return this._outlineRenderer;
};
Object.defineProperty(Mesh.prototype, "renderOutline", {
  get: function() {
    return this._renderOutline;
  },
  set: function(value) {
    if (value) {
      this.getScene().getOutlineRenderer();
    }
    this._renderOutline = value;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(Mesh.prototype, "renderOverlay", {
  get: function() {
    return this._renderOverlay;
  },
  set: function(value) {
    if (value) {
      this.getScene().getOutlineRenderer();
    }
    this._renderOverlay = value;
  },
  enumerable: true,
  configurable: true
});
var OutlineRenderer = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_OUTLINERENDERER;
    this.zOffset = 1;
    this.zOffsetUnits = 4;
    this.scene = scene;
    this._engine = scene.getEngine();
    this.scene._addComponent(this);
    this._passIdForDrawWrapper = [];
    for (let i = 0; i < 4; ++i) {
      this._passIdForDrawWrapper[i] = this._engine.createRenderPassId(`Outline Renderer (${i})`);
    }
  }
  register() {
    this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh);
    this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);
  }
  rebuild() {
  }
  dispose() {
    for (let i = 0; i < this._passIdForDrawWrapper.length; ++i) {
      this._engine.releaseRenderPassId(this._passIdForDrawWrapper[i]);
    }
  }
  render(subMesh, batch, useOverlay = false, renderPassId) {
    renderPassId = renderPassId !== null && renderPassId !== void 0 ? renderPassId : this._passIdForDrawWrapper[0];
    const scene = this.scene;
    const engine = scene.getEngine();
    const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || subMesh.getRenderingMesh().hasThinInstances);
    if (!this.isReady(subMesh, hardwareInstancedRendering, renderPassId)) {
      return;
    }
    const ownerMesh = subMesh.getMesh();
    const replacementMesh = ownerMesh._internalAbstractMeshDataInfo._actAsRegularMesh ? ownerMesh : null;
    const renderingMesh = subMesh.getRenderingMesh();
    const effectiveMesh = replacementMesh ? replacementMesh : renderingMesh;
    const material = subMesh.getMaterial();
    if (!material || !scene.activeCamera) {
      return;
    }
    const drawWrapper = subMesh._getDrawWrapper(renderPassId);
    const effect = DrawWrapper.GetEffect(drawWrapper);
    engine.enableEffect(drawWrapper);
    if (material.useLogarithmicDepth) {
      effect.setFloat("logarithmicDepthConstant", 2 / (Math.log(scene.activeCamera.maxZ + 1) / Math.LN2));
    }
    effect.setFloat("offset", useOverlay ? 0 : renderingMesh.outlineWidth);
    effect.setColor4("color", useOverlay ? renderingMesh.overlayColor : renderingMesh.outlineColor, useOverlay ? renderingMesh.overlayAlpha : material.alpha);
    effect.setMatrix("viewProjection", scene.getTransformMatrix());
    effect.setMatrix("world", effectiveMesh.getWorldMatrix());
    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
      effect.setMatrices("mBones", renderingMesh.skeleton.getTransformMatrices(renderingMesh));
    }
    if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
      renderingMesh.morphTargetManager._bind(effect);
    }
    MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);
    if (!hardwareInstancedRendering) {
      renderingMesh._bind(subMesh, effect, material.fillMode);
    }
    if (material && material.needAlphaTesting()) {
      const alphaTexture = material.getAlphaTestTexture();
      if (alphaTexture) {
        effect.setTexture("diffuseSampler", alphaTexture);
        effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
      }
    }
    bindClipPlane(effect, material, scene);
    engine.setZOffset(-this.zOffset);
    engine.setZOffsetUnits(-this.zOffsetUnits);
    renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => {
      effect.setMatrix("world", world);
    });
    engine.setZOffset(0);
    engine.setZOffsetUnits(0);
  }
  isReady(subMesh, useInstances, renderPassId) {
    renderPassId = renderPassId !== null && renderPassId !== void 0 ? renderPassId : this._passIdForDrawWrapper[0];
    const defines = [];
    const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];
    const mesh = subMesh.getMesh();
    const material = subMesh.getMaterial();
    if (!material) {
      return false;
    }
    const scene = mesh.getScene();
    if (material.needAlphaTesting()) {
      defines.push("#define ALPHATEST");
      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
        attribs.push(VertexBuffer.UVKind);
        defines.push("#define UV1");
      }
      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
        attribs.push(VertexBuffer.UV2Kind);
        defines.push("#define UV2");
      }
    }
    if (material.useLogarithmicDepth) {
      defines.push("#define LOGARITHMICDEPTH");
    }
    prepareDefinesForClipPlanes(material, scene, defines);
    if (mesh.useBones && mesh.computeBonesUsingShaders) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      defines.push("#define BonesPerMesh " + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    const morphTargetManager = mesh.morphTargetManager;
    let numMorphInfluencers = 0;
    if (morphTargetManager) {
      if (morphTargetManager.numInfluencers > 0) {
        numMorphInfluencers = morphTargetManager.numInfluencers;
        defines.push("#define MORPHTARGETS");
        defines.push("#define NUM_MORPH_INFLUENCERS " + numMorphInfluencers);
        if (morphTargetManager.isUsingTextureForTargets) {
          defines.push("#define MORPHTARGETS_TEXTURE");
        }
        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);
      }
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      MaterialHelper.PushAttributesForInstances(attribs);
      if (subMesh.getRenderingMesh().hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
      }
    }
    const drawWrapper = subMesh._getDrawWrapper(renderPassId, true);
    const cachedDefines = drawWrapper.defines;
    const join = defines.join("\n");
    if (cachedDefines !== join) {
      const uniforms = [
        "world",
        "mBones",
        "viewProjection",
        "diffuseMatrix",
        "offset",
        "color",
        "logarithmicDepthConstant",
        "morphTargetInfluences",
        "morphTargetTextureInfo",
        "morphTargetTextureIndices"
      ];
      addClipPlaneUniforms(uniforms);
      drawWrapper.setEffect(this.scene.getEngine().createEffect("outline", attribs, uniforms, ["diffuseSampler", "morphTargets"], join, void 0, void 0, void 0, {
        maxSimultaneousMorphTargets: numMorphInfluencers
      }), join);
    }
    return drawWrapper.effect.isReady();
  }
  _beforeRenderingMesh(mesh, subMesh, batch) {
    this._savedDepthWrite = this._engine.getDepthWrite();
    if (mesh.renderOutline) {
      const material = subMesh.getMaterial();
      if (material && material.needAlphaBlendingForMesh(mesh)) {
        this._engine.cacheStencilState();
        this._engine.setDepthWrite(false);
        this._engine.setColorWrite(false);
        this._engine.setStencilBuffer(true);
        this._engine.setStencilOperationPass(7681);
        this._engine.setStencilFunction(519);
        this._engine.setStencilMask(OutlineRenderer._StencilReference);
        this._engine.setStencilFunctionReference(OutlineRenderer._StencilReference);
        this._engine.stencilStateComposer.useStencilGlobalOnly = true;
        this.render(subMesh, batch, true, this._passIdForDrawWrapper[1]);
        this._engine.setColorWrite(true);
        this._engine.setStencilFunction(517);
      }
      this._engine.setDepthWrite(false);
      this.render(subMesh, batch, false, this._passIdForDrawWrapper[0]);
      this._engine.setDepthWrite(this._savedDepthWrite);
      if (material && material.needAlphaBlendingForMesh(mesh)) {
        this._engine.stencilStateComposer.useStencilGlobalOnly = false;
        this._engine.restoreStencilState();
      }
    }
  }
  _afterRenderingMesh(mesh, subMesh, batch) {
    if (mesh.renderOverlay) {
      const currentMode = this._engine.getAlphaMode();
      const alphaBlendState = this._engine.alphaState.alphaBlend;
      this._engine.setAlphaMode(2);
      this.render(subMesh, batch, true, this._passIdForDrawWrapper[3]);
      this._engine.setAlphaMode(currentMode);
      this._engine.setDepthWrite(this._savedDepthWrite);
      this._engine.alphaState.alphaBlend = alphaBlendState;
    }
    if (mesh.renderOutline && this._savedDepthWrite) {
      this._engine.setDepthWrite(true);
      this._engine.setColorWrite(false);
      this.render(subMesh, batch, false, this._passIdForDrawWrapper[2]);
      this._engine.setColorWrite(true);
    }
  }
};
OutlineRenderer._StencilReference = 4;

// node_modules/@babylonjs/core/Rendering/fluidRenderer/fluidRenderingObject.js
var FluidRenderingObject = class {
  constructor(scene) {
    this.priority = 0;
    this._particleSize = 0.1;
    this.onParticleSizeChanged = new Observable();
    this.particleThicknessAlpha = 0.05;
    this._useVelocity = false;
    this._scene = scene;
    this._engine = scene.getEngine();
    this._effectsAreDirty = true;
    this._depthEffectWrapper = null;
    this._thicknessEffectWrapper = null;
  }
  get particleSize() {
    return this._particleSize;
  }
  set particleSize(size) {
    if (size === this._particleSize) {
      return;
    }
    this._particleSize = size;
    this.onParticleSizeChanged.notifyObservers(this);
  }
  get useInstancing() {
    return !this.indexBuffer;
  }
  get useVelocity() {
    return this._useVelocity;
  }
  set useVelocity(use) {
    if (this._useVelocity === use || !this._hasVelocity()) {
      return;
    }
    this._useVelocity = use;
    this._effectsAreDirty = true;
  }
  _hasVelocity() {
    var _a;
    return !!((_a = this.vertexBuffers) === null || _a === void 0 ? void 0 : _a.velocity);
  }
  get indexBuffer() {
    return null;
  }
  getClassName() {
    return "FluidRenderingObject";
  }
  _createEffects() {
    const uniformNames = ["view", "projection", "particleRadius", "size"];
    const attributeNames = ["position", "offset"];
    const defines = [];
    this._effectsAreDirty = false;
    if (this.useVelocity) {
      attributeNames.push("velocity");
      defines.push("#define FLUIDRENDERING_VELOCITY");
    }
    this._depthEffectWrapper = new EffectWrapper({
      engine: this._engine,
      useShaderStore: true,
      vertexShader: "fluidRenderingParticleDepth",
      fragmentShader: "fluidRenderingParticleDepth",
      attributeNames,
      uniformNames,
      samplerNames: [],
      defines
    });
    uniformNames.push("particleAlpha");
    this._thicknessEffectWrapper = new EffectWrapper({
      engine: this._engine,
      useShaderStore: true,
      vertexShader: "fluidRenderingParticleThickness",
      fragmentShader: "fluidRenderingParticleThickness",
      attributeNames: ["position", "offset"],
      uniformNames,
      samplerNames: []
    });
  }
  isReady() {
    if (this._effectsAreDirty) {
      this._createEffects();
    }
    if (!this._depthEffectWrapper || !this._thicknessEffectWrapper) {
      return false;
    }
    const depthEffect = this._depthEffectWrapper._drawWrapper.effect;
    const thicknessEffect = this._thicknessEffectWrapper._drawWrapper.effect;
    return depthEffect.isReady() && thicknessEffect.isReady();
  }
  renderDepthTexture() {
    const numParticles = this.numParticles;
    if (!this._depthEffectWrapper || numParticles === 0) {
      return;
    }
    const depthDrawWrapper = this._depthEffectWrapper._drawWrapper;
    const depthEffect = depthDrawWrapper.effect;
    this._engine.enableEffect(depthDrawWrapper);
    this._engine.bindBuffers(this.vertexBuffers, this.indexBuffer, depthEffect);
    depthEffect.setMatrix("view", this._scene.getViewMatrix());
    depthEffect.setMatrix("projection", this._scene.getProjectionMatrix());
    depthEffect.setFloat2("size", this._particleSize, this._particleSize);
    depthEffect.setFloat("particleRadius", this._particleSize / 2);
    if (this.useInstancing) {
      this._engine.drawArraysType(7, 0, 4, numParticles);
    } else {
      this._engine.drawElementsType(0, 0, numParticles);
    }
  }
  renderThicknessTexture() {
    const numParticles = this.numParticles;
    if (!this._thicknessEffectWrapper || numParticles === 0) {
      return;
    }
    const thicknessDrawWrapper = this._thicknessEffectWrapper._drawWrapper;
    const thicknessEffect = thicknessDrawWrapper.effect;
    this._engine.setAlphaMode(6);
    this._engine.setDepthWrite(false);
    this._engine.enableEffect(thicknessDrawWrapper);
    this._engine.bindBuffers(this.vertexBuffers, this.indexBuffer, thicknessEffect);
    thicknessEffect.setMatrix("view", this._scene.getViewMatrix());
    thicknessEffect.setMatrix("projection", this._scene.getProjectionMatrix());
    thicknessEffect.setFloat("particleAlpha", this.particleThicknessAlpha);
    thicknessEffect.setFloat2("size", this._particleSize, this._particleSize);
    if (this.useInstancing) {
      this._engine.drawArraysType(7, 0, 4, numParticles);
    } else {
      this._engine.drawElementsType(0, 0, numParticles);
    }
    this._engine.setDepthWrite(true);
    this._engine.setAlphaMode(0);
  }
  renderDiffuseTexture() {
  }
  dispose() {
    var _a, _b;
    (_a = this._depthEffectWrapper) === null || _a === void 0 ? void 0 : _a.dispose();
    (_b = this._thicknessEffectWrapper) === null || _b === void 0 ? void 0 : _b.dispose();
  }
};

// node_modules/@babylonjs/core/Rendering/fluidRenderer/fluidRenderingObjectParticleSystem.js
var FluidRenderingObjectParticleSystem = class extends FluidRenderingObject {
  constructor(scene, ps) {
    super(scene);
    this._useTrueRenderingForDiffuseTexture = true;
    this._particleSystem = ps;
    this._originalRender = ps.render.bind(ps);
    this._blendMode = ps.blendMode;
    this._onBeforeDrawParticleObserver = null;
    this._updateInAnimate = this._particleSystem.updateInAnimate;
    this._particleSystem.updateInAnimate = true;
    this._particleSystem.render = () => 0;
    this.particleSize = (ps.minSize + ps.maxSize) / 2;
    this.useTrueRenderingForDiffuseTexture = false;
  }
  get particleSystem() {
    return this._particleSystem;
  }
  getClassName() {
    return "FluidRenderingObjectParticleSystem";
  }
  get useTrueRenderingForDiffuseTexture() {
    return this._useTrueRenderingForDiffuseTexture;
  }
  set useTrueRenderingForDiffuseTexture(use) {
    if (this._useTrueRenderingForDiffuseTexture === use) {
      return;
    }
    this._useTrueRenderingForDiffuseTexture = use;
    if (use) {
      this._particleSystem.blendMode = this._blendMode;
      this._particleSystem.onBeforeDrawParticlesObservable.remove(this._onBeforeDrawParticleObserver);
      this._onBeforeDrawParticleObserver = null;
    } else {
      this._particleSystem.blendMode = -1;
      this._onBeforeDrawParticleObserver = this._particleSystem.onBeforeDrawParticlesObservable.add(() => {
        this._engine.setAlphaMode(2);
      });
    }
  }
  get vertexBuffers() {
    return this._particleSystem.vertexBuffers;
  }
  get indexBuffer() {
    return this._particleSystem.indexBuffer;
  }
  isReady() {
    return super.isReady() && this._particleSystem.isReady();
  }
  get numParticles() {
    return this._particleSystem.getActiveCount();
  }
  renderDiffuseTexture() {
    this._originalRender();
  }
  dispose() {
    super.dispose();
    this._particleSystem.onBeforeDrawParticlesObservable.remove(this._onBeforeDrawParticleObserver);
    this._onBeforeDrawParticleObserver = null;
    this._particleSystem.render = this._originalRender;
    this._particleSystem.blendMode = this._blendMode;
    this._particleSystem.updateInAnimate = this._updateInAnimate;
  }
};

// node_modules/@babylonjs/core/Rendering/fluidRenderer/fluidRenderingTextures.js
var FluidRenderingTextures = class {
  constructor(name137, scene, width, height, blurTextureSizeX, blurTextureSizeY, textureType = 1, textureFormat = 6, blurTextureType = 1, blurTextureFormat = 6, useStandardBlur = false, camera = null, generateDepthBuffer = true, samples = 1) {
    this.enableBlur = true;
    this.blurSizeDivisor = 1;
    this.blurFilterSize = 7;
    this._blurNumIterations = 3;
    this.blurMaxFilterSize = 100;
    this.blurDepthScale = 10;
    this.particleSize = 0.02;
    this.onDisposeObservable = new Observable();
    this._name = name137;
    this._scene = scene;
    this._camera = camera;
    this._engine = scene.getEngine();
    this._width = width;
    this._height = height;
    this._blurTextureSizeX = blurTextureSizeX;
    this._blurTextureSizeY = blurTextureSizeY;
    this._textureType = textureType;
    this._textureFormat = textureFormat;
    this._blurTextureType = blurTextureType;
    this._blurTextureFormat = blurTextureFormat;
    this._useStandardBlur = useStandardBlur;
    this._generateDepthBuffer = generateDepthBuffer;
    this._samples = samples;
    this._postProcessRunningIndex = 0;
    this.enableBlur = blurTextureSizeX !== 0 && blurTextureSizeY !== 0;
    this._rt = null;
    this._texture = null;
    this._rtBlur = null;
    this._textureBlurred = null;
    this._blurPostProcesses = null;
  }
  get blurNumIterations() {
    return this._blurNumIterations;
  }
  set blurNumIterations(numIterations) {
    if (this._blurNumIterations === numIterations) {
      return;
    }
    this._blurNumIterations = numIterations;
    if (this._blurPostProcesses !== null) {
      const blurX = this._blurPostProcesses[0];
      const blurY = this._blurPostProcesses[1];
      this._blurPostProcesses = [];
      for (let i = 0; i < this._blurNumIterations * 2; ++i) {
        this._blurPostProcesses[i] = i & 1 ? blurY : blurX;
      }
    }
  }
  get renderTarget() {
    return this._rt;
  }
  get renderTargetBlur() {
    return this._rtBlur;
  }
  get texture() {
    return this._texture;
  }
  get textureBlur() {
    return this._textureBlurred;
  }
  initialize() {
    this.dispose();
    this._createRenderTarget();
    if (this.enableBlur && this._texture) {
      const [rtBlur, textureBlurred, blurPostProcesses] = this._createBlurPostProcesses(this._texture, this._blurTextureType, this._blurTextureFormat, this.blurSizeDivisor, this._name, this._useStandardBlur);
      this._rtBlur = rtBlur;
      this._textureBlurred = textureBlurred;
      this._blurPostProcesses = blurPostProcesses;
    }
  }
  applyBlurPostProcesses() {
    if (this.enableBlur && this._blurPostProcesses) {
      this._postProcessRunningIndex = 0;
      this._scene.postProcessManager.directRender(this._blurPostProcesses, this._rtBlur, true);
      this._engine.unBindFramebuffer(this._rtBlur);
    }
  }
  _createRenderTarget() {
    this._rt = this._engine.createRenderTargetTexture({ width: this._width, height: this._height }, {
      generateMipMaps: false,
      type: this._textureType,
      format: this._textureFormat,
      samplingMode: 1,
      generateDepthBuffer: this._generateDepthBuffer,
      generateStencilBuffer: false,
      samples: this._samples
    });
    const renderTexture = this._rt.texture;
    renderTexture.incrementReferences();
    this._texture = new Texture(null, this._scene);
    this._texture.name = "rtt" + this._name;
    this._texture._texture = renderTexture;
    this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._texture.anisotropicFilteringLevel = 1;
  }
  _createBlurPostProcesses(textureBlurSource, textureType, textureFormat, blurSizeDivisor, debugName, useStandardBlur = false) {
    const engine = this._scene.getEngine();
    const targetSize = new Vector2(Math.floor(this._blurTextureSizeX / blurSizeDivisor), Math.floor(this._blurTextureSizeY / blurSizeDivisor));
    const useBilinearFiltering = textureType === 1 && engine.getCaps().textureFloatLinearFiltering || textureType === 2 && engine.getCaps().textureHalfFloatLinearFiltering;
    const rtBlur = this._engine.createRenderTargetTexture({ width: targetSize.x, height: targetSize.y }, {
      generateMipMaps: false,
      type: textureType,
      format: textureFormat,
      samplingMode: useBilinearFiltering ? 2 : 1,
      generateDepthBuffer: false,
      generateStencilBuffer: false,
      samples: this._samples
    });
    const renderTexture = rtBlur.texture;
    renderTexture.incrementReferences();
    const texture = new Texture(null, this._scene);
    texture.name = "rttBlurred" + debugName;
    texture._texture = renderTexture;
    texture.wrapU = Texture.CLAMP_ADDRESSMODE;
    texture.wrapV = Texture.CLAMP_ADDRESSMODE;
    texture.anisotropicFilteringLevel = 1;
    if (useStandardBlur) {
      const kernelBlurXPostprocess = new PostProcess("BilateralBlurX", "fluidRenderingStandardBlur", ["filterSize", "blurDir"], null, 1, null, 1, engine, true, null, textureType, void 0, void 0, void 0, textureFormat);
      kernelBlurXPostprocess.samples = this._samples;
      kernelBlurXPostprocess.externalTextureSamplerBinding = true;
      kernelBlurXPostprocess.onApplyObservable.add((effect) => {
        if (this._postProcessRunningIndex === 0) {
          effect.setTexture("textureSampler", textureBlurSource);
        } else {
          effect._bindTexture("textureSampler", kernelBlurXPostprocess.inputTexture.texture);
        }
        effect.setInt("filterSize", this.blurFilterSize);
        effect.setFloat2("blurDir", 1 / this._blurTextureSizeX, 0);
        this._postProcessRunningIndex++;
      });
      kernelBlurXPostprocess.onSizeChangedObservable.add(() => {
        kernelBlurXPostprocess._textures.forEach((rt) => {
          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;
          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;
        });
      });
      this._fixReusablePostProcess(kernelBlurXPostprocess);
      const kernelBlurYPostprocess = new PostProcess("BilateralBlurY", "fluidRenderingStandardBlur", ["filterSize", "blurDir"], null, 1, null, 1, engine, true, null, textureType, void 0, void 0, void 0, textureFormat);
      kernelBlurYPostprocess.samples = this._samples;
      kernelBlurYPostprocess.onApplyObservable.add((effect) => {
        effect.setInt("filterSize", this.blurFilterSize);
        effect.setFloat2("blurDir", 0, 1 / this._blurTextureSizeY);
        this._postProcessRunningIndex++;
      });
      kernelBlurYPostprocess.onSizeChangedObservable.add(() => {
        kernelBlurYPostprocess._textures.forEach((rt) => {
          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;
          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;
        });
      });
      this._fixReusablePostProcess(kernelBlurYPostprocess);
      kernelBlurXPostprocess.autoClear = false;
      kernelBlurYPostprocess.autoClear = false;
      const blurList = [];
      for (let i = 0; i < this._blurNumIterations * 2; ++i) {
        blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;
      }
      return [rtBlur, texture, blurList];
    } else {
      const uniforms = ["maxFilterSize", "blurDir", "projectedParticleConstant", "depthThreshold"];
      const kernelBlurXPostprocess = new PostProcess("BilateralBlurX", "fluidRenderingBilateralBlur", uniforms, null, 1, null, 1, engine, true, null, textureType, void 0, void 0, void 0, textureFormat);
      kernelBlurXPostprocess.samples = this._samples;
      kernelBlurXPostprocess.externalTextureSamplerBinding = true;
      kernelBlurXPostprocess.onApplyObservable.add((effect) => {
        if (this._postProcessRunningIndex === 0) {
          effect.setTexture("textureSampler", textureBlurSource);
        } else {
          effect._bindTexture("textureSampler", kernelBlurXPostprocess.inputTexture.texture);
        }
        effect.setInt("maxFilterSize", this.blurMaxFilterSize);
        effect.setFloat2("blurDir", 1 / this._blurTextureSizeX, 0);
        effect.setFloat("projectedParticleConstant", this._getProjectedParticleConstant());
        effect.setFloat("depthThreshold", this._getDepthThreshold());
        this._postProcessRunningIndex++;
      });
      kernelBlurXPostprocess.onSizeChangedObservable.add(() => {
        kernelBlurXPostprocess._textures.forEach((rt) => {
          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;
          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;
        });
      });
      this._fixReusablePostProcess(kernelBlurXPostprocess);
      const kernelBlurYPostprocess = new PostProcess("BilateralBlurY", "fluidRenderingBilateralBlur", uniforms, null, 1, null, 1, engine, true, null, textureType, void 0, void 0, void 0, textureFormat);
      kernelBlurYPostprocess.samples = this._samples;
      kernelBlurYPostprocess.onApplyObservable.add((effect) => {
        effect.setInt("maxFilterSize", this.blurMaxFilterSize);
        effect.setFloat2("blurDir", 0, 1 / this._blurTextureSizeY);
        effect.setFloat("projectedParticleConstant", this._getProjectedParticleConstant());
        effect.setFloat("depthThreshold", this._getDepthThreshold());
        this._postProcessRunningIndex++;
      });
      kernelBlurYPostprocess.onSizeChangedObservable.add(() => {
        kernelBlurYPostprocess._textures.forEach((rt) => {
          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;
          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;
        });
      });
      this._fixReusablePostProcess(kernelBlurYPostprocess);
      kernelBlurXPostprocess.autoClear = false;
      kernelBlurYPostprocess.autoClear = false;
      const blurList = [];
      for (let i = 0; i < this._blurNumIterations * 2; ++i) {
        blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;
      }
      return [rtBlur, texture, blurList];
    }
  }
  _fixReusablePostProcess(pp) {
    if (!pp.isReusable()) {
      return;
    }
    pp.onActivateObservable.add(() => {
      pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;
    });
    pp.onApplyObservable.add(() => {
      pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;
    });
  }
  _getProjectedParticleConstant() {
    var _a, _b;
    return this.blurFilterSize * this.particleSize * 0.05 * (this._height / 2) / Math.tan(((_b = (_a = this._camera) === null || _a === void 0 ? void 0 : _a.fov) !== null && _b !== void 0 ? _b : 45 * Math.PI / 180) / 2);
  }
  _getDepthThreshold() {
    return this.particleSize / 2 * this.blurDepthScale;
  }
  dispose() {
    var _a, _b, _c, _d;
    if (this.onDisposeObservable.hasObservers()) {
      this.onDisposeObservable.notifyObservers(this);
    }
    (_a = this._rt) === null || _a === void 0 ? void 0 : _a.dispose();
    this._rt = null;
    (_b = this._texture) === null || _b === void 0 ? void 0 : _b.dispose();
    this._texture = null;
    (_c = this._rtBlur) === null || _c === void 0 ? void 0 : _c.dispose();
    this._rtBlur = null;
    (_d = this._textureBlurred) === null || _d === void 0 ? void 0 : _d.dispose();
    this._textureBlurred = null;
    if (this._blurPostProcesses) {
      this._blurPostProcesses[0].dispose();
      this._blurPostProcesses[1].dispose();
    }
    this._blurPostProcesses = null;
  }
};

// node_modules/@babylonjs/core/Rendering/fluidRenderer/fluidRenderingTargetRenderer.js
var FluidRenderingDebug;
(function(FluidRenderingDebug2) {
  FluidRenderingDebug2[FluidRenderingDebug2["DepthTexture"] = 0] = "DepthTexture";
  FluidRenderingDebug2[FluidRenderingDebug2["DepthBlurredTexture"] = 1] = "DepthBlurredTexture";
  FluidRenderingDebug2[FluidRenderingDebug2["ThicknessTexture"] = 2] = "ThicknessTexture";
  FluidRenderingDebug2[FluidRenderingDebug2["ThicknessBlurredTexture"] = 3] = "ThicknessBlurredTexture";
  FluidRenderingDebug2[FluidRenderingDebug2["DiffuseTexture"] = 4] = "DiffuseTexture";
  FluidRenderingDebug2[FluidRenderingDebug2["Normals"] = 5] = "Normals";
  FluidRenderingDebug2[FluidRenderingDebug2["DiffuseRendering"] = 6] = "DiffuseRendering";
})(FluidRenderingDebug || (FluidRenderingDebug = {}));
var FluidRenderingTargetRenderer = class {
  constructor(scene, camera) {
    this._generateDiffuseTexture = false;
    this.fluidColor = new Color3(0.085, 0.6375, 0.765);
    this.density = 2;
    this.refractionStrength = 0.1;
    this.fresnelClamp = 1;
    this.specularPower = 250;
    this.minimumThickness = 0;
    this.dirLight = new Vector3(-2, -1, 1).normalize();
    this._debugFeature = FluidRenderingDebug.DepthBlurredTexture;
    this._debug = false;
    this._enableBlurDepth = true;
    this._blurDepthSizeDivisor = 1;
    this._blurDepthFilterSize = 7;
    this._blurDepthNumIterations = 3;
    this._blurDepthMaxFilterSize = 100;
    this._blurDepthDepthScale = 10;
    this._enableBlurThickness = true;
    this._blurThicknessSizeDivisor = 1;
    this._blurThicknessFilterSize = 5;
    this._blurThicknessNumIterations = 1;
    this._useFixedThickness = false;
    this._onUseVelocityChanged = new Observable();
    this._useVelocity = false;
    this._depthMapSize = null;
    this._thicknessMapSize = null;
    this._diffuseMapSize = null;
    this._samples = 1;
    this._scene = scene;
    this._engine = scene.getEngine();
    this._camera = camera !== null && camera !== void 0 ? camera : scene.activeCamera;
    this._needInitialization = true;
    this._bgDepthTexture = null;
    this._invProjectionMatrix = new Matrix();
    this._depthClearColor = new Color4(1e6, 1e6, 1e6, 1);
    this._thicknessClearColor = new Color4(0, 0, 0, 1);
    this._depthRenderTarget = null;
    this._diffuseRenderTarget = null;
    this._thicknessRenderTarget = null;
    this._renderPostProcess = null;
  }
  get needInitialization() {
    return this._needInitialization;
  }
  get generateDiffuseTexture() {
    return this._generateDiffuseTexture;
  }
  set generateDiffuseTexture(generate) {
    if (this._generateDiffuseTexture === generate) {
      return;
    }
    this._generateDiffuseTexture = generate;
    this._needInitialization = true;
  }
  get debugFeature() {
    return this._debugFeature;
  }
  set debugFeature(feature) {
    if (this._debugFeature === feature) {
      return;
    }
    this._needInitialization = true;
    this._debugFeature = feature;
  }
  get debug() {
    return this._debug;
  }
  set debug(debug) {
    if (this._debug === debug) {
      return;
    }
    this._debug = debug;
    this._needInitialization = true;
  }
  get environmentMap() {
    return this._environmentMap;
  }
  set environmentMap(map) {
    if (this._environmentMap === map) {
      return;
    }
    this._needInitialization = true;
    this._environmentMap = map;
  }
  get enableBlurDepth() {
    return this._enableBlurDepth;
  }
  set enableBlurDepth(enable) {
    if (this._enableBlurDepth === enable) {
      return;
    }
    this._enableBlurDepth = enable;
    this._needInitialization = true;
  }
  get blurDepthSizeDivisor() {
    return this._blurDepthSizeDivisor;
  }
  set blurDepthSizeDivisor(scale) {
    if (this._blurDepthSizeDivisor === scale) {
      return;
    }
    this._blurDepthSizeDivisor = scale;
    this._needInitialization = true;
  }
  get blurDepthFilterSize() {
    return this._blurDepthFilterSize;
  }
  set blurDepthFilterSize(filterSize) {
    if (this._blurDepthFilterSize === filterSize) {
      return;
    }
    this._blurDepthFilterSize = filterSize;
    this._setBlurParameters();
  }
  get blurDepthNumIterations() {
    return this._blurDepthNumIterations;
  }
  set blurDepthNumIterations(numIterations) {
    if (this._blurDepthNumIterations === numIterations) {
      return;
    }
    this._blurDepthNumIterations = numIterations;
    this._setBlurParameters();
  }
  get blurDepthMaxFilterSize() {
    return this._blurDepthMaxFilterSize;
  }
  set blurDepthMaxFilterSize(maxFilterSize) {
    if (this._blurDepthMaxFilterSize === maxFilterSize) {
      return;
    }
    this._blurDepthMaxFilterSize = maxFilterSize;
    this._setBlurParameters();
  }
  get blurDepthDepthScale() {
    return this._blurDepthDepthScale;
  }
  set blurDepthDepthScale(scale) {
    if (this._blurDepthDepthScale === scale) {
      return;
    }
    this._blurDepthDepthScale = scale;
    this._setBlurParameters();
  }
  get enableBlurThickness() {
    return this._enableBlurThickness;
  }
  set enableBlurThickness(enable) {
    if (this._enableBlurThickness === enable) {
      return;
    }
    this._enableBlurThickness = enable;
    this._needInitialization = true;
  }
  get blurThicknessSizeDivisor() {
    return this._blurThicknessSizeDivisor;
  }
  set blurThicknessSizeDivisor(scale) {
    if (this._blurThicknessSizeDivisor === scale) {
      return;
    }
    this._blurThicknessSizeDivisor = scale;
    this._needInitialization = true;
  }
  get blurThicknessFilterSize() {
    return this._blurThicknessFilterSize;
  }
  set blurThicknessFilterSize(filterSize) {
    if (this._blurThicknessFilterSize === filterSize) {
      return;
    }
    this._blurThicknessFilterSize = filterSize;
    this._setBlurParameters();
  }
  get blurThicknessNumIterations() {
    return this._blurThicknessNumIterations;
  }
  set blurThicknessNumIterations(numIterations) {
    if (this._blurThicknessNumIterations === numIterations) {
      return;
    }
    this._blurThicknessNumIterations = numIterations;
    this._setBlurParameters();
  }
  get useFixedThickness() {
    return this._useFixedThickness;
  }
  set useFixedThickness(use) {
    if (this._useFixedThickness === use) {
      return;
    }
    this._useFixedThickness = use;
    this._needInitialization = true;
  }
  get useVelocity() {
    return this._useVelocity;
  }
  set useVelocity(use) {
    if (this._useVelocity === use) {
      return;
    }
    this._useVelocity = use;
    this._needInitialization = true;
    this._onUseVelocityChanged.notifyObservers(this);
  }
  get depthMapSize() {
    return this._depthMapSize;
  }
  set depthMapSize(size) {
    if (this._depthMapSize === size) {
      return;
    }
    this._depthMapSize = size;
    this._needInitialization = true;
  }
  get thicknessMapSize() {
    return this._thicknessMapSize;
  }
  set thicknessMapSize(size) {
    if (this._thicknessMapSize === size) {
      return;
    }
    this._thicknessMapSize = size;
    this._needInitialization = true;
  }
  get diffuseMapSize() {
    return this._diffuseMapSize;
  }
  set diffuseMapSize(size) {
    if (this._diffuseMapSize === size) {
      return;
    }
    this._diffuseMapSize = size;
    this._needInitialization = true;
  }
  get samples() {
    return this._samples;
  }
  set samples(samples) {
    if (this._samples === samples) {
      return;
    }
    this._samples = samples;
    this._needInitialization = true;
  }
  get camera() {
    return this._camera;
  }
  _initialize() {
    var _a, _b, _c;
    this.dispose();
    this._needInitialization = false;
    const depthWidth = (_a = this._depthMapSize) !== null && _a !== void 0 ? _a : this._engine.getRenderWidth();
    const depthHeight = this._depthMapSize !== null ? Math.round(this._depthMapSize * this._engine.getRenderHeight() / this._engine.getRenderWidth()) : this._engine.getRenderHeight();
    this._depthRenderTarget = new FluidRenderingTextures("Depth", this._scene, depthWidth, depthHeight, depthWidth, depthHeight, 1, 7, 1, 7, false, this._camera, true, this._samples);
    this._initializeRenderTarget(this._depthRenderTarget);
    if (this.generateDiffuseTexture) {
      const diffuseWidth = (_b = this._diffuseMapSize) !== null && _b !== void 0 ? _b : this._engine.getRenderWidth();
      const diffuseHeight = this._diffuseMapSize !== null ? Math.round(this._diffuseMapSize * this._engine.getRenderHeight() / this._engine.getRenderWidth()) : this._engine.getRenderHeight();
      this._diffuseRenderTarget = new FluidRenderingTextures("Diffuse", this._scene, diffuseWidth, diffuseHeight, 0, 0, 0, 5, 0, 5, true, this._camera, true, this._samples);
      this._initializeRenderTarget(this._diffuseRenderTarget);
    }
    const thicknessWidth = (_c = this._thicknessMapSize) !== null && _c !== void 0 ? _c : this._engine.getRenderWidth();
    const thicknessHeight = this._thicknessMapSize !== null ? Math.round(this._thicknessMapSize * this._engine.getRenderHeight() / this._engine.getRenderWidth()) : this._engine.getRenderHeight();
    if (!this._useFixedThickness) {
      this._thicknessRenderTarget = new FluidRenderingTextures("Thickness", this._scene, thicknessWidth, thicknessHeight, thicknessWidth, thicknessHeight, 2, 6, 2, 6, true, this._camera, false, this._samples);
      this._initializeRenderTarget(this._thicknessRenderTarget);
    }
    this._createLiquidRenderingPostProcess();
  }
  _setBlurParameters(renderTarget = null) {
    if (renderTarget === null || renderTarget === this._depthRenderTarget) {
      this._setBlurDepthParameters();
    }
    if (renderTarget === null || renderTarget === this._thicknessRenderTarget) {
      this._setBlurThicknessParameters();
    }
  }
  _setBlurDepthParameters() {
    if (!this._depthRenderTarget) {
      return;
    }
    this._depthRenderTarget.blurFilterSize = this.blurDepthFilterSize;
    this._depthRenderTarget.blurMaxFilterSize = this.blurDepthMaxFilterSize;
    this._depthRenderTarget.blurNumIterations = this.blurDepthNumIterations;
    this._depthRenderTarget.blurDepthScale = this.blurDepthDepthScale;
  }
  _setBlurThicknessParameters() {
    if (!this._thicknessRenderTarget) {
      return;
    }
    this._thicknessRenderTarget.blurFilterSize = this.blurThicknessFilterSize;
    this._thicknessRenderTarget.blurNumIterations = this.blurThicknessNumIterations;
  }
  _initializeRenderTarget(renderTarget) {
    if (renderTarget !== this._diffuseRenderTarget) {
      renderTarget.enableBlur = renderTarget === this._depthRenderTarget ? this.enableBlurDepth : this.enableBlurThickness;
      renderTarget.blurSizeDivisor = renderTarget === this._depthRenderTarget ? this.blurDepthSizeDivisor : this.blurThicknessSizeDivisor;
    }
    this._setBlurParameters(renderTarget);
    renderTarget.initialize();
  }
  _createLiquidRenderingPostProcess() {
    var _a;
    const engine = this._scene.getEngine();
    const uniformNames = [
      "viewMatrix",
      "projectionMatrix",
      "invProjectionMatrix",
      "texelSize",
      "dirLight",
      "cameraFar",
      "density",
      "refractionStrength",
      "fresnelClamp",
      "specularPower"
    ];
    const samplerNames = ["depthSampler"];
    const defines = [];
    this.dispose(true);
    if (!this._camera) {
      return;
    }
    const texture = this._depthRenderTarget.enableBlur ? this._depthRenderTarget.textureBlur : this._depthRenderTarget.texture;
    const texelSize = new Vector2(1 / texture.getSize().width, 1 / texture.getSize().height);
    if (this._environmentMap !== null) {
      const envMap = (_a = this._environmentMap) !== null && _a !== void 0 ? _a : this._scene.environmentTexture;
      if (envMap) {
        samplerNames.push("reflectionSampler");
        defines.push("#define FLUIDRENDERING_ENVIRONMENT");
      }
    }
    if (this._diffuseRenderTarget) {
      samplerNames.push("diffuseSampler");
      defines.push("#define FLUIDRENDERING_DIFFUSETEXTURE");
    } else {
      uniformNames.push("diffuseColor");
    }
    if (this._useVelocity) {
      samplerNames.push("velocitySampler");
      defines.push("#define FLUIDRENDERING_VELOCITY");
    }
    if (this._useFixedThickness) {
      uniformNames.push("thickness");
      samplerNames.push("bgDepthSampler");
      defines.push("#define FLUIDRENDERING_FIXED_THICKNESS");
    } else {
      uniformNames.push("minimumThickness");
      samplerNames.push("thicknessSampler");
    }
    if (this._debug) {
      defines.push("#define FLUIDRENDERING_DEBUG");
      if (this._debugFeature === FluidRenderingDebug.Normals) {
        defines.push("#define FLUIDRENDERING_DEBUG_SHOWNORMAL");
      } else if (this._debugFeature === FluidRenderingDebug.DiffuseRendering) {
        defines.push("#define FLUIDRENDERING_DEBUG_DIFFUSERENDERING");
      } else {
        defines.push("#define FLUIDRENDERING_DEBUG_TEXTURE");
        samplerNames.push("debugSampler");
        if (this._debugFeature === FluidRenderingDebug.DepthTexture || this._debugFeature === FluidRenderingDebug.DepthBlurredTexture) {
          defines.push("#define FLUIDRENDERING_DEBUG_DEPTH");
        }
      }
    }
    this._renderPostProcess = new PostProcess("FluidRendering", "fluidRenderingRender", uniformNames, samplerNames, 1, null, 2, engine, false, null, 0, void 0, void 0, true, void 0);
    this._renderPostProcess.updateEffect(defines.join("\n"));
    this._renderPostProcess.samples = this._samples;
    this._renderPostProcess.onApplyObservable.add((effect) => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
      this._invProjectionMatrix.copyFrom(this._scene.getProjectionMatrix());
      this._invProjectionMatrix.invert();
      if (engine.isWebGPU) {
        effect.setTextureSampler("textureSamplerSampler", this._renderPostProcess.inputTexture.texture);
      }
      if (!this._depthRenderTarget.enableBlur) {
        effect.setTexture("depthSampler", this._depthRenderTarget.texture);
        if (engine.isWebGPU) {
          effect.setTextureSampler("depthSamplerSampler", (_b = (_a2 = this._depthRenderTarget.texture) === null || _a2 === void 0 ? void 0 : _a2.getInternalTexture()) !== null && _b !== void 0 ? _b : null);
        }
      } else {
        effect.setTexture("depthSampler", this._depthRenderTarget.textureBlur);
        if (engine.isWebGPU) {
          effect.setTextureSampler("depthSamplerSampler", (_d = (_c = this._depthRenderTarget.textureBlur) === null || _c === void 0 ? void 0 : _c.getInternalTexture()) !== null && _d !== void 0 ? _d : null);
        }
      }
      if (this._diffuseRenderTarget) {
        if (!this._diffuseRenderTarget.enableBlur) {
          effect.setTexture("diffuseSampler", this._diffuseRenderTarget.texture);
          if (engine.isWebGPU) {
            effect.setTextureSampler("diffuseSamplerSampler", (_f = (_e = this._diffuseRenderTarget.texture) === null || _e === void 0 ? void 0 : _e.getInternalTexture()) !== null && _f !== void 0 ? _f : null);
          }
        } else {
          effect.setTexture("diffuseSampler", this._diffuseRenderTarget.textureBlur);
          if (engine.isWebGPU) {
            effect.setTextureSampler("diffuseSamplerSampler", (_h = (_g = this._diffuseRenderTarget.textureBlur) === null || _g === void 0 ? void 0 : _g.getInternalTexture()) !== null && _h !== void 0 ? _h : null);
          }
        }
      } else {
        effect.setColor3("diffuseColor", this.fluidColor);
      }
      if (this._useFixedThickness) {
        effect.setFloat("thickness", this.minimumThickness);
        effect._bindTexture("bgDepthSampler", this._bgDepthTexture);
        if (engine.isWebGPU) {
          effect.setTextureSampler("bgDepthSamplerSampler", (_j = this._bgDepthTexture) !== null && _j !== void 0 ? _j : null);
        }
      } else {
        if (!this._thicknessRenderTarget.enableBlur) {
          effect.setTexture("thicknessSampler", this._thicknessRenderTarget.texture);
          if (engine.isWebGPU) {
            effect.setTextureSampler("thicknessSamplerSampler", (_l = (_k = this._thicknessRenderTarget.texture) === null || _k === void 0 ? void 0 : _k.getInternalTexture()) !== null && _l !== void 0 ? _l : null);
          }
        } else {
          effect.setTexture("thicknessSampler", this._thicknessRenderTarget.textureBlur);
          if (engine.isWebGPU) {
            effect.setTextureSampler("thicknessSamplerSampler", (_o = (_m = this._thicknessRenderTarget.textureBlur) === null || _m === void 0 ? void 0 : _m.getInternalTexture()) !== null && _o !== void 0 ? _o : null);
          }
        }
        effect.setFloat("minimumThickness", this.minimumThickness);
      }
      if (this._environmentMap !== null) {
        const envMap = (_p = this._environmentMap) !== null && _p !== void 0 ? _p : this._scene.environmentTexture;
        if (envMap) {
          effect.setTexture("reflectionSampler", envMap);
          if (engine.isWebGPU) {
            effect.setTextureSampler("reflectionSamplerSampler", (_q = envMap === null || envMap === void 0 ? void 0 : envMap.getInternalTexture()) !== null && _q !== void 0 ? _q : null);
          }
        }
      }
      effect.setMatrix("viewMatrix", this._scene.getViewMatrix());
      effect.setMatrix("invProjectionMatrix", this._invProjectionMatrix);
      effect.setMatrix("projectionMatrix", this._scene.getProjectionMatrix());
      effect.setVector2("texelSize", texelSize);
      effect.setFloat("density", this.density);
      effect.setFloat("refractionStrength", this.refractionStrength);
      effect.setFloat("fresnelClamp", this.fresnelClamp);
      effect.setFloat("specularPower", this.specularPower);
      effect.setVector3("dirLight", this.dirLight);
      effect.setFloat("cameraFar", this._camera.maxZ);
      if (this._debug) {
        let texture2 = null;
        switch (this._debugFeature) {
          case FluidRenderingDebug.DepthTexture:
            texture2 = this._depthRenderTarget.texture;
            break;
          case FluidRenderingDebug.DepthBlurredTexture:
            texture2 = this._depthRenderTarget.enableBlur ? this._depthRenderTarget.textureBlur : this._depthRenderTarget.texture;
            break;
          case FluidRenderingDebug.ThicknessTexture:
            texture2 = (_s = (_r = this._thicknessRenderTarget) === null || _r === void 0 ? void 0 : _r.texture) !== null && _s !== void 0 ? _s : null;
            break;
          case FluidRenderingDebug.ThicknessBlurredTexture:
            texture2 = ((_t = this._thicknessRenderTarget) === null || _t === void 0 ? void 0 : _t.enableBlur) ? (_v = (_u = this._thicknessRenderTarget) === null || _u === void 0 ? void 0 : _u.textureBlur) !== null && _v !== void 0 ? _v : null : (_x = (_w = this._thicknessRenderTarget) === null || _w === void 0 ? void 0 : _w.texture) !== null && _x !== void 0 ? _x : null;
            break;
          case FluidRenderingDebug.DiffuseTexture:
            if (this._diffuseRenderTarget) {
              texture2 = this._diffuseRenderTarget.texture;
            }
            break;
        }
        if (this._debugFeature !== FluidRenderingDebug.Normals) {
          effect.setTexture("debugSampler", texture2);
          if (engine.isWebGPU) {
            effect.setTextureSampler("debugSamplerSampler", (_y = texture2 === null || texture2 === void 0 ? void 0 : texture2.getInternalTexture()) !== null && _y !== void 0 ? _y : null);
          }
        }
      }
    });
  }
  _clearTargets() {
    var _a, _b, _c;
    if ((_a = this._depthRenderTarget) === null || _a === void 0 ? void 0 : _a.renderTarget) {
      this._engine.bindFramebuffer(this._depthRenderTarget.renderTarget);
      this._engine.clear(this._depthClearColor, true, true, false);
      this._engine.unBindFramebuffer(this._depthRenderTarget.renderTarget);
    }
    if ((_b = this._diffuseRenderTarget) === null || _b === void 0 ? void 0 : _b.renderTarget) {
      this._engine.bindFramebuffer(this._diffuseRenderTarget.renderTarget);
      this._engine.clear(this._thicknessClearColor, true, true, false);
      this._engine.unBindFramebuffer(this._diffuseRenderTarget.renderTarget);
    }
    if ((_c = this._thicknessRenderTarget) === null || _c === void 0 ? void 0 : _c.renderTarget) {
      this._engine.bindFramebuffer(this._thicknessRenderTarget.renderTarget);
      this._engine.clear(this._thicknessClearColor, true, false, false);
      this._engine.unBindFramebuffer(this._thicknessRenderTarget.renderTarget);
    }
  }
  _render(fluidObject) {
    var _a, _b, _c, _d, _e, _f;
    if (this._needInitialization || !fluidObject.isReady()) {
      return;
    }
    const currentRenderTarget = this._engine._currentRenderTarget;
    this._engine.setState(false, void 0, void 0, void 0, true);
    this._engine.setDepthBuffer(true);
    this._engine.setDepthWrite(true);
    this._engine.setAlphaMode(0);
    if ((_a = this._depthRenderTarget) === null || _a === void 0 ? void 0 : _a.renderTarget) {
      this._engine.bindFramebuffer(this._depthRenderTarget.renderTarget);
      fluidObject.renderDepthTexture();
      this._engine.unbindInstanceAttributes();
      this._engine.unBindFramebuffer(this._depthRenderTarget.renderTarget);
    }
    if ((_b = this._diffuseRenderTarget) === null || _b === void 0 ? void 0 : _b.renderTarget) {
      this._engine.bindFramebuffer(this._diffuseRenderTarget.renderTarget);
      fluidObject.renderDiffuseTexture();
      this._engine.unbindInstanceAttributes();
      this._engine.unBindFramebuffer(this._diffuseRenderTarget.renderTarget);
    }
    if ((_c = this._thicknessRenderTarget) === null || _c === void 0 ? void 0 : _c.renderTarget) {
      this._engine.bindFramebuffer(this._thicknessRenderTarget.renderTarget);
      fluidObject.renderThicknessTexture();
      this._engine.unbindInstanceAttributes();
      this._engine.unBindFramebuffer(this._thicknessRenderTarget.renderTarget);
    }
    (_d = this._depthRenderTarget) === null || _d === void 0 ? void 0 : _d.applyBlurPostProcesses();
    (_e = this._diffuseRenderTarget) === null || _e === void 0 ? void 0 : _e.applyBlurPostProcesses();
    (_f = this._thicknessRenderTarget) === null || _f === void 0 ? void 0 : _f.applyBlurPostProcesses();
    if (currentRenderTarget) {
      this._engine.bindFramebuffer(currentRenderTarget);
    }
  }
  dispose(onlyPostProcesses = false) {
    var _a, _b, _c, _d;
    if (!onlyPostProcesses) {
      (_a = this._depthRenderTarget) === null || _a === void 0 ? void 0 : _a.dispose();
      this._depthRenderTarget = null;
      (_b = this._diffuseRenderTarget) === null || _b === void 0 ? void 0 : _b.dispose();
      this._diffuseRenderTarget = null;
      (_c = this._thicknessRenderTarget) === null || _c === void 0 ? void 0 : _c.dispose();
      this._thicknessRenderTarget = null;
    }
    if (this._renderPostProcess && this._camera) {
      this._camera.detachPostProcess(this._renderPostProcess);
    }
    (_d = this._renderPostProcess) === null || _d === void 0 ? void 0 : _d.dispose();
    this._renderPostProcess = null;
    this._needInitialization = false;
  }
};

// node_modules/@babylonjs/core/Rendering/fluidRenderer/fluidRenderingObjectCustomParticles.js
var FluidRenderingObjectCustomParticles = class extends FluidRenderingObject {
  constructor(scene, buffers, numParticles) {
    super(scene);
    this._numParticles = numParticles;
    this._diffuseEffectWrapper = null;
    this._vertexBuffers = {};
    this.addBuffers(buffers);
  }
  getClassName() {
    return "FluidRenderingObjectCustomParticles";
  }
  get vertexBuffers() {
    return this._vertexBuffers;
  }
  addBuffers(buffers) {
    for (const name137 in buffers) {
      let stride;
      let instanced = true;
      switch (name137) {
        case "velocity":
          stride = 3;
          break;
        case "offset":
          instanced = false;
          break;
      }
      this._vertexBuffers[name137] = new VertexBuffer(this._engine, buffers[name137], name137, true, false, stride, instanced);
    }
  }
  _createEffects() {
    super._createEffects();
    const uniformNames = ["view", "projection", "size"];
    const attributeNames = ["position", "offset", "color"];
    this._diffuseEffectWrapper = new EffectWrapper({
      engine: this._engine,
      useShaderStore: true,
      vertexShader: "fluidRenderingParticleDiffuse",
      fragmentShader: "fluidRenderingParticleDiffuse",
      attributeNames,
      uniformNames,
      samplerNames: []
    });
  }
  isReady() {
    var _a, _b;
    if (!this._vertexBuffers["offset"]) {
      this._vertexBuffers["offset"] = new VertexBuffer(this._engine, [0, 0, 1, 0, 0, 1, 1, 1], "offset", false, false, 2);
    }
    return super.isReady() && ((_b = (_a = this._diffuseEffectWrapper) === null || _a === void 0 ? void 0 : _a.effect.isReady()) !== null && _b !== void 0 ? _b : false);
  }
  get numParticles() {
    return this._numParticles;
  }
  setNumParticles(num) {
    this._numParticles = num;
  }
  renderDiffuseTexture() {
    const numParticles = this.numParticles;
    if (!this._diffuseEffectWrapper || numParticles === 0) {
      return;
    }
    const diffuseDrawWrapper = this._diffuseEffectWrapper._drawWrapper;
    const diffuseEffect = diffuseDrawWrapper.effect;
    this._engine.enableEffect(diffuseDrawWrapper);
    this._engine.bindBuffers(this.vertexBuffers, this.indexBuffer, diffuseEffect);
    diffuseEffect.setMatrix("view", this._scene.getViewMatrix());
    diffuseEffect.setMatrix("projection", this._scene.getProjectionMatrix());
    if (this._particleSize !== null) {
      diffuseEffect.setFloat2("size", this._particleSize, this._particleSize);
    }
    if (this.useInstancing) {
      this._engine.drawArraysType(7, 0, 4, numParticles);
    } else {
      this._engine.drawElementsType(0, 0, numParticles);
    }
  }
  dispose() {
    var _a;
    super.dispose();
    (_a = this._diffuseEffectWrapper) === null || _a === void 0 ? void 0 : _a.dispose();
    for (const name137 in this._vertexBuffers) {
      this._vertexBuffers[name137].dispose();
    }
    this._vertexBuffers = {};
  }
};

// node_modules/@babylonjs/core/Shaders/copyTextureToTexture.fragment.js
var name122 = "copyTextureToTexturePixelShader";
var shader122 = `uniform float conversion;
uniform sampler2D textureSampler;
varying vec2 vUV;
#include<helperFunctions>
void main(void) 
{
vec4 color=texture2D(textureSampler,vUV);
#ifdef DEPTH_TEXTURE
gl_FragDepth=color.r;
#else
if (conversion==1.) {
color=toLinearSpace(color);
} else if (conversion==2.) {
color=toGammaSpace(color);
}
gl_FragColor=color;
#endif
}
`;
ShaderStore.ShadersStore[name122] = shader122;

// node_modules/@babylonjs/core/Misc/copyTextureToTexture.js
var ConversionMode;
(function(ConversionMode2) {
  ConversionMode2[ConversionMode2["None"] = 0] = "None";
  ConversionMode2[ConversionMode2["ToLinearSpace"] = 1] = "ToLinearSpace";
  ConversionMode2[ConversionMode2["ToGammaSpace"] = 2] = "ToGammaSpace";
})(ConversionMode || (ConversionMode = {}));
var CopyTextureToTexture = class {
  constructor(engine, isDepthTexture = false) {
    this._engine = engine;
    this._isDepthTexture = isDepthTexture;
    this._renderer = new EffectRenderer(engine);
    this._effectWrapper = new EffectWrapper({
      engine,
      name: "CopyTextureToTexture",
      fragmentShader: "copyTextureToTexture",
      useShaderStore: true,
      uniformNames: ["conversion"],
      samplerNames: ["textureSampler"],
      defines: isDepthTexture ? ["#define DEPTH_TEXTURE"] : []
    });
    this._effectWrapper.onApplyObservable.add(() => {
      if (isDepthTexture) {
        engine.setState(false);
        engine.setDepthBuffer(true);
        engine.depthCullingState.depthMask = true;
        engine.depthCullingState.depthFunc = 519;
      }
      if (this._textureIsInternal(this._source)) {
        this._effectWrapper.effect._bindTexture("textureSampler", this._source);
      } else {
        this._effectWrapper.effect.setTexture("textureSampler", this._source);
      }
      this._effectWrapper.effect.setFloat("conversion", this._conversion);
    });
  }
  _textureIsInternal(texture) {
    return texture.getInternalTexture === void 0;
  }
  isReady() {
    return this._effectWrapper.effect.isReady();
  }
  copy(source, destination, conversion = ConversionMode.None) {
    if (!this.isReady()) {
      return false;
    }
    this._source = source;
    this._conversion = conversion;
    const engineDepthFunc = this._engine.depthCullingState.depthFunc;
    this._renderer.render(this._effectWrapper, destination);
    if (this._isDepthTexture && engineDepthFunc) {
      this._engine.depthCullingState.depthFunc = engineDepthFunc;
    }
    return true;
  }
  dispose() {
    this._effectWrapper.dispose();
    this._renderer.dispose();
  }
};

// node_modules/@babylonjs/core/Rendering/fluidRenderer/fluidRenderingDepthTextureCopy.js
var FluidRenderingDepthTextureCopy = class {
  constructor(engine, width, height, samples = 1) {
    this._engine = engine;
    this._copyTextureToTexture = new CopyTextureToTexture(engine, true);
    this._depthRTWrapper = this._engine.createRenderTargetTexture({ width, height }, {
      generateMipMaps: false,
      type: 0,
      format: 6,
      samplingMode: 1,
      generateDepthBuffer: true,
      generateStencilBuffer: false,
      samples,
      noColorAttachment: true
    });
    this._depthRTWrapper.createDepthStencilTexture(0, false, false, 1);
  }
  get depthRTWrapper() {
    return this._depthRTWrapper;
  }
  copy(source) {
    return this._copyTextureToTexture.copy(source, this._depthRTWrapper);
  }
  dispose() {
    this._depthRTWrapper.dispose();
    this._copyTextureToTexture.dispose();
  }
};

// node_modules/@babylonjs/core/Shaders/fluidRenderingParticleDepth.vertex.js
var name123 = "fluidRenderingParticleDepthVertexShader";
var shader123 = `attribute vec3 position;
attribute vec2 offset;
uniform mat4 view;
uniform mat4 projection;
uniform vec2 size;
varying vec2 uv;
varying vec3 viewPos;
varying float sphereRadius;
#ifdef FLUIDRENDERING_VELOCITY
attribute vec3 velocity;
varying float velocityNorm;
#endif
void main(void) {
vec3 cornerPos;
cornerPos.xy=vec2(offset.x-0.5,offset.y-0.5)*size;
cornerPos.z=0.0;
viewPos=(view*vec4(position,1.0)).xyz;
gl_Position=projection*vec4(viewPos+cornerPos,1.0);
uv=offset;
sphereRadius=size.x/2.0;
#ifdef FLUIDRENDERING_VELOCITY
velocityNorm=length(velocity);
#endif
}
`;
ShaderStore.ShadersStore[name123] = shader123;

// node_modules/@babylonjs/core/Shaders/fluidRenderingParticleDepth.fragment.js
var name124 = "fluidRenderingParticleDepthPixelShader";
var shader124 = `uniform mat4 projection;
varying vec2 uv;
varying vec3 viewPos;
varying float sphereRadius;
#ifdef FLUIDRENDERING_VELOCITY
varying float velocityNorm;
#endif
void main(void) {
vec3 normal;
normal.xy=uv*2.0-1.0;
float r2=dot(normal.xy,normal.xy);
if (r2>1.0) discard;
normal.z=-sqrt(1.0-r2);
vec4 realViewPos=vec4(viewPos+normal*sphereRadius,1.0);
vec4 clipSpacePos=projection*realViewPos;
#ifdef WEBGPU
gl_FragDepth=clipSpacePos.z/clipSpacePos.w;
#else
gl_FragDepth=(clipSpacePos.z/clipSpacePos.w)*0.5+0.5;
#endif
#ifdef FLUIDRENDERING_VELOCITY
glFragColor=vec4(realViewPos.z,velocityNorm,0.,1.);
#else
glFragColor=vec4(realViewPos.z,0.,0.,1.);
#endif
}
`;
ShaderStore.ShadersStore[name124] = shader124;

// node_modules/@babylonjs/core/Shaders/fluidRenderingParticleThickness.vertex.js
var name125 = "fluidRenderingParticleThicknessVertexShader";
var shader125 = `attribute vec3 position;
attribute vec2 offset;
uniform mat4 view;
uniform mat4 projection;
uniform vec2 size;
varying vec2 uv;
void main(void) {
vec3 cornerPos;
cornerPos.xy=vec2(offset.x-0.5,offset.y-0.5)*size;
cornerPos.z=0.0;
vec3 viewPos=(view*vec4(position,1.0)).xyz+cornerPos;
gl_Position=projection*vec4(viewPos,1.0);
uv=offset;
}
`;
ShaderStore.ShadersStore[name125] = shader125;

// node_modules/@babylonjs/core/Shaders/fluidRenderingParticleThickness.fragment.js
var name126 = "fluidRenderingParticleThicknessPixelShader";
var shader126 = `uniform float particleAlpha;
varying vec2 uv;
void main(void) {
vec3 normal;
normal.xy=uv*2.0-1.0;
float r2=dot(normal.xy,normal.xy);
if (r2>1.0) discard;
float thickness=sqrt(1.0-r2);
glFragColor=vec4(vec3(particleAlpha*thickness),1.0);
}
`;
ShaderStore.ShadersStore[name126] = shader126;

// node_modules/@babylonjs/core/Shaders/fluidRenderingParticleDiffuse.vertex.js
var name127 = "fluidRenderingParticleDiffuseVertexShader";
var shader127 = `attribute vec3 position;
attribute vec2 offset;
attribute vec4 color;
uniform mat4 view;
uniform mat4 projection;
uniform vec2 size;
varying vec2 uv;
varying vec3 diffuseColor;
void main(void) {
vec3 cornerPos;
cornerPos.xy=vec2(offset.x-0.5,offset.y-0.5)*size;
cornerPos.z=0.0;
vec3 viewPos=(view*vec4(position,1.0)).xyz+cornerPos;
gl_Position=projection*vec4(viewPos,1.0);
uv=offset;
diffuseColor=color.rgb;
}
`;
ShaderStore.ShadersStore[name127] = shader127;

// node_modules/@babylonjs/core/Shaders/fluidRenderingParticleDiffuse.fragment.js
var name128 = "fluidRenderingParticleDiffusePixelShader";
var shader128 = `uniform float particleAlpha;
varying vec2 uv;
varying vec3 diffuseColor;
void main(void) {
vec3 normal;
normal.xy=uv*2.0-1.0;
float r2=dot(normal.xy,normal.xy);
if (r2>1.0) discard;
glFragColor=vec4(diffuseColor,1.0);
}
`;
ShaderStore.ShadersStore[name128] = shader128;

// node_modules/@babylonjs/core/Shaders/fluidRenderingBilateralBlur.fragment.js
var name129 = "fluidRenderingBilateralBlurPixelShader";
var shader129 = `uniform sampler2D textureSampler;
uniform int maxFilterSize;
uniform vec2 blurDir;
uniform float projectedParticleConstant;
uniform float depthThreshold;
varying vec2 vUV;
void main(void) {
float depth=texture2D(textureSampler,vUV).x;
if (depth>=1e6 || depth<=0.) {
glFragColor=vec4(vec3(depth),1.);
return;
}
int filterSize=min(maxFilterSize,int(ceil(projectedParticleConstant/depth)));
float sigma=float(filterSize)/3.0;
float two_sigma2=2.0*sigma*sigma;
float sigmaDepth=depthThreshold/3.0;
float two_sigmaDepth2=2.0*sigmaDepth*sigmaDepth;
float sum=0.;
float wsum=0.;
float sumVel=0.;
for (int x=-filterSize; x<=filterSize; ++x) {
vec2 coords=vec2(x);
vec2 sampleDepthVel=textureLod(textureSampler,vUV+coords*blurDir,0.).rg;
float r=dot(coords,coords);
float w=exp(-r/two_sigma2);
float rDepth=sampleDepthVel.r-depth;
float wd=exp(-rDepth*rDepth/two_sigmaDepth2);
sum+=sampleDepthVel.r*w*wd;
sumVel+=sampleDepthVel.g*w*wd;
wsum+=w*wd;
}
glFragColor=vec4(sum/wsum,sumVel/wsum,0.,1.);
}
`;
ShaderStore.ShadersStore[name129] = shader129;

// node_modules/@babylonjs/core/Shaders/fluidRenderingStandardBlur.fragment.js
var name130 = "fluidRenderingStandardBlurPixelShader";
var shader130 = `uniform sampler2D textureSampler;
uniform int filterSize;
uniform vec2 blurDir;
varying vec2 vUV;
void main(void) {
vec4 s=texture2D(textureSampler,vUV);
if (s.r==0.) {
glFragColor=vec4(0.,0.,0.,1.);
return;
}
float sigma=float(filterSize)/3.0;
float twoSigma2=2.0*sigma*sigma;
vec4 sum=vec4(0.);
float wsum=0.;
for (int x=-filterSize; x<=filterSize; ++x) {
vec2 coords=vec2(x);
vec4 sampl=texture2D(textureSampler,vUV+coords*blurDir);
float w=exp(-coords.x*coords.x/twoSigma2);
sum+=sampl*w;
wsum+=w;
}
sum/=wsum;
glFragColor=vec4(sum.rgb,1.);
}
`;
ShaderStore.ShadersStore[name130] = shader130;

// node_modules/@babylonjs/core/Shaders/fluidRenderingRender.fragment.js
var name131 = "fluidRenderingRenderPixelShader";
var shader131 = `#define IOR 1.333
#define ETA 1.0/IOR
#define F0 0.02
uniform sampler2D textureSampler;
uniform sampler2D depthSampler;
#ifdef FLUIDRENDERING_DIFFUSETEXTURE
uniform sampler2D diffuseSampler;
#else
uniform vec3 diffuseColor;
#endif
#ifdef FLUIDRENDERING_FIXED_THICKNESS
uniform float thickness;
uniform sampler2D bgDepthSampler;
#else
uniform float minimumThickness;
uniform sampler2D thicknessSampler;
#endif
#ifdef FLUIDRENDERING_ENVIRONMENT
uniform samplerCube reflectionSampler;
#endif
#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)
uniform sampler2D debugSampler;
#endif
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 invProjectionMatrix;
uniform vec2 texelSize;
uniform vec3 dirLight;
uniform float cameraFar;
uniform float density;
uniform float refractionStrength;
uniform float fresnelClamp;
uniform float specularPower;
varying vec2 vUV;
vec3 computeViewPosFromUVDepth(vec2 texCoord,float depth) {
vec4 ndc;
ndc.xy=texCoord*2.0-1.0;
ndc.z=projectionMatrix[2].z+projectionMatrix[3].z/depth;
ndc.w=1.0;
vec4 eyePos=invProjectionMatrix*ndc;
eyePos.xyz/=eyePos.w;
return eyePos.xyz;
}
vec3 getViewPosFromTexCoord(vec2 texCoord) {
float depth=texture2D(depthSampler,texCoord).x;
return computeViewPosFromUVDepth(texCoord,depth);
}
void main(void) {
vec2 texCoord=vUV;
#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)
vec4 color=texture2D(debugSampler,texCoord);
#ifdef FLUIDRENDERING_DEBUG_DEPTH
glFragColor=vec4(color.rgb/vec3(2.0),1.);
if (color.r>0.999 && color.g>0.999) {
glFragColor=texture2D(textureSampler,texCoord);
}
#else
glFragColor=vec4(color.rgb,1.);
if (color.r<0.001 && color.g<0.001 && color.b<0.001) {
glFragColor=texture2D(textureSampler,texCoord);
}
#endif
return;
#endif
vec2 depthVel=texture2D(depthSampler,texCoord).rg;
float depth=depthVel.r;
#ifndef FLUIDRENDERING_FIXED_THICKNESS
float thickness=texture2D(thicknessSampler,texCoord).x;
#else
float bgDepth=texture2D(bgDepthSampler,texCoord).x;
float depthNonLinear=projectionMatrix[2].z+projectionMatrix[3].z/depth;
depthNonLinear=depthNonLinear*0.5+0.5;
#endif
vec3 backColor=texture2D(textureSampler,texCoord).rgb;
#ifndef FLUIDRENDERING_FIXED_THICKNESS
if (depth>=cameraFar || depth<=0. || thickness<=minimumThickness) {
#else
if (depth>=cameraFar || depth<=0. || bgDepth<=depthNonLinear) {
#endif
glFragColor=vec4(backColor,1.);
return;
}
vec3 viewPos=computeViewPosFromUVDepth(texCoord,depth);
vec3 ddx=getViewPosFromTexCoord(texCoord+vec2(texelSize.x,0.))-viewPos;
vec3 ddy=getViewPosFromTexCoord(texCoord+vec2(0.,texelSize.y))-viewPos;
vec3 ddx2=viewPos-getViewPosFromTexCoord(texCoord+vec2(-texelSize.x,0.));
if (abs(ddx.z)>abs(ddx2.z)) {
ddx=ddx2;
}
vec3 ddy2=viewPos-getViewPosFromTexCoord(texCoord+vec2(0.,-texelSize.y));
if (abs(ddy.z)>abs(ddy2.z)) {
ddy=ddy2;
}
vec3 normal=normalize(cross(ddy,ddx));
#ifndef WEBGPU
if(isnan(normal.x) || isnan(normal.y) || isnan(normal.z) || isinf(normal.x) || isinf(normal.y) || isinf(normal.z)) {
normal=vec3(0.,0.,-1.);
}
#endif
#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_SHOWNORMAL)
glFragColor=vec4(normal*0.5+0.5,1.0);
return;
#endif
vec3 rayDir=normalize(viewPos); 
#ifdef FLUIDRENDERING_DIFFUSETEXTURE
vec3 diffuseColor=texture2D(diffuseSampler,texCoord).rgb;
#endif
vec3 lightDir=normalize(vec3(viewMatrix*vec4(-dirLight,0.)));
vec3 H =normalize(lightDir-rayDir);
float specular=pow(max(0.0,dot(H,normal)),specularPower);
#ifdef FLUIDRENDERING_DEBUG_DIFFUSERENDERING
float diffuse =max(0.0,dot(lightDir,normal))*1.0;
glFragColor=vec4(vec3(0.1) /*ambient*/+vec3(0.42,0.50,1.00)*diffuse+vec3(0,0,0.2)+specular,1.);
return;
#endif
vec3 refractionDir=refract(rayDir,normal,ETA);
vec3 transmitted=(texture2D(textureSampler,vec2(texCoord+refractionDir.xy*thickness*refractionStrength)).rgb);
vec3 transmittance=exp(-density*thickness*(1.0-diffuseColor)); 
vec3 refractionColor=transmitted*transmittance;
#ifdef FLUIDRENDERING_ENVIRONMENT
vec3 reflectionDir=reflect(rayDir,normal);
vec3 reflectionColor=(textureCube(reflectionSampler,reflectionDir).rgb);
float fresnel=clamp(F0+(1.0-F0)*pow(1.0-dot(normal,-rayDir),5.0),0.,fresnelClamp);
vec3 finalColor=mix(refractionColor,reflectionColor,fresnel)+specular;
#else
vec3 finalColor=refractionColor+specular;
#endif
#ifdef FLUIDRENDERING_VELOCITY
float velocity=depthVel.g;
finalColor=mix(finalColor,vec3(1.0),smoothstep(0.3,1.0,velocity/6.0));
#endif
glFragColor=vec4(finalColor,1.);
}
`;
ShaderStore.ShadersStore[name131] = shader131;

// node_modules/@babylonjs/core/Rendering/fluidRenderer/fluidRenderer.js
Object.defineProperty(Scene.prototype, "fluidRenderer", {
  get: function() {
    return this._fluidRenderer;
  },
  set: function(value) {
    this._fluidRenderer = value;
  },
  enumerable: true,
  configurable: true
});
Scene.prototype.enableFluidRenderer = function() {
  if (this._fluidRenderer) {
    return this._fluidRenderer;
  }
  this._fluidRenderer = new FluidRenderer(this);
  return this._fluidRenderer;
};
Scene.prototype.disableFluidRenderer = function() {
  var _a;
  (_a = this._fluidRenderer) === null || _a === void 0 ? void 0 : _a.dispose();
  this._fluidRenderer = null;
};
function IsParticleSystemObject(obj) {
  return !!obj.particleSystem;
}
var FluidRendererSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_FLUIDRENDERER;
    this.scene = scene;
  }
  register() {
    this.scene._gatherActiveCameraRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER, this, this._gatherActiveCameraRenderTargets);
    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_FLUIDRENDERER, this, this._afterCameraDraw);
  }
  _gatherActiveCameraRenderTargets(_renderTargets) {
    var _a;
    (_a = this.scene.fluidRenderer) === null || _a === void 0 ? void 0 : _a._prepareRendering();
  }
  _afterCameraDraw(camera) {
    var _a;
    (_a = this.scene.fluidRenderer) === null || _a === void 0 ? void 0 : _a._render(camera);
  }
  rebuild() {
    if (this.scene._fluidRenderer) {
      this.scene.disableFluidRenderer();
      this.scene.enableFluidRenderer();
    }
  }
  dispose() {
    this.scene.disableFluidRenderer();
  }
};
var FluidRenderer = class {
  constructor(scene) {
    this._scene = scene;
    this._engine = scene.getEngine();
    this._onEngineResizeObserver = null;
    this.renderObjects = [];
    this.targetRenderers = [];
    this._cameras = /* @__PURE__ */ new Map();
    FluidRenderer._SceneComponentInitialization(this._scene);
    this._onEngineResizeObserver = this._engine.onResizeObservable.add(() => {
      this._initialize();
    });
  }
  static _SceneComponentInitialization(scene) {
    let component = scene._getComponent(SceneComponentConstants.NAME_FLUIDRENDERER);
    if (!component) {
      component = new FluidRendererSceneComponent(scene);
      scene._addComponent(component);
    }
  }
  recreate() {
    this._sortRenderingObjects();
    this._initialize();
  }
  getRenderObjectFromParticleSystem(ps) {
    const index = this._getParticleSystemIndex(ps);
    return index !== -1 ? this.renderObjects[index] : null;
  }
  addParticleSystem(ps, generateDiffuseTexture, targetRenderer, camera) {
    const object = new FluidRenderingObjectParticleSystem(this._scene, ps);
    object.onParticleSizeChanged.add(this._setParticleSizeForRenderTargets.bind(this));
    if (!targetRenderer) {
      targetRenderer = new FluidRenderingTargetRenderer(this._scene, camera);
      this.targetRenderers.push(targetRenderer);
    }
    if (!targetRenderer._onUseVelocityChanged.hasObservers()) {
      targetRenderer._onUseVelocityChanged.add(this._setUseVelocityForRenderObject.bind(this));
    }
    if (generateDiffuseTexture !== void 0) {
      targetRenderer.generateDiffuseTexture = generateDiffuseTexture;
    }
    const renderObject = { object, targetRenderer };
    this.renderObjects.push(renderObject);
    this._sortRenderingObjects();
    this._setParticleSizeForRenderTargets();
    return renderObject;
  }
  addCustomParticles(buffers, numParticles, generateDiffuseTexture, targetRenderer, camera) {
    const object = new FluidRenderingObjectCustomParticles(this._scene, buffers, numParticles);
    object.onParticleSizeChanged.add(this._setParticleSizeForRenderTargets.bind(this));
    if (!targetRenderer) {
      targetRenderer = new FluidRenderingTargetRenderer(this._scene, camera);
      this.targetRenderers.push(targetRenderer);
    }
    if (!targetRenderer._onUseVelocityChanged.hasObservers()) {
      targetRenderer._onUseVelocityChanged.add(this._setUseVelocityForRenderObject.bind(this));
    }
    if (generateDiffuseTexture !== void 0) {
      targetRenderer.generateDiffuseTexture = generateDiffuseTexture;
    }
    const renderObject = { object, targetRenderer };
    this.renderObjects.push(renderObject);
    this._sortRenderingObjects();
    this._setParticleSizeForRenderTargets();
    return renderObject;
  }
  removeRenderObject(renderObject, removeUnusedTargetRenderer = true) {
    const index = this.renderObjects.indexOf(renderObject);
    if (index === -1) {
      return false;
    }
    renderObject.object.dispose();
    this.renderObjects.splice(index, 1);
    if (removeUnusedTargetRenderer && this._removeUnusedTargetRenderers()) {
      this._initialize();
    } else {
      this._setParticleSizeForRenderTargets();
    }
    return true;
  }
  _sortRenderingObjects() {
    this.renderObjects.sort((a, b) => {
      return a.object.priority < b.object.priority ? -1 : a.object.priority > b.object.priority ? 1 : 0;
    });
  }
  _removeUnusedTargetRenderers() {
    const indexes = {};
    for (let i = 0; i < this.renderObjects.length; ++i) {
      const targetRenderer = this.renderObjects[i].targetRenderer;
      indexes[this.targetRenderers.indexOf(targetRenderer)] = true;
    }
    let removed = false;
    const newList = [];
    for (let i = 0; i < this.targetRenderers.length; ++i) {
      if (!indexes[i]) {
        this.targetRenderers[i].dispose();
        removed = true;
      } else {
        newList.push(this.targetRenderers[i]);
      }
    }
    if (removed) {
      this.targetRenderers.length = 0;
      this.targetRenderers.push(...newList);
    }
    return removed;
  }
  _getParticleSystemIndex(ps) {
    for (let i = 0; i < this.renderObjects.length; ++i) {
      const obj = this.renderObjects[i].object;
      if (IsParticleSystemObject(obj) && obj.particleSystem === ps) {
        return i;
      }
    }
    return -1;
  }
  _initialize() {
    for (let i = 0; i < this.targetRenderers.length; ++i) {
      this.targetRenderers[i].dispose();
    }
    const cameras = /* @__PURE__ */ new Map();
    for (let i = 0; i < this.targetRenderers.length; ++i) {
      const targetRenderer = this.targetRenderers[i];
      targetRenderer._initialize();
      if (targetRenderer.camera && targetRenderer._renderPostProcess) {
        let list = cameras.get(targetRenderer.camera);
        if (!list) {
          list = [[], {}];
          cameras.set(targetRenderer.camera, list);
        }
        list[0].push(targetRenderer);
        targetRenderer.camera.attachPostProcess(targetRenderer._renderPostProcess, i);
      }
    }
    let iterator = cameras.keys();
    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
      const camera = key.value;
      const list = cameras.get(camera);
      const firstPostProcess = camera._getFirstPostProcess();
      if (!firstPostProcess) {
        continue;
      }
      const [targetRenderers, copyDepthTextures] = list;
      firstPostProcess.onSizeChangedObservable.add(() => {
        var _a;
        if (!firstPostProcess.inputTexture.depthStencilTexture) {
          firstPostProcess.inputTexture.createDepthStencilTexture(0, true, this._engine.isStencilEnable, targetRenderers[0].samples);
        }
        for (const targetRenderer of targetRenderers) {
          const thicknessRT = (_a = targetRenderer._thicknessRenderTarget) === null || _a === void 0 ? void 0 : _a.renderTarget;
          const thicknessTexture = thicknessRT === null || thicknessRT === void 0 ? void 0 : thicknessRT.texture;
          if (thicknessRT && thicknessTexture) {
            const key2 = thicknessTexture.width + "_" + thicknessTexture.height;
            let copyDepthTexture = copyDepthTextures[key2];
            if (!copyDepthTexture) {
              copyDepthTexture = copyDepthTextures[key2] = new FluidRenderingDepthTextureCopy(this._engine, thicknessTexture.width, thicknessTexture.height);
            }
            copyDepthTexture.depthRTWrapper._shareDepth(thicknessRT);
          }
        }
      });
    }
    iterator = this._cameras.keys();
    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
      const camera = key.value;
      const list = this._cameras.get(camera);
      const copyDepthTextures = list[1];
      const list2 = cameras.get(camera);
      if (!list2) {
        for (const key2 in copyDepthTextures) {
          copyDepthTextures[key2].dispose();
        }
      } else {
        for (const key2 in copyDepthTextures) {
          if (!list2[1][key2]) {
            copyDepthTextures[key2].dispose();
          }
        }
      }
    }
    this._cameras.clear();
    this._cameras = cameras;
    this._setParticleSizeForRenderTargets();
  }
  _setParticleSizeForRenderTargets() {
    const particleSizes = /* @__PURE__ */ new Map();
    for (let i = 0; i < this.renderObjects.length; ++i) {
      const renderingObject = this.renderObjects[i];
      let curSize = particleSizes.get(renderingObject.targetRenderer);
      if (curSize === void 0) {
        curSize = 0;
      }
      particleSizes.set(renderingObject.targetRenderer, Math.max(curSize, renderingObject.object.particleSize));
    }
    particleSizes.forEach((particleSize, targetRenderer) => {
      if (targetRenderer._depthRenderTarget) {
        targetRenderer._depthRenderTarget.particleSize = particleSize;
      }
    });
  }
  _setUseVelocityForRenderObject() {
    for (const renderingObject of this.renderObjects) {
      renderingObject.object.useVelocity = renderingObject.targetRenderer.useVelocity;
    }
  }
  _prepareRendering() {
    for (const renderer of this.targetRenderers) {
      if (renderer.needInitialization) {
        this._initialize();
        return;
      }
    }
  }
  _render(forCamera) {
    var _a;
    for (let i = 0; i < this.targetRenderers.length; ++i) {
      if (!forCamera || this.targetRenderers[i].camera === forCamera) {
        this.targetRenderers[i]._clearTargets();
      }
    }
    const iterator = this._cameras.keys();
    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
      const camera = key.value;
      const list = this._cameras.get(camera);
      if (forCamera && camera !== forCamera) {
        continue;
      }
      const firstPostProcess = camera._getFirstPostProcess();
      if (!firstPostProcess) {
        continue;
      }
      const sourceCopyDepth = (_a = firstPostProcess.inputTexture) === null || _a === void 0 ? void 0 : _a.depthStencilTexture;
      if (sourceCopyDepth) {
        const [targetRenderers, copyDepthTextures] = list;
        for (const targetRenderer of targetRenderers) {
          targetRenderer._bgDepthTexture = sourceCopyDepth;
        }
        for (const key2 in copyDepthTextures) {
          copyDepthTextures[key2].copy(sourceCopyDepth);
        }
      }
    }
    for (let i = 0; i < this.renderObjects.length; ++i) {
      const renderingObject = this.renderObjects[i];
      if (!forCamera || renderingObject.targetRenderer.camera === forCamera) {
        renderingObject.targetRenderer._render(renderingObject.object);
      }
    }
  }
  dispose() {
    this._engine.onResizeObservable.remove(this._onEngineResizeObserver);
    this._onEngineResizeObserver = null;
    for (let i = 0; i < this.renderObjects.length; ++i) {
      this.renderObjects[i].object.dispose();
    }
    for (let i = 0; i < this.targetRenderers.length; ++i) {
      this.targetRenderers[i].dispose();
    }
    this._cameras.forEach((list) => {
      const copyDepthTextures = list[1];
      for (const key in copyDepthTextures) {
        copyDepthTextures[key].dispose();
      }
    });
    this.renderObjects = [];
    this.targetRenderers = [];
    this._cameras.clear();
  }
};

// node_modules/@babylonjs/core/Sprites/thinSprite.js
var ThinSprite = class {
  constructor() {
    this.width = 1;
    this.height = 1;
    this.angle = 0;
    this.invertU = false;
    this.invertV = false;
    this.isVisible = true;
    this._animationStarted = false;
    this._loopAnimation = false;
    this._fromIndex = 0;
    this._toIndex = 0;
    this._delay = 0;
    this._direction = 1;
    this._time = 0;
    this._onBaseAnimationEnd = null;
    this.position = { x: 1, y: 1, z: 1 };
    this.color = { r: 1, g: 1, b: 1, a: 1 };
  }
  get animationStarted() {
    return this._animationStarted;
  }
  get fromIndex() {
    return this._fromIndex;
  }
  get toIndex() {
    return this._toIndex;
  }
  get loopAnimation() {
    return this._loopAnimation;
  }
  get delay() {
    return Math.max(this._delay, 1);
  }
  playAnimation(from, to, loop, delay, onAnimationEnd) {
    this._fromIndex = from;
    this._toIndex = to;
    this._loopAnimation = loop;
    this._delay = delay || 1;
    this._animationStarted = true;
    this._onBaseAnimationEnd = onAnimationEnd;
    if (from < to) {
      this._direction = 1;
    } else {
      this._direction = -1;
      this._toIndex = from;
      this._fromIndex = to;
    }
    this.cellIndex = from;
    this._time = 0;
  }
  stopAnimation() {
    this._animationStarted = false;
  }
  _animate(deltaTime) {
    if (!this._animationStarted) {
      return;
    }
    this._time += deltaTime;
    if (this._time > this._delay) {
      this._time = this._time % this._delay;
      this.cellIndex += this._direction;
      if (this._direction > 0 && this.cellIndex > this._toIndex || this._direction < 0 && this.cellIndex < this._fromIndex) {
        if (this._loopAnimation) {
          this.cellIndex = this._direction > 0 ? this._fromIndex : this._toIndex;
        } else {
          this.cellIndex = this._toIndex;
          this._animationStarted = false;
          if (this._onBaseAnimationEnd) {
            this._onBaseAnimationEnd();
          }
        }
      }
    }
  }
};

// node_modules/@babylonjs/core/Sprites/sprite.js
var Sprite = class extends ThinSprite {
  constructor(name137, manager) {
    super();
    this.name = name137;
    this.animations = new Array();
    this.isPickable = false;
    this.useAlphaForPicking = false;
    this.onDisposeObservable = new Observable();
    this._onAnimationEnd = null;
    this._endAnimation = () => {
      if (this._onAnimationEnd) {
        this._onAnimationEnd();
      }
      if (this.disposeWhenFinishedAnimating) {
        this.dispose();
      }
    };
    this.color = new Color4(1, 1, 1, 1);
    this.position = Vector3.Zero();
    this._manager = manager;
    this._manager.sprites.push(this);
    this.uniqueId = this._manager.scene.getUniqueId();
  }
  get size() {
    return this.width;
  }
  set size(value) {
    this.width = value;
    this.height = value;
  }
  get manager() {
    return this._manager;
  }
  getClassName() {
    return "Sprite";
  }
  get fromIndex() {
    return this._fromIndex;
  }
  set fromIndex(value) {
    this.playAnimation(value, this._toIndex, this._loopAnimation, this._delay, this._onAnimationEnd);
  }
  get toIndex() {
    return this._toIndex;
  }
  set toIndex(value) {
    this.playAnimation(this._fromIndex, value, this._loopAnimation, this._delay, this._onAnimationEnd);
  }
  get loopAnimation() {
    return this._loopAnimation;
  }
  set loopAnimation(value) {
    this.playAnimation(this._fromIndex, this._toIndex, value, this._delay, this._onAnimationEnd);
  }
  get delay() {
    return Math.max(this._delay, 1);
  }
  set delay(value) {
    this.playAnimation(this._fromIndex, this._toIndex, this._loopAnimation, value, this._onAnimationEnd);
  }
  playAnimation(from, to, loop, delay, onAnimationEnd = null) {
    this._onAnimationEnd = onAnimationEnd;
    super.playAnimation(from, to, loop, delay, this._endAnimation);
  }
  dispose() {
    for (let i = 0; i < this._manager.sprites.length; i++) {
      if (this._manager.sprites[i] == this) {
        this._manager.sprites.splice(i, 1);
      }
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
  }
  serialize() {
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.position = this.position.asArray();
    serializationObject.color = this.color.asArray();
    serializationObject.width = this.width;
    serializationObject.height = this.height;
    serializationObject.angle = this.angle;
    serializationObject.cellIndex = this.cellIndex;
    serializationObject.cellRef = this.cellRef;
    serializationObject.invertU = this.invertU;
    serializationObject.invertV = this.invertV;
    serializationObject.disposeWhenFinishedAnimating = this.disposeWhenFinishedAnimating;
    serializationObject.isPickable = this.isPickable;
    serializationObject.isVisible = this.isVisible;
    serializationObject.useAlphaForPicking = this.useAlphaForPicking;
    serializationObject.animationStarted = this.animationStarted;
    serializationObject.fromIndex = this.fromIndex;
    serializationObject.toIndex = this.toIndex;
    serializationObject.loopAnimation = this.loopAnimation;
    serializationObject.delay = this.delay;
    return serializationObject;
  }
  static Parse(parsedSprite, manager) {
    const sprite = new Sprite(parsedSprite.name, manager);
    sprite.position = Vector3.FromArray(parsedSprite.position);
    sprite.color = Color4.FromArray(parsedSprite.color);
    sprite.width = parsedSprite.width;
    sprite.height = parsedSprite.height;
    sprite.angle = parsedSprite.angle;
    sprite.cellIndex = parsedSprite.cellIndex;
    sprite.cellRef = parsedSprite.cellRef;
    sprite.invertU = parsedSprite.invertU;
    sprite.invertV = parsedSprite.invertV;
    sprite.disposeWhenFinishedAnimating = parsedSprite.disposeWhenFinishedAnimating;
    sprite.isPickable = parsedSprite.isPickable;
    sprite.isVisible = parsedSprite.isVisible;
    sprite.useAlphaForPicking = parsedSprite.useAlphaForPicking;
    sprite.fromIndex = parsedSprite.fromIndex;
    sprite.toIndex = parsedSprite.toIndex;
    sprite.loopAnimation = parsedSprite.loopAnimation;
    sprite.delay = parsedSprite.delay;
    if (parsedSprite.animationStarted) {
      sprite.playAnimation(sprite.fromIndex, sprite.toIndex, sprite.loopAnimation, sprite.delay);
    }
    return sprite;
  }
};

// node_modules/@babylonjs/core/Sprites/spriteSceneComponent.js
Scene.prototype._internalPickSprites = function(ray, predicate, fastCheck, camera) {
  if (!PickingInfo) {
    return null;
  }
  let pickingInfo = null;
  if (!camera) {
    if (!this.activeCamera) {
      return null;
    }
    camera = this.activeCamera;
  }
  if (this.spriteManagers.length > 0) {
    for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {
      const spriteManager = this.spriteManagers[spriteIndex];
      if (!spriteManager.isPickable) {
        continue;
      }
      const result = spriteManager.intersects(ray, camera, predicate, fastCheck);
      if (!result || !result.hit) {
        continue;
      }
      if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {
        continue;
      }
      pickingInfo = result;
      if (fastCheck) {
        break;
      }
    }
  }
  return pickingInfo || new PickingInfo();
};
Scene.prototype._internalMultiPickSprites = function(ray, predicate, camera) {
  if (!PickingInfo) {
    return null;
  }
  let pickingInfos = new Array();
  if (!camera) {
    if (!this.activeCamera) {
      return null;
    }
    camera = this.activeCamera;
  }
  if (this.spriteManagers.length > 0) {
    for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {
      const spriteManager = this.spriteManagers[spriteIndex];
      if (!spriteManager.isPickable) {
        continue;
      }
      const results = spriteManager.multiIntersects(ray, camera, predicate);
      if (results !== null) {
        pickingInfos = pickingInfos.concat(results);
      }
    }
  }
  return pickingInfos;
};
Scene.prototype.pickSprite = function(x, y, predicate, fastCheck, camera) {
  if (!this._tempSpritePickingRay) {
    return null;
  }
  this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);
  const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);
  if (result) {
    result.ray = this.createPickingRayInCameraSpace(x, y, camera);
  }
  return result;
};
Scene.prototype.pickSpriteWithRay = function(ray, predicate, fastCheck, camera) {
  if (!this._tempSpritePickingRay) {
    return null;
  }
  if (!camera) {
    if (!this.activeCamera) {
      return null;
    }
    camera = this.activeCamera;
  }
  Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);
  const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);
  if (result) {
    result.ray = ray;
  }
  return result;
};
Scene.prototype.multiPickSprite = function(x, y, predicate, camera) {
  this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);
  return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);
};
Scene.prototype.multiPickSpriteWithRay = function(ray, predicate, camera) {
  if (!this._tempSpritePickingRay) {
    return null;
  }
  if (!camera) {
    if (!this.activeCamera) {
      return null;
    }
    camera = this.activeCamera;
  }
  Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);
  return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);
};
Scene.prototype.setPointerOverSprite = function(sprite) {
  if (this._pointerOverSprite === sprite) {
    return;
  }
  if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {
    this._pointerOverSprite.actionManager.processTrigger(10, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));
  }
  this._pointerOverSprite = sprite;
  if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {
    this._pointerOverSprite.actionManager.processTrigger(9, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));
  }
};
Scene.prototype.getPointerOverSprite = function() {
  return this._pointerOverSprite;
};
var SpriteSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_SPRITE;
    this.scene = scene;
    this.scene.spriteManagers = new Array();
    this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;
    this.scene.onBeforeSpritesRenderingObservable = new Observable();
    this.scene.onAfterSpritesRenderingObservable = new Observable();
    this._spritePredicate = (sprite) => {
      if (!sprite.actionManager) {
        return false;
      }
      return sprite.isPickable && sprite.actionManager.hasPointerTriggers;
    };
  }
  register() {
    this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);
    this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);
    this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);
  }
  rebuild() {
  }
  dispose() {
    this.scene.onBeforeSpritesRenderingObservable.clear();
    this.scene.onAfterSpritesRenderingObservable.clear();
    const spriteManagers = this.scene.spriteManagers;
    while (spriteManagers.length) {
      spriteManagers[0].dispose();
    }
  }
  _pickSpriteButKeepRay(originalPointerInfo, x, y, fastCheck, camera) {
    const result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);
    if (result) {
      result.ray = originalPointerInfo ? originalPointerInfo.ray : null;
    }
    return result;
  }
  _pointerMove(unTranslatedPointerX, unTranslatedPointerY, pickResult, isMeshPicked, element) {
    const scene = this.scene;
    if (isMeshPicked) {
      scene.setPointerOverSprite(null);
    } else {
      pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || void 0);
      if (pickResult && pickResult.hit && pickResult.pickedSprite) {
        scene.setPointerOverSprite(pickResult.pickedSprite);
        if (!scene.doNotHandleCursors && element) {
          if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {
            element.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;
          } else {
            element.style.cursor = scene.hoverCursor;
          }
        }
      } else {
        scene.setPointerOverSprite(null);
      }
    }
    return pickResult;
  }
  _pointerDown(unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {
    const scene = this.scene;
    scene._pickedDownSprite = null;
    if (scene.spriteManagers.length > 0) {
      pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || void 0);
      if (pickResult && pickResult.hit && pickResult.pickedSprite) {
        if (pickResult.pickedSprite.actionManager) {
          scene._pickedDownSprite = pickResult.pickedSprite;
          switch (evt.button) {
            case 0:
              pickResult.pickedSprite.actionManager.processTrigger(2, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
              break;
            case 1:
              pickResult.pickedSprite.actionManager.processTrigger(4, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
              break;
            case 2:
              pickResult.pickedSprite.actionManager.processTrigger(3, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
              break;
          }
          if (pickResult.pickedSprite.actionManager) {
            pickResult.pickedSprite.actionManager.processTrigger(5, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
          }
        }
      }
    }
    return pickResult;
  }
  _pointerUp(unTranslatedPointerX, unTranslatedPointerY, pickResult, evt, doubleClick) {
    const scene = this.scene;
    if (scene.spriteManagers.length > 0) {
      const spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || void 0);
      if (spritePickResult) {
        if (spritePickResult.hit && spritePickResult.pickedSprite) {
          if (spritePickResult.pickedSprite.actionManager) {
            spritePickResult.pickedSprite.actionManager.processTrigger(7, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));
            if (spritePickResult.pickedSprite.actionManager) {
              if (!this.scene._inputManager._isPointerSwiping()) {
                spritePickResult.pickedSprite.actionManager.processTrigger(1, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));
              }
              if (doubleClick) {
                spritePickResult.pickedSprite.actionManager.processTrigger(6, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));
              }
            }
          }
        }
        if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {
          scene._pickedDownSprite.actionManager.processTrigger(16, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));
        }
      }
    }
    return pickResult;
  }
};

// node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingCompatibility.js
var name132 = "imageProcessingCompatibility";
var shader132 = `#ifdef IMAGEPROCESSINGPOSTPROCESS
gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(2.2));
#endif
`;
ShaderStore.IncludesShadersStore[name132] = shader132;

// node_modules/@babylonjs/core/Shaders/sprites.fragment.js
var name133 = "spritesPixelShader";
var shader133 = `uniform bool alphaTest;
varying vec4 vColor;
varying vec2 vUV;
uniform sampler2D diffuseSampler;
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec4 color=texture2D(diffuseSampler,vUV);
if (float(alphaTest) != 0.)
{
if (color.a<0.95)
discard;
}
color*=vColor;
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name133] = shader133;

// node_modules/@babylonjs/core/Shaders/sprites.vertex.js
var name134 = "spritesVertexShader";
var shader134 = `attribute vec4 position;
attribute vec2 options;
attribute vec2 offsets;
attribute vec2 inverts;
attribute vec4 cellInfo;
attribute vec4 color;
uniform mat4 view;
uniform mat4 projection;
varying vec2 vUV;
varying vec4 vColor;
#include<fogVertexDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 viewPos=(view*vec4(position.xyz,1.0)).xyz; 
vec2 cornerPos;
float angle=position.w;
vec2 size=vec2(options.x,options.y);
vec2 offset=offsets.xy;
cornerPos=vec2(offset.x-0.5,offset.y -0.5)*size;
vec3 rotatedCorner;
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);
rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);
rotatedCorner.z=0.;
viewPos+=rotatedCorner;
gl_Position=projection*vec4(viewPos,1.0); 
vColor=color;
vec2 uvOffset=vec2(abs(offset.x-inverts.x),abs(1.0-offset.y-inverts.y));
vec2 uvPlace=cellInfo.xy;
vec2 uvSize=cellInfo.zw;
vUV.x=uvPlace.x+uvSize.x*uvOffset.x;
vUV.y=uvPlace.y+uvSize.y*uvOffset.y;
#ifdef FOG
vFogDistance=viewPos;
#endif
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name134] = shader134;

// node_modules/@babylonjs/core/Sprites/spriteRenderer.js
var SpriteRenderer = class {
  constructor(engine, capacity, epsilon = 0.01, scene = null) {
    this.blendMode = 2;
    this.autoResetAlpha = true;
    this.disableDepthWrite = false;
    this.fogEnabled = true;
    this._useVAO = false;
    this._useInstancing = false;
    this._vertexBuffers = {};
    this._capacity = capacity;
    this._epsilon = epsilon;
    this._engine = engine;
    this._useInstancing = engine.getCaps().instancedArrays && engine._features.supportSpriteInstancing;
    this._useVAO = engine.getCaps().vertexArrayObject && !engine.disableVertexArrayObjects;
    this._scene = scene;
    this._drawWrapperBase = new DrawWrapper(engine);
    this._drawWrapperFog = new DrawWrapper(engine);
    this._drawWrapperDepth = new DrawWrapper(engine, false);
    this._drawWrapperFogDepth = new DrawWrapper(engine, false);
    if (!this._useInstancing) {
      this._buildIndexBuffer();
    }
    if (this._drawWrapperBase.drawContext) {
      this._drawWrapperBase.drawContext.useInstancing = this._useInstancing;
    }
    if (this._drawWrapperFog.drawContext) {
      this._drawWrapperFog.drawContext.useInstancing = this._useInstancing;
    }
    if (this._drawWrapperDepth.drawContext) {
      this._drawWrapperDepth.drawContext.useInstancing = this._useInstancing;
    }
    if (this._drawWrapperFogDepth.drawContext) {
      this._drawWrapperFogDepth.drawContext.useInstancing = this._useInstancing;
    }
    this._vertexBufferSize = this._useInstancing ? 16 : 18;
    this._vertexData = new Float32Array(capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));
    this._buffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);
    const positions = this._buffer.createVertexBuffer(VertexBuffer.PositionKind, 0, 4, this._vertexBufferSize, this._useInstancing);
    const options = this._buffer.createVertexBuffer("options", 4, 2, this._vertexBufferSize, this._useInstancing);
    let offset = 6;
    let offsets;
    if (this._useInstancing) {
      const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);
      offsets = this._spriteBuffer.createVertexBuffer("offsets", 0, 2);
    } else {
      offsets = this._buffer.createVertexBuffer("offsets", offset, 2, this._vertexBufferSize, this._useInstancing);
      offset += 2;
    }
    const inverts = this._buffer.createVertexBuffer("inverts", offset, 2, this._vertexBufferSize, this._useInstancing);
    const cellInfo = this._buffer.createVertexBuffer("cellInfo", offset + 2, 4, this._vertexBufferSize, this._useInstancing);
    const colors = this._buffer.createVertexBuffer(VertexBuffer.ColorKind, offset + 6, 4, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers[VertexBuffer.PositionKind] = positions;
    this._vertexBuffers["options"] = options;
    this._vertexBuffers["offsets"] = offsets;
    this._vertexBuffers["inverts"] = inverts;
    this._vertexBuffers["cellInfo"] = cellInfo;
    this._vertexBuffers[VertexBuffer.ColorKind] = colors;
    this._drawWrapperBase.effect = this._engine.createEffect("sprites", [VertexBuffer.PositionKind, "options", "offsets", "inverts", "cellInfo", VertexBuffer.ColorKind], ["view", "projection", "textureInfos", "alphaTest"], ["diffuseSampler"], "");
    this._drawWrapperDepth.effect = this._drawWrapperBase.effect;
    this._drawWrapperDepth.materialContext = this._drawWrapperBase.materialContext;
    if (this._scene) {
      this._drawWrapperFog.effect = this._scene.getEngine().createEffect("sprites", [VertexBuffer.PositionKind, "options", "offsets", "inverts", "cellInfo", VertexBuffer.ColorKind], ["view", "projection", "textureInfos", "alphaTest", "vFogInfos", "vFogColor"], ["diffuseSampler"], "#define FOG");
      this._drawWrapperFogDepth.effect = this._drawWrapperFog.effect;
      this._drawWrapperFogDepth.materialContext = this._drawWrapperFog.materialContext;
    }
  }
  get capacity() {
    return this._capacity;
  }
  render(sprites, deltaTime, viewMatrix, projectionMatrix, customSpriteUpdate = null) {
    if (!this.texture || !this.texture.isReady() || !sprites.length) {
      return;
    }
    let drawWrapper = this._drawWrapperBase;
    let drawWrapperDepth = this._drawWrapperDepth;
    let shouldRenderFog = false;
    if (this.fogEnabled && this._scene && this._scene.fogEnabled && this._scene.fogMode !== 0) {
      drawWrapper = this._drawWrapperFog;
      drawWrapperDepth = this._drawWrapperFogDepth;
      shouldRenderFog = true;
    }
    const effect = drawWrapper.effect;
    if (!effect.isReady()) {
      return;
    }
    const engine = this._engine;
    const useRightHandedSystem = !!(this._scene && this._scene.useRightHandedSystem);
    const baseSize = this.texture.getBaseSize();
    const max = Math.min(this._capacity, sprites.length);
    let offset = 0;
    let noSprite = true;
    for (let index = 0; index < max; index++) {
      const sprite = sprites[index];
      if (!sprite || !sprite.isVisible) {
        continue;
      }
      noSprite = false;
      sprite._animate(deltaTime);
      this._appendSpriteVertex(offset++, sprite, 0, 0, baseSize, useRightHandedSystem, customSpriteUpdate);
      if (!this._useInstancing) {
        this._appendSpriteVertex(offset++, sprite, 1, 0, baseSize, useRightHandedSystem, customSpriteUpdate);
        this._appendSpriteVertex(offset++, sprite, 1, 1, baseSize, useRightHandedSystem, customSpriteUpdate);
        this._appendSpriteVertex(offset++, sprite, 0, 1, baseSize, useRightHandedSystem, customSpriteUpdate);
      }
    }
    if (noSprite) {
      return;
    }
    this._buffer.update(this._vertexData);
    const culling = !!engine.depthCullingState.cull;
    const zOffset = engine.depthCullingState.zOffset;
    const zOffsetUnits = engine.depthCullingState.zOffsetUnits;
    engine.setState(culling, zOffset, false, false, void 0, void 0, zOffsetUnits);
    engine.enableEffect(drawWrapper);
    effect.setTexture("diffuseSampler", this.texture);
    effect.setMatrix("view", viewMatrix);
    effect.setMatrix("projection", projectionMatrix);
    if (shouldRenderFog) {
      const scene = this._scene;
      effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
      effect.setColor3("vFogColor", scene.fogColor);
    }
    if (this._useVAO) {
      if (!this._vertexArrayObject) {
        this._vertexArrayObject = engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);
      }
      engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);
    } else {
      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
    }
    engine.depthCullingState.depthFunc = engine.useReverseDepthBuffer ? 518 : 515;
    if (!this.disableDepthWrite) {
      effect.setBool("alphaTest", true);
      engine.setColorWrite(false);
      engine.enableEffect(drawWrapperDepth);
      if (this._useInstancing) {
        engine.drawArraysType(7, 0, 4, offset);
      } else {
        engine.drawElementsType(0, 0, offset / 4 * 6);
      }
      engine.enableEffect(drawWrapper);
      engine.setColorWrite(true);
      effect.setBool("alphaTest", false);
    }
    engine.setAlphaMode(this.blendMode);
    if (this._useInstancing) {
      engine.drawArraysType(7, 0, 4, offset);
    } else {
      engine.drawElementsType(0, 0, offset / 4 * 6);
    }
    if (this.autoResetAlpha) {
      engine.setAlphaMode(0);
    }
    if (useRightHandedSystem) {
      this._scene.getEngine().setState(culling, zOffset, false, true, void 0, void 0, zOffsetUnits);
    }
    engine.unbindInstanceAttributes();
  }
  _appendSpriteVertex(index, sprite, offsetX, offsetY, baseSize, useRightHandedSystem, customSpriteUpdate) {
    let arrayOffset = index * this._vertexBufferSize;
    if (offsetX === 0) {
      offsetX = this._epsilon;
    } else if (offsetX === 1) {
      offsetX = 1 - this._epsilon;
    }
    if (offsetY === 0) {
      offsetY = this._epsilon;
    } else if (offsetY === 1) {
      offsetY = 1 - this._epsilon;
    }
    if (customSpriteUpdate) {
      customSpriteUpdate(sprite, baseSize);
    } else {
      if (!sprite.cellIndex) {
        sprite.cellIndex = 0;
      }
      const rowSize = baseSize.width / this.cellWidth;
      const offset = sprite.cellIndex / rowSize >> 0;
      sprite._xOffset = (sprite.cellIndex - offset * rowSize) * this.cellWidth / baseSize.width;
      sprite._yOffset = offset * this.cellHeight / baseSize.height;
      sprite._xSize = this.cellWidth;
      sprite._ySize = this.cellHeight;
    }
    this._vertexData[arrayOffset] = sprite.position.x;
    this._vertexData[arrayOffset + 1] = sprite.position.y;
    this._vertexData[arrayOffset + 2] = sprite.position.z;
    this._vertexData[arrayOffset + 3] = sprite.angle;
    this._vertexData[arrayOffset + 4] = sprite.width;
    this._vertexData[arrayOffset + 5] = sprite.height;
    if (!this._useInstancing) {
      this._vertexData[arrayOffset + 6] = offsetX;
      this._vertexData[arrayOffset + 7] = offsetY;
    } else {
      arrayOffset -= 2;
    }
    if (useRightHandedSystem) {
      this._vertexData[arrayOffset + 8] = sprite.invertU ? 0 : 1;
    } else {
      this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;
    }
    this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;
    this._vertexData[arrayOffset + 10] = sprite._xOffset;
    this._vertexData[arrayOffset + 11] = sprite._yOffset;
    this._vertexData[arrayOffset + 12] = sprite._xSize / baseSize.width;
    this._vertexData[arrayOffset + 13] = sprite._ySize / baseSize.height;
    this._vertexData[arrayOffset + 14] = sprite.color.r;
    this._vertexData[arrayOffset + 15] = sprite.color.g;
    this._vertexData[arrayOffset + 16] = sprite.color.b;
    this._vertexData[arrayOffset + 17] = sprite.color.a;
  }
  _buildIndexBuffer() {
    const indices = [];
    let index = 0;
    for (let count = 0; count < this._capacity; count++) {
      indices.push(index);
      indices.push(index + 1);
      indices.push(index + 2);
      indices.push(index);
      indices.push(index + 2);
      indices.push(index + 3);
      index += 4;
    }
    this._indexBuffer = this._engine.createIndexBuffer(indices);
  }
  rebuild() {
    var _a;
    if (this._indexBuffer) {
      this._buildIndexBuffer();
    }
    if (this._useVAO) {
      this._vertexArrayObject = void 0;
    }
    this._buffer._rebuild();
    for (const key in this._vertexBuffers) {
      const vertexBuffer = this._vertexBuffers[key];
      vertexBuffer._rebuild();
    }
    (_a = this._spriteBuffer) === null || _a === void 0 ? void 0 : _a._rebuild();
  }
  dispose() {
    if (this._buffer) {
      this._buffer.dispose();
      this._buffer = null;
    }
    if (this._spriteBuffer) {
      this._spriteBuffer.dispose();
      this._spriteBuffer = null;
    }
    if (this._indexBuffer) {
      this._engine._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    if (this._vertexArrayObject) {
      this._engine.releaseVertexArrayObject(this._vertexArrayObject);
      this._vertexArrayObject = null;
    }
    if (this.texture) {
      this.texture.dispose();
      this.texture = null;
    }
    this._drawWrapperBase.dispose();
    this._drawWrapperFog.dispose();
    this._drawWrapperDepth.dispose();
    this._drawWrapperFogDepth.dispose();
  }
};

// node_modules/@babylonjs/core/Sprites/spriteManager.js
var SpriteManager = class {
  constructor(name137, imgUrl, capacity, cellSize, scene, epsilon = 0.01, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, fromPacked = false, spriteJSON = null) {
    this.name = name137;
    this.sprites = new Array();
    this.renderingGroupId = 0;
    this.layerMask = 268435455;
    this.isPickable = false;
    this.metadata = null;
    this._wasDispatched = false;
    this.onDisposeObservable = new Observable();
    this._disableDepthWrite = false;
    this._packedAndReady = false;
    this._customUpdate = (sprite, baseSize) => {
      if (!sprite.cellRef) {
        sprite.cellIndex = 0;
      }
      const num = sprite.cellIndex;
      if (typeof num === "number" && isFinite(num) && Math.floor(num) === num) {
        sprite.cellRef = this._spriteMap[sprite.cellIndex];
      }
      sprite._xOffset = this._cellData[sprite.cellRef].frame.x / baseSize.width;
      sprite._yOffset = this._cellData[sprite.cellRef].frame.y / baseSize.height;
      sprite._xSize = this._cellData[sprite.cellRef].frame.w;
      sprite._ySize = this._cellData[sprite.cellRef].frame.h;
    };
    if (!scene) {
      scene = EngineStore.LastCreatedScene;
    }
    if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {
      scene._addComponent(new SpriteSceneComponent(scene));
    }
    this._fromPacked = fromPacked;
    this._scene = scene;
    const engine = this._scene.getEngine();
    this._spriteRenderer = new SpriteRenderer(engine, capacity, epsilon, scene);
    if (cellSize.width && cellSize.height) {
      this.cellWidth = cellSize.width;
      this.cellHeight = cellSize.height;
    } else if (cellSize !== void 0) {
      this.cellWidth = cellSize;
      this.cellHeight = cellSize;
    } else {
      this._spriteRenderer = null;
      return;
    }
    this._scene.spriteManagers.push(this);
    this.uniqueId = this.scene.getUniqueId();
    if (imgUrl) {
      this.texture = new Texture(imgUrl, scene, true, false, samplingMode);
    }
    if (this._fromPacked) {
      this._makePacked(imgUrl, spriteJSON);
    }
  }
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  get children() {
    return this.sprites;
  }
  get scene() {
    return this._scene;
  }
  get capacity() {
    return this._spriteRenderer.capacity;
  }
  get texture() {
    return this._spriteRenderer.texture;
  }
  set texture(value) {
    value.wrapU = Texture.CLAMP_ADDRESSMODE;
    value.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._spriteRenderer.texture = value;
    this._textureContent = null;
  }
  get cellWidth() {
    return this._spriteRenderer.cellWidth;
  }
  set cellWidth(value) {
    this._spriteRenderer.cellWidth = value;
  }
  get cellHeight() {
    return this._spriteRenderer.cellHeight;
  }
  set cellHeight(value) {
    this._spriteRenderer.cellHeight = value;
  }
  get fogEnabled() {
    return this._spriteRenderer.fogEnabled;
  }
  set fogEnabled(value) {
    this._spriteRenderer.fogEnabled = value;
  }
  get blendMode() {
    return this._spriteRenderer.blendMode;
  }
  set blendMode(blendMode) {
    this._spriteRenderer.blendMode = blendMode;
  }
  get disableDepthWrite() {
    return this._disableDepthWrite;
  }
  set disableDepthWrite(value) {
    this._disableDepthWrite = value;
    this._spriteRenderer.disableDepthWrite = value;
  }
  getClassName() {
    return "SpriteManager";
  }
  _makePacked(imgUrl, spriteJSON) {
    if (spriteJSON !== null) {
      try {
        let celldata;
        if (typeof spriteJSON === "string") {
          celldata = JSON.parse(spriteJSON);
        } else {
          celldata = spriteJSON;
        }
        if (celldata.frames.length) {
          const frametemp = {};
          for (let i = 0; i < celldata.frames.length; i++) {
            const _f = celldata.frames[i];
            if (typeof Object.keys(_f)[0] !== "string") {
              throw new Error("Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.");
            }
            const name137 = _f[Object.keys(_f)[0]];
            frametemp[name137] = _f;
          }
          celldata.frames = frametemp;
        }
        const spritemap = Reflect.ownKeys(celldata.frames);
        this._spriteMap = spritemap;
        this._packedAndReady = true;
        this._cellData = celldata.frames;
      } catch (e) {
        this._fromPacked = false;
        this._packedAndReady = false;
        throw new Error("Invalid JSON from string. Spritesheet managed with constant cell size.");
      }
    } else {
      const re = /\./g;
      let li;
      do {
        li = re.lastIndex;
        re.test(imgUrl);
      } while (re.lastIndex > 0);
      const jsonUrl = imgUrl.substring(0, li - 1) + ".json";
      const onerror = () => {
        Logger.Error("JSON ERROR: Unable to load JSON file.");
        this._fromPacked = false;
        this._packedAndReady = false;
      };
      const onload = (data) => {
        try {
          const celldata = JSON.parse(data);
          const spritemap = Reflect.ownKeys(celldata.frames);
          this._spriteMap = spritemap;
          this._packedAndReady = true;
          this._cellData = celldata.frames;
        } catch (e) {
          this._fromPacked = false;
          this._packedAndReady = false;
          throw new Error("Invalid JSON format. Please check documentation for format specifications.");
        }
      };
      Tools.LoadFile(jsonUrl, onload, void 0, void 0, false, onerror);
    }
  }
  _checkTextureAlpha(sprite, ray, distance, min, max) {
    if (!sprite.useAlphaForPicking || !this.texture) {
      return true;
    }
    const textureSize = this.texture.getSize();
    if (!this._textureContent) {
      this._textureContent = new Uint8Array(textureSize.width * textureSize.height * 4);
      this.texture.readPixels(0, 0, this._textureContent);
    }
    const contactPoint = TmpVectors.Vector3[0];
    contactPoint.copyFrom(ray.direction);
    contactPoint.normalize();
    contactPoint.scaleInPlace(distance);
    contactPoint.addInPlace(ray.origin);
    const contactPointU = (contactPoint.x - min.x) / (max.x - min.x) - 0.5;
    const contactPointV = 1 - (contactPoint.y - min.y) / (max.y - min.y) - 0.5;
    const angle = sprite.angle;
    const rotatedU = 0.5 + (contactPointU * Math.cos(angle) - contactPointV * Math.sin(angle));
    const rotatedV = 0.5 + (contactPointU * Math.sin(angle) + contactPointV * Math.cos(angle));
    const u = sprite._xOffset * textureSize.width + rotatedU * sprite._xSize | 0;
    const v = sprite._yOffset * textureSize.height + rotatedV * sprite._ySize | 0;
    const alpha = this._textureContent[(u + v * textureSize.width) * 4 + 3];
    return alpha > 0.5;
  }
  intersects(ray, camera, predicate, fastCheck) {
    const count = Math.min(this.capacity, this.sprites.length);
    const min = Vector3.Zero();
    const max = Vector3.Zero();
    let distance = Number.MAX_VALUE;
    let currentSprite = null;
    const pickedPoint = TmpVectors.Vector3[0];
    const cameraSpacePosition = TmpVectors.Vector3[1];
    const cameraView = camera.getViewMatrix();
    let activeRay = ray;
    let pickedRay = ray;
    for (let index = 0; index < count; index++) {
      const sprite = this.sprites[index];
      if (!sprite) {
        continue;
      }
      if (predicate) {
        if (!predicate(sprite)) {
          continue;
        }
      } else if (!sprite.isPickable) {
        continue;
      }
      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);
      if (sprite.angle) {
        Matrix.TranslationToRef(-cameraSpacePosition.x, -cameraSpacePosition.y, 0, TmpVectors.Matrix[1]);
        Matrix.TranslationToRef(cameraSpacePosition.x, cameraSpacePosition.y, 0, TmpVectors.Matrix[2]);
        Matrix.RotationZToRef(sprite.angle, TmpVectors.Matrix[3]);
        TmpVectors.Matrix[1].multiplyToRef(TmpVectors.Matrix[3], TmpVectors.Matrix[4]);
        TmpVectors.Matrix[4].multiplyToRef(TmpVectors.Matrix[2], TmpVectors.Matrix[0]);
        activeRay = ray.clone();
        Vector3.TransformCoordinatesToRef(ray.origin, TmpVectors.Matrix[0], activeRay.origin);
        Vector3.TransformNormalToRef(ray.direction, TmpVectors.Matrix[0], activeRay.direction);
      } else {
        activeRay = ray;
      }
      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);
      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);
      if (activeRay.intersectsBoxMinMax(min, max)) {
        const currentDistance = Vector3.Distance(cameraSpacePosition, activeRay.origin);
        if (distance > currentDistance) {
          if (!this._checkTextureAlpha(sprite, activeRay, currentDistance, min, max)) {
            continue;
          }
          pickedRay = activeRay;
          distance = currentDistance;
          currentSprite = sprite;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    if (currentSprite) {
      const result = new PickingInfo();
      cameraView.invertToRef(TmpVectors.Matrix[0]);
      result.hit = true;
      result.pickedSprite = currentSprite;
      result.distance = distance;
      const direction = TmpVectors.Vector3[2];
      direction.copyFrom(pickedRay.direction);
      direction.normalize();
      direction.scaleInPlace(distance);
      pickedRay.origin.addToRef(direction, pickedPoint);
      result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);
      return result;
    }
    return null;
  }
  multiIntersects(ray, camera, predicate) {
    const count = Math.min(this.capacity, this.sprites.length);
    const min = Vector3.Zero();
    const max = Vector3.Zero();
    let distance;
    const results = [];
    const pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);
    const cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);
    const cameraView = camera.getViewMatrix();
    for (let index = 0; index < count; index++) {
      const sprite = this.sprites[index];
      if (!sprite) {
        continue;
      }
      if (predicate) {
        if (!predicate(sprite)) {
          continue;
        }
      } else if (!sprite.isPickable) {
        continue;
      }
      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);
      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);
      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);
      if (ray.intersectsBoxMinMax(min, max)) {
        distance = Vector3.Distance(cameraSpacePosition, ray.origin);
        if (!this._checkTextureAlpha(sprite, ray, distance, min, max)) {
          continue;
        }
        const result = new PickingInfo();
        results.push(result);
        cameraView.invertToRef(TmpVectors.Matrix[0]);
        result.hit = true;
        result.pickedSprite = sprite;
        result.distance = distance;
        const direction = TmpVectors.Vector3[2];
        direction.copyFrom(ray.direction);
        direction.normalize();
        direction.scaleInPlace(distance);
        ray.origin.addToRef(direction, pickedPoint);
        result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);
      }
    }
    return results;
  }
  render() {
    if (this._fromPacked && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {
      return;
    }
    const engine = this._scene.getEngine();
    const deltaTime = engine.getDeltaTime();
    if (this._packedAndReady) {
      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate);
    } else {
      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix());
    }
  }
  rebuild() {
    var _a;
    (_a = this._spriteRenderer) === null || _a === void 0 ? void 0 : _a.rebuild();
  }
  dispose() {
    if (this._spriteRenderer) {
      this._spriteRenderer.dispose();
      this._spriteRenderer = null;
    }
    this._textureContent = null;
    const index = this._scene.spriteManagers.indexOf(this);
    this._scene.spriteManagers.splice(index, 1);
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.metadata = null;
  }
  serialize(serializeTexture = false) {
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.capacity = this.capacity;
    serializationObject.cellWidth = this.cellWidth;
    serializationObject.cellHeight = this.cellHeight;
    if (this.texture) {
      if (serializeTexture) {
        serializationObject.texture = this.texture.serialize();
      } else {
        serializationObject.textureUrl = this.texture.name;
        serializationObject.invertY = this.texture._invertY;
      }
    }
    serializationObject.sprites = [];
    for (const sprite of this.sprites) {
      serializationObject.sprites.push(sprite.serialize());
    }
    serializationObject.metadata = this.metadata;
    return serializationObject;
  }
  static Parse(parsedManager, scene, rootUrl) {
    const manager = new SpriteManager(parsedManager.name, "", parsedManager.capacity, {
      width: parsedManager.cellWidth,
      height: parsedManager.cellHeight
    }, scene);
    if (parsedManager.metadata !== void 0) {
      manager.metadata = parsedManager.metadata;
    }
    if (parsedManager.texture) {
      manager.texture = Texture.Parse(parsedManager.texture, scene, rootUrl);
    } else if (parsedManager.textureName) {
      manager.texture = new Texture(rootUrl + parsedManager.textureUrl, scene, false, parsedManager.invertY !== void 0 ? parsedManager.invertY : true);
    }
    for (const parsedSprite of parsedManager.sprites) {
      Sprite.Parse(parsedSprite, manager);
    }
    return manager;
  }
  static ParseFromFileAsync(name137, url, scene, rootUrl = "") {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const serializationObject = JSON.parse(request.responseText);
            const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
            if (name137) {
              output.name = name137;
            }
            resolve(output);
          } else {
            reject("Unable to load the sprite manager");
          }
        }
      });
      request.open("GET", url);
      request.send();
    });
  }
  static ParseFromSnippetAsync(snippetId, scene, rootUrl = "") {
    if (snippetId === "_BLANK") {
      return Promise.resolve(new SpriteManager("Default sprite manager", "//playground.babylonjs.com/textures/player.png", 500, 64, scene));
    }
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            const serializationObject = JSON.parse(snippet.spriteManager);
            const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
            output.snippetId = snippetId;
            resolve(output);
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  }
};
SpriteManager.SnippetUrl = `https://snippet.babylonjs.com`;
SpriteManager.CreateFromSnippetAsync = SpriteManager.ParseFromSnippetAsync;

// node_modules/@babylonjs/core/Shaders/spriteMap.fragment.js
var name135 = "spriteMapPixelShader";
var shader135 = `#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)
#else
#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)
#endif
precision highp float;
varying vec3 vPosition;
varying vec2 vUV;
varying vec2 tUV;
uniform float time;
uniform float spriteCount;
uniform sampler2D spriteSheet;
uniform vec2 spriteMapSize;
uniform vec2 outputSize;
uniform vec2 stageSize;
uniform sampler2D frameMap;
uniform sampler2D tileMaps[LAYERS];
uniform sampler2D animationMap;
uniform vec3 colorMul;
float mt;
const float fdStep=1./4.;
const float aFrameSteps=1./MAX_ANIMATION_FRAMES;
mat4 getFrameData(float frameID){
float fX=frameID/spriteCount;
return mat4(
texture2D(frameMap,vec2(fX,0.),0.),
texture2D(frameMap,vec2(fX,fdStep*1.),0.),
texture2D(frameMap,vec2(fX,fdStep*2.),0.),
vec4(0.)
);
}
void main(){
vec4 color=vec4(0.);
vec2 tileUV=fract(tUV);
#ifdef FLIPU
tileUV.y=1.0-tileUV.y;
#endif
vec2 tileID=floor(tUV);
vec2 sheetUnits=1./spriteMapSize;
float spriteUnits=1./spriteCount;
vec2 stageUnits=1./stageSize;
for(int i=0; i<LAYERS; i++) {
float frameID;
#define LAYER_ID_SWITCH
vec4 animationData=TEXTUREFUNC(animationMap,vec2((frameID+0.5)/spriteCount,0.),0.);
if(animationData.y>0.) {
mt=mod(time*animationData.z,1.0);
for(float f=0.; f<MAX_ANIMATION_FRAMES; f++){
if(animationData.y>mt){
frameID=animationData.x;
break;
}
animationData=TEXTUREFUNC(animationMap,vec2((frameID+0.5)/spriteCount,aFrameSteps*f),0.);
}
}
mat4 frameData=getFrameData(frameID+0.5);
vec2 frameSize=(frameData[0].zw)/spriteMapSize;
vec2 offset=frameData[0].xy*sheetUnits;
vec2 ratio=frameData[2].xy/frameData[0].zw;
if (frameData[2].z==1.){
tileUV.xy=tileUV.yx;
}
vec4 nc=texture2D(spriteSheet,tileUV*frameSize+offset);
if (i==0){
color=nc;
} else {
float alpha=min(color.a+nc.a,1.0);
vec3 mixed=mix(color.xyz,nc.xyz,nc.a);
color=vec4(mixed,alpha);
}
}
color.xyz*=colorMul;
gl_FragColor=color;
}`;
ShaderStore.ShadersStore[name135] = shader135;

// node_modules/@babylonjs/core/Shaders/spriteMap.vertex.js
var name136 = "spriteMapVertexShader";
var shader136 = `precision highp float;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
varying vec3 vPosition;
varying vec2 vUV;
varying vec2 tUV;
varying vec2 stageUnits;
varying vec2 levelUnits;
varying vec2 tileID;
uniform float time;
uniform mat4 worldViewProjection;
uniform vec2 outputSize;
uniform vec2 stageSize;
uniform vec2 spriteMapSize;
uniform float stageScale;
void main() {
vec4 p=vec4( position,1. );
vPosition=p.xyz;
vUV=uv;
tUV=uv*stageSize; 
gl_Position=worldViewProjection*p;
}`;
ShaderStore.ShadersStore[name136] = shader136;

// node_modules/@babylonjs/core/Sprites/spriteMap.js
var SpriteMap = class {
  constructor(name137, atlasJSON, spriteSheet, options, scene) {
    this.name = name137;
    this.sprites = [];
    this.atlasJSON = atlasJSON;
    this.sprites = this.atlasJSON["frames"];
    this.spriteSheet = spriteSheet;
    this.options = options;
    options.stageSize = options.stageSize || new Vector2(1, 1);
    options.outputSize = options.outputSize || options.stageSize;
    options.outputPosition = options.outputPosition || Vector3.Zero();
    options.outputRotation = options.outputRotation || Vector3.Zero();
    options.layerCount = options.layerCount || 1;
    options.maxAnimationFrames = options.maxAnimationFrames || 0;
    options.baseTile = options.baseTile || 0;
    options.flipU = options.flipU || false;
    options.colorMultiply = options.colorMultiply || new Vector3(1, 1, 1);
    this._scene = scene;
    this._frameMap = this._createFrameBuffer();
    this._tileMaps = new Array();
    for (let i = 0; i < options.layerCount; i++) {
      this._tileMaps.push(this._createTileBuffer(null, i));
    }
    this._animationMap = this._createTileAnimationBuffer(null);
    const defines = [];
    defines.push("#define LAYERS " + options.layerCount);
    if (options.flipU) {
      defines.push("#define FLIPU");
    }
    defines.push(`#define MAX_ANIMATION_FRAMES ${options.maxAnimationFrames}.0`);
    const shaderString = Effect.ShadersStore["spriteMapPixelShader"];
    let layerSampleString;
    if (!scene.getEngine()._features.supportSwitchCaseInShader) {
      layerSampleString = "";
      for (let i = 0; i < options.layerCount; i++) {
        layerSampleString += `if (${i} == i) { frameID = texture2D(tileMaps[${i}], (tileID + 0.5) / stageSize, 0.).x; }`;
      }
    } else {
      layerSampleString = "switch(i) {";
      for (let i = 0; i < options.layerCount; i++) {
        layerSampleString += "case " + i + " : frameID = texture(tileMaps[" + i + "], (tileID + 0.5) / stageSize, 0.).x;";
        layerSampleString += "break;";
      }
      layerSampleString += "}";
    }
    Effect.ShadersStore["spriteMap" + this.name + "PixelShader"] = shaderString.replace("#define LAYER_ID_SWITCH", layerSampleString);
    this._material = new ShaderMaterial("spriteMap:" + this.name, this._scene, {
      vertex: "spriteMap",
      fragment: "spriteMap" + this.name
    }, {
      defines,
      attributes: ["position", "normal", "uv"],
      uniforms: ["worldViewProjection", "time", "stageSize", "outputSize", "spriteMapSize", "spriteCount", "time", "colorMul", "mousePosition", "curTile", "flipU"],
      samplers: ["spriteSheet", "frameMap", "tileMaps", "animationMap"],
      needAlphaBlending: true
    });
    this._time = 0;
    this._material.setFloat("spriteCount", this.spriteCount);
    this._material.setVector2("stageSize", options.stageSize);
    this._material.setVector2("outputSize", options.outputSize);
    this._material.setTexture("spriteSheet", this.spriteSheet);
    this._material.setVector2("spriteMapSize", new Vector2(1, 1));
    this._material.setVector3("colorMul", options.colorMultiply);
    let tickSave = 0;
    const bindSpriteTexture = () => {
      if (this.spriteSheet && this.spriteSheet.isReady()) {
        if (this.spriteSheet._texture) {
          this._material.setVector2("spriteMapSize", new Vector2(this.spriteSheet._texture.baseWidth || 1, this.spriteSheet._texture.baseHeight || 1));
          return;
        }
      }
      if (tickSave < 100) {
        setTimeout(() => {
          tickSave++;
          bindSpriteTexture();
        }, 100);
      }
    };
    bindSpriteTexture();
    this._material.setVector3("colorMul", options.colorMultiply);
    this._material.setTexture("frameMap", this._frameMap);
    this._material.setTextureArray("tileMaps", this._tileMaps);
    this._material.setTexture("animationMap", this._animationMap);
    this._material.setFloat("time", this._time);
    this._output = CreatePlane(name137 + ":output", { size: 1, updatable: true }, scene);
    this._output.scaling.x = options.outputSize.x;
    this._output.scaling.y = options.outputSize.y;
    this.position = options.outputPosition;
    this.rotation = options.outputRotation;
    const obfunction = () => {
      this._time += this._scene.getEngine().getDeltaTime();
      this._material.setFloat("time", this._time);
    };
    this._scene.onBeforeRenderObservable.add(obfunction);
    this._output.material = this._material;
  }
  get spriteCount() {
    return this.sprites.length;
  }
  get position() {
    return this._output.position;
  }
  set position(v) {
    this._output.position = v;
  }
  get rotation() {
    return this._output.rotation;
  }
  set rotation(v) {
    this._output.rotation = v;
  }
  get animationMap() {
    return this._animationMap;
  }
  set animationMap(v) {
    const buffer = v._texture._bufferView;
    const am = this._createTileAnimationBuffer(buffer);
    this._animationMap.dispose();
    this._animationMap = am;
    this._material.setTexture("animationMap", this._animationMap);
  }
  getTileID() {
    const p = this.getMousePosition();
    p.multiplyInPlace(this.options.stageSize || Vector2.Zero());
    p.x = Math.floor(p.x);
    p.y = Math.floor(p.y);
    return p;
  }
  getMousePosition() {
    const out = this._output;
    const pickinfo = this._scene.pick(this._scene.pointerX, this._scene.pointerY, (mesh) => {
      if (mesh !== out) {
        return false;
      }
      return true;
    });
    if (!pickinfo || !pickinfo.hit || !pickinfo.getTextureCoordinates) {
      return new Vector2(-1, -1);
    }
    const coords = pickinfo.getTextureCoordinates();
    if (coords) {
      return coords;
    }
    return new Vector2(-1, -1);
  }
  _createFrameBuffer() {
    const data = new Array();
    for (let i = 0; i < this.spriteCount; i++) {
      data.push(0, 0, 0, 0);
      data.push(0, 0, 0, 0);
      data.push(0, 0, 0, 0);
      data.push(0, 0, 0, 0);
    }
    for (let i = 0; i < this.spriteCount; i++) {
      const f = this.sprites[i]["frame"];
      const sss = this.sprites[i]["spriteSourceSize"];
      const ss = this.sprites[i]["sourceSize"];
      const r = this.sprites[i]["rotated"] ? 1 : 0;
      const t2 = this.sprites[i]["trimmed"] ? 1 : 0;
      data[i * 4] = f.x;
      data[i * 4 + 1] = f.y;
      data[i * 4 + 2] = f.w;
      data[i * 4 + 3] = f.h;
      data[i * 4 + this.spriteCount * 4] = sss.x;
      data[i * 4 + 1 + this.spriteCount * 4] = sss.y;
      data[i * 4 + 3 + this.spriteCount * 4] = sss.h;
      data[i * 4 + this.spriteCount * 8] = ss.w;
      data[i * 4 + 1 + this.spriteCount * 8] = ss.h;
      data[i * 4 + 2 + this.spriteCount * 8] = r;
      data[i * 4 + 3 + this.spriteCount * 8] = t2;
    }
    const floatArray = new Float32Array(data);
    const t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);
    return t;
  }
  _createTileBuffer(buffer, _layer = 0) {
    let data = new Array();
    const _ty = this.options.stageSize.y || 0;
    const _tx = this.options.stageSize.x || 0;
    if (!buffer) {
      let bt = this.options.baseTile;
      if (_layer != 0) {
        bt = 0;
      }
      for (let y = 0; y < _ty; y++) {
        for (let x = 0; x < _tx * 4; x += 4) {
          data.push(bt, 0, 0, 0);
        }
      }
    } else {
      data = buffer;
    }
    const floatArray = new Float32Array(data);
    const t = RawTexture.CreateRGBATexture(floatArray, _tx, _ty, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);
    return t;
  }
  changeTiles(_layer = 0, pos, tile = 0) {
    const buffer = this._tileMaps[_layer]._texture._bufferView;
    if (buffer === null) {
      return;
    }
    let p = new Array();
    if (pos instanceof Vector2) {
      p.push(pos);
    } else {
      p = pos;
    }
    const _tx = this.options.stageSize.x || 0;
    for (let i = 0; i < p.length; i++) {
      const _p = p[i];
      _p.x = Math.floor(_p.x);
      _p.y = Math.floor(_p.y);
      const id = _p.x * 4 + _p.y * (_tx * 4);
      buffer[id] = tile;
    }
    const t = this._createTileBuffer(buffer);
    this._tileMaps[_layer].dispose();
    this._tileMaps[_layer] = t;
    this._material.setTextureArray("tileMap", this._tileMaps);
  }
  _createTileAnimationBuffer(buffer) {
    const data = new Array();
    let floatArray;
    if (!buffer) {
      for (let i = 0; i < this.spriteCount; i++) {
        data.push(0, 0, 0, 0);
        let count = 1;
        while (count < (this.options.maxAnimationFrames || 4)) {
          data.push(0, 0, 0, 0);
          count++;
        }
      }
      floatArray = new Float32Array(data);
    } else {
      floatArray = buffer;
    }
    const t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, this.options.maxAnimationFrames || 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);
    return t;
  }
  addAnimationToTile(cellID = 0, _frame = 0, toCell = 0, time = 0, speed = 1) {
    const buffer = this._animationMap._texture._bufferView;
    const id = cellID * 4 + this.spriteCount * 4 * _frame;
    if (!buffer) {
      return;
    }
    buffer[id] = toCell;
    buffer[id + 1] = time;
    buffer[id + 2] = speed;
    const t = this._createTileAnimationBuffer(buffer);
    this._animationMap.dispose();
    this._animationMap = t;
    this._material.setTexture("animationMap", this._animationMap);
  }
  saveTileMaps() {
    let maps = "";
    for (let i = 0; i < this._tileMaps.length; i++) {
      if (i > 0) {
        maps += "\n\r";
      }
      maps += this._tileMaps[i]._texture._bufferView.toString();
    }
    const hiddenElement = document.createElement("a");
    hiddenElement.href = "data:octet/stream;charset=utf-8," + encodeURI(maps);
    hiddenElement.target = "_blank";
    hiddenElement.download = this.name + ".tilemaps";
    hiddenElement.click();
    hiddenElement.remove();
  }
  loadTileMaps(url) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    const _lc = this.options.layerCount || 0;
    xhr.onload = () => {
      const data = xhr.response.split("\n\r");
      for (let i = 0; i < _lc; i++) {
        const d = data[i].split(",").map(Number);
        const t = this._createTileBuffer(d);
        this._tileMaps[i].dispose();
        this._tileMaps[i] = t;
      }
      this._material.setTextureArray("tileMap", this._tileMaps);
    };
    xhr.send();
  }
  dispose() {
    this._output.dispose();
    this._material.dispose();
    this._animationMap.dispose();
    this._tileMaps.forEach((tm) => {
      tm.dispose();
    });
    this._frameMap.dispose();
  }
};

// node_modules/@babylonjs/core/Sprites/spritePackedManager.js
var SpritePackedManager = class extends SpriteManager {
  constructor(name137, imgUrl, capacity, scene, spriteJSON = null, epsilon = 0.01, samplingMode = Texture.TRILINEAR_SAMPLINGMODE) {
    super(name137, imgUrl, capacity, 64, scene, epsilon, samplingMode, true, spriteJSON);
    this.name = name137;
  }
};

// node_modules/@babylonjs/core/Misc/assetsManager.js
var AssetTaskState;
(function(AssetTaskState2) {
  AssetTaskState2[AssetTaskState2["INIT"] = 0] = "INIT";
  AssetTaskState2[AssetTaskState2["RUNNING"] = 1] = "RUNNING";
  AssetTaskState2[AssetTaskState2["DONE"] = 2] = "DONE";
  AssetTaskState2[AssetTaskState2["ERROR"] = 3] = "ERROR";
})(AssetTaskState || (AssetTaskState = {}));
var AbstractAssetTask = class {
  constructor(name137) {
    this.name = name137;
    this._isCompleted = false;
    this._taskState = AssetTaskState.INIT;
  }
  get isCompleted() {
    return this._isCompleted;
  }
  get taskState() {
    return this._taskState;
  }
  get errorObject() {
    return this._errorObject;
  }
  _setErrorObject(message, exception) {
    if (this._errorObject) {
      return;
    }
    this._errorObject = {
      message,
      exception
    };
  }
  run(scene, onSuccess, onError) {
    this._taskState = AssetTaskState.RUNNING;
    this.runTask(scene, () => {
      this._onDoneCallback(onSuccess, onError);
    }, (msg, exception) => {
      this._onErrorCallback(onError, msg, exception);
    });
  }
  runTask(scene, onSuccess, onError) {
    throw new Error("runTask is not implemented");
  }
  reset() {
    this._taskState = AssetTaskState.INIT;
  }
  _onErrorCallback(onError, message, exception) {
    this._taskState = AssetTaskState.ERROR;
    this._errorObject = {
      message,
      exception
    };
    if (this.onError) {
      this.onError(this, message, exception);
    }
    onError();
  }
  _onDoneCallback(onSuccess, onError) {
    try {
      this._taskState = AssetTaskState.DONE;
      this._isCompleted = true;
      if (this.onSuccess) {
        this.onSuccess(this);
      }
      onSuccess();
    } catch (e) {
      this._onErrorCallback(onError, "Task is done, error executing success callback(s)", e);
    }
  }
};
var AssetsProgressEvent = class {
  constructor(remainingCount, totalCount, task) {
    this.remainingCount = remainingCount;
    this.totalCount = totalCount;
    this.task = task;
  }
};
var ContainerAssetTask = class extends AbstractAssetTask {
  constructor(name137, meshesNames, rootUrl, sceneFilename, extension) {
    super(name137);
    this.name = name137;
    this.meshesNames = meshesNames;
    this.rootUrl = rootUrl;
    this.sceneFilename = sceneFilename;
    this.extension = extension;
  }
  runTask(scene, onSuccess, onError) {
    SceneLoader.LoadAssetContainer(this.rootUrl, this.sceneFilename, scene, (container) => {
      this.loadedContainer = container;
      this.loadedMeshes = container.meshes;
      this.loadedTransformNodes = container.transformNodes;
      this.loadedParticleSystems = container.particleSystems;
      this.loadedSkeletons = container.skeletons;
      this.loadedAnimationGroups = container.animationGroups;
      onSuccess();
    }, null, (scene2, message, exception) => {
      onError(message, exception);
    }, this.extension);
  }
};
var MeshAssetTask = class extends AbstractAssetTask {
  constructor(name137, meshesNames, rootUrl, sceneFilename, extension) {
    super(name137);
    this.name = name137;
    this.meshesNames = meshesNames;
    this.rootUrl = rootUrl;
    this.sceneFilename = sceneFilename;
    this.extension = extension;
  }
  runTask(scene, onSuccess, onError) {
    SceneLoader.ImportMesh(this.meshesNames, this.rootUrl, this.sceneFilename, scene, (meshes, particleSystems, skeletons, animationGroups, transformNodes) => {
      this.loadedMeshes = meshes;
      this.loadedTransformNodes = transformNodes;
      this.loadedParticleSystems = particleSystems;
      this.loadedSkeletons = skeletons;
      this.loadedAnimationGroups = animationGroups;
      onSuccess();
    }, null, (scene2, message, exception) => {
      onError(message, exception);
    }, this.extension);
  }
};
var TextFileAssetTask = class extends AbstractAssetTask {
  constructor(name137, url) {
    super(name137);
    this.name = name137;
    this.url = url;
  }
  runTask(scene, onSuccess, onError) {
    scene._loadFile(this.url, (data) => {
      this.text = data;
      onSuccess();
    }, void 0, false, false, (request, exception) => {
      if (request) {
        onError(request.status + " " + request.statusText, exception);
      }
    });
  }
};
var BinaryFileAssetTask = class extends AbstractAssetTask {
  constructor(name137, url) {
    super(name137);
    this.name = name137;
    this.url = url;
  }
  runTask(scene, onSuccess, onError) {
    scene._loadFile(this.url, (data) => {
      this.data = data;
      onSuccess();
    }, void 0, true, true, (request, exception) => {
      if (request) {
        onError(request.status + " " + request.statusText, exception);
      }
    });
  }
};
var ImageAssetTask = class extends AbstractAssetTask {
  constructor(name137, url) {
    super(name137);
    this.name = name137;
    this.url = url;
  }
  runTask(scene, onSuccess, onError) {
    const img = new Image();
    Tools.SetCorsBehavior(this.url, img);
    img.onload = () => {
      this.image = img;
      onSuccess();
    };
    img.onerror = (err) => {
      onError("Error loading image", err);
    };
    img.src = this.url;
  }
};
var TextureAssetTask = class extends AbstractAssetTask {
  constructor(name137, url, noMipmap, invertY = true, samplingMode = Texture.TRILINEAR_SAMPLINGMODE) {
    super(name137);
    this.name = name137;
    this.url = url;
    this.noMipmap = noMipmap;
    this.invertY = invertY;
    this.samplingMode = samplingMode;
  }
  runTask(scene, onSuccess, onError) {
    const onload = () => {
      onSuccess();
    };
    const onerror = (message, exception) => {
      onError(message, exception);
    };
    this.texture = new Texture(this.url, scene, this.noMipmap, this.invertY, this.samplingMode, onload, onerror);
  }
};
var CubeTextureAssetTask = class extends AbstractAssetTask {
  constructor(name137, url, extensions, noMipmap, files, prefiltered) {
    super(name137);
    this.name = name137;
    this.url = url;
    this.extensions = extensions;
    this.noMipmap = noMipmap;
    this.files = files;
    this.prefiltered = prefiltered;
  }
  runTask(scene, onSuccess, onError) {
    const onload = () => {
      onSuccess();
    };
    const onerror = (message, exception) => {
      onError(message, exception);
    };
    this.texture = new CubeTexture(this.url, scene, this.extensions, this.noMipmap, this.files, onload, onerror, void 0, this.prefiltered);
  }
};
var HDRCubeTextureAssetTask = class extends AbstractAssetTask {
  constructor(name137, url, size, noMipmap = false, generateHarmonics = true, gammaSpace = false, reserved = false) {
    super(name137);
    this.name = name137;
    this.url = url;
    this.size = size;
    this.noMipmap = noMipmap;
    this.generateHarmonics = generateHarmonics;
    this.gammaSpace = gammaSpace;
    this.reserved = reserved;
  }
  runTask(scene, onSuccess, onError) {
    const onload = () => {
      onSuccess();
    };
    const onerror = (message, exception) => {
      onError(message, exception);
    };
    this.texture = new HDRCubeTexture(this.url, scene, this.size, this.noMipmap, this.generateHarmonics, this.gammaSpace, this.reserved, onload, onerror);
  }
};
var EquiRectangularCubeTextureAssetTask = class extends AbstractAssetTask {
  constructor(name137, url, size, noMipmap = false, gammaSpace = true) {
    super(name137);
    this.name = name137;
    this.url = url;
    this.size = size;
    this.noMipmap = noMipmap;
    this.gammaSpace = gammaSpace;
  }
  runTask(scene, onSuccess, onError) {
    const onload = () => {
      onSuccess();
    };
    const onerror = (message, exception) => {
      onError(message, exception);
    };
    this.texture = new EquiRectangularCubeTexture(this.url, scene, this.size, this.noMipmap, this.gammaSpace, onload, onerror);
  }
};
var AssetsManager = class {
  constructor(scene) {
    this._isLoading = false;
    this._tasks = new Array();
    this._waitingTasksCount = 0;
    this._totalTasksCount = 0;
    this.onTaskSuccessObservable = new Observable();
    this.onTaskErrorObservable = new Observable();
    this.onTasksDoneObservable = new Observable();
    this.onProgressObservable = new Observable();
    this.useDefaultLoadingScreen = true;
    this.autoHideLoadingUI = true;
    this._scene = scene || EngineStore.LastCreatedScene;
  }
  addContainerTask(taskName, meshesNames, rootUrl, sceneFilename, extension) {
    const task = new ContainerAssetTask(taskName, meshesNames, rootUrl, sceneFilename, extension);
    this._tasks.push(task);
    return task;
  }
  addMeshTask(taskName, meshesNames, rootUrl, sceneFilename, extension) {
    const task = new MeshAssetTask(taskName, meshesNames, rootUrl, sceneFilename, extension);
    this._tasks.push(task);
    return task;
  }
  addTextFileTask(taskName, url) {
    const task = new TextFileAssetTask(taskName, url);
    this._tasks.push(task);
    return task;
  }
  addBinaryFileTask(taskName, url) {
    const task = new BinaryFileAssetTask(taskName, url);
    this._tasks.push(task);
    return task;
  }
  addImageTask(taskName, url) {
    const task = new ImageAssetTask(taskName, url);
    this._tasks.push(task);
    return task;
  }
  addTextureTask(taskName, url, noMipmap, invertY, samplingMode = Texture.TRILINEAR_SAMPLINGMODE) {
    const task = new TextureAssetTask(taskName, url, noMipmap, invertY, samplingMode);
    this._tasks.push(task);
    return task;
  }
  addCubeTextureTask(taskName, url, extensions, noMipmap, files, prefiltered) {
    const task = new CubeTextureAssetTask(taskName, url, extensions, noMipmap, files, prefiltered);
    this._tasks.push(task);
    return task;
  }
  addHDRCubeTextureTask(taskName, url, size, noMipmap = false, generateHarmonics = true, gammaSpace = false, reserved = false) {
    const task = new HDRCubeTextureAssetTask(taskName, url, size, noMipmap, generateHarmonics, gammaSpace, reserved);
    this._tasks.push(task);
    return task;
  }
  addEquiRectangularCubeTextureAssetTask(taskName, url, size, noMipmap = false, gammaSpace = true) {
    const task = new EquiRectangularCubeTextureAssetTask(taskName, url, size, noMipmap, gammaSpace);
    this._tasks.push(task);
    return task;
  }
  removeTask(task) {
    const index = this._tasks.indexOf(task);
    if (index > -1) {
      this._tasks.splice(index, 1);
    }
  }
  _decreaseWaitingTasksCount(task) {
    this._waitingTasksCount--;
    try {
      if (this.onProgress) {
        this.onProgress(this._waitingTasksCount, this._totalTasksCount, task);
      }
      this.onProgressObservable.notifyObservers(new AssetsProgressEvent(this._waitingTasksCount, this._totalTasksCount, task));
    } catch (e) {
      Logger.Error("Error running progress callbacks.");
      console.log(e);
    }
    if (this._waitingTasksCount === 0) {
      try {
        const currentTasks = this._tasks.slice();
        if (this.onFinish) {
          this.onFinish(currentTasks);
        }
        for (const task2 of currentTasks) {
          if (task2.taskState === AssetTaskState.DONE) {
            const index = this._tasks.indexOf(task2);
            if (index > -1) {
              this._tasks.splice(index, 1);
            }
          }
        }
        this.onTasksDoneObservable.notifyObservers(this._tasks);
      } catch (e) {
        Logger.Error("Error running tasks-done callbacks.");
        console.log(e);
      }
      this._isLoading = false;
      if (this.autoHideLoadingUI) {
        this._scene.getEngine().hideLoadingUI();
      }
    }
  }
  _runTask(task) {
    const done = () => {
      try {
        if (this.onTaskSuccess) {
          this.onTaskSuccess(task);
        }
        this.onTaskSuccessObservable.notifyObservers(task);
        this._decreaseWaitingTasksCount(task);
      } catch (e) {
        error("Error executing task success callbacks", e);
      }
    };
    const error = (message, exception) => {
      task._setErrorObject(message, exception);
      if (this.onTaskError) {
        this.onTaskError(task);
      } else if (!task.onError) {
        Logger.Error(this._formatTaskErrorMessage(task));
      }
      this.onTaskErrorObservable.notifyObservers(task);
      this._decreaseWaitingTasksCount(task);
    };
    task.run(this._scene, done, error);
  }
  _formatTaskErrorMessage(task) {
    let errorMessage = "Unable to complete task " + task.name;
    if (task.errorObject.message) {
      errorMessage += `: ${task.errorObject.message}`;
    }
    if (task.errorObject.exception) {
      errorMessage += `: ${task.errorObject.exception}`;
    }
    return errorMessage;
  }
  reset() {
    this._isLoading = false;
    this._tasks = new Array();
    return this;
  }
  load() {
    if (this._isLoading) {
      return this;
    }
    this._isLoading = true;
    this._waitingTasksCount = this._tasks.length;
    this._totalTasksCount = this._tasks.length;
    if (this._waitingTasksCount === 0) {
      this._isLoading = false;
      if (this.onFinish) {
        this.onFinish(this._tasks);
      }
      this.onTasksDoneObservable.notifyObservers(this._tasks);
      return this;
    }
    if (this.useDefaultLoadingScreen) {
      this._scene.getEngine().displayLoadingUI();
    }
    for (let index = 0; index < this._tasks.length; index++) {
      const task = this._tasks[index];
      if (task.taskState === AssetTaskState.INIT) {
        this._runTask(task);
      }
    }
    return this;
  }
  loadAsync() {
    return new Promise((resolve, reject) => {
      if (this._isLoading) {
        resolve();
        return;
      }
      this.onTasksDoneObservable.addOnce((remainingTasks) => {
        if (remainingTasks && remainingTasks.length) {
          reject(remainingTasks);
        } else {
          resolve();
        }
      });
      this.load();
    });
  }
};

// node_modules/@babylonjs/core/Misc/meshExploder.js
var MeshExploder = class {
  constructor(meshes, centerMesh) {
    this._meshesOrigins = [];
    this._toCenterVectors = [];
    this._scaledDirection = new Vector3(1, 1, 1);
    this._newPosition = Vector3.Zero();
    this._centerPosition = Vector3.Zero();
    this._meshes = meshes.slice();
    if (centerMesh) {
      this._centerMesh = centerMesh;
    } else {
      this._setCenterMesh();
    }
    this._centerMesh.computeWorldMatrix(true);
    const centerMeshIndex = this._meshes.indexOf(this._centerMesh);
    if (centerMeshIndex >= 0) {
      this._meshes.splice(centerMeshIndex, 1);
    }
    this._centerPosition = this._centerMesh.getAbsolutePosition().clone();
    for (let index = 0; index < this._meshes.length; index++) {
      if (this._meshes[index]) {
        const mesh = this._meshes[index];
        this._meshesOrigins[index] = mesh.getAbsolutePosition().clone();
        this._toCenterVectors[index] = Vector3.Zero();
        if (mesh.hasBoundingInfo && this._centerMesh.hasBoundingInfo) {
          mesh.computeWorldMatrix(true);
          mesh.getBoundingInfo().boundingBox.centerWorld.subtractToRef(this._centerMesh.getBoundingInfo().boundingBox.centerWorld, this._toCenterVectors[index]);
        }
      }
    }
  }
  _setCenterMesh() {
    let averageCenter = Vector3.Zero();
    const totalCenters = Vector3.Zero();
    let shortestToCenter = Number.MAX_VALUE;
    for (let index = 0; index < this._meshes.length; index++) {
      if (this._meshes[index]) {
        const mesh = this._meshes[index];
        const boundingInfo = mesh.getBoundingInfo();
        if (boundingInfo) {
          totalCenters.addInPlace(boundingInfo.boundingBox.centerWorld);
        }
      }
    }
    averageCenter = totalCenters.scale(1 / this._meshes.length);
    for (let index = 0; index < this._meshes.length; index++) {
      if (this._meshes[index]) {
        const mesh = this._meshes[index];
        const boundingInfo = mesh.getBoundingInfo();
        if (boundingInfo) {
          const distanceToCenter = boundingInfo.boundingBox.centerWorld.subtract(averageCenter).lengthSquared();
          if (distanceToCenter < shortestToCenter) {
            this._centerMesh = mesh;
            shortestToCenter = distanceToCenter;
          }
        }
      }
    }
  }
  getClassName() {
    return "MeshExploder";
  }
  getMeshes() {
    const meshArray = this._meshes.slice();
    meshArray.unshift(this._centerMesh);
    return meshArray;
  }
  explode(direction = 1) {
    for (let index = 0; index < this._meshes.length; index++) {
      if (this._meshes[index] && this._meshesOrigins[index] && this._toCenterVectors[index]) {
        this._toCenterVectors[index].scaleToRef(direction, this._scaledDirection);
        this._meshesOrigins[index].addToRef(this._scaledDirection, this._newPosition);
        this._meshes[index].setAbsolutePosition(this._newPosition);
      }
    }
    this._centerMesh.setAbsolutePosition(this._centerPosition);
  }
};

// node_modules/@babylonjs/core/Misc/filesInput.js
var FilesInput = class {
  constructor(engine, scene, sceneLoadedCallback, progressCallback, additionalRenderLoopLogicCallback, textureLoadingCallback, startingProcessingFilesCallback, onReloadCallback, errorCallback) {
    this.onProcessFileCallback = () => {
      return true;
    };
    this.loadAsync = (sceneFile, onProgress) => SceneLoader.LoadAsync("file:", sceneFile, this._engine, onProgress);
    this._engine = engine;
    this._currentScene = scene;
    this._sceneLoadedCallback = sceneLoadedCallback;
    this._progressCallback = progressCallback;
    this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;
    this._textureLoadingCallback = textureLoadingCallback;
    this._startingProcessingFilesCallback = startingProcessingFilesCallback;
    this._onReloadCallback = onReloadCallback;
    this._errorCallback = errorCallback;
  }
  static get FilesToLoad() {
    return FilesInputStore.FilesToLoad;
  }
  monitorElementForDragNDrop(elementToMonitor) {
    if (elementToMonitor) {
      this._elementToMonitor = elementToMonitor;
      this._dragEnterHandler = (e) => {
        this._drag(e);
      };
      this._dragOverHandler = (e) => {
        this._drag(e);
      };
      this._dropHandler = (e) => {
        this._drop(e);
      };
      this._elementToMonitor.addEventListener("dragenter", this._dragEnterHandler, false);
      this._elementToMonitor.addEventListener("dragover", this._dragOverHandler, false);
      this._elementToMonitor.addEventListener("drop", this._dropHandler, false);
    }
  }
  get filesToLoad() {
    return this._filesToLoad;
  }
  dispose() {
    if (!this._elementToMonitor) {
      return;
    }
    this._elementToMonitor.removeEventListener("dragenter", this._dragEnterHandler);
    this._elementToMonitor.removeEventListener("dragover", this._dragOverHandler);
    this._elementToMonitor.removeEventListener("drop", this._dropHandler);
  }
  _renderFunction() {
    if (this._additionalRenderLoopLogicCallback) {
      this._additionalRenderLoopLogicCallback();
    }
    if (this._currentScene) {
      if (this._textureLoadingCallback) {
        const remaining = this._currentScene.getWaitingItemsCount();
        if (remaining > 0) {
          this._textureLoadingCallback(remaining);
        }
      }
      this._currentScene.render();
    }
  }
  _drag(e) {
    e.stopPropagation();
    e.preventDefault();
  }
  _drop(eventDrop) {
    eventDrop.stopPropagation();
    eventDrop.preventDefault();
    this.loadFiles(eventDrop);
  }
  _traverseFolder(folder, files, remaining, callback) {
    const reader = folder.createReader();
    const relativePath = folder.fullPath.replace(/^\//, "").replace(/(.+?)\/?$/, "$1/");
    reader.readEntries((entries) => {
      remaining.count += entries.length;
      for (const entry of entries) {
        if (entry.isFile) {
          entry.file((file) => {
            file.correctName = relativePath + file.name;
            files.push(file);
            if (--remaining.count === 0) {
              callback();
            }
          });
        } else if (entry.isDirectory) {
          this._traverseFolder(entry, files, remaining, callback);
        }
      }
      if (--remaining.count === 0) {
        callback();
      }
    });
  }
  _processFiles(files) {
    for (let i = 0; i < files.length; i++) {
      const name137 = files[i].correctName.toLowerCase();
      const extension = name137.split(".").pop();
      if (!this.onProcessFileCallback(files[i], name137, extension, (sceneFile) => this._sceneFileToLoad = sceneFile)) {
        continue;
      }
      if (SceneLoader.IsPluginForExtensionAvailable("." + extension)) {
        this._sceneFileToLoad = files[i];
      }
      FilesInput.FilesToLoad[name137] = files[i];
    }
  }
  loadFiles(event) {
    if (event && event.dataTransfer && event.dataTransfer.files) {
      this._filesToLoad = event.dataTransfer.files;
    }
    if (event && event.target && event.target.files) {
      this._filesToLoad = event.target.files;
    }
    if (!this._filesToLoad || this._filesToLoad.length === 0) {
      return;
    }
    if (this._startingProcessingFilesCallback) {
      this._startingProcessingFilesCallback(this._filesToLoad);
    }
    if (this._filesToLoad && this._filesToLoad.length > 0) {
      const files = new Array();
      const folders = [];
      const items = event.dataTransfer ? event.dataTransfer.items : null;
      for (let i = 0; i < this._filesToLoad.length; i++) {
        const fileToLoad = this._filesToLoad[i];
        const name137 = fileToLoad.name.toLowerCase();
        let entry;
        fileToLoad.correctName = name137;
        if (items) {
          const item = items[i];
          if (item.getAsEntry) {
            entry = item.getAsEntry();
          } else if (item.webkitGetAsEntry) {
            entry = item.webkitGetAsEntry();
          }
        }
        if (!entry) {
          files.push(fileToLoad);
        } else {
          if (entry.isDirectory) {
            folders.push(entry);
          } else {
            files.push(fileToLoad);
          }
        }
      }
      if (folders.length === 0) {
        this._processFiles(files);
        this._processReload();
      } else {
        const remaining = { count: folders.length };
        for (const folder of folders) {
          this._traverseFolder(folder, files, remaining, () => {
            this._processFiles(files);
            if (remaining.count === 0) {
              this._processReload();
            }
          });
        }
      }
    }
  }
  _processReload() {
    if (this._onReloadCallback) {
      this._onReloadCallback(this._sceneFileToLoad);
    } else {
      this.reload();
    }
  }
  reload() {
    if (this._sceneFileToLoad) {
      if (this._currentScene) {
        if (Logger.errorsCount > 0) {
          Logger.ClearLogCache();
        }
        this._engine.stopRenderLoop();
      }
      SceneLoader.ShowLoadingScreen = false;
      this._engine.displayLoadingUI();
      this.loadAsync(this._sceneFileToLoad, this._progressCallback).then((scene) => {
        if (this._currentScene) {
          this._currentScene.dispose();
        }
        this._currentScene = scene;
        if (this._sceneLoadedCallback) {
          this._sceneLoadedCallback(this._sceneFileToLoad, this._currentScene);
        }
        this._currentScene.executeWhenReady(() => {
          this._engine.hideLoadingUI();
          this._engine.runRenderLoop(() => {
            this._renderFunction();
          });
        });
      }).catch((error) => {
        this._engine.hideLoadingUI();
        if (this._errorCallback) {
          this._errorCallback(this._sceneFileToLoad, this._currentScene, error.message);
        }
      });
    } else {
      Logger.Error("Please provide a valid .babylon file.");
    }
  }
};

// node_modules/@babylonjs/core/Misc/observable.extensions.js
var MultiObserver = class {
  dispose() {
    if (this._observers && this._observables) {
      for (let index = 0; index < this._observers.length; index++) {
        this._observables[index].remove(this._observers[index]);
      }
    }
    this._observers = null;
    this._observables = null;
  }
  static Watch(observables, callback, mask = -1, scope = null) {
    const result = new MultiObserver();
    result._observers = new Array();
    result._observables = observables;
    for (const observable of observables) {
      const observer = observable.add(callback, mask, false, scope);
      if (observer) {
        result._observers.push(observer);
      }
    }
    return result;
  }
};
Observable.prototype.notifyObserversWithPromise = async function(eventData, mask = -1, target, currentTarget, userInfo) {
  let p = Promise.resolve(eventData);
  if (!this.observers.length) {
    return p;
  }
  const state = this._eventState;
  state.mask = mask;
  state.target = target;
  state.currentTarget = currentTarget;
  state.skipNextObservers = false;
  state.userInfo = userInfo;
  this.observers.forEach((obs) => {
    if (state.skipNextObservers) {
      return;
    }
    if (obs._willBeUnregistered) {
      return;
    }
    if (obs.mask & mask) {
      if (obs.scope) {
        p = p.then((lastReturnedValue) => {
          state.lastReturnValue = lastReturnedValue;
          return obs.callback.apply(obs.scope, [eventData, state]);
        });
      } else {
        p = p.then((lastReturnedValue) => {
          state.lastReturnValue = lastReturnedValue;
          return obs.callback(eventData, state);
        });
      }
      if (obs.unregisterOnNextCall) {
        this._deferUnregister(obs);
      }
    }
  });
  await p;
  return eventData;
};

// node_modules/@babylonjs/core/Misc/sceneOptimizer.js
var SceneOptimization = class {
  constructor(priority = 0) {
    this.priority = priority;
  }
  getDescription() {
    return "";
  }
  apply(scene, optimizer) {
    return true;
  }
};
var TextureOptimization = class extends SceneOptimization {
  constructor(priority = 0, maximumSize = 1024, step = 0.5) {
    super(priority);
    this.priority = priority;
    this.maximumSize = maximumSize;
    this.step = step;
  }
  getDescription() {
    return "Reducing render target texture size to " + this.maximumSize;
  }
  apply(scene, optimizer) {
    let allDone = true;
    for (let index = 0; index < scene.textures.length; index++) {
      const texture = scene.textures[index];
      if (!texture.canRescale || texture.getContext) {
        continue;
      }
      const currentSize = texture.getSize();
      const maxDimension = Math.max(currentSize.width, currentSize.height);
      if (maxDimension > this.maximumSize) {
        texture.scale(this.step);
        allDone = false;
      }
    }
    return allDone;
  }
};
var HardwareScalingOptimization = class extends SceneOptimization {
  constructor(priority = 0, maximumScale = 2, step = 0.25) {
    super(priority);
    this.priority = priority;
    this.maximumScale = maximumScale;
    this.step = step;
    this._currentScale = -1;
    this._directionOffset = 1;
  }
  getDescription() {
    return "Setting hardware scaling level to " + this._currentScale;
  }
  apply(scene, optimizer) {
    if (this._currentScale === -1) {
      this._currentScale = scene.getEngine().getHardwareScalingLevel();
      if (this._currentScale > this.maximumScale) {
        this._directionOffset = -1;
      }
    }
    this._currentScale += this._directionOffset * this.step;
    scene.getEngine().setHardwareScalingLevel(this._currentScale);
    return this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;
  }
};
var ShadowsOptimization = class extends SceneOptimization {
  getDescription() {
    return "Turning shadows on/off";
  }
  apply(scene, optimizer) {
    scene.shadowsEnabled = optimizer.isInImprovementMode;
    return true;
  }
};
var PostProcessesOptimization = class extends SceneOptimization {
  getDescription() {
    return "Turning post-processes on/off";
  }
  apply(scene, optimizer) {
    scene.postProcessesEnabled = optimizer.isInImprovementMode;
    return true;
  }
};
var LensFlaresOptimization = class extends SceneOptimization {
  getDescription() {
    return "Turning lens flares on/off";
  }
  apply(scene, optimizer) {
    scene.lensFlaresEnabled = optimizer.isInImprovementMode;
    return true;
  }
};
var CustomOptimization = class extends SceneOptimization {
  getDescription() {
    if (this.onGetDescription) {
      return this.onGetDescription();
    }
    return "Running user defined callback";
  }
  apply(scene, optimizer) {
    if (this.onApply) {
      return this.onApply(scene, optimizer);
    }
    return true;
  }
};
var ParticlesOptimization = class extends SceneOptimization {
  getDescription() {
    return "Turning particles on/off";
  }
  apply(scene, optimizer) {
    scene.particlesEnabled = optimizer.isInImprovementMode;
    return true;
  }
};
var RenderTargetsOptimization = class extends SceneOptimization {
  getDescription() {
    return "Turning render targets off";
  }
  apply(scene, optimizer) {
    scene.renderTargetsEnabled = optimizer.isInImprovementMode;
    return true;
  }
};
var MergeMeshesOptimization = class extends SceneOptimization {
  constructor() {
    super(...arguments);
    this._canBeMerged = (abstractMesh) => {
      if (!(abstractMesh instanceof Mesh)) {
        return false;
      }
      const mesh = abstractMesh;
      if (mesh.isDisposed()) {
        return false;
      }
      if (!mesh.isVisible || !mesh.isEnabled()) {
        return false;
      }
      if (mesh.instances.length > 0) {
        return false;
      }
      if (mesh.skeleton || mesh.hasLODLevels) {
        return false;
      }
      return true;
    };
  }
  static get UpdateSelectionTree() {
    return MergeMeshesOptimization._UpdateSelectionTree;
  }
  static set UpdateSelectionTree(value) {
    MergeMeshesOptimization._UpdateSelectionTree = value;
  }
  getDescription() {
    return "Merging similar meshes together";
  }
  apply(scene, optimizer, updateSelectionTree) {
    const globalPool = scene.meshes.slice(0);
    let globalLength = globalPool.length;
    for (let index = 0; index < globalLength; index++) {
      const currentPool = new Array();
      const current = globalPool[index];
      if (!this._canBeMerged(current)) {
        continue;
      }
      currentPool.push(current);
      for (let subIndex = index + 1; subIndex < globalLength; subIndex++) {
        const otherMesh = globalPool[subIndex];
        if (!this._canBeMerged(otherMesh)) {
          continue;
        }
        if (otherMesh.material !== current.material) {
          continue;
        }
        if (otherMesh.checkCollisions !== current.checkCollisions) {
          continue;
        }
        currentPool.push(otherMesh);
        globalLength--;
        globalPool.splice(subIndex, 1);
        subIndex--;
      }
      if (currentPool.length < 2) {
        continue;
      }
      Mesh.MergeMeshes(currentPool, void 0, true);
    }
    const sceneAsAny = scene;
    if (sceneAsAny.createOrUpdateSelectionOctree) {
      if (updateSelectionTree != void 0) {
        if (updateSelectionTree) {
          sceneAsAny.createOrUpdateSelectionOctree();
        }
      } else if (MergeMeshesOptimization.UpdateSelectionTree) {
        sceneAsAny.createOrUpdateSelectionOctree();
      }
    }
    return true;
  }
};
MergeMeshesOptimization._UpdateSelectionTree = false;
var SceneOptimizerOptions = class {
  constructor(targetFrameRate = 60, trackerDuration = 2e3) {
    this.targetFrameRate = targetFrameRate;
    this.trackerDuration = trackerDuration;
    this.optimizations = new Array();
  }
  addOptimization(optimization) {
    this.optimizations.push(optimization);
    return this;
  }
  addCustomOptimization(onApply, onGetDescription, priority = 0) {
    const optimization = new CustomOptimization(priority);
    optimization.onApply = onApply;
    optimization.onGetDescription = onGetDescription;
    this.optimizations.push(optimization);
    return this;
  }
  static LowDegradationAllowed(targetFrameRate) {
    const result = new SceneOptimizerOptions(targetFrameRate);
    let priority = 0;
    result.addOptimization(new MergeMeshesOptimization(priority));
    result.addOptimization(new ShadowsOptimization(priority));
    result.addOptimization(new LensFlaresOptimization(priority));
    priority++;
    result.addOptimization(new PostProcessesOptimization(priority));
    result.addOptimization(new ParticlesOptimization(priority));
    priority++;
    result.addOptimization(new TextureOptimization(priority, 1024));
    return result;
  }
  static ModerateDegradationAllowed(targetFrameRate) {
    const result = new SceneOptimizerOptions(targetFrameRate);
    let priority = 0;
    result.addOptimization(new MergeMeshesOptimization(priority));
    result.addOptimization(new ShadowsOptimization(priority));
    result.addOptimization(new LensFlaresOptimization(priority));
    priority++;
    result.addOptimization(new PostProcessesOptimization(priority));
    result.addOptimization(new ParticlesOptimization(priority));
    priority++;
    result.addOptimization(new TextureOptimization(priority, 512));
    priority++;
    result.addOptimization(new RenderTargetsOptimization(priority));
    priority++;
    result.addOptimization(new HardwareScalingOptimization(priority, 2));
    return result;
  }
  static HighDegradationAllowed(targetFrameRate) {
    const result = new SceneOptimizerOptions(targetFrameRate);
    let priority = 0;
    result.addOptimization(new MergeMeshesOptimization(priority));
    result.addOptimization(new ShadowsOptimization(priority));
    result.addOptimization(new LensFlaresOptimization(priority));
    priority++;
    result.addOptimization(new PostProcessesOptimization(priority));
    result.addOptimization(new ParticlesOptimization(priority));
    priority++;
    result.addOptimization(new TextureOptimization(priority, 256));
    priority++;
    result.addOptimization(new RenderTargetsOptimization(priority));
    priority++;
    result.addOptimization(new HardwareScalingOptimization(priority, 4));
    return result;
  }
};
var SceneOptimizer = class {
  constructor(scene, options, autoGeneratePriorities = true, improvementMode = false) {
    this._isRunning = false;
    this._currentPriorityLevel = 0;
    this._targetFrameRate = 60;
    this._trackerDuration = 2e3;
    this._currentFrameRate = 0;
    this._improvementMode = false;
    this.onSuccessObservable = new Observable();
    this.onNewOptimizationAppliedObservable = new Observable();
    this.onFailureObservable = new Observable();
    if (!options) {
      this._options = new SceneOptimizerOptions();
    } else {
      this._options = options;
    }
    if (this._options.targetFrameRate) {
      this._targetFrameRate = this._options.targetFrameRate;
    }
    if (this._options.trackerDuration) {
      this._trackerDuration = this._options.trackerDuration;
    }
    if (autoGeneratePriorities) {
      let priority = 0;
      for (const optim of this._options.optimizations) {
        optim.priority = priority++;
      }
    }
    this._improvementMode = improvementMode;
    this._scene = scene || EngineStore.LastCreatedScene;
    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {
      this._sceneDisposeObserver = null;
      this.dispose();
    });
  }
  get isInImprovementMode() {
    return this._improvementMode;
  }
  set isInImprovementMode(value) {
    this._improvementMode = value;
  }
  get currentPriorityLevel() {
    return this._currentPriorityLevel;
  }
  get currentFrameRate() {
    return this._currentFrameRate;
  }
  get targetFrameRate() {
    return this._targetFrameRate;
  }
  set targetFrameRate(value) {
    this._targetFrameRate = value;
  }
  get trackerDuration() {
    return this._trackerDuration;
  }
  set trackerDuration(value) {
    this._trackerDuration = value;
  }
  get optimizations() {
    return this._options.optimizations;
  }
  stop() {
    this._isRunning = false;
  }
  reset() {
    this._currentPriorityLevel = 0;
  }
  start() {
    if (this._isRunning) {
      return;
    }
    this._isRunning = true;
    this._scene.executeWhenReady(() => {
      setTimeout(() => {
        this._checkCurrentState();
      }, this._trackerDuration);
    });
  }
  _checkCurrentState() {
    if (!this._isRunning) {
      return;
    }
    const scene = this._scene;
    const options = this._options;
    this._currentFrameRate = Math.round(scene.getEngine().getFps());
    if (this._improvementMode && this._currentFrameRate <= this._targetFrameRate || !this._improvementMode && this._currentFrameRate >= this._targetFrameRate) {
      this._isRunning = false;
      this.onSuccessObservable.notifyObservers(this);
      return;
    }
    let allDone = true;
    let noOptimizationApplied = true;
    for (let index = 0; index < options.optimizations.length; index++) {
      const optimization = options.optimizations[index];
      if (optimization.priority === this._currentPriorityLevel) {
        noOptimizationApplied = false;
        allDone = allDone && optimization.apply(scene, this);
        this.onNewOptimizationAppliedObservable.notifyObservers(optimization);
      }
    }
    if (noOptimizationApplied) {
      this._isRunning = false;
      this.onFailureObservable.notifyObservers(this);
      return;
    }
    if (allDone) {
      this._currentPriorityLevel++;
    }
    scene.executeWhenReady(() => {
      setTimeout(() => {
        this._checkCurrentState();
      }, this._trackerDuration);
    });
  }
  dispose() {
    this.stop();
    this.onSuccessObservable.clear();
    this.onFailureObservable.clear();
    this.onNewOptimizationAppliedObservable.clear();
    if (this._sceneDisposeObserver) {
      this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);
    }
  }
  static OptimizeAsync(scene, options, onSuccess, onFailure) {
    const optimizer = new SceneOptimizer(scene, options || SceneOptimizerOptions.ModerateDegradationAllowed(), false);
    if (onSuccess) {
      optimizer.onSuccessObservable.add(() => {
        onSuccess();
      });
    }
    if (onFailure) {
      optimizer.onFailureObservable.add(() => {
        onFailure();
      });
    }
    optimizer.start();
    return optimizer;
  }
};

// node_modules/@babylonjs/core/Misc/sceneSerializer.js
var serializedGeometries = [];
var SerializeGeometry = (geometry, serializationGeometries) => {
  if (geometry.doNotSerialize) {
    return;
  }
  serializationGeometries.vertexData.push(geometry.serializeVerticeData());
  serializedGeometries[geometry.id] = true;
};
var SerializeMesh = (mesh, serializationScene) => {
  const serializationObject = {};
  const geometry = mesh._geometry;
  if (geometry) {
    if (!mesh.getScene().getGeometryById(geometry.id)) {
      SerializeGeometry(geometry, serializationScene.geometries);
    }
  }
  if (mesh.serialize) {
    mesh.serialize(serializationObject);
  }
  return serializationObject;
};
var FinalizeSingleMesh = (mesh, serializationObject) => {
  if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {
    const serializeMaterial = (material) => {
      serializationObject.materials = serializationObject.materials || [];
      if (mesh.material && !serializationObject.materials.some((mat) => mat.id === mesh.material.id)) {
        serializationObject.materials.push(material.serialize());
      }
    };
    if (mesh.material && !mesh.material.doNotSerialize) {
      if (mesh.material instanceof MultiMaterial) {
        serializationObject.multiMaterials = serializationObject.multiMaterials || [];
        if (!serializationObject.multiMaterials.some((mat) => mat.id === mesh.material.id)) {
          serializationObject.multiMaterials.push(mesh.material.serialize());
          for (const submaterial of mesh.material.subMaterials) {
            if (submaterial) {
              serializeMaterial(submaterial);
            }
          }
        }
      } else {
        serializeMaterial(mesh.material);
      }
    } else if (!mesh.material) {
      serializeMaterial(mesh.getScene().defaultMaterial);
    }
    const geometry = mesh._geometry;
    if (geometry) {
      if (!serializationObject.geometries) {
        serializationObject.geometries = {};
        serializationObject.geometries.boxes = [];
        serializationObject.geometries.spheres = [];
        serializationObject.geometries.cylinders = [];
        serializationObject.geometries.toruses = [];
        serializationObject.geometries.grounds = [];
        serializationObject.geometries.planes = [];
        serializationObject.geometries.torusKnots = [];
        serializationObject.geometries.vertexData = [];
      }
      SerializeGeometry(geometry, serializationObject.geometries);
    }
    if (mesh.skeleton && !mesh.skeleton.doNotSerialize) {
      serializationObject.skeletons = serializationObject.skeletons || [];
      serializationObject.skeletons.push(mesh.skeleton.serialize());
    }
    serializationObject.meshes = serializationObject.meshes || [];
    serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));
  }
};
var SceneSerializer = class {
  static ClearCache() {
    serializedGeometries = [];
  }
  static Serialize(scene) {
    return SceneSerializer._Serialize(scene);
  }
  static _Serialize(scene, checkSyncReadSupported = true) {
    const serializationObject = {};
    if (checkSyncReadSupported && !scene.getEngine()._features.supportSyncTextureRead && Texture.ForceSerializeBuffers) {
      console.warn("The serialization object may not contain the proper base64 encoded texture data! You should use the SerializeAsync method instead.");
    }
    SceneSerializer.ClearCache();
    serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;
    serializationObject.autoClear = scene.autoClear;
    serializationObject.clearColor = scene.clearColor.asArray();
    serializationObject.ambientColor = scene.ambientColor.asArray();
    serializationObject.gravity = scene.gravity.asArray();
    serializationObject.collisionsEnabled = scene.collisionsEnabled;
    serializationObject.useRightHandedSystem = scene.useRightHandedSystem;
    if (scene.fogMode && scene.fogMode !== 0) {
      serializationObject.fogMode = scene.fogMode;
      serializationObject.fogColor = scene.fogColor.asArray();
      serializationObject.fogStart = scene.fogStart;
      serializationObject.fogEnd = scene.fogEnd;
      serializationObject.fogDensity = scene.fogDensity;
    }
    if (scene.isPhysicsEnabled()) {
      const physicEngine = scene.getPhysicsEngine();
      if (physicEngine) {
        serializationObject.physicsEnabled = true;
        serializationObject.physicsGravity = physicEngine.gravity.asArray();
        serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();
      }
    }
    if (scene.metadata) {
      serializationObject.metadata = scene.metadata;
    }
    serializationObject.morphTargetManagers = [];
    for (const abstractMesh of scene.meshes) {
      const manager = abstractMesh.morphTargetManager;
      if (manager) {
        serializationObject.morphTargetManagers.push(manager.serialize());
      }
    }
    serializationObject.lights = [];
    let index;
    let light;
    for (index = 0; index < scene.lights.length; index++) {
      light = scene.lights[index];
      if (!light.doNotSerialize) {
        serializationObject.lights.push(light.serialize());
      }
    }
    serializationObject.cameras = [];
    for (index = 0; index < scene.cameras.length; index++) {
      const camera = scene.cameras[index];
      if (!camera.doNotSerialize) {
        serializationObject.cameras.push(camera.serialize());
      }
    }
    if (scene.activeCamera) {
      serializationObject.activeCameraID = scene.activeCamera.id;
    }
    SerializationHelper.AppendSerializedAnimations(scene, serializationObject);
    if (scene.animationGroups && scene.animationGroups.length > 0) {
      serializationObject.animationGroups = [];
      for (let animationGroupIndex = 0; animationGroupIndex < scene.animationGroups.length; animationGroupIndex++) {
        const animationGroup = scene.animationGroups[animationGroupIndex];
        serializationObject.animationGroups.push(animationGroup.serialize());
      }
    }
    if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {
      serializationObject.reflectionProbes = [];
      for (index = 0; index < scene.reflectionProbes.length; index++) {
        const reflectionProbe = scene.reflectionProbes[index];
        serializationObject.reflectionProbes.push(reflectionProbe.serialize());
      }
    }
    serializationObject.materials = [];
    serializationObject.multiMaterials = [];
    let material;
    for (index = 0; index < scene.materials.length; index++) {
      material = scene.materials[index];
      if (!material.doNotSerialize) {
        serializationObject.materials.push(material.serialize());
      }
    }
    serializationObject.multiMaterials = [];
    for (index = 0; index < scene.multiMaterials.length; index++) {
      const multiMaterial = scene.multiMaterials[index];
      serializationObject.multiMaterials.push(multiMaterial.serialize());
    }
    if (scene.environmentTexture) {
      if (scene.environmentTexture._files) {
        serializationObject.environmentTexture = scene.environmentTexture.serialize();
      } else {
        serializationObject.environmentTexture = scene.environmentTexture.name;
        serializationObject.environmentTextureRotationY = scene.environmentTexture.rotationY;
      }
    }
    serializationObject.environmentIntensity = scene.environmentIntensity;
    serializationObject.skeletons = [];
    for (index = 0; index < scene.skeletons.length; index++) {
      const skeleton = scene.skeletons[index];
      if (!skeleton.doNotSerialize) {
        serializationObject.skeletons.push(skeleton.serialize());
      }
    }
    serializationObject.transformNodes = [];
    for (index = 0; index < scene.transformNodes.length; index++) {
      if (!scene.transformNodes[index].doNotSerialize) {
        serializationObject.transformNodes.push(scene.transformNodes[index].serialize());
      }
    }
    serializationObject.geometries = {};
    serializationObject.geometries.boxes = [];
    serializationObject.geometries.spheres = [];
    serializationObject.geometries.cylinders = [];
    serializationObject.geometries.toruses = [];
    serializationObject.geometries.grounds = [];
    serializationObject.geometries.planes = [];
    serializationObject.geometries.torusKnots = [];
    serializationObject.geometries.vertexData = [];
    serializedGeometries = [];
    const geometries = scene.getGeometries();
    for (index = 0; index < geometries.length; index++) {
      const geometry = geometries[index];
      if (geometry.isReady()) {
        SerializeGeometry(geometry, serializationObject.geometries);
      }
    }
    serializationObject.meshes = [];
    for (index = 0; index < scene.meshes.length; index++) {
      const abstractMesh = scene.meshes[index];
      if (abstractMesh instanceof Mesh) {
        const mesh = abstractMesh;
        if (!mesh.doNotSerialize) {
          if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {
            serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));
          }
        }
      }
    }
    serializationObject.particleSystems = [];
    for (index = 0; index < scene.particleSystems.length; index++) {
      serializationObject.particleSystems.push(scene.particleSystems[index].serialize(false));
    }
    serializationObject.postProcesses = [];
    for (index = 0; index < scene.postProcesses.length; index++) {
      serializationObject.postProcesses.push(scene.postProcesses[index].serialize());
    }
    if (scene.actionManager) {
      serializationObject.actions = scene.actionManager.serialize("scene");
    }
    for (const component of scene._serializableComponents) {
      component.serialize(serializationObject);
    }
    return serializationObject;
  }
  static SerializeAsync(scene) {
    const serializationObject = SceneSerializer._Serialize(scene, false);
    const promises = [];
    this._CollectPromises(serializationObject, promises);
    return Promise.all(promises).then(() => serializationObject);
  }
  static _CollectPromises(obj, promises) {
    if (Array.isArray(obj)) {
      for (let i = 0; i < obj.length; ++i) {
        const o = obj[i];
        if (o instanceof Promise) {
          promises.push(o.then((res) => obj[i] = res));
        } else if (o instanceof Object || Array.isArray(o)) {
          this._CollectPromises(o, promises);
        }
      }
    } else if (obj instanceof Object) {
      for (const name137 in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, name137)) {
          const o = obj[name137];
          if (o instanceof Promise) {
            promises.push(o.then((res) => obj[name137] = res));
          } else if (o instanceof Object || Array.isArray(o)) {
            this._CollectPromises(o, promises);
          }
        }
      }
    }
  }
  static SerializeMesh(toSerialize, withParents = false, withChildren = false) {
    const serializationObject = {};
    SceneSerializer.ClearCache();
    toSerialize = toSerialize instanceof Array ? toSerialize : [toSerialize];
    if (withParents || withChildren) {
      for (let i = 0; i < toSerialize.length; ++i) {
        if (withChildren) {
          toSerialize[i].getDescendants().forEach((node) => {
            if (node instanceof Mesh && toSerialize.indexOf(node) < 0 && !node.doNotSerialize) {
              toSerialize.push(node);
            }
          });
        }
        if (withParents && toSerialize[i].parent && toSerialize.indexOf(toSerialize[i].parent) < 0 && !toSerialize[i].parent.doNotSerialize) {
          toSerialize.push(toSerialize[i].parent);
        }
      }
    }
    toSerialize.forEach((mesh) => {
      FinalizeSingleMesh(mesh, serializationObject);
    });
    return serializationObject;
  }
};

// node_modules/@babylonjs/core/Misc/videoRecorder.js
var VideoRecorder = class {
  constructor(engine, options = {}) {
    if (!VideoRecorder.IsSupported(engine)) {
      throw "Your browser does not support recording so far.";
    }
    const canvas = engine.getRenderingCanvas();
    if (!canvas) {
      throw "The babylon engine must have a canvas to be recorded";
    }
    this._canvas = canvas;
    this._canvas.isRecording = false;
    this._options = {
      ...VideoRecorder._DefaultOptions,
      ...options
    };
    const stream = this._canvas.captureStream(this._options.fps);
    if (this._options.audioTracks) {
      for (const track of this._options.audioTracks) {
        stream.addTrack(track);
      }
    }
    this._mediaRecorder = new MediaRecorder(stream, { mimeType: this._options.mimeType });
    this._mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this);
    this._mediaRecorder.onerror = this._handleError.bind(this);
    this._mediaRecorder.onstop = this._handleStop.bind(this);
  }
  static IsSupported(engine) {
    const canvas = engine.getRenderingCanvas();
    return !!canvas && typeof canvas.captureStream === "function";
  }
  get isRecording() {
    return !!this._canvas && this._canvas.isRecording;
  }
  stopRecording() {
    if (!this._canvas || !this._mediaRecorder) {
      return;
    }
    if (!this.isRecording) {
      return;
    }
    this._canvas.isRecording = false;
    this._mediaRecorder.stop();
  }
  startRecording(fileName = "babylonjs.webm", maxDuration = 7) {
    if (!this._canvas || !this._mediaRecorder) {
      throw "Recorder has already been disposed";
    }
    if (this.isRecording) {
      throw "Recording already in progress";
    }
    if (maxDuration > 0) {
      setTimeout(() => {
        this.stopRecording();
      }, maxDuration * 1e3);
    }
    this._fileName = fileName;
    this._recordedChunks = [];
    this._resolve = null;
    this._reject = null;
    this._canvas.isRecording = true;
    this._mediaRecorder.start(this._options.recordChunckSize);
    return new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
  dispose() {
    this._canvas = null;
    this._mediaRecorder = null;
    this._recordedChunks = [];
    this._fileName = null;
    this._resolve = null;
    this._reject = null;
  }
  _handleDataAvailable(event) {
    if (event.data.size > 0) {
      this._recordedChunks.push(event.data);
    }
  }
  _handleError(event) {
    this.stopRecording();
    if (this._reject) {
      this._reject(event.error);
    } else {
      throw new event.error();
    }
  }
  _handleStop() {
    this.stopRecording();
    const superBuffer = new Blob(this._recordedChunks);
    if (this._resolve) {
      this._resolve(superBuffer);
    }
    window.URL.createObjectURL(superBuffer);
    if (this._fileName) {
      Tools.Download(superBuffer, this._fileName);
    }
  }
};
VideoRecorder._DefaultOptions = {
  mimeType: "video/webm",
  fps: 25,
  recordChunckSize: 3e3
};

// node_modules/@babylonjs/core/Misc/screenshotTools.js
var screenshotCanvas = null;
function CreateScreenshot(engine, camera, size, successCallback, mimeType = "image/png", forceDownload = false) {
  const { height, width } = _GetScreenshotSize(engine, camera, size);
  if (!(height && width)) {
    Logger.Error("Invalid 'size' parameter !");
    return;
  }
  if (!screenshotCanvas) {
    screenshotCanvas = document.createElement("canvas");
  }
  screenshotCanvas.width = width;
  screenshotCanvas.height = height;
  const renderContext = screenshotCanvas.getContext("2d");
  const ratio = engine.getRenderWidth() / engine.getRenderHeight();
  let newWidth = width;
  let newHeight = newWidth / ratio;
  if (newHeight > height) {
    newHeight = height;
    newWidth = newHeight * ratio;
  }
  const offsetX = Math.max(0, width - newWidth) / 2;
  const offsetY = Math.max(0, height - newHeight) / 2;
  const scene = camera.getScene();
  if (scene.activeCamera !== camera) {
    CreateScreenshotUsingRenderTarget(engine, camera, size, (data) => {
      if (forceDownload) {
        const blob = new Blob([data]);
        Tools.DownloadBlob(blob);
        if (successCallback) {
          successCallback("");
        }
      } else if (successCallback) {
        successCallback(data);
      }
    }, mimeType, 1, engine.getCreationOptions().antialias);
  } else {
    engine.onEndFrameObservable.addOnce(() => {
      const renderingCanvas = engine.getRenderingCanvas();
      if (renderContext && renderingCanvas) {
        renderContext.drawImage(renderingCanvas, offsetX, offsetY, newWidth, newHeight);
      }
      if (screenshotCanvas) {
        if (forceDownload) {
          Tools.EncodeScreenshotCanvasData(screenshotCanvas, void 0, mimeType);
          if (successCallback) {
            successCallback("");
          }
        } else {
          Tools.EncodeScreenshotCanvasData(screenshotCanvas, successCallback, mimeType);
        }
      }
    });
  }
}
function CreateScreenshotAsync(engine, camera, size, mimeType = "image/png") {
  return new Promise((resolve, reject) => {
    CreateScreenshot(engine, camera, size, (data) => {
      if (typeof data !== "undefined") {
        resolve(data);
      } else {
        reject(new Error("Data is undefined"));
      }
    }, mimeType);
  });
}
function CreateScreenshotWithResizeAsync(engine, camera, width, height, mimeType = "image/png") {
  return new Promise((resolve) => {
    CreateScreenshot(engine, camera, { width, height }, () => {
      resolve();
    }, mimeType, true);
  });
}
function CreateScreenshotUsingRenderTarget(engine, camera, size, successCallback, mimeType = "image/png", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true) {
  const { height, width } = _GetScreenshotSize(engine, camera, size);
  const targetTextureSize = { width, height };
  if (!(height && width)) {
    Logger.Error("Invalid 'size' parameter !");
    return;
  }
  const originalSize = { width: engine.getRenderWidth(), height: engine.getRenderHeight() };
  engine.setSize(width, height);
  const scene = camera.getScene();
  const texture = new RenderTargetTexture("screenShot", targetTextureSize, scene, false, false, 0, false, Texture.NEAREST_SAMPLINGMODE, void 0, enableStencilBuffer, void 0, void 0, void 0, samples);
  texture.renderList = scene.meshes.slice();
  texture.samples = samples;
  texture.renderSprites = renderSprites;
  texture.activeCamera = camera;
  texture.forceLayerMaskCheck = useLayerMask;
  const renderToTexture = () => {
    engine.onEndFrameObservable.addOnce(() => {
      texture.readPixels(void 0, void 0, void 0, false).then((data) => {
        DumpTools.DumpData(width, height, data, successCallback, mimeType, fileName, true);
        texture.dispose();
      });
    });
    scene.incrementRenderId();
    scene.resetCachedMaterial();
    texture.render(true);
    scene.incrementRenderId();
    scene.resetCachedMaterial();
    engine.setSize(originalSize.width, originalSize.height);
    camera.getProjectionMatrix(true);
    scene.render();
  };
  if (antialiasing) {
    const fxaaPostProcess = new FxaaPostProcess("antialiasing", 1, scene.activeCamera);
    texture.addPostProcess(fxaaPostProcess);
    if (!fxaaPostProcess.getEffect().isReady()) {
      fxaaPostProcess.getEffect().onCompiled = () => {
        renderToTexture();
      };
    } else {
      renderToTexture();
    }
  } else {
    renderToTexture();
  }
}
function CreateScreenshotUsingRenderTargetAsync(engine, camera, size, mimeType = "image/png", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true) {
  return new Promise((resolve, reject) => {
    CreateScreenshotUsingRenderTarget(engine, camera, size, (data) => {
      if (typeof data !== "undefined") {
        resolve(data);
      } else {
        reject(new Error("Data is undefined"));
      }
    }, mimeType, samples, antialiasing, fileName, renderSprites, enableStencilBuffer, useLayerMask);
  });
}
function _GetScreenshotSize(engine, camera, size) {
  let height = 0;
  let width = 0;
  if (typeof size === "object") {
    const precision = size.precision ? Math.abs(size.precision) : 1;
    if (size.width && size.height) {
      height = size.height * precision;
      width = size.width * precision;
    } else if (size.width && !size.height) {
      width = size.width * precision;
      height = Math.round(width / engine.getAspectRatio(camera));
    } else if (size.height && !size.width) {
      height = size.height * precision;
      width = Math.round(height * engine.getAspectRatio(camera));
    } else {
      width = Math.round(engine.getRenderWidth() * precision);
      height = Math.round(width / engine.getAspectRatio(camera));
    }
  } else if (!isNaN(size)) {
    height = size;
    width = size;
  }
  if (width) {
    width = Math.floor(width);
  }
  if (height) {
    height = Math.floor(height);
  }
  return { height: height | 0, width: width | 0 };
}
var ScreenshotTools = {
  CreateScreenshot,
  CreateScreenshotAsync,
  CreateScreenshotWithResizeAsync,
  CreateScreenshotUsingRenderTarget,
  CreateScreenshotUsingRenderTargetAsync
};
var initSideEffects = () => {
  Tools.CreateScreenshot = CreateScreenshot;
  Tools.CreateScreenshotAsync = CreateScreenshotAsync;
  Tools.CreateScreenshotUsingRenderTarget = CreateScreenshotUsingRenderTarget;
  Tools.CreateScreenshotUsingRenderTargetAsync = CreateScreenshotUsingRenderTargetAsync;
};
initSideEffects();

// node_modules/@babylonjs/core/Misc/iInspectable.js
var InspectableType;
(function(InspectableType2) {
  InspectableType2[InspectableType2["Checkbox"] = 0] = "Checkbox";
  InspectableType2[InspectableType2["Slider"] = 1] = "Slider";
  InspectableType2[InspectableType2["Vector3"] = 2] = "Vector3";
  InspectableType2[InspectableType2["Quaternion"] = 3] = "Quaternion";
  InspectableType2[InspectableType2["Color3"] = 4] = "Color3";
  InspectableType2[InspectableType2["String"] = 5] = "String";
  InspectableType2[InspectableType2["Button"] = 6] = "Button";
  InspectableType2[InspectableType2["Options"] = 7] = "Options";
  InspectableType2[InspectableType2["Tab"] = 8] = "Tab";
  InspectableType2[InspectableType2["FileButton"] = 9] = "FileButton";
  InspectableType2[InspectableType2["Vector2"] = 10] = "Vector2";
})(InspectableType || (InspectableType = {}));

// node_modules/@babylonjs/core/Misc/dataStorage.js
var DataStorage = class {
  static _GetStorage() {
    try {
      localStorage.setItem("test", "");
      localStorage.removeItem("test");
      return localStorage;
    } catch (_a) {
      const inMemoryStorage = {};
      return {
        getItem: (key) => {
          const value = inMemoryStorage[key];
          return value === void 0 ? null : value;
        },
        setItem: (key, value) => {
          inMemoryStorage[key] = value;
        }
      };
    }
  }
  static ReadString(key, defaultValue) {
    const value = this._Storage.getItem(key);
    return value !== null ? value : defaultValue;
  }
  static WriteString(key, value) {
    this._Storage.setItem(key, value);
  }
  static ReadBoolean(key, defaultValue) {
    const value = this._Storage.getItem(key);
    return value !== null ? value === "true" : defaultValue;
  }
  static WriteBoolean(key, value) {
    this._Storage.setItem(key, value ? "true" : "false");
  }
  static ReadNumber(key, defaultValue) {
    const value = this._Storage.getItem(key);
    return value !== null ? parseFloat(value) : defaultValue;
  }
  static WriteNumber(key, value) {
    this._Storage.setItem(key, value.toString());
  }
};
DataStorage._Storage = DataStorage._GetStorage();

// node_modules/@babylonjs/core/Misc/sceneRecorder.js
var SceneRecorder = class {
  constructor() {
    this._trackedScene = null;
  }
  track(scene) {
    this._trackedScene = scene;
    SerializationHelper.AllowLoadingUniqueId = true;
    this._savedJSON = SceneSerializer.Serialize(scene);
    SerializationHelper.AllowLoadingUniqueId = false;
  }
  getDelta() {
    if (!this._trackedScene) {
      return null;
    }
    const currentForceSerializeBuffers = Texture.ForceSerializeBuffers;
    Texture.ForceSerializeBuffers = false;
    SerializationHelper.AllowLoadingUniqueId = true;
    const newJSON = SceneSerializer.Serialize(this._trackedScene);
    SerializationHelper.AllowLoadingUniqueId = false;
    const deltaJSON = {};
    for (const node in newJSON) {
      this._compareCollections(node, this._savedJSON[node], newJSON[node], deltaJSON);
    }
    Texture.ForceSerializeBuffers = currentForceSerializeBuffers;
    return deltaJSON;
  }
  _compareArray(key, original, current, deltaJSON) {
    if (original.length === 0 && current.length === 0) {
      return true;
    }
    if (original.length && !isNaN(original[0]) || current.length && !isNaN(current[0])) {
      if (original.length !== current.length) {
        return false;
      }
      if (original.length === 0) {
        return true;
      }
      for (let index = 0; index < original.length; index++) {
        if (original[index] !== current[index]) {
          deltaJSON[key] = current;
          return false;
        }
      }
      return true;
    }
    const originalUniqueIds = [];
    for (let index = 0; index < original.length; index++) {
      const originalObject = original[index];
      const originalUniqueId = originalObject.uniqueId;
      originalUniqueIds.push(originalUniqueId);
      const currentObjects = current.filter((c) => c.uniqueId === originalUniqueId);
      if (currentObjects.length) {
        const currentObject = currentObjects[0];
        const newObject = {};
        if (!this._compareObjects(originalObject, currentObject, newObject)) {
          if (!deltaJSON[key]) {
            deltaJSON[key] = [];
          }
          newObject.__state = {
            id: currentObject.id || currentObject.name
          };
          deltaJSON[key].push(newObject);
        }
      } else {
        const newObject = {
          __state: {
            deleteId: originalObject.id || originalObject.name
          }
        };
        deltaJSON[key].push(newObject);
      }
    }
    for (let index = 0; index < current.length; index++) {
      const currentObject = current[index];
      const currentUniqueId = currentObject.uniqueId;
      if (originalUniqueIds.indexOf(currentUniqueId) === -1) {
        if (!deltaJSON[key]) {
          deltaJSON[key] = [];
        }
        deltaJSON[key].push(currentObject);
      }
    }
    return true;
  }
  _compareObjects(originalObjet, currentObject, deltaJSON) {
    let aDifferenceWasFound = false;
    for (const prop in originalObjet) {
      if (!Object.prototype.hasOwnProperty.call(originalObjet, prop)) {
        continue;
      }
      const originalValue = originalObjet[prop];
      const currentValue = currentObject[prop];
      let diffFound = false;
      if (Array.isArray(originalValue)) {
        diffFound = JSON.stringify(originalValue) !== JSON.stringify(currentValue);
      } else if (!isNaN(originalValue) || Object.prototype.toString.call(originalValue) == "[object String]") {
        diffFound = originalValue !== currentValue;
      } else if (typeof originalValue === "object" && typeof currentValue === "object") {
        const newObject = {};
        if (!this._compareObjects(originalValue, currentValue, newObject)) {
          deltaJSON[prop] = newObject;
          aDifferenceWasFound = true;
        }
      }
      if (diffFound) {
        aDifferenceWasFound = true;
        deltaJSON[prop] = currentValue;
      }
    }
    return !aDifferenceWasFound;
  }
  _compareCollections(key, original, current, deltaJSON) {
    if (original === current) {
      return;
    }
    if (original && current) {
      if (Array.isArray(original) && Array.isArray(current)) {
        if (this._compareArray(key, original, current, deltaJSON)) {
          return;
        }
      } else if (typeof original === "object" && typeof current === "object") {
        const newObject = {};
        if (!this._compareObjects(original, current, newObject)) {
          deltaJSON[key] = newObject;
        }
        return;
      }
    }
  }
  static GetShadowGeneratorById(scene, id) {
    const allGenerators = scene.lights.map((l) => l.getShadowGenerators());
    for (const generators of allGenerators) {
      if (generators) {
        const iterator = generators.values();
        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
          const generator = key.value;
          if (generator && generator.id === id) {
            return generator;
          }
        }
      }
    }
    return null;
  }
  static ApplyDelta(deltaJSON, scene) {
    if (typeof deltaJSON === "string") {
      deltaJSON = JSON.parse(deltaJSON);
    }
    const anyScene = scene;
    for (const prop in deltaJSON) {
      const source = deltaJSON[prop];
      const property = anyScene[prop];
      if (Array.isArray(property) || prop === "shadowGenerators") {
        switch (prop) {
          case "cameras":
            this._ApplyDeltaForEntity(source, scene, scene.getCameraById.bind(scene), (data) => Camera.Parse(data, scene));
            break;
          case "lights":
            this._ApplyDeltaForEntity(source, scene, scene.getLightById.bind(scene), (data) => Light.Parse(data, scene));
            break;
          case "shadowGenerators":
            this._ApplyDeltaForEntity(source, scene, (id) => this.GetShadowGeneratorById(scene, id), (data) => ShadowGenerator.Parse(data, scene));
            break;
          case "meshes":
            this._ApplyDeltaForEntity(source, scene, scene.getMeshById.bind(scene), (data) => Mesh.Parse(data, scene, ""));
            break;
          case "skeletons":
            this._ApplyDeltaForEntity(source, scene, scene.getSkeletonById.bind(scene), (data) => Skeleton.Parse(data, scene));
            break;
          case "materials":
            this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), (data) => Material.Parse(data, scene, ""));
            break;
          case "multiMaterials":
            this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), (data) => MultiMaterial.Parse(data, scene, ""));
            break;
          case "transformNodes":
            this._ApplyDeltaForEntity(source, scene, scene.getTransformNodeById.bind(scene), (data) => TransformNode.Parse(data, scene, ""));
            break;
          case "particleSystems":
            this._ApplyDeltaForEntity(source, scene, scene.getParticleSystemById.bind(scene), (data) => ParticleSystem.Parse(data, scene, ""));
            break;
          case "morphTargetManagers":
            this._ApplyDeltaForEntity(source, scene, scene.getMorphTargetById.bind(scene), (data) => MorphTargetManager.Parse(data, scene));
            break;
          case "postProcesses":
            this._ApplyDeltaForEntity(source, scene, scene.getPostProcessByName.bind(scene), (data) => PostProcess.Parse(data, scene, ""));
            break;
        }
      } else if (!isNaN(property)) {
        anyScene[prop] = source;
      } else if (property.fromArray) {
        property.fromArray(source);
      }
    }
  }
  static _ApplyPropertiesToEntity(deltaJSON, entity) {
    for (const prop in deltaJSON) {
      const source = deltaJSON[prop];
      const property = entity[prop];
      if (property === void 0) {
        continue;
      }
      if (!isNaN(property) || Array.isArray(property)) {
        entity[prop] = source;
      } else if (property.fromArray) {
        property.fromArray(source);
      } else if (typeof property === "object" && property !== null) {
        this._ApplyPropertiesToEntity(source, property);
      }
    }
  }
  static _ApplyDeltaForEntity(sources, scene, finder, addNew) {
    for (const source of sources) {
      if (source.__state && source.__state.id !== void 0) {
        const targetEntity = finder(source.__state.id);
        if (targetEntity) {
          this._ApplyPropertiesToEntity(source, targetEntity);
        }
      } else if (source.__state && source.__state.deleteId !== void 0) {
        const target = finder(source.__state.deleteId);
        target === null || target === void 0 ? void 0 : target.dispose();
      } else {
        addNew(source);
      }
    }
  }
};

// node_modules/@babylonjs/core/Misc/trajectoryClassifier.js
var Levenshtein;
(function(Levenshtein2) {
  class Alphabet {
    constructor(characters, charToInsertionCost = null, charToDeletionCost = null, charsToSubstitutionCost = null) {
      charToInsertionCost = charToInsertionCost !== null && charToInsertionCost !== void 0 ? charToInsertionCost : () => 1;
      charToDeletionCost = charToDeletionCost !== null && charToDeletionCost !== void 0 ? charToDeletionCost : () => 1;
      charsToSubstitutionCost = charsToSubstitutionCost !== null && charsToSubstitutionCost !== void 0 ? charsToSubstitutionCost : (a, b) => a === b ? 0 : 1;
      this._characterToIdx = /* @__PURE__ */ new Map();
      this._insertionCosts = new Array(characters.length);
      this._deletionCosts = new Array(characters.length);
      this._substitutionCosts = new Array(characters.length);
      let c;
      for (let outerIdx = 0; outerIdx < characters.length; ++outerIdx) {
        c = characters[outerIdx];
        this._characterToIdx.set(c, outerIdx);
        this._insertionCosts[outerIdx] = charToInsertionCost(c);
        this._deletionCosts[outerIdx] = charToDeletionCost(c);
        this._substitutionCosts[outerIdx] = new Array(characters.length);
        for (let innerIdx = outerIdx; innerIdx < characters.length; ++innerIdx) {
          this._substitutionCosts[outerIdx][innerIdx] = charsToSubstitutionCost(c, characters[innerIdx]);
        }
      }
    }
    serialize() {
      const jsonObject = {};
      const characters = new Array(this._characterToIdx.size);
      this._characterToIdx.forEach((v, k) => {
        characters[v] = k;
      });
      jsonObject["characters"] = characters;
      jsonObject["insertionCosts"] = this._insertionCosts;
      jsonObject["deletionCosts"] = this._deletionCosts;
      jsonObject["substitutionCosts"] = this._substitutionCosts;
      return JSON.stringify(jsonObject);
    }
    static Deserialize(json) {
      const jsonObject = JSON.parse(json);
      const alphabet = new Alphabet(jsonObject["characters"]);
      alphabet._insertionCosts = jsonObject["insertionCosts"];
      alphabet._deletionCosts = jsonObject["deletionCosts"];
      alphabet._substitutionCosts = jsonObject["substitutionCosts"];
      return alphabet;
    }
    getCharacterIdx(char) {
      return this._characterToIdx.get(char);
    }
    getInsertionCost(idx) {
      return this._insertionCosts[idx];
    }
    getDeletionCost(idx) {
      return this._deletionCosts[idx];
    }
    getSubstitutionCost(idx1, idx2) {
      const min = Math.min(idx1, idx2);
      const max = Math.max(idx1, idx2);
      return this._substitutionCosts[min][max];
    }
  }
  Levenshtein2.Alphabet = Alphabet;
  class Sequence {
    constructor(characters, alphabet) {
      if (characters.length > Sequence._MAX_SEQUENCE_LENGTH) {
        throw new Error("Sequences longer than " + Sequence._MAX_SEQUENCE_LENGTH + " not supported.");
      }
      this._alphabet = alphabet;
      this._characters = characters.map((c) => this._alphabet.getCharacterIdx(c));
    }
    serialize() {
      return JSON.stringify(this._characters);
    }
    static Deserialize(json, alphabet) {
      const sequence = new Sequence([], alphabet);
      sequence._characters = JSON.parse(json);
      return sequence;
    }
    distance(other) {
      return Sequence._Distance(this, other);
    }
    static _Distance(a, b) {
      const alphabet = a._alphabet;
      if (alphabet !== b._alphabet) {
        throw new Error("Cannot Levenshtein compare Sequences built from different alphabets.");
      }
      const aChars = a._characters;
      const bChars = b._characters;
      const aLength = aChars.length;
      const bLength = bChars.length;
      const costMatrix = Sequence._CostMatrix;
      costMatrix[0][0] = 0;
      for (let idx = 0; idx < aLength; ++idx) {
        costMatrix[idx + 1][0] = costMatrix[idx][0] + alphabet.getInsertionCost(aChars[idx]);
      }
      for (let idx = 0; idx < bLength; ++idx) {
        costMatrix[0][idx + 1] = costMatrix[0][idx] + alphabet.getInsertionCost(bChars[idx]);
      }
      for (let aIdx = 0; aIdx < aLength; ++aIdx) {
        for (let bIdx = 0; bIdx < bLength; ++bIdx) {
          Sequence._InsertionCost = costMatrix[aIdx + 1][bIdx] + alphabet.getInsertionCost(bChars[bIdx]);
          Sequence._DeletionCost = costMatrix[aIdx][bIdx + 1] + alphabet.getDeletionCost(aChars[aIdx]);
          Sequence._SubstitutionCost = costMatrix[aIdx][bIdx] + alphabet.getSubstitutionCost(aChars[aIdx], bChars[bIdx]);
          costMatrix[aIdx + 1][bIdx + 1] = Math.min(Sequence._InsertionCost, Sequence._DeletionCost, Sequence._SubstitutionCost);
        }
      }
      return costMatrix[aLength][bLength];
    }
  }
  Sequence._MAX_SEQUENCE_LENGTH = 256;
  Sequence._CostMatrix = [...Array(Sequence._MAX_SEQUENCE_LENGTH + 1)].map(() => new Array(Sequence._MAX_SEQUENCE_LENGTH + 1));
  Levenshtein2.Sequence = Sequence;
})(Levenshtein || (Levenshtein = {}));
var Trajectory = class {
  constructor(segmentLength = 0.01) {
    this._points = [];
    this._segmentLength = segmentLength;
  }
  serialize() {
    return JSON.stringify(this);
  }
  static Deserialize(json) {
    const jsonObject = JSON.parse(json);
    const trajectory = new Trajectory(jsonObject["_segmentLength"]);
    trajectory._points = jsonObject["_points"].map((pt) => {
      return new Vector3(pt["_x"], pt["_y"], pt["_z"]);
    });
    return trajectory;
  }
  getLength() {
    return this._points.length * this._segmentLength;
  }
  add(point) {
    let numPoints = this._points.length;
    if (numPoints === 0) {
      this._points.push(point.clone());
    } else {
      const getT = () => this._segmentLength / Vector3.Distance(this._points[numPoints - 1], point);
      for (let t = getT(); t <= 1; t = getT()) {
        const newPoint = this._points[numPoints - 1].scale(1 - t);
        point.scaleAndAddToRef(t, newPoint);
        this._points.push(newPoint);
        ++numPoints;
      }
    }
  }
  resampleAtTargetResolution(targetResolution) {
    const resampled = new Trajectory(this.getLength() / targetResolution);
    this._points.forEach((pt) => {
      resampled.add(pt);
    });
    return resampled;
  }
  tokenize(tokens) {
    const tokenization = [];
    const segmentDir = new Vector3();
    for (let idx = 2; idx < this._points.length; ++idx) {
      if (Trajectory._TransformSegmentDirToRef(this._points[idx - 2], this._points[idx - 1], this._points[idx], segmentDir)) {
        tokenization.push(Trajectory._TokenizeSegment(segmentDir, tokens));
      }
    }
    return tokenization;
  }
  static _TransformSegmentDirToRef(priorVec, fromVec, toVec, result) {
    const DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD = 0.98;
    fromVec.subtractToRef(priorVec, Trajectory._ForwardDir);
    Trajectory._ForwardDir.normalize();
    fromVec.scaleToRef(-1, Trajectory._InverseFromVec);
    Trajectory._InverseFromVec.normalize();
    if (Math.abs(Vector3.Dot(Trajectory._ForwardDir, Trajectory._InverseFromVec)) > DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD) {
      return false;
    }
    Vector3.CrossToRef(Trajectory._ForwardDir, Trajectory._InverseFromVec, Trajectory._UpDir);
    Trajectory._UpDir.normalize();
    Matrix.LookAtLHToRef(priorVec, fromVec, Trajectory._UpDir, Trajectory._LookMatrix);
    toVec.subtractToRef(fromVec, Trajectory._FromToVec);
    Trajectory._FromToVec.normalize();
    Vector3.TransformNormalToRef(Trajectory._FromToVec, Trajectory._LookMatrix, result);
    return true;
  }
  static _TokenizeSegment(segment, tokens) {
    Trajectory._BestMatch = 0;
    Trajectory._Score = Vector3.Dot(segment, tokens[0]);
    Trajectory._BestScore = Trajectory._Score;
    for (let idx = 1; idx < tokens.length; ++idx) {
      Trajectory._Score = Vector3.Dot(segment, tokens[idx]);
      if (Trajectory._Score > Trajectory._BestScore) {
        Trajectory._BestMatch = idx;
        Trajectory._BestScore = Trajectory._Score;
      }
    }
    return Trajectory._BestMatch;
  }
};
Trajectory._ForwardDir = new Vector3();
Trajectory._InverseFromVec = new Vector3();
Trajectory._UpDir = new Vector3();
Trajectory._FromToVec = new Vector3();
Trajectory._LookMatrix = new Matrix();
var Vector3Alphabet = class {
  constructor(size) {
    this.chars = new Array(size);
  }
  static Generate(alphabetSize = 64, iterations = 256, startingStepSize = 0.1, endingStepSize = 1e-3, fixedValues = []) {
    const EPSILON = 1e-3;
    const EPSILON_SQUARED = EPSILON * EPSILON;
    const alphabet = new Vector3Alphabet(alphabetSize);
    for (let idx = 0; idx < alphabetSize; ++idx) {
      alphabet.chars[idx] = new Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
      alphabet.chars[idx].normalize();
    }
    for (let idx = 0; idx < fixedValues.length; ++idx) {
      alphabet.chars[idx].copyFrom(fixedValues[idx]);
    }
    let stepSize;
    let distSq;
    const force = new Vector3();
    const scratch = new Vector3();
    const lerp = (l, r, t) => (1 - t) * l + t * r;
    for (let iteration = 0; iteration < iterations; ++iteration) {
      stepSize = lerp(startingStepSize, endingStepSize, iteration / (iterations - 1));
      for (let idx = fixedValues.length; idx < alphabet.chars.length; ++idx) {
        force.copyFromFloats(0, 0, 0);
        alphabet.chars.forEach((pt) => {
          alphabet.chars[idx].subtractToRef(pt, scratch);
          distSq = scratch.lengthSquared();
          if (distSq > EPSILON_SQUARED) {
            scratch.scaleAndAddToRef(1 / (scratch.lengthSquared() * distSq), force);
          }
        });
        force.scaleInPlace(stepSize);
        alphabet.chars[idx].addInPlace(force);
        alphabet.chars[idx].normalize();
      }
    }
    return alphabet;
  }
  serialize() {
    return JSON.stringify(this.chars);
  }
  static Deserialize(json) {
    const jsonObject = JSON.parse(json);
    const alphabet = new Vector3Alphabet(jsonObject.length);
    for (let idx = 0; idx < jsonObject.length; ++idx) {
      alphabet.chars[idx] = new Vector3(jsonObject[idx]["_x"], jsonObject[idx]["_y"], jsonObject[idx]["_z"]);
    }
    return alphabet;
  }
};
var TrajectoryDescriptor = class {
  constructor() {
    this._sequences = [];
  }
  serialize() {
    return JSON.stringify(this._sequences.map((sequence) => sequence.serialize()));
  }
  static Deserialize(json, alphabet) {
    const descriptor = new TrajectoryDescriptor();
    descriptor._sequences = JSON.parse(json).map((s) => Levenshtein.Sequence.Deserialize(s, alphabet));
    return descriptor;
  }
  static CreateFromTrajectory(trajectory, vector3Alphabet, levenshteinAlphabet) {
    return TrajectoryDescriptor.CreateFromTokenizationPyramid(TrajectoryDescriptor._GetTokenizationPyramid(trajectory, vector3Alphabet), levenshteinAlphabet);
  }
  static CreateFromTokenizationPyramid(pyramid, levenshteinAlphabet) {
    const descriptor = new TrajectoryDescriptor();
    descriptor._sequences = pyramid.map((tokens) => new Levenshtein.Sequence(tokens, levenshteinAlphabet));
    return descriptor;
  }
  static _GetTokenizationPyramid(trajectory, alphabet, targetResolution = TrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION) {
    const pyramid = [];
    for (let res = targetResolution; res > 4; res = Math.floor(res / 2)) {
      pyramid.push(trajectory.resampleAtTargetResolution(res).tokenize(alphabet.chars));
    }
    return pyramid;
  }
  distance(other) {
    let totalDistance = 0;
    let weight;
    for (let idx = 0; idx < this._sequences.length; ++idx) {
      weight = Math.pow(2, idx);
      totalDistance += weight * this._sequences[idx].distance(other._sequences[idx]);
    }
    return totalDistance;
  }
};
TrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION = 32;
var TrajectoryClass = class {
  constructor(descriptors = []) {
    this._descriptors = descriptors;
    this._centroidIdx = -1;
    this._averageDistance = 0;
    this._refreshDescription();
  }
  serialize() {
    const jsonObject = {};
    jsonObject.descriptors = this._descriptors.map((desc) => desc.serialize());
    jsonObject.centroidIdx = this._centroidIdx;
    jsonObject.averageDistance = this._averageDistance;
    return JSON.stringify(jsonObject);
  }
  static Deserialize(json, alphabet) {
    const jsonObject = JSON.parse(json);
    const described = new TrajectoryClass();
    described._descriptors = jsonObject.descriptors.map((s) => TrajectoryDescriptor.Deserialize(s, alphabet));
    described._centroidIdx = jsonObject.centroidIdx;
    described._averageDistance = jsonObject.averageDistance;
    return described;
  }
  add(descriptor) {
    this._descriptors.push(descriptor);
    this._refreshDescription();
  }
  getMatchCost(descriptor) {
    return descriptor.distance(this._descriptors[this._centroidIdx]) / this._averageDistance;
  }
  getMatchMinimumDistance(descriptor) {
    return Math.min(...this._descriptors.map((desc) => desc.distance(descriptor)));
  }
  _refreshDescription() {
    this._centroidIdx = -1;
    let sum;
    const distances = this._descriptors.map((a) => {
      sum = 0;
      this._descriptors.forEach((b) => {
        sum += a.distance(b);
      });
      return sum;
    });
    for (let idx = 0; idx < distances.length; ++idx) {
      if (this._centroidIdx < 0 || distances[idx] < distances[this._centroidIdx]) {
        this._centroidIdx = idx;
      }
    }
    this._averageDistance = 0;
    this._descriptors.forEach((desc) => {
      this._averageDistance += desc.distance(this._descriptors[this._centroidIdx]);
    });
    if (this._descriptors.length > 0) {
      this._averageDistance = Math.max(this._averageDistance / this._descriptors.length, TrajectoryClass._MIN_AVERAGE_DISTANCE);
    }
  }
};
TrajectoryClass._MIN_AVERAGE_DISTANCE = 1;
var TrajectoryClassifier = class {
  constructor() {
    this._maximumAllowableMatchCost = 4;
    this._nameToDescribedTrajectory = /* @__PURE__ */ new Map();
  }
  serialize() {
    const jsonObject = {};
    jsonObject.maximumAllowableMatchCost = this._maximumAllowableMatchCost;
    jsonObject.vector3Alphabet = this._vector3Alphabet.serialize();
    jsonObject.levenshteinAlphabet = this._levenshteinAlphabet.serialize();
    jsonObject.nameToDescribedTrajectory = [];
    this._nameToDescribedTrajectory.forEach((described, name137) => {
      jsonObject.nameToDescribedTrajectory.push(name137);
      jsonObject.nameToDescribedTrajectory.push(described.serialize());
    });
    return JSON.stringify(jsonObject);
  }
  static Deserialize(json) {
    const jsonObject = JSON.parse(json);
    const classifier = new TrajectoryClassifier();
    classifier._maximumAllowableMatchCost = jsonObject.maximumAllowableMatchCost;
    classifier._vector3Alphabet = Vector3Alphabet.Deserialize(jsonObject.vector3Alphabet);
    classifier._levenshteinAlphabet = Levenshtein.Alphabet.Deserialize(jsonObject.levenshteinAlphabet);
    for (let idx = 0; idx < jsonObject.nameToDescribedTrajectory.length; idx += 2) {
      classifier._nameToDescribedTrajectory.set(jsonObject.nameToDescribedTrajectory[idx], TrajectoryClass.Deserialize(jsonObject.nameToDescribedTrajectory[idx + 1], classifier._levenshteinAlphabet));
    }
    return classifier;
  }
  static Generate() {
    const vecs = Vector3Alphabet.Generate(64, 256, 0.1, 1e-3, [Vector3.Forward()]);
    const charIdxs = new Array(vecs.chars.length);
    for (let idx = 0; idx < charIdxs.length; ++idx) {
      charIdxs[idx] = idx;
    }
    const alphabet = new Levenshtein.Alphabet(charIdxs, (idx) => idx === 0 ? 0 : 1, (idx) => idx === 0 ? 0 : 1, (a, b) => Math.min(1 - Vector3.Dot(vecs.chars[a], vecs.chars[b]), 1));
    const trajectorySet = new TrajectoryClassifier();
    trajectorySet._vector3Alphabet = vecs;
    trajectorySet._levenshteinAlphabet = alphabet;
    return trajectorySet;
  }
  addTrajectoryToClassification(trajectory, classification) {
    if (!this._nameToDescribedTrajectory.has(classification)) {
      this._nameToDescribedTrajectory.set(classification, new TrajectoryClass());
    }
    this._nameToDescribedTrajectory.get(classification).add(TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet));
  }
  deleteClassification(classification) {
    return this._nameToDescribedTrajectory.delete(classification);
  }
  classifyTrajectory(trajectory) {
    const descriptor = TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet);
    const allowableMatches = [];
    this._nameToDescribedTrajectory.forEach((trajectoryClass, classification) => {
      if (trajectoryClass.getMatchCost(descriptor) < this._maximumAllowableMatchCost) {
        allowableMatches.push(classification);
      }
    });
    if (allowableMatches.length === 0) {
      return null;
    }
    let bestIdx = 0;
    let bestMatch = this._nameToDescribedTrajectory.get(allowableMatches[bestIdx]).getMatchMinimumDistance(descriptor);
    let match;
    for (let idx = 0; idx < allowableMatches.length; ++idx) {
      match = this._nameToDescribedTrajectory.get(allowableMatches[idx]).getMatchMinimumDistance(descriptor);
      if (match < bestMatch) {
        bestMatch = match;
        bestIdx = idx;
      }
    }
    return allowableMatches[bestIdx];
  }
};

// node_modules/@babylonjs/core/Misc/reflector.js
var Reflector = class {
  constructor(scene, hostname, port) {
    this._scene = scene;
    Logger.Log(`[Reflector] Connecting to ws://${hostname}:${port}`);
    this._webSocket = new WebSocket(`ws://${hostname}:${port}`);
    this._webSocket.onmessage = (event) => {
      const message = event.data;
      if (message.startsWith(Reflector._SERVER_PREFIX)) {
        const serverMessage = message.substr(Reflector._SERVER_PREFIX.length);
        Logger.Log(`[Reflector] Received server message: ${serverMessage.substr(0, 64)}`);
        this._handleServerMessage(serverMessage);
        return;
      } else {
        Logger.Log(`[Reflector] Received client message: ${message.substr(0, 64)}`);
        this._handleClientMessage();
      }
    };
    this._webSocket.onclose = (event) => {
      Logger.Log(`[Reflector] Disconnected ${event.code} ${event.reason}`);
    };
  }
  close() {
    this._webSocket.close();
  }
  _handleServerMessage(message) {
    switch (message) {
      case "connected": {
        SceneSerializer.SerializeAsync(this._scene).then((serialized) => {
          this._webSocket.send(`load|${JSON.stringify(serialized)}`);
        });
        break;
      }
    }
  }
  _handleClientMessage() {
  }
};
Reflector._SERVER_PREFIX = "$$";

// node_modules/@babylonjs/core/Misc/pressureObserverWrapper.js
var PressureObserverWrapper = class {
  constructor(options) {
    this._observer = null;
    this._currentState = [];
    this.onPressureChanged = new Observable();
    if (PressureObserverWrapper.IsAvailable) {
      this._observer = new PressureObserver((update) => {
        this._currentState = update;
        this.onPressureChanged.notifyObservers(update);
      }, options);
    }
  }
  static get IsAvailable() {
    return typeof PressureObserver !== "undefined" && PressureObserver.supportedSources.includes("cpu");
  }
  observe(source) {
    var _a;
    try {
      (_a = this._observer) === null || _a === void 0 ? void 0 : _a.observe(source);
      this.onPressureChanged.notifyObservers(this._currentState);
    } catch (_b) {
    }
  }
  unobserve(source) {
    var _a;
    try {
      (_a = this._observer) === null || _a === void 0 ? void 0 : _a.unobserve(source);
    } catch (_b) {
    }
  }
  dispose() {
    var _a;
    (_a = this._observer) === null || _a === void 0 ? void 0 : _a.disconnect();
    this._observer = null;
    this.onPressureChanged.clear();
  }
};

// node_modules/@babylonjs/core/Misc/PerformanceViewer/dynamicFloat32Array.js
var growthFactor = 1.5;
var DynamicFloat32Array = class {
  constructor(itemCapacity) {
    this._view = new Float32Array(itemCapacity);
    this._itemLength = 0;
  }
  get itemLength() {
    return this._itemLength;
  }
  at(index) {
    if (index < 0 || index >= this._itemLength) {
      return NaN;
    }
    return this._view[index];
  }
  subarray(start, end) {
    if (start >= end || start < 0) {
      return new Float32Array(0);
    }
    if (end > this._itemLength) {
      end = this._itemLength;
    }
    return this._view.subarray(start, end);
  }
  push(item) {
    this._view[this._itemLength] = item;
    this._itemLength++;
    if (this._itemLength >= this._view.length) {
      this._growArray();
    }
  }
  _growArray() {
    const newCapacity = Math.floor(this._view.length * growthFactor);
    const view = new Float32Array(newCapacity);
    view.set(this._view);
    this._view = view;
  }
};

// node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollector.js
var InitialArraySize = 1800;
var NumberOfBitsInHexcode = 24;
var HexPadding = "0";
var TimestampColHeader = "timestamp";
var NumPointsColHeader = "numPoints";
var CarriageReturnRegex = /\r/g;
var ExportedDataSeparator = "@";
var PerformanceViewerCollector = class {
  constructor(_scene, _enabledStrategyCallbacks) {
    this._scene = _scene;
    this._collectDataAtFrame = () => {
      const timestamp = PrecisionDate.Now - this._startingTimestamp;
      const numPoints = this.datasets.ids.length;
      const numberOfIndices = this.datasets.startingIndices.itemLength;
      let startingIndex = 0;
      if (numberOfIndices > 0) {
        const previousStartingIndex = this.datasets.startingIndices.at(numberOfIndices - 1);
        startingIndex = previousStartingIndex + this.datasets.data.at(previousStartingIndex + PerformanceViewerCollector.NumberOfPointsOffset) + PerformanceViewerCollector.SliceDataOffset;
      }
      this.datasets.startingIndices.push(startingIndex);
      this.datasets.data.push(timestamp);
      this.datasets.data.push(numPoints);
      this.datasets.ids.forEach((id) => {
        const strategy = this._strategies.get(id);
        if (!strategy) {
          return;
        }
        this.datasets.data.push(strategy.getData());
      });
      if (this.datasetObservable.hasObservers()) {
        const slice = [timestamp, numPoints];
        for (let i = 0; i < numPoints; i++) {
          slice.push(this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + i));
        }
        this.datasetObservable.notifyObservers(slice);
      }
    };
    this.datasets = {
      ids: [],
      data: new DynamicFloat32Array(InitialArraySize),
      startingIndices: new DynamicFloat32Array(InitialArraySize)
    };
    this._strategies = /* @__PURE__ */ new Map();
    this._datasetMeta = /* @__PURE__ */ new Map();
    this._eventRestoreSet = /* @__PURE__ */ new Set();
    this._customEventObservable = new Observable();
    this.datasetObservable = new Observable();
    this.metadataObservable = new Observable((observer) => observer.callback(this._datasetMeta, new EventState(0)));
    if (_enabledStrategyCallbacks) {
      this.addCollectionStrategies(..._enabledStrategyCallbacks);
    }
  }
  static get SliceDataOffset() {
    return 2;
  }
  static get NumberOfPointsOffset() {
    return 1;
  }
  registerEvent(name137, forceUpdate, category) {
    var _a;
    if (this._strategies.has(name137) && !forceUpdate) {
      return;
    }
    if (this._strategies.has(name137) && forceUpdate) {
      (_a = this._strategies.get(name137)) === null || _a === void 0 ? void 0 : _a.dispose();
      this._strategies.delete(name137);
    }
    const strategy = (scene) => {
      let counter = 0;
      let value = 0;
      const afterRenderObserver = scene.onAfterRenderObservable.add(() => {
        value = counter;
        counter = 0;
      });
      const stringObserver = this._customEventObservable.add((eventVal) => {
        if (name137 !== eventVal.name) {
          return;
        }
        if (eventVal.value !== void 0) {
          counter = eventVal.value;
        } else {
          counter++;
        }
      });
      return {
        id: name137,
        getData: () => value,
        dispose: () => {
          scene.onAfterRenderObservable.remove(afterRenderObserver);
          this._customEventObservable.remove(stringObserver);
        }
      };
    };
    const event = {
      name: name137
    };
    this._eventRestoreSet.add(name137);
    this.addCollectionStrategies({ strategyCallback: strategy, category });
    return event;
  }
  sendEvent(event) {
    this._customEventObservable.notifyObservers(event);
  }
  _restoreStringEvents() {
    if (this._eventRestoreSet.size !== this._customEventObservable.observers.length) {
      this._eventRestoreSet.forEach((event) => {
        this.registerEvent(event, true);
      });
    }
  }
  addCollectionStrategies(...strategyCallbacks) {
    for (let { strategyCallback, category, hidden } of strategyCallbacks) {
      const strategy = strategyCallback(this._scene);
      if (this._strategies.has(strategy.id)) {
        strategy.dispose();
        continue;
      }
      this.datasets.ids.push(strategy.id);
      if (category) {
        category = category.replace(new RegExp(ExportedDataSeparator, "g"), "");
      }
      this._datasetMeta.set(strategy.id, {
        color: this._getHexColorFromId(strategy.id),
        category,
        hidden
      });
      this._strategies.set(strategy.id, strategy);
    }
    this.metadataObservable.notifyObservers(this._datasetMeta);
  }
  _getHexColorFromId(id) {
    let hash = 0;
    for (let i = 0; i < id.length; i++) {
      hash = id.charCodeAt(i) + ((hash << 5) - hash);
    }
    let hex = "#";
    for (let i = 0; i < NumberOfBitsInHexcode; i += 8) {
      const octet = hash >> i & 255;
      hex += (HexPadding + octet.toString(16)).substr(-2);
    }
    return hex;
  }
  getCurrentSlice() {
    const timestamp = PrecisionDate.Now - this._startingTimestamp;
    const numPoints = this.datasets.ids.length;
    const slice = [timestamp, numPoints];
    this.datasets.ids.forEach((id) => {
      const strategy = this._strategies.get(id);
      if (!strategy) {
        return;
      }
      if (this.datasetObservable.hasObservers()) {
        slice.push(strategy.getData());
      }
    });
    if (this.datasetObservable.hasObservers()) {
      this.datasetObservable.notifyObservers(slice);
    }
  }
  updateMetadata(id, prop, value) {
    const meta = this._datasetMeta.get(id);
    if (!meta) {
      return;
    }
    meta[prop] = value;
    this.metadataObservable.notifyObservers(this._datasetMeta);
  }
  clear(preserveStringEventsRestore) {
    this.datasets.data = new DynamicFloat32Array(InitialArraySize);
    this.datasets.ids.length = 0;
    this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);
    this._datasetMeta.clear();
    this._strategies.forEach((strategy) => strategy.dispose());
    this._strategies.clear();
    if (!preserveStringEventsRestore) {
      this._eventRestoreSet.clear();
    }
    this._hasLoadedData = false;
  }
  get hasLoadedData() {
    return this._hasLoadedData;
  }
  loadFromFileData(data, keepDatasetMeta) {
    const lines = data.replace(CarriageReturnRegex, "").split("\n").map((line) => line.split(",").filter((s) => s.length > 0)).filter((line) => line.length > 0);
    const timestampIndex = 0;
    const numPointsIndex = PerformanceViewerCollector.NumberOfPointsOffset;
    if (lines.length < 2) {
      return false;
    }
    const parsedDatasets = {
      ids: [],
      data: new DynamicFloat32Array(InitialArraySize),
      startingIndices: new DynamicFloat32Array(InitialArraySize)
    };
    const [firstLine, ...dataLines] = lines;
    if (firstLine.length < 2 || firstLine[timestampIndex] !== TimestampColHeader || firstLine[numPointsIndex] !== NumPointsColHeader) {
      return false;
    }
    const idCategoryMap = /* @__PURE__ */ new Map();
    for (let i = PerformanceViewerCollector.SliceDataOffset; i < firstLine.length; i++) {
      const [id, category] = firstLine[i].split(ExportedDataSeparator);
      parsedDatasets.ids.push(id);
      idCategoryMap.set(id, category);
    }
    let startingIndex = 0;
    for (const line of dataLines) {
      if (line.length < 2) {
        return false;
      }
      const timestamp = parseFloat(line[timestampIndex]);
      const numPoints = parseInt(line[numPointsIndex]);
      if (isNaN(numPoints) || isNaN(timestamp)) {
        return false;
      }
      parsedDatasets.data.push(timestamp);
      parsedDatasets.data.push(numPoints);
      if (numPoints + PerformanceViewerCollector.SliceDataOffset !== line.length) {
        return false;
      }
      for (let i = PerformanceViewerCollector.SliceDataOffset; i < line.length; i++) {
        const val = parseFloat(line[i]);
        if (isNaN(val)) {
          return false;
        }
        parsedDatasets.data.push(val);
      }
      parsedDatasets.startingIndices.push(startingIndex);
      startingIndex += line.length;
    }
    this.datasets.ids = parsedDatasets.ids;
    this.datasets.data = parsedDatasets.data;
    this.datasets.startingIndices = parsedDatasets.startingIndices;
    if (!keepDatasetMeta) {
      this._datasetMeta.clear();
    }
    this._strategies.forEach((strategy) => strategy.dispose());
    this._strategies.clear();
    if (!keepDatasetMeta) {
      for (const id of this.datasets.ids) {
        const category = idCategoryMap.get(id);
        this._datasetMeta.set(id, { category, color: this._getHexColorFromId(id) });
      }
    }
    this.metadataObservable.notifyObservers(this._datasetMeta);
    this._hasLoadedData = true;
    return true;
  }
  exportDataToCsv() {
    let csvContent = "";
    csvContent += `${TimestampColHeader},${NumPointsColHeader}`;
    for (let i = 0; i < this.datasets.ids.length; i++) {
      csvContent += `,${this.datasets.ids[i]}`;
      if (this._datasetMeta) {
        const meta = this._datasetMeta.get(this.datasets.ids[i]);
        if (meta === null || meta === void 0 ? void 0 : meta.category) {
          csvContent += `${ExportedDataSeparator}${meta.category}`;
        }
      }
    }
    csvContent += "\n";
    for (let i = 0; i < this.datasets.startingIndices.itemLength; i++) {
      const startingIndex = this.datasets.startingIndices.at(i);
      const timestamp = this.datasets.data.at(startingIndex);
      const numPoints = this.datasets.data.at(startingIndex + PerformanceViewerCollector.NumberOfPointsOffset);
      csvContent += `${timestamp},${numPoints}`;
      for (let offset = 0; offset < numPoints; offset++) {
        csvContent += `,${this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + offset)}`;
      }
      for (let diff = 0; diff < this.datasets.ids.length - numPoints; diff++) {
        csvContent += ",";
      }
      csvContent += "\n";
    }
    const fileName = `${new Date().toISOString()}-perfdata.csv`;
    Tools.Download(new Blob([csvContent], { type: "text/csv" }), fileName);
  }
  start(shouldPreserve) {
    if (!shouldPreserve) {
      this.datasets.data = new DynamicFloat32Array(InitialArraySize);
      this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);
      this._startingTimestamp = PrecisionDate.Now;
    } else if (this._startingTimestamp === void 0) {
      this._startingTimestamp = PrecisionDate.Now;
    }
    this._scene.onAfterRenderObservable.add(this._collectDataAtFrame);
    this._restoreStringEvents();
    this._isStarted = true;
  }
  stop() {
    this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);
    this._isStarted = false;
  }
  get isStarted() {
    return this._isStarted;
  }
  dispose() {
    this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);
    this._datasetMeta.clear();
    this._strategies.forEach((strategy) => {
      strategy.dispose();
    });
    this.datasetObservable.clear();
    this.metadataObservable.clear();
    this._isStarted = false;
    this.datasets = null;
  }
};

// node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollectionStrategies.js
var defaultDisposeImpl = () => {
};
var PerfCollectionStrategy = class {
  static FpsStrategy() {
    return (scene) => {
      const engine = scene.getEngine();
      return {
        id: "FPS",
        getData: () => engine.getFps(),
        dispose: defaultDisposeImpl
      };
    };
  }
  static ThermalStrategy() {
    return this._PressureStrategy("Thermal utilization", "thermal");
  }
  static PowerSupplyStrategy() {
    return this._PressureStrategy("Power supply utilization", "power-supply");
  }
  static PressureStrategy() {
    return this._PressureStrategy("Pressure");
  }
  static _PressureStrategy(name137, factor = null) {
    return () => {
      let value = 0;
      const wrapper = new PressureObserverWrapper();
      wrapper.observe("cpu");
      wrapper.onPressureChanged.add((update) => {
        for (const record of update) {
          if (factor && record.factors.includes(factor) || !factor && record.factors.length === 0) {
            switch (record.state) {
              case "nominal":
                value = 0;
                break;
              case "fair":
                value = 0.25;
                break;
              case "serious":
                value = 0.5;
                break;
              case "critical":
                value = 1;
                break;
            }
          }
        }
      });
      return {
        id: name137,
        getData: () => value,
        dispose: () => wrapper.dispose()
      };
    };
  }
  static TotalMeshesStrategy() {
    return (scene) => {
      return {
        id: "Total meshes",
        getData: () => scene.meshes.length,
        dispose: defaultDisposeImpl
      };
    };
  }
  static ActiveMeshesStrategy() {
    return (scene) => {
      return {
        id: "Active meshes",
        getData: () => scene.getActiveMeshes().length,
        dispose: defaultDisposeImpl
      };
    };
  }
  static ActiveIndicesStrategy() {
    return (scene) => {
      return {
        id: "Active indices",
        getData: () => scene.getActiveIndices(),
        dispose: defaultDisposeImpl
      };
    };
  }
  static ActiveFacesStrategy() {
    return (scene) => {
      return {
        id: "Active faces",
        getData: () => scene.getActiveIndices() / 3,
        dispose: defaultDisposeImpl
      };
    };
  }
  static ActiveBonesStrategy() {
    return (scene) => {
      return {
        id: "Active bones",
        getData: () => scene.getActiveBones(),
        dispose: defaultDisposeImpl
      };
    };
  }
  static ActiveParticlesStrategy() {
    return (scene) => {
      return {
        id: "Active particles",
        getData: () => scene.getActiveParticles(),
        dispose: defaultDisposeImpl
      };
    };
  }
  static DrawCallsStrategy() {
    return (scene) => {
      let drawCalls = 0;
      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {
        scene.getEngine()._drawCalls.fetchNewFrame();
      });
      const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {
        drawCalls = scene.getEngine()._drawCalls.current;
      });
      return {
        id: "Draw calls",
        getData: () => drawCalls,
        dispose: () => {
          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);
          scene.onAfterRenderObservable.remove(onAfterRenderObserver);
        }
      };
    };
  }
  static TotalLightsStrategy() {
    return (scene) => {
      return {
        id: "Total lights",
        getData: () => scene.lights.length,
        dispose: defaultDisposeImpl
      };
    };
  }
  static TotalVerticesStrategy() {
    return (scene) => {
      return {
        id: "Total vertices",
        getData: () => scene.getTotalVertices(),
        dispose: defaultDisposeImpl
      };
    };
  }
  static TotalMaterialsStrategy() {
    return (scene) => {
      return {
        id: "Total materials",
        getData: () => scene.materials.length,
        dispose: defaultDisposeImpl
      };
    };
  }
  static TotalTexturesStrategy() {
    return (scene) => {
      return {
        id: "Total textures",
        getData: () => scene.textures.length,
        dispose: defaultDisposeImpl
      };
    };
  }
  static AbsoluteFpsStrategy() {
    return (scene) => {
      const sceneInstrumentation = new SceneInstrumentation(scene);
      sceneInstrumentation.captureFrameTime = true;
      return {
        id: "Absolute FPS",
        getData: () => {
          return 1e3 / sceneInstrumentation.frameTimeCounter.lastSecAverage;
        },
        dispose: defaultDisposeImpl
      };
    };
  }
  static MeshesSelectionStrategy() {
    return (scene) => {
      let startTime = PrecisionDate.Now;
      let timeTaken = 0;
      const onBeforeActiveMeshesObserver = scene.onBeforeActiveMeshesEvaluationObservable.add(() => {
        startTime = PrecisionDate.Now;
      });
      const onAfterActiveMeshesObserver = scene.onAfterActiveMeshesEvaluationObservable.add(() => {
        timeTaken = PrecisionDate.Now - startTime;
      });
      return {
        id: "Meshes Selection",
        getData: () => timeTaken,
        dispose: () => {
          scene.onBeforeActiveMeshesEvaluationObservable.remove(onBeforeActiveMeshesObserver);
          scene.onAfterActiveMeshesEvaluationObservable.remove(onAfterActiveMeshesObserver);
        }
      };
    };
  }
  static RenderTargetsStrategy() {
    return (scene) => {
      let startTime = PrecisionDate.Now;
      let timeTaken = 0;
      const onBeforeRenderTargetsObserver = scene.onBeforeRenderTargetsRenderObservable.add(() => {
        startTime = PrecisionDate.Now;
      });
      const onAfterRenderTargetsObserver = scene.onAfterRenderTargetsRenderObservable.add(() => {
        timeTaken = PrecisionDate.Now - startTime;
      });
      return {
        id: "Render Targets",
        getData: () => timeTaken,
        dispose: () => {
          scene.onBeforeRenderTargetsRenderObservable.remove(onBeforeRenderTargetsObserver);
          scene.onAfterRenderTargetsRenderObservable.remove(onAfterRenderTargetsObserver);
        }
      };
    };
  }
  static ParticlesStrategy() {
    return (scene) => {
      let startTime = PrecisionDate.Now;
      let timeTaken = 0;
      const onBeforeParticlesObserver = scene.onBeforeParticlesRenderingObservable.add(() => {
        startTime = PrecisionDate.Now;
      });
      const onAfterParticlesObserver = scene.onAfterParticlesRenderingObservable.add(() => {
        timeTaken = PrecisionDate.Now - startTime;
      });
      return {
        id: "Particles",
        getData: () => timeTaken,
        dispose: () => {
          scene.onBeforeParticlesRenderingObservable.remove(onBeforeParticlesObserver);
          scene.onAfterParticlesRenderingObservable.remove(onAfterParticlesObserver);
        }
      };
    };
  }
  static SpritesStrategy() {
    return (scene) => {
      var _a, _b;
      let startTime = PrecisionDate.Now;
      let timeTaken = 0;
      const onBeforeSpritesObserver = (_a = scene.onBeforeSpritesRenderingObservable) === null || _a === void 0 ? void 0 : _a.add(() => {
        startTime = PrecisionDate.Now;
      });
      const onAfterSpritesObserver = (_b = scene.onAfterSpritesRenderingObservable) === null || _b === void 0 ? void 0 : _b.add(() => {
        timeTaken = PrecisionDate.Now - startTime;
      });
      return {
        id: "Sprites",
        getData: () => timeTaken,
        dispose: () => {
          var _a2, _b2;
          (_a2 = scene.onBeforeSpritesRenderingObservable) === null || _a2 === void 0 ? void 0 : _a2.remove(onBeforeSpritesObserver);
          (_b2 = scene.onAfterSpritesRenderingObservable) === null || _b2 === void 0 ? void 0 : _b2.remove(onAfterSpritesObserver);
        }
      };
    };
  }
  static AnimationsStrategy() {
    return (scene) => {
      let startTime = PrecisionDate.Now;
      let timeTaken = 0;
      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {
        startTime = PrecisionDate.Now;
      });
      const onAfterAnimationsObserver = scene.onAfterAnimationsObservable.add(() => {
        timeTaken = PrecisionDate.Now - startTime;
      });
      return {
        id: "Animations",
        getData: () => timeTaken,
        dispose: () => {
          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);
          scene.onAfterAnimationsObservable.remove(onAfterAnimationsObserver);
        }
      };
    };
  }
  static PhysicsStrategy() {
    return (scene) => {
      var _a, _b;
      let startTime = PrecisionDate.Now;
      let timeTaken = 0;
      const onBeforePhysicsObserver = (_a = scene.onBeforePhysicsObservable) === null || _a === void 0 ? void 0 : _a.add(() => {
        startTime = PrecisionDate.Now;
      });
      const onAfterPhysicsObserver = (_b = scene.onAfterPhysicsObservable) === null || _b === void 0 ? void 0 : _b.add(() => {
        timeTaken = PrecisionDate.Now - startTime;
      });
      return {
        id: "Physics",
        getData: () => timeTaken,
        dispose: () => {
          var _a2, _b2;
          (_a2 = scene.onBeforePhysicsObservable) === null || _a2 === void 0 ? void 0 : _a2.remove(onBeforePhysicsObserver);
          (_b2 = scene.onAfterPhysicsObservable) === null || _b2 === void 0 ? void 0 : _b2.remove(onAfterPhysicsObserver);
        }
      };
    };
  }
  static RenderStrategy() {
    return (scene) => {
      let startTime = PrecisionDate.Now;
      let timeTaken = 0;
      const onBeforeDrawPhaseObserver = scene.onBeforeDrawPhaseObservable.add(() => {
        startTime = PrecisionDate.Now;
      });
      const onAfterDrawPhaseObserver = scene.onAfterDrawPhaseObservable.add(() => {
        timeTaken = PrecisionDate.Now - startTime;
      });
      return {
        id: "Render",
        getData: () => timeTaken,
        dispose: () => {
          scene.onBeforeDrawPhaseObservable.remove(onBeforeDrawPhaseObserver);
          scene.onAfterDrawPhaseObservable.remove(onAfterDrawPhaseObserver);
        }
      };
    };
  }
  static FrameTotalStrategy() {
    return (scene) => {
      let startTime = PrecisionDate.Now;
      let timeTaken = 0;
      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {
        startTime = PrecisionDate.Now;
      });
      const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {
        timeTaken = PrecisionDate.Now - startTime;
      });
      return {
        id: "Frame Total",
        getData: () => timeTaken,
        dispose: () => {
          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);
          scene.onAfterRenderObservable.remove(onAfterRenderObserver);
        }
      };
    };
  }
  static InterFrameStrategy() {
    return (scene) => {
      let startTime = PrecisionDate.Now;
      let timeTaken = 0;
      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {
        timeTaken = PrecisionDate.Now - startTime;
      });
      const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {
        startTime = PrecisionDate.Now;
      });
      return {
        id: "Inter-frame",
        getData: () => timeTaken,
        dispose: () => {
          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);
          scene.onAfterRenderObservable.remove(onAfterRenderObserver);
        }
      };
    };
  }
  static GpuFrameTimeStrategy() {
    return (scene) => {
      const engineInstrumentation = new EngineInstrumentation(scene.getEngine());
      engineInstrumentation.captureGPUFrameTime = true;
      return {
        id: "GPU frame time",
        getData: () => Math.max(engineInstrumentation.gpuFrameTimeCounter.current * 1e-6, 0),
        dispose: () => {
          engineInstrumentation.dispose();
        }
      };
    };
  }
};

// node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerSceneExtension.js
Scene.prototype.getPerfCollector = function() {
  if (!this._perfCollector) {
    this._perfCollector = new PerformanceViewerCollector(this);
  }
  return this._perfCollector;
};

// node_modules/@babylonjs/core/Misc/observableCoroutine.js
function CreateObservableScheduler(observable) {
  const coroutines = new Array();
  const onSteps = new Array();
  const onErrors = new Array();
  const observer = observable.add(() => {
    const count = coroutines.length;
    for (let i = 0; i < count; i++) {
      inlineScheduler(coroutines.shift(), onSteps.shift(), onErrors.shift());
    }
  });
  const scheduler = (coroutine, onStep, onError) => {
    coroutines.push(coroutine);
    onSteps.push(onStep);
    onErrors.push(onError);
  };
  return {
    scheduler,
    dispose: () => {
      observable.remove(observer);
    }
  };
}
Observable.prototype.runCoroutineAsync = function(coroutine) {
  if (!this._coroutineScheduler) {
    const schedulerAndDispose = CreateObservableScheduler(this);
    this._coroutineScheduler = schedulerAndDispose.scheduler;
    this._coroutineSchedulerDispose = schedulerAndDispose.dispose;
  }
  return runCoroutineAsync(coroutine, this._coroutineScheduler);
};
Observable.prototype.cancelAllCoroutines = function() {
  if (this._coroutineSchedulerDispose) {
    this._coroutineSchedulerDispose();
  }
  this._coroutineScheduler = void 0;
  this._coroutineSchedulerDispose = void 0;
};

// node_modules/@babylonjs/core/XR/features/WebXRHitTestLegacy.js
var WebXRHitTestLegacy = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, options = {}) {
    super(_xrSessionManager);
    this.options = options;
    this._direction = new Vector3(0, 0, -1);
    this._mat = new Matrix();
    this._onSelectEnabled = false;
    this._origin = new Vector3(0, 0, 0);
    this.lastNativeXRHitResults = [];
    this.onHitTestResultObservable = new Observable();
    this._onHitTestResults = (xrResults) => {
      const mats = xrResults.map((result) => {
        const mat = Matrix.FromArray(result.hitMatrix);
        if (!this._xrSessionManager.scene.useRightHandedSystem) {
          mat.toggleModelMatrixHandInPlace();
        }
        if (this.options.worldParentNode) {
          mat.multiplyToRef(this.options.worldParentNode.getWorldMatrix(), mat);
        }
        return {
          xrHitResult: result,
          transformationMatrix: mat
        };
      });
      this.lastNativeXRHitResults = xrResults;
      this.onHitTestResultObservable.notifyObservers(mats);
    };
    this._onSelect = (event) => {
      if (!this._onSelectEnabled) {
        return;
      }
      WebXRHitTestLegacy.XRHitTestWithSelectEvent(event, this._xrSessionManager.referenceSpace);
    };
    this.xrNativeFeatureName = "hit-test";
    Tools.Warn("A newer version of this plugin is available");
  }
  static XRHitTestWithRay(xrSession, xrRay, referenceSpace, filter) {
    return xrSession.requestHitTest(xrRay, referenceSpace).then((results) => {
      const filterFunction = filter || ((result) => !!result.hitMatrix);
      return results.filter(filterFunction);
    });
  }
  static XRHitTestWithSelectEvent(event, referenceSpace) {
    const targetRayPose = event.frame.getPose(event.inputSource.targetRaySpace, referenceSpace);
    if (!targetRayPose) {
      return Promise.resolve([]);
    }
    const targetRay = new XRRay(targetRayPose.transform);
    return this.XRHitTestWithRay(event.frame.session, targetRay, referenceSpace);
  }
  attach() {
    if (!super.attach()) {
      return false;
    }
    if (this.options.testOnPointerDownOnly) {
      this._xrSessionManager.session.addEventListener("select", this._onSelect, false);
    }
    return true;
  }
  detach() {
    if (!super.detach()) {
      return false;
    }
    this._onSelectEnabled = false;
    this._xrSessionManager.session.removeEventListener("select", this._onSelect);
    return true;
  }
  dispose() {
    super.dispose();
    this.onHitTestResultObservable.clear();
  }
  _onXRFrame(frame) {
    if (!this.attached || this.options.testOnPointerDownOnly) {
      return;
    }
    const pose = frame.getViewerPose(this._xrSessionManager.referenceSpace);
    if (!pose) {
      return;
    }
    Matrix.FromArrayToRef(pose.transform.matrix, 0, this._mat);
    Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, this._mat, this._origin);
    Vector3.TransformCoordinatesFromFloatsToRef(0, 0, -1, this._mat, this._direction);
    this._direction.subtractInPlace(this._origin);
    this._direction.normalize();
    const ray = new XRRay({ x: this._origin.x, y: this._origin.y, z: this._origin.z, w: 0 }, { x: this._direction.x, y: this._direction.y, z: this._direction.z, w: 0 });
    WebXRHitTestLegacy.XRHitTestWithRay(this._xrSessionManager.session, ray, this._xrSessionManager.referenceSpace).then(this._onHitTestResults);
  }
};
WebXRHitTestLegacy.Name = WebXRFeatureName.HIT_TEST;
WebXRHitTestLegacy.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRHitTestLegacy.Name, (xrSessionManager, options) => {
  return () => new WebXRHitTestLegacy(xrSessionManager, options);
}, WebXRHitTestLegacy.Version, false);

// node_modules/@babylonjs/core/XR/features/WebXRAnchorSystem.js
var anchorIdProvider = 0;
var WebXRAnchorSystem = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, _options = {}) {
    super(_xrSessionManager);
    this._options = _options;
    this._lastFrameDetected = /* @__PURE__ */ new Set();
    this._trackedAnchors = [];
    this._futureAnchors = [];
    this.onAnchorAddedObservable = new Observable();
    this.onAnchorRemovedObservable = new Observable();
    this.onAnchorUpdatedObservable = new Observable();
    this._tmpVector = new Vector3();
    this._tmpQuaternion = new Quaternion();
    this.xrNativeFeatureName = "anchors";
  }
  set referenceSpaceForFrameAnchors(referenceSpace) {
    this._referenceSpaceForFrameAnchors = referenceSpace;
  }
  _populateTmpTransformation(position, rotationQuaternion) {
    this._tmpVector.copyFrom(position);
    this._tmpQuaternion.copyFrom(rotationQuaternion);
    if (!this._xrSessionManager.scene.useRightHandedSystem) {
      this._tmpVector.z *= -1;
      this._tmpQuaternion.z *= -1;
      this._tmpQuaternion.w *= -1;
    }
    return {
      position: this._tmpVector,
      rotationQuaternion: this._tmpQuaternion
    };
  }
  async addAnchorPointUsingHitTestResultAsync(hitTestResult, position = new Vector3(), rotationQuaternion = new Quaternion()) {
    this._populateTmpTransformation(position, rotationQuaternion);
    const m = new XRRigidTransform({ x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z }, { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w });
    if (!hitTestResult.xrHitResult.createAnchor) {
      this.detach();
      throw new Error("Anchors not enabled in this environment/browser");
    } else {
      try {
        const nativeAnchor = await hitTestResult.xrHitResult.createAnchor(m);
        return new Promise((resolve, reject) => {
          this._futureAnchors.push({
            nativeAnchor,
            resolved: false,
            submitted: true,
            xrTransformation: m,
            resolve,
            reject
          });
        });
      } catch (error) {
        throw new Error(error);
      }
    }
  }
  async addAnchorAtPositionAndRotationAsync(position, rotationQuaternion = new Quaternion(), forceCreateInCurrentFrame = false) {
    this._populateTmpTransformation(position, rotationQuaternion);
    const xrTransformation = new XRRigidTransform({ x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z }, { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w });
    const xrAnchor = forceCreateInCurrentFrame && this.attached && this._xrSessionManager.currentFrame ? await this._createAnchorAtTransformation(xrTransformation, this._xrSessionManager.currentFrame) : void 0;
    return new Promise((resolve, reject) => {
      this._futureAnchors.push({
        nativeAnchor: xrAnchor,
        resolved: false,
        submitted: false,
        xrTransformation,
        resolve,
        reject
      });
    });
  }
  get anchors() {
    return this._trackedAnchors;
  }
  detach() {
    if (!super.detach()) {
      return false;
    }
    if (!this._options.doNotRemoveAnchorsOnSessionEnded) {
      while (this._trackedAnchors.length) {
        const toRemove = this._trackedAnchors.pop();
        if (toRemove) {
          try {
            toRemove.remove();
          } catch (e) {
          }
          this.onAnchorRemovedObservable.notifyObservers(toRemove);
        }
      }
    }
    return true;
  }
  dispose() {
    this._futureAnchors.length = 0;
    super.dispose();
    this.onAnchorAddedObservable.clear();
    this.onAnchorRemovedObservable.clear();
    this.onAnchorUpdatedObservable.clear();
  }
  _onXRFrame(frame) {
    if (!this.attached || !frame) {
      return;
    }
    const trackedAnchors = frame.trackedAnchors;
    if (trackedAnchors) {
      const toRemove = this._trackedAnchors.filter((anchor) => !trackedAnchors.has(anchor.xrAnchor)).map((anchor) => {
        const index = this._trackedAnchors.indexOf(anchor);
        return index;
      });
      let idxTracker = 0;
      toRemove.forEach((index) => {
        const anchor = this._trackedAnchors.splice(index - idxTracker, 1)[0];
        this.onAnchorRemovedObservable.notifyObservers(anchor);
        idxTracker++;
      });
      trackedAnchors.forEach((xrAnchor) => {
        if (!this._lastFrameDetected.has(xrAnchor)) {
          const newAnchor = {
            id: anchorIdProvider++,
            xrAnchor,
            remove: () => xrAnchor.delete()
          };
          const anchor = this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);
          this._trackedAnchors.push(anchor);
          this.onAnchorAddedObservable.notifyObservers(anchor);
          const results = this._futureAnchors.filter((futureAnchor) => futureAnchor.nativeAnchor === xrAnchor);
          const result = results[0];
          if (result) {
            result.resolve(anchor);
            result.resolved = true;
          }
        } else {
          const index = this._findIndexInAnchorArray(xrAnchor);
          const anchor = this._trackedAnchors[index];
          try {
            this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);
            if (anchor.attachedNode) {
              anchor.attachedNode.rotationQuaternion = anchor.attachedNode.rotationQuaternion || new Quaternion();
              anchor.transformationMatrix.decompose(anchor.attachedNode.scaling, anchor.attachedNode.rotationQuaternion, anchor.attachedNode.position);
            }
            this.onAnchorUpdatedObservable.notifyObservers(anchor);
          } catch (e) {
            Tools.Warn(`Anchor could not be updated`);
          }
        }
      });
      this._lastFrameDetected = trackedAnchors;
    }
    this._futureAnchors.forEach((futureAnchor) => {
      if (!futureAnchor.resolved && !futureAnchor.submitted) {
        this._createAnchorAtTransformation(futureAnchor.xrTransformation, frame).then((nativeAnchor) => {
          futureAnchor.nativeAnchor = nativeAnchor;
        }, (error) => {
          futureAnchor.resolved = true;
          futureAnchor.reject(error);
        });
        futureAnchor.submitted = true;
      }
    });
  }
  _findIndexInAnchorArray(xrAnchor) {
    for (let i = 0; i < this._trackedAnchors.length; ++i) {
      if (this._trackedAnchors[i].xrAnchor === xrAnchor) {
        return i;
      }
    }
    return -1;
  }
  _updateAnchorWithXRFrame(xrAnchor, anchor, xrFrame) {
    const pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);
    if (pose) {
      const mat = anchor.transformationMatrix || new Matrix();
      Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);
      if (!this._xrSessionManager.scene.useRightHandedSystem) {
        mat.toggleModelMatrixHandInPlace();
      }
      anchor.transformationMatrix = mat;
      if (!this._options.worldParentNode) {
      } else {
        mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);
      }
    }
    return anchor;
  }
  async _createAnchorAtTransformation(xrTransformation, xrFrame) {
    var _a;
    if (xrFrame.createAnchor) {
      try {
        return xrFrame.createAnchor(xrTransformation, (_a = this._referenceSpaceForFrameAnchors) !== null && _a !== void 0 ? _a : this._xrSessionManager.referenceSpace);
      } catch (error) {
        throw new Error(error);
      }
    } else {
      this.detach();
      throw new Error("Anchors are not enabled in your browser");
    }
  }
};
WebXRAnchorSystem.Name = WebXRFeatureName.ANCHOR_SYSTEM;
WebXRAnchorSystem.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRAnchorSystem.Name, (xrSessionManager, options) => {
  return () => new WebXRAnchorSystem(xrSessionManager, options);
}, WebXRAnchorSystem.Version);

// node_modules/@babylonjs/core/XR/features/WebXRPlaneDetector.js
var planeIdProvider = 0;
var WebXRPlaneDetector = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, _options = {}) {
    super(_xrSessionManager);
    this._options = _options;
    this._detectedPlanes = [];
    this._enabled = false;
    this._lastFrameDetected = /* @__PURE__ */ new Set();
    this.onPlaneAddedObservable = new Observable();
    this.onPlaneRemovedObservable = new Observable();
    this.onPlaneUpdatedObservable = new Observable();
    this.xrNativeFeatureName = "plane-detection";
    if (this._xrSessionManager.session) {
      this._init();
    } else {
      this._xrSessionManager.onXRSessionInit.addOnce(() => {
        this._init();
      });
    }
  }
  detach() {
    if (!super.detach()) {
      return false;
    }
    if (!this._options.doNotRemovePlanesOnSessionEnded) {
      while (this._detectedPlanes.length) {
        const toRemove = this._detectedPlanes.pop();
        if (toRemove) {
          this.onPlaneRemovedObservable.notifyObservers(toRemove);
        }
      }
    }
    return true;
  }
  dispose() {
    super.dispose();
    this.onPlaneAddedObservable.clear();
    this.onPlaneRemovedObservable.clear();
    this.onPlaneUpdatedObservable.clear();
  }
  isCompatible() {
    return typeof XRPlane !== "undefined";
  }
  _onXRFrame(frame) {
    var _a;
    if (!this.attached || !this._enabled || !frame) {
      return;
    }
    const detectedPlanes = frame.detectedPlanes || ((_a = frame.worldInformation) === null || _a === void 0 ? void 0 : _a.detectedPlanes);
    if (detectedPlanes) {
      for (let planeIdx = 0; planeIdx < this._detectedPlanes.length; planeIdx++) {
        const plane = this._detectedPlanes[planeIdx];
        if (!detectedPlanes.has(plane.xrPlane)) {
          this._detectedPlanes.splice(planeIdx--, 1);
          this.onPlaneRemovedObservable.notifyObservers(plane);
        }
      }
      detectedPlanes.forEach((xrPlane) => {
        if (!this._lastFrameDetected.has(xrPlane)) {
          const newPlane = {
            id: planeIdProvider++,
            xrPlane,
            polygonDefinition: []
          };
          const plane = this._updatePlaneWithXRPlane(xrPlane, newPlane, frame);
          this._detectedPlanes.push(plane);
          this.onPlaneAddedObservable.notifyObservers(plane);
        } else {
          if (xrPlane.lastChangedTime === this._xrSessionManager.currentTimestamp) {
            const index = this._findIndexInPlaneArray(xrPlane);
            const plane = this._detectedPlanes[index];
            this._updatePlaneWithXRPlane(xrPlane, plane, frame);
            this.onPlaneUpdatedObservable.notifyObservers(plane);
          }
        }
      });
      this._lastFrameDetected = detectedPlanes;
    }
  }
  _init() {
    const internalInit = () => {
      this._enabled = true;
      if (this._detectedPlanes.length) {
        this._detectedPlanes.length = 0;
      }
    };
    if (!!this._xrSessionManager.isNative && !!this._options.preferredDetectorOptions && !!this._xrSessionManager.session.trySetPreferredPlaneDetectorOptions) {
      this._xrSessionManager.session.trySetPreferredPlaneDetectorOptions(this._options.preferredDetectorOptions);
    }
    if (!this._xrSessionManager.session.updateWorldTrackingState) {
      internalInit();
      return;
    }
    this._xrSessionManager.session.updateWorldTrackingState({ planeDetectionState: { enabled: true } });
    internalInit();
  }
  _updatePlaneWithXRPlane(xrPlane, plane, xrFrame) {
    plane.polygonDefinition = xrPlane.polygon.map((xrPoint) => {
      const rightHandedSystem = this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1;
      return new Vector3(xrPoint.x, xrPoint.y, xrPoint.z * rightHandedSystem);
    });
    const pose = xrFrame.getPose(xrPlane.planeSpace, this._xrSessionManager.referenceSpace);
    if (pose) {
      const mat = plane.transformationMatrix || new Matrix();
      Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);
      if (!this._xrSessionManager.scene.useRightHandedSystem) {
        mat.toggleModelMatrixHandInPlace();
      }
      plane.transformationMatrix = mat;
      if (this._options.worldParentNode) {
        mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);
      }
    }
    return plane;
  }
  _findIndexInPlaneArray(xrPlane) {
    for (let i = 0; i < this._detectedPlanes.length; ++i) {
      if (this._detectedPlanes[i].xrPlane === xrPlane) {
        return i;
      }
    }
    return -1;
  }
};
WebXRPlaneDetector.Name = WebXRFeatureName.PLANE_DETECTION;
WebXRPlaneDetector.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRPlaneDetector.Name, (xrSessionManager, options) => {
  return () => new WebXRPlaneDetector(xrSessionManager, options);
}, WebXRPlaneDetector.Version);

// node_modules/@babylonjs/core/XR/features/WebXRBackgroundRemover.js
var WebXRBackgroundRemover = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, options = {}) {
    super(_xrSessionManager);
    this.options = options;
    this.onBackgroundStateChangedObservable = new Observable();
  }
  attach() {
    this._setBackgroundState(false);
    return super.attach();
  }
  detach() {
    this._setBackgroundState(true);
    return super.detach();
  }
  dispose() {
    super.dispose();
    this.onBackgroundStateChangedObservable.clear();
  }
  _onXRFrame(_xrFrame) {
  }
  _setBackgroundState(newState) {
    const scene = this._xrSessionManager.scene;
    if (!this.options.ignoreEnvironmentHelper) {
      if (this.options.environmentHelperRemovalFlags) {
        if (this.options.environmentHelperRemovalFlags.skyBox) {
          const backgroundSkybox = scene.getMeshByName("BackgroundSkybox");
          if (backgroundSkybox) {
            backgroundSkybox.setEnabled(newState);
          }
        }
        if (this.options.environmentHelperRemovalFlags.ground) {
          const backgroundPlane = scene.getMeshByName("BackgroundPlane");
          if (backgroundPlane) {
            backgroundPlane.setEnabled(newState);
          }
        }
      } else {
        const backgroundHelper = scene.getMeshByName("BackgroundHelper");
        if (backgroundHelper) {
          backgroundHelper.setEnabled(newState);
        }
      }
    }
    if (this.options.backgroundMeshes) {
      this.options.backgroundMeshes.forEach((mesh) => mesh.setEnabled(newState));
    }
    this.onBackgroundStateChangedObservable.notifyObservers(newState);
  }
};
WebXRBackgroundRemover.Name = WebXRFeatureName.BACKGROUND_REMOVER;
WebXRBackgroundRemover.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRBackgroundRemover.Name, (xrSessionManager, options) => {
  return () => new WebXRBackgroundRemover(xrSessionManager, options);
}, WebXRBackgroundRemover.Version, true);

// node_modules/@babylonjs/core/XR/features/WebXRControllerPhysics.js
var IWebXRControllerPhysicsOptions = class {
};
var WebXRControllerPhysics = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, _options) {
    super(_xrSessionManager);
    this._options = _options;
    this._attachController = (xrController) => {
      if (this._controllers[xrController.uniqueId]) {
        return;
      }
      if (!this._xrSessionManager.scene.isPhysicsEnabled()) {
        Logger.Warn("physics engine not enabled, skipped. Please add this controller manually.");
      }
      if (this._options.physicsProperties.useControllerMesh && xrController.inputSource.gamepad) {
        xrController.onMotionControllerInitObservable.addOnce((motionController) => {
          if (!motionController._doNotLoadControllerMesh) {
            motionController.onModelLoadedObservable.addOnce(() => {
              const impostor = new PhysicsImpostor(motionController.rootMesh, PhysicsImpostor.MeshImpostor, {
                mass: 0,
                ...this._options.physicsProperties
              });
              const controllerMesh = xrController.grip || xrController.pointer;
              this._controllers[xrController.uniqueId] = {
                xrController,
                impostor,
                oldPos: controllerMesh.position.clone(),
                oldRotation: controllerMesh.rotationQuaternion.clone()
              };
            });
          } else {
            this._createPhysicsImpostor(xrController);
          }
        });
      } else {
        this._createPhysicsImpostor(xrController);
      }
    };
    this._controllers = {};
    this._debugMode = false;
    this._delta = 0;
    this._lastTimestamp = 0;
    this._tmpQuaternion = new Quaternion();
    this._tmpVector = new Vector3();
    if (!this._options.physicsProperties) {
      this._options.physicsProperties = {};
    }
  }
  _createPhysicsImpostor(xrController) {
    const impostorType = this._options.physicsProperties.impostorType || PhysicsImpostor.SphereImpostor;
    const impostorSize = this._options.physicsProperties.impostorSize || 0.1;
    const impostorMesh = CreateSphere("impostor-mesh-" + xrController.uniqueId, {
      diameterX: typeof impostorSize === "number" ? impostorSize : impostorSize.width,
      diameterY: typeof impostorSize === "number" ? impostorSize : impostorSize.height,
      diameterZ: typeof impostorSize === "number" ? impostorSize : impostorSize.depth
    });
    impostorMesh.isVisible = this._debugMode;
    impostorMesh.isPickable = false;
    impostorMesh.rotationQuaternion = new Quaternion();
    const controllerMesh = xrController.grip || xrController.pointer;
    impostorMesh.position.copyFrom(controllerMesh.position);
    impostorMesh.rotationQuaternion.copyFrom(controllerMesh.rotationQuaternion);
    const impostor = new PhysicsImpostor(impostorMesh, impostorType, {
      mass: 0,
      ...this._options.physicsProperties
    });
    this._controllers[xrController.uniqueId] = {
      xrController,
      impostor,
      impostorMesh
    };
  }
  _enablePhysicsDebug() {
    this._debugMode = true;
    Object.keys(this._controllers).forEach((controllerId) => {
      const controllerData = this._controllers[controllerId];
      if (controllerData.impostorMesh) {
        controllerData.impostorMesh.isVisible = true;
      }
    });
  }
  addController(xrController) {
    this._attachController(xrController);
  }
  attach() {
    if (!super.attach()) {
      return false;
    }
    if (!this._options.xrInput) {
      return true;
    }
    this._options.xrInput.controllers.forEach(this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {
      this._detachController(controller.uniqueId);
    });
    if (this._options.enableHeadsetImpostor) {
      const params = this._options.headsetImpostorParams || {
        impostorType: PhysicsImpostor.SphereImpostor,
        restitution: 0.8,
        impostorSize: 0.3
      };
      const impostorSize = params.impostorSize || 0.3;
      this._headsetMesh = CreateSphere("headset-mesh", {
        diameterX: typeof impostorSize === "number" ? impostorSize : impostorSize.width,
        diameterY: typeof impostorSize === "number" ? impostorSize : impostorSize.height,
        diameterZ: typeof impostorSize === "number" ? impostorSize : impostorSize.depth
      });
      this._headsetMesh.rotationQuaternion = new Quaternion();
      this._headsetMesh.isVisible = false;
      this._headsetImpostor = new PhysicsImpostor(this._headsetMesh, params.impostorType, { mass: 0, ...params });
    }
    return true;
  }
  detach() {
    if (!super.detach()) {
      return false;
    }
    Object.keys(this._controllers).forEach((controllerId) => {
      this._detachController(controllerId);
    });
    if (this._headsetMesh) {
      this._headsetMesh.dispose();
    }
    return true;
  }
  getHeadsetImpostor() {
    return this._headsetImpostor;
  }
  getImpostorForController(controller) {
    const id = typeof controller === "string" ? controller : controller.uniqueId;
    if (this._controllers[id]) {
      return this._controllers[id].impostor;
    } else {
      return null;
    }
  }
  setPhysicsProperties(newProperties) {
    this._options.physicsProperties = {
      ...this._options.physicsProperties,
      ...newProperties
    };
  }
  _onXRFrame(_xrFrame) {
    var _a, _b;
    this._delta = this._xrSessionManager.currentTimestamp - this._lastTimestamp;
    this._lastTimestamp = this._xrSessionManager.currentTimestamp;
    if (this._headsetMesh && this._headsetImpostor) {
      this._headsetMesh.position.copyFrom(this._options.xrInput.xrCamera.globalPosition);
      this._headsetMesh.rotationQuaternion.copyFrom(this._options.xrInput.xrCamera.absoluteRotation);
      if ((_a = this._options.xrInput.xrCamera._lastXRViewerPose) === null || _a === void 0 ? void 0 : _a.linearVelocity) {
        const lv = this._options.xrInput.xrCamera._lastXRViewerPose.linearVelocity;
        this._tmpVector.set(lv.x, lv.y, lv.z);
        this._headsetImpostor.setLinearVelocity(this._tmpVector);
      }
      if ((_b = this._options.xrInput.xrCamera._lastXRViewerPose) === null || _b === void 0 ? void 0 : _b.angularVelocity) {
        const av = this._options.xrInput.xrCamera._lastXRViewerPose.angularVelocity;
        this._tmpVector.set(av.x, av.y, av.z);
        this._headsetImpostor.setAngularVelocity(this._tmpVector);
      }
    }
    Object.keys(this._controllers).forEach((controllerId) => {
      var _a2, _b2;
      const controllerData = this._controllers[controllerId];
      const controllerMesh = controllerData.xrController.grip || controllerData.xrController.pointer;
      const comparedPosition = controllerData.oldPos || controllerData.impostorMesh.position;
      if ((_a2 = controllerData.xrController._lastXRPose) === null || _a2 === void 0 ? void 0 : _a2.linearVelocity) {
        const lv = controllerData.xrController._lastXRPose.linearVelocity;
        this._tmpVector.set(lv.x, lv.y, lv.z);
        controllerData.impostor.setLinearVelocity(this._tmpVector);
      } else {
        controllerMesh.position.subtractToRef(comparedPosition, this._tmpVector);
        this._tmpVector.scaleInPlace(1e3 / this._delta);
        controllerData.impostor.setLinearVelocity(this._tmpVector);
      }
      comparedPosition.copyFrom(controllerMesh.position);
      if (this._debugMode) {
        console.log(this._tmpVector, "linear");
      }
      const comparedQuaternion = controllerData.oldRotation || controllerData.impostorMesh.rotationQuaternion;
      if ((_b2 = controllerData.xrController._lastXRPose) === null || _b2 === void 0 ? void 0 : _b2.angularVelocity) {
        const av = controllerData.xrController._lastXRPose.angularVelocity;
        this._tmpVector.set(av.x, av.y, av.z);
        controllerData.impostor.setAngularVelocity(this._tmpVector);
      } else {
        if (!comparedQuaternion.equalsWithEpsilon(controllerMesh.rotationQuaternion)) {
          comparedQuaternion.conjugateInPlace().multiplyToRef(controllerMesh.rotationQuaternion, this._tmpQuaternion);
          const len = Math.sqrt(this._tmpQuaternion.x * this._tmpQuaternion.x + this._tmpQuaternion.y * this._tmpQuaternion.y + this._tmpQuaternion.z * this._tmpQuaternion.z);
          this._tmpVector.set(this._tmpQuaternion.x, this._tmpQuaternion.y, this._tmpQuaternion.z);
          if (len < 1e-3) {
            this._tmpVector.scaleInPlace(2);
          } else {
            const angle = 2 * Math.atan2(len, this._tmpQuaternion.w);
            this._tmpVector.scaleInPlace(angle / (len * (this._delta / 1e3)));
          }
          controllerData.impostor.setAngularVelocity(this._tmpVector);
        }
      }
      comparedQuaternion.copyFrom(controllerMesh.rotationQuaternion);
      if (this._debugMode) {
        console.log(this._tmpVector, this._tmpQuaternion, "angular");
      }
    });
  }
  _detachController(xrControllerUniqueId) {
    const controllerData = this._controllers[xrControllerUniqueId];
    if (!controllerData) {
      return;
    }
    if (controllerData.impostorMesh) {
      controllerData.impostorMesh.dispose();
    }
    delete this._controllers[xrControllerUniqueId];
  }
};
WebXRControllerPhysics.Name = WebXRFeatureName.PHYSICS_CONTROLLERS;
WebXRControllerPhysics.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRControllerPhysics.Name, (xrSessionManager, options) => {
  return () => new WebXRControllerPhysics(xrSessionManager, options);
}, WebXRControllerPhysics.Version, true);

// node_modules/@babylonjs/core/XR/features/WebXRHitTest.js
var WebXRHitTest = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, options = {}) {
    super(_xrSessionManager);
    this.options = options;
    this._tmpMat = new Matrix();
    this._tmpPos = new Vector3();
    this._tmpQuat = new Quaternion();
    this._initHitTestSource = (referenceSpace) => {
      if (!referenceSpace) {
        return;
      }
      const offsetRay = new XRRay(this.options.offsetRay || {});
      const hitTestOptions = {
        space: this.options.useReferenceSpace ? referenceSpace : this._xrSessionManager.viewerReferenceSpace,
        offsetRay
      };
      if (this.options.entityTypes) {
        hitTestOptions.entityTypes = this.options.entityTypes;
      }
      if (!hitTestOptions.space) {
        Tools.Warn("waiting for viewer reference space to initialize");
        return;
      }
      this._xrSessionManager.session.requestHitTestSource(hitTestOptions).then((hitTestSource) => {
        if (this._xrHitTestSource) {
          this._xrHitTestSource.cancel();
        }
        this._xrHitTestSource = hitTestSource;
      });
    };
    this.autoCloneTransformation = false;
    this.onHitTestResultObservable = new Observable();
    this.paused = false;
    this.xrNativeFeatureName = "hit-test";
    Tools.Warn("Hit test is an experimental and unstable feature.");
  }
  attach() {
    if (!super.attach()) {
      return false;
    }
    if (!this._xrSessionManager.session.requestHitTestSource) {
      return false;
    }
    if (!this.options.disablePermanentHitTest) {
      if (this._xrSessionManager.referenceSpace) {
        this._initHitTestSource(this._xrSessionManager.referenceSpace);
      }
      this._xrSessionManager.onXRReferenceSpaceChanged.add(this._initHitTestSource);
    }
    if (this.options.enableTransientHitTest) {
      const offsetRay = new XRRay(this.options.transientOffsetRay || {});
      this._xrSessionManager.session.requestHitTestSourceForTransientInput({
        profile: this.options.transientHitTestProfile || "generic-touchscreen",
        offsetRay,
        entityTypes: this.options.entityTypes
      }).then((hitSource) => {
        this._transientXrHitTestSource = hitSource;
      });
    }
    return true;
  }
  detach() {
    if (!super.detach()) {
      return false;
    }
    if (this._xrHitTestSource) {
      this._xrHitTestSource.cancel();
      this._xrHitTestSource = null;
    }
    this._xrSessionManager.onXRReferenceSpaceChanged.removeCallback(this._initHitTestSource);
    if (this._transientXrHitTestSource) {
      this._transientXrHitTestSource.cancel();
      this._transientXrHitTestSource = null;
    }
    return true;
  }
  dispose() {
    super.dispose();
    this.onHitTestResultObservable.clear();
  }
  _onXRFrame(frame) {
    if (!this.attached || this.paused) {
      return;
    }
    if (this._xrHitTestSource) {
      const results = frame.getHitTestResults(this._xrHitTestSource);
      this._processWebXRHitTestResult(results);
    }
    if (this._transientXrHitTestSource) {
      const hitTestResultsPerInputSource = frame.getHitTestResultsForTransientInput(this._transientXrHitTestSource);
      hitTestResultsPerInputSource.forEach((resultsPerInputSource) => {
        this._processWebXRHitTestResult(resultsPerInputSource.results, resultsPerInputSource.inputSource);
      });
    }
  }
  _processWebXRHitTestResult(hitTestResults, inputSource) {
    const results = [];
    hitTestResults.forEach((hitTestResult) => {
      const pose = hitTestResult.getPose(this._xrSessionManager.referenceSpace);
      if (!pose) {
        return;
      }
      const pos = pose.transform.position;
      const quat = pose.transform.orientation;
      this._tmpPos.set(pos.x, pos.y, pos.z);
      this._tmpQuat.set(quat.x, quat.y, quat.z, quat.w);
      Matrix.FromFloat32ArrayToRefScaled(pose.transform.matrix, 0, 1, this._tmpMat);
      if (!this._xrSessionManager.scene.useRightHandedSystem) {
        this._tmpPos.z *= -1;
        this._tmpQuat.z *= -1;
        this._tmpQuat.w *= -1;
        this._tmpMat.toggleModelMatrixHandInPlace();
      }
      const result = {
        position: this.autoCloneTransformation ? this._tmpPos.clone() : this._tmpPos,
        rotationQuaternion: this.autoCloneTransformation ? this._tmpQuat.clone() : this._tmpQuat,
        transformationMatrix: this.autoCloneTransformation ? this._tmpMat.clone() : this._tmpMat,
        inputSource,
        isTransient: !!inputSource,
        xrHitResult: hitTestResult
      };
      results.push(result);
    });
    this.onHitTestResultObservable.notifyObservers(results);
  }
};
WebXRHitTest.Name = WebXRFeatureName.HIT_TEST;
WebXRHitTest.Version = 2;
WebXRFeaturesManager.AddWebXRFeature(WebXRHitTest.Name, (xrSessionManager, options) => {
  return () => new WebXRHitTest(xrSessionManager, options);
}, WebXRHitTest.Version, false);

// node_modules/@babylonjs/core/XR/features/WebXRFeaturePointSystem.js
var WebXRFeaturePointSystem = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager) {
    super(_xrSessionManager);
    this._enabled = false;
    this._featurePointCloud = [];
    this.onFeaturePointsAddedObservable = new Observable();
    this.onFeaturePointsUpdatedObservable = new Observable();
    this.xrNativeFeatureName = "bjsfeature-points";
    if (this._xrSessionManager.session) {
      this._init();
    } else {
      this._xrSessionManager.onXRSessionInit.addOnce(() => {
        this._init();
      });
    }
  }
  get featurePointCloud() {
    return this._featurePointCloud;
  }
  detach() {
    if (!super.detach()) {
      return false;
    }
    this.featurePointCloud.length = 0;
    return true;
  }
  dispose() {
    super.dispose();
    this._featurePointCloud.length = 0;
    this.onFeaturePointsUpdatedObservable.clear();
    this.onFeaturePointsAddedObservable.clear();
  }
  _onXRFrame(frame) {
    if (!this.attached || !this._enabled || !frame) {
      return;
    }
    const featurePointRawData = frame.featurePointCloud;
    if (!featurePointRawData || featurePointRawData.length === 0) {
      return;
    } else {
      if (featurePointRawData.length % 5 !== 0) {
        throw new Error("Received malformed feature point cloud of length: " + featurePointRawData.length);
      }
      const numberOfFeaturePoints = featurePointRawData.length / 5;
      const updatedFeaturePoints = new Array();
      const addedFeaturePoints = new Array();
      for (let i = 0; i < numberOfFeaturePoints; i++) {
        const rawIndex = i * 5;
        const id = featurePointRawData[rawIndex + 4];
        if (!this._featurePointCloud[id]) {
          this._featurePointCloud[id] = { position: new Vector3(), confidenceValue: 0 };
          addedFeaturePoints.push(id);
        } else {
          updatedFeaturePoints.push(id);
        }
        this._featurePointCloud[id].position.x = featurePointRawData[rawIndex];
        this._featurePointCloud[id].position.y = featurePointRawData[rawIndex + 1];
        this._featurePointCloud[id].position.z = featurePointRawData[rawIndex + 2];
        this._featurePointCloud[id].confidenceValue = featurePointRawData[rawIndex + 3];
      }
      if (addedFeaturePoints.length > 0) {
        this.onFeaturePointsAddedObservable.notifyObservers(addedFeaturePoints);
      }
      if (updatedFeaturePoints.length > 0) {
        this.onFeaturePointsUpdatedObservable.notifyObservers(updatedFeaturePoints);
      }
    }
  }
  _init() {
    if (!this._xrSessionManager.session.trySetFeaturePointCloudEnabled || !this._xrSessionManager.session.trySetFeaturePointCloudEnabled(true)) {
      return;
    }
    this._enabled = true;
  }
};
WebXRFeaturePointSystem.Name = WebXRFeatureName.FEATURE_POINTS;
WebXRFeaturePointSystem.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRFeaturePointSystem.Name, (xrSessionManager) => {
  return () => new WebXRFeaturePointSystem(xrSessionManager);
}, WebXRFeaturePointSystem.Version);

// node_modules/@babylonjs/core/XR/features/WebXRMeshDetector.js
var meshIdProvider = 0;
var WebXRMeshDetector = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, _options = {}) {
    super(_xrSessionManager);
    this._options = _options;
    this._detectedMeshes = /* @__PURE__ */ new Map();
    this.onMeshAddedObservable = new Observable();
    this.onMeshRemovedObservable = new Observable();
    this.onMeshUpdatedObservable = new Observable();
    this.xrNativeFeatureName = "mesh-detection";
    if (this._xrSessionManager.session) {
      this._init();
    } else {
      this._xrSessionManager.onXRSessionInit.addOnce(() => {
        this._init();
      });
    }
  }
  detach() {
    if (!super.detach()) {
      return false;
    }
    if (!!this._xrSessionManager.isNative && !!this._xrSessionManager.session.trySetMeshDetectorEnabled) {
      this._xrSessionManager.session.trySetMeshDetectorEnabled(false);
    }
    if (!this._options.doNotRemoveMeshesOnSessionEnded) {
      this._detectedMeshes.forEach((mesh) => {
        this.onMeshRemovedObservable.notifyObservers(mesh);
      });
      this._detectedMeshes.clear();
    }
    return true;
  }
  dispose() {
    super.dispose();
    this.onMeshAddedObservable.clear();
    this.onMeshRemovedObservable.clear();
    this.onMeshUpdatedObservable.clear();
  }
  _onXRFrame(frame) {
    var _a;
    try {
      if (!this.attached || !frame) {
        return;
      }
      const detectedMeshes = (_a = frame.worldInformation) === null || _a === void 0 ? void 0 : _a.detectedMeshes;
      if (detectedMeshes) {
        const toRemove = /* @__PURE__ */ new Set();
        this._detectedMeshes.forEach((vertexData, xrMesh) => {
          if (!detectedMeshes.has(xrMesh)) {
            toRemove.add(xrMesh);
          }
        });
        toRemove.forEach((xrMesh) => {
          const vertexData = this._detectedMeshes.get(xrMesh);
          if (vertexData) {
            this.onMeshRemovedObservable.notifyObservers(vertexData);
            this._detectedMeshes.delete(xrMesh);
          }
        });
        detectedMeshes.forEach((xrMesh) => {
          if (!this._detectedMeshes.has(xrMesh)) {
            const partialVertexData = {
              id: meshIdProvider++,
              xrMesh
            };
            const vertexData = this._updateVertexDataWithXRMesh(xrMesh, partialVertexData, frame);
            this._detectedMeshes.set(xrMesh, vertexData);
            this.onMeshAddedObservable.notifyObservers(vertexData);
          } else {
            if (xrMesh.lastChangedTime === this._xrSessionManager.currentTimestamp) {
              const vertexData = this._detectedMeshes.get(xrMesh);
              if (vertexData) {
                this._updateVertexDataWithXRMesh(xrMesh, vertexData, frame);
                this.onMeshUpdatedObservable.notifyObservers(vertexData);
              }
            }
          }
        });
      }
    } catch (error) {
      console.log(error.stack);
    }
  }
  _init() {
    if (this._xrSessionManager.isNative) {
      if (this._xrSessionManager.session.trySetMeshDetectorEnabled) {
        this._xrSessionManager.session.trySetMeshDetectorEnabled(true);
      }
      if (!!this._options.preferredDetectorOptions && !!this._xrSessionManager.session.trySetPreferredMeshDetectorOptions) {
        this._xrSessionManager.session.trySetPreferredMeshDetectorOptions(this._options.preferredDetectorOptions);
      }
    }
  }
  _updateVertexDataWithXRMesh(xrMesh, mesh, xrFrame) {
    mesh.xrMesh = xrMesh;
    mesh.worldParentNode = this._options.worldParentNode;
    if (this._options.convertCoordinateSystems) {
      if (!this._xrSessionManager.scene.useRightHandedSystem) {
        mesh.positions = new Float32Array(xrMesh.positions.length);
        for (let i = 0; i < xrMesh.positions.length; i += 3) {
          mesh.positions[i] = xrMesh.positions[i];
          mesh.positions[i + 1] = xrMesh.positions[i + 1];
          mesh.positions[i + 2] = -1 * xrMesh.positions[i + 2];
        }
        if (xrMesh.normals) {
          mesh.normals = new Float32Array(xrMesh.normals.length);
          for (let i = 0; i < xrMesh.normals.length; i += 3) {
            mesh.normals[i] = xrMesh.normals[i];
            mesh.normals[i + 1] = xrMesh.normals[i + 1];
            mesh.normals[i + 2] = -1 * xrMesh.normals[i + 2];
          }
        }
      } else {
        mesh.positions = xrMesh.positions;
        mesh.normals = xrMesh.normals;
      }
      mesh.indices = xrMesh.indices;
      const pose = xrFrame.getPose(xrMesh.meshSpace, this._xrSessionManager.referenceSpace);
      if (pose) {
        const mat = mesh.transformationMatrix || new Matrix();
        Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);
        if (!this._xrSessionManager.scene.useRightHandedSystem) {
          mat.toggleModelMatrixHandInPlace();
        }
        mesh.transformationMatrix = mat;
        if (this._options.worldParentNode) {
          mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);
        }
      }
    }
    return mesh;
  }
};
WebXRMeshDetector.Name = WebXRFeatureName.MESH_DETECTION;
WebXRMeshDetector.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRMeshDetector.Name, (xrSessionManager, options) => {
  return () => new WebXRMeshDetector(xrSessionManager, options);
}, WebXRMeshDetector.Version, false);

// node_modules/@babylonjs/core/XR/features/WebXRImageTracking.js
var ImageTrackingScoreStatus;
(function(ImageTrackingScoreStatus2) {
  ImageTrackingScoreStatus2[ImageTrackingScoreStatus2["NotReceived"] = 0] = "NotReceived";
  ImageTrackingScoreStatus2[ImageTrackingScoreStatus2["Waiting"] = 1] = "Waiting";
  ImageTrackingScoreStatus2[ImageTrackingScoreStatus2["Received"] = 2] = "Received";
})(ImageTrackingScoreStatus || (ImageTrackingScoreStatus = {}));
var WebXRImageTracking = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, options) {
    super(_xrSessionManager);
    this.options = options;
    this.onUntrackableImageFoundObservable = new Observable();
    this.onTrackableImageFoundObservable = new Observable();
    this.onTrackedImageUpdatedObservable = new Observable();
    this._trackableScoreStatus = ImageTrackingScoreStatus.NotReceived;
    this._trackedImages = [];
    this.xrNativeFeatureName = "image-tracking";
  }
  attach() {
    return super.attach();
  }
  detach() {
    return super.detach();
  }
  getTrackedImageById(id) {
    return this._trackedImages[id] || null;
  }
  dispose() {
    super.dispose();
    this._trackedImages.forEach((trackedImage) => {
      trackedImage.originalBitmap.close();
    });
    this._trackedImages.length = 0;
    this.onTrackableImageFoundObservable.clear();
    this.onUntrackableImageFoundObservable.clear();
    this.onTrackedImageUpdatedObservable.clear();
  }
  async getXRSessionInitExtension() {
    if (!this.options.images || !this.options.images.length) {
      return {};
    }
    const promises = this.options.images.map((image) => {
      if (typeof image.src === "string") {
        return this._xrSessionManager.scene.getEngine()._createImageBitmapFromSource(image.src);
      } else {
        return Promise.resolve(image.src);
      }
    });
    try {
      const images = await Promise.all(promises);
      this._originalTrackingRequest = images.map((image, idx) => {
        return {
          image,
          widthInMeters: this.options.images[idx].estimatedRealWorldWidth
        };
      });
      return {
        trackedImages: this._originalTrackingRequest
      };
    } catch (ex) {
      Tools.Error("Error loading images for tracking, WebXRImageTracking disabled for this session.");
      return {};
    }
  }
  _onXRFrame(_xrFrame) {
    if (!_xrFrame.getImageTrackingResults || this._trackableScoreStatus === ImageTrackingScoreStatus.Waiting) {
      return;
    }
    if (this._trackableScoreStatus === ImageTrackingScoreStatus.NotReceived) {
      this._checkScoresAsync();
      return;
    }
    const imageTrackedResults = _xrFrame.getImageTrackingResults();
    for (const result of imageTrackedResults) {
      let changed = false;
      const imageIndex = result.index;
      const imageObject = this._trackedImages[imageIndex];
      if (!imageObject) {
        continue;
      }
      imageObject.xrTrackingResult = result;
      if (imageObject.realWorldWidth !== result.measuredWidthInMeters) {
        imageObject.realWorldWidth = result.measuredWidthInMeters;
        changed = true;
      }
      const pose = _xrFrame.getPose(result.imageSpace, this._xrSessionManager.referenceSpace);
      if (pose) {
        const mat = imageObject.transformationMatrix;
        Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);
        if (!this._xrSessionManager.scene.useRightHandedSystem) {
          mat.toggleModelMatrixHandInPlace();
        }
        changed = true;
      }
      const state = result.trackingState;
      const emulated = state === "emulated";
      if (imageObject.emulated !== emulated) {
        imageObject.emulated = emulated;
        changed = true;
      }
      if (changed) {
        this.onTrackedImageUpdatedObservable.notifyObservers(imageObject);
      }
    }
  }
  async _checkScoresAsync() {
    if (!this._xrSessionManager.session.getTrackedImageScores || this._trackableScoreStatus !== ImageTrackingScoreStatus.NotReceived) {
      return;
    }
    this._trackableScoreStatus = ImageTrackingScoreStatus.Waiting;
    const imageScores = await this._xrSessionManager.session.getTrackedImageScores();
    if (!imageScores || imageScores.length === 0) {
      this._trackableScoreStatus = ImageTrackingScoreStatus.NotReceived;
      return;
    }
    for (let idx = 0; idx < imageScores.length; ++idx) {
      if (imageScores[idx] == "untrackable") {
        this.onUntrackableImageFoundObservable.notifyObservers(idx);
      } else {
        const originalBitmap = this._originalTrackingRequest[idx].image;
        const imageObject = {
          id: idx,
          originalBitmap,
          transformationMatrix: new Matrix(),
          ratio: originalBitmap.width / originalBitmap.height
        };
        this._trackedImages[idx] = imageObject;
        this.onTrackableImageFoundObservable.notifyObservers(imageObject);
      }
    }
    this._trackableScoreStatus = imageScores.length > 0 ? ImageTrackingScoreStatus.Received : ImageTrackingScoreStatus.NotReceived;
  }
};
WebXRImageTracking.Name = WebXRFeatureName.IMAGE_TRACKING;
WebXRImageTracking.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRImageTracking.Name, (xrSessionManager, options) => {
  return () => new WebXRImageTracking(xrSessionManager, options);
}, WebXRImageTracking.Version, false);

// node_modules/@babylonjs/core/XR/features/WebXRDOMOverlay.js
var WebXRDomOverlay = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, options) {
    super(_xrSessionManager);
    this.options = options;
    this._domOverlayType = null;
    this._beforeXRSelectListener = null;
    this._element = null;
    this.xrNativeFeatureName = "dom-overlay";
    Tools.Warn("dom-overlay is an experimental and unstable feature.");
  }
  attach() {
    if (!super.attach()) {
      return false;
    }
    if (!this._xrSessionManager.session.domOverlayState || this._xrSessionManager.session.domOverlayState.type === null) {
      return false;
    }
    this._domOverlayType = this._xrSessionManager.session.domOverlayState.type;
    if (this._element !== null && this.options.supressXRSelectEvents === true) {
      this._beforeXRSelectListener = (ev) => {
        ev.preventDefault();
      };
      this._element.addEventListener("beforexrselect", this._beforeXRSelectListener);
    }
    return true;
  }
  get domOverlayType() {
    return this._domOverlayType;
  }
  dispose() {
    super.dispose();
    if (this._element !== null && this._beforeXRSelectListener) {
      this._element.removeEventListener("beforexrselect", this._beforeXRSelectListener);
    }
  }
  _onXRFrame(_xrFrame) {
  }
  async getXRSessionInitExtension() {
    if (this.options.element === void 0) {
      Tools.Warn('"element" option must be provided to attach xr-dom-overlay feature.');
      return {};
    } else if (typeof this.options.element === "string") {
      const selectedElement = document.querySelector(this.options.element);
      if (selectedElement === null) {
        Tools.Warn(`element not found '${this.options.element}' (not requesting xr-dom-overlay)`);
        return {};
      }
      this._element = selectedElement;
    } else {
      this._element = this.options.element;
    }
    return {
      domOverlay: {
        root: this._element
      }
    };
  }
};
WebXRDomOverlay.Name = WebXRFeatureName.DOM_OVERLAY;
WebXRDomOverlay.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRDomOverlay.Name, (xrSessionManager, options) => {
  return () => new WebXRDomOverlay(xrSessionManager, options);
}, WebXRDomOverlay.Version, false);

// node_modules/@babylonjs/core/XR/features/WebXRControllerMovement.js
var WebXRControllerMovement = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, options) {
    var _a, _b, _c, _d, _e, _f;
    super(_xrSessionManager);
    this._controllers = {};
    this._currentRegistrationConfigurations = [];
    this._movementDirection = null;
    this._tmpRotationMatrix = Matrix.Identity();
    this._tmpTranslationDirection = new Vector3();
    this._tmpMovementTranslation = new Vector3();
    this._attachController = (xrController) => {
      if (this._controllers[xrController.uniqueId]) {
        return;
      }
      this._controllers[xrController.uniqueId] = {
        xrController,
        registeredComponents: []
      };
      const controllerData = this._controllers[xrController.uniqueId];
      if (controllerData.xrController.inputSource.targetRayMode === "tracked-pointer" && controllerData.xrController.inputSource.gamepad) {
        const initController = () => {
          if (xrController.motionController) {
            for (const registration of this._currentRegistrationConfigurations) {
              let component = null;
              if (registration.allowedComponentTypes) {
                for (const componentType of registration.allowedComponentTypes) {
                  const componentOfType = xrController.motionController.getComponentOfType(componentType);
                  if (componentOfType !== null) {
                    component = componentOfType;
                    break;
                  }
                }
              }
              if (registration.mainComponentOnly) {
                const mainComponent = xrController.motionController.getMainComponent();
                if (mainComponent === null) {
                  continue;
                }
                component = mainComponent;
              }
              if (typeof registration.componentSelectionPredicate === "function") {
                component = registration.componentSelectionPredicate(xrController);
              }
              if (component && registration.forceHandedness) {
                if (xrController.inputSource.handedness !== registration.forceHandedness) {
                  continue;
                }
              }
              if (component === null) {
                continue;
              }
              const registeredComponent = {
                registrationConfiguration: registration,
                component
              };
              controllerData.registeredComponents.push(registeredComponent);
              if ("axisChangedHandler" in registration) {
                registeredComponent.onAxisChangedObserver = component.onAxisValueChangedObservable.add((axesData) => {
                  registration.axisChangedHandler(axesData, this._movementState, this._featureContext, this._xrInput);
                });
              }
              if ("buttonChangedhandler" in registration) {
                registeredComponent.onButtonChangedObserver = component.onButtonStateChangedObservable.add(() => {
                  if (component.changes.pressed) {
                    registration.buttonChangedhandler(component.changes.pressed, this._movementState, this._featureContext, this._xrInput);
                  }
                });
              }
            }
          }
        };
        if (xrController.motionController) {
          initController();
        } else {
          xrController.onMotionControllerInitObservable.addOnce(() => {
            initController();
          });
        }
      }
    };
    if (!options || options.xrInput === void 0) {
      Tools.Error('WebXRControllerMovement feature requires "xrInput" option.');
      return;
    }
    if (Array.isArray(options.customRegistrationConfigurations)) {
      this._currentRegistrationConfigurations = options.customRegistrationConfigurations;
    } else {
      this._currentRegistrationConfigurations = WebXRControllerMovement.REGISTRATIONS.default;
    }
    this._featureContext = {
      movementEnabled: options.movementEnabled || true,
      movementOrientationFollowsViewerPose: (_a = options.movementOrientationFollowsViewerPose) !== null && _a !== void 0 ? _a : true,
      movementSpeed: (_b = options.movementSpeed) !== null && _b !== void 0 ? _b : 1,
      movementThreshold: (_c = options.movementThreshold) !== null && _c !== void 0 ? _c : 0.25,
      rotationEnabled: (_d = options.rotationEnabled) !== null && _d !== void 0 ? _d : true,
      rotationSpeed: (_e = options.rotationSpeed) !== null && _e !== void 0 ? _e : 1,
      rotationThreshold: (_f = options.rotationThreshold) !== null && _f !== void 0 ? _f : 0.25
    };
    this._movementState = {
      moveX: 0,
      moveY: 0,
      rotateX: 0,
      rotateY: 0
    };
    this._xrInput = options.xrInput;
  }
  get movementDirection() {
    return this._movementDirection;
  }
  get movementEnabled() {
    return this._featureContext.movementEnabled;
  }
  set movementEnabled(enabled) {
    this._featureContext.movementEnabled = enabled;
  }
  get movementOrientationFollowsViewerPose() {
    return this._featureContext.movementOrientationFollowsViewerPose;
  }
  set movementOrientationFollowsViewerPose(followsPose) {
    this._featureContext.movementOrientationFollowsViewerPose = followsPose;
  }
  get movementSpeed() {
    return this._featureContext.movementSpeed;
  }
  set movementSpeed(movementSpeed) {
    this._featureContext.movementSpeed = movementSpeed;
  }
  get movementThreshold() {
    return this._featureContext.movementThreshold;
  }
  set movementThreshold(movementThreshold) {
    this._featureContext.movementThreshold = movementThreshold;
  }
  get rotationEnabled() {
    return this._featureContext.rotationEnabled;
  }
  set rotationEnabled(enabled) {
    this._featureContext.rotationEnabled = enabled;
  }
  get rotationSpeed() {
    return this._featureContext.rotationSpeed;
  }
  set rotationSpeed(rotationSpeed) {
    this._featureContext.rotationSpeed = rotationSpeed;
  }
  get rotationThreshold() {
    return this._featureContext.rotationThreshold;
  }
  set rotationThreshold(threshold) {
    this._featureContext.rotationThreshold = threshold;
  }
  attach() {
    if (!super.attach()) {
      return false;
    }
    this._xrInput.controllers.forEach(this._attachController);
    this._addNewAttachObserver(this._xrInput.onControllerAddedObservable, this._attachController);
    this._addNewAttachObserver(this._xrInput.onControllerRemovedObservable, (controller) => {
      this._detachController(controller.uniqueId);
    });
    return true;
  }
  detach() {
    if (!super.detach()) {
      return false;
    }
    Object.keys(this._controllers).forEach((controllerId) => {
      this._detachController(controllerId);
    });
    this._controllers = {};
    return true;
  }
  _onXRFrame(_xrFrame) {
    if (!this.attach) {
      return;
    }
    if (this._movementDirection === null) {
      this._movementDirection = this._xrInput.xrCamera.rotationQuaternion.clone();
    }
    if (this._movementState.rotateX !== 0 && this._featureContext.rotationEnabled) {
      const deltaMillis = this._xrSessionManager.scene.getEngine().getDeltaTime();
      const rotationY = deltaMillis * 1e-3 * this._featureContext.rotationSpeed * this._movementState.rotateX * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);
      if (this._featureContext.movementOrientationFollowsViewerPose === true) {
        this._xrInput.xrCamera.cameraRotation.y += rotationY;
        this._movementDirection = this._xrInput.xrCamera.rotationQuaternion.multiply(Quaternion.RotationYawPitchRoll(rotationY, 0, 0));
      } else {
        this._movementDirection.multiplyInPlace(Quaternion.RotationYawPitchRoll(rotationY * 3, 0, 0));
      }
    } else if (this._featureContext.movementOrientationFollowsViewerPose === true) {
      this._movementDirection.copyFrom(this._xrInput.xrCamera.rotationQuaternion);
    }
    if ((this._movementState.moveX !== 0 || this._movementState.moveY !== 0) && this._featureContext.movementEnabled) {
      Matrix.FromQuaternionToRef(this._movementDirection, this._tmpRotationMatrix);
      this._tmpTranslationDirection.set(this._movementState.moveX, 0, this._movementState.moveY * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1));
      Vector3.TransformCoordinatesToRef(this._tmpTranslationDirection, this._tmpRotationMatrix, this._tmpMovementTranslation);
      this._tmpMovementTranslation.scaleInPlace(this._xrInput.xrCamera._computeLocalCameraSpeed() * this._featureContext.movementSpeed);
      this._xrInput.xrCamera.cameraDirection.addInPlace(this._tmpMovementTranslation);
    }
  }
  _detachController(xrControllerUniqueId) {
    const controllerData = this._controllers[xrControllerUniqueId];
    if (!controllerData) {
      return;
    }
    for (const registeredComponent of controllerData.registeredComponents) {
      if (registeredComponent.onAxisChangedObserver) {
        registeredComponent.component.onAxisValueChangedObservable.remove(registeredComponent.onAxisChangedObserver);
      }
      if (registeredComponent.onButtonChangedObserver) {
        registeredComponent.component.onButtonStateChangedObservable.remove(registeredComponent.onButtonChangedObserver);
      }
    }
    delete this._controllers[xrControllerUniqueId];
  }
};
WebXRControllerMovement.Name = WebXRFeatureName.MOVEMENT;
WebXRControllerMovement.REGISTRATIONS = {
  default: [
    {
      allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],
      forceHandedness: "left",
      axisChangedHandler: (axes, movementState, featureContext) => {
        movementState.rotateX = Math.abs(axes.x) > featureContext.rotationThreshold ? axes.x : 0;
        movementState.rotateY = Math.abs(axes.y) > featureContext.rotationThreshold ? axes.y : 0;
      }
    },
    {
      allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],
      forceHandedness: "right",
      axisChangedHandler: (axes, movementState, featureContext) => {
        movementState.moveX = Math.abs(axes.x) > featureContext.movementThreshold ? axes.x : 0;
        movementState.moveY = Math.abs(axes.y) > featureContext.movementThreshold ? axes.y : 0;
      }
    }
  ]
};
WebXRControllerMovement.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRControllerMovement.Name, (xrSessionManager, options) => {
  return () => new WebXRControllerMovement(xrSessionManager, options);
}, WebXRControllerMovement.Version, true);

// node_modules/@babylonjs/core/XR/features/WebXRLightEstimation.js
var WebXRLightEstimation = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, options) {
    super(_xrSessionManager);
    this.options = options;
    this._canvasContext = null;
    this._reflectionCubeMap = null;
    this._xrLightEstimate = null;
    this._xrLightProbe = null;
    this._xrWebGLBinding = null;
    this._lightDirection = Vector3.Up().negateInPlace();
    this._lightColor = Color3.White();
    this._intensity = 1;
    this._sphericalHarmonics = new SphericalHarmonics();
    this._cubeMapPollTime = Date.now();
    this._lightEstimationPollTime = Date.now();
    this._reflectionCubeMapTextureSize = 16;
    this.directionalLight = null;
    this.onReflectionCubeMapUpdatedObservable = new Observable();
    this._updateReflectionCubeMap = () => {
      var _a;
      if (!this._xrLightProbe) {
        return;
      }
      if (this.options.cubeMapPollInterval) {
        const now = Date.now();
        if (now - this._cubeMapPollTime < this.options.cubeMapPollInterval) {
          return;
        }
        this._cubeMapPollTime = now;
      }
      const lp = this._getXRGLBinding().getReflectionCubeMap(this._xrLightProbe);
      if (lp && this._reflectionCubeMap) {
        if (!this._reflectionCubeMap._texture) {
          const internalTexture = new InternalTexture(this._xrSessionManager.scene.getEngine(), InternalTextureSource.Unknown);
          internalTexture.isCube = true;
          internalTexture.invertY = false;
          internalTexture._useSRGBBuffer = this.options.reflectionFormat === "srgba8";
          internalTexture.format = 5;
          internalTexture.generateMipMaps = true;
          internalTexture.type = this.options.reflectionFormat !== "srgba8" ? 2 : 0;
          internalTexture.samplingMode = 3;
          internalTexture.width = this._reflectionCubeMapTextureSize;
          internalTexture.height = this._reflectionCubeMapTextureSize;
          internalTexture._cachedWrapU = 1;
          internalTexture._cachedWrapV = 1;
          internalTexture._hardwareTexture = new WebGLHardwareTexture(lp, this._getCanvasContext());
          this._reflectionCubeMap._texture = internalTexture;
        } else {
          (_a = this._reflectionCubeMap._texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.set(lp);
          this._reflectionCubeMap._texture.getEngine().resetTextureCache();
        }
        this._reflectionCubeMap._texture.isReady = true;
        this._xrSessionManager.scene.markAllMaterialsAsDirty(1);
        this.onReflectionCubeMapUpdatedObservable.notifyObservers(this._reflectionCubeMap);
      }
    };
    this.xrNativeFeatureName = "light-estimation";
    if (this.options.createDirectionalLightSource) {
      this.directionalLight = new DirectionalLight("light estimation directional", this._lightDirection, this._xrSessionManager.scene);
      this.directionalLight.position = new Vector3(0, 8, 0);
      this.directionalLight.intensity = 0;
      this.directionalLight.falloffType = LightConstants.FALLOFF_GLTF;
    }
    Tools.Warn("light-estimation is an experimental and unstable feature.");
  }
  get reflectionCubeMapTexture() {
    return this._reflectionCubeMap;
  }
  get xrLightingEstimate() {
    if (this._xrLightEstimate) {
      return {
        lightColor: this._lightColor,
        lightDirection: this._lightDirection,
        lightIntensity: this._intensity,
        sphericalHarmonics: this._sphericalHarmonics
      };
    }
    return this._xrLightEstimate;
  }
  _getCanvasContext() {
    if (this._canvasContext === null) {
      this._canvasContext = this._xrSessionManager.scene.getEngine()._gl;
    }
    return this._canvasContext;
  }
  _getXRGLBinding() {
    if (this._xrWebGLBinding === null) {
      const context = this._getCanvasContext();
      this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, context);
    }
    return this._xrWebGLBinding;
  }
  attach() {
    var _a;
    if (!super.attach()) {
      return false;
    }
    const reflectionFormat = (_a = this.options.reflectionFormat) !== null && _a !== void 0 ? _a : this._xrSessionManager.session.preferredReflectionFormat || "srgba8";
    this.options.reflectionFormat = reflectionFormat;
    this._xrSessionManager.session.requestLightProbe({
      reflectionFormat
    }).then((xrLightProbe) => {
      this._xrLightProbe = xrLightProbe;
      if (!this.options.disableCubeMapReflection) {
        if (!this._reflectionCubeMap) {
          this._reflectionCubeMap = new BaseTexture(this._xrSessionManager.scene);
          this._reflectionCubeMap._isCube = true;
          this._reflectionCubeMap.coordinatesMode = 3;
          if (this.options.setSceneEnvironmentTexture) {
            this._xrSessionManager.scene.environmentTexture = this._reflectionCubeMap;
          }
        }
        this._xrLightProbe.addEventListener("reflectionchange", this._updateReflectionCubeMap);
      }
    });
    return true;
  }
  detach() {
    const detached = super.detach();
    if (this._xrLightProbe !== null && !this.options.disableCubeMapReflection) {
      this._xrLightProbe.removeEventListener("reflectionchange", this._updateReflectionCubeMap);
      this._xrLightProbe = null;
    }
    this._canvasContext = null;
    this._xrLightEstimate = null;
    this._xrWebGLBinding = null;
    return detached;
  }
  dispose() {
    super.dispose();
    this.onReflectionCubeMapUpdatedObservable.clear();
    if (this.directionalLight) {
      this.directionalLight.dispose();
      this.directionalLight = null;
    }
    if (this._reflectionCubeMap !== null) {
      if (this._reflectionCubeMap._texture) {
        this._reflectionCubeMap._texture.dispose();
      }
      this._reflectionCubeMap.dispose();
      this._reflectionCubeMap = null;
    }
  }
  _onXRFrame(_xrFrame) {
    var _a;
    if (this._xrLightProbe !== null) {
      if (this.options.lightEstimationPollInterval) {
        const now = Date.now();
        if (now - this._lightEstimationPollTime < this.options.lightEstimationPollInterval) {
          return;
        }
        this._lightEstimationPollTime = now;
      }
      this._xrLightEstimate = _xrFrame.getLightEstimate(this._xrLightProbe);
      if (this._xrLightEstimate) {
        this._intensity = Math.max(1, this._xrLightEstimate.primaryLightIntensity.x, this._xrLightEstimate.primaryLightIntensity.y, this._xrLightEstimate.primaryLightIntensity.z);
        const rhsFactor = this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1;
        if (this.options.disableVectorReuse) {
          this._lightDirection = new Vector3();
          this._lightColor = new Color3();
          if (this.directionalLight) {
            this.directionalLight.direction = this._lightDirection;
            this.directionalLight.diffuse = this._lightColor;
          }
        }
        this._lightDirection.copyFromFloats(this._xrLightEstimate.primaryLightDirection.x, this._xrLightEstimate.primaryLightDirection.y, this._xrLightEstimate.primaryLightDirection.z * rhsFactor);
        this._lightColor.copyFromFloats(this._xrLightEstimate.primaryLightIntensity.x / this._intensity, this._xrLightEstimate.primaryLightIntensity.y / this._intensity, this._xrLightEstimate.primaryLightIntensity.z / this._intensity);
        this._sphericalHarmonics.updateFromFloatsArray(this._xrLightEstimate.sphericalHarmonicsCoefficients);
        if (this._reflectionCubeMap && !this.options.disableSphericalPolynomial) {
          this._reflectionCubeMap.sphericalPolynomial = this._reflectionCubeMap.sphericalPolynomial || new SphericalPolynomial();
          (_a = this._reflectionCubeMap.sphericalPolynomial) === null || _a === void 0 ? void 0 : _a.updateFromHarmonics(this._sphericalHarmonics);
        }
        this._lightDirection.negateInPlace();
        if (this.directionalLight) {
          this.directionalLight.direction.copyFrom(this._lightDirection);
          this.directionalLight.intensity = Math.min(this._intensity, 1);
          this.directionalLight.diffuse.copyFrom(this._lightColor);
        }
      }
    }
  }
};
WebXRLightEstimation.Name = WebXRFeatureName.LIGHT_ESTIMATION;
WebXRLightEstimation.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRLightEstimation.Name, (xrSessionManager, options) => {
  return () => new WebXRLightEstimation(xrSessionManager, options);
}, WebXRLightEstimation.Version, false);

// node_modules/@babylonjs/core/XR/features/WebXREyeTracking.js
var WebXREyeTracking = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager) {
    super(_xrSessionManager);
    this.onEyeTrackingStartedObservable = new Observable();
    this.onEyeTrackingEndedObservable = new Observable();
    this.onEyeTrackingFrameUpdateObservable = new Observable();
    this._eyeTrackingStartListener = (event) => {
      this._latestEyeSpace = event.gazeSpace;
      this._gazeRay = new Ray(Vector3.Zero(), Vector3.Forward());
      this.onEyeTrackingStartedObservable.notifyObservers(this._gazeRay);
    };
    this._eyeTrackingEndListener = () => {
      this._latestEyeSpace = null;
      this._gazeRay = null;
      this.onEyeTrackingEndedObservable.notifyObservers();
    };
    this.xrNativeFeatureName = "eye-tracking";
    if (this._xrSessionManager.session) {
      this._init();
    } else {
      this._xrSessionManager.onXRSessionInit.addOnce(() => {
        this._init();
      });
    }
  }
  dispose() {
    super.dispose();
    this._xrSessionManager.session.removeEventListener("eyetrackingstart", this._eyeTrackingStartListener);
    this._xrSessionManager.session.removeEventListener("eyetrackingend", this._eyeTrackingEndListener);
    this.onEyeTrackingStartedObservable.clear();
    this.onEyeTrackingEndedObservable.clear();
    this.onEyeTrackingFrameUpdateObservable.clear();
  }
  get isEyeGazeValid() {
    return !!this._gazeRay;
  }
  getEyeGaze() {
    return this._gazeRay;
  }
  _onXRFrame(frame) {
    if (!this.attached || !frame) {
      return;
    }
    if (this._latestEyeSpace && this._gazeRay) {
      const pose = frame.getPose(this._latestEyeSpace, this._xrSessionManager.referenceSpace);
      if (pose) {
        this._gazeRay.origin.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
        const quat = pose.transform.orientation;
        TmpVectors.Quaternion[0].set(quat.x, quat.y, quat.z, quat.w);
        if (!this._xrSessionManager.scene.useRightHandedSystem) {
          this._gazeRay.origin.z *= -1;
          TmpVectors.Quaternion[0].z *= -1;
          TmpVectors.Quaternion[0].w *= -1;
          Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(TmpVectors.Quaternion[0], this._gazeRay.direction);
        } else {
          Vector3.RightHandedForwardReadOnly.rotateByQuaternionToRef(TmpVectors.Quaternion[0], this._gazeRay.direction);
        }
        this.onEyeTrackingFrameUpdateObservable.notifyObservers(this._gazeRay);
      }
    }
  }
  _init() {
    if (this._xrSessionManager.isNative) {
      this._xrSessionManager.session.addEventListener("eyetrackingstart", this._eyeTrackingStartListener);
      this._xrSessionManager.session.addEventListener("eyetrackingend", this._eyeTrackingEndListener);
    }
  }
};
WebXREyeTracking.Name = WebXRFeatureName.EYE_TRACKING;
WebXREyeTracking.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXREyeTracking.Name, (xrSessionManager) => {
  return () => new WebXREyeTracking(xrSessionManager);
}, WebXREyeTracking.Version, false);

// node_modules/@babylonjs/core/XR/features/WebXRWalkingLocomotion.js
var CircleBuffer = class {
  constructor(numSamples, initializer) {
    this._samples = [];
    this._idx = 0;
    for (let idx = 0; idx < numSamples; ++idx) {
      this._samples.push(initializer ? initializer() : Vector2.Zero());
    }
  }
  get length() {
    return this._samples.length;
  }
  push(x, y) {
    this._idx = (this._idx + this._samples.length - 1) % this._samples.length;
    this.at(0).copyFromFloats(x, y);
  }
  at(idx) {
    if (idx >= this._samples.length) {
      throw new Error("Index out of bounds");
    }
    return this._samples[(this._idx + idx) % this._samples.length];
  }
};
var FirstStepDetector = class {
  constructor() {
    this._samples = new CircleBuffer(20);
    this._entropy = 0;
    this.onFirstStepDetected = new Observable();
  }
  update(posX, posY, forwardX, forwardY) {
    this._samples.push(posX, posY);
    const origin = this._samples.at(0);
    this._entropy *= this._entropyDecayFactor;
    this._entropy += Vector2.Distance(origin, this._samples.at(1));
    if (this._entropy > this._entropyThreshold) {
      return;
    }
    let samePointIdx;
    for (samePointIdx = this._samePointCheckStartIdx; samePointIdx < this._samples.length; ++samePointIdx) {
      if (Vector2.DistanceSquared(origin, this._samples.at(samePointIdx)) < this._samePointSquaredDistanceThreshold) {
        break;
      }
    }
    if (samePointIdx === this._samples.length) {
      return;
    }
    let apexDistSquared = -1;
    let apexIdx = 0;
    for (let distSquared, idx = 1; idx < samePointIdx; ++idx) {
      distSquared = Vector2.DistanceSquared(origin, this._samples.at(idx));
      if (distSquared > apexDistSquared) {
        apexIdx = idx;
        apexDistSquared = distSquared;
      }
    }
    if (apexDistSquared < this._apexSquaredDistanceThreshold) {
      return;
    }
    const apex = this._samples.at(apexIdx);
    const axis = apex.subtract(origin);
    axis.normalize();
    const vec = TmpVectors.Vector2[0];
    let dot;
    let sample;
    let sumSquaredProjectionDistances = 0;
    for (let idx = 1; idx < samePointIdx; ++idx) {
      sample = this._samples.at(idx);
      sample.subtractToRef(origin, vec);
      dot = Vector2.Dot(axis, vec);
      sumSquaredProjectionDistances += vec.lengthSquared() - dot * dot;
    }
    if (sumSquaredProjectionDistances > samePointIdx * this._squaredProjectionDistanceThreshold) {
      return;
    }
    const forwardVec = TmpVectors.Vector3[0];
    forwardVec.set(forwardX, forwardY, 0);
    const axisVec = TmpVectors.Vector3[1];
    axisVec.set(axis.x, axis.y, 0);
    const isApexLeft = Vector3.Cross(forwardVec, axisVec).z > 0;
    const leftApex = origin.clone();
    const rightApex = origin.clone();
    apex.subtractToRef(origin, axis);
    if (isApexLeft) {
      axis.scaleAndAddToRef(this._axisToApexShrinkFactor, leftApex);
      axis.scaleAndAddToRef(this._axisToApexExtendFactor, rightApex);
    } else {
      axis.scaleAndAddToRef(this._axisToApexExtendFactor, leftApex);
      axis.scaleAndAddToRef(this._axisToApexShrinkFactor, rightApex);
    }
    this.onFirstStepDetected.notifyObservers({
      leftApex,
      rightApex,
      currentPosition: origin,
      currentStepDirection: isApexLeft ? "right" : "left"
    });
  }
  reset() {
    for (let idx = 0; idx < this._samples.length; ++idx) {
      this._samples.at(idx).copyFromFloats(0, 0);
    }
  }
  get _samePointCheckStartIdx() {
    return Math.floor(this._samples.length / 3);
  }
  get _samePointSquaredDistanceThreshold() {
    return 0.03 * 0.03;
  }
  get _apexSquaredDistanceThreshold() {
    return 0.09 * 0.09;
  }
  get _squaredProjectionDistanceThreshold() {
    return 0.03 * 0.03;
  }
  get _axisToApexShrinkFactor() {
    return 0.8;
  }
  get _axisToApexExtendFactor() {
    return -1.6;
  }
  get _entropyDecayFactor() {
    return 0.93;
  }
  get _entropyThreshold() {
    return 0.4;
  }
};
var WalkingTracker = class {
  constructor(leftApex, rightApex, currentPosition, currentStepDirection) {
    this._leftApex = new Vector2();
    this._rightApex = new Vector2();
    this._currentPosition = new Vector2();
    this._axis = new Vector2();
    this._axisLength = -1;
    this._forward = new Vector2();
    this._steppingLeft = false;
    this._t = -1;
    this._maxT = -1;
    this._maxTPosition = new Vector2();
    this._vitality = 0;
    this.onMovement = new Observable();
    this.onFootfall = new Observable();
    this._reset(leftApex, rightApex, currentPosition, currentStepDirection === "left");
  }
  _reset(leftApex, rightApex, currentPosition, steppingLeft) {
    this._leftApex.copyFrom(leftApex);
    this._rightApex.copyFrom(rightApex);
    this._steppingLeft = steppingLeft;
    if (this._steppingLeft) {
      this._leftApex.subtractToRef(this._rightApex, this._axis);
      this._forward.copyFromFloats(-this._axis.y, this._axis.x);
    } else {
      this._rightApex.subtractToRef(this._leftApex, this._axis);
      this._forward.copyFromFloats(this._axis.y, -this._axis.x);
    }
    this._axisLength = this._axis.length();
    this._forward.scaleInPlace(1 / this._axisLength);
    this._updateTAndVitality(currentPosition.x, currentPosition.y);
    this._maxT = this._t;
    this._maxTPosition.copyFrom(currentPosition);
    this._vitality = 1;
  }
  _updateTAndVitality(x, y) {
    this._currentPosition.copyFromFloats(x, y);
    if (this._steppingLeft) {
      this._currentPosition.subtractInPlace(this._rightApex);
    } else {
      this._currentPosition.subtractInPlace(this._leftApex);
    }
    const priorT = this._t;
    const dot = Vector2.Dot(this._currentPosition, this._axis);
    this._t = dot / (this._axisLength * this._axisLength);
    const projDistSquared = this._currentPosition.lengthSquared() - dot / this._axisLength * (dot / this._axisLength);
    this._vitality *= 0.92 - 100 * Math.max(projDistSquared - 16e-4, 0) + Math.max(this._t - priorT, 0);
  }
  update(x, y) {
    if (this._vitality < this._vitalityThreshold) {
      return false;
    }
    const priorT = this._t;
    this._updateTAndVitality(x, y);
    if (this._t > this._maxT) {
      this._maxT = this._t;
      this._maxTPosition.copyFromFloats(x, y);
    }
    if (this._vitality < this._vitalityThreshold) {
      return false;
    }
    if (this._t > priorT) {
      this.onMovement.notifyObservers({ deltaT: this._t - priorT });
      if (priorT < 0.5 && this._t >= 0.5) {
        this.onFootfall.notifyObservers({ foot: this._steppingLeft ? "left" : "right" });
      }
    }
    if (this._t < 0.95 * this._maxT) {
      this._currentPosition.copyFromFloats(x, y);
      if (this._steppingLeft) {
        this._leftApex.copyFrom(this._maxTPosition);
      } else {
        this._rightApex.copyFrom(this._maxTPosition);
      }
      this._reset(this._leftApex, this._rightApex, this._currentPosition, !this._steppingLeft);
    }
    if (this._axisLength < 0.03) {
      return false;
    }
    return true;
  }
  get _vitalityThreshold() {
    return 0.1;
  }
  get forward() {
    return this._forward;
  }
};
var Walker = class {
  constructor(engine) {
    this._detector = new FirstStepDetector();
    this._walker = null;
    this._movement = new Vector2();
    this._millisecondsSinceLastUpdate = Walker._MillisecondsPerUpdate;
    this.movementThisFrame = Vector3.Zero();
    this._engine = engine;
    this._detector.onFirstStepDetected.add((event) => {
      if (!this._walker) {
        this._walker = new WalkingTracker(event.leftApex, event.rightApex, event.currentPosition, event.currentStepDirection);
        this._walker.onFootfall.add(() => {
          console.log("Footfall!");
        });
        this._walker.onMovement.add((event2) => {
          this._walker.forward.scaleAndAddToRef(0.024 * event2.deltaT, this._movement);
        });
      }
    });
  }
  static get _MillisecondsPerUpdate() {
    return 1e3 / 15;
  }
  update(position, forward) {
    forward.y = 0;
    forward.normalize();
    this._millisecondsSinceLastUpdate += this._engine.getDeltaTime();
    if (this._millisecondsSinceLastUpdate >= Walker._MillisecondsPerUpdate) {
      this._millisecondsSinceLastUpdate -= Walker._MillisecondsPerUpdate;
      this._detector.update(position.x, position.z, forward.x, forward.z);
      if (this._walker) {
        const updated = this._walker.update(position.x, position.z);
        if (!updated) {
          this._walker = null;
        }
      }
      this._movement.scaleInPlace(0.85);
    }
    this.movementThisFrame.set(this._movement.x, 0, this._movement.y);
  }
};
var WebXRWalkingLocomotion = class extends WebXRAbstractFeature {
  constructor(sessionManager, options) {
    super(sessionManager);
    this._up = new Vector3();
    this._forward = new Vector3();
    this._position = new Vector3();
    this._movement = new Vector3();
    this._sessionManager = sessionManager;
    this.locomotionTarget = options.locomotionTarget;
    if (this._isLocomotionTargetWebXRCamera) {
      Logger.Warn("Using walking locomotion directly on a WebXRCamera may have unintended interactions with other XR techniques. Using an XR space parent is highly recommended");
    }
  }
  static get Name() {
    return WebXRFeatureName.WALKING_LOCOMOTION;
  }
  static get Version() {
    return 1;
  }
  get locomotionTarget() {
    return this._locomotionTarget;
  }
  set locomotionTarget(locomotionTarget) {
    this._locomotionTarget = locomotionTarget;
    this._isLocomotionTargetWebXRCamera = this._locomotionTarget.getClassName() === "WebXRCamera";
  }
  isCompatible() {
    return this._sessionManager.sessionMode === void 0 || this._sessionManager.sessionMode === "immersive-vr";
  }
  attach() {
    if (!this.isCompatible || !super.attach()) {
      return false;
    }
    this._walker = new Walker(this._sessionManager.scene.getEngine());
    return true;
  }
  detach() {
    if (!super.detach()) {
      return false;
    }
    this._walker = null;
    return true;
  }
  _onXRFrame(frame) {
    const pose = frame.getViewerPose(this._sessionManager.baseReferenceSpace);
    if (!pose) {
      return;
    }
    const handednessScalar = this.locomotionTarget.getScene().useRightHandedSystem ? 1 : -1;
    const m = pose.transform.matrix;
    this._up.copyFromFloats(m[4], m[5], handednessScalar * m[6]);
    this._forward.copyFromFloats(m[8], m[9], handednessScalar * m[10]);
    this._position.copyFromFloats(m[12], m[13], handednessScalar * m[14]);
    this._forward.scaleAndAddToRef(0.05, this._position);
    this._up.scaleAndAddToRef(-0.05, this._position);
    this._walker.update(this._position, this._forward);
    this._movement.copyFrom(this._walker.movementThisFrame);
    if (!this._isLocomotionTargetWebXRCamera) {
      Vector3.TransformNormalToRef(this._movement, this.locomotionTarget.getWorldMatrix(), this._movement);
    }
    this.locomotionTarget.position.addInPlace(this._movement);
  }
};
WebXRFeaturesManager.AddWebXRFeature(WebXRWalkingLocomotion.Name, (xrSessionManager, options) => {
  return () => new WebXRWalkingLocomotion(xrSessionManager, options);
}, WebXRWalkingLocomotion.Version, false);

// node_modules/@babylonjs/core/XR/features/WebXRLayers.js
var WebXRCompositionLayerWrapper = class extends WebXRLayerWrapper {
  constructor(getWidth, getHeight, layer, layerType, isMultiview, createRTTProvider) {
    super(getWidth, getHeight, layer, layerType, createRTTProvider);
    this.getWidth = getWidth;
    this.getHeight = getHeight;
    this.layer = layer;
    this.layerType = layerType;
    this.isMultiview = isMultiview;
    this.createRTTProvider = createRTTProvider;
  }
};
var WebXRCompositionLayerRenderTargetTextureProvider = class extends WebXRLayerRenderTargetTextureProvider {
  constructor(_xrSessionManager, _xrWebGLBinding, layerWrapper) {
    super(_xrSessionManager.scene, layerWrapper);
    this._xrSessionManager = _xrSessionManager;
    this._xrWebGLBinding = _xrWebGLBinding;
    this.layerWrapper = layerWrapper;
    this._lastSubImages = /* @__PURE__ */ new Map();
    this._compositionLayer = layerWrapper.layer;
  }
  _getRenderTargetForSubImage(subImage, eye) {
    const lastSubImage = this._lastSubImages.get(eye);
    const eyeIndex = eye == "left" ? 0 : 1;
    if (!this._renderTargetTextures[eyeIndex] || (lastSubImage === null || lastSubImage === void 0 ? void 0 : lastSubImage.textureWidth) !== subImage.textureWidth || (lastSubImage === null || lastSubImage === void 0 ? void 0 : lastSubImage.textureHeight) != subImage.textureHeight) {
      this._renderTargetTextures[eyeIndex] = this._createRenderTargetTexture(subImage.textureWidth, subImage.textureHeight, null, subImage.colorTexture, subImage.depthStencilTexture, this.layerWrapper.isMultiview);
      this._framebufferDimensions = {
        framebufferWidth: subImage.textureWidth,
        framebufferHeight: subImage.textureHeight
      };
    }
    this._lastSubImages.set(eye, subImage);
    return this._renderTargetTextures[eyeIndex];
  }
  _getSubImageForEye(eye) {
    const currentFrame = this._xrSessionManager.currentFrame;
    if (currentFrame) {
      return this._xrWebGLBinding.getSubImage(this._compositionLayer, currentFrame, eye);
    }
    return null;
  }
  getRenderTargetTextureForEye(eye) {
    const subImage = this._getSubImageForEye(eye);
    if (subImage) {
      return this._getRenderTargetForSubImage(subImage, eye);
    }
    return null;
  }
  getRenderTargetTextureForView(view) {
    return this.getRenderTargetTextureForEye(view.eye);
  }
  _setViewportForSubImage(viewport, subImage) {
    const textureWidth = subImage.textureWidth;
    const textureHeight = subImage.textureHeight;
    const xrViewport = subImage.viewport;
    viewport.x = xrViewport.x / textureWidth;
    viewport.y = xrViewport.y / textureHeight;
    viewport.width = xrViewport.width / textureWidth;
    viewport.height = xrViewport.height / textureHeight;
  }
  trySetViewportForView(viewport, view) {
    const subImage = this._lastSubImages.get(view.eye) || this._getSubImageForEye(view.eye);
    if (subImage) {
      this._setViewportForSubImage(viewport, subImage);
      return true;
    }
    return false;
  }
};
var WebXRProjectionLayerWrapper = class extends WebXRCompositionLayerWrapper {
  constructor(layer, isMultiview, xrGLBinding) {
    super(() => layer.textureWidth, () => layer.textureHeight, layer, "XRProjectionLayer", isMultiview, (sessionManager) => new WebXRProjectionLayerRenderTargetTextureProvider(sessionManager, xrGLBinding, this));
    this.layer = layer;
  }
};
var WebXRProjectionLayerRenderTargetTextureProvider = class extends WebXRCompositionLayerRenderTargetTextureProvider {
  constructor(_xrSessionManager, _xrWebGLBinding, layerWrapper) {
    super(_xrSessionManager, _xrWebGLBinding, layerWrapper);
    this.layerWrapper = layerWrapper;
    this._projectionLayer = layerWrapper.layer;
  }
  _getSubImageForView(view) {
    return this._xrWebGLBinding.getViewSubImage(this._projectionLayer, view);
  }
  getRenderTargetTextureForView(view) {
    return this._getRenderTargetForSubImage(this._getSubImageForView(view), view.eye);
  }
  getRenderTargetTextureForEye(eye) {
    const lastSubImage = this._lastSubImages.get(eye);
    if (lastSubImage) {
      return this._getRenderTargetForSubImage(lastSubImage, eye);
    }
    return null;
  }
  trySetViewportForView(viewport, view) {
    const subImage = this._lastSubImages.get(view.eye) || this._getSubImageForView(view);
    if (subImage) {
      this._setViewportForSubImage(viewport, subImage);
      return true;
    }
    return false;
  }
};
var defaultXRWebGLLayerInit = {};
var defaultXRProjectionLayerInit = {
  textureType: "texture",
  colorFormat: 6408,
  depthFormat: 35056,
  scaleFactor: 1
};
var WebXRLayers = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, _options = {}) {
    super(_xrSessionManager);
    this._options = _options;
    this._existingLayers = [];
    this.xrNativeFeatureName = "layers";
  }
  attach() {
    if (!super.attach()) {
      return false;
    }
    const engine = this._xrSessionManager.scene.getEngine();
    this._glContext = engine._gl;
    this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, this._glContext);
    this._existingLayers.length = 0;
    const projectionLayerInit = { ...defaultXRProjectionLayerInit };
    const projectionLayerMultiview = this._options.preferMultiviewOnInit && engine.getCaps().multiview;
    if (projectionLayerMultiview) {
      projectionLayerInit.textureType = "texture-array";
    }
    this.addXRSessionLayer(this.createProjectionLayer(projectionLayerInit, projectionLayerMultiview));
    return true;
  }
  detach() {
    if (!super.detach()) {
      return false;
    }
    this._existingLayers.length = 0;
    return true;
  }
  createXRWebGLLayer(params = defaultXRWebGLLayerInit) {
    const layer = new XRWebGLLayer(this._xrSessionManager.session, this._glContext, params);
    return new WebXRWebGLLayerWrapper(layer);
  }
  createProjectionLayer(params = defaultXRProjectionLayerInit, multiview = false) {
    if (multiview && params.textureType !== "texture-array") {
      throw new Error("Projection layers can only be made multiview if they use texture arrays. Set the textureType parameter to 'texture-array'.");
    }
    if (!multiview && params.textureType === "texture-array") {
      throw new Error("We currently only support multiview rendering when the textureType parameter is set to 'texture-array'.");
    }
    const projLayer = this._xrWebGLBinding.createProjectionLayer(params);
    return new WebXRProjectionLayerWrapper(projLayer, multiview, this._xrWebGLBinding);
  }
  addXRSessionLayer(wrappedLayer) {
    this.setXRSessionLayers([...this._existingLayers, wrappedLayer]);
  }
  setXRSessionLayers(wrappedLayers) {
    this._existingLayers = wrappedLayers;
    const renderStateInit = { ...this._xrSessionManager.session.renderState };
    renderStateInit.baseLayer = void 0;
    renderStateInit.layers = wrappedLayers.map((wrappedLayer) => wrappedLayer.layer);
    this._xrSessionManager.updateRenderState(renderStateInit);
    this._xrSessionManager._setBaseLayerWrapper(wrappedLayers.length > 0 ? wrappedLayers[0] : null);
  }
  isCompatible() {
    return !this._xrSessionManager.isNative && typeof XRWebGLBinding !== "undefined" && !!XRWebGLBinding.prototype.createProjectionLayer;
  }
  dispose() {
    super.dispose();
  }
  _onXRFrame(_xrFrame) {
  }
};
WebXRLayers.Name = WebXRFeatureName.LAYERS;
WebXRLayers.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRLayers.Name, (xrSessionManager, options) => {
  return () => new WebXRLayers(xrSessionManager, options);
}, WebXRLayers.Version, false);

// node_modules/@babylonjs/core/XR/motionController/webXRGenericHandController.js
var WebXRGenericHandController = class extends WebXRAbstractMotionController {
  constructor(scene, gamepadObject, handedness) {
    super(scene, GenericHandSelectGraspProfile[handedness], gamepadObject, handedness, true);
    this.profileId = "generic-hand-select-grasp";
  }
  _getFilenameAndPath() {
    return {
      filename: "generic.babylon",
      path: "https://controllers.babylonjs.com/generic/"
    };
  }
  _getModelLoadingConstraints() {
    return true;
  }
  _processLoadedModel(_meshes) {
  }
  _setRootMesh(meshes) {
  }
  _updateModel() {
  }
};
WebXRMotionControllerManager.RegisterController("generic-hand-select-grasp", (xrInput, scene) => {
  return new WebXRGenericHandController(scene, xrInput.gamepad, xrInput.handedness);
});
var GenericHandSelectGraspProfile = {
  left: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr-standard-trigger",
        visualResponses: {}
      },
      grasp: {
        type: "trigger",
        gamepadIndices: {
          button: 4
        },
        rootNodeName: "grasp",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "generic-hand-select-grasp-left",
    assetPath: "left.glb"
  },
  right: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr-standard-trigger",
        visualResponses: {}
      },
      grasp: {
        type: "trigger",
        gamepadIndices: {
          button: 4
        },
        rootNodeName: "grasp",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "generic-hand-select-grasp-right",
    assetPath: "right.glb"
  },
  none: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr-standard-trigger",
        visualResponses: {}
      },
      grasp: {
        type: "trigger",
        gamepadIndices: {
          button: 4
        },
        rootNodeName: "grasp",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "generic-hand-select-grasp-none",
    assetPath: "none.glb"
  }
};

// node_modules/@babylonjs/core/XR/motionController/webXRMicrosoftMixedRealityController.js
var WebXRMicrosoftMixedRealityController = class extends WebXRAbstractMotionController {
  constructor(scene, gamepadObject, handedness) {
    super(scene, MixedRealityProfile["left-right"], gamepadObject, handedness);
    this._mapping = {
      defaultButton: {
        valueNodeName: "VALUE",
        unpressedNodeName: "UNPRESSED",
        pressedNodeName: "PRESSED"
      },
      defaultAxis: {
        valueNodeName: "VALUE",
        minNodeName: "MIN",
        maxNodeName: "MAX"
      },
      buttons: {
        "xr-standard-trigger": {
          rootNodeName: "SELECT",
          componentProperty: "button",
          states: ["default", "touched", "pressed"]
        },
        "xr-standard-squeeze": {
          rootNodeName: "GRASP",
          componentProperty: "state",
          states: ["pressed"]
        },
        "xr-standard-touchpad": {
          rootNodeName: "TOUCHPAD_PRESS",
          labelAnchorNodeName: "squeeze-label",
          touchPointNodeName: "TOUCH"
        },
        "xr-standard-thumbstick": {
          rootNodeName: "THUMBSTICK_PRESS",
          componentProperty: "state",
          states: ["pressed"]
        }
      },
      axes: {
        "xr-standard-touchpad": {
          "x-axis": {
            rootNodeName: "TOUCHPAD_TOUCH_X"
          },
          "y-axis": {
            rootNodeName: "TOUCHPAD_TOUCH_Y"
          }
        },
        "xr-standard-thumbstick": {
          "x-axis": {
            rootNodeName: "THUMBSTICK_X"
          },
          "y-axis": {
            rootNodeName: "THUMBSTICK_Y"
          }
        }
      }
    };
    this.profileId = "microsoft-mixed-reality";
  }
  _getFilenameAndPath() {
    let filename = "";
    if (this.handedness === "left") {
      filename = WebXRMicrosoftMixedRealityController.MODEL_LEFT_FILENAME;
    } else {
      filename = WebXRMicrosoftMixedRealityController.MODEL_RIGHT_FILENAME;
    }
    const device = "default";
    const path = WebXRMicrosoftMixedRealityController.MODEL_BASE_URL + device + "/";
    return {
      filename,
      path
    };
  }
  _getModelLoadingConstraints() {
    const glbLoaded = SceneLoader.IsPluginForExtensionAvailable(".glb");
    if (!glbLoaded) {
      Logger.Warn("glTF / glb loaded was not registered, using generic controller instead");
    }
    return glbLoaded;
  }
  _processLoadedModel(_meshes) {
    if (!this.rootMesh) {
      return;
    }
    this.getComponentIds().forEach((id, i) => {
      if (this.disableAnimation) {
        return;
      }
      if (id && this.rootMesh) {
        const buttonMap = this._mapping.buttons[id];
        const buttonMeshName = buttonMap.rootNodeName;
        if (!buttonMeshName) {
          Logger.Log("Skipping unknown button at index: " + i + " with mapped name: " + id);
          return;
        }
        const buttonMesh = this._getChildByName(this.rootMesh, buttonMeshName);
        if (!buttonMesh) {
          Logger.Warn("Missing button mesh with name: " + buttonMeshName);
          return;
        }
        buttonMap.valueMesh = this._getImmediateChildByName(buttonMesh, this._mapping.defaultButton.valueNodeName);
        buttonMap.pressedMesh = this._getImmediateChildByName(buttonMesh, this._mapping.defaultButton.pressedNodeName);
        buttonMap.unpressedMesh = this._getImmediateChildByName(buttonMesh, this._mapping.defaultButton.unpressedNodeName);
        if (buttonMap.valueMesh && buttonMap.pressedMesh && buttonMap.unpressedMesh) {
          const comp = this.getComponent(id);
          if (comp) {
            comp.onButtonStateChangedObservable.add((component) => {
              this._lerpTransform(buttonMap, component.value);
            }, void 0, true);
          }
        } else {
          Logger.Warn("Missing button submesh under mesh with name: " + buttonMeshName);
        }
      }
    });
    this.getComponentIds().forEach((id) => {
      const comp = this.getComponent(id);
      if (!comp.isAxes()) {
        return;
      }
      ["x-axis", "y-axis"].forEach((axis) => {
        if (!this.rootMesh) {
          return;
        }
        const axisMap = this._mapping.axes[id][axis];
        const axisMesh = this._getChildByName(this.rootMesh, axisMap.rootNodeName);
        if (!axisMesh) {
          Logger.Warn("Missing axis mesh with name: " + axisMap.rootNodeName);
          return;
        }
        axisMap.valueMesh = this._getImmediateChildByName(axisMesh, this._mapping.defaultAxis.valueNodeName);
        axisMap.minMesh = this._getImmediateChildByName(axisMesh, this._mapping.defaultAxis.minNodeName);
        axisMap.maxMesh = this._getImmediateChildByName(axisMesh, this._mapping.defaultAxis.maxNodeName);
        if (axisMap.valueMesh && axisMap.minMesh && axisMap.maxMesh) {
          if (comp) {
            comp.onAxisValueChangedObservable.add((axisValues) => {
              const value = axis === "x-axis" ? axisValues.x : axisValues.y;
              this._lerpTransform(axisMap, value, true);
            }, void 0, true);
          }
        } else {
          Logger.Warn("Missing axis submesh under mesh with name: " + axisMap.rootNodeName);
        }
      });
    });
  }
  _setRootMesh(meshes) {
    this.rootMesh = new Mesh(this.profileId + " " + this.handedness, this.scene);
    this.rootMesh.isPickable = false;
    let rootMesh;
    for (let i = 0; i < meshes.length; i++) {
      const mesh = meshes[i];
      mesh.isPickable = false;
      if (!mesh.parent) {
        rootMesh = mesh;
      }
    }
    if (rootMesh) {
      rootMesh.setParent(this.rootMesh);
    }
    if (!this.scene.useRightHandedSystem) {
      this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);
    }
  }
  _updateModel() {
  }
};
WebXRMicrosoftMixedRealityController.MODEL_BASE_URL = "https://controllers.babylonjs.com/microsoft/";
WebXRMicrosoftMixedRealityController.MODEL_LEFT_FILENAME = "left.glb";
WebXRMicrosoftMixedRealityController.MODEL_RIGHT_FILENAME = "right.glb";
WebXRMotionControllerManager.RegisterController("windows-mixed-reality", (xrInput, scene) => {
  return new WebXRMicrosoftMixedRealityController(scene, xrInput.gamepad, xrInput.handedness);
});
var MixedRealityProfile = {
  left: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {
          xr_standard_trigger_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_trigger_pressed_value",
            minNodeName: "xr_standard_trigger_pressed_min",
            maxNodeName: "xr_standard_trigger_pressed_max"
          }
        }
      },
      "xr-standard-squeeze": {
        type: "squeeze",
        gamepadIndices: {
          button: 1
        },
        rootNodeName: "xr_standard_squeeze",
        visualResponses: {
          xr_standard_squeeze_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_squeeze_pressed_value",
            minNodeName: "xr_standard_squeeze_pressed_min",
            maxNodeName: "xr_standard_squeeze_pressed_max"
          }
        }
      },
      "xr-standard-touchpad": {
        type: "touchpad",
        gamepadIndices: {
          button: 2,
          xAxis: 0,
          yAxis: 1
        },
        rootNodeName: "xr_standard_touchpad",
        visualResponses: {
          xr_standard_touchpad_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_pressed_value",
            minNodeName: "xr_standard_touchpad_pressed_min",
            maxNodeName: "xr_standard_touchpad_pressed_max"
          },
          xr_standard_touchpad_xaxis_pressed: {
            componentProperty: "xAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_xaxis_pressed_value",
            minNodeName: "xr_standard_touchpad_xaxis_pressed_min",
            maxNodeName: "xr_standard_touchpad_xaxis_pressed_max"
          },
          xr_standard_touchpad_yaxis_pressed: {
            componentProperty: "yAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_yaxis_pressed_value",
            minNodeName: "xr_standard_touchpad_yaxis_pressed_min",
            maxNodeName: "xr_standard_touchpad_yaxis_pressed_max"
          },
          xr_standard_touchpad_xaxis_touched: {
            componentProperty: "xAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_xaxis_touched_value",
            minNodeName: "xr_standard_touchpad_xaxis_touched_min",
            maxNodeName: "xr_standard_touchpad_xaxis_touched_max"
          },
          xr_standard_touchpad_yaxis_touched: {
            componentProperty: "yAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_yaxis_touched_value",
            minNodeName: "xr_standard_touchpad_yaxis_touched_min",
            maxNodeName: "xr_standard_touchpad_yaxis_touched_max"
          },
          xr_standard_touchpad_axes_touched: {
            componentProperty: "state",
            states: ["touched", "pressed"],
            valueNodeProperty: "visibility",
            valueNodeName: "xr_standard_touchpad_axes_touched_value"
          }
        },
        touchPointNodeName: "xr_standard_touchpad_axes_touched_value"
      },
      "xr-standard-thumbstick": {
        type: "thumbstick",
        gamepadIndices: {
          button: 3,
          xAxis: 2,
          yAxis: 3
        },
        rootNodeName: "xr_standard_thumbstick",
        visualResponses: {
          xr_standard_thumbstick_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_thumbstick_pressed_value",
            minNodeName: "xr_standard_thumbstick_pressed_min",
            maxNodeName: "xr_standard_thumbstick_pressed_max"
          },
          xr_standard_thumbstick_xaxis_pressed: {
            componentProperty: "xAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_thumbstick_xaxis_pressed_value",
            minNodeName: "xr_standard_thumbstick_xaxis_pressed_min",
            maxNodeName: "xr_standard_thumbstick_xaxis_pressed_max"
          },
          xr_standard_thumbstick_yaxis_pressed: {
            componentProperty: "yAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_thumbstick_yaxis_pressed_value",
            minNodeName: "xr_standard_thumbstick_yaxis_pressed_min",
            maxNodeName: "xr_standard_thumbstick_yaxis_pressed_max"
          }
        }
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "microsoft-mixed-reality-left",
    assetPath: "left.glb"
  },
  right: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {
          xr_standard_trigger_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_trigger_pressed_value",
            minNodeName: "xr_standard_trigger_pressed_min",
            maxNodeName: "xr_standard_trigger_pressed_max"
          }
        }
      },
      "xr-standard-squeeze": {
        type: "squeeze",
        gamepadIndices: {
          button: 1
        },
        rootNodeName: "xr_standard_squeeze",
        visualResponses: {
          xr_standard_squeeze_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_squeeze_pressed_value",
            minNodeName: "xr_standard_squeeze_pressed_min",
            maxNodeName: "xr_standard_squeeze_pressed_max"
          }
        }
      },
      "xr-standard-touchpad": {
        type: "touchpad",
        gamepadIndices: {
          button: 2,
          xAxis: 0,
          yAxis: 1
        },
        rootNodeName: "xr_standard_touchpad",
        visualResponses: {
          xr_standard_touchpad_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_pressed_value",
            minNodeName: "xr_standard_touchpad_pressed_min",
            maxNodeName: "xr_standard_touchpad_pressed_max"
          },
          xr_standard_touchpad_xaxis_pressed: {
            componentProperty: "xAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_xaxis_pressed_value",
            minNodeName: "xr_standard_touchpad_xaxis_pressed_min",
            maxNodeName: "xr_standard_touchpad_xaxis_pressed_max"
          },
          xr_standard_touchpad_yaxis_pressed: {
            componentProperty: "yAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_yaxis_pressed_value",
            minNodeName: "xr_standard_touchpad_yaxis_pressed_min",
            maxNodeName: "xr_standard_touchpad_yaxis_pressed_max"
          },
          xr_standard_touchpad_xaxis_touched: {
            componentProperty: "xAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_xaxis_touched_value",
            minNodeName: "xr_standard_touchpad_xaxis_touched_min",
            maxNodeName: "xr_standard_touchpad_xaxis_touched_max"
          },
          xr_standard_touchpad_yaxis_touched: {
            componentProperty: "yAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_yaxis_touched_value",
            minNodeName: "xr_standard_touchpad_yaxis_touched_min",
            maxNodeName: "xr_standard_touchpad_yaxis_touched_max"
          },
          xr_standard_touchpad_axes_touched: {
            componentProperty: "state",
            states: ["touched", "pressed"],
            valueNodeProperty: "visibility",
            valueNodeName: "xr_standard_touchpad_axes_touched_value"
          }
        },
        touchPointNodeName: "xr_standard_touchpad_axes_touched_value"
      },
      "xr-standard-thumbstick": {
        type: "thumbstick",
        gamepadIndices: {
          button: 3,
          xAxis: 2,
          yAxis: 3
        },
        rootNodeName: "xr_standard_thumbstick",
        visualResponses: {
          xr_standard_thumbstick_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_thumbstick_pressed_value",
            minNodeName: "xr_standard_thumbstick_pressed_min",
            maxNodeName: "xr_standard_thumbstick_pressed_max"
          },
          xr_standard_thumbstick_xaxis_pressed: {
            componentProperty: "xAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_thumbstick_xaxis_pressed_value",
            minNodeName: "xr_standard_thumbstick_xaxis_pressed_min",
            maxNodeName: "xr_standard_thumbstick_xaxis_pressed_max"
          },
          xr_standard_thumbstick_yaxis_pressed: {
            componentProperty: "yAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_thumbstick_yaxis_pressed_value",
            minNodeName: "xr_standard_thumbstick_yaxis_pressed_min",
            maxNodeName: "xr_standard_thumbstick_yaxis_pressed_max"
          }
        }
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "microsoft-mixed-reality-right",
    assetPath: "right.glb"
  }
};

// node_modules/@babylonjs/core/XR/motionController/webXROculusTouchMotionController.js
var WebXROculusTouchMotionController = class extends WebXRAbstractMotionController {
  constructor(scene, gamepadObject, handedness, _legacyMapping = false, _forceLegacyControllers = false) {
    super(scene, OculusTouchLayouts[handedness], gamepadObject, handedness);
    this._forceLegacyControllers = _forceLegacyControllers;
    this.profileId = "oculus-touch";
  }
  _getFilenameAndPath() {
    let filename = "";
    if (this.handedness === "left") {
      filename = WebXROculusTouchMotionController.MODEL_LEFT_FILENAME;
    } else {
      filename = WebXROculusTouchMotionController.MODEL_RIGHT_FILENAME;
    }
    const path = this._isQuest() ? WebXROculusTouchMotionController.QUEST_MODEL_BASE_URL : WebXROculusTouchMotionController.MODEL_BASE_URL;
    return {
      filename,
      path
    };
  }
  _getModelLoadingConstraints() {
    return true;
  }
  _processLoadedModel(_meshes) {
    const isQuest = this._isQuest();
    const triggerDirection = this.handedness === "right" ? -1 : 1;
    this.getComponentIds().forEach((id) => {
      const comp = id && this.getComponent(id);
      if (comp) {
        comp.onButtonStateChangedObservable.add((component) => {
          if (!this.rootMesh || this.disableAnimation) {
            return;
          }
          switch (id) {
            case "xr-standard-trigger":
              if (!isQuest) {
                this._modelRootNode.getChildren()[3].rotation.x = -component.value * 0.2;
                this._modelRootNode.getChildren()[3].position.y = -component.value * 5e-3;
                this._modelRootNode.getChildren()[3].position.z = -component.value * 5e-3;
              }
              return;
            case "xr-standard-squeeze":
              if (!isQuest) {
                this._modelRootNode.getChildren()[4].position.x = triggerDirection * component.value * 35e-4;
              }
              return;
            case "xr-standard-thumbstick":
              return;
            case "a-button":
            case "x-button":
              if (!isQuest) {
                if (component.pressed) {
                  this._modelRootNode.getChildren()[1].position.y = -1e-3;
                } else {
                  this._modelRootNode.getChildren()[1].position.y = 0;
                }
              }
              return;
            case "b-button":
            case "y-button":
              if (!isQuest) {
                if (component.pressed) {
                  this._modelRootNode.getChildren()[2].position.y = -1e-3;
                } else {
                  this._modelRootNode.getChildren()[2].position.y = 0;
                }
              }
              return;
          }
        }, void 0, true);
      }
    });
  }
  _setRootMesh(meshes) {
    this.rootMesh = new Mesh(this.profileId + " " + this.handedness, this.scene);
    if (!this.scene.useRightHandedSystem) {
      this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);
    }
    meshes.forEach((mesh) => {
      mesh.isPickable = false;
    });
    if (this._isQuest()) {
      this._modelRootNode = meshes[0];
    } else {
      this._modelRootNode = meshes[1];
      this.rootMesh.position.y = 0.034;
      this.rootMesh.position.z = 0.052;
    }
    this._modelRootNode.parent = this.rootMesh;
  }
  _updateModel() {
  }
  _isQuest() {
    return !!navigator.userAgent.match(/Quest/gi) && !this._forceLegacyControllers;
  }
};
WebXROculusTouchMotionController.MODEL_BASE_URL = "https://controllers.babylonjs.com/oculus/";
WebXROculusTouchMotionController.MODEL_LEFT_FILENAME = "left.babylon";
WebXROculusTouchMotionController.MODEL_RIGHT_FILENAME = "right.babylon";
WebXROculusTouchMotionController.QUEST_MODEL_BASE_URL = "https://controllers.babylonjs.com/oculusQuest/";
WebXRMotionControllerManager.RegisterController("oculus-touch", (xrInput, scene) => {
  return new WebXROculusTouchMotionController(scene, xrInput.gamepad, xrInput.handedness);
});
WebXRMotionControllerManager.RegisterController("oculus-touch-legacy", (xrInput, scene) => {
  return new WebXROculusTouchMotionController(scene, xrInput.gamepad, xrInput.handedness, true);
});
var OculusTouchLayouts = {
  left: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      },
      "xr-standard-squeeze": {
        type: "squeeze",
        gamepadIndices: {
          button: 1
        },
        rootNodeName: "xr_standard_squeeze",
        visualResponses: {}
      },
      "xr-standard-thumbstick": {
        type: "thumbstick",
        gamepadIndices: {
          button: 3,
          xAxis: 2,
          yAxis: 3
        },
        rootNodeName: "xr_standard_thumbstick",
        visualResponses: {}
      },
      "x-button": {
        type: "button",
        gamepadIndices: {
          button: 4
        },
        rootNodeName: "x_button",
        visualResponses: {}
      },
      "y-button": {
        type: "button",
        gamepadIndices: {
          button: 5
        },
        rootNodeName: "y_button",
        visualResponses: {}
      },
      thumbrest: {
        type: "button",
        gamepadIndices: {
          button: 6
        },
        rootNodeName: "thumbrest",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "oculus-touch-v2-left",
    assetPath: "left.glb"
  },
  right: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      },
      "xr-standard-squeeze": {
        type: "squeeze",
        gamepadIndices: {
          button: 1
        },
        rootNodeName: "xr_standard_squeeze",
        visualResponses: {}
      },
      "xr-standard-thumbstick": {
        type: "thumbstick",
        gamepadIndices: {
          button: 3,
          xAxis: 2,
          yAxis: 3
        },
        rootNodeName: "xr_standard_thumbstick",
        visualResponses: {}
      },
      "a-button": {
        type: "button",
        gamepadIndices: {
          button: 4
        },
        rootNodeName: "a_button",
        visualResponses: {}
      },
      "b-button": {
        type: "button",
        gamepadIndices: {
          button: 5
        },
        rootNodeName: "b_button",
        visualResponses: {}
      },
      thumbrest: {
        type: "button",
        gamepadIndices: {
          button: 6
        },
        rootNodeName: "thumbrest",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "oculus-touch-v2-right",
    assetPath: "right.glb"
  }
};

// node_modules/@babylonjs/core/XR/motionController/webXRHTCViveMotionController.js
var WebXRHTCViveMotionController = class extends WebXRAbstractMotionController {
  constructor(scene, gamepadObject, handedness) {
    super(scene, HTCViveLayout[handedness], gamepadObject, handedness);
    this.profileId = "htc-vive";
  }
  _getFilenameAndPath() {
    const filename = WebXRHTCViveMotionController.MODEL_FILENAME;
    const path = WebXRHTCViveMotionController.MODEL_BASE_URL;
    return {
      filename,
      path
    };
  }
  _getModelLoadingConstraints() {
    return true;
  }
  _processLoadedModel(_meshes) {
    this.getComponentIds().forEach((id) => {
      const comp = id && this.getComponent(id);
      if (comp) {
        comp.onButtonStateChangedObservable.add((component) => {
          if (!this.rootMesh || this.disableAnimation) {
            return;
          }
          switch (id) {
            case "xr-standard-trigger":
              this._modelRootNode.getChildren()[6].rotation.x = -component.value * 0.15;
              return;
            case "xr-standard-touchpad":
              return;
            case "xr-standard-squeeze":
              return;
          }
        }, void 0, true);
      }
    });
  }
  _setRootMesh(meshes) {
    this.rootMesh = new Mesh(this.profileId + " " + this.handedness, this.scene);
    meshes.forEach((mesh) => {
      mesh.isPickable = false;
    });
    this._modelRootNode = meshes[1];
    this._modelRootNode.parent = this.rootMesh;
    if (!this.scene.useRightHandedSystem) {
      this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);
    }
  }
  _updateModel() {
  }
};
WebXRHTCViveMotionController.MODEL_BASE_URL = "https://controllers.babylonjs.com/vive/";
WebXRHTCViveMotionController.MODEL_FILENAME = "wand.babylon";
WebXRMotionControllerManager.RegisterController("htc-vive", (xrInput, scene) => {
  return new WebXRHTCViveMotionController(scene, xrInput.gamepad, xrInput.handedness);
});
var HTCViveLayout = {
  left: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      },
      "xr-standard-squeeze": {
        type: "squeeze",
        gamepadIndices: {
          button: 1
        },
        rootNodeName: "xr_standard_squeeze",
        visualResponses: {}
      },
      "xr-standard-touchpad": {
        type: "touchpad",
        gamepadIndices: {
          button: 2,
          xAxis: 0,
          yAxis: 1
        },
        rootNodeName: "xr_standard_touchpad",
        visualResponses: {}
      },
      menu: {
        type: "button",
        gamepadIndices: {
          button: 4
        },
        rootNodeName: "menu",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "htc_vive_none",
    assetPath: "none.glb"
  },
  right: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      },
      "xr-standard-squeeze": {
        type: "squeeze",
        gamepadIndices: {
          button: 1
        },
        rootNodeName: "xr_standard_squeeze",
        visualResponses: {}
      },
      "xr-standard-touchpad": {
        type: "touchpad",
        gamepadIndices: {
          button: 2,
          xAxis: 0,
          yAxis: 1
        },
        rootNodeName: "xr_standard_touchpad",
        visualResponses: {}
      },
      menu: {
        type: "button",
        gamepadIndices: {
          button: 4
        },
        rootNodeName: "menu",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "htc_vive_none",
    assetPath: "none.glb"
  },
  none: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      },
      "xr-standard-squeeze": {
        type: "squeeze",
        gamepadIndices: {
          button: 1
        },
        rootNodeName: "xr_standard_squeeze",
        visualResponses: {}
      },
      "xr-standard-touchpad": {
        type: "touchpad",
        gamepadIndices: {
          button: 2,
          xAxis: 0,
          yAxis: 1
        },
        rootNodeName: "xr_standard_touchpad",
        visualResponses: {}
      },
      menu: {
        type: "button",
        gamepadIndices: {
          button: 4
        },
        rootNodeName: "menu",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "htc-vive-none",
    assetPath: "none.glb"
  }
};

// node_modules/@babylonjs/core/XR/native/nativeXRFrame.js
var NativeXRFrame = class {
  constructor(_nativeImpl) {
    this._nativeImpl = _nativeImpl;
    this._xrTransform = new XRRigidTransform();
    this._xrPose = {
      transform: this._xrTransform,
      emulatedPosition: false
    };
    this._xrPoseVectorData = new Float32Array(4 + 4);
    this.fillPoses = this._nativeImpl.fillPoses.bind(this._nativeImpl);
    this.getViewerPose = this._nativeImpl.getViewerPose.bind(this._nativeImpl);
    this.getHitTestResults = this._nativeImpl.getHitTestResults.bind(this._nativeImpl);
    this.getHitTestResultsForTransientInput = () => {
      throw new Error("XRFrame.getHitTestResultsForTransientInput not supported on native.");
    };
    this.createAnchor = this._nativeImpl.createAnchor.bind(this._nativeImpl);
    this.getJointPose = this._nativeImpl.getJointPose.bind(this._nativeImpl);
    this.fillJointRadii = this._nativeImpl.fillJointRadii.bind(this._nativeImpl);
    this.getLightEstimate = () => {
      throw new Error("XRFrame.getLightEstimate not supported on native.");
    };
    this.getImageTrackingResults = () => {
      var _a;
      return (_a = this._nativeImpl._imageTrackingResults) !== null && _a !== void 0 ? _a : [];
    };
  }
  get session() {
    return this._nativeImpl.session;
  }
  getPose(space, baseSpace) {
    if (!this._nativeImpl.getPoseData(space, baseSpace, this._xrPoseVectorData.buffer, this._xrTransform.matrix.buffer)) {
      return void 0;
    }
    const position = this._xrTransform.position;
    position.x = this._xrPoseVectorData[0];
    position.y = this._xrPoseVectorData[1];
    position.z = this._xrPoseVectorData[2];
    position.w = this._xrPoseVectorData[3];
    const orientation = this._xrTransform.orientation;
    orientation.x = this._xrPoseVectorData[4];
    orientation.y = this._xrPoseVectorData[5];
    orientation.z = this._xrPoseVectorData[6];
    orientation.w = this._xrPoseVectorData[7];
    return this._xrPose;
  }
  get trackedAnchors() {
    return this._nativeImpl.trackedAnchors;
  }
  get worldInformation() {
    return this._nativeImpl.worldInformation;
  }
  get detectedPlanes() {
    return this._nativeImpl.detectedPlanes;
  }
  get featurePointCloud() {
    return this._nativeImpl.featurePointCloud;
  }
};
RegisterNativeTypeAsync("NativeXRFrame", NativeXRFrame);
export {
  AbstractActionManager,
  AbstractAssetTask,
  AbstractMesh,
  AbstractScene,
  AcquireNativeObjectAsync,
  Action,
  ActionEvent,
  ActionManager,
  AddBlock,
  AddressMode,
  AdvancedTimer,
  AlphaState,
  AmmoJSPlugin,
  AnaglyphArcRotateCamera,
  AnaglyphFreeCamera,
  AnaglyphGamepadCamera,
  AnaglyphPostProcess,
  AnaglyphUniversalCamera,
  Analyser,
  AndOrNotEvaluator,
  Angle,
  Animatable,
  AnimatedInputBlockTypes,
  Animation,
  AnimationEvent,
  AnimationGroup,
  AnimationKeyInterpolation,
  AnimationPropertiesOverride,
  AnimationRange,
  AnisotropyBlock,
  ApplyPostProcess,
  Arc2,
  ArcFollowCamera,
  ArcRotateCamera,
  ArcRotateCameraGamepadInput,
  ArcRotateCameraInputsManager,
  ArcRotateCameraKeyboardMoveInput,
  ArcRotateCameraMouseWheelInput,
  ArcRotateCameraPointersInput,
  ArcRotateCameraVRDeviceOrientationInput,
  ArcTan2Block,
  AssetContainer,
  AssetTaskState,
  AssetsManager,
  AssetsProgressEvent,
  AsyncLoop,
  AttachToBoxBehavior,
  AudioEngine,
  AudioSceneComponent,
  AutoLayoutMode,
  AutoReleaseWorkerPool,
  AutoRotationBehavior,
  AxesViewer,
  Axis,
  AxisDragGizmo,
  AxisScaleGizmo,
  BRDFTextureTools,
  BabylonFileLoaderConfiguration,
  BackEase,
  BackgroundMaterial,
  BakedVertexAnimationManager,
  BaseCameraMouseWheelInput,
  BaseCameraPointersInput,
  BaseError,
  BaseParticleSystem,
  BaseSixDofDragBehavior,
  BaseTexture,
  BasisTools,
  BasisToolsOptions,
  BasisTranscodeConfiguration,
  BezierCurve,
  BezierCurveEase,
  BiPlanarBlock,
  BinaryFileAssetTask,
  BlackAndWhitePostProcess,
  BlendFactor,
  BlendOperation,
  BloomEffect,
  BloomMergePostProcess,
  BlurPostProcess,
  Bone,
  BoneAxesViewer,
  BoneIKController,
  BoneLookController,
  BonesBlock,
  BounceEase,
  BouncingBehavior,
  BoundingBox,
  BoundingBoxGizmo,
  BoundingBoxRenderer,
  BoundingInfo,
  BoundingSphere,
  BoxBuilder,
  BoxParticleEmitter,
  Buffer,
  BufferBindingType,
  BufferUsage,
  CSG,
  Camera,
  CameraGizmo,
  CameraInputTypes,
  CameraInputsManager,
  CannonJSPlugin,
  CanvasAlphaMode,
  CapsuleBuilder,
  CascadedShadowGenerator,
  ChromaticAberrationPostProcess,
  CircleEase,
  CircleOfConfusionPostProcess,
  ClampBlock,
  ClearCoatBlock,
  ClipPlanesBlock,
  ClipboardEventTypes,
  ClipboardInfo,
  CloudBlock,
  CloudPoint,
  Collider,
  Color3,
  Color3Gradient,
  Color4,
  ColorCorrectionPostProcess,
  ColorCurves,
  ColorGradient,
  ColorGradingTexture,
  ColorMergerBlock,
  ColorSplitterBlock,
  ColorWriteFlags,
  CombineAction,
  CompareFunction,
  CompatibilityOptions,
  CompilationMessageType,
  ComputeBindingType,
  ComputeEffect,
  ComputePassTimestampLocation,
  ComputeShader,
  ComputeShaderParticleSystem,
  Condition,
  ConditionalBlock,
  ConditionalBlockConditions,
  ConeParticleEmitter,
  Constants,
  ContainerAssetTask,
  ConversionMode,
  ConvolutionPostProcess,
  Coordinate,
  CopyTextureToTexture,
  CopyTools,
  CreateBox,
  CreateBoxVertexData,
  CreateCapsule,
  CreateCapsuleVertexData,
  CreateCylinder,
  CreateCylinderVertexData,
  CreateDashedLines,
  CreateDashedLinesVertexData,
  CreateDecal,
  CreateDisc,
  CreateDiscVertexData,
  CreateEnvTextureAsync,
  CreateGeodesic,
  CreateGoldberg,
  CreateGoldbergVertexData,
  CreateGround,
  CreateGroundFromHeightMap,
  CreateGroundFromHeightMapVertexData,
  CreateGroundVertexData,
  CreateHemisphere,
  CreateIcoSphere,
  CreateIcoSphereVertexData,
  CreateImageDataArrayBufferViews,
  CreateLathe,
  CreateLineSystem,
  CreateLineSystemVertexData,
  CreateLines,
  CreatePlane,
  CreatePlaneVertexData,
  CreatePolygon,
  CreatePolygonVertexData,
  CreatePolyhedron,
  CreatePolyhedronVertexData,
  CreateResizedCopy,
  CreateRibbon,
  CreateRibbonVertexData,
  CreateScreenshot,
  CreateScreenshotAsync,
  CreateScreenshotUsingRenderTarget,
  CreateScreenshotUsingRenderTargetAsync,
  CreateScreenshotWithResizeAsync,
  CreateSphere,
  CreateSphereVertexData,
  CreateTiledBox,
  CreateTiledBoxVertexData,
  CreateTiledGround,
  CreateTiledGroundVertexData,
  CreateTiledPlane,
  CreateTiledPlaneVertexData,
  CreateTorus,
  CreateTorusKnot,
  CreateTorusKnotVertexData,
  CreateTorusVertexData,
  CreateTube,
  CrossBlock,
  CubeMapToSphericalPolynomialTools,
  CubeTexture,
  CubeTextureAssetTask,
  CubicEase,
  CullMode,
  CurrentScreenBlock,
  Curve3,
  CustomBlock,
  CustomOptimization,
  CustomParticleEmitter,
  CustomProceduralTexture,
  CylinderBuilder,
  CylinderDirectedParticleEmitter,
  CylinderParticleEmitter,
  DDSTools,
  DataBuffer,
  DataReader,
  DataStorage,
  Database,
  DaydreamController,
  DebugLayer,
  DebugLayerTab,
  DecalBuilder,
  Decode,
  DecodeBase64ToBinary,
  DecodeBase64ToString,
  DecodeBase64UrlToBinary,
  DecodeBase64UrlToString,
  DeepCopier,
  DefaultCollisionCoordinator,
  DefaultLoadingScreen,
  DefaultRenderingPipeline,
  Deferred,
  DepthCullingState,
  DepthOfFieldBlurPostProcess,
  DepthOfFieldEffect,
  DepthOfFieldEffectBlurLevel,
  DepthOfFieldMergePostProcess,
  DepthOfFieldMergePostProcessOptions,
  DepthPeelingRenderer,
  DepthPeelingSceneComponent,
  DepthReducer,
  DepthRenderer,
  DepthRendererSceneComponent,
  DepthSortedParticle,
  DerivativeBlock,
  DesaturateBlock,
  DetailMapConfiguration,
  DeviceInputEventType,
  DeviceLostReason,
  DeviceOrientationCamera,
  DeviceSource,
  DeviceSourceManager,
  DeviceType,
  DirectionalLight,
  DirectionalLightFrustumViewer,
  DiscBuilder,
  DiscardBlock,
  DisplayPassPostProcess,
  DistanceBlock,
  DistanceJoint,
  DivideBlock,
  DoNothingAction,
  DomManagement,
  DotBlock,
  DracoCompression,
  DrawWrapper,
  DualSenseInput,
  DualShockButton,
  DualShockDpad,
  DualShockInput,
  DualShockPad,
  DumpTools,
  DynamicFloat32Array,
  DynamicTexture,
  EasingFunction,
  EdgesRenderer,
  Effect,
  EffectFallbacks,
  EffectLayer,
  EffectLayerSceneComponent,
  EffectRenderer,
  EffectWrapper,
  ElasticEase,
  ElbowBlock,
  EncodeArrayBufferToBase64,
  EndsWith,
  Engine,
  EngineFactory,
  EngineInstrumentation,
  EngineStore,
  EngineView,
  EnvironmentHelper,
  EnvironmentTextureTools,
  Epsilon,
  EquiRectangularCubeTexture,
  EquiRectangularCubeTextureAssetTask,
  ErrorCodes,
  ErrorFilter,
  EventConstants,
  EventState,
  ExecuteCodeAction,
  ExponentialEase,
  ExternalTexture,
  ExtractHighlightsPostProcess,
  ExtrudePolygon,
  ExtrudeShape,
  ExtrudeShapeCustom,
  FactorGradient,
  FadeInOutBehavior,
  FeatureName,
  FileTools,
  FileToolsOptions,
  FilesInput,
  FilesInputStore,
  FilterMode,
  FilterPostProcess,
  FluidRenderer,
  FluidRendererSceneComponent,
  FluidRenderingDebug,
  FluidRenderingObject,
  FluidRenderingObjectCustomParticles,
  FluidRenderingObjectParticleSystem,
  FluidRenderingTargetRenderer,
  FlyCamera,
  FlyCameraInputsManager,
  FlyCameraKeyboardInput,
  FlyCameraMouseInput,
  FogBlock,
  FollowBehavior,
  FollowCamera,
  FollowCameraInputsManager,
  FollowCameraKeyboardMoveInput,
  FollowCameraMouseWheelInput,
  FollowCameraPointersInput,
  FragCoordBlock,
  FragDepthBlock,
  FragmentOutputBlock,
  FramingBehavior,
  FreeCamera,
  FreeCameraDeviceOrientationInput,
  FreeCameraGamepadInput,
  FreeCameraInputsManager,
  FreeCameraKeyboardMoveInput,
  FreeCameraMouseInput,
  FreeCameraMouseWheelInput,
  FreeCameraTouchInput,
  FreeCameraVirtualJoystickInput,
  FresnelBlock,
  FresnelParameters,
  FromHalfFloat,
  FrontFace,
  FrontFacingBlock,
  Frustum,
  FxaaPostProcess,
  GPUParticleSystem,
  GUID,
  Gamepad,
  GamepadCamera,
  GamepadManager,
  GamepadSystemSceneComponent,
  GearVRController,
  GenerateBase64StringFromPixelData,
  GenerateBase64StringFromTexture,
  GenerateBase64StringFromTextureAsync,
  GenericController,
  GenericPad,
  GeodesicData,
  Geometry,
  GeometryBufferRenderer,
  GeometryBufferRendererSceneComponent,
  GetClass,
  GetDOMTextContent,
  GetEnvInfo,
  GetEnvironmentBRDFTexture,
  GetInternalFormatFromBasisFormat,
  GetTGAHeader,
  Gizmo,
  GizmoManager,
  GlowLayer,
  GoldbergMesh,
  GradientBlock,
  GradientBlockColorStep,
  GradientHelper,
  GrainPostProcess,
  GroundBuilder,
  GroundMesh,
  HDRCubeTexture,
  HDRCubeTextureAssetTask,
  HDRFiltering,
  HDRTools,
  HandConstraintBehavior,
  HandConstraintOrientation,
  HandConstraintVisibility,
  HandConstraintZone,
  HandPart,
  HardwareScalingOptimization,
  HeightToNormalBlock,
  HemisphereBuilder,
  HemisphericLight,
  HemisphericParticleEmitter,
  HighlightLayer,
  HighlightsPostProcess,
  Hinge2Joint,
  HingeJoint,
  HtmlElementTexture,
  IWebXRControllerPhysicsOptions,
  IcoSphereBuilder,
  ImageAssetTask,
  ImageProcessingBlock,
  ImageProcessingConfiguration,
  ImageProcessingConfigurationDefines,
  ImageProcessingPostProcess,
  ImageSourceBlock,
  IncrementValueAction,
  IndexFormat,
  InputBlock,
  InputStepMode,
  InspectableType,
  InstancedLinesMesh,
  InstancedMesh,
  InstancesBlock,
  InstantiatedEntries,
  InternalTexture,
  InternalTextureSource,
  InterpolateValueAction,
  IntersectionInfo,
  IsBase64DataUrl,
  IsDocumentAvailable,
  IsFileURL,
  IsNavigatorAvailable,
  IsWindowObjectExist,
  JoystickAxis,
  KeepAssets,
  KeyboardEventTypes,
  KeyboardInfo,
  KeyboardInfoPre,
  KhronosTextureContainer,
  KhronosTextureContainer2,
  LatheBuilder,
  Layer,
  LayerSceneComponent,
  LengthBlock,
  LensFlare,
  LensFlareSystem,
  LensFlareSystemSceneComponent,
  LensFlaresOptimization,
  LensRenderingPipeline,
  LerpBlock,
  Light,
  LightBlock,
  LightGizmo,
  LightInformationBlock,
  LineEdgesRenderer,
  LinesBuilder,
  LinesMesh,
  LoadFile,
  LoadFileError,
  LoadImage,
  LoadOp,
  LoadTextureFromTranscodeResult,
  Logger,
  MapMode,
  Material,
  MaterialAnisotropicDefines,
  MaterialClearCoatDefines,
  MaterialDefines,
  MaterialDetailMapDefines,
  MaterialFlags,
  MaterialHelper,
  MaterialIridescenceDefines,
  MaterialPluginBase,
  MaterialPluginEvent,
  MaterialPluginManager,
  MaterialSheenDefines,
  MaterialSubSurfaceDefines,
  Matrix,
  MatrixBuilderBlock,
  MatrixDeterminantBlock,
  MatrixTransposeBlock,
  MaxBlock,
  MergeMeshesOptimization,
  Mesh,
  MeshAssetTask,
  MeshBuilder,
  MeshExploder,
  MeshLODLevel,
  MeshParticleEmitter,
  MeshoptCompression,
  MinBlock,
  MinMaxReducer,
  MirrorTexture,
  ModBlock,
  ModelShape,
  MorphTarget,
  MorphTargetManager,
  MorphTargetsBlock,
  MotionBlurPostProcess,
  MotorEnabledJoint,
  MultiMaterial,
  MultiObserver,
  MultiPointerScaleBehavior,
  MultiRenderTarget,
  MultiplyBlock,
  NLerpBlock,
  NativeDataStream,
  NativeEngine,
  NativePointerInput,
  NativeXRFrame,
  NativeXRLayerRenderTargetTextureProvider,
  NativeXRLayerWrapper,
  NativeXRRenderTarget,
  NegateBlock,
  Node2 as Node,
  NodeMaterial,
  NodeMaterialBlock,
  NodeMaterialBlockConnectionPointMode,
  NodeMaterialBlockConnectionPointTypes,
  NodeMaterialBlockTargets,
  NodeMaterialConnectionPoint,
  NodeMaterialConnectionPointCompatibilityStates,
  NodeMaterialConnectionPointCustomObject,
  NodeMaterialConnectionPointDirection,
  NodeMaterialDefines,
  NodeMaterialModes,
  NodeMaterialOptimizer,
  NodeMaterialSystemValues,
  NoiseProceduralTexture,
  NormalBlendBlock,
  NormalizeBlock,
  NullEngine,
  NullEngineOptions,
  Observable,
  Observer,
  OcclusionMaterial,
  Octree,
  OctreeBlock,
  OctreeSceneComponent,
  OculusTouchController,
  OimoJSPlugin,
  OnAfterEnteringVRObservableEvent,
  OneMinusBlock,
  Orientation,
  OutlineRenderer,
  PBRAnisotropicConfiguration,
  PBRBaseMaterial,
  PBRBaseSimpleMaterial,
  PBRClearCoatConfiguration,
  PBRIridescenceConfiguration,
  PBRMaterial,
  PBRMaterialDefines,
  PBRMetallicRoughnessBlock,
  PBRMetallicRoughnessMaterial,
  PBRSheenConfiguration,
  PBRSpecularGlossinessMaterial,
  PBRSubSurfaceConfiguration,
  PHI,
  PadNumber,
  PanoramaToCubeMapTools,
  Particle,
  ParticleBlendMultiplyBlock,
  ParticleHelper,
  ParticleRampGradientBlock,
  ParticleSystem,
  ParticleSystemSet,
  ParticleTextureBlock,
  ParticlesOptimization,
  PassCubePostProcess,
  PassPostProcess,
  Path2,
  Path3D,
  PathCursor,
  PerfCollectionStrategy,
  PerfCounter,
  PerformanceConfigurator,
  PerformanceMonitor,
  PerformanceViewerCollector,
  PerturbNormalBlock,
  PhotoDome,
  PhysicsAggregate,
  PhysicsBody,
  PhysicsConstraint,
  PhysicsConstraintBallAndSocket,
  PhysicsConstraintDistance,
  PhysicsConstraintHinge,
  PhysicsConstraintLock,
  PhysicsConstraintSlider,
  PhysicsEngine,
  PhysicsEngineSceneComponent,
  PhysicsEngine2 as PhysicsEngineV2,
  PhysicsHelper,
  PhysicsImpostor,
  PhysicsJoint,
  PhysicsMaterial,
  PhysicsRadialExplosionEventOptions,
  PhysicsRadialImpulseFalloff,
  PhysicsShape,
  PhysicsShapeCapsule,
  PhysicsShapeCylinder,
  PhysicsShapeShapeBox,
  PhysicsShapeShapeContainer,
  PhysicsShapeShapeConvexHull,
  PhysicsShapeShapeMesh,
  PhysicsShapeSphere,
  PhysicsUpdraftEventOptions,
  PhysicsUpdraftMode,
  PhysicsViewer,
  PhysicsVortexEventOptions,
  PickingInfo,
  PivotTools,
  Plane,
  PlaneBuilder,
  PlaneDragGizmo,
  PlaneRotationGizmo,
  PlayAnimationAction,
  PlaySoundAction,
  PointColor,
  PointLight,
  PointParticleEmitter,
  PointerDragBehavior,
  PointerEventTypes,
  PointerInfo,
  PointerInfoBase,
  PointerInfoPre,
  PointerInput,
  PointsCloudSystem,
  PointsGroup,
  Polar,
  Polygon2 as Polygon,
  PolygonBuilder,
  PolygonMeshBuilder,
  PolyhedronBuilder,
  PolyhedronData,
  PoseEnabledController,
  PoseEnabledControllerHelper,
  PoseEnabledControllerType,
  PositionGizmo,
  PositionNormalTextureVertex,
  PositionNormalVertex,
  PostProcess,
  PostProcessManager,
  PostProcessRenderEffect,
  PostProcessRenderPipeline,
  PostProcessRenderPipelineManager,
  PostProcessRenderPipelineManagerSceneComponent,
  PostProcessesOptimization,
  PosterizeBlock,
  PowBlock,
  PowerEase,
  PowerPreference,
  PrePassRenderer,
  PrePassRendererSceneComponent,
  PrecisionDate,
  PredefinedColorSpace,
  PredicateCondition,
  PressureObserverWrapper,
  PrimitiveTopology,
  ProceduralTexture,
  ProceduralTextureSceneComponent,
  PropertyTypeForEdition,
  PushMaterial,
  QuadraticEase,
  QuadraticErrorSimplification,
  QuarticEase,
  Quaternion,
  QueryType,
  QuinticEase,
  RGBDTextureTools,
  RandomGUID,
  RandomNumberBlock,
  RawCubeTexture,
  RawTexture,
  RawTexture2DArray,
  RawTexture3D,
  Ray,
  RayHelper,
  ReadFile,
  ReadFileError,
  RecastJSCrowd,
  RecastJSPlugin,
  ReciprocalBlock,
  ReflectBlock,
  ReflectionBlock,
  ReflectionProbe,
  ReflectionTextureBlock,
  Reflector,
  RefractBlock,
  RefractionBlock,
  RefractionPostProcess,
  RefractionTexture,
  RegisterClass,
  RegisterMaterialPlugin,
  RegisterNativeTypeAsync,
  RemapBlock,
  RenderPassTimestampLocation,
  RenderTargetTexture,
  RenderTargetWrapper,
  RenderTargetsOptimization,
  RenderingGroup,
  RenderingGroupInfo,
  RenderingManager,
  ReplaceColorBlock,
  RequestFile,
  RequestFileError,
  RetryStrategy,
  RibbonBuilder,
  RollingAverage,
  Rotate2dBlock,
  RotationGizmo,
  RuntimeAnimation,
  RuntimeError,
  SSAO2RenderingPipeline,
  SSAORenderingPipeline,
  SamplerBindingType,
  Scalar,
  ScaleBlock,
  ScaleGizmo,
  Scene,
  SceneComponentConstants,
  SceneDepthBlock,
  SceneInstrumentation,
  SceneLoader,
  SceneLoaderAnimationGroupLoadingMode,
  SceneLoaderFlags,
  SceneOptimization,
  SceneOptimizer,
  SceneOptimizerOptions,
  ScenePerformancePriority,
  SceneRecorder,
  SceneSerializer,
  ScreenSizeBlock,
  ScreenSpaceBlock,
  ScreenSpaceCurvaturePostProcess,
  ScreenSpaceReflectionPostProcess,
  ScreenshotTools,
  SerializationHelper,
  SetCorsBehavior,
  SetParentAction,
  SetStateAction,
  SetValueAction,
  ShaderCodeInliner,
  ShaderLanguage,
  ShaderMaterial,
  ShaderStage,
  ShaderStore,
  ShadowDepthWrapper,
  ShadowGenerator,
  ShadowGeneratorSceneComponent,
  ShadowLight,
  ShadowMapBlock,
  ShadowsOptimization,
  ShapeBuilder,
  SharpenPostProcess,
  SheenBlock,
  SimplexPerlin3DBlock,
  SimplicationQueueSceneComponent,
  SimplificationQueue,
  SimplificationSettings,
  SimplificationType,
  SineEase,
  SixDofDragBehavior,
  Size,
  Skeleton,
  SkeletonViewer,
  SmartArray,
  SmartArrayNoDuplicate,
  SmoothStepBlock,
  SolidParticle,
  SolidParticleSystem,
  SolidParticleVertex,
  Sound,
  SoundTrack,
  Space,
  SphereBuilder,
  SphereDirectedParticleEmitter,
  SphereParticleEmitter,
  Spherical,
  SphericalHarmonics,
  SphericalPolynomial,
  SpotLight,
  Sprite,
  SpriteManager,
  SpriteMap,
  SpritePackedManager,
  SpriteSceneComponent,
  Stage,
  StandardMaterial,
  StandardMaterialDefines,
  StandardRenderingPipeline,
  StartsWith,
  StateCondition,
  StencilOperation,
  StencilState,
  StencilStateComposer,
  StepBlock,
  StereoscopicArcRotateCamera,
  StereoscopicFreeCamera,
  StereoscopicGamepadCamera,
  StereoscopicInterlacePostProcess,
  StereoscopicInterlacePostProcessI,
  StereoscopicScreenUniversalCamera,
  StereoscopicUniversalCamera,
  StickValues,
  StopAnimationAction,
  StopSoundAction,
  StorageBuffer,
  StorageTextureAccess,
  StoreOp,
  StringDictionary,
  StringTools,
  SubEmitter,
  SubEmitterType,
  SubMesh,
  SubSurfaceBlock,
  SubSurfaceSceneComponent,
  SubtractBlock,
  SurfaceMagnetismBehavior,
  SwitchBooleanAction,
  SwitchInput,
  TBNBlock,
  TGATools,
  Tags,
  TargetCamera,
  TargetedAnimation,
  TestBase64DataUrl,
  TextFileAssetTask,
  Texture,
  TextureAspect,
  TextureAssetTask,
  TextureBlock,
  TextureDimension,
  TextureFormat,
  TextureOptimization,
  TexturePacker,
  TexturePackerFrame,
  TextureSampleType,
  TextureSampler,
  TextureTools,
  TextureUsage,
  TextureViewDimension,
  ThinEngine,
  ThinRenderTargetTexture,
  ThinTexture,
  TiledBoxBuilder,
  TiledPlaneBuilder,
  TimerState,
  TmpColors,
  TmpVectors,
  ToGammaSpace,
  ToHalfFloat,
  ToLinearSpace,
  TonemapPostProcess,
  TonemappingOperator,
  Tools,
  TorusBuilder,
  TorusKnotBuilder,
  TouchCamera,
  TrailMesh,
  Trajectory,
  TrajectoryClassifier,
  TranscodeAsync,
  TransformBlock,
  TransformNode,
  TriPlanarBlock,
  TrigonometryBlock,
  TrigonometryBlockOperations,
  TubeBuilder,
  TwirlBlock,
  UniformBuffer,
  UniversalCamera,
  UnregisterAllMaterialPlugins,
  UnregisterMaterialPlugin,
  UploadContent,
  UploadEnvLevelsAsync,
  UploadEnvSpherical,
  UploadLevelsAsync,
  UtilityLayerRenderer,
  VRCameraMetrics,
  VRDeviceOrientationArcRotateCamera,
  VRDeviceOrientationFreeCamera,
  VRDeviceOrientationGamepadCamera,
  VRDistortionCorrectionPostProcess,
  VRExperienceHelper,
  VRMultiviewToSingleviewPostProcess,
  ValidatedNativeDataStream,
  ValueCondition,
  Vector2,
  Vector3,
  Vector4,
  VectorMergerBlock,
  VectorSplitterBlock,
  VertexAnimationBaker,
  VertexBuffer,
  VertexData,
  VertexFormat,
  VertexOutputBlock,
  VideoDome,
  VideoRecorder,
  VideoTexture,
  ViewDirectionBlock,
  Viewport,
  VirtualJoystick,
  VirtualJoysticksCamera,
  ViveController,
  VolumetricLightScatteringPostProcess,
  VoronoiNoiseBlock,
  WaveBlock,
  WaveBlockKind,
  WebGL2ParticleSystem,
  WebGL2ShaderProcessor,
  WebGLDataBuffer,
  WebGLHardwareTexture,
  WebGLPipelineContext,
  WebGPUCacheBindGroups,
  WebGPUCacheRenderPipeline,
  WebGPUCacheRenderPipelineTree,
  WebGPUCacheSampler,
  WebGPUDataBuffer,
  WebGPUDrawContext,
  WebGPUEngine,
  WebGPUTintWASM,
  WebRequest,
  WebVRController,
  WebVRFreeCamera,
  WebXRAbstractFeature,
  WebXRAbstractMotionController,
  WebXRAnchorSystem,
  WebXRBackgroundRemover,
  WebXRCamera,
  WebXRCompositionLayerWrapper,
  WebXRControllerComponent,
  WebXRControllerMovement,
  WebXRControllerPhysics,
  WebXRControllerPointerSelection,
  WebXRDefaultExperience,
  WebXRDefaultExperienceOptions,
  WebXRDomOverlay,
  WebXREnterExitUI,
  WebXREnterExitUIButton,
  WebXREnterExitUIOptions,
  WebXRExperienceHelper,
  WebXREyeTracking,
  WebXRFeatureName,
  WebXRFeaturePointSystem,
  WebXRFeaturesManager,
  WebXRGenericHandController,
  WebXRGenericTriggerMotionController,
  WebXRHTCViveMotionController,
  WebXRHand,
  WebXRHandJoint,
  WebXRHandTracking,
  WebXRHitTest,
  WebXRHitTestLegacy,
  WebXRImageTracking,
  WebXRInput,
  WebXRInputSource,
  WebXRLayers,
  WebXRLightEstimation,
  WebXRManagedOutputCanvas,
  WebXRManagedOutputCanvasOptions,
  WebXRMeshDetector,
  WebXRMicrosoftMixedRealityController,
  WebXRMotionControllerManager,
  WebXRMotionControllerTeleportation,
  WebXRNearControllerMode,
  WebXRNearInteraction,
  WebXROculusTouchMotionController,
  WebXRPlaneDetector,
  WebXRProfiledMotionController,
  WebXRProjectionLayerWrapper,
  WebXRSessionManager,
  WebXRState,
  WebXRTrackingState,
  WebXRWalkingLocomotion,
  WeightedSound,
  WindowsMotionController,
  WorkerPool,
  WorleyNoise3DBlock,
  XRWindowsMotionController,
  Xbox360Button,
  Xbox360Dpad,
  Xbox360Pad,
  XboxInput,
  _BabylonLoaderRegistered,
  _BasisTextureLoader,
  _CreationDataStorage,
  _DDSTextureLoader,
  _ENVTextureLoader,
  _HDRTextureLoader,
  _IAnimationState,
  _InstancesBatch,
  _KTXTextureLoader,
  _MeshCollisionData,
  _OcclusionDataStorage,
  _PrimaryIsoTriangle,
  _TGATextureLoader,
  _TimeToken,
  _UpdateRGBDAsync,
  _forceSceneHelpersToBundle,
  _forceTransformFeedbackToBundle,
  _injectLTSFileTools,
  addClipPlaneUniforms,
  allocateAndCopyTypedBuffer,
  bindClipPlane,
  className,
  createDetailMapPlugin,
  createPBRAnisotropicPlugin,
  createPBRBRDFPlugin,
  createPBRClearCoatPlugin,
  createPBRIridescencePlugin,
  createPBRSheenPlugin,
  createPBRSubSurfacePlugin,
  createYieldingScheduler,
  editableInPropertyPage,
  expandToProperty,
  extractMinAndMax,
  extractMinAndMaxIndexed,
  inlineScheduler,
  makeAsyncFunction,
  makeSyncFunction,
  nativeOverride,
  normalizeEnvInfo,
  prepareDefinesForClipPlanes,
  runCoroutine,
  runCoroutineAsync,
  runCoroutineSync,
  serialize,
  serializeAsCameraReference,
  serializeAsColor3,
  serializeAsColor4,
  serializeAsColorCurves,
  serializeAsFresnelParameters,
  serializeAsImageProcessingConfiguration,
  serializeAsMatrix,
  serializeAsMeshReference,
  serializeAsQuaternion,
  serializeAsTexture,
  serializeAsVector2,
  serializeAsVector3,
  setAndStartTimer,
  setStereoscopicAnaglyphRigMode,
  setStereoscopicRigMode,
  setVRRigMode,
  setWebVRRigMode
};
//# sourceMappingURL=@babylonjs_core.js.map
