import {
  AbstractMesh,
  ArrayTools,
  Axis,
  Camera,
  Color3,
  Color4,
  CompatibilityOptions,
  DeepCopier,
  DrawWrapper,
  Effect,
  EffectFallbacks,
  Engine,
  EngineStore,
  Epsilon,
  GetClass,
  HemisphericLight,
  ImageProcessingConfigurationDefines,
  InternalTexture,
  InternalTextureSource,
  IntersectionInfo,
  Light,
  Logger,
  Material,
  MaterialDefines,
  MaterialHelper,
  Matrix,
  Mesh,
  Observable,
  PickingInfo,
  PointerEventTypes,
  PointerInfo,
  PostProcess,
  PrecisionDate,
  PushMaterial,
  Quaternion,
  RegisterClass,
  RenderTargetTexture,
  Scalar,
  Scene,
  SceneComponentConstants,
  SceneLoader,
  ScenePerformancePriority,
  SerializationHelper,
  ShaderStore,
  Space,
  Texture,
  ThinEngine,
  TimingTools,
  TmpColors,
  TmpVectors,
  Tools,
  TransformNode,
  UniqueIdGenerator,
  Vector2,
  Vector3,
  Vector4,
  VertexBuffer,
  VertexData,
  WebRequest,
  __decorate,
  serialize
} from "./chunk-PPM2REY6.js";

// node_modules/@babylonjs/core/Behaviors/Meshes/fadeInOutBehavior.js
var FadeInOutBehavior = class {
  constructor() {
    this.fadeInDelay = 0;
    this.fadeOutDelay = 0;
    this.fadeInTime = 300;
    this.fadeOutTime = 300;
    this._millisecondsPerFrame = 1e3 / 60;
    this._hovered = false;
    this._hoverValue = 0;
    this._ownerNode = null;
    this._delay = 0;
    this._time = 300;
    this._update = () => {
      if (this._ownerNode) {
        this._hoverValue += this._hovered ? this._millisecondsPerFrame : -this._millisecondsPerFrame;
        this._setAllVisibility(this._ownerNode, (this._hoverValue - this._delay) / this._time);
        if (this._ownerNode.visibility > 1) {
          this._setAllVisibility(this._ownerNode, 1);
          if (this._hoverValue > this._time) {
            this._hoverValue = this._time;
            this._detachObserver();
            return;
          }
        } else if (this._ownerNode.visibility < 0) {
          this._setAllVisibility(this._ownerNode, 0);
          if (this._hoverValue < 0) {
            this._hoverValue = 0;
            this._detachObserver();
            return;
          }
        }
        this._attachObserver();
      }
    };
  }
  get delay() {
    return this.fadeInDelay;
  }
  set delay(value) {
    this.fadeInDelay = value;
    this.fadeOutDelay = value;
  }
  get name() {
    return "FadeInOut";
  }
  init() {
  }
  attach(ownerNode) {
    this._ownerNode = ownerNode;
    this._setAllVisibility(this._ownerNode, 0);
  }
  detach() {
    this._ownerNode = null;
  }
  fadeIn(fadeIn = true) {
    this._delay = fadeIn ? this.fadeInDelay : this.fadeOutDelay;
    this._time = fadeIn ? this.fadeInTime : this.fadeOutTime;
    this._detachObserver();
    if (this._ownerNode && (fadeIn && this._ownerNode.visibility >= 1 || !fadeIn && this._ownerNode.visibility <= 0)) {
      return;
    }
    this._hovered = fadeIn;
    if (!this._hovered) {
      this._delay *= -1;
    }
    if (this._ownerNode.visibility >= 1) {
      this._hoverValue = this._time;
    } else if (this._ownerNode.visibility <= 0) {
      this._hoverValue = 0;
    }
    this._update();
  }
  fadeOut() {
    this.fadeIn(false);
  }
  _setAllVisibility(mesh, value) {
    mesh.visibility = value;
    mesh.getChildMeshes().forEach((c) => {
      this._setAllVisibility(c, value);
    });
  }
  _attachObserver() {
    var _a;
    if (!this._onBeforeRenderObserver) {
      this._onBeforeRenderObserver = (_a = this._ownerNode) === null || _a === void 0 ? void 0 : _a.getScene().onBeforeRenderObservable.add(this._update);
    }
  }
  _detachObserver() {
    var _a;
    if (this._onBeforeRenderObserver) {
      (_a = this._ownerNode) === null || _a === void 0 ? void 0 : _a.getScene().onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
      this._onBeforeRenderObserver = null;
    }
  }
};

// node_modules/@babylonjs/core/Culling/ray.js
var Ray = class {
  constructor(origin, direction, length = Number.MAX_VALUE) {
    this.origin = origin;
    this.direction = direction;
    this.length = length;
  }
  clone() {
    return new Ray(this.origin.clone(), this.direction.clone(), this.length);
  }
  intersectsBoxMinMax(minimum, maximum, intersectionTreshold = 0) {
    const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);
    const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);
    let d = 0;
    let maxValue = Number.MAX_VALUE;
    let inv;
    let min;
    let max;
    let temp;
    if (Math.abs(this.direction.x) < 1e-7) {
      if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {
        return false;
      }
    } else {
      inv = 1 / this.direction.x;
      min = (newMinimum.x - this.origin.x) * inv;
      max = (newMaximum.x - this.origin.x) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    if (Math.abs(this.direction.y) < 1e-7) {
      if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {
        return false;
      }
    } else {
      inv = 1 / this.direction.y;
      min = (newMinimum.y - this.origin.y) * inv;
      max = (newMaximum.y - this.origin.y) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    if (Math.abs(this.direction.z) < 1e-7) {
      if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {
        return false;
      }
    } else {
      inv = 1 / this.direction.z;
      min = (newMinimum.z - this.origin.z) * inv;
      max = (newMaximum.z - this.origin.z) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box, intersectionTreshold = 0) {
    return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);
  }
  intersectsSphere(sphere, intersectionTreshold = 0) {
    const x = sphere.center.x - this.origin.x;
    const y = sphere.center.y - this.origin.y;
    const z = sphere.center.z - this.origin.z;
    const pyth = x * x + y * y + z * z;
    const radius = sphere.radius + intersectionTreshold;
    const rr = radius * radius;
    if (pyth <= rr) {
      return true;
    }
    const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;
    if (dot < 0) {
      return false;
    }
    const temp = pyth - dot * dot;
    return temp <= rr;
  }
  intersectsTriangle(vertex0, vertex1, vertex2) {
    const edge1 = Ray._TmpVector3[0];
    const edge2 = Ray._TmpVector3[1];
    const pvec = Ray._TmpVector3[2];
    const tvec = Ray._TmpVector3[3];
    const qvec = Ray._TmpVector3[4];
    vertex1.subtractToRef(vertex0, edge1);
    vertex2.subtractToRef(vertex0, edge2);
    Vector3.CrossToRef(this.direction, edge2, pvec);
    const det = Vector3.Dot(edge1, pvec);
    if (det === 0) {
      return null;
    }
    const invdet = 1 / det;
    this.origin.subtractToRef(vertex0, tvec);
    const bv = Vector3.Dot(tvec, pvec) * invdet;
    if (bv < 0 || bv > 1) {
      return null;
    }
    Vector3.CrossToRef(tvec, edge1, qvec);
    const bw = Vector3.Dot(this.direction, qvec) * invdet;
    if (bw < 0 || bv + bw > 1) {
      return null;
    }
    const distance = Vector3.Dot(edge2, qvec) * invdet;
    if (distance > this.length) {
      return null;
    }
    return new IntersectionInfo(1 - bv - bw, bv, distance);
  }
  intersectsPlane(plane) {
    let distance;
    const result1 = Vector3.Dot(plane.normal, this.direction);
    if (Math.abs(result1) < 999999997475243e-21) {
      return null;
    } else {
      const result2 = Vector3.Dot(plane.normal, this.origin);
      distance = (-plane.d - result2) / result1;
      if (distance < 0) {
        if (distance < -999999997475243e-21) {
          return null;
        } else {
          return 0;
        }
      }
      return distance;
    }
  }
  intersectsAxis(axis, offset = 0) {
    switch (axis) {
      case "y": {
        const t = (this.origin.y - offset) / this.direction.y;
        if (t > 0) {
          return null;
        }
        return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);
      }
      case "x": {
        const t = (this.origin.x - offset) / this.direction.x;
        if (t > 0) {
          return null;
        }
        return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);
      }
      case "z": {
        const t = (this.origin.z - offset) / this.direction.z;
        if (t > 0) {
          return null;
        }
        return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);
      }
      default:
        return null;
    }
  }
  intersectsMesh(mesh, fastCheck) {
    const tm = TmpVectors.Matrix[0];
    mesh.getWorldMatrix().invertToRef(tm);
    if (this._tmpRay) {
      Ray.TransformToRef(this, tm, this._tmpRay);
    } else {
      this._tmpRay = Ray.Transform(this, tm);
    }
    return mesh.intersects(this._tmpRay, fastCheck);
  }
  intersectsMeshes(meshes, fastCheck, results) {
    if (results) {
      results.length = 0;
    } else {
      results = [];
    }
    for (let i = 0; i < meshes.length; i++) {
      const pickInfo = this.intersectsMesh(meshes[i], fastCheck);
      if (pickInfo.hit) {
        results.push(pickInfo);
      }
    }
    results.sort(this._comparePickingInfo);
    return results;
  }
  _comparePickingInfo(pickingInfoA, pickingInfoB) {
    if (pickingInfoA.distance < pickingInfoB.distance) {
      return -1;
    } else if (pickingInfoA.distance > pickingInfoB.distance) {
      return 1;
    } else {
      return 0;
    }
  }
  intersectionSegment(sega, segb, threshold) {
    const o = this.origin;
    const u = TmpVectors.Vector3[0];
    const rsegb = TmpVectors.Vector3[1];
    const v = TmpVectors.Vector3[2];
    const w = TmpVectors.Vector3[3];
    segb.subtractToRef(sega, u);
    this.direction.scaleToRef(Ray._Rayl, v);
    o.addToRef(v, rsegb);
    sega.subtractToRef(o, w);
    const a = Vector3.Dot(u, u);
    const b = Vector3.Dot(u, v);
    const c = Vector3.Dot(v, v);
    const d = Vector3.Dot(u, w);
    const e = Vector3.Dot(v, w);
    const D = a * c - b * b;
    let sN, sD = D;
    let tN, tD = D;
    if (D < Ray._Smallnum) {
      sN = 0;
      sD = 1;
      tN = e;
      tD = c;
    } else {
      sN = b * e - c * d;
      tN = a * e - b * d;
      if (sN < 0) {
        sN = 0;
        tN = e;
        tD = c;
      } else if (sN > sD) {
        sN = sD;
        tN = e + b;
        tD = c;
      }
    }
    if (tN < 0) {
      tN = 0;
      if (-d < 0) {
        sN = 0;
      } else if (-d > a) {
        sN = sD;
      } else {
        sN = -d;
        sD = a;
      }
    } else if (tN > tD) {
      tN = tD;
      if (-d + b < 0) {
        sN = 0;
      } else if (-d + b > a) {
        sN = sD;
      } else {
        sN = -d + b;
        sD = a;
      }
    }
    const sc = Math.abs(sN) < Ray._Smallnum ? 0 : sN / sD;
    const tc = Math.abs(tN) < Ray._Smallnum ? 0 : tN / tD;
    const qtc = TmpVectors.Vector3[4];
    v.scaleToRef(tc, qtc);
    const qsc = TmpVectors.Vector3[5];
    u.scaleToRef(sc, qsc);
    qsc.addInPlace(w);
    const dP = TmpVectors.Vector3[6];
    qsc.subtractToRef(qtc, dP);
    const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold;
    if (isIntersected) {
      return qsc.length();
    }
    return -1;
  }
  update(x, y, viewportWidth, viewportHeight, world, view, projection, enableDistantPicking = false) {
    if (enableDistantPicking) {
      if (!Ray._RayDistant) {
        Ray._RayDistant = Ray.Zero();
      }
      Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);
      const tm = TmpVectors.Matrix[0];
      world.invertToRef(tm);
      Ray.TransformToRef(Ray._RayDistant, tm, this);
    } else {
      this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);
    }
    return this;
  }
  static Zero() {
    return new Ray(Vector3.Zero(), Vector3.Zero());
  }
  static CreateNew(x, y, viewportWidth, viewportHeight, world, view, projection) {
    const result = Ray.Zero();
    return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);
  }
  static CreateNewFromTo(origin, end, world = Matrix.IdentityReadOnly) {
    const direction = end.subtract(origin);
    const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
    direction.normalize();
    return Ray.Transform(new Ray(origin, direction, length), world);
  }
  static Transform(ray, matrix) {
    const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    Ray.TransformToRef(ray, matrix, result);
    return result;
  }
  static TransformToRef(ray, matrix, result) {
    Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);
    Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);
    result.length = ray.length;
    const dir = result.direction;
    const len = dir.length();
    if (!(len === 0 || len === 1)) {
      const num = 1 / len;
      dir.x *= num;
      dir.y *= num;
      dir.z *= num;
      result.length *= len;
    }
  }
  unprojectRayToRef(sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {
    var _a;
    const matrix = TmpVectors.Matrix[0];
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    matrix.invert();
    const nearScreenSource = TmpVectors.Vector3[0];
    nearScreenSource.x = sourceX / viewportWidth * 2 - 1;
    nearScreenSource.y = -(sourceY / viewportHeight * 2 - 1);
    nearScreenSource.z = ((_a = EngineStore.LastCreatedEngine) === null || _a === void 0 ? void 0 : _a.isNDCHalfZRange) ? 0 : -1;
    const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1 - 1e-8);
    const nearVec3 = TmpVectors.Vector3[2];
    const farVec3 = TmpVectors.Vector3[3];
    Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);
    Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);
    this.origin.copyFrom(nearVec3);
    farVec3.subtractToRef(nearVec3, this.direction);
    this.direction.normalize();
  }
};
Ray._TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);
Ray._RayDistant = Ray.Zero();
Ray._Smallnum = 1e-8;
Ray._Rayl = 1e9;
Scene.prototype.createPickingRay = function(x, y, world, camera, cameraViewSpace = false) {
  const result = Ray.Zero();
  this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);
  return result;
};
Scene.prototype.createPickingRayToRef = function(x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {
  const engine = this.getEngine();
  if (!camera) {
    if (!this.activeCamera) {
      return this;
    }
    camera = this.activeCamera;
  }
  const cameraViewport = camera.viewport;
  const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());
  x = x / engine.getHardwareScalingLevel() - viewport.x;
  y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);
  result.update(x, y, viewport.width, viewport.height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix(), enableDistantPicking);
  return this;
};
Scene.prototype.createPickingRayInCameraSpace = function(x, y, camera) {
  const result = Ray.Zero();
  this.createPickingRayInCameraSpaceToRef(x, y, result, camera);
  return result;
};
Scene.prototype.createPickingRayInCameraSpaceToRef = function(x, y, result, camera) {
  if (!PickingInfo) {
    return this;
  }
  const engine = this.getEngine();
  if (!camera) {
    if (!this.activeCamera) {
      throw new Error("Active camera not set");
    }
    camera = this.activeCamera;
  }
  const cameraViewport = camera.viewport;
  const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());
  const identity = Matrix.Identity();
  x = x / engine.getHardwareScalingLevel() - viewport.x;
  y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);
  result.update(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());
  return this;
};
Scene.prototype._internalPickForMesh = function(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {
  const ray = rayFunction(world, mesh.enableDistantPicking);
  const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);
  if (!result || !result.hit) {
    return null;
  }
  if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {
    return null;
  }
  return result;
};
Scene.prototype._internalPick = function(rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {
  let pickingInfo = null;
  for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
    const mesh = this.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    const world = mesh.getWorldMatrix();
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        if (onlyBoundingInfo) {
          return result;
        }
        const tmpMatrix = TmpVectors.Matrix[1];
        const thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (let index = 0; index < thinMatrices.length; index++) {
          const thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix);
          const result2 = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);
          if (result2) {
            pickingInfo = result2;
            pickingInfo.thinInstanceIndex = index;
            if (fastCheck) {
              return pickingInfo;
            }
          }
        }
      }
    } else {
      const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);
      if (result) {
        pickingInfo = result;
        if (fastCheck) {
          return pickingInfo;
        }
      }
    }
  }
  return pickingInfo || new PickingInfo();
};
Scene.prototype._internalMultiPick = function(rayFunction, predicate, trianglePredicate) {
  if (!PickingInfo) {
    return null;
  }
  const pickingInfos = new Array();
  for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
    const mesh = this.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    const world = mesh.getWorldMatrix();
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      const result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        const tmpMatrix = TmpVectors.Matrix[1];
        const thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (let index = 0; index < thinMatrices.length; index++) {
          const thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix);
          const result2 = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);
          if (result2) {
            result2.thinInstanceIndex = index;
            pickingInfos.push(result2);
          }
        }
      }
    } else {
      const result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);
      if (result) {
        pickingInfos.push(result);
      }
    }
  }
  return pickingInfos;
};
Scene.prototype.pickWithBoundingInfo = function(x, y, predicate, fastCheck, camera) {
  if (!PickingInfo) {
    return null;
  }
  const result = this._internalPick((world) => {
    if (!this._tempPickingRay) {
      this._tempPickingRay = Ray.Zero();
    }
    this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null);
    return this._tempPickingRay;
  }, predicate, fastCheck, true);
  if (result) {
    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);
  }
  return result;
};
Object.defineProperty(Scene.prototype, "_pickingAvailable", {
  get: () => true,
  enumerable: false,
  configurable: false
});
Scene.prototype.pick = function(x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {
  const result = this._internalPick((world, enableDistantPicking) => {
    if (!this._tempPickingRay) {
      this._tempPickingRay = Ray.Zero();
    }
    this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null, false, enableDistantPicking);
    return this._tempPickingRay;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);
  }
  return result;
};
Scene.prototype.pickWithRay = function(ray, predicate, fastCheck, trianglePredicate) {
  const result = this._internalPick((world) => {
    if (!this._pickWithRayInverseMatrix) {
      this._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(this._pickWithRayInverseMatrix);
    if (!this._cachedRayForTransform) {
      this._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);
    return this._cachedRayForTransform;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = ray;
  }
  return result;
};
Scene.prototype.multiPick = function(x, y, predicate, camera, trianglePredicate) {
  return this._internalMultiPick((world) => this.createPickingRay(x, y, world, camera || null), predicate, trianglePredicate);
};
Scene.prototype.multiPickWithRay = function(ray, predicate, trianglePredicate) {
  return this._internalMultiPick((world) => {
    if (!this._pickWithRayInverseMatrix) {
      this._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(this._pickWithRayInverseMatrix);
    if (!this._cachedRayForTransform) {
      this._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);
    return this._cachedRayForTransform;
  }, predicate, trianglePredicate);
};
Camera.prototype.getForwardRay = function(length = 100, transform, origin) {
  return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);
};
Camera.prototype.getForwardRayToRef = function(refRay, length = 100, transform, origin) {
  if (!transform) {
    transform = this.getWorldMatrix();
  }
  refRay.length = length;
  if (!origin) {
    refRay.origin.copyFrom(this.position);
  } else {
    refRay.origin.copyFrom(origin);
  }
  TmpVectors.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
  Vector3.TransformNormalToRef(TmpVectors.Vector3[2], transform, TmpVectors.Vector3[3]);
  Vector3.NormalizeToRef(TmpVectors.Vector3[3], refRay.direction);
  return refRay;
};

// node_modules/@babylonjs/core/Misc/pivotTools.js
var PivotTools = class {
  static _RemoveAndStorePivotPoint(mesh) {
    if (mesh && PivotTools._PivotCached === 0) {
      mesh.getPivotPointToRef(PivotTools._OldPivotPoint);
      PivotTools._PivotPostMultiplyPivotMatrix = mesh._postMultiplyPivotMatrix;
      if (!PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0)) {
        mesh.setPivotMatrix(Matrix.IdentityReadOnly);
        PivotTools._OldPivotPoint.subtractToRef(mesh.getPivotPoint(), PivotTools._PivotTranslation);
        PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);
        PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);
        PivotTools._PivotTmpVector.multiplyInPlace(PivotTools._PivotTranslation);
        mesh.position.addInPlace(PivotTools._PivotTmpVector);
      }
    }
    PivotTools._PivotCached++;
  }
  static _RestorePivotPoint(mesh) {
    if (mesh && !PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0) && PivotTools._PivotCached === 1) {
      mesh.setPivotPoint(PivotTools._OldPivotPoint);
      mesh._postMultiplyPivotMatrix = PivotTools._PivotPostMultiplyPivotMatrix;
      PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);
      PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);
      PivotTools._PivotTmpVector.multiplyInPlace(PivotTools._PivotTranslation);
      mesh.position.subtractInPlace(PivotTools._PivotTmpVector);
    }
    this._PivotCached--;
  }
};
PivotTools._PivotCached = 0;
PivotTools._OldPivotPoint = new Vector3();
PivotTools._PivotTranslation = new Vector3();
PivotTools._PivotTmpVector = new Vector3();
PivotTools._PivotPostMultiplyPivotMatrix = false;

// node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js
function CreatePlaneVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const halfWidth = width / 2;
  const halfHeight = height / 2;
  positions.push(-halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 : 0);
  positions.push(halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 : 0);
  positions.push(halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, CompatibilityOptions.UseOpenGLOrientationForUV ? 0 : 1);
  positions.push(-halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0 : 1);
  indices.push(0);
  indices.push(1);
  indices.push(2);
  indices.push(0);
  indices.push(2);
  indices.push(3);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreatePlane(name4, options = {}, scene = null) {
  const plane = new Mesh(name4, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  plane._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreatePlaneVertexData(options);
  vertexData.applyToMesh(plane, options.updatable);
  if (options.sourcePlane) {
    plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);
    plane.setDirection(options.sourcePlane.normal.scale(-1));
  }
  return plane;
}
var PlaneBuilder = {
  CreatePlane
};
VertexData.CreatePlane = CreatePlaneVertexData;
Mesh.CreatePlane = (name4, size, scene, updatable, sideOrientation) => {
  const options = {
    size,
    width: size,
    height: size,
    sideOrientation,
    updatable
  };
  return CreatePlane(name4, options, scene);
};

// node_modules/@babylonjs/core/Behaviors/Meshes/pointerDragBehavior.js
var PointerDragBehavior = class {
  constructor(options) {
    this._useAlternatePickedPointAboveMaxDragAngleDragSpeed = -1.1;
    this._activeDragButton = -1;
    this.maxDragAngle = 0;
    this.dragButtons = [0, 1, 2];
    this._useAlternatePickedPointAboveMaxDragAngle = false;
    this.currentDraggingPointerId = -1;
    this.dragging = false;
    this.dragDeltaRatio = 0.2;
    this.updateDragPlane = true;
    this._debugMode = false;
    this._moving = false;
    this.onDragObservable = new Observable();
    this.onDragStartObservable = new Observable();
    this.onDragEndObservable = new Observable();
    this.onEnabledObservable = new Observable();
    this.moveAttached = true;
    this._enabled = true;
    this.startAndReleaseDragOnPointerEvents = true;
    this.detachCameraControls = true;
    this.useObjectOrientationForDragging = true;
    this.validateDrag = (targetPosition) => {
      return true;
    };
    this._tmpVector = new Vector3(0, 0, 0);
    this._alternatePickedPoint = new Vector3(0, 0, 0);
    this._worldDragAxis = new Vector3(0, 0, 0);
    this._targetPosition = new Vector3(0, 0, 0);
    this._attachedToElement = false;
    this._startDragRay = new Ray(new Vector3(), new Vector3());
    this._lastPointerRay = {};
    this._dragDelta = new Vector3();
    this._pointA = new Vector3(0, 0, 0);
    this._pointC = new Vector3(0, 0, 0);
    this._localAxis = new Vector3(0, 0, 0);
    this._lookAt = new Vector3(0, 0, 0);
    this._options = options ? options : {};
    let optionCount = 0;
    if (this._options.dragAxis) {
      optionCount++;
    }
    if (this._options.dragPlaneNormal) {
      optionCount++;
    }
    if (optionCount > 1) {
      throw "Multiple drag modes specified in dragBehavior options. Only one expected";
    }
  }
  get currentDraggingPointerID() {
    return this.currentDraggingPointerId;
  }
  set currentDraggingPointerID(currentDraggingPointerID) {
    this.currentDraggingPointerId = currentDraggingPointerID;
  }
  set enabled(value) {
    if (value != this._enabled) {
      this.onEnabledObservable.notifyObservers(value);
    }
    this._enabled = value;
  }
  get enabled() {
    return this._enabled;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this._options = options;
  }
  get name() {
    return "PointerDrag";
  }
  init() {
  }
  attach(ownerNode, predicate) {
    this._scene = ownerNode.getScene();
    ownerNode.isNearGrabbable = true;
    this.attachedNode = ownerNode;
    if (!PointerDragBehavior._PlaneScene) {
      if (this._debugMode) {
        PointerDragBehavior._PlaneScene = this._scene;
      } else {
        PointerDragBehavior._PlaneScene = new Scene(this._scene.getEngine(), { virtual: true });
        PointerDragBehavior._PlaneScene.detachControl();
        this._scene.onDisposeObservable.addOnce(() => {
          PointerDragBehavior._PlaneScene.dispose();
          PointerDragBehavior._PlaneScene = null;
        });
      }
    }
    this._dragPlane = CreatePlane("pointerDragPlane", { size: this._debugMode ? 1 : 1e4, updatable: false, sideOrientation: Mesh.DOUBLESIDE }, PointerDragBehavior._PlaneScene);
    this.lastDragPosition = new Vector3(0, 0, 0);
    const pickPredicate = predicate ? predicate : (m) => {
      return this.attachedNode == m || m.isDescendantOf(this.attachedNode);
    };
    this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {
      if (!this.enabled) {
        if (this._attachedToElement) {
          this.releaseDrag();
        }
        return;
      }
      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
        if (this.startAndReleaseDragOnPointerEvents && !this.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedPoint && pointerInfo.pickInfo.ray && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {
          if (this._activeDragButton === -1 && this.dragButtons.indexOf(pointerInfo.event.button) !== -1) {
            this._activeDragButton = pointerInfo.event.button;
            this._activePointerInfo = pointerInfo;
            this._startDrag(pointerInfo.event.pointerId, pointerInfo.pickInfo.ray, pointerInfo.pickInfo.pickedPoint);
          }
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERUP) {
        if (this.startAndReleaseDragOnPointerEvents && this.currentDraggingPointerId == pointerInfo.event.pointerId && this._activeDragButton === pointerInfo.event.button) {
          this.releaseDrag();
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {
        const pointerId = pointerInfo.event.pointerId;
        if (this.currentDraggingPointerId === PointerDragBehavior._AnyMouseId && pointerId !== PointerDragBehavior._AnyMouseId) {
          const evt = pointerInfo.event;
          const isMouseEvent = evt.pointerType === "mouse" || !this._scene.getEngine().hostInformation.isMobile && evt instanceof MouseEvent;
          if (isMouseEvent) {
            if (this._lastPointerRay[this.currentDraggingPointerId]) {
              this._lastPointerRay[pointerId] = this._lastPointerRay[this.currentDraggingPointerId];
              delete this._lastPointerRay[this.currentDraggingPointerId];
            }
            this.currentDraggingPointerId = pointerId;
          }
        }
        if (!this._lastPointerRay[pointerId]) {
          this._lastPointerRay[pointerId] = new Ray(new Vector3(), new Vector3());
        }
        if (pointerInfo.pickInfo && pointerInfo.pickInfo.ray) {
          this._lastPointerRay[pointerId].origin.copyFrom(pointerInfo.pickInfo.ray.origin);
          this._lastPointerRay[pointerId].direction.copyFrom(pointerInfo.pickInfo.ray.direction);
          if (this.currentDraggingPointerId == pointerId && this.dragging) {
            this._moveDrag(pointerInfo.pickInfo.ray);
          }
        }
      }
    });
    this._beforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {
      if (this._moving && this.moveAttached) {
        let needMatrixUpdate = false;
        PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
        this._targetPosition.subtractToRef(this.attachedNode.absolutePosition, this._tmpVector);
        this._tmpVector.scaleInPlace(this.dragDeltaRatio);
        this.attachedNode.getAbsolutePosition().addToRef(this._tmpVector, this._tmpVector);
        if (this.validateDrag(this._tmpVector)) {
          this.attachedNode.setAbsolutePosition(this._tmpVector);
          needMatrixUpdate = true;
        }
        PivotTools._RestorePivotPoint(this.attachedNode);
        if (needMatrixUpdate) {
          this.attachedNode.computeWorldMatrix();
        }
      }
    });
  }
  releaseDrag() {
    if (this.dragging) {
      this.dragging = false;
      this.onDragEndObservable.notifyObservers({ dragPlanePoint: this.lastDragPosition, pointerId: this.currentDraggingPointerId, pointerInfo: this._activePointerInfo });
    }
    this.currentDraggingPointerId = -1;
    this._activeDragButton = -1;
    this._activePointerInfo = null;
    this._moving = false;
    if (this.detachCameraControls && this._attachedToElement && this._scene.activeCamera && !this._scene.activeCamera.leftCamera) {
      if (this._scene.activeCamera.getClassName() === "ArcRotateCamera") {
        const arcRotateCamera = this._scene.activeCamera;
        arcRotateCamera.attachControl(arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true, arcRotateCamera._useCtrlForPanning, arcRotateCamera._panningMouseButton);
      } else {
        this._scene.activeCamera.attachControl(this._scene.activeCamera.inputs ? this._scene.activeCamera.inputs.noPreventDefault : true);
      }
      this._attachedToElement = false;
    }
  }
  startDrag(pointerId = PointerDragBehavior._AnyMouseId, fromRay, startPickedPoint) {
    this._startDrag(pointerId, fromRay, startPickedPoint);
    let lastRay = this._lastPointerRay[pointerId];
    if (pointerId === PointerDragBehavior._AnyMouseId) {
      lastRay = this._lastPointerRay[Object.keys(this._lastPointerRay)[0]];
    }
    if (lastRay) {
      this._moveDrag(lastRay);
    }
  }
  _startDrag(pointerId, fromRay, startPickedPoint) {
    if (!this._scene.activeCamera || this.dragging || !this.attachedNode) {
      return;
    }
    PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
    if (fromRay) {
      this._startDragRay.direction.copyFrom(fromRay.direction);
      this._startDragRay.origin.copyFrom(fromRay.origin);
    } else {
      this._startDragRay.origin.copyFrom(this._scene.activeCamera.position);
      this.attachedNode.getWorldMatrix().getTranslationToRef(this._tmpVector);
      this._tmpVector.subtractToRef(this._scene.activeCamera.position, this._startDragRay.direction);
    }
    this._updateDragPlanePosition(this._startDragRay, startPickedPoint ? startPickedPoint : this._tmpVector);
    const pickedPoint = this._pickWithRayOnDragPlane(this._startDragRay);
    if (pickedPoint) {
      this.dragging = true;
      this.currentDraggingPointerId = pointerId;
      this.lastDragPosition.copyFrom(pickedPoint);
      this.onDragStartObservable.notifyObservers({ dragPlanePoint: pickedPoint, pointerId: this.currentDraggingPointerId, pointerInfo: this._activePointerInfo });
      this._targetPosition.copyFrom(this.attachedNode.getAbsolutePosition());
      if (this.detachCameraControls && this._scene.activeCamera && this._scene.activeCamera.inputs && !this._scene.activeCamera.leftCamera) {
        if (this._scene.activeCamera.inputs.attachedToElement) {
          this._scene.activeCamera.detachControl();
          this._attachedToElement = true;
        } else {
          this._attachedToElement = false;
        }
      }
    } else {
      this.releaseDrag();
    }
    PivotTools._RestorePivotPoint(this.attachedNode);
  }
  _moveDrag(ray) {
    this._moving = true;
    const pickedPoint = this._pickWithRayOnDragPlane(ray);
    if (pickedPoint) {
      PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
      if (this.updateDragPlane) {
        this._updateDragPlanePosition(ray, pickedPoint);
      }
      let dragLength = 0;
      if (this._options.dragAxis) {
        this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._worldDragAxis) : this._worldDragAxis.copyFrom(this._options.dragAxis);
        pickedPoint.subtractToRef(this.lastDragPosition, this._tmpVector);
        dragLength = Vector3.Dot(this._tmpVector, this._worldDragAxis);
        this._worldDragAxis.scaleToRef(dragLength, this._dragDelta);
      } else {
        dragLength = this._dragDelta.length();
        pickedPoint.subtractToRef(this.lastDragPosition, this._dragDelta);
      }
      this._targetPosition.addInPlace(this._dragDelta);
      this.onDragObservable.notifyObservers({
        dragDistance: dragLength,
        delta: this._dragDelta,
        dragPlanePoint: pickedPoint,
        dragPlaneNormal: this._dragPlane.forward,
        pointerId: this.currentDraggingPointerId,
        pointerInfo: this._activePointerInfo
      });
      this.lastDragPosition.copyFrom(pickedPoint);
      PivotTools._RestorePivotPoint(this.attachedNode);
    }
  }
  _pickWithRayOnDragPlane(ray) {
    if (!ray) {
      return null;
    }
    let angle = Math.acos(Vector3.Dot(this._dragPlane.forward, ray.direction));
    if (angle > Math.PI / 2) {
      angle = Math.PI - angle;
    }
    if (this.maxDragAngle > 0 && angle > this.maxDragAngle) {
      if (this._useAlternatePickedPointAboveMaxDragAngle) {
        this._tmpVector.copyFrom(ray.direction);
        this.attachedNode.absolutePosition.subtractToRef(ray.origin, this._alternatePickedPoint);
        this._alternatePickedPoint.normalize();
        this._alternatePickedPoint.scaleInPlace(this._useAlternatePickedPointAboveMaxDragAngleDragSpeed * Vector3.Dot(this._alternatePickedPoint, this._tmpVector));
        this._tmpVector.addInPlace(this._alternatePickedPoint);
        const dot = Vector3.Dot(this._dragPlane.forward, this._tmpVector);
        this._dragPlane.forward.scaleToRef(-dot, this._alternatePickedPoint);
        this._alternatePickedPoint.addInPlace(this._tmpVector);
        this._alternatePickedPoint.addInPlace(this.attachedNode.absolutePosition);
        return this._alternatePickedPoint;
      } else {
        return null;
      }
    }
    const pickResult = PointerDragBehavior._PlaneScene.pickWithRay(ray, (m) => {
      return m == this._dragPlane;
    });
    if (pickResult && pickResult.hit && pickResult.pickedMesh && pickResult.pickedPoint) {
      return pickResult.pickedPoint;
    } else {
      return null;
    }
  }
  _updateDragPlanePosition(ray, dragPlanePosition) {
    this._pointA.copyFrom(dragPlanePosition);
    if (this._options.dragAxis) {
      this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragAxis);
      ray.origin.subtractToRef(this._pointA, this._pointC);
      this._pointC.normalize();
      if (Math.abs(Vector3.Dot(this._localAxis, this._pointC)) > 0.999) {
        if (Math.abs(Vector3.Dot(Vector3.UpReadOnly, this._pointC)) > 0.999) {
          this._lookAt.copyFrom(Vector3.Right());
        } else {
          this._lookAt.copyFrom(Vector3.UpReadOnly);
        }
      } else {
        Vector3.CrossToRef(this._localAxis, this._pointC, this._lookAt);
        Vector3.CrossToRef(this._localAxis, this._lookAt, this._lookAt);
        this._lookAt.normalize();
      }
      this._dragPlane.position.copyFrom(this._pointA);
      this._pointA.addToRef(this._lookAt, this._lookAt);
      this._dragPlane.lookAt(this._lookAt);
    } else if (this._options.dragPlaneNormal) {
      this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragPlaneNormal, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragPlaneNormal);
      this._dragPlane.position.copyFrom(this._pointA);
      this._pointA.addToRef(this._localAxis, this._lookAt);
      this._dragPlane.lookAt(this._lookAt);
    } else {
      this._dragPlane.position.copyFrom(this._pointA);
      this._dragPlane.lookAt(ray.origin);
    }
    this._dragPlane.position.copyFrom(this.attachedNode.getAbsolutePosition());
    this._dragPlane.computeWorldMatrix(true);
  }
  detach() {
    this._lastPointerRay = {};
    if (this.attachedNode) {
      this.attachedNode.isNearGrabbable = false;
    }
    if (this._pointerObserver) {
      this._scene.onPointerObservable.remove(this._pointerObserver);
    }
    if (this._beforeRenderObserver) {
      this._scene.onBeforeRenderObservable.remove(this._beforeRenderObserver);
    }
    if (this._dragPlane) {
      this._dragPlane.dispose();
    }
    this.releaseDrag();
  }
};
PointerDragBehavior._AnyMouseId = -2;

// node_modules/@babylonjs/core/Behaviors/Meshes/baseSixDofDragBehavior.js
var BaseSixDofDragBehavior = class {
  constructor() {
    this._attachedToElement = false;
    this._virtualMeshesInfo = {};
    this._tmpVector = new Vector3();
    this._tmpQuaternion = new Quaternion();
    this._dragType = {
      NONE: 0,
      DRAG: 1,
      DRAG_WITH_CONTROLLER: 2,
      NEAR_DRAG: 3
    };
    this._moving = false;
    this._dragging = this._dragType.NONE;
    this.draggableMeshes = null;
    this.zDragFactor = 3;
    this.currentDraggingPointerIds = [];
    this.detachCameraControls = true;
    this.onDragStartObservable = new Observable();
    this.onDragObservable = new Observable();
    this.onDragEndObservable = new Observable();
    this.allowMultiPointer = true;
  }
  get currentDraggingPointerId() {
    if (this.currentDraggingPointerIds[0] !== void 0) {
      return this.currentDraggingPointerIds[0];
    }
    return -1;
  }
  set currentDraggingPointerId(value) {
    this.currentDraggingPointerIds[0] = value;
  }
  get currentDraggingPointerID() {
    return this.currentDraggingPointerId;
  }
  set currentDraggingPointerID(currentDraggingPointerID) {
    this.currentDraggingPointerId = currentDraggingPointerID;
  }
  get name() {
    return "BaseSixDofDrag";
  }
  get isMoving() {
    return this._moving;
  }
  init() {
  }
  get _pointerCamera() {
    if (this._scene.cameraToUseForPointers) {
      return this._scene.cameraToUseForPointers;
    } else {
      return this._scene.activeCamera;
    }
  }
  _createVirtualMeshInfo() {
    const dragMesh = new AbstractMesh("", BaseSixDofDragBehavior._virtualScene);
    dragMesh.rotationQuaternion = new Quaternion();
    const originMesh = new AbstractMesh("", BaseSixDofDragBehavior._virtualScene);
    originMesh.rotationQuaternion = new Quaternion();
    const pivotMesh = new AbstractMesh("", BaseSixDofDragBehavior._virtualScene);
    pivotMesh.rotationQuaternion = new Quaternion();
    return {
      dragging: false,
      moving: false,
      dragMesh,
      originMesh,
      pivotMesh,
      startingPivotPosition: new Vector3(),
      startingPivotOrientation: new Quaternion(),
      startingPosition: new Vector3(),
      startingOrientation: new Quaternion(),
      lastOriginPosition: new Vector3(),
      lastDragPosition: new Vector3()
    };
  }
  _resetVirtualMeshesPosition() {
    for (let i = 0; i < this.currentDraggingPointerIds.length; i++) {
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion.copyFrom(this._ownerNode.rotationQuaternion);
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position);
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotOrientation.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion);
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.position);
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingOrientation.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.rotationQuaternion);
    }
  }
  _pointerUpdate2D(ray, pointerId, zDragFactor) {
    if (this._pointerCamera && this._pointerCamera.cameraRigMode == Camera.RIG_MODE_NONE && !this._pointerCamera._isLeftCamera && !this._pointerCamera._isRightCamera) {
      ray.origin.copyFrom(this._pointerCamera.globalPosition);
      zDragFactor = 0;
    }
    const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];
    const originDragDifference = TmpVectors.Vector3[0];
    ray.origin.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDifference);
    virtualMeshesInfo.lastOriginPosition.copyFrom(ray.origin);
    const localOriginDragDifference = -Vector3.Dot(originDragDifference, ray.direction);
    virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.dragMesh);
    virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.pivotMesh);
    this._applyZOffset(virtualMeshesInfo.dragMesh, localOriginDragDifference, zDragFactor);
    this._applyZOffset(virtualMeshesInfo.pivotMesh, localOriginDragDifference, zDragFactor);
    virtualMeshesInfo.originMesh.position.copyFrom(ray.origin);
    const lookAt = TmpVectors.Vector3[0];
    ray.origin.addToRef(ray.direction, lookAt);
    virtualMeshesInfo.originMesh.lookAt(lookAt);
    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);
    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);
  }
  _pointerUpdateXR(controllerAimTransform, controllerGripTransform, pointerId, zDragFactor) {
    const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];
    virtualMeshesInfo.originMesh.position.copyFrom(controllerAimTransform.position);
    if (this._dragging === this._dragType.NEAR_DRAG && controllerGripTransform) {
      virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(controllerGripTransform.rotationQuaternion);
    } else {
      virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(controllerAimTransform.rotationQuaternion);
    }
    virtualMeshesInfo.pivotMesh.computeWorldMatrix(true);
    virtualMeshesInfo.dragMesh.computeWorldMatrix(true);
    if (zDragFactor !== 0) {
      const cameraForwardVec = TmpVectors.Vector3[0];
      const originDragDirection = TmpVectors.Vector3[1];
      cameraForwardVec.copyFrom(this._pointerCamera.getForwardRay().direction);
      virtualMeshesInfo.originMesh.position.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDirection);
      virtualMeshesInfo.lastOriginPosition.copyFrom(virtualMeshesInfo.originMesh.position);
      const controllerDragDistance = originDragDirection.length();
      originDragDirection.normalize();
      const cameraToDrag = TmpVectors.Vector3[2];
      const controllerToDrag = TmpVectors.Vector3[3];
      virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(this._pointerCamera.globalPosition, cameraToDrag);
      virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(virtualMeshesInfo.originMesh.position, controllerToDrag);
      const controllerToDragDistance = controllerToDrag.length();
      cameraToDrag.normalize();
      controllerToDrag.normalize();
      const controllerDragScaling = Math.abs(Vector3.Dot(originDragDirection, controllerToDrag)) * Vector3.Dot(originDragDirection, cameraForwardVec);
      let zOffsetScaling = controllerDragScaling * zDragFactor * controllerDragDistance * controllerToDragDistance;
      const minDistanceFromControllerToDragMesh = 0.01;
      if (zOffsetScaling < 0 && minDistanceFromControllerToDragMesh - controllerToDragDistance > zOffsetScaling) {
        zOffsetScaling = Math.min(minDistanceFromControllerToDragMesh - controllerToDragDistance, 0);
      }
      controllerToDrag.scaleInPlace(zOffsetScaling);
      controllerToDrag.addToRef(virtualMeshesInfo.pivotMesh.absolutePosition, this._tmpVector);
      virtualMeshesInfo.pivotMesh.setAbsolutePosition(this._tmpVector);
      controllerToDrag.addToRef(virtualMeshesInfo.dragMesh.absolutePosition, this._tmpVector);
      virtualMeshesInfo.dragMesh.setAbsolutePosition(this._tmpVector);
    }
  }
  attach(ownerNode) {
    this._ownerNode = ownerNode;
    this._scene = this._ownerNode.getScene();
    if (!BaseSixDofDragBehavior._virtualScene) {
      BaseSixDofDragBehavior._virtualScene = new Scene(this._scene.getEngine(), { virtual: true });
      BaseSixDofDragBehavior._virtualScene.detachControl();
    }
    const pickPredicate = (m) => {
      return this._ownerNode === m || m.isDescendantOf(this._ownerNode) && (!this.draggableMeshes || this.draggableMeshes.indexOf(m) !== -1);
    };
    this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {
      const pointerId = pointerInfo.event.pointerId;
      if (!this._virtualMeshesInfo[pointerId]) {
        this._virtualMeshesInfo[pointerId] = this._createVirtualMeshInfo();
      }
      const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];
      const isXRNearPointer = pointerInfo.event.pointerType === "xr-near";
      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
        if (!virtualMeshesInfo.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedPoint && pointerInfo.pickInfo.ray && (!isXRNearPointer || pointerInfo.pickInfo.aimTransform) && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {
          if (!this.allowMultiPointer && this.currentDraggingPointerIds.length > 0) {
            return;
          }
          if (this._pointerCamera && this._pointerCamera.cameraRigMode === Camera.RIG_MODE_NONE && !this._pointerCamera._isLeftCamera && !this._pointerCamera._isRightCamera) {
            pointerInfo.pickInfo.ray.origin.copyFrom(this._pointerCamera.globalPosition);
          }
          this._ownerNode.computeWorldMatrix(true);
          const virtualMeshesInfo2 = this._virtualMeshesInfo[pointerId];
          if (isXRNearPointer) {
            this._dragging = pointerInfo.pickInfo.originMesh ? this._dragType.NEAR_DRAG : this._dragType.DRAG_WITH_CONTROLLER;
            virtualMeshesInfo2.originMesh.position.copyFrom(pointerInfo.pickInfo.aimTransform.position);
            if (this._dragging === this._dragType.NEAR_DRAG && pointerInfo.pickInfo.gripTransform) {
              virtualMeshesInfo2.originMesh.rotationQuaternion.copyFrom(pointerInfo.pickInfo.gripTransform.rotationQuaternion);
            } else {
              virtualMeshesInfo2.originMesh.rotationQuaternion.copyFrom(pointerInfo.pickInfo.aimTransform.rotationQuaternion);
            }
          } else {
            this._dragging = this._dragType.DRAG;
            virtualMeshesInfo2.originMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);
          }
          virtualMeshesInfo2.lastOriginPosition.copyFrom(virtualMeshesInfo2.originMesh.position);
          virtualMeshesInfo2.dragMesh.position.copyFrom(pointerInfo.pickInfo.pickedPoint);
          virtualMeshesInfo2.lastDragPosition.copyFrom(pointerInfo.pickInfo.pickedPoint);
          virtualMeshesInfo2.pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());
          virtualMeshesInfo2.pivotMesh.rotationQuaternion.copyFrom(this._ownerNode.absoluteRotationQuaternion);
          virtualMeshesInfo2.startingPosition.copyFrom(virtualMeshesInfo2.dragMesh.position);
          virtualMeshesInfo2.startingPivotPosition.copyFrom(virtualMeshesInfo2.pivotMesh.position);
          virtualMeshesInfo2.startingOrientation.copyFrom(virtualMeshesInfo2.dragMesh.rotationQuaternion);
          virtualMeshesInfo2.startingPivotOrientation.copyFrom(virtualMeshesInfo2.pivotMesh.rotationQuaternion);
          if (isXRNearPointer) {
            virtualMeshesInfo2.originMesh.addChild(virtualMeshesInfo2.dragMesh);
            virtualMeshesInfo2.originMesh.addChild(virtualMeshesInfo2.pivotMesh);
          } else {
            virtualMeshesInfo2.originMesh.lookAt(virtualMeshesInfo2.dragMesh.position);
          }
          virtualMeshesInfo2.dragging = true;
          if (this.currentDraggingPointerIds.indexOf(pointerId) === -1) {
            this.currentDraggingPointerIds.push(pointerId);
          }
          if (this.detachCameraControls && this._pointerCamera && !this._pointerCamera.leftCamera) {
            if (this._pointerCamera.inputs && this._pointerCamera.inputs.attachedToElement) {
              this._pointerCamera.detachControl();
              this._attachedToElement = true;
            } else {
              this._attachedToElement = false;
            }
          }
          this._targetDragStart(virtualMeshesInfo2.pivotMesh.position, virtualMeshesInfo2.pivotMesh.rotationQuaternion, pointerId);
          this.onDragStartObservable.notifyObservers({ position: virtualMeshesInfo2.pivotMesh.position });
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERUP || pointerInfo.type == PointerEventTypes.POINTERDOUBLETAP) {
        const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);
        virtualMeshesInfo.dragging = false;
        if (registeredPointerIndex !== -1) {
          this.currentDraggingPointerIds.splice(registeredPointerIndex, 1);
          if (this.currentDraggingPointerIds.length === 0) {
            this._moving = false;
            this._dragging = this._dragType.NONE;
            if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {
              this._reattachCameraControls();
              this._attachedToElement = false;
            }
          }
          virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);
          virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);
          this._targetDragEnd(pointerId);
          this.onDragEndObservable.notifyObservers({});
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {
        const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);
        if (registeredPointerIndex !== -1 && virtualMeshesInfo.dragging && pointerInfo.pickInfo && (pointerInfo.pickInfo.ray || pointerInfo.pickInfo.aimTransform)) {
          let zDragFactor = this.zDragFactor;
          if (this.currentDraggingPointerIds.length > 1 || pointerInfo.pickInfo.originMesh) {
            zDragFactor = 0;
          }
          this._ownerNode.computeWorldMatrix(true);
          if (!isXRNearPointer) {
            this._pointerUpdate2D(pointerInfo.pickInfo.ray, pointerId, zDragFactor);
          } else {
            this._pointerUpdateXR(pointerInfo.pickInfo.aimTransform, pointerInfo.pickInfo.gripTransform, pointerId, zDragFactor);
          }
          this._tmpQuaternion.copyFrom(virtualMeshesInfo.startingPivotOrientation);
          this._tmpQuaternion.x = -this._tmpQuaternion.x;
          this._tmpQuaternion.y = -this._tmpQuaternion.y;
          this._tmpQuaternion.z = -this._tmpQuaternion.z;
          virtualMeshesInfo.pivotMesh.absoluteRotationQuaternion.multiplyToRef(this._tmpQuaternion, this._tmpQuaternion);
          virtualMeshesInfo.pivotMesh.absolutePosition.subtractToRef(virtualMeshesInfo.startingPivotPosition, this._tmpVector);
          this.onDragObservable.notifyObservers({ delta: this._tmpVector, position: virtualMeshesInfo.pivotMesh.position, pickInfo: pointerInfo.pickInfo });
          this._targetDrag(this._tmpVector, this._tmpQuaternion, pointerId);
          virtualMeshesInfo.lastDragPosition.copyFrom(virtualMeshesInfo.dragMesh.absolutePosition);
          this._moving = true;
        }
      }
    });
  }
  _applyZOffset(node, localOriginDragDifference, zDragFactor) {
    node.position.z -= node.position.z < 1 ? localOriginDragDifference * zDragFactor : localOriginDragDifference * zDragFactor * node.position.z;
    if (node.position.z < 0) {
      node.position.z = 0;
    }
  }
  _targetDragStart(worldPosition, worldRotation, pointerId) {
  }
  _targetDrag(worldDeltaPosition, worldDeltaRotation, pointerId) {
  }
  _targetDragEnd(pointerId) {
  }
  _reattachCameraControls() {
    if (this._pointerCamera) {
      if (this._pointerCamera.getClassName() === "ArcRotateCamera") {
        const arcRotateCamera = this._pointerCamera;
        arcRotateCamera.attachControl(arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true, arcRotateCamera._useCtrlForPanning, arcRotateCamera._panningMouseButton);
      } else {
        this._pointerCamera.attachControl(this._pointerCamera.inputs ? this._pointerCamera.inputs.noPreventDefault : true);
      }
    }
  }
  detach() {
    if (this._scene) {
      if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {
        this._reattachCameraControls();
        this._attachedToElement = false;
      }
      this._scene.onPointerObservable.remove(this._pointerObserver);
    }
    for (const pointerId in this._virtualMeshesInfo) {
      this._virtualMeshesInfo[pointerId].originMesh.dispose();
      this._virtualMeshesInfo[pointerId].dragMesh.dispose();
    }
    this.onDragEndObservable.clear();
    this.onDragObservable.clear();
    this.onDragStartObservable.clear();
  }
};

// node_modules/@babylonjs/core/Behaviors/Meshes/sixDofDragBehavior.js
var SixDofDragBehavior = class extends BaseSixDofDragBehavior {
  constructor() {
    super(...arguments);
    this._sceneRenderObserver = null;
    this._targetPosition = new Vector3(0, 0, 0);
    this._targetOrientation = new Quaternion();
    this._targetScaling = new Vector3(1, 1, 1);
    this._startingPosition = new Vector3(0, 0, 0);
    this._startingOrientation = new Quaternion();
    this._startingScaling = new Vector3(1, 1, 1);
    this.onPositionChangedObservable = new Observable();
    this.dragDeltaRatio = 0.2;
    this.rotateDraggedObject = true;
    this.rotateAroundYOnly = false;
    this.rotateWithMotionController = true;
    this.disableMovement = false;
    this.faceCameraOnDragStart = false;
  }
  get name() {
    return "SixDofDrag";
  }
  attach(ownerNode) {
    super.attach(ownerNode);
    ownerNode.isNearGrabbable = true;
    this._virtualTransformNode = new TransformNode("virtual_sixDof", BaseSixDofDragBehavior._virtualScene);
    this._virtualTransformNode.rotationQuaternion = Quaternion.Identity();
    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {
      if (this.currentDraggingPointerIds.length === 1 && this._moving && !this.disableMovement) {
        const oldParent = ownerNode.parent;
        ownerNode.setParent(null);
        ownerNode.position.addInPlace(this._targetPosition.subtract(ownerNode.position).scale(this.dragDeltaRatio));
        this.onPositionChangedObservable.notifyObservers({ position: ownerNode.absolutePosition });
        if (!oldParent || oldParent.scaling && !oldParent.scaling.isNonUniformWithinEpsilon(1e-3)) {
          Quaternion.SlerpToRef(ownerNode.rotationQuaternion, this._targetOrientation, this.dragDeltaRatio, ownerNode.rotationQuaternion);
        }
        ownerNode.setParent(oldParent);
      }
    });
  }
  _getPositionOffsetAround(transformationLocalOrigin, scaling, rotation) {
    const translationMatrix = TmpVectors.Matrix[0];
    const translationMatrixInv = TmpVectors.Matrix[1];
    const rotationMatrix = TmpVectors.Matrix[2];
    const scaleMatrix = TmpVectors.Matrix[3];
    const finalMatrix = TmpVectors.Matrix[4];
    Matrix.TranslationToRef(transformationLocalOrigin.x, transformationLocalOrigin.y, transformationLocalOrigin.z, translationMatrix);
    Matrix.TranslationToRef(-transformationLocalOrigin.x, -transformationLocalOrigin.y, -transformationLocalOrigin.z, translationMatrixInv);
    Matrix.FromQuaternionToRef(rotation, rotationMatrix);
    Matrix.ScalingToRef(scaling, scaling, scaling, scaleMatrix);
    translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix);
    finalMatrix.multiplyToRef(scaleMatrix, finalMatrix);
    finalMatrix.multiplyToRef(translationMatrix, finalMatrix);
    return finalMatrix.getTranslation();
  }
  _onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation) {
    const pointerDelta = TmpVectors.Vector3[0];
    pointerDelta.setAll(0);
    if (this._dragging === this._dragType.DRAG) {
      if (this.rotateDraggedObject) {
        if (this.rotateAroundYOnly) {
          Quaternion.RotationYawPitchRollToRef(worldDeltaRotation.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);
        } else {
          TmpVectors.Quaternion[0].copyFrom(worldDeltaRotation);
        }
        TmpVectors.Quaternion[0].multiplyToRef(this._startingOrientation, this._targetOrientation);
      }
    } else if (this._dragging === this._dragType.NEAR_DRAG || this._dragging === this._dragType.DRAG_WITH_CONTROLLER && this.rotateWithMotionController) {
      worldDeltaRotation.multiplyToRef(this._startingOrientation, this._targetOrientation);
    }
    this._targetPosition.copyFrom(this._startingPosition).addInPlace(worldDeltaPosition);
  }
  _twoPointersPositionUpdated() {
    const startingPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].startingPosition;
    const startingPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].startingPosition;
    const startingCenter = TmpVectors.Vector3[0];
    startingPosition0.addToRef(startingPosition1, startingCenter);
    startingCenter.scaleInPlace(0.5);
    const startingVector = TmpVectors.Vector3[1];
    startingPosition1.subtractToRef(startingPosition0, startingVector);
    const currentPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].dragMesh.absolutePosition;
    const currentPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].dragMesh.absolutePosition;
    const currentCenter = TmpVectors.Vector3[2];
    currentPosition0.addToRef(currentPosition1, currentCenter);
    currentCenter.scaleInPlace(0.5);
    const currentVector = TmpVectors.Vector3[3];
    currentPosition1.subtractToRef(currentPosition0, currentVector);
    const scaling = currentVector.length() / startingVector.length();
    const translation = currentCenter.subtract(startingCenter);
    const rotationQuaternion = Quaternion.FromEulerAngles(0, Vector3.GetAngleBetweenVectorsOnPlane(startingVector.normalize(), currentVector.normalize(), Vector3.UpReadOnly), 0);
    const oldParent = this._ownerNode.parent;
    this._ownerNode.setParent(null);
    const positionOffset = this._getPositionOffsetAround(startingCenter.subtract(this._virtualTransformNode.getAbsolutePivotPoint()), scaling, rotationQuaternion);
    this._virtualTransformNode.rotationQuaternion.multiplyToRef(rotationQuaternion, this._ownerNode.rotationQuaternion);
    this._virtualTransformNode.scaling.scaleToRef(scaling, this._ownerNode.scaling);
    this._virtualTransformNode.position.addToRef(translation.addInPlace(positionOffset), this._ownerNode.position);
    this.onPositionChangedObservable.notifyObservers({ position: this._ownerNode.position });
    this._ownerNode.setParent(oldParent);
  }
  _targetDragStart() {
    const pointerCount = this.currentDraggingPointerIds.length;
    const oldParent = this._ownerNode.parent;
    if (!this._ownerNode.rotationQuaternion) {
      this._ownerNode.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ownerNode.rotation.y, this._ownerNode.rotation.x, this._ownerNode.rotation.z);
    }
    const worldPivot = this._ownerNode.getAbsolutePivotPoint();
    this._ownerNode.setParent(null);
    if (pointerCount === 1) {
      this._targetPosition.copyFrom(this._ownerNode.position);
      this._targetOrientation.copyFrom(this._ownerNode.rotationQuaternion);
      this._targetScaling.copyFrom(this._ownerNode.scaling);
      if (this.faceCameraOnDragStart && this._scene.activeCamera) {
        const toCamera = TmpVectors.Vector3[0];
        this._scene.activeCamera.position.subtractToRef(worldPivot, toCamera);
        toCamera.normalize();
        const quat = TmpVectors.Quaternion[0];
        if (this._scene.useRightHandedSystem) {
          Quaternion.FromLookDirectionRHToRef(toCamera, new Vector3(0, 1, 0), quat);
        } else {
          Quaternion.FromLookDirectionLHToRef(toCamera, new Vector3(0, 1, 0), quat);
        }
        quat.normalize();
        Quaternion.RotationYawPitchRollToRef(quat.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);
        this._targetOrientation.copyFrom(TmpVectors.Quaternion[0]);
      }
      this._startingPosition.copyFrom(this._targetPosition);
      this._startingOrientation.copyFrom(this._targetOrientation);
      this._startingScaling.copyFrom(this._targetScaling);
    } else if (pointerCount === 2) {
      this._virtualTransformNode.setPivotPoint(new Vector3(0, 0, 0), Space.LOCAL);
      this._virtualTransformNode.position.copyFrom(this._ownerNode.position);
      this._virtualTransformNode.scaling.copyFrom(this._ownerNode.scaling);
      this._virtualTransformNode.rotationQuaternion.copyFrom(this._ownerNode.rotationQuaternion);
      this._virtualTransformNode.setPivotPoint(worldPivot, Space.WORLD);
      this._resetVirtualMeshesPosition();
    }
    this._ownerNode.setParent(oldParent);
  }
  _targetDrag(worldDeltaPosition, worldDeltaRotation) {
    if (this.currentDraggingPointerIds.length === 1) {
      this._onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation);
    } else if (this.currentDraggingPointerIds.length === 2) {
      this._twoPointersPositionUpdated();
    }
  }
  _targetDragEnd() {
    if (this.currentDraggingPointerIds.length === 1) {
      this._resetVirtualMeshesPosition();
      const previousFaceCameraFlag = this.faceCameraOnDragStart;
      this.faceCameraOnDragStart = false;
      this._targetDragStart();
      this.faceCameraOnDragStart = previousFaceCameraFlag;
    }
  }
  detach() {
    super.detach();
    if (this._ownerNode) {
      this._ownerNode.isNearGrabbable = false;
      this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);
    }
    if (this._virtualTransformNode) {
      this._virtualTransformNode.dispose();
    }
  }
};

// node_modules/@babylonjs/core/Behaviors/Meshes/surfaceMagnetismBehavior.js
var SurfaceMagnetismBehavior = class {
  constructor() {
    this._attachPointLocalOffset = new Vector3();
    this._workingPosition = new Vector3();
    this._workingQuaternion = new Quaternion();
    this._lastTick = -1;
    this._hit = false;
    this.hitNormalOffset = 0.05;
    this.meshes = [];
    this.interpolatePose = true;
    this.lerpTime = 250;
    this.keepOrientationVertical = true;
    this.enabled = true;
    this.maxStickingDistance = 0.8;
  }
  get name() {
    return "SurfaceMagnetism";
  }
  init() {
  }
  attach(target, scene) {
    this._attachedMesh = target;
    this._scene = scene || target.getScene();
    if (!this._attachedMesh.rotationQuaternion) {
      this._attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._attachedMesh.rotation.y, this._attachedMesh.rotation.x, this._attachedMesh.rotation.z);
    }
    this.updateAttachPoint();
    this._workingPosition.copyFrom(this._attachedMesh.position);
    this._workingQuaternion.copyFrom(this._attachedMesh.rotationQuaternion);
    this._addObservables();
  }
  detach() {
    this._attachedMesh = null;
    this._removeObservables();
  }
  _getTargetPose(pickingInfo) {
    if (!this._attachedMesh) {
      return null;
    }
    if (pickingInfo && pickingInfo.hit) {
      const pickedNormal = pickingInfo.getNormal(true, true);
      const pickedPoint = pickingInfo.pickedPoint;
      if (!pickedNormal || !pickedPoint) {
        return null;
      }
      pickedNormal.normalize();
      const worldTarget = TmpVectors.Vector3[0];
      worldTarget.copyFrom(pickedNormal);
      worldTarget.scaleInPlace(this.hitNormalOffset);
      worldTarget.addInPlace(pickedPoint);
      if (this._attachedMesh.parent) {
        TmpVectors.Matrix[0].copyFrom(this._attachedMesh.parent.getWorldMatrix()).invert();
        Vector3.TransformNormalToRef(worldTarget, TmpVectors.Matrix[0], worldTarget);
      }
      return {
        position: worldTarget,
        quaternion: Quaternion.RotationYawPitchRoll(-Math.atan2(pickedNormal.x, -pickedNormal.z), this.keepOrientationVertical ? 0 : Math.atan2(pickedNormal.y, Math.sqrt(pickedNormal.z * pickedNormal.z + pickedNormal.x * pickedNormal.x)), 0)
      };
    }
    return null;
  }
  updateAttachPoint() {
    this._getAttachPointOffsetToRef(this._attachPointLocalOffset);
  }
  findAndUpdateTarget(pickInfo) {
    this._hit = false;
    if (!pickInfo.ray) {
      return false;
    }
    const subPicking = pickInfo.ray.intersectsMeshes(this.meshes)[0];
    if (this._attachedMesh && subPicking && subPicking.hit && subPicking.pickedMesh) {
      const pose = this._getTargetPose(subPicking);
      if (pose && Vector3.Distance(this._attachedMesh.position, pose.position) < this.maxStickingDistance) {
        this._workingPosition.copyFrom(pose.position);
        this._workingQuaternion.copyFrom(pose.quaternion);
        this._hit = true;
      }
    }
    return this._hit;
  }
  _getAttachPointOffsetToRef(ref) {
    if (!this._attachedMesh) {
      ref.setAll(0);
      return;
    }
    const storedQuat = TmpVectors.Quaternion[0];
    storedQuat.copyFrom(this._attachedMesh.rotationQuaternion);
    this._attachedMesh.rotationQuaternion.copyFromFloats(0, 0, 0, 1);
    this._attachedMesh.computeWorldMatrix();
    const boundingMinMax = this._attachedMesh.getHierarchyBoundingVectors();
    const center = TmpVectors.Vector3[0];
    boundingMinMax.max.addToRef(boundingMinMax.min, center);
    center.scaleInPlace(0.5);
    center.z = boundingMinMax.max.z;
    const invWorld = TmpVectors.Matrix[0];
    this._attachedMesh.getWorldMatrix().invertToRef(invWorld);
    Vector3.TransformCoordinatesToRef(center, invWorld, ref);
    this._attachedMesh.rotationQuaternion.copyFrom(storedQuat);
  }
  _updateTransformToGoal(elapsed) {
    if (!this._attachedMesh || !this._hit) {
      return;
    }
    const oldParent = this._attachedMesh.parent;
    this._attachedMesh.setParent(null);
    const worldOffset = TmpVectors.Vector3[0];
    Vector3.TransformNormalToRef(this._attachPointLocalOffset, this._attachedMesh.getWorldMatrix(), worldOffset);
    if (!this.interpolatePose) {
      this._attachedMesh.position.copyFrom(this._workingPosition).subtractInPlace(worldOffset);
      this._attachedMesh.rotationQuaternion.copyFrom(this._workingQuaternion);
      return;
    }
    const interpolatedPosition = new Vector3();
    Vector3.SmoothToRef(this._attachedMesh.position, this._workingPosition, elapsed, this.lerpTime, interpolatedPosition);
    this._attachedMesh.position.copyFrom(interpolatedPosition);
    const currentRotation = new Quaternion();
    currentRotation.copyFrom(this._attachedMesh.rotationQuaternion);
    Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this._attachedMesh.rotationQuaternion);
    this._attachedMesh.setParent(oldParent);
  }
  _addObservables() {
    this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {
      if (this.enabled && pointerInfo.type == PointerEventTypes.POINTERMOVE && pointerInfo.pickInfo) {
        this.findAndUpdateTarget(pointerInfo.pickInfo);
      }
    });
    this._lastTick = Date.now();
    this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {
      const tick = Date.now();
      this._updateTransformToGoal(tick - this._lastTick);
      this._lastTick = tick;
    });
  }
  _removeObservables() {
    this._scene.onPointerObservable.remove(this._pointerObserver);
    this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);
    this._pointerObserver = null;
    this._onBeforeRender = null;
  }
};

// node_modules/@babylonjs/core/Behaviors/Meshes/followBehavior.js
var FollowBehavior = class {
  constructor() {
    this._tmpQuaternion = new Quaternion();
    this._tmpVectors = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];
    this._tmpMatrix = new Matrix();
    this._tmpInvertView = new Matrix();
    this._tmpForward = new Vector3();
    this._tmpNodeForward = new Vector3();
    this._tmpPosition = new Vector3();
    this._workingPosition = new Vector3();
    this._workingQuaternion = new Quaternion();
    this._lastTick = -1;
    this._recenterNextUpdate = true;
    this.interpolatePose = true;
    this.lerpTime = 500;
    this.ignoreCameraPitchAndRoll = false;
    this.pitchOffset = 15;
    this.maxViewVerticalDegrees = 30;
    this.maxViewHorizontalDegrees = 30;
    this.orientToCameraDeadzoneDegrees = 60;
    this.ignoreDistanceClamp = false;
    this.ignoreAngleClamp = false;
    this.verticalMaxDistance = 0;
    this.defaultDistance = 0.8;
    this.maximumDistance = 2;
    this.minimumDistance = 0.3;
    this.useFixedVerticalOffset = false;
    this.fixedVerticalOffset = 0;
    this._enabled = true;
  }
  get followedCamera() {
    return this._followedCamera || this._scene.activeCamera;
  }
  set followedCamera(camera) {
    this._followedCamera = camera;
  }
  get name() {
    return "Follow";
  }
  init() {
  }
  attach(ownerNode, followedCamera) {
    this._scene = ownerNode.getScene();
    this.attachedNode = ownerNode;
    if (followedCamera) {
      this.followedCamera = followedCamera;
    }
    this._addObservables();
  }
  detach() {
    this.attachedNode = null;
    this._removeObservables();
  }
  recenter() {
    this._recenterNextUpdate = true;
  }
  _angleBetweenVectorAndPlane(vector, normal) {
    this._tmpVectors[0].copyFrom(vector);
    vector = this._tmpVectors[0];
    this._tmpVectors[1].copyFrom(normal);
    normal = this._tmpVectors[1];
    vector.normalize();
    normal.normalize();
    return Math.PI / 2 - Math.acos(Vector3.Dot(vector, normal));
  }
  _length2D(vector) {
    return Math.sqrt(vector.x * vector.x + vector.z * vector.z);
  }
  _distanceClamp(currentToTarget, moveToDefault = false) {
    let minDistance = this.minimumDistance;
    let maxDistance = this.maximumDistance;
    const defaultDistance = this.defaultDistance;
    const direction = this._tmpVectors[0];
    direction.copyFrom(currentToTarget);
    let currentDistance = direction.length();
    direction.normalizeFromLength(currentDistance);
    if (this.ignoreCameraPitchAndRoll) {
      minDistance = this._length2D(direction) * minDistance;
      maxDistance = this._length2D(direction) * maxDistance;
      const currentDistance2D = this._length2D(currentToTarget);
      direction.scaleInPlace(currentDistance / currentDistance2D);
      currentDistance = currentDistance2D;
    }
    let clampedDistance = currentDistance;
    if (moveToDefault) {
      clampedDistance = defaultDistance;
    } else {
      clampedDistance = Scalar.Clamp(currentDistance, minDistance, maxDistance);
    }
    currentToTarget.copyFrom(direction).scaleInPlace(clampedDistance);
    return currentDistance !== clampedDistance;
  }
  _applyVerticalClamp(currentToTarget) {
    if (this.verticalMaxDistance !== 0) {
      currentToTarget.y = Scalar.Clamp(currentToTarget.y, -this.verticalMaxDistance, this.verticalMaxDistance);
    }
  }
  _toOrientationQuatToRef(vector, quaternion) {
    Quaternion.RotationYawPitchRollToRef(Math.atan2(vector.x, vector.z), Math.atan2(vector.y, Math.sqrt(vector.z * vector.z + vector.x * vector.x)), 0, quaternion);
  }
  _applyPitchOffset(invertView) {
    const forward = this._tmpVectors[0];
    const right = this._tmpVectors[1];
    forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
    right.copyFromFloats(1, 0, 0);
    Vector3.TransformNormalToRef(forward, invertView, forward);
    forward.y = 0;
    forward.normalize();
    Vector3.TransformNormalToRef(right, invertView, right);
    Quaternion.RotationAxisToRef(right, this.pitchOffset * Math.PI / 180, this._tmpQuaternion);
    forward.rotateByQuaternionToRef(this._tmpQuaternion, forward);
    this._toOrientationQuatToRef(forward, this._tmpQuaternion);
    this._tmpQuaternion.toRotationMatrix(this._tmpMatrix);
    invertView.copyFrom(this._tmpMatrix);
  }
  _angularClamp(invertView, currentToTarget) {
    const forward = this._tmpVectors[5];
    forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
    const right = this._tmpVectors[6];
    right.copyFromFloats(1, 0, 0);
    Vector3.TransformNormalToRef(forward, invertView, forward);
    Vector3.TransformNormalToRef(right, invertView, right);
    const up = Vector3.UpReadOnly;
    const dist = currentToTarget.length();
    if (dist < Epsilon) {
      return false;
    }
    let angularClamped = false;
    const rotationQuat = this._tmpQuaternion;
    if (this.ignoreCameraPitchAndRoll) {
      const angle2 = Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);
      Quaternion.RotationAxisToRef(right, angle2, rotationQuat);
      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
    } else {
      const angle2 = -Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);
      const minMaxAngle2 = this.maxViewVerticalDegrees * Math.PI / 180 * 0.5;
      if (angle2 < -minMaxAngle2) {
        Quaternion.RotationAxisToRef(right, -angle2 - minMaxAngle2, rotationQuat);
        currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
        angularClamped = true;
      } else if (angle2 > minMaxAngle2) {
        Quaternion.RotationAxisToRef(right, -angle2 + minMaxAngle2, rotationQuat);
        currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
        angularClamped = true;
      }
    }
    const angle = this._angleBetweenVectorAndPlane(currentToTarget, right) * (this._scene.useRightHandedSystem ? -1 : 1);
    const minMaxAngle = this.maxViewHorizontalDegrees * Math.PI / 180 * 0.5;
    if (angle < -minMaxAngle) {
      Quaternion.RotationAxisToRef(up, -angle - minMaxAngle, rotationQuat);
      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
      angularClamped = true;
    } else if (angle > minMaxAngle) {
      Quaternion.RotationAxisToRef(up, -angle + minMaxAngle, rotationQuat);
      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
      angularClamped = true;
    }
    return angularClamped;
  }
  _orientationClamp(currentToTarget, rotationQuaternion) {
    var _a;
    const toFollowed = this._tmpVectors[0];
    toFollowed.copyFrom(currentToTarget).scaleInPlace(-1).normalize();
    const up = this._tmpVectors[1];
    const right = this._tmpVectors[2];
    up.copyFromFloats(0, 1, 0);
    Vector3.CrossToRef(toFollowed, up, right);
    const length = right.length();
    if (length < Epsilon) {
      return;
    }
    right.normalizeFromLength(length);
    Vector3.CrossToRef(right, toFollowed, up);
    if ((_a = this.attachedNode) === null || _a === void 0 ? void 0 : _a.getScene().useRightHandedSystem) {
      Quaternion.FromLookDirectionRHToRef(toFollowed, up, rotationQuaternion);
    } else {
      Quaternion.FromLookDirectionLHToRef(toFollowed, up, rotationQuaternion);
    }
  }
  _passedOrientationDeadzone(currentToTarget, forward) {
    const leashToFollow = this._tmpVectors[5];
    leashToFollow.copyFrom(currentToTarget);
    leashToFollow.normalize();
    const angle = Math.abs(Vector3.GetAngleBetweenVectorsOnPlane(forward, leashToFollow, Vector3.UpReadOnly));
    return angle * 180 / Math.PI > this.orientToCameraDeadzoneDegrees;
  }
  _updateLeashing(camera) {
    if (this.attachedNode && this._enabled) {
      const oldParent = this.attachedNode.parent;
      this.attachedNode.setParent(null);
      const worldMatrix = this.attachedNode.getWorldMatrix();
      const currentToTarget = this._workingPosition;
      const rotationQuaternion = this._workingQuaternion;
      const pivot = this.attachedNode.getPivotPoint();
      const invertView = this._tmpInvertView;
      invertView.copyFrom(camera.getViewMatrix());
      invertView.invert();
      Vector3.TransformCoordinatesToRef(pivot, worldMatrix, currentToTarget);
      const position = this._tmpPosition;
      position.copyFromFloats(0, 0, 0);
      Vector3.TransformCoordinatesToRef(position, worldMatrix, position);
      position.scaleInPlace(-1).subtractInPlace(pivot);
      currentToTarget.subtractInPlace(camera.globalPosition);
      if (this.ignoreCameraPitchAndRoll) {
        this._applyPitchOffset(invertView);
      }
      let angularClamped = false;
      const forward = this._tmpForward;
      forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
      Vector3.TransformNormalToRef(forward, invertView, forward);
      const nodeForward = this._tmpNodeForward;
      nodeForward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
      Vector3.TransformNormalToRef(nodeForward, worldMatrix, nodeForward);
      if (this._recenterNextUpdate) {
        currentToTarget.copyFrom(forward).scaleInPlace(this.defaultDistance);
      } else {
        if (this.ignoreAngleClamp) {
          const currentDistance = currentToTarget.length();
          currentToTarget.copyFrom(forward).scaleInPlace(currentDistance);
        } else {
          angularClamped = this._angularClamp(invertView, currentToTarget);
        }
      }
      let distanceClamped = false;
      if (!this.ignoreDistanceClamp) {
        distanceClamped = this._distanceClamp(currentToTarget, angularClamped);
        this._applyVerticalClamp(currentToTarget);
      }
      if (this.useFixedVerticalOffset) {
        currentToTarget.y = position.y - camera.globalPosition.y + this.fixedVerticalOffset;
      }
      if (angularClamped || distanceClamped || this._passedOrientationDeadzone(currentToTarget, nodeForward) || this._recenterNextUpdate) {
        this._orientationClamp(currentToTarget, rotationQuaternion);
      }
      this._workingPosition.subtractInPlace(pivot);
      this._recenterNextUpdate = false;
      this.attachedNode.setParent(oldParent);
    }
  }
  _updateTransformToGoal(elapsed) {
    if (!this.attachedNode || !this.followedCamera || !this._enabled) {
      return;
    }
    if (!this.attachedNode.rotationQuaternion) {
      this.attachedNode.rotationQuaternion = Quaternion.Identity();
    }
    const oldParent = this.attachedNode.parent;
    this.attachedNode.setParent(null);
    if (!this.interpolatePose) {
      this.attachedNode.position.copyFrom(this.followedCamera.globalPosition).addInPlace(this._workingPosition);
      this.attachedNode.rotationQuaternion.copyFrom(this._workingQuaternion);
      return;
    }
    const currentDirection = new Vector3();
    currentDirection.copyFrom(this.attachedNode.position).subtractInPlace(this.followedCamera.globalPosition);
    Vector3.SmoothToRef(currentDirection, this._workingPosition, elapsed, this.lerpTime, currentDirection);
    currentDirection.addInPlace(this.followedCamera.globalPosition);
    this.attachedNode.position.copyFrom(currentDirection);
    const currentRotation = new Quaternion();
    currentRotation.copyFrom(this.attachedNode.rotationQuaternion);
    Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this.attachedNode.rotationQuaternion);
    this.attachedNode.setParent(oldParent);
  }
  _addObservables() {
    this._lastTick = Date.now();
    this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {
      if (!this.followedCamera) {
        return;
      }
      const tick = Date.now();
      this._updateLeashing(this.followedCamera);
      this._updateTransformToGoal(tick - this._lastTick);
      this._lastTick = tick;
    });
  }
  _removeObservables() {
    if (this._onBeforeRender) {
      this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);
    }
  }
};

// node_modules/@babylonjs/core/XR/webXRFeaturesManager.js
var WebXRFeatureName = class {
};
WebXRFeatureName.ANCHOR_SYSTEM = "xr-anchor-system";
WebXRFeatureName.BACKGROUND_REMOVER = "xr-background-remover";
WebXRFeatureName.HIT_TEST = "xr-hit-test";
WebXRFeatureName.MESH_DETECTION = "xr-mesh-detection";
WebXRFeatureName.PHYSICS_CONTROLLERS = "xr-physics-controller";
WebXRFeatureName.PLANE_DETECTION = "xr-plane-detection";
WebXRFeatureName.POINTER_SELECTION = "xr-controller-pointer-selection";
WebXRFeatureName.TELEPORTATION = "xr-controller-teleportation";
WebXRFeatureName.FEATURE_POINTS = "xr-feature-points";
WebXRFeatureName.HAND_TRACKING = "xr-hand-tracking";
WebXRFeatureName.IMAGE_TRACKING = "xr-image-tracking";
WebXRFeatureName.NEAR_INTERACTION = "xr-near-interaction";
WebXRFeatureName.DOM_OVERLAY = "xr-dom-overlay";
WebXRFeatureName.MOVEMENT = "xr-controller-movement";
WebXRFeatureName.LIGHT_ESTIMATION = "xr-light-estimation";
WebXRFeatureName.EYE_TRACKING = "xr-eye-tracking";
WebXRFeatureName.WALKING_LOCOMOTION = "xr-walking-locomotion";
WebXRFeatureName.LAYERS = "xr-layers";
var WebXRFeaturesManager = class {
  constructor(_xrSessionManager) {
    this._xrSessionManager = _xrSessionManager;
    this._features = {};
    this._xrSessionManager.onXRSessionInit.add(() => {
      this.getEnabledFeatures().forEach((featureName) => {
        const feature = this._features[featureName];
        if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {
          this.attachFeature(featureName);
        }
      });
    });
    this._xrSessionManager.onXRSessionEnded.add(() => {
      this.getEnabledFeatures().forEach((featureName) => {
        const feature = this._features[featureName];
        if (feature.enabled && feature.featureImplementation.attached) {
          this.detachFeature(featureName);
        }
      });
    });
  }
  static AddWebXRFeature(featureName, constructorFunction, version = 1, stable = false) {
    this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || { latest: version };
    if (version > this._AvailableFeatures[featureName].latest) {
      this._AvailableFeatures[featureName].latest = version;
    }
    if (stable) {
      this._AvailableFeatures[featureName].stable = version;
    }
    this._AvailableFeatures[featureName][version] = constructorFunction;
  }
  static ConstructFeature(featureName, version = 1, xrSessionManager, options) {
    const constructorFunction = this._AvailableFeatures[featureName][version];
    if (!constructorFunction) {
      throw new Error("feature not found");
    }
    return constructorFunction(xrSessionManager, options);
  }
  static GetAvailableFeatures() {
    return Object.keys(this._AvailableFeatures);
  }
  static GetAvailableVersions(featureName) {
    return Object.keys(this._AvailableFeatures[featureName]);
  }
  static GetLatestVersionOfFeature(featureName) {
    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest || -1;
  }
  static GetStableVersionOfFeature(featureName) {
    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable || -1;
  }
  attachFeature(featureName) {
    const feature = this._features[featureName];
    if (feature && feature.enabled && !feature.featureImplementation.attached) {
      feature.featureImplementation.attach();
    }
  }
  detachFeature(featureName) {
    const feature = this._features[featureName];
    if (feature && feature.featureImplementation.attached) {
      feature.featureImplementation.detach();
    }
  }
  disableFeature(featureName) {
    const name4 = typeof featureName === "string" ? featureName : featureName.Name;
    const feature = this._features[name4];
    if (feature && feature.enabled) {
      feature.enabled = false;
      this.detachFeature(name4);
      feature.featureImplementation.dispose();
      delete this._features[name4];
      return true;
    }
    return false;
  }
  dispose() {
    this.getEnabledFeatures().forEach((feature) => {
      this.disableFeature(feature);
    });
  }
  enableFeature(featureName, version = "latest", moduleOptions = {}, attachIfPossible = true, required = true) {
    const name4 = typeof featureName === "string" ? featureName : featureName.Name;
    let versionToLoad = 0;
    if (typeof version === "string") {
      if (!version) {
        throw new Error(`Error in provided version - ${name4} (${version})`);
      }
      if (version === "stable") {
        versionToLoad = WebXRFeaturesManager.GetStableVersionOfFeature(name4);
      } else if (version === "latest") {
        versionToLoad = WebXRFeaturesManager.GetLatestVersionOfFeature(name4);
      } else {
        versionToLoad = +version;
      }
      if (versionToLoad === -1 || isNaN(versionToLoad)) {
        throw new Error(`feature not found - ${name4} (${version})`);
      }
    } else {
      versionToLoad = version;
    }
    const conflictingFeature = WebXRFeaturesManager._ConflictingFeatures[name4];
    if (conflictingFeature !== void 0 && this.getEnabledFeatures().indexOf(conflictingFeature) !== -1) {
      throw new Error(`Feature ${name4} cannot be enabled while ${conflictingFeature} is enabled.`);
    }
    const feature = this._features[name4];
    const constructFunction = WebXRFeaturesManager.ConstructFeature(name4, versionToLoad, this._xrSessionManager, moduleOptions);
    if (!constructFunction) {
      throw new Error(`feature not found - ${name4}`);
    }
    if (feature) {
      this.disableFeature(name4);
    }
    const constructed = constructFunction();
    if (constructed.dependsOn) {
      const dependentsFound = constructed.dependsOn.every((featureName2) => !!this._features[featureName2]);
      if (!dependentsFound) {
        throw new Error(`Dependant features missing. Make sure the following features are enabled - ${constructed.dependsOn.join(", ")}`);
      }
    }
    if (constructed.isCompatible()) {
      this._features[name4] = {
        featureImplementation: constructed,
        enabled: true,
        version: versionToLoad,
        required
      };
      if (attachIfPossible) {
        if (this._xrSessionManager.session && !this._features[name4].featureImplementation.attached) {
          this.attachFeature(name4);
        }
      } else {
        this._features[name4].featureImplementation.disableAutoAttach = true;
      }
      return this._features[name4].featureImplementation;
    } else {
      if (required) {
        throw new Error("required feature not compatible");
      } else {
        Tools.Warn(`Feature ${name4} not compatible with the current environment/browser and was not enabled.`);
        return constructed;
      }
    }
  }
  getEnabledFeature(featureName) {
    return this._features[featureName] && this._features[featureName].featureImplementation;
  }
  getEnabledFeatures() {
    return Object.keys(this._features);
  }
  async _extendXRSessionInitObject(xrSessionInit) {
    const enabledFeatures = this.getEnabledFeatures();
    for (const featureName of enabledFeatures) {
      const feature = this._features[featureName];
      const nativeName = feature.featureImplementation.xrNativeFeatureName;
      if (nativeName) {
        if (feature.required) {
          xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];
          if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {
            xrSessionInit.requiredFeatures.push(nativeName);
          }
        } else {
          xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];
          if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {
            xrSessionInit.optionalFeatures.push(nativeName);
          }
        }
      }
      if (feature.featureImplementation.getXRSessionInitExtension) {
        const extended = await feature.featureImplementation.getXRSessionInitExtension();
        xrSessionInit = {
          ...xrSessionInit,
          ...extended
        };
      }
    }
    return xrSessionInit;
  }
};
WebXRFeaturesManager._AvailableFeatures = {};
WebXRFeaturesManager._ConflictingFeatures = {
  [WebXRFeatureName.TELEPORTATION]: WebXRFeatureName.MOVEMENT,
  [WebXRFeatureName.MOVEMENT]: WebXRFeatureName.TELEPORTATION
};

// node_modules/@babylonjs/core/XR/features/WebXRAbstractFeature.js
var WebXRAbstractFeature = class {
  constructor(_xrSessionManager) {
    this._xrSessionManager = _xrSessionManager;
    this._attached = false;
    this._removeOnDetach = [];
    this.isDisposed = false;
    this.disableAutoAttach = false;
    this.xrNativeFeatureName = "";
  }
  get attached() {
    return this._attached;
  }
  attach(force) {
    if (this.isDisposed) {
      return false;
    }
    if (!force) {
      if (this.attached) {
        return false;
      }
    } else {
      if (this.attached) {
        this.detach();
      }
    }
    this._attached = true;
    this._addNewAttachObserver(this._xrSessionManager.onXRFrameObservable, (frame) => this._onXRFrame(frame));
    return true;
  }
  detach() {
    if (!this._attached) {
      this.disableAutoAttach = true;
      return false;
    }
    this._attached = false;
    this._removeOnDetach.forEach((toRemove) => {
      toRemove.observable.remove(toRemove.observer);
    });
    return true;
  }
  dispose() {
    this.detach();
    this.isDisposed = true;
  }
  isCompatible() {
    return true;
  }
  _addNewAttachObserver(observable, callback) {
    this._removeOnDetach.push({
      observable,
      observer: observable.add(callback)
    });
  }
};

// node_modules/@babylonjs/core/Physics/v1/physicsJoint.js
var PhysicsJoint = class {
  constructor(type, jointData) {
    this.type = type;
    this.jointData = jointData;
    jointData.nativeParams = jointData.nativeParams || {};
  }
  get physicsJoint() {
    return this._physicsJoint;
  }
  set physicsJoint(newJoint) {
    if (this._physicsJoint) {
    }
    this._physicsJoint = newJoint;
  }
  set physicsPlugin(physicsPlugin) {
    this._physicsPlugin = physicsPlugin;
  }
  executeNativeFunction(func) {
    func(this._physicsPlugin.world, this._physicsJoint);
  }
};
PhysicsJoint.DistanceJoint = 0;
PhysicsJoint.HingeJoint = 1;
PhysicsJoint.BallAndSocketJoint = 2;
PhysicsJoint.WheelJoint = 3;
PhysicsJoint.SliderJoint = 4;
PhysicsJoint.PrismaticJoint = 5;
PhysicsJoint.UniversalJoint = 6;
PhysicsJoint.Hinge2Joint = PhysicsJoint.WheelJoint;
PhysicsJoint.PointToPointJoint = 8;
PhysicsJoint.SpringJoint = 9;
PhysicsJoint.LockJoint = 10;
var DistanceJoint = class extends PhysicsJoint {
  constructor(jointData) {
    super(PhysicsJoint.DistanceJoint, jointData);
  }
  updateDistance(maxDistance, minDistance) {
    this._physicsPlugin.updateDistanceJoint(this, maxDistance, minDistance);
  }
};
var MotorEnabledJoint = class extends PhysicsJoint {
  constructor(type, jointData) {
    super(type, jointData);
  }
  setMotor(force, maxForce) {
    this._physicsPlugin.setMotor(this, force || 0, maxForce);
  }
  setLimit(upperLimit, lowerLimit) {
    this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
  }
};
var HingeJoint = class extends MotorEnabledJoint {
  constructor(jointData) {
    super(PhysicsJoint.HingeJoint, jointData);
  }
  setMotor(force, maxForce) {
    this._physicsPlugin.setMotor(this, force || 0, maxForce);
  }
  setLimit(upperLimit, lowerLimit) {
    this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
  }
};
var Hinge2Joint = class extends MotorEnabledJoint {
  constructor(jointData) {
    super(PhysicsJoint.Hinge2Joint, jointData);
  }
  setMotor(targetSpeed, maxForce, motorIndex = 0) {
    this._physicsPlugin.setMotor(this, targetSpeed || 0, maxForce, motorIndex);
  }
  setLimit(upperLimit, lowerLimit, motorIndex = 0) {
    this._physicsPlugin.setLimit(this, upperLimit, lowerLimit, motorIndex);
  }
};

// node_modules/@babylonjs/core/Physics/v1/physicsImpostor.js
Mesh._PhysicsImpostorParser = function(scene, physicObject, jsonObject) {
  return new PhysicsImpostor(physicObject, jsonObject.physicsImpostor, {
    mass: jsonObject.physicsMass,
    friction: jsonObject.physicsFriction,
    restitution: jsonObject.physicsRestitution
  }, scene);
};
var PhysicsImpostor = class {
  constructor(object, type, _options = { mass: 0 }, _scene) {
    this.object = object;
    this.type = type;
    this._options = _options;
    this._scene = _scene;
    this._pluginData = {};
    this._bodyUpdateRequired = false;
    this._onBeforePhysicsStepCallbacks = new Array();
    this._onAfterPhysicsStepCallbacks = new Array();
    this._onPhysicsCollideCallbacks = [];
    this._deltaPosition = Vector3.Zero();
    this._isDisposed = false;
    this.soft = false;
    this.segments = 0;
    this._tmpQuat = new Quaternion();
    this._tmpQuat2 = new Quaternion();
    this.beforeStep = () => {
      if (!this._physicsEngine) {
        return;
      }
      this.object.translate(this._deltaPosition, -1);
      this._deltaRotationConjugated && this.object.rotationQuaternion && this.object.rotationQuaternion.multiplyToRef(this._deltaRotationConjugated, this.object.rotationQuaternion);
      this.object.computeWorldMatrix(false);
      if (this.object.parent && this.object.rotationQuaternion) {
        this.getParentsRotation();
        this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this._tmpQuat);
      } else {
        this._tmpQuat.copyFrom(this.object.rotationQuaternion || new Quaternion());
      }
      if (!this._options.disableBidirectionalTransformation) {
        this.object.rotationQuaternion && this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(this, this.object.getAbsolutePosition(), this._tmpQuat);
      }
      this._onBeforePhysicsStepCallbacks.forEach((func) => {
        func(this);
      });
    };
    this.afterStep = () => {
      if (!this._physicsEngine) {
        return;
      }
      this._onAfterPhysicsStepCallbacks.forEach((func) => {
        func(this);
      });
      this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(this);
      if (this.object.parent && this.object.rotationQuaternion) {
        this.getParentsRotation();
        this._tmpQuat.conjugateInPlace();
        this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this.object.rotationQuaternion);
      }
      this.object.setAbsolutePosition(this.object.position);
      if (this._deltaRotation) {
        this.object.rotationQuaternion && this.object.rotationQuaternion.multiplyToRef(this._deltaRotation, this.object.rotationQuaternion);
        this._deltaPosition.applyRotationQuaternionToRef(this._deltaRotation, PhysicsImpostor._TmpVecs[0]);
        this.object.translate(PhysicsImpostor._TmpVecs[0], 1);
      } else {
        this.object.translate(this._deltaPosition, 1);
      }
      this.object.computeWorldMatrix(true);
    };
    this.onCollideEvent = null;
    this.onCollide = (e) => {
      if (!this._onPhysicsCollideCallbacks.length && !this.onCollideEvent) {
        return;
      }
      if (!this._physicsEngine) {
        return;
      }
      const otherImpostor = this._physicsEngine.getImpostorWithPhysicsBody(e.body);
      if (otherImpostor) {
        if (this.onCollideEvent) {
          this.onCollideEvent(this, otherImpostor);
        }
        this._onPhysicsCollideCallbacks.filter((obj) => {
          return obj.otherImpostors.indexOf(otherImpostor) !== -1;
        }).forEach((obj) => {
          obj.callback(this, otherImpostor, e.point, e.distance, e.impulse, e.normal);
        });
      }
    };
    if (!this.object) {
      Logger.Error("No object was provided. A physics object is obligatory");
      return;
    }
    if (this.object.parent && _options.mass !== 0) {
      Logger.Warn("A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur.");
    }
    if (!this._scene && object.getScene) {
      this._scene = object.getScene();
    }
    if (!this._scene) {
      return;
    }
    if (this.type > 100) {
      this.soft = true;
    }
    this._physicsEngine = this._scene.getPhysicsEngine();
    if (!this._physicsEngine) {
      Logger.Error("Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.");
    } else {
      if (!this.object.rotationQuaternion) {
        if (this.object.rotation) {
          this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);
        } else {
          this.object.rotationQuaternion = new Quaternion();
        }
      }
      this._options.mass = _options.mass === void 0 ? 0 : _options.mass;
      this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;
      this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;
      if (this.soft) {
        this._options.mass = this._options.mass > 0 ? this._options.mass : 1;
        this._options.pressure = _options.pressure === void 0 ? 200 : _options.pressure;
        this._options.stiffness = _options.stiffness === void 0 ? 1 : _options.stiffness;
        this._options.velocityIterations = _options.velocityIterations === void 0 ? 20 : _options.velocityIterations;
        this._options.positionIterations = _options.positionIterations === void 0 ? 20 : _options.positionIterations;
        this._options.fixedPoints = _options.fixedPoints === void 0 ? 0 : _options.fixedPoints;
        this._options.margin = _options.margin === void 0 ? 0 : _options.margin;
        this._options.damping = _options.damping === void 0 ? 0 : _options.damping;
        this._options.path = _options.path === void 0 ? null : _options.path;
        this._options.shape = _options.shape === void 0 ? null : _options.shape;
      }
      this._joints = [];
      if (!this.object.parent || this._options.ignoreParent) {
        this._init();
      } else if (this.object.parent.physicsImpostor) {
        Logger.Warn("You must affect impostors to children before affecting impostor to parent.");
      }
    }
  }
  get isDisposed() {
    return this._isDisposed;
  }
  get mass() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;
  }
  set mass(value) {
    this.setMass(value);
  }
  get friction() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;
  }
  set friction(value) {
    if (!this._physicsEngine) {
      return;
    }
    this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);
  }
  get restitution() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;
  }
  set restitution(value) {
    if (!this._physicsEngine) {
      return;
    }
    this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);
  }
  get pressure() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyPressure) {
      return 0;
    }
    return plugin.getBodyPressure(this);
  }
  set pressure(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyPressure) {
      return;
    }
    plugin.setBodyPressure(this, value);
  }
  get stiffness() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.getBodyStiffness) {
      return 0;
    }
    return plugin.getBodyStiffness(this);
  }
  set stiffness(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyStiffness) {
      return;
    }
    plugin.setBodyStiffness(this, value);
  }
  get velocityIterations() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.getBodyVelocityIterations) {
      return 0;
    }
    return plugin.getBodyVelocityIterations(this);
  }
  set velocityIterations(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyVelocityIterations) {
      return;
    }
    plugin.setBodyVelocityIterations(this, value);
  }
  get positionIterations() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.getBodyPositionIterations) {
      return 0;
    }
    return plugin.getBodyPositionIterations(this);
  }
  set positionIterations(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyPositionIterations) {
      return;
    }
    plugin.setBodyPositionIterations(this, value);
  }
  _init() {
    if (!this._physicsEngine) {
      return;
    }
    this._physicsEngine.removeImpostor(this);
    this.physicsBody = null;
    this._parent = this._parent || this._getPhysicsParent();
    if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {
      this._physicsEngine.addImpostor(this);
    }
  }
  _getPhysicsParent() {
    if (this.object.parent instanceof AbstractMesh) {
      const parentMesh = this.object.parent;
      return parentMesh.physicsImpostor;
    }
    return null;
  }
  isBodyInitRequired() {
    return this._bodyUpdateRequired || !this._physicsBody && (!this._parent || !!this._options.ignoreParent);
  }
  setScalingUpdated() {
    this.forceUpdate();
  }
  forceUpdate() {
    this._init();
    if (this.parent && !this._options.ignoreParent) {
      this.parent.forceUpdate();
    }
  }
  get physicsBody() {
    return this._parent && !this._options.ignoreParent ? this._parent.physicsBody : this._physicsBody;
  }
  get parent() {
    return !this._options.ignoreParent && this._parent ? this._parent : null;
  }
  set parent(value) {
    this._parent = value;
  }
  set physicsBody(physicsBody) {
    if (this._physicsBody && this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);
    }
    this._physicsBody = physicsBody;
    this.resetUpdateFlags();
  }
  resetUpdateFlags() {
    this._bodyUpdateRequired = false;
  }
  getObjectExtents() {
    if (this.object.getBoundingInfo) {
      const q = this.object.rotationQuaternion;
      const scaling = this.object.scaling.clone();
      this.object.rotationQuaternion = PhysicsImpostor.IDENTITY_QUATERNION;
      const worldMatrix = this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);
      if (worldMatrix) {
        worldMatrix.decompose(scaling, void 0, void 0);
      }
      const boundingInfo = this.object.getBoundingInfo();
      const size = boundingInfo.boundingBox.extendSize.scale(2).multiplyInPlace(scaling);
      size.x = Math.abs(size.x);
      size.y = Math.abs(size.y);
      size.z = Math.abs(size.z);
      this.object.rotationQuaternion = q;
      this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);
      return size;
    } else {
      return PhysicsImpostor.DEFAULT_OBJECT_SIZE;
    }
  }
  getObjectCenter() {
    if (this.object.getBoundingInfo) {
      const boundingInfo = this.object.getBoundingInfo();
      return boundingInfo.boundingBox.centerWorld;
    } else {
      return this.object.position;
    }
  }
  getParam(paramName) {
    return this._options[paramName];
  }
  setParam(paramName, value) {
    this._options[paramName] = value;
    this._bodyUpdateRequired = true;
  }
  setMass(mass) {
    if (this.getParam("mass") !== mass) {
      this.setParam("mass", mass);
    }
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);
    }
  }
  getLinearVelocity() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Vector3.Zero();
  }
  setLinearVelocity(velocity) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);
    }
  }
  getAngularVelocity() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Vector3.Zero();
  }
  setAngularVelocity(velocity) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);
    }
  }
  executeNativeFunction(func) {
    if (this._physicsEngine) {
      func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);
    }
  }
  registerBeforePhysicsStep(func) {
    this._onBeforePhysicsStepCallbacks.push(func);
  }
  unregisterBeforePhysicsStep(func) {
    const index = this._onBeforePhysicsStepCallbacks.indexOf(func);
    if (index > -1) {
      this._onBeforePhysicsStepCallbacks.splice(index, 1);
    } else {
      Logger.Warn("Function to remove was not found");
    }
  }
  registerAfterPhysicsStep(func) {
    this._onAfterPhysicsStepCallbacks.push(func);
  }
  unregisterAfterPhysicsStep(func) {
    const index = this._onAfterPhysicsStepCallbacks.indexOf(func);
    if (index > -1) {
      this._onAfterPhysicsStepCallbacks.splice(index, 1);
    } else {
      Logger.Warn("Function to remove was not found");
    }
  }
  registerOnPhysicsCollide(collideAgainst, func) {
    const collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
    this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });
  }
  unregisterOnPhysicsCollide(collideAgainst, func) {
    const collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
    let index = -1;
    const found = this._onPhysicsCollideCallbacks.some((cbDef, idx) => {
      if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {
        const sameList = cbDef.otherImpostors.every((impostor) => {
          return collidedAgainstList.indexOf(impostor) > -1;
        });
        if (sameList) {
          index = idx;
        }
        return sameList;
      }
      return false;
    });
    if (found) {
      this._onPhysicsCollideCallbacks.splice(index, 1);
    } else {
      Logger.Warn("Function to remove was not found");
    }
  }
  getParentsRotation() {
    let parent = this.object.parent;
    this._tmpQuat.copyFromFloats(0, 0, 0, 1);
    while (parent) {
      if (parent.rotationQuaternion) {
        this._tmpQuat2.copyFrom(parent.rotationQuaternion);
      } else {
        Quaternion.RotationYawPitchRollToRef(parent.rotation.y, parent.rotation.x, parent.rotation.z, this._tmpQuat2);
      }
      this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat);
      parent = parent.parent;
    }
    return this._tmpQuat;
  }
  applyForce(force, contactPoint) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);
    }
    return this;
  }
  applyImpulse(force, contactPoint) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);
    }
    return this;
  }
  createJoint(otherImpostor, jointType, jointData) {
    const joint = new PhysicsJoint(jointType, jointData);
    this.addJoint(otherImpostor, joint);
    return this;
  }
  addJoint(otherImpostor, joint) {
    this._joints.push({
      otherImpostor,
      joint
    });
    if (this._physicsEngine) {
      this._physicsEngine.addJoint(this, otherImpostor, joint);
    }
    return this;
  }
  addAnchor(otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies) {
    if (!this._physicsEngine) {
      return this;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.appendAnchor) {
      return this;
    }
    if (this._physicsEngine) {
      plugin.appendAnchor(this, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies);
    }
    return this;
  }
  addHook(otherImpostor, length, influence, noCollisionBetweenLinkedBodies) {
    if (!this._physicsEngine) {
      return this;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.appendAnchor) {
      return this;
    }
    if (this._physicsEngine) {
      plugin.appendHook(this, otherImpostor, length, influence, noCollisionBetweenLinkedBodies);
    }
    return this;
  }
  sleep() {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().sleepBody(this);
    }
    return this;
  }
  wakeUp() {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);
    }
    return this;
  }
  clone(newObject) {
    if (!newObject) {
      return null;
    }
    return new PhysicsImpostor(newObject, this.type, this._options, this._scene);
  }
  dispose() {
    if (!this._physicsEngine) {
      return;
    }
    this._joints.forEach((j) => {
      if (this._physicsEngine) {
        this._physicsEngine.removeJoint(this, j.otherImpostor, j.joint);
      }
    });
    this._physicsEngine.removeImpostor(this);
    if (this.parent) {
      this.parent.forceUpdate();
    } else {
    }
    this._isDisposed = true;
  }
  setDeltaPosition(position) {
    this._deltaPosition.copyFrom(position);
  }
  setDeltaRotation(rotation) {
    if (!this._deltaRotation) {
      this._deltaRotation = new Quaternion();
    }
    this._deltaRotation.copyFrom(rotation);
    this._deltaRotationConjugated = this._deltaRotation.conjugate();
  }
  getBoxSizeToRef(result) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);
    }
    return this;
  }
  getRadius() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;
  }
  syncBoneWithImpostor(bone, boneMesh, jointPivot, distToJoint, adjustRotation) {
    const tempVec = PhysicsImpostor._TmpVecs[0];
    const mesh = this.object;
    if (mesh.rotationQuaternion) {
      if (adjustRotation) {
        const tempQuat = PhysicsImpostor._TmpQuat;
        mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);
        bone.setRotationQuaternion(tempQuat, Space.WORLD, boneMesh);
      } else {
        bone.setRotationQuaternion(mesh.rotationQuaternion, Space.WORLD, boneMesh);
      }
    }
    tempVec.x = 0;
    tempVec.y = 0;
    tempVec.z = 0;
    if (jointPivot) {
      tempVec.x = jointPivot.x;
      tempVec.y = jointPivot.y;
      tempVec.z = jointPivot.z;
      bone.getDirectionToRef(tempVec, boneMesh, tempVec);
      if (distToJoint === void 0 || distToJoint === null) {
        distToJoint = jointPivot.length();
      }
      tempVec.x *= distToJoint;
      tempVec.y *= distToJoint;
      tempVec.z *= distToJoint;
    }
    if (bone.getParent()) {
      tempVec.addInPlace(mesh.getAbsolutePosition());
      bone.setAbsolutePosition(tempVec, boneMesh);
    } else {
      boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());
      boneMesh.position.x -= tempVec.x;
      boneMesh.position.y -= tempVec.y;
      boneMesh.position.z -= tempVec.z;
    }
  }
  syncImpostorWithBone(bone, boneMesh, jointPivot, distToJoint, adjustRotation, boneAxis) {
    const mesh = this.object;
    if (mesh.rotationQuaternion) {
      if (adjustRotation) {
        const tempQuat = PhysicsImpostor._TmpQuat;
        bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);
        tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);
      } else {
        bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);
      }
    }
    const pos = PhysicsImpostor._TmpVecs[0];
    const boneDir = PhysicsImpostor._TmpVecs[1];
    if (!boneAxis) {
      boneAxis = PhysicsImpostor._TmpVecs[2];
      boneAxis.x = 0;
      boneAxis.y = 1;
      boneAxis.z = 0;
    }
    bone.getDirectionToRef(boneAxis, boneMesh, boneDir);
    bone.getAbsolutePositionToRef(boneMesh, pos);
    if ((distToJoint === void 0 || distToJoint === null) && jointPivot) {
      distToJoint = jointPivot.length();
    }
    if (distToJoint !== void 0 && distToJoint !== null) {
      pos.x += boneDir.x * distToJoint;
      pos.y += boneDir.y * distToJoint;
      pos.z += boneDir.z * distToJoint;
    }
    mesh.setAbsolutePosition(pos);
  }
};
PhysicsImpostor.DEFAULT_OBJECT_SIZE = new Vector3(1, 1, 1);
PhysicsImpostor.IDENTITY_QUATERNION = Quaternion.Identity();
PhysicsImpostor._TmpVecs = ArrayTools.BuildArray(3, Vector3.Zero);
PhysicsImpostor._TmpQuat = Quaternion.Identity();
PhysicsImpostor.NoImpostor = 0;
PhysicsImpostor.SphereImpostor = 1;
PhysicsImpostor.BoxImpostor = 2;
PhysicsImpostor.PlaneImpostor = 3;
PhysicsImpostor.MeshImpostor = 4;
PhysicsImpostor.CapsuleImpostor = 6;
PhysicsImpostor.CylinderImpostor = 7;
PhysicsImpostor.ParticleImpostor = 8;
PhysicsImpostor.HeightmapImpostor = 9;
PhysicsImpostor.ConvexHullImpostor = 10;
PhysicsImpostor.CustomImpostor = 100;
PhysicsImpostor.RopeImpostor = 101;
PhysicsImpostor.ClothImpostor = 102;
PhysicsImpostor.SoftbodyImpostor = 103;

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockConnectionPointTypes.js
var NodeMaterialBlockConnectionPointTypes;
(function(NodeMaterialBlockConnectionPointTypes2) {
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Float"] = 1] = "Float";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Int"] = 2] = "Int";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector2"] = 4] = "Vector2";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector3"] = 8] = "Vector3";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector4"] = 16] = "Vector4";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Color3"] = 32] = "Color3";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Color4"] = 64] = "Color4";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Matrix"] = 128] = "Matrix";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Object"] = 256] = "Object";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["AutoDetect"] = 1024] = "AutoDetect";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["BasedOnInput"] = 2048] = "BasedOnInput";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["All"] = 4095] = "All";
})(NodeMaterialBlockConnectionPointTypes || (NodeMaterialBlockConnectionPointTypes = {}));

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockTargets.js
var NodeMaterialBlockTargets;
(function(NodeMaterialBlockTargets2) {
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Vertex"] = 1] = "Vertex";
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Fragment"] = 2] = "Fragment";
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Neutral"] = 4] = "Neutral";
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["VertexAndFragment"] = 3] = "VertexAndFragment";
})(NodeMaterialBlockTargets || (NodeMaterialBlockTargets = {}));

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBlockConnectionPoint.js
var NodeMaterialConnectionPointCompatibilityStates;
(function(NodeMaterialConnectionPointCompatibilityStates2) {
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["Compatible"] = 0] = "Compatible";
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["TypeIncompatible"] = 1] = "TypeIncompatible";
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["TargetIncompatible"] = 2] = "TargetIncompatible";
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["HierarchyIssue"] = 3] = "HierarchyIssue";
})(NodeMaterialConnectionPointCompatibilityStates || (NodeMaterialConnectionPointCompatibilityStates = {}));
var NodeMaterialConnectionPointDirection;
(function(NodeMaterialConnectionPointDirection2) {
  NodeMaterialConnectionPointDirection2[NodeMaterialConnectionPointDirection2["Input"] = 0] = "Input";
  NodeMaterialConnectionPointDirection2[NodeMaterialConnectionPointDirection2["Output"] = 1] = "Output";
})(NodeMaterialConnectionPointDirection || (NodeMaterialConnectionPointDirection = {}));
var NodeMaterialConnectionPoint = class {
  constructor(name4, ownerBlock, direction) {
    this._connectedPoint = null;
    this._endpoints = new Array();
    this._typeConnectionSource = null;
    this._defaultConnectionPointType = null;
    this._linkedConnectionSource = null;
    this._acceptedConnectionPointType = null;
    this._type = NodeMaterialBlockConnectionPointTypes.Float;
    this._enforceAssociatedVariableName = false;
    this.needDualDirectionValidation = false;
    this.acceptedConnectionPointTypes = new Array();
    this.excludedConnectionPointTypes = new Array();
    this.onConnectionObservable = new Observable();
    this.isExposedOnFrame = false;
    this.exposedPortPosition = -1;
    this._prioritizeVertex = false;
    this._target = NodeMaterialBlockTargets.VertexAndFragment;
    this._ownerBlock = ownerBlock;
    this.name = name4;
    this._direction = direction;
  }
  static AreEquivalentTypes(type1, type2) {
    switch (type1) {
      case NodeMaterialBlockConnectionPointTypes.Vector3: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {
          return true;
        }
        break;
      }
      case NodeMaterialBlockConnectionPointTypes.Vector4: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {
          return true;
        }
        break;
      }
      case NodeMaterialBlockConnectionPointTypes.Color3: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {
          return true;
        }
        break;
      }
      case NodeMaterialBlockConnectionPointTypes.Color4: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {
          return true;
        }
        break;
      }
    }
    return false;
  }
  get direction() {
    return this._direction;
  }
  get associatedVariableName() {
    if (this._ownerBlock.isInput) {
      return this._ownerBlock.associatedVariableName;
    }
    if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {
      return this._connectedPoint.associatedVariableName;
    }
    return this._associatedVariableName;
  }
  set associatedVariableName(value) {
    this._associatedVariableName = value;
  }
  get innerType() {
    if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {
      return this.type;
    }
    return this._type;
  }
  get type() {
    if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
      if (this._ownerBlock.isInput) {
        return this._ownerBlock.type;
      }
      if (this._connectedPoint) {
        return this._connectedPoint.type;
      }
      if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {
        return this._linkedConnectionSource.type;
      }
    }
    if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput) {
      if (this._typeConnectionSource) {
        if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {
          return this._defaultConnectionPointType;
        }
        return this._typeConnectionSource.type;
      } else if (this._defaultConnectionPointType) {
        return this._defaultConnectionPointType;
      }
    }
    return this._type;
  }
  set type(value) {
    this._type = value;
  }
  get target() {
    if (!this._prioritizeVertex || !this._ownerBlock) {
      return this._target;
    }
    if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {
      return this._target;
    }
    if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      return NodeMaterialBlockTargets.Fragment;
    }
    return NodeMaterialBlockTargets.Vertex;
  }
  set target(value) {
    this._target = value;
  }
  get isConnected() {
    return this.connectedPoint !== null || this.hasEndpoints;
  }
  get isConnectedToInputBlock() {
    return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;
  }
  get connectInputBlock() {
    if (!this.isConnectedToInputBlock) {
      return null;
    }
    return this.connectedPoint.ownerBlock;
  }
  get connectedPoint() {
    return this._connectedPoint;
  }
  get ownerBlock() {
    return this._ownerBlock;
  }
  get sourceBlock() {
    if (!this._connectedPoint) {
      return null;
    }
    return this._connectedPoint.ownerBlock;
  }
  get connectedBlocks() {
    if (this._endpoints.length === 0) {
      return [];
    }
    return this._endpoints.map((e) => e.ownerBlock);
  }
  get endpoints() {
    return this._endpoints;
  }
  get hasEndpoints() {
    return this._endpoints && this._endpoints.length > 0;
  }
  get isDirectlyConnectedToVertexOutput() {
    if (!this.hasEndpoints) {
      return false;
    }
    for (const endpoint of this._endpoints) {
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {
        return true;
      }
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
        if (endpoint.ownerBlock.outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {
          return true;
        }
      }
    }
    return false;
  }
  get isConnectedInVertexShader() {
    if (this.target === NodeMaterialBlockTargets.Vertex) {
      return true;
    }
    if (!this.hasEndpoints) {
      return false;
    }
    for (const endpoint of this._endpoints) {
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {
        return true;
      }
      if (endpoint.target === NodeMaterialBlockTargets.Vertex) {
        return true;
      }
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
        if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInVertexShader)) {
          return true;
        }
      }
    }
    return false;
  }
  get isConnectedInFragmentShader() {
    if (this.target === NodeMaterialBlockTargets.Fragment) {
      return true;
    }
    if (!this.hasEndpoints) {
      return false;
    }
    for (const endpoint of this._endpoints) {
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
        return true;
      }
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
        if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInFragmentShader)) {
          return true;
        }
      }
    }
    return false;
  }
  createCustomInputBlock() {
    return null;
  }
  getClassName() {
    return "NodeMaterialConnectionPoint";
  }
  canConnectTo(connectionPoint) {
    return this.checkCompatibilityState(connectionPoint) === NodeMaterialConnectionPointCompatibilityStates.Compatible;
  }
  checkCompatibilityState(connectionPoint) {
    const ownerBlock = this._ownerBlock;
    const otherBlock = connectionPoint.ownerBlock;
    if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {
        return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;
      }
      for (const output of otherBlock.outputs) {
        if (output.ownerBlock.target != NodeMaterialBlockTargets.Neutral && output.isConnectedInVertexShader) {
          return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;
        }
      }
    }
    if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {
      if (NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {
        return NodeMaterialConnectionPointCompatibilityStates.Compatible;
      }
      if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1 || connectionPoint._acceptedConnectionPointType && NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type)) {
        return NodeMaterialConnectionPointCompatibilityStates.Compatible;
      } else {
        return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;
      }
    }
    if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {
      return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;
    }
    let targetBlock = otherBlock;
    let sourceBlock = ownerBlock;
    if (this.direction === NodeMaterialConnectionPointDirection.Input) {
      targetBlock = ownerBlock;
      sourceBlock = otherBlock;
    }
    if (targetBlock.isAnAncestorOf(sourceBlock)) {
      return NodeMaterialConnectionPointCompatibilityStates.HierarchyIssue;
    }
    return NodeMaterialConnectionPointCompatibilityStates.Compatible;
  }
  connectTo(connectionPoint, ignoreConstraints = false) {
    if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {
      throw "Cannot connect these two connectors.";
    }
    this._endpoints.push(connectionPoint);
    connectionPoint._connectedPoint = this;
    this._enforceAssociatedVariableName = false;
    this.onConnectionObservable.notifyObservers(connectionPoint);
    connectionPoint.onConnectionObservable.notifyObservers(this);
    return this;
  }
  disconnectFrom(endpoint) {
    const index = this._endpoints.indexOf(endpoint);
    if (index === -1) {
      return this;
    }
    this._endpoints.splice(index, 1);
    endpoint._connectedPoint = null;
    this._enforceAssociatedVariableName = false;
    endpoint._enforceAssociatedVariableName = false;
    return this;
  }
  addExcludedConnectionPointFromAllowedTypes(mask) {
    let bitmask = 1;
    while (bitmask < NodeMaterialBlockConnectionPointTypes.All) {
      if (!(mask & bitmask)) {
        this.excludedConnectionPointTypes.push(bitmask);
      }
      bitmask = bitmask << 1;
    }
  }
  serialize(isInput = true) {
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.displayName = this.displayName;
    if (isInput && this.connectedPoint) {
      serializationObject.inputName = this.name;
      serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;
      serializationObject.targetConnectionName = this.connectedPoint.name;
      serializationObject.isExposedOnFrame = true;
      serializationObject.exposedPortPosition = this.exposedPortPosition;
    }
    if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {
      serializationObject.isExposedOnFrame = true;
      serializationObject.exposedPortPosition = this.exposedPortPosition;
    }
    return serializationObject;
  }
  dispose() {
    this.onConnectionObservable.clear();
  }
};

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBlock.js
var NodeMaterialBlock = class {
  constructor(name4, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false, isInput = false) {
    this._isFinalMerger = false;
    this._isInput = false;
    this._name = "";
    this._isUnique = false;
    this.inputsAreExclusive = false;
    this._codeVariableName = "";
    this._inputs = new Array();
    this._outputs = new Array();
    this.comments = "";
    this.visibleInInspector = false;
    this.visibleOnFrame = false;
    this._target = target;
    this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;
    this._isFinalMerger = isFinalMerger;
    this._isInput = isInput;
    this._name = name4;
    this.uniqueId = UniqueIdGenerator.UniqueId;
  }
  get name() {
    return this._name;
  }
  set name(newName) {
    if (!this.validateBlockName(newName)) {
      return;
    }
    this._name = newName;
  }
  get isUnique() {
    return this._isUnique;
  }
  get isFinalMerger() {
    return this._isFinalMerger;
  }
  get isInput() {
    return this._isInput;
  }
  get buildId() {
    return this._buildId;
  }
  set buildId(value) {
    this._buildId = value;
  }
  get target() {
    return this._target;
  }
  set target(value) {
    if ((this._target & value) !== 0) {
      return;
    }
    this._target = value;
  }
  get inputs() {
    return this._inputs;
  }
  get outputs() {
    return this._outputs;
  }
  getInputByName(name4) {
    const filter = this._inputs.filter((e) => e.name === name4);
    if (filter.length) {
      return filter[0];
    }
    return null;
  }
  getOutputByName(name4) {
    const filter = this._outputs.filter((e) => e.name === name4);
    if (filter.length) {
      return filter[0];
    }
    return null;
  }
  _setInitialTarget(target) {
    this._target = target;
    this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;
  }
  initialize(state) {
  }
  bind(effect, nodeMaterial, mesh, subMesh) {
  }
  _declareOutput(output, state) {
    return `${state._getGLType(output.type)} ${output.associatedVariableName}`;
  }
  _writeVariable(currentPoint) {
    const connectionPoint = currentPoint.connectedPoint;
    if (connectionPoint) {
      return `${currentPoint.associatedVariableName}`;
    }
    return `0.`;
  }
  _writeFloat(value) {
    let stringVersion = value.toString();
    if (stringVersion.indexOf(".") === -1) {
      stringVersion += ".0";
    }
    return `${stringVersion}`;
  }
  getClassName() {
    return "NodeMaterialBlock";
  }
  registerInput(name4, type, isOptional = false, target, point) {
    point = point !== null && point !== void 0 ? point : new NodeMaterialConnectionPoint(name4, this, NodeMaterialConnectionPointDirection.Input);
    point.type = type;
    point.isOptional = isOptional;
    if (target) {
      point.target = target;
    }
    this._inputs.push(point);
    return this;
  }
  registerOutput(name4, type, target, point) {
    point = point !== null && point !== void 0 ? point : new NodeMaterialConnectionPoint(name4, this, NodeMaterialConnectionPointDirection.Output);
    point.type = type;
    if (target) {
      point.target = target;
    }
    this._outputs.push(point);
    return this;
  }
  getFirstAvailableInput(forOutput = null) {
    for (const input of this._inputs) {
      if (!input.connectedPoint) {
        if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
          return input;
        }
      }
    }
    return null;
  }
  getFirstAvailableOutput(forBlock = null) {
    for (const output of this._outputs) {
      if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {
        return output;
      }
    }
    return null;
  }
  getSiblingOutput(current) {
    const index = this._outputs.indexOf(current);
    if (index === -1 || index >= this._outputs.length) {
      return null;
    }
    return this._outputs[index + 1];
  }
  isAnAncestorOf(block) {
    for (const output of this._outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        if (endpoint.ownerBlock === block) {
          return true;
        }
        if (endpoint.ownerBlock.isAnAncestorOf(block)) {
          return true;
        }
      }
    }
    return false;
  }
  connectTo(other, options) {
    if (this._outputs.length === 0) {
      return;
    }
    let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);
    let notFound = true;
    while (notFound) {
      const input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);
      if (output && input && output.canConnectTo(input)) {
        output.connectTo(input);
        notFound = false;
      } else if (!output) {
        throw "Unable to find a compatible match";
      } else {
        output = this.getSiblingOutput(output);
      }
    }
    return this;
  }
  _buildBlock(state) {
  }
  updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {
  }
  provideFallbacks(mesh, fallbacks) {
  }
  initializeDefines(mesh, nodeMaterial, defines, useInstances = false) {
  }
  prepareDefines(mesh, nodeMaterial, defines, useInstances = false, subMesh) {
  }
  autoConfigure(material) {
  }
  replaceRepeatableContent(vertexShaderState, fragmentShaderState, mesh, defines) {
  }
  get willBeGeneratedIntoVertexShaderFromFragmentShader() {
    if (this.isInput || this.isFinalMerger) {
      return false;
    }
    if (this._outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {
      return false;
    }
    if (this.target === NodeMaterialBlockTargets.Vertex) {
      return false;
    }
    if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {
      if (this._outputs.some((o) => o.isConnectedInVertexShader)) {
        return true;
      }
    }
    return false;
  }
  isReady(mesh, nodeMaterial, defines, useInstances = false) {
    return true;
  }
  _linkConnectionTypes(inputIndex0, inputIndex1, looseCoupling = false) {
    if (looseCoupling) {
      this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];
    } else {
      this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];
    }
    this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];
  }
  _processBuild(block, state, input, activeBlocks) {
    block.build(state, activeBlocks);
    const localBlockIsFragment = state._vertexState != null;
    const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;
    if (localBlockIsFragment && ((block.target & block._buildTarget) === 0 || (block.target & input.target) === 0 || this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader)) {
      if (!block.isInput && state.target !== block._buildTarget || block.isInput && block.isAttribute && !block._noContextSwitch) {
        const connectedPoint = input.connectedPoint;
        if (state._vertexState._emitVaryingFromString("v_" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {
          state._vertexState.compilationString += `${"v_" + connectedPoint.associatedVariableName} = ${connectedPoint.associatedVariableName};\r
`;
        }
        input.associatedVariableName = "v_" + connectedPoint.associatedVariableName;
        input._enforceAssociatedVariableName = true;
      }
    }
  }
  validateBlockName(newName) {
    const reservedNames = [
      "position",
      "normal",
      "tangent",
      "particle_positionw",
      "uv",
      "uv2",
      "uv3",
      "uv4",
      "uv5",
      "uv6",
      "position2d",
      "particle_uv",
      "matricesIndices",
      "matricesWeights",
      "world0",
      "world1",
      "world2",
      "world3",
      "particle_color",
      "particle_texturemask"
    ];
    for (const reservedName of reservedNames) {
      if (newName === reservedName) {
        return false;
      }
    }
    return true;
  }
  build(state, activeBlocks) {
    if (this._buildId === state.sharedData.buildId) {
      return true;
    }
    if (!this.isInput) {
      for (const output of this._outputs) {
        if (!output.associatedVariableName) {
          output.associatedVariableName = state._getFreeVariableName(output.name);
        }
      }
    }
    for (const input of this._inputs) {
      if (!input.connectedPoint) {
        if (!input.isOptional) {
          state.sharedData.checks.notConnectedNonOptionalInputs.push(input);
        }
        continue;
      }
      if (this.target !== NodeMaterialBlockTargets.Neutral) {
        if ((input.target & this.target) === 0) {
          continue;
        }
        if ((input.target & state.target) === 0) {
          continue;
        }
      }
      const block = input.connectedPoint.ownerBlock;
      if (block && block !== this) {
        this._processBuild(block, state, input, activeBlocks);
      }
    }
    if (this._buildId === state.sharedData.buildId) {
      return true;
    }
    if (state.sharedData.verbose) {
      console.log(`${state.target === NodeMaterialBlockTargets.Vertex ? "Vertex shader" : "Fragment shader"}: Building ${this.name} [${this.getClassName()}]`);
    }
    if (this.isFinalMerger) {
      switch (state.target) {
        case NodeMaterialBlockTargets.Vertex:
          state.sharedData.checks.emitVertex = true;
          break;
        case NodeMaterialBlockTargets.Fragment:
          state.sharedData.checks.emitFragment = true;
          break;
      }
    }
    if (!this.isInput && state.sharedData.emitComments) {
      state.compilationString += `\r
//${this.name}\r
`;
    }
    this._buildBlock(state);
    this._buildId = state.sharedData.buildId;
    this._buildTarget = state.target;
    for (const output of this._outputs) {
      if ((output.target & state.target) === 0) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        const block = endpoint.ownerBlock;
        if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {
          this._processBuild(block, state, endpoint, activeBlocks);
        }
      }
    }
    return false;
  }
  _inputRename(name4) {
    return name4;
  }
  _outputRename(name4) {
    return name4;
  }
  _dumpPropertiesCode() {
    const variableName = this._codeVariableName;
    return `${variableName}.visibleInInspector = ${this.visibleInInspector};\r
${variableName}.visibleOnFrame = ${this.visibleOnFrame};\r
${variableName}.target = ${this.target};\r
`;
  }
  _dumpCode(uniqueNames, alreadyDumped) {
    alreadyDumped.push(this);
    let codeString;
    const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, "");
    this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;
    if (uniqueNames.indexOf(this._codeVariableName) !== -1) {
      let index = 0;
      do {
        index++;
        this._codeVariableName = nameAsVariableName + index;
      } while (uniqueNames.indexOf(this._codeVariableName) !== -1);
    }
    uniqueNames.push(this._codeVariableName);
    codeString = `\r
// ${this.getClassName()}\r
`;
    if (this.comments) {
      codeString += `// ${this.comments}\r
`;
    }
    codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}("${this.name}");\r
`;
    codeString += this._dumpPropertiesCode();
    for (const input of this.inputs) {
      if (!input.isConnected) {
        continue;
      }
      const connectedOutput = input.connectedPoint;
      const connectedBlock = connectedOutput.ownerBlock;
      if (alreadyDumped.indexOf(connectedBlock) === -1) {
        codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    for (const output of this.outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        const connectedBlock = endpoint.ownerBlock;
        if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {
          codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
        }
      }
    }
    return codeString;
  }
  _dumpCodeForOutputConnections(alreadyDumped) {
    let codeString = "";
    if (alreadyDumped.indexOf(this) !== -1) {
      return codeString;
    }
    alreadyDumped.push(this);
    for (const input of this.inputs) {
      if (!input.isConnected) {
        continue;
      }
      const connectedOutput = input.connectedPoint;
      const connectedBlock = connectedOutput.ownerBlock;
      codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);
      codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});\r
`;
    }
    return codeString;
  }
  clone(scene, rootUrl = "") {
    const serializationObject = this.serialize();
    const blockType = GetClass(serializationObject.customType);
    if (blockType) {
      const block = new blockType();
      block._deserialize(serializationObject, scene, rootUrl);
      return block;
    }
    return null;
  }
  serialize() {
    const serializationObject = {};
    serializationObject.customType = "BABYLON." + this.getClassName();
    serializationObject.id = this.uniqueId;
    serializationObject.name = this.name;
    serializationObject.comments = this.comments;
    serializationObject.visibleInInspector = this.visibleInInspector;
    serializationObject.visibleOnFrame = this.visibleOnFrame;
    serializationObject.target = this.target;
    serializationObject.inputs = [];
    serializationObject.outputs = [];
    for (const input of this.inputs) {
      serializationObject.inputs.push(input.serialize());
    }
    for (const output of this.outputs) {
      serializationObject.outputs.push(output.serialize(false));
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    var _a;
    this.name = serializationObject.name;
    this.comments = serializationObject.comments;
    this.visibleInInspector = !!serializationObject.visibleInInspector;
    this.visibleOnFrame = !!serializationObject.visibleOnFrame;
    this._target = (_a = serializationObject.target) !== null && _a !== void 0 ? _a : this.target;
    this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);
  }
  _deserializePortDisplayNamesAndExposedOnFrame(serializationObject) {
    const serializedInputs = serializationObject.inputs;
    const serializedOutputs = serializationObject.outputs;
    if (serializedInputs) {
      serializedInputs.forEach((port, i) => {
        if (port.displayName) {
          this.inputs[i].displayName = port.displayName;
        }
        if (port.isExposedOnFrame) {
          this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;
          this.inputs[i].exposedPortPosition = port.exposedPortPosition;
        }
      });
    }
    if (serializedOutputs) {
      serializedOutputs.forEach((port, i) => {
        if (port.displayName) {
          this.outputs[i].displayName = port.displayName;
        }
        if (port.isExposedOnFrame) {
          this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;
          this.outputs[i].exposedPortPosition = port.exposedPortPosition;
        }
      });
    }
  }
  dispose() {
    for (const input of this.inputs) {
      input.dispose();
    }
    for (const output of this.outputs) {
      output.dispose();
    }
  }
};

// node_modules/@babylonjs/core/Materials/Node/Blocks/transformBlock.js
var TransformBlock = class extends NodeMaterialBlock {
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Neutral);
    this.complementW = 1;
    this.complementZ = 0;
    this.target = NodeMaterialBlockTargets.Vertex;
    this.registerInput("vector", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("transform", NodeMaterialBlockConnectionPointTypes.Matrix);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
    this._inputs[0].onConnectionObservable.add((other) => {
      if (other.ownerBlock.isInput) {
        const otherAsInput = other.ownerBlock;
        if (otherAsInput.name === "normal" || otherAsInput.name === "tangent") {
          this.complementW = 0;
        }
      }
    });
  }
  getClassName() {
    return "TransformBlock";
  }
  get vector() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  get xyz() {
    return this._outputs[1];
  }
  get transform() {
    return this._inputs[1];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const vector = this.vector;
    const transform = this.transform;
    if (vector.connectedPoint) {
      if (this.complementW === 0) {
        const comments = `//${this.name}`;
        state._emitFunctionFromInclude("helperFunctions", comments);
        state.sharedData.blocksWithDefines.push(this);
        const transformName = state._getFreeVariableName(`${transform.associatedVariableName}_NUS`);
        state.compilationString += `mat3 ${transformName} = mat3(${transform.associatedVariableName});\r
`;
        state.compilationString += `#ifdef NONUNIFORMSCALING\r
`;
        state.compilationString += `${transformName} = transposeMat3(inverseMat3(${transformName}));\r
`;
        state.compilationString += `#endif\r
`;
        switch (vector.connectedPoint.type) {
          case NodeMaterialBlockConnectionPointTypes.Vector2:
            state.compilationString += this._declareOutput(this.output, state) + ` = vec4(${transformName} * vec3(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}), ${this._writeFloat(this.complementW)});\r
`;
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector3:
          case NodeMaterialBlockConnectionPointTypes.Color3:
            state.compilationString += this._declareOutput(this.output, state) + ` = vec4(${transformName} * ${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\r
`;
            break;
          default:
            state.compilationString += this._declareOutput(this.output, state) + ` = vec4(${transformName} * ${vector.associatedVariableName}.xyz, ${this._writeFloat(this.complementW)});\r
`;
            break;
        }
      } else {
        const transformName = transform.associatedVariableName;
        switch (vector.connectedPoint.type) {
          case NodeMaterialBlockConnectionPointTypes.Vector2:
            state.compilationString += this._declareOutput(this.output, state) + ` = ${transformName} * vec4(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}, ${this._writeFloat(this.complementW)});\r
`;
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector3:
          case NodeMaterialBlockConnectionPointTypes.Color3:
            state.compilationString += this._declareOutput(this.output, state) + ` = ${transformName} * vec4(${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\r
`;
            break;
          default:
            state.compilationString += this._declareOutput(this.output, state) + ` = ${transformName} * ${vector.associatedVariableName};\r
`;
            break;
        }
      }
      if (this.xyz.hasEndpoints) {
        state.compilationString += this._declareOutput(this.xyz, state) + ` = ${this.output.associatedVariableName}.xyz;\r
`;
      }
    }
    return this;
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    if (mesh.nonUniformScaling) {
      defines.setValue("NONUNIFORMSCALING", true);
    }
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.complementZ = this.complementZ;
    serializationObject.complementW = this.complementW;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.complementZ = serializationObject.complementZ !== void 0 ? serializationObject.complementZ : 0;
    this.complementW = serializationObject.complementW !== void 0 ? serializationObject.complementW : 1;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.complementZ = ${this.complementZ};\r
`;
    codeString += `${this._codeVariableName}.complementW = ${this.complementW};\r
`;
    return codeString;
  }
};
RegisterClass("BABYLON.TransformBlock", TransformBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/vertexOutputBlock.js
var VertexOutputBlock = class extends NodeMaterialBlock {
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Vertex, true);
    this.registerInput("vector", NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  getClassName() {
    return "VertexOutputBlock";
  }
  get vector() {
    return this._inputs[0];
  }
  _isLogarithmicDepthEnabled(nodeList) {
    for (const node of nodeList) {
      if (node.useLogarithmicDepth) {
        return true;
      }
    }
    return false;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const input = this.vector;
    state.compilationString += `gl_Position = ${input.associatedVariableName};\r
`;
    if (this._isLogarithmicDepthEnabled(state.sharedData.fragmentOutputNodes)) {
      state._emitUniformFromString("logarithmicDepthConstant", "float");
      state._emitVaryingFromString("vFragmentDepth", "float");
      state.compilationString += `vFragmentDepth = 1.0 + gl_Position.w;\r
`;
      state.compilationString += `gl_Position.z = log2(max(0.000001, vFragmentDepth)) * logarithmicDepthConstant;\r
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.VertexOutputBlock", VertexOutputBlock);

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialDecorator.js
var PropertyTypeForEdition;
(function(PropertyTypeForEdition2) {
  PropertyTypeForEdition2[PropertyTypeForEdition2["Boolean"] = 0] = "Boolean";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Float"] = 1] = "Float";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Int"] = 2] = "Int";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Vector2"] = 3] = "Vector2";
  PropertyTypeForEdition2[PropertyTypeForEdition2["List"] = 4] = "List";
})(PropertyTypeForEdition || (PropertyTypeForEdition = {}));
function editableInPropertyPage(displayName, propertyType = PropertyTypeForEdition.Boolean, groupName = "PROPERTIES", options) {
  return (target, propertyKey) => {
    let propStore = target._propStore;
    if (!propStore) {
      propStore = [];
      target._propStore = propStore;
    }
    propStore.push({
      propertyName: propertyKey,
      displayName,
      type: propertyType,
      groupName,
      options: options !== null && options !== void 0 ? options : {}
    });
  };
}

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/fragmentOutputBlock.js
var FragmentOutputBlock = class extends NodeMaterialBlock {
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Fragment, true);
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this.useLogarithmicDepth = false;
    this.registerInput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, true);
    this.registerInput("rgb", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerInput("a", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.rgb.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Float);
  }
  getClassName() {
    return "FragmentOutputBlock";
  }
  initialize(state) {
    state._excludeVariableName("logarithmicDepthConstant");
    state._excludeVariableName("vFragmentDepth");
  }
  get rgba() {
    return this._inputs[0];
  }
  get rgb() {
    return this._inputs[1];
  }
  get a() {
    return this._inputs[2];
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);
    defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);
  }
  bind(effect, nodeMaterial, mesh) {
    if (this.useLogarithmicDepth && mesh) {
      MaterialHelper.BindLogDepth(void 0, effect, mesh.getScene());
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const rgba = this.rgba;
    const rgb = this.rgb;
    const a = this.a;
    state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;
    state.sharedData.blocksWithDefines.push(this);
    if (this.useLogarithmicDepth) {
      state._emitUniformFromString("logarithmicDepthConstant", "float");
      state._emitVaryingFromString("vFragmentDepth", "float");
      state.sharedData.bindableBlocks.push(this);
    }
    this._linearDefineName = state._getFreeDefineName("CONVERTTOLINEAR");
    this._gammaDefineName = state._getFreeDefineName("CONVERTTOGAMMA");
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    if (rgba.connectedPoint) {
      if (a.isConnected) {
        state.compilationString += `gl_FragColor = vec4(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});\r
`;
      } else {
        state.compilationString += `gl_FragColor = ${rgba.associatedVariableName};\r
`;
      }
    } else if (rgb.connectedPoint) {
      let aValue = "1.0";
      if (a.connectedPoint) {
        aValue = a.associatedVariableName;
      }
      if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {
        state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});\r
`;
      } else {
        state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${aValue});\r
`;
      }
    } else {
      state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);
    }
    state.compilationString += `#ifdef ${this._linearDefineName}\r
`;
    state.compilationString += `gl_FragColor = toLinearSpace(gl_FragColor);\r
`;
    state.compilationString += `#endif\r
`;
    state.compilationString += `#ifdef ${this._gammaDefineName}\r
`;
    state.compilationString += `gl_FragColor = toGammaSpace(gl_FragColor);\r
`;
    state.compilationString += `#endif\r
`;
    if (this.useLogarithmicDepth) {
      state.compilationString += `gl_FragDepthEXT = log2(vFragmentDepth) * logarithmicDepthConstant * 0.5;\r
`;
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\r
`;
    codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\r
`;
    codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    var _a;
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = serializationObject.convertToLinearSpace;
    this.useLogarithmicDepth = (_a = serializationObject.useLogarithmicDepth) !== null && _a !== void 0 ? _a : false;
  }
};
__decorate([
  editableInPropertyPage("Convert to gamma space", PropertyTypeForEdition.Boolean, "PROPERTIES", { notifiers: { update: true } })
], FragmentOutputBlock.prototype, "convertToGammaSpace", void 0);
__decorate([
  editableInPropertyPage("Convert to linear space", PropertyTypeForEdition.Boolean, "PROPERTIES", { notifiers: { update: true } })
], FragmentOutputBlock.prototype, "convertToLinearSpace", void 0);
__decorate([
  editableInPropertyPage("Use logarithmic depth", PropertyTypeForEdition.Boolean, "PROPERTIES")
], FragmentOutputBlock.prototype, "useLogarithmicDepth", void 0);
RegisterClass("BABYLON.FragmentOutputBlock", FragmentOutputBlock);

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockConnectionPointMode.js
var NodeMaterialBlockConnectionPointMode;
(function(NodeMaterialBlockConnectionPointMode2) {
  NodeMaterialBlockConnectionPointMode2[NodeMaterialBlockConnectionPointMode2["Uniform"] = 0] = "Uniform";
  NodeMaterialBlockConnectionPointMode2[NodeMaterialBlockConnectionPointMode2["Attribute"] = 1] = "Attribute";
  NodeMaterialBlockConnectionPointMode2[NodeMaterialBlockConnectionPointMode2["Varying"] = 2] = "Varying";
  NodeMaterialBlockConnectionPointMode2[NodeMaterialBlockConnectionPointMode2["Undefined"] = 3] = "Undefined";
})(NodeMaterialBlockConnectionPointMode || (NodeMaterialBlockConnectionPointMode = {}));

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialSystemValues.js
var NodeMaterialSystemValues;
(function(NodeMaterialSystemValues2) {
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["World"] = 1] = "World";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["View"] = 2] = "View";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["Projection"] = 3] = "Projection";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["ViewProjection"] = 4] = "ViewProjection";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["WorldView"] = 5] = "WorldView";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["WorldViewProjection"] = 6] = "WorldViewProjection";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["CameraPosition"] = 7] = "CameraPosition";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["FogColor"] = 8] = "FogColor";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["DeltaTime"] = 9] = "DeltaTime";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["CameraParameters"] = 10] = "CameraParameters";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["MaterialAlpha"] = 11] = "MaterialAlpha";
})(NodeMaterialSystemValues || (NodeMaterialSystemValues = {}));

// node_modules/@babylonjs/core/Materials/Node/Blocks/Input/animatedInputBlockTypes.js
var AnimatedInputBlockTypes;
(function(AnimatedInputBlockTypes2) {
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["None"] = 0] = "None";
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["Time"] = 1] = "Time";
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["RealTime"] = 2] = "RealTime";
})(AnimatedInputBlockTypes || (AnimatedInputBlockTypes = {}));

// node_modules/@babylonjs/core/Materials/Node/Blocks/Input/inputBlock.js
var remapAttributeName = {
  position2d: "position",
  particle_uv: "vUV",
  particle_color: "vColor",
  particle_texturemask: "textureMask",
  particle_positionw: "vPositionW"
};
var attributeInFragmentOnly = {
  particle_uv: true,
  particle_color: true,
  particle_texturemask: true,
  particle_positionw: true
};
var attributeAsUniform = {
  particle_texturemask: true
};
var InputBlock = class extends NodeMaterialBlock {
  constructor(name4, target = NodeMaterialBlockTargets.Vertex, type = NodeMaterialBlockConnectionPointTypes.AutoDetect) {
    super(name4, target, false, true);
    this._mode = NodeMaterialBlockConnectionPointMode.Undefined;
    this._animationType = AnimatedInputBlockTypes.None;
    this.min = 0;
    this.max = 0;
    this.isBoolean = false;
    this.matrixMode = 0;
    this._systemValue = null;
    this.isConstant = false;
    this.groupInInspector = "";
    this.onValueChangedObservable = new Observable();
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this._type = type;
    this.setDefaultValue();
    this.registerOutput("output", type);
  }
  get type() {
    if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
      if (this.isUniform && this.value != null) {
        if (!isNaN(this.value)) {
          this._type = NodeMaterialBlockConnectionPointTypes.Float;
          return this._type;
        }
        switch (this.value.getClassName()) {
          case "Vector2":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector2;
            return this._type;
          case "Vector3":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
            return this._type;
          case "Vector4":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
            return this._type;
          case "Color3":
            this._type = NodeMaterialBlockConnectionPointTypes.Color3;
            return this._type;
          case "Color4":
            this._type = NodeMaterialBlockConnectionPointTypes.Color4;
            return this._type;
          case "Matrix":
            this._type = NodeMaterialBlockConnectionPointTypes.Matrix;
            return this._type;
        }
      }
      if (this.isAttribute) {
        switch (this.name) {
          case "position":
          case "normal":
          case "particle_positionw":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
            return this._type;
          case "uv":
          case "uv2":
          case "uv3":
          case "uv4":
          case "uv5":
          case "uv6":
          case "position2d":
          case "particle_uv":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector2;
            return this._type;
          case "matricesIndices":
          case "matricesWeights":
          case "world0":
          case "world1":
          case "world2":
          case "world3":
          case "tangent":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
            return this._type;
          case "color":
          case "instanceColor":
          case "particle_color":
          case "particle_texturemask":
            this._type = NodeMaterialBlockConnectionPointTypes.Color4;
            return this._type;
        }
      }
      if (this.isSystemValue) {
        switch (this._systemValue) {
          case NodeMaterialSystemValues.World:
          case NodeMaterialSystemValues.WorldView:
          case NodeMaterialSystemValues.WorldViewProjection:
          case NodeMaterialSystemValues.View:
          case NodeMaterialSystemValues.ViewProjection:
          case NodeMaterialSystemValues.Projection:
            this._type = NodeMaterialBlockConnectionPointTypes.Matrix;
            return this._type;
          case NodeMaterialSystemValues.CameraPosition:
            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
            return this._type;
          case NodeMaterialSystemValues.FogColor:
            this._type = NodeMaterialBlockConnectionPointTypes.Color3;
            return this._type;
          case NodeMaterialSystemValues.DeltaTime:
          case NodeMaterialSystemValues.MaterialAlpha:
            this._type = NodeMaterialBlockConnectionPointTypes.Float;
            return this._type;
          case NodeMaterialSystemValues.CameraParameters:
            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
            return this._type;
        }
      }
    }
    return this._type;
  }
  validateBlockName(newName) {
    if (!this.isAttribute) {
      return super.validateBlockName(newName);
    }
    return true;
  }
  get output() {
    return this._outputs[0];
  }
  setAsAttribute(attributeName) {
    this._mode = NodeMaterialBlockConnectionPointMode.Attribute;
    if (attributeName) {
      this.name = attributeName;
    }
    return this;
  }
  setAsSystemValue(value) {
    this.systemValue = value;
    return this;
  }
  get value() {
    return this._storedValue;
  }
  set value(value) {
    if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
      if (this.isBoolean) {
        value = value ? 1 : 0;
      } else if (this.min !== this.max) {
        value = Math.max(this.min, value);
        value = Math.min(this.max, value);
      }
    }
    this._storedValue = value;
    this._mode = NodeMaterialBlockConnectionPointMode.Uniform;
    this.onValueChangedObservable.notifyObservers(this);
  }
  get valueCallback() {
    return this._valueCallback;
  }
  set valueCallback(value) {
    this._valueCallback = value;
    this._mode = NodeMaterialBlockConnectionPointMode.Uniform;
  }
  get associatedVariableName() {
    return this._associatedVariableName;
  }
  set associatedVariableName(value) {
    this._associatedVariableName = value;
  }
  get animationType() {
    return this._animationType;
  }
  set animationType(value) {
    this._animationType = value;
  }
  get isUndefined() {
    return this._mode === NodeMaterialBlockConnectionPointMode.Undefined;
  }
  get isUniform() {
    return this._mode === NodeMaterialBlockConnectionPointMode.Uniform;
  }
  set isUniform(value) {
    this._mode = value ? NodeMaterialBlockConnectionPointMode.Uniform : NodeMaterialBlockConnectionPointMode.Undefined;
    this.associatedVariableName = "";
  }
  get isAttribute() {
    return this._mode === NodeMaterialBlockConnectionPointMode.Attribute;
  }
  set isAttribute(value) {
    this._mode = value ? NodeMaterialBlockConnectionPointMode.Attribute : NodeMaterialBlockConnectionPointMode.Undefined;
    this.associatedVariableName = "";
  }
  get isVarying() {
    return this._mode === NodeMaterialBlockConnectionPointMode.Varying;
  }
  set isVarying(value) {
    this._mode = value ? NodeMaterialBlockConnectionPointMode.Varying : NodeMaterialBlockConnectionPointMode.Undefined;
    this.associatedVariableName = "";
  }
  get isSystemValue() {
    return this._systemValue != null;
  }
  get systemValue() {
    return this._systemValue;
  }
  set systemValue(value) {
    this._mode = NodeMaterialBlockConnectionPointMode.Uniform;
    this.associatedVariableName = "";
    this._systemValue = value;
  }
  getClassName() {
    return "InputBlock";
  }
  animate(scene) {
    switch (this._animationType) {
      case AnimatedInputBlockTypes.Time: {
        if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
          this.value += scene.getAnimationRatio() * 0.01;
        }
        break;
      }
      case AnimatedInputBlockTypes.RealTime: {
        if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
          this.value = (PrecisionDate.Now - scene.getEngine().startTime) / 1e3;
        }
        break;
      }
    }
  }
  _emitDefine(define) {
    if (define[0] === "!") {
      return `#ifndef ${define.substring(1)}\r
`;
    }
    return `#ifdef ${define}\r
`;
  }
  initialize() {
    this.associatedVariableName = "";
  }
  setDefaultValue() {
    switch (this.type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        this.value = 0;
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        this.value = Vector2.Zero();
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        this.value = Vector3.Zero();
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        this.value = Vector4.Zero();
        break;
      case NodeMaterialBlockConnectionPointTypes.Color3:
        this.value = Color3.White();
        break;
      case NodeMaterialBlockConnectionPointTypes.Color4:
        this.value = new Color4(1, 1, 1, 1);
        break;
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        this.value = Matrix.Identity();
        break;
    }
  }
  _emitConstant(state) {
    switch (this.type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        return `${state._emitFloat(this.value)}`;
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        return `vec2(${this.value.x}, ${this.value.y})`;
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        return `vec3(${this.value.x}, ${this.value.y}, ${this.value.z})`;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        return `vec4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;
      case NodeMaterialBlockConnectionPointTypes.Color3:
        TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);
        if (this.convertToGammaSpace) {
          TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0]);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0]);
        }
        return `vec3(${TmpColors.Color3[0].r}, ${TmpColors.Color3[0].g}, ${TmpColors.Color3[0].b})`;
      case NodeMaterialBlockConnectionPointTypes.Color4:
        TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);
        if (this.convertToGammaSpace) {
          TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0]);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0]);
        }
        return `vec4(${TmpColors.Color4[0].r}, ${TmpColors.Color4[0].g}, ${TmpColors.Color4[0].b}, ${TmpColors.Color4[0].a})`;
    }
    return "";
  }
  get _noContextSwitch() {
    return attributeInFragmentOnly[this.name];
  }
  _emit(state, define) {
    var _a;
    if (this.isUniform) {
      if (!this.associatedVariableName) {
        this.associatedVariableName = state._getFreeVariableName("u_" + this.name);
      }
      if (this.isConstant) {
        if (state.constants.indexOf(this.associatedVariableName) !== -1) {
          return;
        }
        state.constants.push(this.associatedVariableName);
        state._constantDeclaration += this._declareOutput(this.output, state) + ` = ${this._emitConstant(state)};\r
`;
        return;
      }
      if (state.uniforms.indexOf(this.associatedVariableName) !== -1) {
        return;
      }
      state.uniforms.push(this.associatedVariableName);
      if (define) {
        state._uniformDeclaration += this._emitDefine(define);
      }
      state._uniformDeclaration += `uniform ${state._getGLType(this.type)} ${this.associatedVariableName};\r
`;
      if (define) {
        state._uniformDeclaration += `#endif\r
`;
      }
      const hints = state.sharedData.hints;
      if (this._systemValue !== null && this._systemValue !== void 0) {
        switch (this._systemValue) {
          case NodeMaterialSystemValues.WorldView:
            hints.needWorldViewMatrix = true;
            break;
          case NodeMaterialSystemValues.WorldViewProjection:
            hints.needWorldViewProjectionMatrix = true;
            break;
        }
      } else {
        if (this._animationType !== AnimatedInputBlockTypes.None) {
          state.sharedData.animatedInputs.push(this);
        }
      }
      return;
    }
    if (this.isAttribute) {
      this.associatedVariableName = (_a = remapAttributeName[this.name]) !== null && _a !== void 0 ? _a : this.name;
      if (this.target === NodeMaterialBlockTargets.Vertex && state._vertexState) {
        if (attributeInFragmentOnly[this.name]) {
          if (attributeAsUniform[this.name]) {
            state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);
          } else {
            state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);
          }
        } else {
          this._emit(state._vertexState, define);
        }
        return;
      }
      if (state.attributes.indexOf(this.associatedVariableName) !== -1) {
        return;
      }
      state.attributes.push(this.associatedVariableName);
      if (attributeInFragmentOnly[this.name]) {
        if (attributeAsUniform[this.name]) {
          state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);
        } else {
          state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);
        }
      } else {
        if (define) {
          state._attributeDeclaration += this._emitDefine(define);
        }
        state._attributeDeclaration += `attribute ${state._getGLType(this.type)} ${this.associatedVariableName};\r
`;
        if (define) {
          state._attributeDeclaration += `#endif\r
`;
        }
      }
    }
  }
  _transmitWorld(effect, world, worldView, worldViewProjection) {
    if (!this._systemValue) {
      return;
    }
    const variableName = this.associatedVariableName;
    switch (this._systemValue) {
      case NodeMaterialSystemValues.World:
        effect.setMatrix(variableName, world);
        break;
      case NodeMaterialSystemValues.WorldView:
        effect.setMatrix(variableName, worldView);
        break;
      case NodeMaterialSystemValues.WorldViewProjection:
        effect.setMatrix(variableName, worldViewProjection);
        break;
    }
  }
  _transmit(effect, scene, material) {
    if (this.isAttribute) {
      return;
    }
    const variableName = this.associatedVariableName;
    if (this._systemValue) {
      switch (this._systemValue) {
        case NodeMaterialSystemValues.World:
        case NodeMaterialSystemValues.WorldView:
        case NodeMaterialSystemValues.WorldViewProjection:
          return;
        case NodeMaterialSystemValues.View:
          effect.setMatrix(variableName, scene.getViewMatrix());
          break;
        case NodeMaterialSystemValues.Projection:
          effect.setMatrix(variableName, scene.getProjectionMatrix());
          break;
        case NodeMaterialSystemValues.ViewProjection:
          effect.setMatrix(variableName, scene.getTransformMatrix());
          break;
        case NodeMaterialSystemValues.CameraPosition:
          scene.bindEyePosition(effect, variableName, true);
          break;
        case NodeMaterialSystemValues.FogColor:
          effect.setColor3(variableName, scene.fogColor);
          break;
        case NodeMaterialSystemValues.DeltaTime:
          effect.setFloat(variableName, scene.deltaTime / 1e3);
          break;
        case NodeMaterialSystemValues.CameraParameters:
          if (scene.activeCamera) {
            effect.setFloat4(variableName, scene.getEngine().hasOriginBottomLeft ? -1 : 1, scene.activeCamera.minZ, scene.activeCamera.maxZ, 1 / scene.activeCamera.maxZ);
          }
          break;
        case NodeMaterialSystemValues.MaterialAlpha:
          effect.setFloat(variableName, material.alpha);
          break;
      }
      return;
    }
    const value = this._valueCallback ? this._valueCallback() : this._storedValue;
    if (value === null) {
      return;
    }
    switch (this.type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        effect.setFloat(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Int:
        effect.setInt(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Color3:
        TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);
        if (this.convertToGammaSpace) {
          TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0]);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0]);
        }
        effect.setColor3(variableName, TmpColors.Color3[0]);
        break;
      case NodeMaterialBlockConnectionPointTypes.Color4:
        TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);
        if (this.convertToGammaSpace) {
          TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0]);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0]);
        }
        effect.setDirectColor4(variableName, TmpColors.Color4[0]);
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        effect.setVector2(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        effect.setVector3(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        effect.setVector4(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        effect.setMatrix(variableName, value);
        break;
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (this.isUniform || this.isSystemValue) {
      state.sharedData.inputBlocks.push(this);
    }
    this._emit(state);
  }
  _dumpPropertiesCode() {
    const variableName = this._codeVariableName;
    if (this.isAttribute) {
      return super._dumpPropertiesCode() + `${variableName}.setAsAttribute("${this.name}");\r
`;
    }
    if (this.isSystemValue) {
      return super._dumpPropertiesCode() + `${variableName}.setAsSystemValue(BABYLON.NodeMaterialSystemValues.${NodeMaterialSystemValues[this._systemValue]});\r
`;
    }
    if (this.isUniform) {
      const codes = [];
      let valueString = "";
      switch (this.type) {
        case NodeMaterialBlockConnectionPointTypes.Float:
          valueString = `${this.value}`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Vector2:
          valueString = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Vector3:
          valueString = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Vector4:
          valueString = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Color3:
          valueString = `new BABYLON.Color3(${this.value.r}, ${this.value.g}, ${this.value.b})`;
          if (this.convertToGammaSpace) {
            valueString += ".toGammaSpace()";
          }
          if (this.convertToLinearSpace) {
            valueString += ".toLinearSpace()";
          }
          break;
        case NodeMaterialBlockConnectionPointTypes.Color4:
          valueString = `new BABYLON.Color4(${this.value.r}, ${this.value.g}, ${this.value.b}, ${this.value.a})`;
          if (this.convertToGammaSpace) {
            valueString += ".toGammaSpace()";
          }
          if (this.convertToLinearSpace) {
            valueString += ".toLinearSpace()";
          }
          break;
        case NodeMaterialBlockConnectionPointTypes.Matrix:
          valueString = `BABYLON.Matrix.FromArray([${this.value.m}])`;
          break;
      }
      codes.push(`${variableName}.value = ${valueString}`);
      if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
        codes.push(`${variableName}.min = ${this.min}`, `${variableName}.max = ${this.max}`, `${variableName}.isBoolean = ${this.isBoolean}`, `${variableName}.matrixMode = ${this.matrixMode}`, `${variableName}.animationType = BABYLON.AnimatedInputBlockTypes.${AnimatedInputBlockTypes[this.animationType]}`);
      }
      codes.push(`${variableName}.isConstant = ${this.isConstant}`);
      codes.push("");
      return super._dumpPropertiesCode() + codes.join(";\r\n");
    }
    return super._dumpPropertiesCode();
  }
  dispose() {
    this.onValueChangedObservable.clear();
    super.dispose();
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.type = this.type;
    serializationObject.mode = this._mode;
    serializationObject.systemValue = this._systemValue;
    serializationObject.animationType = this._animationType;
    serializationObject.min = this.min;
    serializationObject.max = this.max;
    serializationObject.isBoolean = this.isBoolean;
    serializationObject.matrixMode = this.matrixMode;
    serializationObject.isConstant = this.isConstant;
    serializationObject.groupInInspector = this.groupInInspector;
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    if (this._storedValue != null && this._mode === NodeMaterialBlockConnectionPointMode.Uniform) {
      if (this._storedValue.asArray) {
        serializationObject.valueType = "BABYLON." + this._storedValue.getClassName();
        serializationObject.value = this._storedValue.asArray();
      } else {
        serializationObject.valueType = "number";
        serializationObject.value = this._storedValue;
      }
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    this._mode = serializationObject.mode;
    super._deserialize(serializationObject, scene, rootUrl);
    this._type = serializationObject.type;
    this._systemValue = serializationObject.systemValue || serializationObject.wellKnownValue;
    this._animationType = serializationObject.animationType;
    this.min = serializationObject.min || 0;
    this.max = serializationObject.max || 0;
    this.isBoolean = !!serializationObject.isBoolean;
    this.matrixMode = serializationObject.matrixMode || 0;
    this.isConstant = !!serializationObject.isConstant;
    this.groupInInspector = serializationObject.groupInInspector || "";
    this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    if (serializationObject.name === "tangent" && serializationObject.mode === NodeMaterialBlockConnectionPointMode.Attribute && serializationObject.type === NodeMaterialBlockConnectionPointTypes.Vector3) {
      this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
    }
    if (!serializationObject.valueType) {
      return;
    }
    if (serializationObject.valueType === "number") {
      this._storedValue = serializationObject.value;
    } else {
      const valueType = GetClass(serializationObject.valueType);
      if (valueType) {
        this._storedValue = valueType.FromArray(serializationObject.value);
      }
    }
  }
};
RegisterClass("BABYLON.InputBlock", InputBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/currentScreenBlock.js
var CurrentScreenBlock = class extends NodeMaterialBlock {
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.VertexAndFragment);
    this._samplerName = "textureSampler";
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this._isUnique = false;
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this._inputs[0]._prioritizeVertex = false;
  }
  getClassName() {
    return "CurrentScreenBlock";
  }
  get uv() {
    return this._inputs[0];
  }
  get rgba() {
    return this._outputs[0];
  }
  get rgb() {
    return this._outputs[1];
  }
  get r() {
    return this._outputs[2];
  }
  get g() {
    return this._outputs[3];
  }
  get b() {
    return this._outputs[4];
  }
  get a() {
    return this._outputs[5];
  }
  initialize(state) {
    state._excludeVariableName("textureSampler");
  }
  get target() {
    if (!this.uv.isConnected) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    if (this.uv.sourceBlock.isInput) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    return NodeMaterialBlockTargets.Fragment;
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);
    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);
  }
  isReady() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  _injectVertexCode(state) {
    const uvInput = this.uv;
    if (uvInput.connectedPoint.ownerBlock.isInput) {
      const uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;
      if (!uvInputOwnerBlock.isAttribute) {
        state._emitUniformFromString(uvInput.associatedVariableName, "vec2");
      }
    }
    this._mainUVName = "vMain" + uvInput.associatedVariableName;
    state._emitVaryingFromString(this._mainUVName, "vec2");
    state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\r
`;
    if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {
      return;
    }
    this._writeTextureRead(state, true);
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name, true);
      }
    }
  }
  _writeTextureRead(state, vertexMode = false) {
    const uvInput = this.uv;
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\r
`;
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\r
`;
      return;
    }
    state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._mainUVName});\r
`;
  }
  _writeOutput(state, output, swizzle, vertexMode = false) {
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\r
`;
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\r
`;
      return;
    }
    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\r
`;
    state.compilationString += `#ifdef ${this._linearDefineName}\r
`;
    state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\r
`;
    state.compilationString += `#endif\r
`;
    state.compilationString += `#ifdef ${this._gammaDefineName}\r
`;
    state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\r
`;
    state.compilationString += `#endif\r
`;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
    if (state.sharedData.blockingBlocks.indexOf(this) < 0) {
      state.sharedData.blockingBlocks.push(this);
    }
    if (state.sharedData.textureBlocks.indexOf(this) < 0) {
      state.sharedData.textureBlocks.push(this);
    }
    if (state.sharedData.blocksWithDefines.indexOf(this) < 0) {
      state.sharedData.blocksWithDefines.push(this);
    }
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      state._emit2DSampler(this._samplerName);
      this._injectVertexCode(state);
      return;
    }
    if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {
      return;
    }
    state._emit2DSampler(this._samplerName);
    this._linearDefineName = state._getFreeDefineName("ISLINEAR");
    this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    this._writeTextureRead(state);
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name);
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    if (this.texture && !this.texture.isRenderTarget) {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    if (serializationObject.texture) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
    }
  }
};
RegisterClass("BABYLON.CurrentScreenBlock", CurrentScreenBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleTextureBlock.js
var ParticleTextureBlock = class extends NodeMaterialBlock {
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Fragment);
    this._samplerName = "diffuseSampler";
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this._isUnique = false;
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  getClassName() {
    return "ParticleTextureBlock";
  }
  get uv() {
    return this._inputs[0];
  }
  get rgba() {
    return this._outputs[0];
  }
  get rgb() {
    return this._outputs[1];
  }
  get r() {
    return this._outputs[2];
  }
  get g() {
    return this._outputs[3];
  }
  get b() {
    return this._outputs[4];
  }
  get a() {
    return this._outputs[5];
  }
  initialize(state) {
    state._excludeVariableName("diffuseSampler");
  }
  autoConfigure(material) {
    if (!this.uv.isConnected) {
      let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "particle_uv");
      if (!uvInput) {
        uvInput = new InputBlock("uv");
        uvInput.setAsAttribute("particle_uv");
      }
      uvInput.output.connectTo(this.uv);
    }
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);
    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);
  }
  isReady() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  _writeOutput(state, output, swizzle) {
    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\r
`;
    state.compilationString += `#ifdef ${this._linearDefineName}\r
`;
    state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\r
`;
    state.compilationString += `#endif\r
`;
    state.compilationString += `#ifdef ${this._gammaDefineName}\r
`;
    state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\r
`;
    state.compilationString += `#endif\r
`;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
    state._emit2DSampler(this._samplerName);
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.textureBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    this._linearDefineName = state._getFreeDefineName("ISLINEAR");
    this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this.uv.associatedVariableName});\r
`;
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name);
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    if (this.texture && !this.texture.isRenderTarget) {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    if (serializationObject.texture) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
    }
  }
};
RegisterClass("BABYLON.ParticleTextureBlock", ParticleTextureBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleRampGradientBlock.js
var ParticleRampGradientBlock = class extends NodeMaterialBlock {
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Fragment);
    this._isUnique = true;
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("rampColor", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
  }
  getClassName() {
    return "ParticleRampGradientBlock";
  }
  get color() {
    return this._inputs[0];
  }
  get rampColor() {
    return this._outputs[0];
  }
  initialize(state) {
    state._excludeVariableName("remapRanges");
    state._excludeVariableName("rampSampler");
    state._excludeVariableName("baseColor");
    state._excludeVariableName("alpha");
    state._excludeVariableName("remappedColorIndex");
    state._excludeVariableName("rampColor");
    state._excludeVariableName("finalAlpha");
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    state._emit2DSampler("rampSampler");
    state._emitVaryingFromString("remapRanges", "vec4", "RAMPGRADIENT");
    state.compilationString += `
            #ifdef RAMPGRADIENT
                vec4 baseColor = ${this.color.associatedVariableName};
                float alpha = ${this.color.associatedVariableName}.a;

                float remappedColorIndex = clamp((alpha - remapRanges.x) / remapRanges.y, 0.0, 1.0);

                vec4 rampColor = texture2D(rampSampler, vec2(1.0 - remappedColorIndex, 0.));
                baseColor.rgb *= rampColor.rgb;

                // Remapped alpha
                float finalAlpha = baseColor.a;
                baseColor.a = clamp((alpha * rampColor.a - remapRanges.z) / remapRanges.w, 0.0, 1.0);

                ${this._declareOutput(this.rampColor, state)} = baseColor;
            #else
                ${this._declareOutput(this.rampColor, state)} = ${this.color.associatedVariableName};
            #endif
        `;
    return this;
  }
};
RegisterClass("BABYLON.ParticleRampGradientBlock", ParticleRampGradientBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleBlendMultiplyBlock.js
var ParticleBlendMultiplyBlock = class extends NodeMaterialBlock {
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Fragment);
    this._isUnique = true;
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("alphaTexture", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("alphaColor", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("blendColor", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
  }
  getClassName() {
    return "ParticleBlendMultiplyBlock";
  }
  get color() {
    return this._inputs[0];
  }
  get alphaTexture() {
    return this._inputs[1];
  }
  get alphaColor() {
    return this._inputs[2];
  }
  get blendColor() {
    return this._outputs[0];
  }
  initialize(state) {
    state._excludeVariableName("sourceAlpha");
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    state.compilationString += `
            #ifdef BLENDMULTIPLYMODE
                ${this._declareOutput(this.blendColor, state)};
                float sourceAlpha = ${this.alphaColor.associatedVariableName} * ${this.alphaTexture.associatedVariableName};
                ${this.blendColor.associatedVariableName}.rgb = ${this.color.associatedVariableName}.rgb * sourceAlpha + vec3(1.0) * (1.0 - sourceAlpha);
                ${this.blendColor.associatedVariableName}.a = ${this.color.associatedVariableName}.a;
            #else
                ${this._declareOutput(this.blendColor, state)} = ${this.color.associatedVariableName};
            #endif
        `;
    return this;
  }
};
RegisterClass("BABYLON.ParticleBlendMultiplyBlock", ParticleBlendMultiplyBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/vectorMergerBlock.js
var VectorMergerBlock = class extends NodeMaterialBlock {
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Neutral);
    this.xSwizzle = "x";
    this.ySwizzle = "y";
    this.zSwizzle = "z";
    this.wSwizzle = "w";
    this.registerInput("xyzw ", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("xyz ", NodeMaterialBlockConnectionPointTypes.Vector3, true);
    this.registerInput("xy ", NodeMaterialBlockConnectionPointTypes.Vector2, true);
    this.registerInput("zw ", NodeMaterialBlockConnectionPointTypes.Vector2, true);
    this.registerInput("x", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("y", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("z", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("w", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerOutput("xyzw", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("zw", NodeMaterialBlockConnectionPointTypes.Vector2);
  }
  getClassName() {
    return "VectorMergerBlock";
  }
  get xyzwIn() {
    return this._inputs[0];
  }
  get xyzIn() {
    return this._inputs[1];
  }
  get xyIn() {
    return this._inputs[2];
  }
  get zwIn() {
    return this._inputs[3];
  }
  get x() {
    return this._inputs[4];
  }
  get y() {
    return this._inputs[5];
  }
  get z() {
    return this._inputs[6];
  }
  get w() {
    return this._inputs[7];
  }
  get xyzw() {
    return this._outputs[0];
  }
  get xyzOut() {
    return this._outputs[1];
  }
  get xyOut() {
    return this._outputs[2];
  }
  get zwOut() {
    return this._outputs[3];
  }
  get xy() {
    return this.xyOut;
  }
  get xyz() {
    return this.xyzOut;
  }
  _inputRename(name4) {
    if (name4 === "xyzw ") {
      return "xyzwIn";
    }
    if (name4 === "xyz ") {
      return "xyzIn";
    }
    if (name4 === "xy ") {
      return "xyIn";
    }
    if (name4 === "zw ") {
      return "zwIn";
    }
    return name4;
  }
  _buildSwizzle(len) {
    const swizzle = this.xSwizzle + this.ySwizzle + this.zSwizzle + this.wSwizzle;
    return "." + swizzle.substr(0, len);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const xInput = this.x;
    const yInput = this.y;
    const zInput = this.z;
    const wInput = this.w;
    const xyInput = this.xyIn;
    const zwInput = this.zwIn;
    const xyzInput = this.xyzIn;
    const xyzwInput = this.xyzwIn;
    const v4Output = this._outputs[0];
    const v3Output = this._outputs[1];
    const v2Output = this._outputs[2];
    const v2CompOutput = this._outputs[3];
    if (xyzwInput.isConnected) {
      if (v4Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v4Output, state) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(4)};\r
`;
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v3Output, state) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(3)};\r
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v2Output, state) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(2)};\r
`;
      }
    } else if (xyzInput.isConnected) {
      if (v4Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v4Output, state) + ` = vec4(${xyzInput.associatedVariableName}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(4)};\r
`;
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v3Output, state) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(3)};\r
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v2Output, state) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(2)};\r
`;
      }
    } else if (xyInput.isConnected) {
      if (v4Output.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += this._declareOutput(v4Output, state) + ` = vec4(${xyInput.associatedVariableName}, ${zwInput.associatedVariableName})${this._buildSwizzle(4)};\r
`;
        } else {
          state.compilationString += this._declareOutput(v4Output, state) + ` = vec4(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(4)};\r
`;
        }
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v3Output, state) + ` = vec3(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"})${this._buildSwizzle(3)};\r
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v2Output, state) + ` = ${xyInput.associatedVariableName}${this._buildSwizzle(2)};\r
`;
      }
      if (v2CompOutput.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += this._declareOutput(v2CompOutput, state) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};\r
`;
        } else {
          state.compilationString += this._declareOutput(v2CompOutput, state) + ` = vec2(${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(2)};\r
`;
        }
      }
    } else {
      if (v4Output.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += this._declareOutput(v4Output, state) + ` = vec4(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"}, ${zwInput.associatedVariableName})${this._buildSwizzle(4)};\r
`;
        } else {
          state.compilationString += this._declareOutput(v4Output, state) + ` = vec4(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(4)};\r
`;
        }
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v3Output, state) + ` = vec3(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"})${this._buildSwizzle(3)};\r
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v2Output, state) + ` = vec2(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"})${this._buildSwizzle(2)};\r
`;
      }
      if (v2CompOutput.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += this._declareOutput(v2CompOutput, state) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};\r
`;
        } else {
          state.compilationString += this._declareOutput(v2CompOutput, state) + ` = vec2(${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(2)};\r
`;
        }
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.xSwizzle = this.xSwizzle;
    serializationObject.ySwizzle = this.ySwizzle;
    serializationObject.zSwizzle = this.zSwizzle;
    serializationObject.wSwizzle = this.wSwizzle;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    var _a, _b, _c, _d;
    super._deserialize(serializationObject, scene, rootUrl);
    this.xSwizzle = (_a = serializationObject.xSwizzle) !== null && _a !== void 0 ? _a : "x";
    this.ySwizzle = (_b = serializationObject.ySwizzle) !== null && _b !== void 0 ? _b : "y";
    this.zSwizzle = (_c = serializationObject.zSwizzle) !== null && _c !== void 0 ? _c : "z";
    this.wSwizzle = (_d = serializationObject.wSwizzle) !== null && _d !== void 0 ? _d : "w";
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.xSwizzle = "${this.xSwizzle}";\r
`;
    codeString += `${this._codeVariableName}.ySwizzle = "${this.ySwizzle}";\r
`;
    codeString += `${this._codeVariableName}.zSwizzle = "${this.zSwizzle}";\r
`;
    codeString += `${this._codeVariableName}.wSwizzle = "${this.wSwizzle}";\r
`;
    return codeString;
  }
};
RegisterClass("BABYLON.VectorMergerBlock", VectorMergerBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/remapBlock.js
var RemapBlock = class extends NodeMaterialBlock {
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Neutral);
    this.sourceRange = new Vector2(-1, 1);
    this.targetRange = new Vector2(0, 1);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("sourceMin", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("sourceMax", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("targetMin", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("targetMax", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  getClassName() {
    return "RemapBlock";
  }
  get input() {
    return this._inputs[0];
  }
  get sourceMin() {
    return this._inputs[1];
  }
  get sourceMax() {
    return this._inputs[2];
  }
  get targetMin() {
    return this._inputs[3];
  }
  get targetMax() {
    return this._inputs[4];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const sourceMin = this.sourceMin.isConnected ? this.sourceMin.associatedVariableName : this._writeFloat(this.sourceRange.x);
    const sourceMax = this.sourceMax.isConnected ? this.sourceMax.associatedVariableName : this._writeFloat(this.sourceRange.y);
    const targetMin = this.targetMin.isConnected ? this.targetMin.associatedVariableName : this._writeFloat(this.targetRange.x);
    const targetMax = this.targetMax.isConnected ? this.targetMax.associatedVariableName : this._writeFloat(this.targetRange.y);
    state.compilationString += this._declareOutput(output, state) + ` = ${targetMin} + (${this._inputs[0].associatedVariableName} - ${sourceMin}) * (${targetMax} - ${targetMin}) / (${sourceMax} - ${sourceMin});\r
`;
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.sourceRange = new BABYLON.Vector2(${this.sourceRange.x}, ${this.sourceRange.y});\r
`;
    codeString += `${this._codeVariableName}.targetRange = new BABYLON.Vector2(${this.targetRange.x}, ${this.targetRange.y});\r
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.sourceRange = this.sourceRange.asArray();
    serializationObject.targetRange = this.targetRange.asArray();
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.sourceRange = Vector2.FromArray(serializationObject.sourceRange);
    this.targetRange = Vector2.FromArray(serializationObject.targetRange);
  }
};
__decorate([
  editableInPropertyPage("From", PropertyTypeForEdition.Vector2)
], RemapBlock.prototype, "sourceRange", void 0);
__decorate([
  editableInPropertyPage("To", PropertyTypeForEdition.Vector2)
], RemapBlock.prototype, "targetRange", void 0);
RegisterClass("BABYLON.RemapBlock", RemapBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/multiplyBlock.js
var MultiplyBlock = class extends NodeMaterialBlock {
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
  }
  getClassName() {
    return "MultiplyBlock";
  }
  get left() {
    return this._inputs[0];
  }
  get right() {
    return this._inputs[1];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = ${this.left.associatedVariableName} * ${this.right.associatedVariableName};\r
`;
    return this;
  }
};
RegisterClass("BABYLON.MultiplyBlock", MultiplyBlock);

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialModes.js
var NodeMaterialModes;
(function(NodeMaterialModes2) {
  NodeMaterialModes2[NodeMaterialModes2["Material"] = 0] = "Material";
  NodeMaterialModes2[NodeMaterialModes2["PostProcess"] = 1] = "PostProcess";
  NodeMaterialModes2[NodeMaterialModes2["Particle"] = 2] = "Particle";
  NodeMaterialModes2[NodeMaterialModes2["ProceduralTexture"] = 3] = "ProceduralTexture";
})(NodeMaterialModes || (NodeMaterialModes = {}));

// node_modules/@babylonjs/core/Particles/EmitterTypes/boxParticleEmitter.js
var BoxParticleEmitter = class {
  constructor() {
    this.direction1 = new Vector3(0, 1, 0);
    this.direction2 = new Vector3(0, 1, 0);
    this.minEmitBox = new Vector3(-0.5, -0.5, -0.5);
    this.maxEmitBox = new Vector3(0.5, 0.5, 0.5);
  }
  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
    const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
    const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
    const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
    if (isLocal) {
      directionToUpdate.x = randX;
      directionToUpdate.y = randY;
      directionToUpdate.z = randZ;
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  }
  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
    const randX = Scalar.RandomRange(this.minEmitBox.x, this.maxEmitBox.x);
    const randY = Scalar.RandomRange(this.minEmitBox.y, this.maxEmitBox.y);
    const randZ = Scalar.RandomRange(this.minEmitBox.z, this.maxEmitBox.z);
    if (isLocal) {
      positionToUpdate.x = randX;
      positionToUpdate.y = randY;
      positionToUpdate.z = randZ;
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
  }
  clone() {
    const newOne = new BoxParticleEmitter();
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  applyToShader(uboOrEffect) {
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
    uboOrEffect.setVector3("minEmitBox", this.minEmitBox);
    uboOrEffect.setVector3("maxEmitBox", this.maxEmitBox);
  }
  buildUniformLayout(ubo) {
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
    ubo.addUniform("minEmitBox", 3);
    ubo.addUniform("maxEmitBox", 3);
  }
  getEffectDefines() {
    return "#define BOXEMITTER";
  }
  getClassName() {
    return "BoxParticleEmitter";
  }
  serialize() {
    const serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    serializationObject.minEmitBox = this.minEmitBox.asArray();
    serializationObject.maxEmitBox = this.maxEmitBox.asArray();
    return serializationObject;
  }
  parse(serializationObject) {
    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
    Vector3.FromArrayToRef(serializationObject.minEmitBox, 0, this.minEmitBox);
    Vector3.FromArrayToRef(serializationObject.maxEmitBox, 0, this.maxEmitBox);
  }
};

// node_modules/@babylonjs/core/Particles/EmitterTypes/coneParticleEmitter.js
var ConeParticleEmitter = class {
  constructor(radius = 1, angle = Math.PI, directionRandomizer = 0) {
    this.directionRandomizer = directionRandomizer;
    this.radiusRange = 1;
    this.heightRange = 1;
    this.emitFromSpawnPointOnly = false;
    this.angle = angle;
    this.radius = radius;
  }
  get radius() {
    return this._radius;
  }
  set radius(value) {
    this._radius = value;
    this._buildHeight();
  }
  get angle() {
    return this._angle;
  }
  set angle(value) {
    this._angle = value;
    this._buildHeight();
  }
  _buildHeight() {
    if (this._angle !== 0) {
      this._height = this._radius / Math.tan(this._angle / 2);
    } else {
      this._height = 1;
    }
  }
  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
    if (isLocal) {
      TmpVectors.Vector3[0].copyFrom(particle._localPosition).normalize();
    } else {
      particle.position.subtractToRef(worldMatrix.getTranslation(), TmpVectors.Vector3[0]).normalize();
    }
    const randX = Scalar.RandomRange(0, this.directionRandomizer);
    const randY = Scalar.RandomRange(0, this.directionRandomizer);
    const randZ = Scalar.RandomRange(0, this.directionRandomizer);
    directionToUpdate.x = TmpVectors.Vector3[0].x + randX;
    directionToUpdate.y = TmpVectors.Vector3[0].y + randY;
    directionToUpdate.z = TmpVectors.Vector3[0].z + randZ;
    directionToUpdate.normalize();
  }
  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
    const s = Scalar.RandomRange(0, Math.PI * 2);
    let h;
    if (!this.emitFromSpawnPointOnly) {
      h = Scalar.RandomRange(0, this.heightRange);
      h = 1 - h * h;
    } else {
      h = 1e-4;
    }
    let radius = this._radius - Scalar.RandomRange(0, this._radius * this.radiusRange);
    radius = radius * h;
    const randX = radius * Math.sin(s);
    const randZ = radius * Math.cos(s);
    const randY = h * this._height;
    if (isLocal) {
      positionToUpdate.x = randX;
      positionToUpdate.y = randY;
      positionToUpdate.z = randZ;
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
  }
  clone() {
    const newOne = new ConeParticleEmitter(this._radius, this._angle, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  applyToShader(uboOrEffect) {
    uboOrEffect.setFloat2("radius", this._radius, this.radiusRange);
    uboOrEffect.setFloat("coneAngle", this._angle);
    uboOrEffect.setFloat2("height", this._height, this.heightRange);
    uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
  }
  buildUniformLayout(ubo) {
    ubo.addUniform("radius", 2);
    ubo.addUniform("coneAngle", 1);
    ubo.addUniform("height", 2);
    ubo.addUniform("directionRandomizer", 1);
  }
  getEffectDefines() {
    let defines = "#define CONEEMITTER";
    if (this.emitFromSpawnPointOnly) {
      defines += "\n#define CONEEMITTERSPAWNPOINT";
    }
    return defines;
  }
  getClassName() {
    return "ConeParticleEmitter";
  }
  serialize() {
    const serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this._radius;
    serializationObject.angle = this._angle;
    serializationObject.directionRandomizer = this.directionRandomizer;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.heightRange = this.heightRange;
    serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;
    return serializationObject;
  }
  parse(serializationObject) {
    this.radius = serializationObject.radius;
    this.angle = serializationObject.angle;
    this.directionRandomizer = serializationObject.directionRandomizer;
    this.radiusRange = serializationObject.radiusRange !== void 0 ? serializationObject.radiusRange : 1;
    this.heightRange = serializationObject.radiusRange !== void 0 ? serializationObject.heightRange : 1;
    this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== void 0 ? serializationObject.emitFromSpawnPointOnly : false;
  }
};

// node_modules/@babylonjs/core/Particles/EmitterTypes/cylinderParticleEmitter.js
var CylinderParticleEmitter = class {
  constructor(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {
    this.radius = radius;
    this.height = height;
    this.radiusRange = radiusRange;
    this.directionRandomizer = directionRandomizer;
    this._tempVector = Vector3.Zero();
  }
  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal, inverseWorldMatrix) {
    particle.position.subtractToRef(worldMatrix.getTranslation(), this._tempVector);
    this._tempVector.normalize();
    Vector3.TransformNormalToRef(this._tempVector, inverseWorldMatrix, this._tempVector);
    const randY = Scalar.RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2);
    let angle = Math.atan2(this._tempVector.x, this._tempVector.z);
    angle += Scalar.RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer;
    this._tempVector.y = randY;
    this._tempVector.x = Math.sin(angle);
    this._tempVector.z = Math.cos(angle);
    this._tempVector.normalize();
    if (isLocal) {
      directionToUpdate.copyFrom(this._tempVector);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(this._tempVector.x, this._tempVector.y, this._tempVector.z, worldMatrix, directionToUpdate);
  }
  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
    const yPos = Scalar.RandomRange(-this.height / 2, this.height / 2);
    const angle = Scalar.RandomRange(0, 2 * Math.PI);
    const radiusDistribution = Scalar.RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1);
    const positionRadius = Math.sqrt(radiusDistribution) * this.radius;
    const xPos = positionRadius * Math.cos(angle);
    const zPos = positionRadius * Math.sin(angle);
    if (isLocal) {
      positionToUpdate.copyFromFloats(xPos, yPos, zPos);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, worldMatrix, positionToUpdate);
  }
  clone() {
    const newOne = new CylinderParticleEmitter(this.radius, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  applyToShader(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("height", this.height);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
  }
  buildUniformLayout(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("height", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("directionRandomizer", 1);
  }
  getEffectDefines() {
    return "#define CYLINDEREMITTER";
  }
  getClassName() {
    return "CylinderParticleEmitter";
  }
  serialize() {
    const serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this.radius;
    serializationObject.height = this.height;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.directionRandomizer = this.directionRandomizer;
    return serializationObject;
  }
  parse(serializationObject) {
    this.radius = serializationObject.radius;
    this.height = serializationObject.height;
    this.radiusRange = serializationObject.radiusRange;
    this.directionRandomizer = serializationObject.directionRandomizer;
  }
};
var CylinderDirectedParticleEmitter = class extends CylinderParticleEmitter {
  constructor(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    super(radius, height, radiusRange);
    this.direction1 = direction1;
    this.direction2 = direction2;
  }
  startDirectionFunction(worldMatrix, directionToUpdate) {
    const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
    const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
    const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  }
  clone() {
    const newOne = new CylinderDirectedParticleEmitter(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  applyToShader(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("height", this.height);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
  }
  buildUniformLayout(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("height", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
  }
  getEffectDefines() {
    return "#define CYLINDEREMITTER\n#define DIRECTEDCYLINDEREMITTER";
  }
  getClassName() {
    return "CylinderDirectedParticleEmitter";
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    return serializationObject;
  }
  parse(serializationObject) {
    super.parse(serializationObject);
    this.direction1.copyFrom(serializationObject.direction1);
    this.direction2.copyFrom(serializationObject.direction2);
  }
};

// node_modules/@babylonjs/core/Particles/EmitterTypes/hemisphericParticleEmitter.js
var HemisphericParticleEmitter = class {
  constructor(radius = 1, radiusRange = 1, directionRandomizer = 0) {
    this.radius = radius;
    this.radiusRange = radiusRange;
    this.directionRandomizer = directionRandomizer;
  }
  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
    const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
    const randX = Scalar.RandomRange(0, this.directionRandomizer);
    const randY = Scalar.RandomRange(0, this.directionRandomizer);
    const randZ = Scalar.RandomRange(0, this.directionRandomizer);
    direction.x += randX;
    direction.y += randY;
    direction.z += randZ;
    direction.normalize();
    if (isLocal) {
      directionToUpdate.copyFrom(direction);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
  }
  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
    const randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);
    const v = Scalar.RandomRange(0, 1);
    const phi = Scalar.RandomRange(0, 2 * Math.PI);
    const theta = Math.acos(2 * v - 1);
    const randX = randRadius * Math.cos(phi) * Math.sin(theta);
    const randY = randRadius * Math.cos(theta);
    const randZ = randRadius * Math.sin(phi) * Math.sin(theta);
    if (isLocal) {
      positionToUpdate.copyFromFloats(randX, Math.abs(randY), randZ);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, Math.abs(randY), randZ, worldMatrix, positionToUpdate);
  }
  clone() {
    const newOne = new HemisphericParticleEmitter(this.radius, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  applyToShader(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
  }
  buildUniformLayout(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("directionRandomizer", 1);
  }
  getEffectDefines() {
    return "#define HEMISPHERICEMITTER";
  }
  getClassName() {
    return "HemisphericParticleEmitter";
  }
  serialize() {
    const serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this.radius;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.directionRandomizer = this.directionRandomizer;
    return serializationObject;
  }
  parse(serializationObject) {
    this.radius = serializationObject.radius;
    this.radiusRange = serializationObject.radiusRange;
    this.directionRandomizer = serializationObject.directionRandomizer;
  }
};

// node_modules/@babylonjs/core/Particles/EmitterTypes/pointParticleEmitter.js
var PointParticleEmitter = class {
  constructor() {
    this.direction1 = new Vector3(0, 1, 0);
    this.direction2 = new Vector3(0, 1, 0);
  }
  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
    const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
    const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
    const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
    if (isLocal) {
      directionToUpdate.copyFromFloats(randX, randY, randZ);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  }
  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
    if (isLocal) {
      positionToUpdate.copyFromFloats(0, 0, 0);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, worldMatrix, positionToUpdate);
  }
  clone() {
    const newOne = new PointParticleEmitter();
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  applyToShader(uboOrEffect) {
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
  }
  buildUniformLayout(ubo) {
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
  }
  getEffectDefines() {
    return "#define POINTEMITTER";
  }
  getClassName() {
    return "PointParticleEmitter";
  }
  serialize() {
    const serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    return serializationObject;
  }
  parse(serializationObject) {
    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
  }
};

// node_modules/@babylonjs/core/Particles/EmitterTypes/sphereParticleEmitter.js
var SphereParticleEmitter = class {
  constructor(radius = 1, radiusRange = 1, directionRandomizer = 0) {
    this.radius = radius;
    this.radiusRange = radiusRange;
    this.directionRandomizer = directionRandomizer;
  }
  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
    const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
    const randX = Scalar.RandomRange(0, this.directionRandomizer);
    const randY = Scalar.RandomRange(0, this.directionRandomizer);
    const randZ = Scalar.RandomRange(0, this.directionRandomizer);
    direction.x += randX;
    direction.y += randY;
    direction.z += randZ;
    direction.normalize();
    if (isLocal) {
      directionToUpdate.copyFrom(direction);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
  }
  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
    const randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);
    const v = Scalar.RandomRange(0, 1);
    const phi = Scalar.RandomRange(0, 2 * Math.PI);
    const theta = Math.acos(2 * v - 1);
    const randX = randRadius * Math.cos(phi) * Math.sin(theta);
    const randY = randRadius * Math.cos(theta);
    const randZ = randRadius * Math.sin(phi) * Math.sin(theta);
    if (isLocal) {
      positionToUpdate.copyFromFloats(randX, randY, randZ);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
  }
  clone() {
    const newOne = new SphereParticleEmitter(this.radius, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  applyToShader(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
  }
  buildUniformLayout(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("directionRandomizer", 1);
  }
  getEffectDefines() {
    return "#define SPHEREEMITTER";
  }
  getClassName() {
    return "SphereParticleEmitter";
  }
  serialize() {
    const serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this.radius;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.directionRandomizer = this.directionRandomizer;
    return serializationObject;
  }
  parse(serializationObject) {
    this.radius = serializationObject.radius;
    this.radiusRange = serializationObject.radiusRange;
    this.directionRandomizer = serializationObject.directionRandomizer;
  }
};
var SphereDirectedParticleEmitter = class extends SphereParticleEmitter {
  constructor(radius = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    super(radius);
    this.direction1 = direction1;
    this.direction2 = direction2;
  }
  startDirectionFunction(worldMatrix, directionToUpdate) {
    const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
    const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
    const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  }
  clone() {
    const newOne = new SphereDirectedParticleEmitter(this.radius, this.direction1, this.direction2);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  applyToShader(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
  }
  buildUniformLayout(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
  }
  getEffectDefines() {
    return "#define SPHEREEMITTER\n#define DIRECTEDSPHEREEMITTER";
  }
  getClassName() {
    return "SphereDirectedParticleEmitter";
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    return serializationObject;
  }
  parse(serializationObject) {
    super.parse(serializationObject);
    this.direction1.copyFrom(serializationObject.direction1);
    this.direction2.copyFrom(serializationObject.direction2);
  }
};

// node_modules/@babylonjs/core/Particles/EmitterTypes/customParticleEmitter.js
var CustomParticleEmitter = class {
  constructor() {
    this.particlePositionGenerator = () => {
    };
    this.particleDestinationGenerator = () => {
    };
  }
  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
    const tmpVector = TmpVectors.Vector3[0];
    if (this.particleDestinationGenerator) {
      this.particleDestinationGenerator(-1, particle, tmpVector);
      const diffVector = TmpVectors.Vector3[1];
      tmpVector.subtractToRef(particle.position, diffVector);
      diffVector.scaleToRef(1 / particle.lifeTime, tmpVector);
    } else {
      tmpVector.set(0, 0, 0);
    }
    if (isLocal) {
      directionToUpdate.copyFrom(tmpVector);
      return;
    }
    Vector3.TransformNormalToRef(tmpVector, worldMatrix, directionToUpdate);
  }
  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
    const tmpVector = TmpVectors.Vector3[0];
    if (this.particlePositionGenerator) {
      this.particlePositionGenerator(-1, particle, tmpVector);
    } else {
      tmpVector.set(0, 0, 0);
    }
    if (isLocal) {
      positionToUpdate.copyFrom(tmpVector);
      return;
    }
    Vector3.TransformCoordinatesToRef(tmpVector, worldMatrix, positionToUpdate);
  }
  clone() {
    const newOne = new CustomParticleEmitter();
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  applyToShader(uboOrEffect) {
  }
  buildUniformLayout(ubo) {
  }
  getEffectDefines() {
    return "#define CUSTOMEMITTER";
  }
  getClassName() {
    return "CustomParticleEmitter";
  }
  serialize() {
    const serializationObject = {};
    serializationObject.type = this.getClassName();
    return serializationObject;
  }
  parse(serializationObject) {
  }
};

// node_modules/@babylonjs/core/Particles/EmitterTypes/meshParticleEmitter.js
var MeshParticleEmitter = class {
  constructor(mesh = null) {
    this._indices = null;
    this._positions = null;
    this._normals = null;
    this._storedNormal = Vector3.Zero();
    this._mesh = null;
    this.direction1 = new Vector3(0, 1, 0);
    this.direction2 = new Vector3(0, 1, 0);
    this.useMeshNormalsForDirection = true;
    this.mesh = mesh;
  }
  get mesh() {
    return this._mesh;
  }
  set mesh(value) {
    if (this._mesh === value) {
      return;
    }
    this._mesh = value;
    if (value) {
      this._indices = value.getIndices();
      this._positions = value.getVerticesData(VertexBuffer.PositionKind);
      this._normals = value.getVerticesData(VertexBuffer.NormalKind);
    } else {
      this._indices = null;
      this._positions = null;
      this._normals = null;
    }
  }
  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
    if (this.useMeshNormalsForDirection && this._normals) {
      Vector3.TransformNormalToRef(this._storedNormal, worldMatrix, directionToUpdate);
      return;
    }
    const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
    const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
    const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
    if (isLocal) {
      directionToUpdate.copyFromFloats(randX, randY, randZ);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  }
  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
    if (!this._indices || !this._positions) {
      return;
    }
    const randomFaceIndex = 3 * Math.random() * (this._indices.length / 3) | 0;
    const bu = Math.random();
    const bv = Math.random() * (1 - bu);
    const bw = 1 - bu - bv;
    const faceIndexA = this._indices[randomFaceIndex];
    const faceIndexB = this._indices[randomFaceIndex + 1];
    const faceIndexC = this._indices[randomFaceIndex + 2];
    const vertexA = TmpVectors.Vector3[0];
    const vertexB = TmpVectors.Vector3[1];
    const vertexC = TmpVectors.Vector3[2];
    const randomVertex = TmpVectors.Vector3[3];
    Vector3.FromArrayToRef(this._positions, faceIndexA * 3, vertexA);
    Vector3.FromArrayToRef(this._positions, faceIndexB * 3, vertexB);
    Vector3.FromArrayToRef(this._positions, faceIndexC * 3, vertexC);
    randomVertex.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;
    randomVertex.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;
    randomVertex.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;
    if (isLocal) {
      positionToUpdate.copyFromFloats(randomVertex.x, randomVertex.y, randomVertex.z);
    } else {
      Vector3.TransformCoordinatesFromFloatsToRef(randomVertex.x, randomVertex.y, randomVertex.z, worldMatrix, positionToUpdate);
    }
    if (this.useMeshNormalsForDirection && this._normals) {
      Vector3.FromArrayToRef(this._normals, faceIndexA * 3, vertexA);
      Vector3.FromArrayToRef(this._normals, faceIndexB * 3, vertexB);
      Vector3.FromArrayToRef(this._normals, faceIndexC * 3, vertexC);
      this._storedNormal.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;
      this._storedNormal.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;
      this._storedNormal.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;
    }
  }
  clone() {
    const newOne = new MeshParticleEmitter(this.mesh);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  }
  applyToShader(uboOrEffect) {
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
  }
  buildUniformLayout(ubo) {
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
  }
  getEffectDefines() {
    return "";
  }
  getClassName() {
    return "MeshParticleEmitter";
  }
  serialize() {
    var _a;
    const serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    serializationObject.meshId = (_a = this.mesh) === null || _a === void 0 ? void 0 : _a.id;
    serializationObject.useMeshNormalsForDirection = this.useMeshNormalsForDirection;
    return serializationObject;
  }
  parse(serializationObject, scene) {
    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
    if (serializationObject.meshId && scene) {
      this.mesh = scene.getLastMeshById(serializationObject.meshId);
    }
    this.useMeshNormalsForDirection = serializationObject.useMeshNormalsForDirection;
  }
};

// node_modules/@babylonjs/core/Particles/baseParticleSystem.js
var BaseParticleSystem = class {
  constructor(name4) {
    this.animations = [];
    this.renderingGroupId = 0;
    this.emitter = Vector3.Zero();
    this.emitRate = 10;
    this.manualEmitCount = -1;
    this.updateSpeed = 0.01;
    this.targetStopDuration = 0;
    this.disposeOnStop = false;
    this.minEmitPower = 1;
    this.maxEmitPower = 1;
    this.minLifeTime = 1;
    this.maxLifeTime = 1;
    this.minSize = 1;
    this.maxSize = 1;
    this.minScaleX = 1;
    this.maxScaleX = 1;
    this.minScaleY = 1;
    this.maxScaleY = 1;
    this.minInitialRotation = 0;
    this.maxInitialRotation = 0;
    this.minAngularSpeed = 0;
    this.maxAngularSpeed = 0;
    this.layerMask = 268435455;
    this.customShader = null;
    this.preventAutoStart = false;
    this._wasDispatched = false;
    this._rootUrl = "";
    this.noiseStrength = new Vector3(10, 10, 10);
    this.onAnimationEnd = null;
    this.blendMode = BaseParticleSystem.BLENDMODE_ONEONE;
    this.forceDepthWrite = false;
    this.preWarmCycles = 0;
    this.preWarmStepOffset = 1;
    this.spriteCellChangeSpeed = 1;
    this.startSpriteCellID = 0;
    this.endSpriteCellID = 0;
    this.spriteCellWidth = 0;
    this.spriteCellHeight = 0;
    this.spriteCellLoop = true;
    this.spriteRandomStartCell = false;
    this.translationPivot = new Vector2(0, 0);
    this.beginAnimationOnStart = false;
    this.beginAnimationFrom = 0;
    this.beginAnimationTo = 60;
    this.beginAnimationLoop = false;
    this.worldOffset = new Vector3(0, 0, 0);
    this._useLogarithmicDepth = false;
    this.gravity = Vector3.Zero();
    this._colorGradients = null;
    this._sizeGradients = null;
    this._lifeTimeGradients = null;
    this._angularSpeedGradients = null;
    this._velocityGradients = null;
    this._limitVelocityGradients = null;
    this._dragGradients = null;
    this._emitRateGradients = null;
    this._startSizeGradients = null;
    this._rampGradients = null;
    this._colorRemapGradients = null;
    this._alphaRemapGradients = null;
    this.startDelay = 0;
    this.limitVelocityDamping = 0.4;
    this.color1 = new Color4(1, 1, 1, 1);
    this.color2 = new Color4(1, 1, 1, 1);
    this.colorDead = new Color4(0, 0, 0, 1);
    this.textureMask = new Color4(1, 1, 1, 1);
    this._isSubEmitter = false;
    this._billboardMode = 7;
    this._isBillboardBased = true;
    this._imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();
    this.id = name4;
    this.name = name4;
  }
  get noiseTexture() {
    return this._noiseTexture;
  }
  set noiseTexture(value) {
    if (this._noiseTexture === value) {
      return;
    }
    this._noiseTexture = value;
    this._reset();
  }
  get isAnimationSheetEnabled() {
    return this._isAnimationSheetEnabled;
  }
  set isAnimationSheetEnabled(value) {
    if (this._isAnimationSheetEnabled == value) {
      return;
    }
    this._isAnimationSheetEnabled = value;
    this._reset();
  }
  get useLogarithmicDepth() {
    return this._useLogarithmicDepth;
  }
  set useLogarithmicDepth(value) {
    this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;
  }
  getScene() {
    return this._scene;
  }
  _hasTargetStopDurationDependantGradient() {
    return this._startSizeGradients && this._startSizeGradients.length > 0 || this._emitRateGradients && this._emitRateGradients.length > 0 || this._lifeTimeGradients && this._lifeTimeGradients.length > 0;
  }
  getDragGradients() {
    return this._dragGradients;
  }
  getLimitVelocityGradients() {
    return this._limitVelocityGradients;
  }
  getColorGradients() {
    return this._colorGradients;
  }
  getSizeGradients() {
    return this._sizeGradients;
  }
  getColorRemapGradients() {
    return this._colorRemapGradients;
  }
  getAlphaRemapGradients() {
    return this._alphaRemapGradients;
  }
  getLifeTimeGradients() {
    return this._lifeTimeGradients;
  }
  getAngularSpeedGradients() {
    return this._angularSpeedGradients;
  }
  getVelocityGradients() {
    return this._velocityGradients;
  }
  getStartSizeGradients() {
    return this._startSizeGradients;
  }
  getEmitRateGradients() {
    return this._emitRateGradients;
  }
  get direction1() {
    if (this.particleEmitterType.direction1) {
      return this.particleEmitterType.direction1;
    }
    return Vector3.Zero();
  }
  set direction1(value) {
    if (this.particleEmitterType.direction1) {
      this.particleEmitterType.direction1 = value;
    }
  }
  get direction2() {
    if (this.particleEmitterType.direction2) {
      return this.particleEmitterType.direction2;
    }
    return Vector3.Zero();
  }
  set direction2(value) {
    if (this.particleEmitterType.direction2) {
      this.particleEmitterType.direction2 = value;
    }
  }
  get minEmitBox() {
    if (this.particleEmitterType.minEmitBox) {
      return this.particleEmitterType.minEmitBox;
    }
    return Vector3.Zero();
  }
  set minEmitBox(value) {
    if (this.particleEmitterType.minEmitBox) {
      this.particleEmitterType.minEmitBox = value;
    }
  }
  get maxEmitBox() {
    if (this.particleEmitterType.maxEmitBox) {
      return this.particleEmitterType.maxEmitBox;
    }
    return Vector3.Zero();
  }
  set maxEmitBox(value) {
    if (this.particleEmitterType.maxEmitBox) {
      this.particleEmitterType.maxEmitBox = value;
    }
  }
  get billboardMode() {
    return this._billboardMode;
  }
  set billboardMode(value) {
    if (this._billboardMode === value) {
      return;
    }
    this._billboardMode = value;
    this._reset();
  }
  get isBillboardBased() {
    return this._isBillboardBased;
  }
  set isBillboardBased(value) {
    if (this._isBillboardBased === value) {
      return;
    }
    this._isBillboardBased = value;
    this._reset();
  }
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  set imageProcessingConfiguration(value) {
    this._attachImageProcessingConfiguration(value);
  }
  _attachImageProcessingConfiguration(configuration) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (!configuration && this._scene) {
      this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
  }
  _reset() {
  }
  _removeGradientAndTexture(gradient, gradients, texture) {
    if (!gradients) {
      return this;
    }
    let index = 0;
    for (const valueGradient of gradients) {
      if (valueGradient.gradient === gradient) {
        gradients.splice(index, 1);
        break;
      }
      index++;
    }
    if (texture) {
      texture.dispose();
    }
    return this;
  }
  createPointEmitter(direction1, direction2) {
    const particleEmitter = new PointParticleEmitter();
    particleEmitter.direction1 = direction1;
    particleEmitter.direction2 = direction2;
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  }
  createHemisphericEmitter(radius = 1, radiusRange = 1) {
    const particleEmitter = new HemisphericParticleEmitter(radius, radiusRange);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  }
  createSphereEmitter(radius = 1, radiusRange = 1) {
    const particleEmitter = new SphereParticleEmitter(radius, radiusRange);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  }
  createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    const particleEmitter = new SphereDirectedParticleEmitter(radius, direction1, direction2);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  }
  createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {
    const particleEmitter = new CylinderParticleEmitter(radius, height, radiusRange, directionRandomizer);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  }
  createDirectedCylinderEmitter(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    const particleEmitter = new CylinderDirectedParticleEmitter(radius, height, radiusRange, direction1, direction2);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  }
  createConeEmitter(radius = 1, angle = Math.PI / 4) {
    const particleEmitter = new ConeParticleEmitter(radius, angle);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  }
  createBoxEmitter(direction1, direction2, minEmitBox, maxEmitBox) {
    const particleEmitter = new BoxParticleEmitter();
    this.particleEmitterType = particleEmitter;
    this.direction1 = direction1;
    this.direction2 = direction2;
    this.minEmitBox = minEmitBox;
    this.maxEmitBox = maxEmitBox;
    return particleEmitter;
  }
};
BaseParticleSystem.BLENDMODE_ONEONE = 0;
BaseParticleSystem.BLENDMODE_STANDARD = 1;
BaseParticleSystem.BLENDMODE_ADD = 2;
BaseParticleSystem.BLENDMODE_MULTIPLY = 3;
BaseParticleSystem.BLENDMODE_MULTIPLYADD = 4;

// node_modules/@babylonjs/core/Materials/Node/Blocks/colorSplitterBlock.js
var ColorSplitterBlock = class extends NodeMaterialBlock {
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Neutral);
    this.registerInput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, true);
    this.registerInput("rgb ", NodeMaterialBlockConnectionPointTypes.Color3, true);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float);
    this.inputsAreExclusive = true;
  }
  getClassName() {
    return "ColorSplitterBlock";
  }
  get rgba() {
    return this._inputs[0];
  }
  get rgbIn() {
    return this._inputs[1];
  }
  get rgbOut() {
    return this._outputs[0];
  }
  get r() {
    return this._outputs[1];
  }
  get g() {
    return this._outputs[2];
  }
  get b() {
    return this._outputs[3];
  }
  get a() {
    return this._outputs[4];
  }
  _inputRename(name4) {
    if (name4 === "rgb ") {
      return "rgbIn";
    }
    return name4;
  }
  _outputRename(name4) {
    if (name4 === "rgb") {
      return "rgbOut";
    }
    return name4;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const input = this.rgba.isConnected ? this.rgba : this.rgbIn;
    if (!input.isConnected) {
      return;
    }
    const rgbOutput = this._outputs[0];
    const rOutput = this._outputs[1];
    const gOutput = this._outputs[2];
    const bOutput = this._outputs[3];
    const aOutput = this._outputs[4];
    if (rgbOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(rgbOutput, state) + ` = ${input.associatedVariableName}.rgb;\r
`;
    }
    if (rOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(rOutput, state) + ` = ${input.associatedVariableName}.r;\r
`;
    }
    if (gOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(gOutput, state) + ` = ${input.associatedVariableName}.g;\r
`;
    }
    if (bOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(bOutput, state) + ` = ${input.associatedVariableName}.b;\r
`;
    }
    if (aOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(aOutput, state) + ` = ${input.associatedVariableName}.a;\r
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.ColorSplitterBlock", ColorSplitterBlock);

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTextureSceneComponent.js
var ProceduralTextureSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;
    this.scene = scene;
    this.scene.proceduralTextures = new Array();
  }
  register() {
    this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);
  }
  rebuild() {
  }
  dispose() {
  }
  _beforeClear() {
    if (this.scene.proceduralTexturesEnabled) {
      Tools.StartPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0);
      for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {
        const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];
        if (proceduralTexture._shouldRender()) {
          proceduralTexture.render();
        }
      }
      Tools.EndPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0);
    }
  }
};

// node_modules/@babylonjs/core/Shaders/procedural.vertex.js
var name = "proceduralVertexShader";
var shader = `attribute vec2 position;
varying vec2 vPosition;
varying vec2 vUV;
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vPosition=position;
vUV=position*madd+madd;
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name] = shader;

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTexture.js
var ProceduralTexture = class extends Texture {
  constructor(name4, size, fragment, scene, fallbackTexture = null, generateMipMaps = true, isCube = false, textureType = 0) {
    super(null, scene, !generateMipMaps);
    this.isEnabled = true;
    this.autoClear = true;
    this.onGeneratedObservable = new Observable();
    this.onBeforeGenerationObservable = new Observable();
    this.nodeMaterialSource = null;
    this._textures = {};
    this._currentRefreshId = -1;
    this._frameId = -1;
    this._refreshRate = 1;
    this._vertexBuffers = {};
    this._uniforms = new Array();
    this._samplers = new Array();
    this._floats = {};
    this._ints = {};
    this._floatsArrays = {};
    this._colors3 = {};
    this._colors4 = {};
    this._vectors2 = {};
    this._vectors3 = {};
    this._matrices = {};
    this._fallbackTextureUsed = false;
    this._cachedDefines = null;
    this._contentUpdateId = -1;
    this._rtWrapper = null;
    scene = this.getScene() || EngineStore.LastCreatedScene;
    let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);
    if (!component) {
      component = new ProceduralTextureSceneComponent(scene);
      scene._addComponent(component);
    }
    scene.proceduralTextures.push(this);
    this._fullEngine = scene.getEngine();
    this.name = name4;
    this.isRenderTarget = true;
    this._size = size;
    this._textureType = textureType;
    this._generateMipMaps = generateMipMaps;
    this._drawWrapper = new DrawWrapper(this._fullEngine);
    this.setFragment(fragment);
    this._fallbackTexture = fallbackTexture;
    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);
    this._texture = rtWrapper.texture;
    const vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);
    this._createIndexBuffer();
  }
  _createRtWrapper(isCube, size, generateMipMaps, textureType) {
    if (isCube) {
      this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size, {
        generateMipMaps,
        generateDepthBuffer: false,
        generateStencilBuffer: false,
        type: textureType
      });
      this.setFloat("face", 0);
    } else {
      this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {
        generateMipMaps,
        generateDepthBuffer: false,
        generateStencilBuffer: false,
        type: textureType
      });
    }
    return this._rtWrapper;
  }
  getEffect() {
    return this._drawWrapper.effect;
  }
  _setEffect(effect) {
    this._drawWrapper.effect = effect;
  }
  getContent() {
    if (this._contentData && this._frameId === this._contentUpdateId) {
      return this._contentData;
    }
    if (this._contentData) {
      this._contentData.then((buffer) => {
        this._contentData = this.readPixels(0, 0, buffer);
        this._contentUpdateId = this._frameId;
      });
    } else {
      this._contentData = this.readPixels(0, 0);
      this._contentUpdateId = this._frameId;
    }
    return this._contentData;
  }
  _createIndexBuffer() {
    const engine = this._fullEngine;
    const indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = engine.createIndexBuffer(indices);
  }
  _rebuild() {
    const vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vb) {
      vb._rebuild();
    }
    this._createIndexBuffer();
    if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {
      this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
    }
  }
  reset() {
    var _a;
    (_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.dispose();
  }
  _getDefines() {
    return "";
  }
  isReady() {
    const engine = this._fullEngine;
    let shaders;
    if (this.nodeMaterialSource) {
      return this._drawWrapper.effect.isReady();
    }
    if (!this._fragment) {
      return false;
    }
    if (this._fallbackTextureUsed) {
      return true;
    }
    if (!this._texture) {
      return false;
    }
    const defines = this._getDefines();
    if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {
      return true;
    }
    if (this._fragment.fragmentElement !== void 0) {
      shaders = { vertex: "procedural", fragmentElement: this._fragment.fragmentElement };
    } else {
      shaders = { vertex: "procedural", fragment: this._fragment };
    }
    if (this._cachedDefines !== defines) {
      this._cachedDefines = defines;
      this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, void 0, void 0, () => {
        var _a;
        (_a = this._rtWrapper) === null || _a === void 0 ? void 0 : _a.dispose();
        this._rtWrapper = this._texture = null;
        if (this._fallbackTexture) {
          this._texture = this._fallbackTexture._texture;
          if (this._texture) {
            this._texture.incrementReferences();
          }
        }
        this._fallbackTextureUsed = true;
      });
    }
    return this._drawWrapper.effect.isReady();
  }
  resetRefreshCounter() {
    this._currentRefreshId = -1;
  }
  setFragment(fragment) {
    this._fragment = fragment;
  }
  get refreshRate() {
    return this._refreshRate;
  }
  set refreshRate(value) {
    this._refreshRate = value;
    this.resetRefreshCounter();
  }
  _shouldRender() {
    if (!this.isEnabled || !this.isReady() || !this._texture) {
      if (this._texture) {
        this._texture.isReady = false;
      }
      return false;
    }
    if (this._fallbackTextureUsed) {
      return false;
    }
    if (this._currentRefreshId === -1) {
      this._currentRefreshId = 1;
      this._frameId++;
      return true;
    }
    if (this.refreshRate === this._currentRefreshId) {
      this._currentRefreshId = 1;
      this._frameId++;
      return true;
    }
    this._currentRefreshId++;
    return false;
  }
  getRenderSize() {
    return this._size;
  }
  resize(size, generateMipMaps) {
    if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {
      return;
    }
    const isCube = this._texture.isCube;
    this._rtWrapper.dispose();
    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);
    this._texture = rtWrapper.texture;
    this._size = size;
    this._generateMipMaps = generateMipMaps;
  }
  _checkUniform(uniformName) {
    if (this._uniforms.indexOf(uniformName) === -1) {
      this._uniforms.push(uniformName);
    }
  }
  setTexture(name4, texture) {
    if (this._samplers.indexOf(name4) === -1) {
      this._samplers.push(name4);
    }
    this._textures[name4] = texture;
    return this;
  }
  setFloat(name4, value) {
    this._checkUniform(name4);
    this._floats[name4] = value;
    return this;
  }
  setInt(name4, value) {
    this._checkUniform(name4);
    this._ints[name4] = value;
    return this;
  }
  setFloats(name4, value) {
    this._checkUniform(name4);
    this._floatsArrays[name4] = value;
    return this;
  }
  setColor3(name4, value) {
    this._checkUniform(name4);
    this._colors3[name4] = value;
    return this;
  }
  setColor4(name4, value) {
    this._checkUniform(name4);
    this._colors4[name4] = value;
    return this;
  }
  setVector2(name4, value) {
    this._checkUniform(name4);
    this._vectors2[name4] = value;
    return this;
  }
  setVector3(name4, value) {
    this._checkUniform(name4);
    this._vectors3[name4] = value;
    return this;
  }
  setMatrix(name4, value) {
    this._checkUniform(name4);
    this._matrices[name4] = value;
    return this;
  }
  render(useCameraPostProcess) {
    var _a, _b;
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    const engine = this._fullEngine;
    engine.enableEffect(this._drawWrapper);
    this.onBeforeGenerationObservable.notifyObservers(this);
    engine.setState(false);
    if (!this.nodeMaterialSource) {
      for (const name4 in this._textures) {
        this._drawWrapper.effect.setTexture(name4, this._textures[name4]);
      }
      for (const name4 in this._ints) {
        this._drawWrapper.effect.setInt(name4, this._ints[name4]);
      }
      for (const name4 in this._floats) {
        this._drawWrapper.effect.setFloat(name4, this._floats[name4]);
      }
      for (const name4 in this._floatsArrays) {
        this._drawWrapper.effect.setArray(name4, this._floatsArrays[name4]);
      }
      for (const name4 in this._colors3) {
        this._drawWrapper.effect.setColor3(name4, this._colors3[name4]);
      }
      for (const name4 in this._colors4) {
        const color = this._colors4[name4];
        this._drawWrapper.effect.setFloat4(name4, color.r, color.g, color.b, color.a);
      }
      for (const name4 in this._vectors2) {
        this._drawWrapper.effect.setVector2(name4, this._vectors2[name4]);
      }
      for (const name4 in this._vectors3) {
        this._drawWrapper.effect.setVector3(name4, this._vectors3[name4]);
      }
      for (const name4 in this._matrices) {
        this._drawWrapper.effect.setMatrix(name4, this._matrices[name4]);
      }
    }
    if (!this._texture || !this._rtWrapper) {
      return;
    }
    (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `procedural texture generation for ${this.name}`, 1);
    const viewPort = engine.currentViewport;
    if (this.isCube) {
      for (let face = 0; face < 6; face++) {
        engine.bindFramebuffer(this._rtWrapper, face, void 0, void 0, true);
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);
        this._drawWrapper.effect.setFloat("face", face);
        if (this.autoClear) {
          engine.clear(scene.clearColor, true, false, false);
        }
        engine.drawElementsType(Material.TriangleFillMode, 0, 6);
      }
    } else {
      engine.bindFramebuffer(this._rtWrapper, 0, void 0, void 0, true);
      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);
      if (this.autoClear) {
        engine.clear(scene.clearColor, true, false, false);
      }
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
    }
    engine.unBindFramebuffer(this._rtWrapper, this.isCube);
    if (viewPort) {
      engine.setViewport(viewPort);
    }
    if (this.isCube) {
      engine.generateMipMapsForCubemap(this._texture);
    }
    (_b = engine._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(engine, 1);
    if (this.onGenerated) {
      this.onGenerated();
    }
    this.onGeneratedObservable.notifyObservers(this);
  }
  clone() {
    const textureSize = this.getSize();
    const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.coordinatesMode = this.coordinatesMode;
    return newTexture;
  }
  dispose() {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    const index = scene.proceduralTextures.indexOf(this);
    if (index >= 0) {
      scene.proceduralTextures.splice(index, 1);
    }
    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {
      this._indexBuffer = null;
    }
    this.onGeneratedObservable.clear();
    this.onBeforeGenerationObservable.clear();
    super.dispose();
  }
};
__decorate([
  serialize()
], ProceduralTexture.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "autoClear", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "_generateMipMaps", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "_size", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "refreshRate", null);
RegisterClass("BABYLON.ProceduralTexture", ProceduralTexture);

// node_modules/@babylonjs/core/Materials/Node/Blocks/trigonometryBlock.js
var TrigonometryBlockOperations;
(function(TrigonometryBlockOperations2) {
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Cos"] = 0] = "Cos";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sin"] = 1] = "Sin";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Abs"] = 2] = "Abs";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Exp"] = 3] = "Exp";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Exp2"] = 4] = "Exp2";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Round"] = 5] = "Round";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Floor"] = 6] = "Floor";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Ceiling"] = 7] = "Ceiling";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sqrt"] = 8] = "Sqrt";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Log"] = 9] = "Log";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Tan"] = 10] = "Tan";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcTan"] = 11] = "ArcTan";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcCos"] = 12] = "ArcCos";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcSin"] = 13] = "ArcSin";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Fract"] = 14] = "Fract";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sign"] = 15] = "Sign";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Radians"] = 16] = "Radians";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Degrees"] = 17] = "Degrees";
})(TrigonometryBlockOperations || (TrigonometryBlockOperations = {}));
var TrigonometryBlock = class extends NodeMaterialBlock {
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Neutral);
    this.operation = TrigonometryBlockOperations.Cos;
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  getClassName() {
    return "TrigonometryBlock";
  }
  get input() {
    return this._inputs[0];
  }
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    let operation = "";
    switch (this.operation) {
      case TrigonometryBlockOperations.Cos: {
        operation = "cos";
        break;
      }
      case TrigonometryBlockOperations.Sin: {
        operation = "sin";
        break;
      }
      case TrigonometryBlockOperations.Abs: {
        operation = "abs";
        break;
      }
      case TrigonometryBlockOperations.Exp: {
        operation = "exp";
        break;
      }
      case TrigonometryBlockOperations.Exp2: {
        operation = "exp2";
        break;
      }
      case TrigonometryBlockOperations.Round: {
        operation = "round";
        break;
      }
      case TrigonometryBlockOperations.Floor: {
        operation = "floor";
        break;
      }
      case TrigonometryBlockOperations.Ceiling: {
        operation = "ceil";
        break;
      }
      case TrigonometryBlockOperations.Sqrt: {
        operation = "sqrt";
        break;
      }
      case TrigonometryBlockOperations.Log: {
        operation = "log";
        break;
      }
      case TrigonometryBlockOperations.Tan: {
        operation = "tan";
        break;
      }
      case TrigonometryBlockOperations.ArcTan: {
        operation = "atan";
        break;
      }
      case TrigonometryBlockOperations.ArcCos: {
        operation = "acos";
        break;
      }
      case TrigonometryBlockOperations.ArcSin: {
        operation = "asin";
        break;
      }
      case TrigonometryBlockOperations.Fract: {
        operation = "fract";
        break;
      }
      case TrigonometryBlockOperations.Sign: {
        operation = "sign";
        break;
      }
      case TrigonometryBlockOperations.Radians: {
        operation = "radians";
        break;
      }
      case TrigonometryBlockOperations.Degrees: {
        operation = "degrees";
        break;
      }
    }
    state.compilationString += this._declareOutput(output, state) + ` = ${operation}(${this.input.associatedVariableName});\r
`;
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.operation = this.operation;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.operation = serializationObject.operation;
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.TrigonometryBlockOperations.${TrigonometryBlockOperations[this.operation]};\r
`;
    return codeString;
  }
};
RegisterClass("BABYLON.TrigonometryBlock", TrigonometryBlock);

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBuildState.js
var NodeMaterialBuildState = class {
  constructor() {
    this.supportUniformBuffers = false;
    this.attributes = new Array();
    this.uniforms = new Array();
    this.constants = new Array();
    this.samplers = new Array();
    this.functions = {};
    this.extensions = {};
    this.counters = {};
    this._attributeDeclaration = "";
    this._uniformDeclaration = "";
    this._constantDeclaration = "";
    this._samplerDeclaration = "";
    this._varyingTransfer = "";
    this._injectAtEnd = "";
    this._repeatableContentAnchorIndex = 0;
    this._builtCompilationString = "";
    this.compilationString = "";
  }
  finalize(state) {
    const emitComments = state.sharedData.emitComments;
    const isFragmentMode = this.target === NodeMaterialBlockTargets.Fragment;
    this.compilationString = `\r
${emitComments ? "//Entry point\r\n" : ""}void main(void) {\r
${this.compilationString}`;
    if (this._constantDeclaration) {
      this.compilationString = `\r
${emitComments ? "//Constants\r\n" : ""}${this._constantDeclaration}\r
${this.compilationString}`;
    }
    let functionCode = "";
    for (const functionName in this.functions) {
      functionCode += this.functions[functionName] + `\r
`;
    }
    this.compilationString = `\r
${functionCode}\r
${this.compilationString}`;
    if (!isFragmentMode && this._varyingTransfer) {
      this.compilationString = `${this.compilationString}\r
${this._varyingTransfer}`;
    }
    if (this._injectAtEnd) {
      this.compilationString = `${this.compilationString}\r
${this._injectAtEnd}`;
    }
    this.compilationString = `${this.compilationString}\r
}`;
    if (this.sharedData.varyingDeclaration) {
      this.compilationString = `\r
${emitComments ? "//Varyings\r\n" : ""}${this.sharedData.varyingDeclaration}\r
${this.compilationString}`;
    }
    if (this._samplerDeclaration) {
      this.compilationString = `\r
${emitComments ? "//Samplers\r\n" : ""}${this._samplerDeclaration}\r
${this.compilationString}`;
    }
    if (this._uniformDeclaration) {
      this.compilationString = `\r
${emitComments ? "//Uniforms\r\n" : ""}${this._uniformDeclaration}\r
${this.compilationString}`;
    }
    if (this._attributeDeclaration && !isFragmentMode) {
      this.compilationString = `\r
${emitComments ? "//Attributes\r\n" : ""}${this._attributeDeclaration}\r
${this.compilationString}`;
    }
    this.compilationString = "precision highp float;\r\n" + this.compilationString;
    for (const extensionName in this.extensions) {
      const extension = this.extensions[extensionName];
      this.compilationString = `\r
${extension}\r
${this.compilationString}`;
    }
    this._builtCompilationString = this.compilationString;
  }
  get _repeatableContentAnchor() {
    return `###___ANCHOR${this._repeatableContentAnchorIndex++}___###`;
  }
  _getFreeVariableName(prefix) {
    prefix = prefix.replace(/[^a-zA-Z_]+/g, "");
    if (this.sharedData.variableNames[prefix] === void 0) {
      this.sharedData.variableNames[prefix] = 0;
      if (prefix === "output" || prefix === "texture") {
        return prefix + this.sharedData.variableNames[prefix];
      }
      return prefix;
    } else {
      this.sharedData.variableNames[prefix]++;
    }
    return prefix + this.sharedData.variableNames[prefix];
  }
  _getFreeDefineName(prefix) {
    if (this.sharedData.defineNames[prefix] === void 0) {
      this.sharedData.defineNames[prefix] = 0;
    } else {
      this.sharedData.defineNames[prefix]++;
    }
    return prefix + this.sharedData.defineNames[prefix];
  }
  _excludeVariableName(name4) {
    this.sharedData.variableNames[name4] = 0;
  }
  _emit2DSampler(name4) {
    if (this.samplers.indexOf(name4) < 0) {
      this._samplerDeclaration += `uniform sampler2D ${name4};\r
`;
      this.samplers.push(name4);
    }
  }
  _getGLType(type) {
    switch (type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        return "float";
      case NodeMaterialBlockConnectionPointTypes.Int:
        return "int";
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        return "vec2";
      case NodeMaterialBlockConnectionPointTypes.Color3:
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        return "vec3";
      case NodeMaterialBlockConnectionPointTypes.Color4:
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        return "vec4";
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        return "mat4";
    }
    return "";
  }
  _emitExtension(name4, extension, define = "") {
    if (this.extensions[name4]) {
      return;
    }
    if (define) {
      extension = `#if ${define}\r
${extension}\r
#endif`;
    }
    this.extensions[name4] = extension;
  }
  _emitFunction(name4, code, comments) {
    if (this.functions[name4]) {
      return;
    }
    if (this.sharedData.emitComments) {
      code = comments + `\r
` + code;
    }
    this.functions[name4] = code;
  }
  _emitCodeFromInclude(includeName, comments, options) {
    if (options && options.repeatKey) {
      return `#include<${includeName}>${options.substitutionVars ? "(" + options.substitutionVars + ")" : ""}[0..${options.repeatKey}]\r
`;
    }
    let code = Effect.IncludesShadersStore[includeName] + "\r\n";
    if (this.sharedData.emitComments) {
      code = comments + `\r
` + code;
    }
    if (!options) {
      return code;
    }
    if (options.replaceStrings) {
      for (let index = 0; index < options.replaceStrings.length; index++) {
        const replaceString = options.replaceStrings[index];
        code = code.replace(replaceString.search, replaceString.replace);
      }
    }
    return code;
  }
  _emitFunctionFromInclude(includeName, comments, options, storeKey = "") {
    const key = includeName + storeKey;
    if (this.functions[key]) {
      return;
    }
    if (!options || !options.removeAttributes && !options.removeUniforms && !options.removeVaryings && !options.removeIfDef && !options.replaceStrings) {
      if (options && options.repeatKey) {
        this.functions[key] = `#include<${includeName}>${options.substitutionVars ? "(" + options.substitutionVars + ")" : ""}[0..${options.repeatKey}]\r
`;
      } else {
        this.functions[key] = `#include<${includeName}>${(options === null || options === void 0 ? void 0 : options.substitutionVars) ? "(" + (options === null || options === void 0 ? void 0 : options.substitutionVars) + ")" : ""}\r
`;
      }
      if (this.sharedData.emitComments) {
        this.functions[key] = comments + `\r
` + this.functions[key];
      }
      return;
    }
    this.functions[key] = Effect.IncludesShadersStore[includeName];
    if (this.sharedData.emitComments) {
      this.functions[key] = comments + `\r
` + this.functions[key];
    }
    if (options.removeIfDef) {
      this.functions[key] = this.functions[key].replace(/^\s*?#ifdef.+$/gm, "");
      this.functions[key] = this.functions[key].replace(/^\s*?#endif.*$/gm, "");
      this.functions[key] = this.functions[key].replace(/^\s*?#else.*$/gm, "");
      this.functions[key] = this.functions[key].replace(/^\s*?#elif.*$/gm, "");
    }
    if (options.removeAttributes) {
      this.functions[key] = this.functions[key].replace(/^\s*?attribute.+$/gm, "");
    }
    if (options.removeUniforms) {
      this.functions[key] = this.functions[key].replace(/^\s*?uniform.+$/gm, "");
    }
    if (options.removeVaryings) {
      this.functions[key] = this.functions[key].replace(/^\s*?varying.+$/gm, "");
    }
    if (options.replaceStrings) {
      for (let index = 0; index < options.replaceStrings.length; index++) {
        const replaceString = options.replaceStrings[index];
        this.functions[key] = this.functions[key].replace(replaceString.search, replaceString.replace);
      }
    }
  }
  _registerTempVariable(name4) {
    if (this.sharedData.temps.indexOf(name4) !== -1) {
      return false;
    }
    this.sharedData.temps.push(name4);
    return true;
  }
  _emitVaryingFromString(name4, type, define = "", notDefine = false) {
    if (this.sharedData.varyings.indexOf(name4) !== -1) {
      return false;
    }
    this.sharedData.varyings.push(name4);
    if (define) {
      if (define.startsWith("defined(")) {
        this.sharedData.varyingDeclaration += `#if ${define}\r
`;
      } else {
        this.sharedData.varyingDeclaration += `${notDefine ? "#ifndef" : "#ifdef"} ${define}\r
`;
      }
    }
    this.sharedData.varyingDeclaration += `varying ${type} ${name4};\r
`;
    if (define) {
      this.sharedData.varyingDeclaration += `#endif\r
`;
    }
    return true;
  }
  _emitUniformFromString(name4, type, define = "", notDefine = false) {
    if (this.uniforms.indexOf(name4) !== -1) {
      return;
    }
    this.uniforms.push(name4);
    if (define) {
      if (define.startsWith("defined(")) {
        this._uniformDeclaration += `#if ${define}\r
`;
      } else {
        this._uniformDeclaration += `${notDefine ? "#ifndef" : "#ifdef"} ${define}\r
`;
      }
    }
    this._uniformDeclaration += `uniform ${type} ${name4};\r
`;
    if (define) {
      this._uniformDeclaration += `#endif\r
`;
    }
  }
  _emitFloat(value) {
    if (value.toString() === value.toFixed(0)) {
      return `${value}.0`;
    }
    return value.toString();
  }
};

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBuildStateSharedData.js
var NodeMaterialBuildStateSharedData = class {
  constructor() {
    this.temps = new Array();
    this.varyings = new Array();
    this.varyingDeclaration = "";
    this.inputBlocks = new Array();
    this.textureBlocks = new Array();
    this.bindableBlocks = new Array();
    this.forcedBindableBlocks = new Array();
    this.blocksWithFallbacks = new Array();
    this.blocksWithDefines = new Array();
    this.repeatableContentBlocks = new Array();
    this.dynamicUniformBlocks = new Array();
    this.blockingBlocks = new Array();
    this.animatedInputs = new Array();
    this.variableNames = {};
    this.defineNames = {};
    this.hints = {
      needWorldViewMatrix: false,
      needWorldViewProjectionMatrix: false,
      needAlphaBlending: false,
      needAlphaTesting: false
    };
    this.checks = {
      emitVertex: false,
      emitFragment: false,
      notConnectedNonOptionalInputs: new Array()
    };
    this.allowEmptyVertexProgram = false;
    this.variableNames["position"] = 0;
    this.variableNames["normal"] = 0;
    this.variableNames["tangent"] = 0;
    this.variableNames["uv"] = 0;
    this.variableNames["uv2"] = 0;
    this.variableNames["uv3"] = 0;
    this.variableNames["uv4"] = 0;
    this.variableNames["uv5"] = 0;
    this.variableNames["uv6"] = 0;
    this.variableNames["color"] = 0;
    this.variableNames["matricesIndices"] = 0;
    this.variableNames["matricesWeights"] = 0;
    this.variableNames["matricesIndicesExtra"] = 0;
    this.variableNames["matricesWeightsExtra"] = 0;
    this.variableNames["diffuseBase"] = 0;
    this.variableNames["specularBase"] = 0;
    this.variableNames["worldPos"] = 0;
    this.variableNames["shadow"] = 0;
    this.variableNames["view"] = 0;
    this.variableNames["vTBN"] = 0;
    this.defineNames["MAINUV0"] = 0;
    this.defineNames["MAINUV1"] = 0;
    this.defineNames["MAINUV2"] = 0;
    this.defineNames["MAINUV3"] = 0;
    this.defineNames["MAINUV4"] = 0;
    this.defineNames["MAINUV5"] = 0;
    this.defineNames["MAINUV6"] = 0;
    this.defineNames["MAINUV7"] = 0;
  }
  emitErrors() {
    let errorMessage = "";
    if (!this.checks.emitVertex && !this.allowEmptyVertexProgram) {
      errorMessage += "NodeMaterial does not have a vertex output. You need to at least add a block that generates a glPosition value.\r\n";
    }
    if (!this.checks.emitFragment) {
      errorMessage += "NodeMaterial does not have a fragment output. You need to at least add a block that generates a glFragColor value.\r\n";
    }
    for (const notConnectedInput of this.checks.notConnectedNonOptionalInputs) {
      errorMessage += `input ${notConnectedInput.name} from block ${notConnectedInput.ownerBlock.name}[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.\r
`;
    }
    if (errorMessage) {
      throw "Build of NodeMaterial failed:\r\n" + errorMessage;
    }
  }
};

// node_modules/@babylonjs/core/Materials/Node/nodeMaterial.js
var onCreatedEffectParameters = { effect: null, subMesh: null };
var NodeMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.NORMAL = false;
    this.TANGENT = false;
    this.UV1 = false;
    this.UV2 = false;
    this.UV3 = false;
    this.UV4 = false;
    this.UV5 = false;
    this.UV6 = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.BONETEXTURE = false;
    this.MORPHTARGETS = false;
    this.MORPHTARGETS_NORMAL = false;
    this.MORPHTARGETS_TANGENT = false;
    this.MORPHTARGETS_UV = false;
    this.NUM_MORPH_INFLUENCERS = 0;
    this.MORPHTARGETS_TEXTURE = false;
    this.IMAGEPROCESSING = false;
    this.VIGNETTE = false;
    this.VIGNETTEBLENDMODEMULTIPLY = false;
    this.VIGNETTEBLENDMODEOPAQUE = false;
    this.TONEMAPPING = false;
    this.TONEMAPPING_ACES = false;
    this.CONTRAST = false;
    this.EXPOSURE = false;
    this.COLORCURVES = false;
    this.COLORGRADING = false;
    this.COLORGRADING3D = false;
    this.SAMPLER3DGREENDEPTH = false;
    this.SAMPLER3DBGRMAP = false;
    this.DITHER = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.BUMPDIRECTUV = 0;
    this.CAMERA_ORTHOGRAPHIC = false;
    this.CAMERA_PERSPECTIVE = false;
    this.rebuild();
  }
  setValue(name4, value, markAsUnprocessedIfDirty = false) {
    if (this[name4] === void 0) {
      this._keys.push(name4);
    }
    if (markAsUnprocessedIfDirty && this[name4] !== value) {
      this.markAsUnprocessed();
    }
    this[name4] = value;
  }
};
var NodeMaterial = class extends PushMaterial {
  constructor(name4, scene, options = {}) {
    super(name4, scene || EngineStore.LastCreatedScene);
    this._buildId = NodeMaterial._BuildIdGenerator++;
    this._buildWasSuccessful = false;
    this._cachedWorldViewMatrix = new Matrix();
    this._cachedWorldViewProjectionMatrix = new Matrix();
    this._optimizers = new Array();
    this._animationFrame = -1;
    this.BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor();
    this.editorData = null;
    this.ignoreAlpha = false;
    this.maxSimultaneousLights = 4;
    this.onBuildObservable = new Observable();
    this._vertexOutputNodes = new Array();
    this._fragmentOutputNodes = new Array();
    this.attachedBlocks = new Array();
    this._mode = NodeMaterialModes.Material;
    this.forceAlphaBlending = false;
    this._options = {
      emitComments: false,
      ...options
    };
    this._attachImageProcessingConfiguration(null);
  }
  static _BlockIsTextureBlock(block) {
    return block.getClassName() === "TextureBlock" || block.getClassName() === "ReflectionTextureBaseBlock" || block.getClassName() === "RefractionBlock" || block.getClassName() === "CurrentScreenBlock" || block.getClassName() === "ParticleTextureBlock" || block.getClassName() === "ImageSourceBlock" || block.getClassName() === "TriPlanarBlock" || block.getClassName() === "BiPlanarBlock";
  }
  _getGlobalNodeMaterialEditor() {
    if (typeof NODEEDITOR !== "undefined") {
      return NODEEDITOR;
    }
    if (typeof BABYLON !== "undefined" && typeof BABYLON.NodeEditor !== "undefined") {
      return BABYLON;
    }
    return void 0;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this._options = options;
  }
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  set imageProcessingConfiguration(value) {
    this._attachImageProcessingConfiguration(value);
    this._markAllSubMeshesAsTexturesDirty();
  }
  get mode() {
    return this._mode;
  }
  set mode(value) {
    this._mode = value;
  }
  get buildId() {
    return this._buildId;
  }
  set buildId(value) {
    this._buildId = value;
  }
  getClassName() {
    return "NodeMaterial";
  }
  _attachImageProcessingConfiguration(configuration) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (!configuration) {
      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
        this._markAllSubMeshesAsImageProcessingDirty();
      });
    }
  }
  getBlockByName(name4) {
    let result = null;
    for (const block of this.attachedBlocks) {
      if (block.name === name4) {
        if (!result) {
          result = block;
        } else {
          Tools.Warn("More than one block was found with the name `" + name4 + "`");
          return result;
        }
      }
    }
    return result;
  }
  getBlockByPredicate(predicate) {
    for (const block of this.attachedBlocks) {
      if (predicate(block)) {
        return block;
      }
    }
    return null;
  }
  getInputBlockByPredicate(predicate) {
    for (const block of this.attachedBlocks) {
      if (block.isInput && predicate(block)) {
        return block;
      }
    }
    return null;
  }
  getInputBlocks() {
    const blocks = [];
    for (const block of this.attachedBlocks) {
      if (block.isInput) {
        blocks.push(block);
      }
    }
    return blocks;
  }
  registerOptimizer(optimizer) {
    const index = this._optimizers.indexOf(optimizer);
    if (index > -1) {
      return;
    }
    this._optimizers.push(optimizer);
    return this;
  }
  unregisterOptimizer(optimizer) {
    const index = this._optimizers.indexOf(optimizer);
    if (index === -1) {
      return;
    }
    this._optimizers.splice(index, 1);
    return this;
  }
  addOutputNode(node) {
    if (node.target === null) {
      throw "This node is not meant to be an output node. You may want to explicitly set its target value.";
    }
    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {
      this._addVertexOutputNode(node);
    }
    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {
      this._addFragmentOutputNode(node);
    }
    return this;
  }
  removeOutputNode(node) {
    if (node.target === null) {
      return this;
    }
    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {
      this._removeVertexOutputNode(node);
    }
    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {
      this._removeFragmentOutputNode(node);
    }
    return this;
  }
  _addVertexOutputNode(node) {
    if (this._vertexOutputNodes.indexOf(node) !== -1) {
      return;
    }
    node.target = NodeMaterialBlockTargets.Vertex;
    this._vertexOutputNodes.push(node);
    return this;
  }
  _removeVertexOutputNode(node) {
    const index = this._vertexOutputNodes.indexOf(node);
    if (index === -1) {
      return;
    }
    this._vertexOutputNodes.splice(index, 1);
    return this;
  }
  _addFragmentOutputNode(node) {
    if (this._fragmentOutputNodes.indexOf(node) !== -1) {
      return;
    }
    node.target = NodeMaterialBlockTargets.Fragment;
    this._fragmentOutputNodes.push(node);
    return this;
  }
  _removeFragmentOutputNode(node) {
    const index = this._fragmentOutputNodes.indexOf(node);
    if (index === -1) {
      return;
    }
    this._fragmentOutputNodes.splice(index, 1);
    return this;
  }
  needAlphaBlending() {
    if (this.ignoreAlpha) {
      return false;
    }
    return this.forceAlphaBlending || this.alpha < 1 || this._sharedData && this._sharedData.hints.needAlphaBlending;
  }
  needAlphaTesting() {
    return this._sharedData && this._sharedData.hints.needAlphaTesting;
  }
  _initializeBlock(node, state, nodesToProcessForOtherBuildState, autoConfigure = true) {
    node.initialize(state);
    if (autoConfigure) {
      node.autoConfigure(this);
    }
    node._preparationId = this._buildId;
    if (this.attachedBlocks.indexOf(node) === -1) {
      if (node.isUnique) {
        const className = node.getClassName();
        for (const other of this.attachedBlocks) {
          if (other.getClassName() === className) {
            throw `Cannot have multiple blocks of type ${className} in the same NodeMaterial`;
          }
        }
      }
      this.attachedBlocks.push(node);
    }
    for (const input of node.inputs) {
      input.associatedVariableName = "";
      const connectedPoint = input.connectedPoint;
      if (connectedPoint) {
        const block = connectedPoint.ownerBlock;
        if (block !== node) {
          if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {
            nodesToProcessForOtherBuildState.push(block);
          } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {
            nodesToProcessForOtherBuildState.push(block);
          }
          this._initializeBlock(block, state, nodesToProcessForOtherBuildState, autoConfigure);
        }
      }
    }
    for (const output of node.outputs) {
      output.associatedVariableName = "";
    }
  }
  _resetDualBlocks(node, id) {
    if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {
      node.buildId = id;
    }
    for (const inputs of node.inputs) {
      const connectedPoint = inputs.connectedPoint;
      if (connectedPoint) {
        const block = connectedPoint.ownerBlock;
        if (block !== node) {
          this._resetDualBlocks(block, id);
        }
      }
    }
  }
  removeBlock(block) {
    const attachedBlockIndex = this.attachedBlocks.indexOf(block);
    if (attachedBlockIndex > -1) {
      this.attachedBlocks.splice(attachedBlockIndex, 1);
    }
    if (block.isFinalMerger) {
      this.removeOutputNode(block);
    }
  }
  build(verbose = false, updateBuildId = true, autoConfigure = true) {
    this._buildWasSuccessful = false;
    const engine = this.getScene().getEngine();
    const allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle;
    if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {
      throw "You must define at least one vertexOutputNode";
    }
    if (this._fragmentOutputNodes.length === 0) {
      throw "You must define at least one fragmentOutputNode";
    }
    this._vertexCompilationState = new NodeMaterialBuildState();
    this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;
    this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;
    this._fragmentCompilationState = new NodeMaterialBuildState();
    this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;
    this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;
    this._sharedData = new NodeMaterialBuildStateSharedData();
    this._sharedData.fragmentOutputNodes = this._fragmentOutputNodes;
    this._vertexCompilationState.sharedData = this._sharedData;
    this._fragmentCompilationState.sharedData = this._sharedData;
    this._sharedData.buildId = this._buildId;
    this._sharedData.emitComments = this._options.emitComments;
    this._sharedData.verbose = verbose;
    this._sharedData.scene = this.getScene();
    this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;
    const vertexNodes = [];
    const fragmentNodes = [];
    for (const vertexOutputNode of this._vertexOutputNodes) {
      vertexNodes.push(vertexOutputNode);
      this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes, autoConfigure);
    }
    for (const fragmentOutputNode of this._fragmentOutputNodes) {
      fragmentNodes.push(fragmentOutputNode);
      this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes, autoConfigure);
    }
    this.optimize();
    for (const vertexOutputNode of vertexNodes) {
      vertexOutputNode.build(this._vertexCompilationState, vertexNodes);
    }
    this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);
    this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;
    this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;
    this._fragmentCompilationState._vertexState = this._vertexCompilationState;
    for (const fragmentOutputNode of fragmentNodes) {
      this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);
    }
    for (const fragmentOutputNode of fragmentNodes) {
      fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);
    }
    this._vertexCompilationState.finalize(this._vertexCompilationState);
    this._fragmentCompilationState.finalize(this._fragmentCompilationState);
    if (updateBuildId) {
      this._buildId = NodeMaterial._BuildIdGenerator++;
    }
    this._sharedData.emitErrors();
    if (verbose) {
      console.log("Vertex shader:");
      console.log(this._vertexCompilationState.compilationString);
      console.log("Fragment shader:");
      console.log(this._fragmentCompilationState.compilationString);
    }
    this._buildWasSuccessful = true;
    this.onBuildObservable.notifyObservers(this);
    const meshes = this.getScene().meshes;
    for (const mesh of meshes) {
      if (!mesh.subMeshes) {
        continue;
      }
      for (const subMesh of mesh.subMeshes) {
        if (subMesh.getMaterial() !== this) {
          continue;
        }
        if (!subMesh.materialDefines) {
          continue;
        }
        const defines = subMesh.materialDefines;
        defines.markAllAsDirty();
        defines.reset();
      }
    }
  }
  optimize() {
    for (const optimizer of this._optimizers) {
      optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);
    }
  }
  _prepareDefinesForAttributes(mesh, defines) {
    const oldNormal = defines["NORMAL"];
    const oldTangent = defines["TANGENT"];
    defines["NORMAL"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
    defines["TANGENT"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);
    let uvChanged = false;
    for (let i = 1; i <= 6; ++i) {
      const oldUV = defines["UV" + i];
      defines["UV" + i] = mesh.isVerticesDataPresent(`uv${i === 1 ? "" : i}`);
      uvChanged = uvChanged || defines["UV" + i] !== oldUV;
    }
    if (oldNormal !== defines["NORMAL"] || oldTangent !== defines["TANGENT"] || uvChanged) {
      defines.markAsAttributesDirty();
    }
  }
  createPostProcess(camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {
    if (this.mode !== NodeMaterialModes.PostProcess) {
      console.log("Incompatible material mode");
      return null;
    }
    return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);
  }
  createEffectForPostProcess(postProcess) {
    this._createEffectForPostProcess(postProcess);
  }
  _createEffectForPostProcess(postProcess, camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {
    let tempName = this.name + this._buildId;
    const defines = new NodeMaterialDefines();
    const dummyMesh = new AbstractMesh(tempName + "PostProcess", this.getScene());
    let buildId = this._buildId;
    this._processDefines(dummyMesh, defines);
    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);
    if (!postProcess) {
      postProcess = new PostProcess(this.name + "PostProcess", tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, options, camera, samplingMode, engine, reusable, defines.toString(), textureType, tempName, { maxSimultaneousLights: this.maxSimultaneousLights }, false, textureFormat);
    } else {
      postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, { maxSimultaneousLights: this.maxSimultaneousLights }, void 0, void 0, tempName, tempName);
    }
    postProcess.nodeMaterialSource = this;
    postProcess.onApplyObservable.add((effect) => {
      if (buildId !== this._buildId) {
        delete Effect.ShadersStore[tempName + "VertexShader"];
        delete Effect.ShadersStore[tempName + "PixelShader"];
        tempName = this.name + this._buildId;
        defines.markAllAsDirty();
        buildId = this._buildId;
      }
      const result = this._processDefines(dummyMesh, defines);
      if (result) {
        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);
        TimingTools.SetImmediate(() => postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, { maxSimultaneousLights: this.maxSimultaneousLights }, void 0, void 0, tempName, tempName));
      }
      this._checkInternals(effect);
    });
    return postProcess;
  }
  createProceduralTexture(size, scene) {
    if (this.mode !== NodeMaterialModes.ProceduralTexture) {
      console.log("Incompatible material mode");
      return null;
    }
    let tempName = this.name + this._buildId;
    const proceduralTexture = new ProceduralTexture(tempName, size, null, scene);
    const dummyMesh = new AbstractMesh(tempName + "Procedural", this.getScene());
    dummyMesh.reservedDataStore = {
      hidden: true
    };
    const defines = new NodeMaterialDefines();
    const result = this._processDefines(dummyMesh, defines);
    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);
    let effect = this.getScene().getEngine().createEffect({
      vertexElement: tempName,
      fragmentElement: tempName
    }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result === null || result === void 0 ? void 0 : result.fallbacks, void 0);
    proceduralTexture.nodeMaterialSource = this;
    proceduralTexture._setEffect(effect);
    let buildId = this._buildId;
    proceduralTexture.onBeforeGenerationObservable.add(() => {
      if (buildId !== this._buildId) {
        delete Effect.ShadersStore[tempName + "VertexShader"];
        delete Effect.ShadersStore[tempName + "PixelShader"];
        tempName = this.name + this._buildId;
        defines.markAllAsDirty();
        buildId = this._buildId;
      }
      const result2 = this._processDefines(dummyMesh, defines);
      if (result2) {
        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);
        TimingTools.SetImmediate(() => {
          effect = this.getScene().getEngine().createEffect({
            vertexElement: tempName,
            fragmentElement: tempName
          }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result2 === null || result2 === void 0 ? void 0 : result2.fallbacks, void 0);
          proceduralTexture._setEffect(effect);
        });
      }
      this._checkInternals(effect);
    });
    return proceduralTexture;
  }
  _createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined = "") {
    let tempName = this.name + this._buildId + "_" + blendMode;
    if (!defines) {
      defines = new NodeMaterialDefines();
    }
    if (!dummyMesh) {
      dummyMesh = this.getScene().getMeshByName(this.name + "Particle");
      if (!dummyMesh) {
        dummyMesh = new AbstractMesh(this.name + "Particle", this.getScene());
        dummyMesh.reservedDataStore = {
          hidden: true
        };
      }
    }
    let buildId = this._buildId;
    const particleSystemDefines = [];
    let join = particleSystemDefinesJoined;
    if (!effect) {
      const result = this._processDefines(dummyMesh, defines);
      Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);
      particleSystem.fillDefines(particleSystemDefines, blendMode);
      join = particleSystemDefines.join("\n");
      effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + "\n" + join, result === null || result === void 0 ? void 0 : result.fallbacks, onCompiled, onError, particleSystem);
      particleSystem.setCustomEffect(effect, blendMode);
    }
    effect.onBindObservable.add((effect2) => {
      if (buildId !== this._buildId) {
        delete Effect.ShadersStore[tempName + "PixelShader"];
        tempName = this.name + this._buildId + "_" + blendMode;
        defines.markAllAsDirty();
        buildId = this._buildId;
      }
      particleSystemDefines.length = 0;
      particleSystem.fillDefines(particleSystemDefines, blendMode);
      const particleSystemDefinesJoinedCurrent = particleSystemDefines.join("\n");
      if (particleSystemDefinesJoinedCurrent !== join) {
        defines.markAllAsDirty();
        join = particleSystemDefinesJoinedCurrent;
      }
      const result = this._processDefines(dummyMesh, defines);
      if (result) {
        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);
        effect2 = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + "\n" + join, result === null || result === void 0 ? void 0 : result.fallbacks, onCompiled, onError, particleSystem);
        particleSystem.setCustomEffect(effect2, blendMode);
        this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect2, defines, dummyMesh, particleSystemDefinesJoined);
        return;
      }
      this._checkInternals(effect2);
    });
  }
  _checkInternals(effect) {
    if (this._sharedData.animatedInputs) {
      const scene = this.getScene();
      const frameId = scene.getFrameId();
      if (this._animationFrame !== frameId) {
        for (const input of this._sharedData.animatedInputs) {
          input.animate(scene);
        }
        this._animationFrame = frameId;
      }
    }
    for (const block of this._sharedData.bindableBlocks) {
      block.bind(effect, this);
    }
    for (const inputBlock of this._sharedData.inputBlocks) {
      inputBlock._transmit(effect, this.getScene(), this);
    }
  }
  createEffectForParticles(particleSystem, onCompiled, onError) {
    if (this.mode !== NodeMaterialModes.Particle) {
      console.log("Incompatible material mode");
      return;
    }
    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);
    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);
  }
  createAsShadowDepthWrapper(targetMaterial) {
    if (this.mode !== NodeMaterialModes.Material) {
      console.log("Incompatible material mode");
      return;
    }
    targetMaterial.shadowDepthWrapper = new BABYLON.ShadowDepthWrapper(this, this.getScene());
  }
  _processDefines(mesh, defines, useInstances = false, subMesh) {
    let result = null;
    const scene = this.getScene();
    if (MaterialHelper.PrepareDefinesForCamera(scene, defines)) {
      defines.markAsMiscDirty();
    }
    this._sharedData.blocksWithDefines.forEach((b) => {
      b.initializeDefines(mesh, this, defines, useInstances);
    });
    this._sharedData.blocksWithDefines.forEach((b) => {
      b.prepareDefines(mesh, this, defines, useInstances, subMesh);
    });
    if (defines.isDirty) {
      const lightDisposed = defines._areLightsDisposed;
      defines.markAsProcessed();
      this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;
      this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;
      this._sharedData.repeatableContentBlocks.forEach((b) => {
        b.replaceRepeatableContent(this._vertexCompilationState, this._fragmentCompilationState, mesh, defines);
      });
      const uniformBuffers = [];
      this._sharedData.dynamicUniformBlocks.forEach((b) => {
        b.updateUniformsAndSamples(this._vertexCompilationState, this, defines, uniformBuffers);
      });
      const mergedUniforms = this._vertexCompilationState.uniforms;
      this._fragmentCompilationState.uniforms.forEach((u) => {
        const index = mergedUniforms.indexOf(u);
        if (index === -1) {
          mergedUniforms.push(u);
        }
      });
      const mergedSamplers = this._vertexCompilationState.samplers;
      this._fragmentCompilationState.samplers.forEach((s) => {
        const index = mergedSamplers.indexOf(s);
        if (index === -1) {
          mergedSamplers.push(s);
        }
      });
      const fallbacks = new EffectFallbacks();
      this._sharedData.blocksWithFallbacks.forEach((b) => {
        b.provideFallbacks(mesh, fallbacks);
      });
      result = {
        lightDisposed,
        uniformBuffers,
        mergedUniforms,
        mergedSamplers,
        fallbacks
      };
    }
    return result;
  }
  isReadyForSubMesh(mesh, subMesh, useInstances = false) {
    if (!this._buildWasSuccessful) {
      return false;
    }
    const scene = this.getScene();
    if (this._sharedData.animatedInputs) {
      const frameId = scene.getFrameId();
      if (this._animationFrame !== frameId) {
        for (const input of this._sharedData.animatedInputs) {
          input.animate(scene);
        }
        this._animationFrame = frameId;
      }
    }
    if (subMesh.effect && this.isFrozen) {
      if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new NodeMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    this._prepareDefinesForAttributes(mesh, defines);
    if (this._sharedData.blockingBlocks.some((b) => !b.isReady(mesh, this, defines, useInstances))) {
      return false;
    }
    const result = this._processDefines(mesh, defines, useInstances, subMesh);
    if (result) {
      const previousEffect = subMesh.effect;
      const join = defines.toString();
      let effect = engine.createEffect({
        vertex: "nodeMaterial" + this._buildId,
        fragment: "nodeMaterial" + this._buildId,
        vertexSource: this._vertexCompilationState.compilationString,
        fragmentSource: this._fragmentCompilationState.compilationString
      }, {
        attributes: this._vertexCompilationState.attributes,
        uniformsNames: result.mergedUniforms,
        uniformBuffersNames: result.uniformBuffers,
        samplers: result.mergedSamplers,
        defines: join,
        fallbacks: result.fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS }
      }, engine);
      if (effect) {
        if (this._onEffectCreatedObservable) {
          onCreatedEffectParameters.effect = effect;
          onCreatedEffectParameters.subMesh = subMesh;
          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
        }
        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
          effect = previousEffect;
          defines.markAsUnprocessed();
          if (result.lightDisposed) {
            defines._areLightsDisposed = true;
            return false;
          }
        } else {
          scene.resetCachedMaterial();
          subMesh.setEffect(effect, defines, this._materialContext);
        }
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    subMesh.effect._wasPreviouslyReady = true;
    subMesh.effect._wasPreviouslyUsingInstances = useInstances;
    if (scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {
      this.checkReadyOnlyOnce = true;
    }
    return true;
  }
  get compiledShaders() {
    return `// Vertex shader\r
${this._vertexCompilationState.compilationString}\r
\r
// Fragment shader\r
${this._fragmentCompilationState.compilationString}`;
  }
  bindOnlyWorldMatrix(world) {
    const scene = this.getScene();
    if (!this._activeEffect) {
      return;
    }
    const hints = this._sharedData.hints;
    if (hints.needWorldViewMatrix) {
      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);
    }
    if (hints.needWorldViewProjectionMatrix) {
      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);
    }
    for (const inputBlock of this._sharedData.inputBlocks) {
      inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);
    }
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    const mustRebind = this._mustRebind(scene, effect, mesh.visibility);
    const sharedData = this._sharedData;
    if (mustRebind) {
      for (const block of sharedData.bindableBlocks) {
        block.bind(effect, this, mesh, subMesh);
      }
      for (const block of sharedData.forcedBindableBlocks) {
        block.bind(effect, this, mesh, subMesh);
      }
      for (const inputBlock of sharedData.inputBlocks) {
        inputBlock._transmit(effect, scene, this);
      }
    } else if (!this.isFrozen) {
      for (const block of sharedData.forcedBindableBlocks) {
        block.bind(effect, this, mesh, subMesh);
      }
    }
    this._afterBind(mesh, this._activeEffect);
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._sharedData) {
      activeTextures.push(...this._sharedData.textureBlocks.filter((tb) => tb.texture).map((tb) => tb.texture));
    }
    return activeTextures;
  }
  getTextureBlocks() {
    if (!this._sharedData) {
      return [];
    }
    return this._sharedData.textureBlocks;
  }
  getAllTextureBlocks() {
    const textureBlocks = [];
    for (const block of this.attachedBlocks) {
      if (NodeMaterial._BlockIsTextureBlock(block)) {
        textureBlocks.push(block);
      }
    }
    return textureBlocks;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (!this._sharedData) {
      return false;
    }
    for (const t of this._sharedData.textureBlocks) {
      if (t.texture === texture) {
        return true;
      }
    }
    return false;
  }
  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    if (forceDisposeTextures) {
      for (const texture of this.getTextureBlocks().filter((tb) => tb.texture).map((tb) => tb.texture)) {
        texture.dispose();
      }
    }
    for (const block of this.attachedBlocks) {
      block.dispose();
    }
    this.attachedBlocks.length = 0;
    this._sharedData = null;
    this._vertexCompilationState = null;
    this._fragmentCompilationState = null;
    this.onBuildObservable.clear();
    if (this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
      this._imageProcessingObserver = null;
    }
    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
  }
  _createNodeEditor() {
    this.BJSNODEMATERIALEDITOR.NodeEditor.Show({
      nodeMaterial: this
    });
  }
  edit(config) {
    return new Promise((resolve) => {
      this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();
      if (typeof this.BJSNODEMATERIALEDITOR == "undefined") {
        const editorUrl = config && config.editorURL ? config.editorURL : NodeMaterial.EditorURL;
        Tools.LoadScript(editorUrl, () => {
          this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();
          this._createNodeEditor();
          resolve();
        });
      } else {
        this._createNodeEditor();
        resolve();
      }
    });
  }
  clear() {
    this._vertexOutputNodes.length = 0;
    this._fragmentOutputNodes.length = 0;
    this.attachedBlocks.length = 0;
  }
  setToDefault() {
    this.clear();
    this.editorData = null;
    const positionInput = new InputBlock("Position");
    positionInput.setAsAttribute("position");
    const worldInput = new InputBlock("World");
    worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
    const worldPos = new TransformBlock("WorldPos");
    positionInput.connectTo(worldPos);
    worldInput.connectTo(worldPos);
    const viewProjectionInput = new InputBlock("ViewProjection");
    viewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.ViewProjection);
    const worldPosdMultipliedByViewProjection = new TransformBlock("WorldPos * ViewProjectionTransform");
    worldPos.connectTo(worldPosdMultipliedByViewProjection);
    viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);
    const vertexOutput = new VertexOutputBlock("VertexOutput");
    worldPosdMultipliedByViewProjection.connectTo(vertexOutput);
    const pixelColor = new InputBlock("color");
    pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    pixelColor.connectTo(fragmentOutput);
    this.addOutputNode(vertexOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.Material;
  }
  setToDefaultPostProcess() {
    this.clear();
    this.editorData = null;
    const position = new InputBlock("Position");
    position.setAsAttribute("position2d");
    const const1 = new InputBlock("Constant1");
    const1.isConstant = true;
    const1.value = 1;
    const vmerger = new VectorMergerBlock("Position3D");
    position.connectTo(vmerger);
    const1.connectTo(vmerger, { input: "w" });
    const vertexOutput = new VertexOutputBlock("VertexOutput");
    vmerger.connectTo(vertexOutput);
    const scale = new InputBlock("Scale");
    scale.visibleInInspector = true;
    scale.value = new Vector2(1, 1);
    const uv0 = new RemapBlock("uv0");
    position.connectTo(uv0);
    const uv = new MultiplyBlock("UV scale");
    uv0.connectTo(uv);
    scale.connectTo(uv);
    const currentScreen = new CurrentScreenBlock("CurrentScreen");
    uv.connectTo(currentScreen);
    currentScreen.texture = new Texture("https://assets.babylonjs.com/nme/currentScreenPostProcess.png", this.getScene());
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    currentScreen.connectTo(fragmentOutput, { output: "rgba" });
    this.addOutputNode(vertexOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.PostProcess;
  }
  setToDefaultProceduralTexture() {
    this.clear();
    this.editorData = null;
    const position = new InputBlock("Position");
    position.setAsAttribute("position2d");
    const const1 = new InputBlock("Constant1");
    const1.isConstant = true;
    const1.value = 1;
    const vmerger = new VectorMergerBlock("Position3D");
    position.connectTo(vmerger);
    const1.connectTo(vmerger, { input: "w" });
    const vertexOutput = new VertexOutputBlock("VertexOutput");
    vmerger.connectTo(vertexOutput);
    const time = new InputBlock("Time");
    time.value = 0;
    time.min = 0;
    time.max = 0;
    time.isBoolean = false;
    time.matrixMode = 0;
    time.animationType = AnimatedInputBlockTypes.Time;
    time.isConstant = false;
    const color = new InputBlock("Color3");
    color.value = new Color3(1, 1, 1);
    color.isConstant = false;
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    const vectorMerger = new VectorMergerBlock("VectorMerger");
    vectorMerger.visibleInInspector = false;
    const cos = new TrigonometryBlock("Cos");
    cos.operation = TrigonometryBlockOperations.Cos;
    position.connectTo(vectorMerger);
    time.output.connectTo(cos.input);
    cos.output.connectTo(vectorMerger.z);
    vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);
    this.addOutputNode(vertexOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.ProceduralTexture;
  }
  setToDefaultParticle() {
    this.clear();
    this.editorData = null;
    const uv = new InputBlock("uv");
    uv.setAsAttribute("particle_uv");
    const texture = new ParticleTextureBlock("ParticleTexture");
    uv.connectTo(texture);
    const color = new InputBlock("Color");
    color.setAsAttribute("particle_color");
    const multiply = new MultiplyBlock("Texture * Color");
    texture.connectTo(multiply);
    color.connectTo(multiply);
    const rampGradient = new ParticleRampGradientBlock("ParticleRampGradient");
    multiply.connectTo(rampGradient);
    const cSplitter = new ColorSplitterBlock("ColorSplitter");
    color.connectTo(cSplitter);
    const blendMultiply = new ParticleBlendMultiplyBlock("ParticleBlendMultiply");
    rampGradient.connectTo(blendMultiply);
    texture.connectTo(blendMultiply, { output: "a" });
    cSplitter.connectTo(blendMultiply, { output: "a" });
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    blendMultiply.connectTo(fragmentOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.Particle;
  }
  async loadAsync(url, rootUrl = "") {
    return NodeMaterial.ParseFromFileAsync("", url, this.getScene(), rootUrl, true, this);
  }
  _gatherBlocks(rootNode, list) {
    if (list.indexOf(rootNode) !== -1) {
      return;
    }
    list.push(rootNode);
    for (const input of rootNode.inputs) {
      const connectedPoint = input.connectedPoint;
      if (connectedPoint) {
        const block = connectedPoint.ownerBlock;
        if (block !== rootNode) {
          this._gatherBlocks(block, list);
        }
      }
    }
  }
  generateCode() {
    let alreadyDumped = [];
    const vertexBlocks = [];
    const uniqueNames = ["const", "var", "let"];
    for (const outputNode of this._vertexOutputNodes) {
      this._gatherBlocks(outputNode, vertexBlocks);
    }
    const fragmentBlocks = [];
    for (const outputNode of this._fragmentOutputNodes) {
      this._gatherBlocks(outputNode, fragmentBlocks);
    }
    let codeString = `var nodeMaterial = new BABYLON.NodeMaterial("${this.name || "node material"}");\r
`;
    for (const node of vertexBlocks) {
      if (node.isInput && alreadyDumped.indexOf(node) === -1) {
        codeString += node._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    for (const node of fragmentBlocks) {
      if (node.isInput && alreadyDumped.indexOf(node) === -1) {
        codeString += node._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    alreadyDumped = [];
    codeString += "\r\n// Connections\r\n";
    for (const node of this._vertexOutputNodes) {
      codeString += node._dumpCodeForOutputConnections(alreadyDumped);
    }
    for (const node of this._fragmentOutputNodes) {
      codeString += node._dumpCodeForOutputConnections(alreadyDumped);
    }
    codeString += "\r\n// Output nodes\r\n";
    for (const node of this._vertexOutputNodes) {
      codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\r
`;
    }
    for (const node of this._fragmentOutputNodes) {
      codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\r
`;
    }
    codeString += `nodeMaterial.build();\r
`;
    return codeString;
  }
  serialize(selectedBlocks) {
    const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);
    serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData));
    let blocks = [];
    if (selectedBlocks) {
      blocks = selectedBlocks;
    } else {
      serializationObject.customType = "BABYLON.NodeMaterial";
      serializationObject.outputNodes = [];
      for (const outputNode of this._vertexOutputNodes) {
        this._gatherBlocks(outputNode, blocks);
        serializationObject.outputNodes.push(outputNode.uniqueId);
      }
      for (const outputNode of this._fragmentOutputNodes) {
        this._gatherBlocks(outputNode, blocks);
        if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {
          serializationObject.outputNodes.push(outputNode.uniqueId);
        }
      }
    }
    serializationObject.blocks = [];
    for (const block of blocks) {
      serializationObject.blocks.push(block.serialize());
    }
    if (!selectedBlocks) {
      for (const block of this.attachedBlocks) {
        if (blocks.indexOf(block) !== -1) {
          continue;
        }
        serializationObject.blocks.push(block.serialize());
      }
    }
    return serializationObject;
  }
  _restoreConnections(block, source, map) {
    for (const outputPoint of block.outputs) {
      for (const candidate of source.blocks) {
        const target = map[candidate.id];
        if (!target) {
          continue;
        }
        for (const input of candidate.inputs) {
          if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {
            const inputPoint = target.getInputByName(input.inputName);
            if (!inputPoint || inputPoint.isConnected) {
              continue;
            }
            outputPoint.connectTo(inputPoint, true);
            this._restoreConnections(target, source, map);
            continue;
          }
        }
      }
    }
  }
  parseSerializedObject(source, rootUrl = "", merge = false) {
    var _a;
    if (!merge) {
      this.clear();
    }
    const map = {};
    for (const parsedBlock of source.blocks) {
      const blockType = GetClass(parsedBlock.customType);
      if (blockType) {
        const block = new blockType();
        block._deserialize(parsedBlock, this.getScene(), rootUrl);
        map[parsedBlock.id] = block;
        this.attachedBlocks.push(block);
      }
    }
    for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {
      const parsedBlock = source.blocks[blockIndex];
      const block = map[parsedBlock.id];
      if (!block) {
        continue;
      }
      if (block.inputs.length && !merge) {
        continue;
      }
      this._restoreConnections(block, source, map);
    }
    if (source.outputNodes) {
      for (const outputNodeId of source.outputNodes) {
        this.addOutputNode(map[outputNodeId]);
      }
    }
    if (source.locations || source.editorData && source.editorData.locations) {
      const locations = source.locations || source.editorData.locations;
      for (const location of locations) {
        if (map[location.blockId]) {
          location.blockId = map[location.blockId].uniqueId;
        }
      }
      if (merge && this.editorData && this.editorData.locations) {
        locations.concat(this.editorData.locations);
      }
      if (source.locations) {
        this.editorData = {
          locations
        };
      } else {
        this.editorData = source.editorData;
        this.editorData.locations = locations;
      }
      const blockMap = [];
      for (const key in map) {
        blockMap[key] = map[key].uniqueId;
      }
      this.editorData.map = blockMap;
    }
    this.comment = source.comment;
    if (source.forceAlphaBlending !== void 0) {
      this.forceAlphaBlending = source.forceAlphaBlending;
    }
    if (!merge) {
      this._mode = (_a = source.mode) !== null && _a !== void 0 ? _a : NodeMaterialModes.Material;
    }
  }
  loadFromSerialization(source, rootUrl = "", merge = false) {
    this.parseSerializedObject(source, rootUrl, merge);
  }
  clone(name4, shareEffect = false) {
    const serializationObject = this.serialize();
    const clone = SerializationHelper.Clone(() => new NodeMaterial(name4, this.getScene(), this.options), this);
    clone.id = name4;
    clone.name = name4;
    clone.parseSerializedObject(serializationObject);
    clone._buildId = this._buildId;
    clone.build(false, !shareEffect);
    return clone;
  }
  static Parse(source, scene, rootUrl = "") {
    const nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(source.name, scene), source, scene, rootUrl);
    nodeMaterial.parseSerializedObject(source, rootUrl);
    nodeMaterial.build();
    return nodeMaterial;
  }
  static async ParseFromFileAsync(name4, url, scene, rootUrl = "", skipBuild = false, targetMaterial) {
    const material = targetMaterial !== null && targetMaterial !== void 0 ? targetMaterial : new NodeMaterial(name4, scene);
    const data = await scene._loadFileAsync(url);
    const serializationObject = JSON.parse(data);
    material.parseSerializedObject(serializationObject, rootUrl);
    if (!skipBuild) {
      material.build();
    }
    return material;
  }
  static ParseFromSnippetAsync(snippetId, scene = EngineStore.LastCreatedScene, rootUrl = "", nodeMaterial, skipBuild = false) {
    if (snippetId === "_BLANK") {
      return Promise.resolve(NodeMaterial.CreateDefault("blank", scene));
    }
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            const serializationObject = JSON.parse(snippet.nodeMaterial);
            if (!nodeMaterial) {
              nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(snippetId, scene), serializationObject, scene, rootUrl);
              nodeMaterial.uniqueId = scene.getUniqueId();
            }
            nodeMaterial.parseSerializedObject(serializationObject);
            nodeMaterial.snippetId = snippetId;
            try {
              if (!skipBuild) {
                nodeMaterial.build();
              }
              resolve(nodeMaterial);
            } catch (err) {
              reject(err);
            }
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  }
  static CreateDefault(name4, scene) {
    const newMaterial = new NodeMaterial(name4, scene);
    newMaterial.setToDefault();
    newMaterial.build();
    return newMaterial;
  }
};
NodeMaterial._BuildIdGenerator = 0;
NodeMaterial.EditorURL = `https://unpkg.com/babylonjs-node-editor@${Engine.Version}/babylon.nodeEditor.js`;
NodeMaterial.SnippetUrl = `https://snippet.babylonjs.com`;
NodeMaterial.IgnoreTexturesAtLoadTime = false;
__decorate([
  serialize()
], NodeMaterial.prototype, "ignoreAlpha", void 0);
__decorate([
  serialize()
], NodeMaterial.prototype, "maxSimultaneousLights", void 0);
__decorate([
  serialize("mode")
], NodeMaterial.prototype, "_mode", void 0);
__decorate([
  serialize("comment")
], NodeMaterial.prototype, "comment", void 0);
__decorate([
  serialize()
], NodeMaterial.prototype, "forceAlphaBlending", void 0);
RegisterClass("BABYLON.NodeMaterial", NodeMaterial);

// node_modules/@babylonjs/core/Meshes/Builders/icoSphereBuilder.js
function CreateIcoSphereVertexData(options) {
  const sideOrientation = options.sideOrientation || VertexData.DEFAULTSIDE;
  const radius = options.radius || 1;
  const flat = options.flat === void 0 ? true : options.flat;
  const subdivisions = options.subdivisions || 4;
  const radiusX = options.radiusX || radius;
  const radiusY = options.radiusY || radius;
  const radiusZ = options.radiusZ || radius;
  const t = (1 + Math.sqrt(5)) / 2;
  const icoVertices = [
    -1,
    t,
    -0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    -1,
    t,
    0,
    1,
    t,
    t,
    0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    -1
  ];
  const ico_indices = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    12,
    22,
    23,
    1,
    5,
    20,
    5,
    11,
    4,
    23,
    22,
    13,
    22,
    18,
    6,
    7,
    1,
    8,
    14,
    21,
    4,
    14,
    4,
    2,
    16,
    13,
    6,
    15,
    6,
    19,
    3,
    8,
    9,
    4,
    21,
    5,
    13,
    17,
    23,
    6,
    13,
    22,
    19,
    6,
    18,
    9,
    8,
    1
  ];
  const vertices_unalias_id = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    0,
    2,
    3,
    3,
    3,
    4,
    7,
    8,
    9,
    9,
    10,
    11
  ];
  const ico_vertexuv = [
    5,
    1,
    3,
    1,
    6,
    4,
    0,
    0,
    5,
    3,
    4,
    2,
    2,
    2,
    4,
    0,
    2,
    0,
    1,
    1,
    6,
    0,
    6,
    2,
    0,
    4,
    3,
    3,
    4,
    4,
    3,
    1,
    4,
    2,
    4,
    4,
    0,
    2,
    1,
    1,
    2,
    2,
    3,
    3,
    1,
    3,
    2,
    4
  ];
  const ustep = 138 / 1024;
  const vstep = 239 / 1024;
  const uoffset = 60 / 1024;
  const voffset = 26 / 1024;
  const island_u_offset = -40 / 1024;
  const island_v_offset = 20 / 1024;
  const island = [
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0
  ];
  const indices = new Array();
  const positions = new Array();
  const normals = new Array();
  const uvs = new Array();
  let current_indice = 0;
  const face_vertex_pos = new Array(3);
  const face_vertex_uv = new Array(3);
  let v012;
  for (v012 = 0; v012 < 3; v012++) {
    face_vertex_pos[v012] = Vector3.Zero();
    face_vertex_uv[v012] = Vector2.Zero();
  }
  for (let face = 0; face < 20; face++) {
    for (v012 = 0; v012 < 3; v012++) {
      const v_id = ico_indices[3 * face + v012];
      face_vertex_pos[v012].copyFromFloats(icoVertices[3 * vertices_unalias_id[v_id]], icoVertices[3 * vertices_unalias_id[v_id] + 1], icoVertices[3 * vertices_unalias_id[v_id] + 2]);
      face_vertex_pos[v012].normalize();
      face_vertex_uv[v012].copyFromFloats(ico_vertexuv[2 * v_id] * ustep + uoffset + island[face] * island_u_offset, ico_vertexuv[2 * v_id + 1] * vstep + voffset + island[face] * island_v_offset);
    }
    const interp_vertex = (i1, i2, c1, c2) => {
      const pos_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], i2 / subdivisions);
      const pos_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], i2 / subdivisions);
      const pos_interp = subdivisions === i2 ? face_vertex_pos[2] : Vector3.Lerp(pos_x0, pos_x1, i1 / (subdivisions - i2));
      pos_interp.normalize();
      let vertex_normal;
      if (flat) {
        const centroid_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], c2 / subdivisions);
        const centroid_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], c2 / subdivisions);
        vertex_normal = Vector3.Lerp(centroid_x0, centroid_x1, c1 / (subdivisions - c2));
      } else {
        vertex_normal = new Vector3(pos_interp.x, pos_interp.y, pos_interp.z);
      }
      vertex_normal.x /= radiusX;
      vertex_normal.y /= radiusY;
      vertex_normal.z /= radiusZ;
      vertex_normal.normalize();
      const uv_x0 = Vector2.Lerp(face_vertex_uv[0], face_vertex_uv[2], i2 / subdivisions);
      const uv_x1 = Vector2.Lerp(face_vertex_uv[1], face_vertex_uv[2], i2 / subdivisions);
      const uv_interp = subdivisions === i2 ? face_vertex_uv[2] : Vector2.Lerp(uv_x0, uv_x1, i1 / (subdivisions - i2));
      positions.push(pos_interp.x * radiusX, pos_interp.y * radiusY, pos_interp.z * radiusZ);
      normals.push(vertex_normal.x, vertex_normal.y, vertex_normal.z);
      uvs.push(uv_interp.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - uv_interp.y : uv_interp.y);
      indices.push(current_indice);
      current_indice++;
    };
    for (let i2 = 0; i2 < subdivisions; i2++) {
      for (let i1 = 0; i1 + i2 < subdivisions; i1++) {
        interp_vertex(i1, i2, i1 + 1 / 3, i2 + 1 / 3);
        interp_vertex(i1 + 1, i2, i1 + 1 / 3, i2 + 1 / 3);
        interp_vertex(i1, i2 + 1, i1 + 1 / 3, i2 + 1 / 3);
        if (i1 + i2 + 1 < subdivisions) {
          interp_vertex(i1 + 1, i2, i1 + 2 / 3, i2 + 2 / 3);
          interp_vertex(i1 + 1, i2 + 1, i1 + 2 / 3, i2 + 2 / 3);
          interp_vertex(i1, i2 + 1, i1 + 2 / 3, i2 + 2 / 3);
        }
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateIcoSphere(name4, options = {}, scene = null) {
  const sphere = new Mesh(name4, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  sphere._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateIcoSphereVertexData(options);
  vertexData.applyToMesh(sphere, options.updatable);
  return sphere;
}
var IcoSphereBuilder = {
  CreateIcoSphere
};
VertexData.CreateIcoSphere = CreateIcoSphereVertexData;
Mesh.CreateIcoSphere = (name4, options, scene) => {
  return CreateIcoSphere(name4, options, scene);
};

// node_modules/@babylonjs/core/XR/features/WebXRHandTracking.js
var HandPart;
(function(HandPart2) {
  HandPart2["WRIST"] = "wrist";
  HandPart2["THUMB"] = "thumb";
  HandPart2["INDEX"] = "index";
  HandPart2["MIDDLE"] = "middle";
  HandPart2["RING"] = "ring";
  HandPart2["LITTLE"] = "little";
})(HandPart || (HandPart = {}));
var WebXRHandJoint;
(function(WebXRHandJoint2) {
  WebXRHandJoint2["WRIST"] = "wrist";
  WebXRHandJoint2["THUMB_METACARPAL"] = "thumb-metacarpal";
  WebXRHandJoint2["THUMB_PHALANX_PROXIMAL"] = "thumb-phalanx-proximal";
  WebXRHandJoint2["THUMB_PHALANX_DISTAL"] = "thumb-phalanx-distal";
  WebXRHandJoint2["THUMB_TIP"] = "thumb-tip";
  WebXRHandJoint2["INDEX_FINGER_METACARPAL"] = "index-finger-metacarpal";
  WebXRHandJoint2["INDEX_FINGER_PHALANX_PROXIMAL"] = "index-finger-phalanx-proximal";
  WebXRHandJoint2["INDEX_FINGER_PHALANX_INTERMEDIATE"] = "index-finger-phalanx-intermediate";
  WebXRHandJoint2["INDEX_FINGER_PHALANX_DISTAL"] = "index-finger-phalanx-distal";
  WebXRHandJoint2["INDEX_FINGER_TIP"] = "index-finger-tip";
  WebXRHandJoint2["MIDDLE_FINGER_METACARPAL"] = "middle-finger-metacarpal";
  WebXRHandJoint2["MIDDLE_FINGER_PHALANX_PROXIMAL"] = "middle-finger-phalanx-proximal";
  WebXRHandJoint2["MIDDLE_FINGER_PHALANX_INTERMEDIATE"] = "middle-finger-phalanx-intermediate";
  WebXRHandJoint2["MIDDLE_FINGER_PHALANX_DISTAL"] = "middle-finger-phalanx-distal";
  WebXRHandJoint2["MIDDLE_FINGER_TIP"] = "middle-finger-tip";
  WebXRHandJoint2["RING_FINGER_METACARPAL"] = "ring-finger-metacarpal";
  WebXRHandJoint2["RING_FINGER_PHALANX_PROXIMAL"] = "ring-finger-phalanx-proximal";
  WebXRHandJoint2["RING_FINGER_PHALANX_INTERMEDIATE"] = "ring-finger-phalanx-intermediate";
  WebXRHandJoint2["RING_FINGER_PHALANX_DISTAL"] = "ring-finger-phalanx-distal";
  WebXRHandJoint2["RING_FINGER_TIP"] = "ring-finger-tip";
  WebXRHandJoint2["PINKY_FINGER_METACARPAL"] = "pinky-finger-metacarpal";
  WebXRHandJoint2["PINKY_FINGER_PHALANX_PROXIMAL"] = "pinky-finger-phalanx-proximal";
  WebXRHandJoint2["PINKY_FINGER_PHALANX_INTERMEDIATE"] = "pinky-finger-phalanx-intermediate";
  WebXRHandJoint2["PINKY_FINGER_PHALANX_DISTAL"] = "pinky-finger-phalanx-distal";
  WebXRHandJoint2["PINKY_FINGER_TIP"] = "pinky-finger-tip";
})(WebXRHandJoint || (WebXRHandJoint = {}));
var handJointReferenceArray = [
  WebXRHandJoint.WRIST,
  WebXRHandJoint.THUMB_METACARPAL,
  WebXRHandJoint.THUMB_PHALANX_PROXIMAL,
  WebXRHandJoint.THUMB_PHALANX_DISTAL,
  WebXRHandJoint.THUMB_TIP,
  WebXRHandJoint.INDEX_FINGER_METACARPAL,
  WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,
  WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,
  WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL,
  WebXRHandJoint.INDEX_FINGER_TIP,
  WebXRHandJoint.MIDDLE_FINGER_METACARPAL,
  WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,
  WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,
  WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,
  WebXRHandJoint.MIDDLE_FINGER_TIP,
  WebXRHandJoint.RING_FINGER_METACARPAL,
  WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL,
  WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,
  WebXRHandJoint.RING_FINGER_PHALANX_DISTAL,
  WebXRHandJoint.RING_FINGER_TIP,
  WebXRHandJoint.PINKY_FINGER_METACARPAL,
  WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,
  WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,
  WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL,
  WebXRHandJoint.PINKY_FINGER_TIP
];
var handPartsDefinition = {
  [HandPart.WRIST]: [WebXRHandJoint.WRIST],
  [HandPart.THUMB]: [WebXRHandJoint.THUMB_METACARPAL, WebXRHandJoint.THUMB_PHALANX_PROXIMAL, WebXRHandJoint.THUMB_PHALANX_DISTAL, WebXRHandJoint.THUMB_TIP],
  [HandPart.INDEX]: [
    WebXRHandJoint.INDEX_FINGER_METACARPAL,
    WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,
    WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,
    WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL,
    WebXRHandJoint.INDEX_FINGER_TIP
  ],
  [HandPart.MIDDLE]: [
    WebXRHandJoint.MIDDLE_FINGER_METACARPAL,
    WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,
    WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,
    WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,
    WebXRHandJoint.MIDDLE_FINGER_TIP
  ],
  [HandPart.RING]: [
    WebXRHandJoint.RING_FINGER_METACARPAL,
    WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL,
    WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,
    WebXRHandJoint.RING_FINGER_PHALANX_DISTAL,
    WebXRHandJoint.RING_FINGER_TIP
  ],
  [HandPart.LITTLE]: [
    WebXRHandJoint.PINKY_FINGER_METACARPAL,
    WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,
    WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,
    WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL,
    WebXRHandJoint.PINKY_FINGER_TIP
  ]
};
var WebXRHand = class {
  constructor(xrController, _jointMeshes, _handMesh, rigMapping, _leftHandedMeshes = false, _jointsInvisible = false, _jointScaleFactor = 1) {
    this.xrController = xrController;
    this._jointMeshes = _jointMeshes;
    this._handMesh = _handMesh;
    this.rigMapping = rigMapping;
    this._leftHandedMeshes = _leftHandedMeshes;
    this._jointsInvisible = _jointsInvisible;
    this._jointScaleFactor = _jointScaleFactor;
    this._jointTransforms = new Array(handJointReferenceArray.length);
    this._jointTransformMatrices = new Float32Array(handJointReferenceArray.length * 16);
    this._tempJointMatrix = new Matrix();
    this._jointRadii = new Float32Array(handJointReferenceArray.length);
    this._scene = _jointMeshes[0].getScene();
    for (let jointIdx = 0; jointIdx < this._jointTransforms.length; jointIdx++) {
      const jointTransform = this._jointTransforms[jointIdx] = new TransformNode(handJointReferenceArray[jointIdx], this._scene);
      jointTransform.rotationQuaternion = new Quaternion();
      _jointMeshes[jointIdx].rotationQuaternion = new Quaternion();
    }
    if (_handMesh) {
      this.setHandMesh(_handMesh, rigMapping);
    }
    if (this.xrController.motionController) {
      if (this.xrController.motionController.rootMesh) {
        this.xrController.motionController.rootMesh.setEnabled(false);
      } else {
        this.xrController.motionController.onModelLoadedObservable.add((controller) => {
          if (controller.rootMesh) {
            controller.rootMesh.setEnabled(false);
          }
        });
      }
    }
    this.xrController.onMotionControllerInitObservable.add((motionController) => {
      motionController.onModelLoadedObservable.add((controller) => {
        if (controller.rootMesh) {
          controller.rootMesh.setEnabled(false);
        }
      });
      if (motionController.rootMesh) {
        motionController.rootMesh.setEnabled(false);
      }
    });
  }
  get handMesh() {
    return this._handMesh;
  }
  getHandPartMeshes(part) {
    return handPartsDefinition[part].map((name4) => this._jointMeshes[handJointReferenceArray.indexOf(name4)]);
  }
  getJointMesh(jointName) {
    return this._jointMeshes[handJointReferenceArray.indexOf(jointName)];
  }
  setHandMesh(handMesh, rigMapping) {
    this._handMesh = handMesh;
    handMesh.alwaysSelectAsActiveMesh = true;
    handMesh.getChildMeshes().forEach((mesh) => mesh.alwaysSelectAsActiveMesh = true);
    if (this._handMesh.skeleton) {
      const handMeshSkeleton = this._handMesh.skeleton;
      handJointReferenceArray.forEach((jointName, jointIdx) => {
        const jointBoneIdx = handMeshSkeleton.getBoneIndexByName(rigMapping ? rigMapping[jointName] : jointName);
        if (jointBoneIdx !== -1) {
          handMeshSkeleton.bones[jointBoneIdx].linkTransformNode(this._jointTransforms[jointIdx]);
        }
      });
    }
  }
  updateFromXRFrame(xrFrame, referenceSpace) {
    const hand = this.xrController.inputSource.hand;
    if (!hand) {
      return;
    }
    const anyHand = hand;
    const jointSpaces = handJointReferenceArray.map((jointName) => anyHand[jointName] || hand.get(jointName));
    let trackingSuccessful = false;
    if (xrFrame.fillPoses && xrFrame.fillJointRadii) {
      trackingSuccessful = xrFrame.fillPoses(jointSpaces, referenceSpace, this._jointTransformMatrices) && xrFrame.fillJointRadii(jointSpaces, this._jointRadii);
    } else if (xrFrame.getJointPose) {
      trackingSuccessful = true;
      for (let jointIdx = 0; jointIdx < jointSpaces.length; jointIdx++) {
        const jointPose = xrFrame.getJointPose(jointSpaces[jointIdx], referenceSpace);
        if (jointPose) {
          this._jointTransformMatrices.set(jointPose.transform.matrix, jointIdx * 16);
          this._jointRadii[jointIdx] = jointPose.radius || 8e-3;
        } else {
          trackingSuccessful = false;
          break;
        }
      }
    }
    if (!trackingSuccessful) {
      return;
    }
    handJointReferenceArray.forEach((_jointName, jointIdx) => {
      const jointTransform = this._jointTransforms[jointIdx];
      Matrix.FromArrayToRef(this._jointTransformMatrices, jointIdx * 16, this._tempJointMatrix);
      this._tempJointMatrix.decompose(void 0, jointTransform.rotationQuaternion, jointTransform.position);
      const scaledJointRadius = this._jointRadii[jointIdx] * this._jointScaleFactor;
      const jointMesh = this._jointMeshes[jointIdx];
      jointMesh.isVisible = !this._handMesh && !this._jointsInvisible;
      jointMesh.position.copyFrom(jointTransform.position);
      jointMesh.rotationQuaternion.copyFrom(jointTransform.rotationQuaternion);
      jointMesh.scaling.setAll(scaledJointRadius);
      if (!this._scene.useRightHandedSystem) {
        jointMesh.position.z *= -1;
        jointMesh.rotationQuaternion.z *= -1;
        jointMesh.rotationQuaternion.w *= -1;
        if (this._leftHandedMeshes && this._handMesh) {
          jointTransform.position.z *= -1;
          jointTransform.rotationQuaternion.z *= -1;
          jointTransform.rotationQuaternion.w *= -1;
        }
      }
    });
    if (this._handMesh) {
      this._handMesh.isVisible = true;
    }
  }
  dispose() {
    if (this._handMesh) {
      this._handMesh.isVisible = false;
    }
  }
};
var WebXRHandTracking = class extends WebXRAbstractFeature {
  constructor(_xrSessionManager, options) {
    super(_xrSessionManager);
    this.options = options;
    this._attachedHands = {};
    this._trackingHands = { left: null, right: null };
    this._handResources = { jointMeshes: null, handMeshes: null, rigMappings: null };
    this.onHandAddedObservable = new Observable();
    this.onHandRemovedObservable = new Observable();
    this._attachHand = (xrController) => {
      var _a, _b, _c;
      if (!xrController.inputSource.hand || xrController.inputSource.handedness == "none" || !this._handResources.jointMeshes) {
        return;
      }
      const handedness = xrController.inputSource.handedness;
      const webxrHand = new WebXRHand(xrController, this._handResources.jointMeshes[handedness], this._handResources.handMeshes && this._handResources.handMeshes[handedness], this._handResources.rigMappings && this._handResources.rigMappings[handedness], (_a = this.options.handMeshes) === null || _a === void 0 ? void 0 : _a.meshesUseLeftHandedCoordinates, (_b = this.options.jointMeshes) === null || _b === void 0 ? void 0 : _b.invisible, (_c = this.options.jointMeshes) === null || _c === void 0 ? void 0 : _c.scaleFactor);
      this._attachedHands[xrController.uniqueId] = webxrHand;
      this._trackingHands[handedness] = webxrHand;
      this.onHandAddedObservable.notifyObservers(webxrHand);
    };
    this._detachHand = (xrController) => {
      this._detachHandById(xrController.uniqueId);
    };
    this.xrNativeFeatureName = "hand-tracking";
    const anyOptions = options;
    const anyJointMeshOptions = anyOptions.jointMeshes;
    if (anyJointMeshOptions) {
      if (typeof anyJointMeshOptions.disableDefaultHandMesh !== "undefined") {
        options.handMeshes = options.handMeshes || {};
        options.handMeshes.disableDefaultMeshes = anyJointMeshOptions.disableDefaultHandMesh;
      }
      if (typeof anyJointMeshOptions.handMeshes !== "undefined") {
        options.handMeshes = options.handMeshes || {};
        options.handMeshes.customMeshes = anyJointMeshOptions.handMeshes;
      }
      if (typeof anyJointMeshOptions.leftHandedSystemMeshes !== "undefined") {
        options.handMeshes = options.handMeshes || {};
        options.handMeshes.meshesUseLeftHandedCoordinates = anyJointMeshOptions.leftHandedSystemMeshes;
      }
      if (typeof anyJointMeshOptions.rigMapping !== "undefined") {
        options.handMeshes = options.handMeshes || {};
        const leftRigMapping = {};
        const rightRigMapping = {};
        [
          [anyJointMeshOptions.rigMapping.left, leftRigMapping],
          [anyJointMeshOptions.rigMapping.right, rightRigMapping]
        ].forEach((rigMappingTuple) => {
          const legacyRigMapping = rigMappingTuple[0];
          const rigMapping = rigMappingTuple[1];
          legacyRigMapping.forEach((modelJointName, index) => {
            rigMapping[handJointReferenceArray[index]] = modelJointName;
          });
        });
        options.handMeshes.customRigMappings = {
          left: leftRigMapping,
          right: rightRigMapping
        };
      }
    }
  }
  static _GenerateTrackedJointMeshes(featureOptions) {
    const meshes = {};
    ["left", "right"].map((handedness) => {
      var _a, _b, _c, _d, _e;
      const trackedMeshes = [];
      const originalMesh = ((_a = featureOptions.jointMeshes) === null || _a === void 0 ? void 0 : _a.sourceMesh) || CreateIcoSphere("jointParent", WebXRHandTracking._ICOSPHERE_PARAMS);
      originalMesh.isVisible = !!((_b = featureOptions.jointMeshes) === null || _b === void 0 ? void 0 : _b.keepOriginalVisible);
      for (let i = 0; i < handJointReferenceArray.length; ++i) {
        let newInstance = originalMesh.createInstance(`${handedness}-handJoint-${i}`);
        if ((_c = featureOptions.jointMeshes) === null || _c === void 0 ? void 0 : _c.onHandJointMeshGenerated) {
          const returnedMesh = featureOptions.jointMeshes.onHandJointMeshGenerated(newInstance, i, handedness);
          if (returnedMesh) {
            if (returnedMesh !== newInstance) {
              newInstance.dispose();
              newInstance = returnedMesh;
            }
          }
        }
        newInstance.isPickable = false;
        if ((_d = featureOptions.jointMeshes) === null || _d === void 0 ? void 0 : _d.enablePhysics) {
          const props = ((_e = featureOptions.jointMeshes) === null || _e === void 0 ? void 0 : _e.physicsProps) || {};
          newInstance.scaling.setAll(0.02);
          const type = props.impostorType !== void 0 ? props.impostorType : PhysicsImpostor.SphereImpostor;
          newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, { mass: 0, ...props });
        }
        newInstance.rotationQuaternion = new Quaternion();
        newInstance.isVisible = false;
        trackedMeshes.push(newInstance);
      }
      meshes[handedness] = trackedMeshes;
    });
    return { left: meshes.left, right: meshes.right };
  }
  static _GenerateDefaultHandMeshesAsync(scene, options) {
    return new Promise(async (resolve) => {
      var _a, _b, _c, _d, _e;
      const riggedMeshes = {};
      if ((_b = (_a = WebXRHandTracking._RightHandGLB) === null || _a === void 0 ? void 0 : _a.meshes[1]) === null || _b === void 0 ? void 0 : _b.isDisposed()) {
        WebXRHandTracking._RightHandGLB = null;
      }
      if ((_d = (_c = WebXRHandTracking._LeftHandGLB) === null || _c === void 0 ? void 0 : _c.meshes[1]) === null || _d === void 0 ? void 0 : _d.isDisposed()) {
        WebXRHandTracking._LeftHandGLB = null;
      }
      const handsDefined = !!(WebXRHandTracking._RightHandGLB && WebXRHandTracking._LeftHandGLB);
      const handGLBs = await Promise.all([
        WebXRHandTracking._RightHandGLB || SceneLoader.ImportMeshAsync("", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME, scene),
        WebXRHandTracking._LeftHandGLB || SceneLoader.ImportMeshAsync("", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME, scene)
      ]);
      WebXRHandTracking._RightHandGLB = handGLBs[0];
      WebXRHandTracking._LeftHandGLB = handGLBs[1];
      const handShader = new NodeMaterial("handShader", scene, { emitComments: false });
      await handShader.loadAsync(WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL);
      handShader.needDepthPrePass = true;
      handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;
      handShader.alphaMode = 2;
      handShader.build(false);
      const handColors = {
        base: Color3.FromInts(116, 63, 203),
        fresnel: Color3.FromInts(149, 102, 229),
        fingerColor: Color3.FromInts(177, 130, 255),
        tipFresnel: Color3.FromInts(220, 200, 255),
        ...(_e = options === null || options === void 0 ? void 0 : options.handMeshes) === null || _e === void 0 ? void 0 : _e.customColors
      };
      const handNodes = {
        base: handShader.getBlockByName("baseColor"),
        fresnel: handShader.getBlockByName("fresnelColor"),
        fingerColor: handShader.getBlockByName("fingerColor"),
        tipFresnel: handShader.getBlockByName("tipFresnelColor")
      };
      handNodes.base.value = handColors.base;
      handNodes.fresnel.value = handColors.fresnel;
      handNodes.fingerColor.value = handColors.fingerColor;
      handNodes.tipFresnel.value = handColors.tipFresnel;
      ["left", "right"].forEach((handedness) => {
        const handGLB = handedness == "left" ? WebXRHandTracking._LeftHandGLB : WebXRHandTracking._RightHandGLB;
        if (!handGLB) {
          throw new Error("Could not load hand model");
        }
        const handMesh = handGLB.meshes[1];
        handMesh._internalAbstractMeshDataInfo._computeBonesUsingShaders = true;
        handMesh.material = handShader.clone(`${handedness}HandShaderClone`, true);
        handMesh.isVisible = false;
        riggedMeshes[handedness] = handMesh;
        if (!handsDefined && !scene.useRightHandedSystem) {
          handGLB.meshes[1].rotate(Axis.Y, Math.PI);
        }
      });
      handShader.dispose();
      resolve({ left: riggedMeshes.left, right: riggedMeshes.right });
    });
  }
  static _GenerateDefaultHandMeshRigMapping(handedness) {
    const H = handedness == "right" ? "R" : "L";
    return {
      [WebXRHandJoint.WRIST]: `wrist_${H}`,
      [WebXRHandJoint.THUMB_METACARPAL]: `thumb_metacarpal_${H}`,
      [WebXRHandJoint.THUMB_PHALANX_PROXIMAL]: `thumb_proxPhalanx_${H}`,
      [WebXRHandJoint.THUMB_PHALANX_DISTAL]: `thumb_distPhalanx_${H}`,
      [WebXRHandJoint.THUMB_TIP]: `thumb_tip_${H}`,
      [WebXRHandJoint.INDEX_FINGER_METACARPAL]: `index_metacarpal_${H}`,
      [WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL]: `index_proxPhalanx_${H}`,
      [WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE]: `index_intPhalanx_${H}`,
      [WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL]: `index_distPhalanx_${H}`,
      [WebXRHandJoint.INDEX_FINGER_TIP]: `index_tip_${H}`,
      [WebXRHandJoint.MIDDLE_FINGER_METACARPAL]: `middle_metacarpal_${H}`,
      [WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL]: `middle_proxPhalanx_${H}`,
      [WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE]: `middle_intPhalanx_${H}`,
      [WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL]: `middle_distPhalanx_${H}`,
      [WebXRHandJoint.MIDDLE_FINGER_TIP]: `middle_tip_${H}`,
      [WebXRHandJoint.RING_FINGER_METACARPAL]: `ring_metacarpal_${H}`,
      [WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL]: `ring_proxPhalanx_${H}`,
      [WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE]: `ring_intPhalanx_${H}`,
      [WebXRHandJoint.RING_FINGER_PHALANX_DISTAL]: `ring_distPhalanx_${H}`,
      [WebXRHandJoint.RING_FINGER_TIP]: `ring_tip_${H}`,
      [WebXRHandJoint.PINKY_FINGER_METACARPAL]: `little_metacarpal_${H}`,
      [WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL]: `little_proxPhalanx_${H}`,
      [WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE]: `little_intPhalanx_${H}`,
      [WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL]: `little_distPhalanx_${H}`,
      [WebXRHandJoint.PINKY_FINGER_TIP]: `little_tip_${H}`
    };
  }
  isCompatible() {
    return typeof XRHand !== "undefined";
  }
  getHandByControllerId(controllerId) {
    return this._attachedHands[controllerId];
  }
  getHandByHandedness(handedness) {
    if (handedness == "none") {
      return null;
    }
    return this._trackingHands[handedness];
  }
  attach() {
    var _a, _b, _c, _d;
    if (!super.attach()) {
      return false;
    }
    this._handResources = {
      jointMeshes: WebXRHandTracking._GenerateTrackedJointMeshes(this.options),
      handMeshes: ((_a = this.options.handMeshes) === null || _a === void 0 ? void 0 : _a.customMeshes) || null,
      rigMappings: ((_b = this.options.handMeshes) === null || _b === void 0 ? void 0 : _b.customRigMappings) || null
    };
    if (!((_c = this.options.handMeshes) === null || _c === void 0 ? void 0 : _c.customMeshes) && !((_d = this.options.handMeshes) === null || _d === void 0 ? void 0 : _d.disableDefaultMeshes)) {
      WebXRHandTracking._GenerateDefaultHandMeshesAsync(EngineStore.LastCreatedScene, this.options).then((defaultHandMeshes) => {
        var _a2, _b2;
        this._handResources.handMeshes = defaultHandMeshes;
        this._handResources.rigMappings = {
          left: WebXRHandTracking._GenerateDefaultHandMeshRigMapping("left"),
          right: WebXRHandTracking._GenerateDefaultHandMeshRigMapping("right")
        };
        (_a2 = this._trackingHands.left) === null || _a2 === void 0 ? void 0 : _a2.setHandMesh(this._handResources.handMeshes.left, this._handResources.rigMappings.left);
        (_b2 = this._trackingHands.right) === null || _b2 === void 0 ? void 0 : _b2.setHandMesh(this._handResources.handMeshes.right, this._handResources.rigMappings.right);
      });
    }
    this.options.xrInput.controllers.forEach(this._attachHand);
    this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);
    this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, this._detachHand);
    return true;
  }
  _onXRFrame(_xrFrame) {
    var _a, _b;
    (_a = this._trackingHands.left) === null || _a === void 0 ? void 0 : _a.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);
    (_b = this._trackingHands.right) === null || _b === void 0 ? void 0 : _b.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);
  }
  _detachHandById(controllerId) {
    var _a;
    const hand = this.getHandByControllerId(controllerId);
    if (hand) {
      const handedness = hand.xrController.inputSource.handedness == "left" ? "left" : "right";
      if (((_a = this._trackingHands[handedness]) === null || _a === void 0 ? void 0 : _a.xrController.uniqueId) === controllerId) {
        this._trackingHands[handedness] = null;
      }
      this.onHandRemovedObservable.notifyObservers(hand);
      hand.dispose();
      delete this._attachedHands[controllerId];
    }
  }
  detach() {
    if (!super.detach()) {
      return false;
    }
    Object.keys(this._attachedHands).forEach((uniqueId) => this._detachHandById(uniqueId));
    return true;
  }
  dispose() {
    var _a;
    super.dispose();
    this.onHandAddedObservable.clear();
    this.onHandRemovedObservable.clear();
    if (this._handResources.handMeshes && !((_a = this.options.handMeshes) === null || _a === void 0 ? void 0 : _a.customMeshes)) {
      this._handResources.handMeshes.left.dispose();
      this._handResources.handMeshes.right.dispose();
      WebXRHandTracking._RightHandGLB = null;
      WebXRHandTracking._LeftHandGLB = null;
    }
    if (this._handResources.jointMeshes) {
      this._handResources.jointMeshes.left.forEach((trackedMesh) => trackedMesh.dispose());
      this._handResources.jointMeshes.right.forEach((trackedMesh) => trackedMesh.dispose());
    }
  }
};
WebXRHandTracking.Name = WebXRFeatureName.HAND_TRACKING;
WebXRHandTracking.Version = 1;
WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL = "https://assets.babylonjs.com/meshes/HandMeshes/";
WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME = "r_hand_rhs.glb";
WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME = "l_hand_rhs.glb";
WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL = "https://assets.babylonjs.com/meshes/HandMeshes/handsShader.json";
WebXRHandTracking._ICOSPHERE_PARAMS = { radius: 0.5, flat: false, subdivisions: 2 };
WebXRHandTracking._RightHandGLB = null;
WebXRHandTracking._LeftHandGLB = null;
WebXRFeaturesManager.AddWebXRFeature(WebXRHandTracking.Name, (xrSessionManager, options) => {
  return () => new WebXRHandTracking(xrSessionManager, options);
}, WebXRHandTracking.Version, false);

// node_modules/@babylonjs/core/Behaviors/Meshes/handConstraintBehavior.js
var HandConstraintZone;
(function(HandConstraintZone2) {
  HandConstraintZone2[HandConstraintZone2["ABOVE_FINGER_TIPS"] = 0] = "ABOVE_FINGER_TIPS";
  HandConstraintZone2[HandConstraintZone2["RADIAL_SIDE"] = 1] = "RADIAL_SIDE";
  HandConstraintZone2[HandConstraintZone2["ULNAR_SIDE"] = 2] = "ULNAR_SIDE";
  HandConstraintZone2[HandConstraintZone2["BELOW_WRIST"] = 3] = "BELOW_WRIST";
})(HandConstraintZone || (HandConstraintZone = {}));
var HandConstraintOrientation;
(function(HandConstraintOrientation2) {
  HandConstraintOrientation2[HandConstraintOrientation2["LOOK_AT_CAMERA"] = 0] = "LOOK_AT_CAMERA";
  HandConstraintOrientation2[HandConstraintOrientation2["HAND_ROTATION"] = 1] = "HAND_ROTATION";
})(HandConstraintOrientation || (HandConstraintOrientation = {}));
var HandConstraintVisibility;
(function(HandConstraintVisibility2) {
  HandConstraintVisibility2[HandConstraintVisibility2["ALWAYS_VISIBLE"] = 0] = "ALWAYS_VISIBLE";
  HandConstraintVisibility2[HandConstraintVisibility2["PALM_UP"] = 1] = "PALM_UP";
  HandConstraintVisibility2[HandConstraintVisibility2["GAZE_FOCUS"] = 2] = "GAZE_FOCUS";
  HandConstraintVisibility2[HandConstraintVisibility2["PALM_AND_GAZE"] = 3] = "PALM_AND_GAZE";
})(HandConstraintVisibility || (HandConstraintVisibility = {}));
var HandConstraintBehavior = class {
  constructor() {
    this._sceneRenderObserver = null;
    this._zoneAxis = {};
    this.handConstraintVisibility = HandConstraintVisibility.PALM_AND_GAZE;
    this.palmUpStrictness = 0.95;
    this.gazeProximityRadius = 0.15;
    this.targetOffset = 0.1;
    this.targetZone = HandConstraintZone.ULNAR_SIDE;
    this.zoneOrientationMode = HandConstraintOrientation.HAND_ROTATION;
    this.nodeOrientationMode = HandConstraintOrientation.HAND_ROTATION;
    this.handedness = "none";
    this.lerpTime = 100;
    this._zoneAxis[HandConstraintZone.ABOVE_FINGER_TIPS] = new Vector3(0, 1, 0);
    this._zoneAxis[HandConstraintZone.RADIAL_SIDE] = new Vector3(-1, 0, 0);
    this._zoneAxis[HandConstraintZone.ULNAR_SIDE] = new Vector3(1, 0, 0);
    this._zoneAxis[HandConstraintZone.BELOW_WRIST] = new Vector3(0, -1, 0);
  }
  get name() {
    return "HandConstraint";
  }
  enable() {
    this._node.setEnabled(true);
  }
  disable() {
    this._node.setEnabled(false);
  }
  _getHandPose() {
    if (!this._handTracking) {
      return null;
    }
    let hand;
    if (this.handedness === "none") {
      hand = this._handTracking.getHandByHandedness("left") || this._handTracking.getHandByHandedness("right");
    } else {
      hand = this._handTracking.getHandByHandedness(this.handedness);
    }
    if (hand) {
      const pinkyMetacarpal = hand.getJointMesh(WebXRHandJoint.PINKY_FINGER_METACARPAL);
      const middleMetacarpal = hand.getJointMesh(WebXRHandJoint.MIDDLE_FINGER_METACARPAL);
      const wrist = hand.getJointMesh(WebXRHandJoint.WRIST);
      if (wrist && middleMetacarpal && pinkyMetacarpal) {
        const handPose = { position: middleMetacarpal.absolutePosition, quaternion: new Quaternion(), id: hand.xrController.uniqueId };
        const up = TmpVectors.Vector3[0];
        const forward = TmpVectors.Vector3[1];
        const left = TmpVectors.Vector3[2];
        up.copyFrom(middleMetacarpal.absolutePosition).subtractInPlace(wrist.absolutePosition).normalize();
        forward.copyFrom(pinkyMetacarpal.absolutePosition).subtractInPlace(middleMetacarpal.absolutePosition).normalize();
        Vector3.CrossToRef(up, forward, forward);
        Vector3.CrossToRef(forward, up, left);
        Quaternion.FromLookDirectionLHToRef(forward, up, handPose.quaternion);
        return handPose;
      }
    }
    return null;
  }
  init() {
  }
  attach(node) {
    this._node = node;
    this._scene = node.getScene();
    if (!this._node.rotationQuaternion) {
      this._node.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._node.rotation.y, this._node.rotation.x, this._node.rotation.z);
    }
    let lastTick = Date.now();
    this._sceneRenderObserver = this._scene.onBeforeRenderObservable.add(() => {
      const pose = this._getHandPose();
      this._node.reservedDataStore = this._node.reservedDataStore || {};
      this._node.reservedDataStore.nearInteraction = this._node.reservedDataStore.nearInteraction || {};
      this._node.reservedDataStore.nearInteraction.excludedControllerId = null;
      if (pose) {
        const zoneOffset = TmpVectors.Vector3[0];
        const camera = this._scene.activeCamera;
        zoneOffset.copyFrom(this._zoneAxis[this.targetZone]);
        const cameraLookAtQuaternion = TmpVectors.Quaternion[0];
        if (camera && (this.zoneOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA || this.nodeOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA)) {
          const toCamera = TmpVectors.Vector3[1];
          toCamera.copyFrom(camera.position).subtractInPlace(pose.position).normalize();
          if (this._scene.useRightHandedSystem) {
            Quaternion.FromLookDirectionRHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);
          } else {
            Quaternion.FromLookDirectionLHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);
          }
        }
        if (this.zoneOrientationMode === HandConstraintOrientation.HAND_ROTATION) {
          pose.quaternion.toRotationMatrix(TmpVectors.Matrix[0]);
        } else {
          cameraLookAtQuaternion.toRotationMatrix(TmpVectors.Matrix[0]);
        }
        Vector3.TransformNormalToRef(zoneOffset, TmpVectors.Matrix[0], zoneOffset);
        zoneOffset.scaleInPlace(this.targetOffset);
        const targetPosition = TmpVectors.Vector3[2];
        const targetRotation = TmpVectors.Quaternion[1];
        targetPosition.copyFrom(pose.position).addInPlace(zoneOffset);
        if (this.nodeOrientationMode === HandConstraintOrientation.HAND_ROTATION) {
          targetRotation.copyFrom(pose.quaternion);
        } else {
          targetRotation.copyFrom(cameraLookAtQuaternion);
        }
        const elapsed = Date.now() - lastTick;
        Vector3.SmoothToRef(this._node.position, targetPosition, elapsed, this.lerpTime, this._node.position);
        Quaternion.SmoothToRef(this._node.rotationQuaternion, targetRotation, elapsed, this.lerpTime, this._node.rotationQuaternion);
        this._node.reservedDataStore.nearInteraction.excludedControllerId = pose.id;
      }
      this._setVisibility(pose);
      lastTick = Date.now();
    });
  }
  _setVisibility(pose) {
    let palmVisible = true;
    let gazeVisible = true;
    const camera = this._scene.activeCamera;
    if (camera) {
      const cameraForward = camera.getForwardRay();
      if (this.handConstraintVisibility === HandConstraintVisibility.GAZE_FOCUS || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {
        gazeVisible = false;
        let gaze;
        if (this._eyeTracking) {
          gaze = this._eyeTracking.getEyeGaze();
        }
        gaze = gaze || cameraForward;
        const gazeToBehavior = TmpVectors.Vector3[0];
        if (pose) {
          pose.position.subtractToRef(gaze.origin, gazeToBehavior);
        } else {
          this._node.getAbsolutePosition().subtractToRef(gaze.origin, gazeToBehavior);
        }
        const projectedDistance = Vector3.Dot(gazeToBehavior, gaze.direction);
        const projectedSquared = projectedDistance * projectedDistance;
        if (projectedDistance > 0) {
          const radiusSquared = gazeToBehavior.lengthSquared() - projectedSquared;
          if (radiusSquared < this.gazeProximityRadius * this.gazeProximityRadius) {
            gazeVisible = true;
          }
        }
      }
      if (this.handConstraintVisibility === HandConstraintVisibility.PALM_UP || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {
        palmVisible = false;
        if (pose) {
          const palmDirection = TmpVectors.Vector3[0];
          Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(pose.quaternion, palmDirection);
          if (Vector3.Dot(palmDirection, cameraForward.direction) > this.palmUpStrictness * 2 - 1) {
            palmVisible = true;
          }
        }
      }
    }
    this._node.setEnabled(palmVisible && gazeVisible);
  }
  detach() {
    this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);
  }
  linkToXRExperience(xr) {
    try {
      this._eyeTracking = xr.featuresManager.getEnabledFeature(WebXRFeatureName.EYE_TRACKING);
    } catch (_a) {
    }
    try {
      this._handTracking = xr.featuresManager.getEnabledFeature(WebXRFeatureName.HAND_TRACKING);
    } catch (_b) {
      alert("Hand tracking must be enabled for the Hand Menu to work");
    }
  }
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicTexture.js
ThinEngine.prototype.createDynamicTexture = function(width, height, generateMipMaps, samplingMode) {
  const texture = new InternalTexture(this, InternalTextureSource.Dynamic);
  texture.baseWidth = width;
  texture.baseHeight = height;
  if (generateMipMaps) {
    width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(width, this._caps.maxTextureSize) : width;
    height = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(height, this._caps.maxTextureSize) : height;
  }
  texture.width = width;
  texture.height = height;
  texture.isReady = false;
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  this.updateTextureSamplingMode(samplingMode, texture);
  this._internalTexturesCache.push(texture);
  return texture;
};
ThinEngine.prototype.updateDynamicTexture = function(texture, source, invertY, premulAlpha = false, format, forceBindTexture = false, allowGPUOptimization = false) {
  if (!texture) {
    return;
  }
  const gl = this._gl;
  const target = gl.TEXTURE_2D;
  const wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);
  this._unpackFlipY(invertY === void 0 ? texture.invertY : invertY);
  if (premulAlpha) {
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
  }
  const textureType = this._getWebGLTextureType(texture.type);
  const glformat = this._getInternalFormat(format ? format : texture.format);
  const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);
  gl.texImage2D(target, 0, internalFormat, glformat, textureType, source);
  if (texture.generateMipMaps) {
    gl.generateMipmap(target);
  }
  if (!wasPreviouslyBound) {
    this._bindTextureDirectly(target, null);
  }
  if (premulAlpha) {
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
  }
  texture.isReady = true;
};

// node_modules/@babylonjs/core/Materials/Textures/dynamicTexture.js
var DynamicTexture = class extends Texture {
  constructor(name4, options, scene = null, generateMipMaps = false, samplingMode = 3, format = 5, invertY) {
    super(null, scene, !generateMipMaps, invertY, samplingMode, void 0, void 0, void 0, void 0, format);
    this.name = name4;
    this.wrapU = Texture.CLAMP_ADDRESSMODE;
    this.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._generateMipMaps = generateMipMaps;
    const engine = this._getEngine();
    if (!engine) {
      return;
    }
    if (options.getContext) {
      this._canvas = options;
      this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);
    } else {
      this._canvas = engine.createCanvas(1, 1);
      if (options.width || options.width === 0) {
        this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);
      } else {
        this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);
      }
    }
    const textureSize = this.getSize();
    if (this._canvas.width !== textureSize.width) {
      this._canvas.width = textureSize.width;
    }
    if (this._canvas.height !== textureSize.height) {
      this._canvas.height = textureSize.height;
    }
    this._context = this._canvas.getContext("2d");
  }
  getClassName() {
    return "DynamicTexture";
  }
  get canRescale() {
    return true;
  }
  _recreate(textureSize) {
    this._canvas.width = textureSize.width;
    this._canvas.height = textureSize.height;
    this.releaseInternalTexture();
    this._texture = this._getEngine().createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);
  }
  scale(ratio) {
    const textureSize = this.getSize();
    textureSize.width *= ratio;
    textureSize.height *= ratio;
    this._recreate(textureSize);
  }
  scaleTo(width, height) {
    const textureSize = this.getSize();
    textureSize.width = width;
    textureSize.height = height;
    this._recreate(textureSize);
  }
  getContext() {
    return this._context;
  }
  clear() {
    const size = this.getSize();
    this._context.fillRect(0, 0, size.width, size.height);
  }
  update(invertY, premulAlpha = false, allowGPUOptimization = false) {
    this._getEngine().updateDynamicTexture(this._texture, this._canvas, invertY === void 0 ? true : invertY, premulAlpha, this._format || void 0, void 0, allowGPUOptimization);
  }
  drawText(text, x, y, font, color, clearColor, invertY, update = true) {
    const size = this.getSize();
    if (clearColor) {
      this._context.fillStyle = clearColor;
      this._context.fillRect(0, 0, size.width, size.height);
    }
    this._context.font = font;
    if (x === null || x === void 0) {
      const textSize = this._context.measureText(text);
      x = (size.width - textSize.width) / 2;
    }
    if (y === null || y === void 0) {
      const fontSize = parseInt(font.replace(/\D/g, ""));
      y = size.height / 2 + fontSize / 3.65;
    }
    this._context.fillStyle = color || "";
    this._context.fillText(text, x, y);
    if (update) {
      this.update(invertY);
    }
  }
  clone() {
    const scene = this.getScene();
    if (!scene) {
      return this;
    }
    const textureSize = this.getSize();
    const newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.wrapU = this.wrapU;
    newTexture.wrapV = this.wrapV;
    return newTexture;
  }
  serialize() {
    const scene = this.getScene();
    if (scene && !scene.isReady()) {
      Logger.Warn("The scene must be ready before serializing the dynamic texture");
    }
    const serializationObject = super.serialize();
    if (DynamicTexture._IsCanvasElement(this._canvas)) {
      serializationObject.base64String = this._canvas.toDataURL();
    }
    serializationObject.invertY = this._invertY;
    serializationObject.samplingMode = this.samplingMode;
    return serializationObject;
  }
  static _IsCanvasElement(canvas) {
    return canvas.toDataURL !== void 0;
  }
  _rebuild() {
    this.update();
  }
};

// node_modules/@babylonjs/core/Rendering/utilityLayerRenderer.js
var UtilityLayerRenderer = class {
  constructor(originalScene, handleEvents = true) {
    this.originalScene = originalScene;
    this._pointerCaptures = {};
    this._lastPointerEvents = {};
    this._sharedGizmoLight = null;
    this._renderCamera = null;
    this.pickUtilitySceneFirst = true;
    this.shouldRender = true;
    this.onlyCheckPointerDownEvents = true;
    this.processAllEvents = false;
    this.pickingEnabled = true;
    this.onPointerOutObservable = new Observable();
    this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });
    this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;
    this.utilityLayerScene._allowPostProcessClearColor = false;
    this.utilityLayerScene.postProcessesEnabled = false;
    this.utilityLayerScene.detachControl();
    if (handleEvents) {
      this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo) => {
        if (!this.utilityLayerScene.activeCamera) {
          return;
        }
        if (!this.pickingEnabled) {
          return;
        }
        if (!this.processAllEvents) {
          if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE && prePointerInfo.type !== PointerEventTypes.POINTERUP && prePointerInfo.type !== PointerEventTypes.POINTERDOWN && prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {
            return;
          }
        }
        this.utilityLayerScene.pointerX = originalScene.pointerX;
        this.utilityLayerScene.pointerY = originalScene.pointerY;
        const pointerEvent = prePointerInfo.event;
        if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {
          this._pointerCaptures[pointerEvent.pointerId] = false;
          return;
        }
        const getNearPickDataForScene = (scene) => {
          let scenePick = null;
          if (prePointerInfo.nearInteractionPickingInfo) {
            if (prePointerInfo.nearInteractionPickingInfo.pickedMesh.getScene() == scene) {
              scenePick = prePointerInfo.nearInteractionPickingInfo;
            } else {
              scenePick = new PickingInfo();
            }
          } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {
            scenePick = prePointerInfo.originalPickingInfo;
          } else {
            let previousActiveCamera = null;
            if (this._renderCamera) {
              previousActiveCamera = scene._activeCamera;
              scene._activeCamera = this._renderCamera;
              prePointerInfo.ray = null;
            }
            scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);
            if (previousActiveCamera) {
              scene._activeCamera = previousActiveCamera;
            }
          }
          return scenePick;
        };
        const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);
        if (!prePointerInfo.ray && utilityScenePick) {
          prePointerInfo.ray = utilityScenePick.ray;
        }
        this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);
        if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {
          if (!prePointerInfo.skipOnPointerObservable) {
            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);
          }
          if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {
            this._pointerCaptures[pointerEvent.pointerId] = false;
          }
          return;
        }
        if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {
          if (utilityScenePick && utilityScenePick.hit) {
            if (!prePointerInfo.skipOnPointerObservable) {
              this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);
            }
            prePointerInfo.skipOnPointerObservable = true;
          }
        } else {
          const originalScenePick = getNearPickDataForScene(originalScene);
          const pointerEvent2 = prePointerInfo.event;
          if (originalScenePick && utilityScenePick) {
            if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {
              if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {
                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                prePointerInfo.skipOnPointerObservable = true;
              } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {
                this._pointerCaptures[pointerEvent2.pointerId] = true;
              } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {
                if (this._lastPointerEvents[pointerEvent2.pointerId]) {
                  this.onPointerOutObservable.notifyObservers(pointerEvent2.pointerId);
                  delete this._lastPointerEvents[pointerEvent2.pointerId];
                }
                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
              }
            } else if (!this._pointerCaptures[pointerEvent2.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {
              this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent2);
              if (!prePointerInfo.skipOnPointerObservable) {
                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;
              }
            } else if (!this._pointerCaptures[pointerEvent2.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {
              if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {
                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                prePointerInfo.skipOnPointerObservable = true;
              } else {
                if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {
                  if (this._lastPointerEvents[pointerEvent2.pointerId]) {
                    this.onPointerOutObservable.notifyObservers(pointerEvent2.pointerId);
                    delete this._lastPointerEvents[pointerEvent2.pointerId];
                  }
                }
                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent2);
              }
            }
            if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent2.pointerId]) {
              this._pointerCaptures[pointerEvent2.pointerId] = false;
            }
          }
        }
      });
      if (this._originalPointerObserver) {
        originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);
      }
    }
    this.utilityLayerScene.autoClear = false;
    this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add((camera) => {
      if (this.shouldRender && camera == this.getRenderCamera()) {
        this.render();
      }
    });
    this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {
      this.dispose();
    });
    this._updateCamera();
  }
  getRenderCamera(getRigParentIfPossible) {
    if (this._renderCamera) {
      return this._renderCamera;
    } else {
      let activeCam;
      if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {
        activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];
      } else {
        activeCam = this.originalScene.activeCamera;
      }
      if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {
        return activeCam.rigParent;
      }
      return activeCam;
    }
  }
  setRenderCamera(cam) {
    this._renderCamera = cam;
  }
  _getSharedGizmoLight() {
    if (!this._sharedGizmoLight) {
      this._sharedGizmoLight = new HemisphericLight("shared gizmo light", new Vector3(0, 1, 0), this.utilityLayerScene);
      this._sharedGizmoLight.intensity = 2;
      this._sharedGizmoLight.groundColor = Color3.Gray();
    }
    return this._sharedGizmoLight;
  }
  static get DefaultUtilityLayer() {
    if (UtilityLayerRenderer._DefaultUtilityLayer == null) {
      return UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene);
    }
    return UtilityLayerRenderer._DefaultUtilityLayer;
  }
  static _CreateDefaultUtilityLayerFromScene(scene) {
    UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(scene);
    UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {
      UtilityLayerRenderer._DefaultUtilityLayer = null;
    });
    return UtilityLayerRenderer._DefaultUtilityLayer;
  }
  static get DefaultKeepDepthUtilityLayer() {
    if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {
      UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene);
      UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;
      UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {
        UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;
      });
    }
    return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;
  }
  _notifyObservers(prePointerInfo, pickInfo, pointerEvent) {
    if (!prePointerInfo.skipOnPointerObservable) {
      this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);
      this._lastPointerEvents[pointerEvent.pointerId] = true;
    }
  }
  render() {
    this._updateCamera();
    if (this.utilityLayerScene.activeCamera) {
      const oldScene = this.utilityLayerScene.activeCamera.getScene();
      const camera = this.utilityLayerScene.activeCamera;
      camera._scene = this.utilityLayerScene;
      if (camera.leftCamera) {
        camera.leftCamera._scene = this.utilityLayerScene;
      }
      if (camera.rightCamera) {
        camera.rightCamera._scene = this.utilityLayerScene;
      }
      this.utilityLayerScene.render(false);
      camera._scene = oldScene;
      if (camera.leftCamera) {
        camera.leftCamera._scene = oldScene;
      }
      if (camera.rightCamera) {
        camera.rightCamera._scene = oldScene;
      }
    }
  }
  dispose() {
    this.onPointerOutObservable.clear();
    if (this._afterRenderObserver) {
      this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);
    }
    if (this._sceneDisposeObserver) {
      this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);
    }
    if (this._originalPointerObserver) {
      this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);
    }
    this.utilityLayerScene.dispose();
  }
  _updateCamera() {
    this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();
    this.utilityLayerScene.activeCamera = this.getRenderCamera();
  }
};
UtilityLayerRenderer._DefaultUtilityLayer = null;
UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;

// node_modules/@babylonjs/core/Gizmos/gizmo.js
var Gizmo = class {
  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer) {
    this.gizmoLayer = gizmoLayer;
    this._attachedMesh = null;
    this._attachedNode = null;
    this._customRotationQuaternion = null;
    this._scaleRatio = 1;
    this._isHovered = false;
    this._customMeshSet = false;
    this._updateGizmoRotationToMatchAttachedMesh = true;
    this._updateGizmoPositionToMatchAttachedMesh = true;
    this._updateScale = true;
    this._interactionsEnabled = true;
    this._rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);
    this._rootMesh = new Mesh("gizmoRootNode", gizmoLayer.utilityLayerScene);
    this._rootMesh.rotationQuaternion = Quaternion.Identity();
    this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {
      this._update();
    });
  }
  set scaleRatio(value) {
    this._scaleRatio = value;
  }
  get scaleRatio() {
    return this._scaleRatio;
  }
  get isHovered() {
    return this._isHovered;
  }
  get attachedMesh() {
    return this._attachedMesh;
  }
  set attachedMesh(value) {
    this._attachedMesh = value;
    if (value) {
      this._attachedNode = value;
    }
    this._rootMesh.setEnabled(value ? true : false);
    this._attachedNodeChanged(value);
  }
  get attachedNode() {
    return this._attachedNode;
  }
  set attachedNode(value) {
    this._attachedNode = value;
    this._attachedMesh = null;
    this._rootMesh.setEnabled(value ? true : false);
    this._attachedNodeChanged(value);
  }
  setCustomMesh(mesh) {
    if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {
      throw "When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)";
    }
    this._rootMesh.getChildMeshes().forEach((c) => {
      c.dispose();
    });
    mesh.parent = this._rootMesh;
    this._customMeshSet = true;
  }
  set updateGizmoRotationToMatchAttachedMesh(value) {
    this._updateGizmoRotationToMatchAttachedMesh = value;
  }
  get updateGizmoRotationToMatchAttachedMesh() {
    return this._updateGizmoRotationToMatchAttachedMesh;
  }
  set updateGizmoPositionToMatchAttachedMesh(value) {
    this._updateGizmoPositionToMatchAttachedMesh = value;
  }
  get updateGizmoPositionToMatchAttachedMesh() {
    return this._updateGizmoPositionToMatchAttachedMesh;
  }
  set updateScale(value) {
    this._updateScale = value;
  }
  get updateScale() {
    return this._updateScale;
  }
  _attachedNodeChanged(value) {
  }
  get customRotationQuaternion() {
    return this._customRotationQuaternion;
  }
  set customRotationQuaternion(customRotationQuaternion) {
    this._customRotationQuaternion = customRotationQuaternion;
  }
  _update() {
    if (this.attachedNode) {
      let effectiveNode = this.attachedNode;
      if (this.attachedMesh) {
        effectiveNode = this.attachedMesh || this.attachedNode;
      }
      if (this.updateGizmoPositionToMatchAttachedMesh) {
        const row = effectiveNode.getWorldMatrix().getRow(3);
        const position = row ? row.toVector3() : new Vector3(0, 0, 0);
        this._rootMesh.position.copyFrom(position);
      }
      if (this.updateGizmoRotationToMatchAttachedMesh) {
        const supportedNode = effectiveNode._isMesh || effectiveNode.getClassName() === "AbstractMesh" || effectiveNode.getClassName() === "TransformNode" || effectiveNode.getClassName() === "InstancedMesh";
        const transformNode = supportedNode ? effectiveNode : void 0;
        effectiveNode.getWorldMatrix().decompose(void 0, this._rootMesh.rotationQuaternion, void 0, Gizmo.PreserveScaling ? transformNode : void 0);
      } else {
        if (this._customRotationQuaternion) {
          this._rootMesh.rotationQuaternion.copyFrom(this._customRotationQuaternion);
        } else {
          this._rootMesh.rotationQuaternion.set(0, 0, 0, 1);
        }
      }
      if (this.updateScale) {
        const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera;
        let cameraPosition = activeCamera.globalPosition;
        if (activeCamera.devicePosition) {
          cameraPosition = activeCamera.devicePosition;
        }
        this._rootMesh.position.subtractToRef(cameraPosition, TmpVectors.Vector3[0]);
        let scale = this.scaleRatio;
        if (activeCamera.mode == Camera.ORTHOGRAPHIC_CAMERA) {
          if (activeCamera.orthoTop && activeCamera.orthoBottom) {
            const orthoHeight = activeCamera.orthoTop - activeCamera.orthoBottom;
            scale *= orthoHeight;
          }
        } else {
          const camForward = activeCamera.getScene().useRightHandedSystem ? Vector3.RightHandedForwardReadOnly : Vector3.LeftHandedForwardReadOnly;
          const direction = activeCamera.getDirection(camForward);
          scale *= Vector3.Dot(TmpVectors.Vector3[0], direction);
        }
        this._rootMesh.scaling.setAll(scale);
        if (effectiveNode._getWorldMatrixDeterminant() < 0 && !Gizmo.PreserveScaling) {
          this._rootMesh.scaling.y *= -1;
        }
      } else {
        this._rootMesh.scaling.setAll(this.scaleRatio);
      }
    }
  }
  _handlePivot() {
    const attachedNodeTransform = this._attachedNode;
    if (attachedNodeTransform.isUsingPivotMatrix && attachedNodeTransform.isUsingPivotMatrix() && attachedNodeTransform.position) {
      attachedNodeTransform.getWorldMatrix().setTranslation(attachedNodeTransform.position);
    }
  }
  _matrixChanged() {
    if (!this._attachedNode) {
      return;
    }
    if (this._attachedNode._isCamera) {
      const camera = this._attachedNode;
      let worldMatrix;
      let worldMatrixUC;
      if (camera.parent) {
        const parentInv = TmpVectors.Matrix[1];
        camera.parent._worldMatrix.invertToRef(parentInv);
        this._attachedNode._worldMatrix.multiplyToRef(parentInv, TmpVectors.Matrix[0]);
        worldMatrix = TmpVectors.Matrix[0];
      } else {
        worldMatrix = this._attachedNode._worldMatrix;
      }
      if (camera.getScene().useRightHandedSystem) {
        this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, TmpVectors.Matrix[1]);
        worldMatrixUC = TmpVectors.Matrix[1];
      } else {
        worldMatrixUC = worldMatrix;
      }
      worldMatrixUC.decompose(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);
      const inheritsTargetCamera = this._attachedNode.getClassName() === "FreeCamera" || this._attachedNode.getClassName() === "FlyCamera" || this._attachedNode.getClassName() === "ArcFollowCamera" || this._attachedNode.getClassName() === "TargetCamera" || this._attachedNode.getClassName() === "TouchCamera" || this._attachedNode.getClassName() === "UniversalCamera";
      if (inheritsTargetCamera) {
        const targetCamera = this._attachedNode;
        targetCamera.rotation = TmpVectors.Quaternion[0].toEulerAngles();
        if (targetCamera.rotationQuaternion) {
          targetCamera.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);
          targetCamera.rotationQuaternion.normalize();
        }
      }
      camera.position.copyFrom(TmpVectors.Vector3[0]);
    } else if (this._attachedNode._isMesh || this._attachedNode.getClassName() === "AbstractMesh" || this._attachedNode.getClassName() === "TransformNode" || this._attachedNode.getClassName() === "InstancedMesh") {
      const transform = this._attachedNode;
      if (transform.parent) {
        const parentInv = TmpVectors.Matrix[0];
        const localMat = TmpVectors.Matrix[1];
        transform.parent.getWorldMatrix().invertToRef(parentInv);
        this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);
        localMat.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, Gizmo.PreserveScaling ? transform : void 0);
      } else {
        this._attachedNode._worldMatrix.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, Gizmo.PreserveScaling ? transform : void 0);
      }
      transform.scaling.copyFrom(TmpVectors.Vector3[0]);
      if (!transform.billboardMode) {
        if (transform.rotationQuaternion) {
          transform.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);
          transform.rotationQuaternion.normalize();
        } else {
          transform.rotation = TmpVectors.Quaternion[0].toEulerAngles();
        }
      }
    } else if (this._attachedNode.getClassName() === "Bone") {
      const bone = this._attachedNode;
      const parent = bone.getParent();
      if (parent) {
        const invParent = TmpVectors.Matrix[0];
        const boneLocalMatrix = TmpVectors.Matrix[1];
        parent.getWorldMatrix().invertToRef(invParent);
        bone.getWorldMatrix().multiplyToRef(invParent, boneLocalMatrix);
        const lmat = bone.getLocalMatrix();
        lmat.copyFrom(boneLocalMatrix);
      } else {
        const lmat = bone.getLocalMatrix();
        lmat.copyFrom(bone.getWorldMatrix());
      }
      bone.markAsDirty();
    } else {
      const light = this._attachedNode;
      if (light.getTypeID) {
        const type = light.getTypeID();
        if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {
          const parent = light.parent;
          if (parent) {
            const invParent = TmpVectors.Matrix[0];
            const nodeLocalMatrix = TmpVectors.Matrix[1];
            parent.getWorldMatrix().invertToRef(invParent);
            light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);
            nodeLocalMatrix.decompose(void 0, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);
          } else {
            this._attachedNode._worldMatrix.decompose(void 0, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);
          }
          light.position = new Vector3(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);
          if (light.direction) {
            light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);
          }
        }
      }
    }
  }
  _setGizmoMeshMaterial(gizmoMeshes, material) {
    if (gizmoMeshes) {
      gizmoMeshes.forEach((m) => {
        m.material = material;
        if (m.color) {
          m.color = material.diffuseColor;
        }
      });
    }
  }
  static GizmoAxisPointerObserver(gizmoLayer, gizmoAxisCache) {
    let dragging = false;
    const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
      var _a, _b;
      if (pointerInfo.pickInfo) {
        if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {
          if (dragging) {
            return;
          }
          gizmoAxisCache.forEach((cache) => {
            var _a2, _b2;
            if (cache.colliderMeshes && cache.gizmoMeshes) {
              const isHovered = ((_a2 = cache.colliderMeshes) === null || _a2 === void 0 ? void 0 : _a2.indexOf((_b2 = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _b2 === void 0 ? void 0 : _b2.pickedMesh)) != -1;
              const material = cache.dragBehavior.enabled ? isHovered || cache.active ? cache.hoverMaterial : cache.material : cache.disableMaterial;
              cache.gizmoMeshes.forEach((m) => {
                m.material = material;
                if (m.color) {
                  m.color = material.diffuseColor;
                }
              });
            }
          });
        }
        if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {
          if (gizmoAxisCache.has((_a = pointerInfo.pickInfo.pickedMesh) === null || _a === void 0 ? void 0 : _a.parent)) {
            dragging = true;
            const statusMap = gizmoAxisCache.get((_b = pointerInfo.pickInfo.pickedMesh) === null || _b === void 0 ? void 0 : _b.parent);
            statusMap.active = true;
            gizmoAxisCache.forEach((cache) => {
              var _a2, _b2;
              const isHovered = ((_a2 = cache.colliderMeshes) === null || _a2 === void 0 ? void 0 : _a2.indexOf((_b2 = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _b2 === void 0 ? void 0 : _b2.pickedMesh)) != -1;
              const material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;
              cache.gizmoMeshes.forEach((m) => {
                m.material = material;
                if (m.color) {
                  m.color = material.diffuseColor;
                }
              });
            });
          }
        }
        if (pointerInfo.type === PointerEventTypes.POINTERUP) {
          gizmoAxisCache.forEach((cache) => {
            cache.active = false;
            dragging = false;
            cache.gizmoMeshes.forEach((m) => {
              m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;
              if (m.color) {
                m.color = cache.material.diffuseColor;
              }
            });
          });
        }
      }
    });
    return pointerObserver;
  }
  dispose() {
    this._rootMesh.dispose();
    if (this._beforeRenderObserver) {
      this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);
    }
  }
};
Gizmo.PreserveScaling = false;

// node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js
function CreateBoxVertexData(options) {
  const nbFaces = 6;
  let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
  const normals = [
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0
  ];
  const uvs = [];
  let positions = [];
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const depth = options.depth || options.size || 1;
  const wrap = options.wrap || false;
  let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;
  let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;
  topBaseAt = (topBaseAt + 4) % 4;
  bottomBaseAt = (bottomBaseAt + 4) % 4;
  const topOrder = [2, 0, 3, 1];
  const bottomOrder = [2, 0, 1, 3];
  let topIndex = topOrder[topBaseAt];
  let bottomIndex = bottomOrder[bottomBaseAt];
  let basePositions = [
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1
  ];
  if (wrap) {
    indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];
    basePositions = [
      -1,
      1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1
    ];
    let topFaceBase = [
      [1, 1, 1],
      [-1, 1, 1],
      [-1, 1, -1],
      [1, 1, -1]
    ];
    let bottomFaceBase = [
      [-1, -1, 1],
      [1, -1, 1],
      [1, -1, -1],
      [-1, -1, -1]
    ];
    const topFaceOrder = [17, 18, 19, 16];
    const bottomFaceOrder = [22, 23, 20, 21];
    while (topIndex > 0) {
      topFaceBase.unshift(topFaceBase.pop());
      topFaceOrder.unshift(topFaceOrder.pop());
      topIndex--;
    }
    while (bottomIndex > 0) {
      bottomFaceBase.unshift(bottomFaceBase.pop());
      bottomFaceOrder.unshift(bottomFaceOrder.pop());
      bottomIndex--;
    }
    topFaceBase = topFaceBase.flat();
    bottomFaceBase = bottomFaceBase.flat();
    basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);
    indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);
    indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);
  }
  const scaleArray = [width / 2, height / 2, depth / 2];
  positions = basePositions.reduce((accumulator, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const faceUV = options.faceUV || new Array(6);
  const faceColors = options.faceColors;
  const colors = [];
  for (let f = 0; f < 6; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  for (let index = 0; index < nbFaces; index++) {
    uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].w : faceUV[index].w);
    uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].w : faceUV[index].w);
    uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].y : faceUV[index].y);
    uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].y : faceUV[index].y);
    if (faceColors) {
      for (let c = 0; c < 4; c++) {
        colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
}
function CreateBox(name4, options = {}, scene = null) {
  const box = new Mesh(name4, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  box._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateBoxVertexData(options);
  vertexData.applyToMesh(box, options.updatable);
  return box;
}
var BoxBuilder = {
  CreateBox
};
VertexData.CreateBox = CreateBoxVertexData;
Mesh.CreateBox = (name4, size, scene = null, updatable, sideOrientation) => {
  const options = {
    size,
    sideOrientation,
    updatable
  };
  return CreateBox(name4, options, scene);
};

// node_modules/@babylonjs/core/Events/clipboardEvents.js
var ClipboardEventTypes = class {
};
ClipboardEventTypes.COPY = 1;
ClipboardEventTypes.CUT = 2;
ClipboardEventTypes.PASTE = 3;
var ClipboardInfo = class {
  constructor(type, event) {
    this.type = type;
    this.event = event;
  }
  static GetTypeFromCharacter(keyCode) {
    const charCode = keyCode;
    switch (charCode) {
      case 67:
        return ClipboardEventTypes.COPY;
      case 86:
        return ClipboardEventTypes.PASTE;
      case 88:
        return ClipboardEventTypes.CUT;
      default:
        return -1;
    }
  }
};

// node_modules/@babylonjs/core/Layers/layerSceneComponent.js
var LayerSceneComponent = class {
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_LAYER;
    this.scene = scene || EngineStore.LastCreatedScene;
    if (!this.scene) {
      return;
    }
    this._engine = this.scene.getEngine();
    this.scene.layers = new Array();
  }
  register() {
    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);
    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForegroundWithPostProcessing);
    this.scene._afterCameraPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER, this, this._drawCameraForegroundWithoutPostProcessing);
    this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);
    this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForegroundWithPostProcessing);
    this.scene._afterRenderTargetPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER, this, this._drawRenderTargetForegroundWithoutPostProcessing);
  }
  rebuild() {
    const layers = this.scene.layers;
    for (const layer of layers) {
      layer._rebuild();
    }
  }
  dispose() {
    const layers = this.scene.layers;
    while (layers.length) {
      layers[0].dispose();
    }
  }
  _draw(predicate) {
    const layers = this.scene.layers;
    if (layers.length) {
      this._engine.setDepthBuffer(false);
      for (const layer of layers) {
        if (predicate(layer)) {
          layer.render();
        }
      }
      this._engine.setDepthBuffer(true);
    }
  }
  _drawCameraPredicate(layer, isBackground, applyPostProcess, cameraLayerMask) {
    return !layer.renderOnlyInRenderTargetTextures && layer.isBackground === isBackground && layer.applyPostProcess === applyPostProcess && (layer.layerMask & cameraLayerMask) !== 0;
  }
  _drawCameraBackground(camera) {
    this._draw((layer) => {
      return this._drawCameraPredicate(layer, true, true, camera.layerMask);
    });
  }
  _drawCameraForegroundWithPostProcessing(camera) {
    this._draw((layer) => {
      return this._drawCameraPredicate(layer, false, true, camera.layerMask);
    });
  }
  _drawCameraForegroundWithoutPostProcessing(camera) {
    this._draw((layer) => {
      return this._drawCameraPredicate(layer, false, false, camera.layerMask);
    });
  }
  _drawRenderTargetPredicate(layer, isBackground, applyPostProcess, cameraLayerMask, renderTargetTexture) {
    return layer.renderTargetTextures.length > 0 && layer.isBackground === isBackground && layer.applyPostProcess === applyPostProcess && layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 && (layer.layerMask & cameraLayerMask) !== 0;
  }
  _drawRenderTargetBackground(renderTarget) {
    this._draw((layer) => {
      return this._drawRenderTargetPredicate(layer, true, true, this.scene.activeCamera.layerMask, renderTarget);
    });
  }
  _drawRenderTargetForegroundWithPostProcessing(renderTarget) {
    this._draw((layer) => {
      return this._drawRenderTargetPredicate(layer, false, true, this.scene.activeCamera.layerMask, renderTarget);
    });
  }
  _drawRenderTargetForegroundWithoutPostProcessing(renderTarget) {
    this._draw((layer) => {
      return this._drawRenderTargetPredicate(layer, false, false, this.scene.activeCamera.layerMask, renderTarget);
    });
  }
  addFromContainer(container) {
    if (!container.layers) {
      return;
    }
    container.layers.forEach((layer) => {
      this.scene.layers.push(layer);
    });
  }
  removeFromContainer(container, dispose = false) {
    if (!container.layers) {
      return;
    }
    container.layers.forEach((layer) => {
      const index = this.scene.layers.indexOf(layer);
      if (index !== -1) {
        this.scene.layers.splice(index, 1);
      }
      if (dispose) {
        layer.dispose();
      }
    });
  }
};

// node_modules/@babylonjs/core/Shaders/layer.fragment.js
var name2 = "layerPixelShader";
var shader2 = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform vec4 color;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec4 baseColor=texture2D(textureSampler,vUV);
#ifdef LINEAR
baseColor.rgb=toGammaSpace(baseColor.rgb);
#endif
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
gl_FragColor=baseColor*color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name2] = shader2;

// node_modules/@babylonjs/core/Shaders/layer.vertex.js
var name3 = "layerVertexShader";
var shader3 = `attribute vec2 position;
uniform vec2 scale;
uniform vec2 offset;
uniform mat4 textureMatrix;
varying vec2 vUV;
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec2 shiftedPosition=position*scale+offset;
vUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));
gl_Position=vec4(shiftedPosition,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name3] = shader3;

// node_modules/@babylonjs/core/Layers/layer.js
var Layer = class {
  constructor(name4, imgUrl, scene, isBackground, color) {
    this.name = name4;
    this._applyPostProcess = true;
    this.scale = new Vector2(1, 1);
    this.offset = new Vector2(0, 0);
    this.alphaBlendingMode = 2;
    this.layerMask = 268435455;
    this.renderTargetTextures = [];
    this.renderOnlyInRenderTargetTextures = false;
    this.isEnabled = true;
    this._vertexBuffers = {};
    this.onDisposeObservable = new Observable();
    this.onBeforeRenderObservable = new Observable();
    this.onAfterRenderObservable = new Observable();
    this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;
    this.isBackground = isBackground === void 0 ? true : isBackground;
    this.color = color === void 0 ? new Color4(1, 1, 1, 1) : color;
    this._scene = scene || EngineStore.LastCreatedScene;
    let layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER);
    if (!layerComponent) {
      layerComponent = new LayerSceneComponent(this._scene);
      this._scene._addComponent(layerComponent);
    }
    this._scene.layers.push(this);
    const engine = this._scene.getEngine();
    this._drawWrapper = new DrawWrapper(engine);
    const vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    const vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);
    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;
    this._createIndexBuffer();
  }
  set applyPostProcess(value) {
    this._applyPostProcess = value;
  }
  get applyPostProcess() {
    return this.isBackground || this._applyPostProcess;
  }
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  set onBeforeRender(callback) {
    if (this._onBeforeRenderObserver) {
      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
    }
    this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
  }
  set onAfterRender(callback) {
    if (this._onAfterRenderObserver) {
      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
    }
    this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
  }
  _createIndexBuffer() {
    const engine = this._scene.getEngine();
    const indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = engine.createIndexBuffer(indices);
  }
  _rebuild() {
    const vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vb) {
      vb._rebuild();
    }
    this._createIndexBuffer();
  }
  render() {
    if (!this.isEnabled) {
      return;
    }
    const engine = this._scene.getEngine();
    let defines = "";
    if (this.alphaTest) {
      defines = "#define ALPHATEST";
    }
    if (this.texture && !this.texture.gammaSpace) {
      defines += "\r\n#define LINEAR";
    }
    if (this._previousDefines !== defines) {
      this._previousDefines = defines;
      this._drawWrapper.effect = engine.createEffect("layer", [VertexBuffer.PositionKind], ["textureMatrix", "color", "scale", "offset"], ["textureSampler"], defines);
    }
    const currentEffect = this._drawWrapper.effect;
    if (!currentEffect || !currentEffect.isReady() || !this.texture || !this.texture.isReady()) {
      return;
    }
    this.onBeforeRenderObservable.notifyObservers(this);
    engine.enableEffect(this._drawWrapper);
    engine.setState(false);
    currentEffect.setTexture("textureSampler", this.texture);
    currentEffect.setMatrix("textureMatrix", this.texture.getTextureMatrix());
    currentEffect.setFloat4("color", this.color.r, this.color.g, this.color.b, this.color.a);
    currentEffect.setVector2("offset", this.offset);
    currentEffect.setVector2("scale", this.scale);
    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);
    if (!this.alphaTest) {
      engine.setAlphaMode(this.alphaBlendingMode);
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
      engine.setAlphaMode(0);
    } else {
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
    }
    this.onAfterRenderObservable.notifyObservers(this);
  }
  dispose() {
    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer) {
      this._scene.getEngine()._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    if (this.texture) {
      this.texture.dispose();
      this.texture = null;
    }
    this.renderTargetTextures = [];
    const index = this._scene.layers.indexOf(this);
    this._scene.layers.splice(index, 1);
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onBeforeRenderObservable.clear();
  }
};

export {
  FadeInOutBehavior,
  Ray,
  PivotTools,
  CreatePlaneVertexData,
  CreatePlane,
  PlaneBuilder,
  PointerDragBehavior,
  BaseSixDofDragBehavior,
  SixDofDragBehavior,
  SurfaceMagnetismBehavior,
  FollowBehavior,
  WebXRFeatureName,
  WebXRFeaturesManager,
  WebXRAbstractFeature,
  PhysicsJoint,
  DistanceJoint,
  MotorEnabledJoint,
  HingeJoint,
  Hinge2Joint,
  PhysicsImpostor,
  NodeMaterialBlockConnectionPointTypes,
  NodeMaterialBlockTargets,
  NodeMaterialConnectionPointCompatibilityStates,
  NodeMaterialConnectionPointDirection,
  NodeMaterialConnectionPoint,
  NodeMaterialBlock,
  TransformBlock,
  VertexOutputBlock,
  PropertyTypeForEdition,
  editableInPropertyPage,
  FragmentOutputBlock,
  NodeMaterialBlockConnectionPointMode,
  NodeMaterialSystemValues,
  AnimatedInputBlockTypes,
  InputBlock,
  CurrentScreenBlock,
  ParticleTextureBlock,
  ParticleRampGradientBlock,
  ParticleBlendMultiplyBlock,
  VectorMergerBlock,
  RemapBlock,
  MultiplyBlock,
  NodeMaterialModes,
  BoxParticleEmitter,
  ConeParticleEmitter,
  CylinderParticleEmitter,
  CylinderDirectedParticleEmitter,
  HemisphericParticleEmitter,
  PointParticleEmitter,
  SphereParticleEmitter,
  SphereDirectedParticleEmitter,
  CustomParticleEmitter,
  MeshParticleEmitter,
  BaseParticleSystem,
  ColorSplitterBlock,
  ProceduralTextureSceneComponent,
  ProceduralTexture,
  TrigonometryBlockOperations,
  TrigonometryBlock,
  NodeMaterialDefines,
  NodeMaterial,
  CreateIcoSphereVertexData,
  CreateIcoSphere,
  IcoSphereBuilder,
  HandPart,
  WebXRHandJoint,
  WebXRHand,
  WebXRHandTracking,
  HandConstraintZone,
  HandConstraintOrientation,
  HandConstraintVisibility,
  HandConstraintBehavior,
  DynamicTexture,
  UtilityLayerRenderer,
  Gizmo,
  CreateBoxVertexData,
  CreateBox,
  BoxBuilder,
  ClipboardEventTypes,
  ClipboardInfo,
  LayerSceneComponent,
  Layer
};
//# sourceMappingURL=chunk-3CAGSAXU.js.map
