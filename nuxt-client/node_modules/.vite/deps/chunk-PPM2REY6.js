// node_modules/@babylonjs/core/abstractScene.js
var AbstractScene = class {
  constructor() {
    this.rootNodes = new Array();
    this.cameras = new Array();
    this.lights = new Array();
    this.meshes = new Array();
    this.skeletons = new Array();
    this.particleSystems = new Array();
    this.animations = [];
    this.animationGroups = new Array();
    this.multiMaterials = new Array();
    this.materials = new Array();
    this.morphTargetManagers = new Array();
    this.geometries = new Array();
    this.transformNodes = new Array();
    this.actionManagers = new Array();
    this.textures = new Array();
    this._environmentTexture = null;
    this.postProcesses = new Array();
  }
  static AddParser(name63, parser) {
    this._BabylonFileParsers[name63] = parser;
  }
  static GetParser(name63) {
    if (this._BabylonFileParsers[name63]) {
      return this._BabylonFileParsers[name63];
    }
    return null;
  }
  static AddIndividualParser(name63, parser) {
    this._IndividualBabylonFileParsers[name63] = parser;
  }
  static GetIndividualParser(name63) {
    if (this._IndividualBabylonFileParsers[name63]) {
      return this._IndividualBabylonFileParsers[name63];
    }
    return null;
  }
  static Parse(jsonData, scene, container, rootUrl) {
    for (const parserName in this._BabylonFileParsers) {
      if (Object.prototype.hasOwnProperty.call(this._BabylonFileParsers, parserName)) {
        this._BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);
      }
    }
  }
  get environmentTexture() {
    return this._environmentTexture;
  }
  set environmentTexture(value) {
    this._environmentTexture = value;
  }
  getNodes() {
    let nodes = new Array();
    nodes = nodes.concat(this.meshes);
    nodes = nodes.concat(this.lights);
    nodes = nodes.concat(this.cameras);
    nodes = nodes.concat(this.transformNodes);
    this.skeletons.forEach((skeleton) => nodes = nodes.concat(skeleton.bones));
    return nodes;
  }
};
AbstractScene._BabylonFileParsers = {};
AbstractScene._IndividualBabylonFileParsers = {};

// node_modules/@babylonjs/core/Actions/abstractActionManager.js
var AbstractActionManager = class {
  constructor() {
    this.hoverCursor = "";
    this.actions = new Array();
    this.isRecursive = false;
  }
  static get HasTriggers() {
    for (const t in AbstractActionManager.Triggers) {
      if (Object.prototype.hasOwnProperty.call(AbstractActionManager.Triggers, t)) {
        return true;
      }
    }
    return false;
  }
  static get HasPickTriggers() {
    for (const t in AbstractActionManager.Triggers) {
      if (Object.prototype.hasOwnProperty.call(AbstractActionManager.Triggers, t)) {
        const tAsInt = parseInt(t);
        if (tAsInt >= 1 && tAsInt <= 7) {
          return true;
        }
      }
    }
    return false;
  }
  static HasSpecificTrigger(trigger) {
    for (const t in AbstractActionManager.Triggers) {
      if (Object.prototype.hasOwnProperty.call(AbstractActionManager.Triggers, t)) {
        const tAsInt = parseInt(t);
        if (tAsInt === trigger) {
          return true;
        }
      }
    }
    return false;
  }
};
AbstractActionManager.Triggers = {};

// node_modules/@babylonjs/core/Misc/observable.js
var EventState = class {
  constructor(mask, skipNextObservers = false, target, currentTarget) {
    this.initialize(mask, skipNextObservers, target, currentTarget);
  }
  initialize(mask, skipNextObservers = false, target, currentTarget) {
    this.mask = mask;
    this.skipNextObservers = skipNextObservers;
    this.target = target;
    this.currentTarget = currentTarget;
    return this;
  }
};
var Observer = class {
  constructor(callback, mask, scope = null) {
    this.callback = callback;
    this.mask = mask;
    this.scope = scope;
    this._willBeUnregistered = false;
    this.unregisterOnNextCall = false;
  }
};
var Observable = class {
  constructor(onObserverAdded) {
    this._observers = new Array();
    this._numObserversMarkedAsDeleted = 0;
    this._eventState = new EventState(0);
    if (onObserverAdded) {
      this._onObserverAdded = onObserverAdded;
    }
  }
  static FromPromise(promise, onErrorObservable) {
    const observable = new Observable();
    promise.then((ret) => {
      observable.notifyObservers(ret);
    }).catch((err) => {
      if (onErrorObservable) {
        onErrorObservable.notifyObservers(err);
      } else {
        throw err;
      }
    });
    return observable;
  }
  get observers() {
    return this._observers;
  }
  add(callback, mask = -1, insertFirst = false, scope = null, unregisterOnFirstCall = false) {
    if (!callback) {
      return null;
    }
    const observer = new Observer(callback, mask, scope);
    observer.unregisterOnNextCall = unregisterOnFirstCall;
    if (insertFirst) {
      this._observers.unshift(observer);
    } else {
      this._observers.push(observer);
    }
    if (this._onObserverAdded) {
      this._onObserverAdded(observer);
    }
    return observer;
  }
  addOnce(callback) {
    return this.add(callback, void 0, void 0, void 0, true);
  }
  remove(observer) {
    if (!observer) {
      return false;
    }
    const index = this._observers.indexOf(observer);
    if (index !== -1) {
      this._deferUnregister(observer);
      return true;
    }
    return false;
  }
  removeCallback(callback, scope) {
    for (let index = 0; index < this._observers.length; index++) {
      const observer = this._observers[index];
      if (observer._willBeUnregistered) {
        continue;
      }
      if (observer.callback === callback && (!scope || scope === observer.scope)) {
        this._deferUnregister(observer);
        return true;
      }
    }
    return false;
  }
  _deferUnregister(observer) {
    this._numObserversMarkedAsDeleted++;
    observer.unregisterOnNextCall = false;
    observer._willBeUnregistered = true;
    setTimeout(() => {
      this._remove(observer);
    }, 0);
  }
  _remove(observer) {
    if (!observer) {
      return false;
    }
    const index = this._observers.indexOf(observer);
    if (index !== -1) {
      this._numObserversMarkedAsDeleted--;
      this._observers.splice(index, 1);
      return true;
    }
    return false;
  }
  makeObserverTopPriority(observer) {
    this._remove(observer);
    this._observers.unshift(observer);
  }
  makeObserverBottomPriority(observer) {
    this._remove(observer);
    this._observers.push(observer);
  }
  notifyObservers(eventData, mask = -1, target, currentTarget, userInfo) {
    if (!this._observers.length) {
      return true;
    }
    const state = this._eventState;
    state.mask = mask;
    state.target = target;
    state.currentTarget = currentTarget;
    state.skipNextObservers = false;
    state.lastReturnValue = eventData;
    state.userInfo = userInfo;
    for (const obs of this._observers) {
      if (obs._willBeUnregistered) {
        continue;
      }
      if (obs.mask & mask) {
        if (obs.unregisterOnNextCall) {
          this._deferUnregister(obs);
        }
        if (obs.scope) {
          state.lastReturnValue = obs.callback.apply(obs.scope, [eventData, state]);
        } else {
          state.lastReturnValue = obs.callback(eventData, state);
        }
      }
      if (state.skipNextObservers) {
        return false;
      }
    }
    return true;
  }
  notifyObserver(observer, eventData, mask = -1) {
    if (observer._willBeUnregistered) {
      return;
    }
    const state = this._eventState;
    state.mask = mask;
    state.skipNextObservers = false;
    if (observer.unregisterOnNextCall) {
      this._deferUnregister(observer);
    }
    observer.callback(eventData, state);
  }
  hasObservers() {
    return this._observers.length - this._numObserversMarkedAsDeleted > 0;
  }
  clear() {
    this._observers = new Array();
    this._onObserverAdded = null;
  }
  clone() {
    const result = new Observable();
    result._observers = this._observers.slice(0);
    return result;
  }
  hasSpecificMask(mask = -1) {
    for (const obs of this._observers) {
      if (obs.mask & mask || obs.mask === mask) {
        return true;
      }
    }
    return false;
  }
};

// node_modules/@babylonjs/core/Maths/math.scalar.js
var Scalar = class {
  static WithinEpsilon(a, b, epsilon = 1401298e-51) {
    return Math.abs(a - b) <= epsilon;
  }
  static ToHex(i) {
    const str = i.toString(16);
    if (i <= 15) {
      return ("0" + str).toUpperCase();
    }
    return str.toUpperCase();
  }
  static Sign(value) {
    value = +value;
    if (value === 0 || isNaN(value)) {
      return value;
    }
    return value > 0 ? 1 : -1;
  }
  static Clamp(value, min = 0, max = 1) {
    return Math.min(max, Math.max(min, value));
  }
  static Log2(value) {
    return Math.log(value) * Math.LOG2E;
  }
  static ILog2(value) {
    if (Math.log2) {
      return Math.floor(Math.log2(value));
    }
    if (value < 0) {
      return NaN;
    } else if (value === 0) {
      return -Infinity;
    }
    let n = 0;
    if (value < 1) {
      while (value < 1) {
        n++;
        value = value * 2;
      }
      n = -n;
    } else if (value > 1) {
      while (value > 1) {
        n++;
        value = Math.floor(value / 2);
      }
    }
    return n;
  }
  static Repeat(value, length) {
    return value - Math.floor(value / length) * length;
  }
  static Normalize(value, min, max) {
    return (value - min) / (max - min);
  }
  static Denormalize(normalized, min, max) {
    return normalized * (max - min) + min;
  }
  static DeltaAngle(current, target) {
    let num = Scalar.Repeat(target - current, 360);
    if (num > 180) {
      num -= 360;
    }
    return num;
  }
  static PingPong(tx, length) {
    const t = Scalar.Repeat(tx, length * 2);
    return length - Math.abs(t - length);
  }
  static SmoothStep(from, to, tx) {
    let t = Scalar.Clamp(tx);
    t = -2 * t * t * t + 3 * t * t;
    return to * t + from * (1 - t);
  }
  static MoveTowards(current, target, maxDelta) {
    let result = 0;
    if (Math.abs(target - current) <= maxDelta) {
      result = target;
    } else {
      result = current + Scalar.Sign(target - current) * maxDelta;
    }
    return result;
  }
  static MoveTowardsAngle(current, target, maxDelta) {
    const num = Scalar.DeltaAngle(current, target);
    let result = 0;
    if (-maxDelta < num && num < maxDelta) {
      result = target;
    } else {
      target = current + num;
      result = Scalar.MoveTowards(current, target, maxDelta);
    }
    return result;
  }
  static Lerp(start, end, amount) {
    return start + (end - start) * amount;
  }
  static LerpAngle(start, end, amount) {
    let num = Scalar.Repeat(end - start, 360);
    if (num > 180) {
      num -= 360;
    }
    return start + num * Scalar.Clamp(amount);
  }
  static InverseLerp(a, b, value) {
    let result = 0;
    if (a != b) {
      result = Scalar.Clamp((value - a) / (b - a));
    } else {
      result = 0;
    }
    return result;
  }
  static Hermite(value1, tangent1, value2, tangent2, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const part1 = 2 * cubed - 3 * squared + 1;
    const part2 = -2 * cubed + 3 * squared;
    const part3 = cubed - 2 * squared + amount;
    const part4 = cubed - squared;
    return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;
  }
  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
    const t2 = time * time;
    return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;
  }
  static RandomRange(min, max) {
    if (min === max) {
      return min;
    }
    return Math.random() * (max - min) + min;
  }
  static RangeToPercent(number, min, max) {
    return (number - min) / (max - min);
  }
  static PercentToRange(percent, min, max) {
    return (max - min) * percent + min;
  }
  static NormalizeRadians(angle) {
    angle -= Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi);
    return angle;
  }
  static HCF(a, b) {
    const r = a % b;
    if (r === 0) {
      return b;
    }
    return Scalar.HCF(b, r);
  }
};
Scalar.TwoPi = Math.PI * 2;

// node_modules/@babylonjs/core/Maths/math.constants.js
var ToGammaSpace = 1 / 2.2;
var ToLinearSpace = 2.2;
var PHI = (1 + Math.sqrt(5)) / 2;
var Epsilon = 1e-3;

// node_modules/@babylonjs/core/Misc/typeStore.js
var _RegisteredTypes = {};
function RegisterClass(className2, type) {
  _RegisteredTypes[className2] = type;
}
function GetClass(fqdn) {
  return _RegisteredTypes[fqdn];
}

// node_modules/@babylonjs/core/Engines/performanceConfigurator.js
var PerformanceConfigurator = class {
  static SetMatrixPrecision(use64bits) {
    PerformanceConfigurator.MatrixTrackPrecisionChange = false;
    if (use64bits && !PerformanceConfigurator.MatrixUse64Bits) {
      if (PerformanceConfigurator.MatrixTrackedMatrices) {
        for (let m = 0; m < PerformanceConfigurator.MatrixTrackedMatrices.length; ++m) {
          const matrix = PerformanceConfigurator.MatrixTrackedMatrices[m];
          const values = matrix._m;
          matrix._m = new Array(16);
          for (let i = 0; i < 16; ++i) {
            matrix._m[i] = values[i];
          }
        }
      }
    }
    PerformanceConfigurator.MatrixUse64Bits = use64bits;
    PerformanceConfigurator.MatrixCurrentType = PerformanceConfigurator.MatrixUse64Bits ? Array : Float32Array;
    PerformanceConfigurator.MatrixTrackedMatrices = null;
  }
};
PerformanceConfigurator.MatrixUse64Bits = false;
PerformanceConfigurator.MatrixTrackPrecisionChange = true;
PerformanceConfigurator.MatrixCurrentType = Float32Array;
PerformanceConfigurator.MatrixTrackedMatrices = [];

// node_modules/@babylonjs/core/Engines/engineStore.js
var EngineStore = class {
  static get LastCreatedEngine() {
    if (this.Instances.length === 0) {
      return null;
    }
    return this.Instances[this.Instances.length - 1];
  }
  static get LastCreatedScene() {
    return this._LastCreatedScene;
  }
};
EngineStore.Instances = new Array();
EngineStore._LastCreatedScene = null;
EngineStore.UseFallbackTexture = true;
EngineStore.FallbackTexture = "";

// node_modules/@babylonjs/core/Misc/arrayTools.js
var ArrayTools = class {
  static BuildArray(size, itemBuilder) {
    const a = [];
    for (let i = 0; i < size; ++i) {
      a.push(itemBuilder());
    }
    return a;
  }
  static BuildTuple(size, itemBuilder) {
    return ArrayTools.BuildArray(size, itemBuilder);
  }
};
function _observeArrayfunction(object, functionName, callback) {
  const oldFunction = object[functionName];
  if (typeof oldFunction !== "function") {
    return null;
  }
  const newFunction = function() {
    const previousLength = object.length;
    const returnValue = newFunction.previous.apply(object, arguments);
    callback(functionName, previousLength);
    return returnValue;
  };
  oldFunction.next = newFunction;
  newFunction.previous = oldFunction;
  object[functionName] = newFunction;
  return () => {
    const previous = newFunction.previous;
    if (!previous) {
      return;
    }
    const next = newFunction.next;
    if (next) {
      previous.next = next;
      next.previous = previous;
    } else {
      previous.next = void 0;
      object[functionName] = previous;
    }
    newFunction.next = void 0;
    newFunction.previous = void 0;
  };
}
var observedArrayFunctions = ["push", "splice", "pop", "shift", "unshift"];
function _ObserveArray(array, callback) {
  const unObserveFunctions = observedArrayFunctions.map((name63) => {
    return _observeArrayfunction(array, name63, callback);
  });
  return () => {
    unObserveFunctions.forEach((unObserveFunction) => {
      unObserveFunction === null || unObserveFunction === void 0 ? void 0 : unObserveFunction();
    });
  };
}

// node_modules/@babylonjs/core/Maths/math.vector.js
var _ExtractAsInt = (value) => {
  return parseInt(value.toString().replace(/\W/g, ""));
};
var Vector2 = class {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  toString() {
    return `{X: ${this.x} Y: ${this.y}}`;
  }
  getClassName() {
    return "Vector2";
  }
  getHashCode() {
    const x = _ExtractAsInt(this.x);
    const y = _ExtractAsInt(this.y);
    let hash = x;
    hash = hash * 397 ^ y;
    return hash;
  }
  toArray(array, index = 0) {
    array[index] = this.x;
    array[index + 1] = this.y;
    return this;
  }
  fromArray(array, index = 0) {
    Vector2.FromArrayToRef(array, index, this);
    return this;
  }
  asArray() {
    const result = new Array();
    this.toArray(result, 0);
    return result;
  }
  copyFrom(source) {
    this.x = source.x;
    this.y = source.y;
    return this;
  }
  copyFromFloats(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  set(x, y) {
    return this.copyFromFloats(x, y);
  }
  add(otherVector) {
    return new this.constructor(this.x + otherVector.x, this.y + otherVector.y);
  }
  addToRef(otherVector, result) {
    result.x = this.x + otherVector.x;
    result.y = this.y + otherVector.y;
    return result;
  }
  addInPlace(otherVector) {
    this.x += otherVector.x;
    this.y += otherVector.y;
    return this;
  }
  addVector3(otherVector) {
    return new this.constructor(this.x + otherVector.x, this.y + otherVector.y);
  }
  subtract(otherVector) {
    return new this.constructor(this.x - otherVector.x, this.y - otherVector.y);
  }
  subtractToRef(otherVector, result) {
    result.x = this.x - otherVector.x;
    result.y = this.y - otherVector.y;
    return result;
  }
  subtractInPlace(otherVector) {
    this.x -= otherVector.x;
    this.y -= otherVector.y;
    return this;
  }
  multiplyInPlace(otherVector) {
    this.x *= otherVector.x;
    this.y *= otherVector.y;
    return this;
  }
  multiply(otherVector) {
    return new this.constructor(this.x * otherVector.x, this.y * otherVector.y);
  }
  multiplyToRef(otherVector, result) {
    result.x = this.x * otherVector.x;
    result.y = this.y * otherVector.y;
    return result;
  }
  multiplyByFloats(x, y) {
    return new this.constructor(this.x * x, this.y * y);
  }
  divide(otherVector) {
    return new this.constructor(this.x / otherVector.x, this.y / otherVector.y);
  }
  divideToRef(otherVector, result) {
    result.x = this.x / otherVector.x;
    result.y = this.y / otherVector.y;
    return result;
  }
  divideInPlace(otherVector) {
    return this.divideToRef(otherVector, this);
  }
  negate() {
    return new this.constructor(-this.x, -this.y);
  }
  negateInPlace() {
    this.x *= -1;
    this.y *= -1;
    return this;
  }
  negateToRef(result) {
    return result.copyFromFloats(this.x * -1, this.y * -1);
  }
  scaleInPlace(scale) {
    this.x *= scale;
    this.y *= scale;
    return this;
  }
  scale(scale) {
    const result = new this.constructor(0, 0);
    this.scaleToRef(scale, result);
    return result;
  }
  scaleToRef(scale, result) {
    result.x = this.x * scale;
    result.y = this.y * scale;
    return result;
  }
  scaleAndAddToRef(scale, result) {
    result.x += this.x * scale;
    result.y += this.y * scale;
    return result;
  }
  equals(otherVector) {
    return otherVector && this.x === otherVector.x && this.y === otherVector.y;
  }
  equalsWithEpsilon(otherVector, epsilon = Epsilon) {
    return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon);
  }
  floor() {
    return new this.constructor(Math.floor(this.x), Math.floor(this.y));
  }
  fract() {
    return new this.constructor(this.x - Math.floor(this.x), this.y - Math.floor(this.y));
  }
  rotateToRef(angle, result) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    result.x = cos * this.x - sin * this.y;
    result.y = sin * this.x + cos * this.y;
    return result;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  lengthSquared() {
    return this.x * this.x + this.y * this.y;
  }
  normalize() {
    Vector2.NormalizeToRef(this, this);
    return this;
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  static Zero() {
    return new Vector2(0, 0);
  }
  static One() {
    return new Vector2(1, 1);
  }
  static get ZeroReadOnly() {
    return Vector2._ZeroReadOnly;
  }
  static FromArray(array, offset = 0) {
    return new Vector2(array[offset], array[offset + 1]);
  }
  static FromArrayToRef(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
    return result;
  }
  static CatmullRom(value1, value2, value3, value4, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const x = 0.5 * (2 * value2.x + (-value1.x + value3.x) * amount + (2 * value1.x - 5 * value2.x + 4 * value3.x - value4.x) * squared + (-value1.x + 3 * value2.x - 3 * value3.x + value4.x) * cubed);
    const y = 0.5 * (2 * value2.y + (-value1.y + value3.y) * amount + (2 * value1.y - 5 * value2.y + 4 * value3.y - value4.y) * squared + (-value1.y + 3 * value2.y - 3 * value3.y + value4.y) * cubed);
    return new value1.constructor(x, y);
  }
  static Clamp(value, min, max) {
    let x = value.x;
    x = x > max.x ? max.x : x;
    x = x < min.x ? min.x : x;
    let y = value.y;
    y = y > max.y ? max.y : y;
    y = y < min.y ? min.y : y;
    return new value.constructor(x, y);
  }
  static Hermite(value1, tangent1, value2, tangent2, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const part1 = 2 * cubed - 3 * squared + 1;
    const part2 = -2 * cubed + 3 * squared;
    const part3 = cubed - 2 * squared + amount;
    const part4 = cubed - squared;
    const x = value1.x * part1 + value2.x * part2 + tangent1.x * part3 + tangent2.x * part4;
    const y = value1.y * part1 + value2.y * part2 + tangent1.y * part3 + tangent2.y * part4;
    return new value1.constructor(x, y);
  }
  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
    const result = new value1.constructor();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  }
  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
    const t2 = time * time;
    result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
    result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
    return result;
  }
  static Lerp(start, end, amount) {
    const x = start.x + (end.x - start.x) * amount;
    const y = start.y + (end.y - start.y) * amount;
    return new start.constructor(x, y);
  }
  static Dot(left, right) {
    return left.x * right.x + left.y * right.y;
  }
  static Normalize(vector) {
    const newVector = new vector.constructor();
    this.NormalizeToRef(vector, newVector);
    return newVector;
  }
  static NormalizeToRef(vector, result) {
    const len = vector.length();
    if (len === 0) {
      return result;
    }
    result.x = vector.x / len;
    result.y = vector.y / len;
    return result;
  }
  static Minimize(left, right) {
    const x = left.x < right.x ? left.x : right.x;
    const y = left.y < right.y ? left.y : right.y;
    return new left.constructor(x, y);
  }
  static Maximize(left, right) {
    const x = left.x > right.x ? left.x : right.x;
    const y = left.y > right.y ? left.y : right.y;
    return new left.constructor(x, y);
  }
  static Transform(vector, transformation) {
    const result = new vector.constructor();
    Vector2.TransformToRef(vector, transformation, result);
    return result;
  }
  static TransformToRef(vector, transformation, result) {
    const m = transformation.m;
    const x = vector.x * m[0] + vector.y * m[4] + m[12];
    const y = vector.x * m[1] + vector.y * m[5] + m[13];
    result.x = x;
    result.y = y;
    return result;
  }
  static PointInTriangle(p, p0, p1, p2) {
    const a = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
    const sign = a < 0 ? -1 : 1;
    const s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;
    const t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;
    return s > 0 && t > 0 && s + t < 2 * a * sign;
  }
  static Distance(value1, value2) {
    return Math.sqrt(Vector2.DistanceSquared(value1, value2));
  }
  static DistanceSquared(value1, value2) {
    const x = value1.x - value2.x;
    const y = value1.y - value2.y;
    return x * x + y * y;
  }
  static Center(value1, value2) {
    const result = new value1.constructor();
    return Vector2.CenterToRef(value1, value2, result);
  }
  static CenterToRef(value1, value2, ref) {
    return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2);
  }
  static DistanceOfPointFromSegment(p, segA, segB) {
    const l2 = Vector2.DistanceSquared(segA, segB);
    if (l2 === 0) {
      return Vector2.Distance(p, segA);
    }
    const v = segB.subtract(segA);
    const t = Math.max(0, Math.min(1, Vector2.Dot(p.subtract(segA), v) / l2));
    const proj = segA.add(v.multiplyByFloats(t, t));
    return Vector2.Distance(p, proj);
  }
};
Vector2._ZeroReadOnly = Vector2.Zero();
var Vector3 = class {
  constructor(x = 0, y = 0, z = 0) {
    this._isDirty = true;
    this._x = x;
    this._y = y;
    this._z = z;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._isDirty = true;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._isDirty = true;
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._isDirty = true;
  }
  toString() {
    return `{X: ${this._x} Y: ${this._y} Z: ${this._z}}`;
  }
  getClassName() {
    return "Vector3";
  }
  getHashCode() {
    const x = _ExtractAsInt(this._x);
    const y = _ExtractAsInt(this._y);
    const z = _ExtractAsInt(this._z);
    let hash = x;
    hash = hash * 397 ^ y;
    hash = hash * 397 ^ z;
    return hash;
  }
  asArray() {
    const result = [];
    this.toArray(result, 0);
    return result;
  }
  toArray(array, index = 0) {
    array[index] = this._x;
    array[index + 1] = this._y;
    array[index + 2] = this._z;
    return this;
  }
  fromArray(array, index = 0) {
    Vector3.FromArrayToRef(array, index, this);
    return this;
  }
  toQuaternion() {
    return Quaternion.RotationYawPitchRoll(this._y, this._x, this._z);
  }
  addInPlace(otherVector) {
    return this.addInPlaceFromFloats(otherVector._x, otherVector._y, otherVector._z);
  }
  addInPlaceFromFloats(x, y, z) {
    this.x += x;
    this.y += y;
    this.z += z;
    return this;
  }
  add(otherVector) {
    return new this.constructor(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);
  }
  addToRef(otherVector, result) {
    return result.copyFromFloats(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);
  }
  subtractInPlace(otherVector) {
    this.x -= otherVector._x;
    this.y -= otherVector._y;
    this.z -= otherVector._z;
    return this;
  }
  subtract(otherVector) {
    return new this.constructor(this._x - otherVector._x, this._y - otherVector._y, this._z - otherVector._z);
  }
  subtractToRef(otherVector, result) {
    return this.subtractFromFloatsToRef(otherVector._x, otherVector._y, otherVector._z, result);
  }
  subtractFromFloats(x, y, z) {
    return new this.constructor(this._x - x, this._y - y, this._z - z);
  }
  subtractFromFloatsToRef(x, y, z, result) {
    return result.copyFromFloats(this._x - x, this._y - y, this._z - z);
  }
  negate() {
    return new this.constructor(-this._x, -this._y, -this._z);
  }
  negateInPlace() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    return this;
  }
  negateToRef(result) {
    return result.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);
  }
  scaleInPlace(scale) {
    this.x *= scale;
    this.y *= scale;
    this.z *= scale;
    return this;
  }
  scale(scale) {
    return new this.constructor(this._x * scale, this._y * scale, this._z * scale);
  }
  scaleToRef(scale, result) {
    return result.copyFromFloats(this._x * scale, this._y * scale, this._z * scale);
  }
  getNormalToRef(result) {
    const radius = this.length();
    let theta = Math.acos(this.y / radius);
    const phi = Math.atan2(this.z, this.x);
    if (theta > Math.PI / 2) {
      theta -= Math.PI / 2;
    } else {
      theta += Math.PI / 2;
    }
    const x = radius * Math.sin(theta) * Math.cos(phi);
    const y = radius * Math.cos(theta);
    const z = radius * Math.sin(theta) * Math.sin(phi);
    result.set(x, y, z);
    return result;
  }
  applyRotationQuaternionToRef(q, result) {
    const ix = q.w * this.x + q.y * this.z - q.z * this.y;
    const iy = q.w * this.y + q.z * this.x - q.x * this.z;
    const iz = q.w * this.z + q.x * this.y - q.y * this.x;
    const iw = -q.x * this.x - q.y * this.y - q.z * this.z;
    result.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;
    result.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;
    result.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;
    return result;
  }
  applyRotationQuaternionInPlace(q) {
    return this.applyRotationQuaternionToRef(q, this);
  }
  applyRotationQuaternion(q) {
    return this.applyRotationQuaternionToRef(q, new this.constructor());
  }
  scaleAndAddToRef(scale, result) {
    return result.addInPlaceFromFloats(this._x * scale, this._y * scale, this._z * scale);
  }
  projectOnPlane(plane, origin) {
    const result = new this.constructor();
    this.projectOnPlaneToRef(plane, origin, result);
    return result;
  }
  projectOnPlaneToRef(plane, origin, result) {
    const n = plane.normal;
    const d = plane.d;
    const V = MathTmp.Vector3[0];
    this.subtractToRef(origin, V);
    V.normalize();
    const denom = Vector3.Dot(V, n);
    if (Math.abs(denom) < Math.pow(10, -10)) {
      result.setAll(Infinity);
    } else {
      const t = -(Vector3.Dot(origin, n) + d) / denom;
      const scaledV = V.scaleInPlace(t);
      origin.addToRef(scaledV, result);
    }
    return result;
  }
  equals(otherVector) {
    return otherVector && this._x === otherVector._x && this._y === otherVector._y && this._z === otherVector._z;
  }
  equalsWithEpsilon(otherVector, epsilon = Epsilon) {
    return otherVector && Scalar.WithinEpsilon(this._x, otherVector._x, epsilon) && Scalar.WithinEpsilon(this._y, otherVector._y, epsilon) && Scalar.WithinEpsilon(this._z, otherVector._z, epsilon);
  }
  equalsToFloats(x, y, z) {
    return this._x === x && this._y === y && this._z === z;
  }
  multiplyInPlace(otherVector) {
    this.x *= otherVector._x;
    this.y *= otherVector._y;
    this.z *= otherVector._z;
    return this;
  }
  multiply(otherVector) {
    return this.multiplyByFloats(otherVector._x, otherVector._y, otherVector._z);
  }
  multiplyToRef(otherVector, result) {
    return result.copyFromFloats(this._x * otherVector._x, this._y * otherVector._y, this._z * otherVector._z);
  }
  multiplyByFloats(x, y, z) {
    return new this.constructor(this._x * x, this._y * y, this._z * z);
  }
  divide(otherVector) {
    return new this.constructor(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);
  }
  divideToRef(otherVector, result) {
    return result.copyFromFloats(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);
  }
  divideInPlace(otherVector) {
    return this.divideToRef(otherVector, this);
  }
  minimizeInPlace(other) {
    return this.minimizeInPlaceFromFloats(other._x, other._y, other._z);
  }
  maximizeInPlace(other) {
    return this.maximizeInPlaceFromFloats(other._x, other._y, other._z);
  }
  minimizeInPlaceFromFloats(x, y, z) {
    if (x < this._x) {
      this.x = x;
    }
    if (y < this._y) {
      this.y = y;
    }
    if (z < this._z) {
      this.z = z;
    }
    return this;
  }
  maximizeInPlaceFromFloats(x, y, z) {
    if (x > this._x) {
      this.x = x;
    }
    if (y > this._y) {
      this.y = y;
    }
    if (z > this._z) {
      this.z = z;
    }
    return this;
  }
  isNonUniformWithinEpsilon(epsilon) {
    const absX = Math.abs(this._x);
    const absY = Math.abs(this._y);
    if (!Scalar.WithinEpsilon(absX, absY, epsilon)) {
      return true;
    }
    const absZ = Math.abs(this._z);
    if (!Scalar.WithinEpsilon(absX, absZ, epsilon)) {
      return true;
    }
    if (!Scalar.WithinEpsilon(absY, absZ, epsilon)) {
      return true;
    }
    return false;
  }
  get isNonUniform() {
    const absX = Math.abs(this._x);
    const absY = Math.abs(this._y);
    if (absX !== absY) {
      return true;
    }
    const absZ = Math.abs(this._z);
    if (absX !== absZ) {
      return true;
    }
    return false;
  }
  floor() {
    return new this.constructor(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));
  }
  fract() {
    return new this.constructor(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
  }
  lengthSquared() {
    return this._x * this._x + this._y * this._y + this._z * this._z;
  }
  get hasAZeroComponent() {
    return this._x * this._y * this._z === 0;
  }
  normalize() {
    return this.normalizeFromLength(this.length());
  }
  reorderInPlace(order) {
    order = order.toLowerCase();
    if (order === "xyz") {
      return this;
    }
    MathTmp.Vector3[0].copyFrom(this);
    ["x", "y", "z"].forEach((val, i) => {
      this[val] = MathTmp.Vector3[0][order[i]];
    });
    return this;
  }
  rotateByQuaternionToRef(quaternion, result) {
    quaternion.toRotationMatrix(MathTmp.Matrix[0]);
    Vector3.TransformCoordinatesToRef(this, MathTmp.Matrix[0], result);
    return result;
  }
  rotateByQuaternionAroundPointToRef(quaternion, point, result) {
    this.subtractToRef(point, MathTmp.Vector3[0]);
    MathTmp.Vector3[0].rotateByQuaternionToRef(quaternion, MathTmp.Vector3[0]);
    point.addToRef(MathTmp.Vector3[0], result);
    return result;
  }
  cross(other) {
    const result = new this.constructor();
    return Vector3.CrossToRef(this, other, result);
  }
  normalizeFromLength(len) {
    if (len === 0 || len === 1) {
      return this;
    }
    return this.scaleInPlace(1 / len);
  }
  normalizeToNew() {
    const normalized = new this.constructor(0, 0, 0);
    this.normalizeToRef(normalized);
    return normalized;
  }
  normalizeToRef(reference) {
    const len = this.length();
    if (len === 0 || len === 1) {
      return reference.copyFromFloats(this._x, this._y, this._z);
    }
    return this.scaleToRef(1 / len, reference);
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z);
  }
  copyFrom(source) {
    return this.copyFromFloats(source._x, source._y, source._z);
  }
  copyFromFloats(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  set(x, y, z) {
    return this.copyFromFloats(x, y, z);
  }
  setAll(v) {
    this.x = this.y = this.z = v;
    return this;
  }
  static GetClipFactor(vector0, vector1, axis, size) {
    const d0 = Vector3.Dot(vector0, axis) - size;
    const d1 = Vector3.Dot(vector1, axis) - size;
    const s = d0 / (d0 - d1);
    return s;
  }
  static GetAngleBetweenVectors(vector0, vector1, normal) {
    const v0 = vector0.normalizeToRef(MathTmp.Vector3[1]);
    const v1 = vector1.normalizeToRef(MathTmp.Vector3[2]);
    let dot = Vector3.Dot(v0, v1);
    dot = Scalar.Clamp(dot, -1, 1);
    const angle = Math.acos(dot);
    const n = MathTmp.Vector3[3];
    Vector3.CrossToRef(v0, v1, n);
    if (Vector3.Dot(n, normal) > 0) {
      return isNaN(angle) ? 0 : angle;
    }
    return isNaN(angle) ? -Math.PI : -Math.acos(dot);
  }
  static GetAngleBetweenVectorsOnPlane(vector0, vector1, normal) {
    MathTmp.Vector3[0].copyFrom(vector0);
    const v0 = MathTmp.Vector3[0];
    MathTmp.Vector3[1].copyFrom(vector1);
    const v1 = MathTmp.Vector3[1];
    MathTmp.Vector3[2].copyFrom(normal);
    const vNormal = MathTmp.Vector3[2];
    const right = MathTmp.Vector3[3];
    const forward = MathTmp.Vector3[4];
    v0.normalize();
    v1.normalize();
    vNormal.normalize();
    Vector3.CrossToRef(vNormal, v0, right);
    Vector3.CrossToRef(right, vNormal, forward);
    const angle = Math.atan2(Vector3.Dot(v1, right), Vector3.Dot(v1, forward));
    return Scalar.NormalizeRadians(angle);
  }
  static PitchYawRollToMoveBetweenPointsToRef(start, target, ref) {
    const diff = TmpVectors.Vector3[0];
    target.subtractToRef(start, diff);
    ref.y = Math.atan2(diff.x, diff.z) || 0;
    ref.x = Math.atan2(Math.sqrt(diff.x ** 2 + diff.z ** 2), diff.y) || 0;
    ref.z = 0;
    return ref;
  }
  static PitchYawRollToMoveBetweenPoints(start, target) {
    const ref = Vector3.Zero();
    return Vector3.PitchYawRollToMoveBetweenPointsToRef(start, target, ref);
  }
  static SlerpToRef(vector0, vector1, slerp, result) {
    slerp = Scalar.Clamp(slerp, 0, 1);
    const vector0Dir = MathTmp.Vector3[0];
    const vector1Dir = MathTmp.Vector3[1];
    vector0Dir.copyFrom(vector0);
    const vector0Length = vector0Dir.length();
    vector0Dir.normalizeFromLength(vector0Length);
    vector1Dir.copyFrom(vector1);
    const vector1Length = vector1Dir.length();
    vector1Dir.normalizeFromLength(vector1Length);
    const dot = Vector3.Dot(vector0Dir, vector1Dir);
    let scale0;
    let scale1;
    if (dot < 1 - Epsilon) {
      const omega = Math.acos(dot);
      const invSin = 1 / Math.sin(omega);
      scale0 = Math.sin((1 - slerp) * omega) * invSin;
      scale1 = Math.sin(slerp * omega) * invSin;
    } else {
      scale0 = 1 - slerp;
      scale1 = slerp;
    }
    vector0Dir.scaleInPlace(scale0);
    vector1Dir.scaleInPlace(scale1);
    result.copyFrom(vector0Dir).addInPlace(vector1Dir);
    result.scaleInPlace(Scalar.Lerp(vector0Length, vector1Length, slerp));
    return result;
  }
  static SmoothToRef(source, goal, deltaTime, lerpTime, result) {
    Vector3.SlerpToRef(source, goal, lerpTime === 0 ? 1 : deltaTime / lerpTime, result);
    return result;
  }
  static FromArray(array, offset = 0) {
    return new Vector3(array[offset], array[offset + 1], array[offset + 2]);
  }
  static FromFloatArray(array, offset) {
    return Vector3.FromArray(array, offset);
  }
  static FromArrayToRef(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
    result.z = array[offset + 2];
    return result;
  }
  static FromFloatArrayToRef(array, offset, result) {
    return Vector3.FromArrayToRef(array, offset, result);
  }
  static FromFloatsToRef(x, y, z, result) {
    result.copyFromFloats(x, y, z);
    return result;
  }
  static Zero() {
    return new Vector3(0, 0, 0);
  }
  static One() {
    return new Vector3(1, 1, 1);
  }
  static Up() {
    return new Vector3(0, 1, 0);
  }
  static get UpReadOnly() {
    return Vector3._UpReadOnly;
  }
  static get DownReadOnly() {
    return Vector3._DownReadOnly;
  }
  static get RightReadOnly() {
    return Vector3._RightReadOnly;
  }
  static get LeftReadOnly() {
    return Vector3._LeftReadOnly;
  }
  static get LeftHandedForwardReadOnly() {
    return Vector3._LeftHandedForwardReadOnly;
  }
  static get RightHandedForwardReadOnly() {
    return Vector3._RightHandedForwardReadOnly;
  }
  static get ZeroReadOnly() {
    return Vector3._ZeroReadOnly;
  }
  static Down() {
    return new Vector3(0, -1, 0);
  }
  static Forward(rightHandedSystem = false) {
    return new Vector3(0, 0, rightHandedSystem ? -1 : 1);
  }
  static Backward(rightHandedSystem = false) {
    return new Vector3(0, 0, rightHandedSystem ? 1 : -1);
  }
  static Right() {
    return new Vector3(1, 0, 0);
  }
  static Left() {
    return new Vector3(-1, 0, 0);
  }
  static TransformCoordinates(vector, transformation) {
    const result = Vector3.Zero();
    Vector3.TransformCoordinatesToRef(vector, transformation, result);
    return result;
  }
  static TransformCoordinatesToRef(vector, transformation, result) {
    Vector3.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
    return result;
  }
  static TransformCoordinatesFromFloatsToRef(x, y, z, transformation, result) {
    const m = transformation.m;
    const rx = x * m[0] + y * m[4] + z * m[8] + m[12];
    const ry = x * m[1] + y * m[5] + z * m[9] + m[13];
    const rz = x * m[2] + y * m[6] + z * m[10] + m[14];
    const rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);
    result.x = rx * rw;
    result.y = ry * rw;
    result.z = rz * rw;
    return result;
  }
  static TransformNormal(vector, transformation) {
    const result = Vector3.Zero();
    Vector3.TransformNormalToRef(vector, transformation, result);
    return result;
  }
  static TransformNormalToRef(vector, transformation, result) {
    this.TransformNormalFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
    return result;
  }
  static TransformNormalFromFloatsToRef(x, y, z, transformation, result) {
    const m = transformation.m;
    result.x = x * m[0] + y * m[4] + z * m[8];
    result.y = x * m[1] + y * m[5] + z * m[9];
    result.z = x * m[2] + y * m[6] + z * m[10];
    return result;
  }
  static CatmullRom(value1, value2, value3, value4, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const x = 0.5 * (2 * value2._x + (-value1._x + value3._x) * amount + (2 * value1._x - 5 * value2._x + 4 * value3._x - value4._x) * squared + (-value1._x + 3 * value2._x - 3 * value3._x + value4._x) * cubed);
    const y = 0.5 * (2 * value2._y + (-value1._y + value3._y) * amount + (2 * value1._y - 5 * value2._y + 4 * value3._y - value4._y) * squared + (-value1._y + 3 * value2._y - 3 * value3._y + value4._y) * cubed);
    const z = 0.5 * (2 * value2._z + (-value1._z + value3._z) * amount + (2 * value1._z - 5 * value2._z + 4 * value3._z - value4._z) * squared + (-value1._z + 3 * value2._z - 3 * value3._z + value4._z) * cubed);
    return new value1.constructor(x, y, z);
  }
  static Clamp(value, min, max) {
    const result = new value.constructor();
    Vector3.ClampToRef(value, min, max, result);
    return result;
  }
  static ClampToRef(value, min, max, result) {
    let x = value._x;
    x = x > max._x ? max._x : x;
    x = x < min._x ? min._x : x;
    let y = value._y;
    y = y > max._y ? max._y : y;
    y = y < min._y ? min._y : y;
    let z = value._z;
    z = z > max._z ? max._z : z;
    z = z < min._z ? min._z : z;
    result.copyFromFloats(x, y, z);
    return result;
  }
  static CheckExtends(v, min, max) {
    min.minimizeInPlace(v);
    max.maximizeInPlace(v);
  }
  static Hermite(value1, tangent1, value2, tangent2, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const part1 = 2 * cubed - 3 * squared + 1;
    const part2 = -2 * cubed + 3 * squared;
    const part3 = cubed - 2 * squared + amount;
    const part4 = cubed - squared;
    const x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;
    const y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;
    const z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;
    return new value1.constructor(x, y, z);
  }
  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
    const result = new value1.constructor();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  }
  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
    const t2 = time * time;
    result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
    result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
    result.z = (t2 - time) * 6 * value1.z + (3 * t2 - 4 * time + 1) * tangent1.z + (-t2 + time) * 6 * value2.z + (3 * t2 - 2 * time) * tangent2.z;
    return result;
  }
  static Lerp(start, end, amount) {
    const result = new start.constructor(0, 0, 0);
    Vector3.LerpToRef(start, end, amount, result);
    return result;
  }
  static LerpToRef(start, end, amount, result) {
    result.x = start._x + (end._x - start._x) * amount;
    result.y = start._y + (end._y - start._y) * amount;
    result.z = start._z + (end._z - start._z) * amount;
    return result;
  }
  static Dot(left, right) {
    return left._x * right._x + left._y * right._y + left._z * right._z;
  }
  static Cross(left, right) {
    const result = new left.constructor();
    Vector3.CrossToRef(left, right, result);
    return result;
  }
  static CrossToRef(left, right, result) {
    const x = left._y * right._z - left._z * right._y;
    const y = left._z * right._x - left._x * right._z;
    const z = left._x * right._y - left._y * right._x;
    result.copyFromFloats(x, y, z);
    return result;
  }
  static Normalize(vector) {
    const result = Vector3.Zero();
    Vector3.NormalizeToRef(vector, result);
    return result;
  }
  static NormalizeToRef(vector, result) {
    vector.normalizeToRef(result);
    return result;
  }
  static Project(vector, world, transform, viewport) {
    const result = new vector.constructor();
    Vector3.ProjectToRef(vector, world, transform, viewport, result);
    return result;
  }
  static ProjectToRef(vector, world, transform, viewport, result) {
    const cw = viewport.width;
    const ch = viewport.height;
    const cx = viewport.x;
    const cy = viewport.y;
    const viewportMatrix = MathTmp.Matrix[1];
    Matrix.FromValuesToRef(cw / 2, 0, 0, 0, 0, -ch / 2, 0, 0, 0, 0, 0.5, 0, cx + cw / 2, ch / 2 + cy, 0.5, 1, viewportMatrix);
    const matrix = MathTmp.Matrix[0];
    world.multiplyToRef(transform, matrix);
    matrix.multiplyToRef(viewportMatrix, matrix);
    Vector3.TransformCoordinatesToRef(vector, matrix, result);
    return result;
  }
  static Reflect(inDirection, normal) {
    return this.ReflectToRef(inDirection, normal, new Vector3());
  }
  static ReflectToRef(inDirection, normal, ref) {
    const tmp = TmpVectors.Vector3[0];
    tmp.copyFrom(normal).scaleInPlace(2 * Vector3.Dot(inDirection, normal));
    return ref.copyFrom(inDirection).subtractInPlace(tmp);
  }
  static _UnprojectFromInvertedMatrixToRef(source, matrix, result) {
    Vector3.TransformCoordinatesToRef(source, matrix, result);
    const m = matrix.m;
    const num = source._x * m[3] + source._y * m[7] + source._z * m[11] + m[15];
    if (Scalar.WithinEpsilon(num, 1)) {
      result.scaleInPlace(1 / num);
    }
    return result;
  }
  static UnprojectFromTransform(source, viewportWidth, viewportHeight, world, transform) {
    return this.Unproject(source, viewportWidth, viewportHeight, world, transform, Matrix.IdentityReadOnly);
  }
  static Unproject(source, viewportWidth, viewportHeight, world, view, projection) {
    const result = new source.constructor();
    Vector3.UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result);
    return result;
  }
  static UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result) {
    Vector3.UnprojectFloatsToRef(source._x, source._y, source._z, viewportWidth, viewportHeight, world, view, projection, result);
    return result;
  }
  static UnprojectFloatsToRef(sourceX, sourceY, sourceZ, viewportWidth, viewportHeight, world, view, projection, result) {
    var _a;
    const matrix = MathTmp.Matrix[0];
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    matrix.invert();
    const screenSource = MathTmp.Vector3[0];
    screenSource.x = sourceX / viewportWidth * 2 - 1;
    screenSource.y = -(sourceY / viewportHeight * 2 - 1);
    if ((_a = EngineStore.LastCreatedEngine) === null || _a === void 0 ? void 0 : _a.isNDCHalfZRange) {
      screenSource.z = sourceZ;
    } else {
      screenSource.z = 2 * sourceZ - 1;
    }
    Vector3._UnprojectFromInvertedMatrixToRef(screenSource, matrix, result);
    return result;
  }
  static Minimize(left, right) {
    const min = new left.constructor();
    min.copyFrom(left);
    min.minimizeInPlace(right);
    return min;
  }
  static Maximize(left, right) {
    const max = new left.constructor();
    max.copyFrom(left);
    max.maximizeInPlace(right);
    return max;
  }
  static Distance(value1, value2) {
    return Math.sqrt(Vector3.DistanceSquared(value1, value2));
  }
  static DistanceSquared(value1, value2) {
    const x = value1._x - value2._x;
    const y = value1._y - value2._y;
    const z = value1._z - value2._z;
    return x * x + y * y + z * z;
  }
  static ProjectOnTriangleToRef(vector, p0, p1, p2, ref) {
    const p1p0 = MathTmp.Vector3[0];
    const p2p0 = MathTmp.Vector3[1];
    const p2p1 = MathTmp.Vector3[2];
    const normal = MathTmp.Vector3[3];
    const vectorp0 = MathTmp.Vector3[4];
    p1.subtractToRef(p0, p1p0);
    p2.subtractToRef(p0, p2p0);
    p2.subtractToRef(p1, p2p1);
    const p1p0L = p1p0.length();
    const p2p0L = p2p0.length();
    const p2p1L = p2p1.length();
    if (p1p0L < Epsilon || p2p0L < Epsilon || p2p1L < Epsilon) {
      ref.copyFrom(p0);
      return Vector3.Distance(vector, p0);
    }
    vector.subtractToRef(p0, vectorp0);
    Vector3.CrossToRef(p1p0, p2p0, normal);
    const nl = normal.length();
    if (nl < Epsilon) {
      ref.copyFrom(p0);
      return Vector3.Distance(vector, p0);
    }
    normal.normalizeFromLength(nl);
    let l = vectorp0.length();
    if (l < Epsilon) {
      ref.copyFrom(p0);
      return 0;
    }
    vectorp0.normalizeFromLength(l);
    const cosA = Vector3.Dot(normal, vectorp0);
    const projVector = MathTmp.Vector3[5];
    const proj = MathTmp.Vector3[6];
    projVector.copyFrom(normal).scaleInPlace(-l * cosA);
    proj.copyFrom(vector).addInPlace(projVector);
    const v0 = MathTmp.Vector3[4];
    const v1 = MathTmp.Vector3[5];
    const v2 = MathTmp.Vector3[7];
    const tmp = MathTmp.Vector3[8];
    v0.copyFrom(p1p0).scaleInPlace(1 / p1p0L);
    tmp.copyFrom(p2p0).scaleInPlace(1 / p2p0L);
    v0.addInPlace(tmp).scaleInPlace(-1);
    v1.copyFrom(p1p0).scaleInPlace(-1 / p1p0L);
    tmp.copyFrom(p2p1).scaleInPlace(1 / p2p1L);
    v1.addInPlace(tmp).scaleInPlace(-1);
    v2.copyFrom(p2p1).scaleInPlace(-1 / p2p1L);
    tmp.copyFrom(p2p0).scaleInPlace(-1 / p2p0L);
    v2.addInPlace(tmp).scaleInPlace(-1);
    const projP = MathTmp.Vector3[9];
    let dot;
    projP.copyFrom(proj).subtractInPlace(p0);
    Vector3.CrossToRef(v0, projP, tmp);
    dot = Vector3.Dot(tmp, normal);
    const s0 = dot;
    projP.copyFrom(proj).subtractInPlace(p1);
    Vector3.CrossToRef(v1, projP, tmp);
    dot = Vector3.Dot(tmp, normal);
    const s1 = dot;
    projP.copyFrom(proj).subtractInPlace(p2);
    Vector3.CrossToRef(v2, projP, tmp);
    dot = Vector3.Dot(tmp, normal);
    const s2 = dot;
    const edge = MathTmp.Vector3[10];
    let e0, e1;
    if (s0 > 0 && s1 < 0) {
      edge.copyFrom(p1p0);
      e0 = p0;
      e1 = p1;
    } else if (s1 > 0 && s2 < 0) {
      edge.copyFrom(p2p1);
      e0 = p1;
      e1 = p2;
    } else {
      edge.copyFrom(p2p0).scaleInPlace(-1);
      e0 = p2;
      e1 = p0;
    }
    const tmp2 = MathTmp.Vector3[9];
    const tmp3 = MathTmp.Vector3[4];
    e0.subtractToRef(proj, tmp);
    e1.subtractToRef(proj, tmp2);
    Vector3.CrossToRef(tmp, tmp2, tmp3);
    const isOutside = Vector3.Dot(tmp3, normal) < 0;
    if (!isOutside) {
      ref.copyFrom(proj);
      return Math.abs(l * cosA);
    }
    const r = MathTmp.Vector3[5];
    Vector3.CrossToRef(edge, tmp3, r);
    r.normalize();
    const e0proj = MathTmp.Vector3[9];
    e0proj.copyFrom(e0).subtractInPlace(proj);
    const e0projL = e0proj.length();
    if (e0projL < Epsilon) {
      ref.copyFrom(e0);
      return Vector3.Distance(vector, e0);
    }
    e0proj.normalizeFromLength(e0projL);
    const cosG = Vector3.Dot(r, e0proj);
    const triProj = MathTmp.Vector3[7];
    triProj.copyFrom(proj).addInPlace(r.scaleInPlace(e0projL * cosG));
    tmp.copyFrom(triProj).subtractInPlace(e0);
    l = edge.length();
    edge.normalizeFromLength(l);
    let t = Vector3.Dot(tmp, edge) / Math.max(l, Epsilon);
    t = Scalar.Clamp(t, 0, 1);
    triProj.copyFrom(e0).addInPlace(edge.scaleInPlace(t * l));
    ref.copyFrom(triProj);
    return Vector3.Distance(vector, triProj);
  }
  static Center(value1, value2) {
    return Vector3.CenterToRef(value1, value2, Vector3.Zero());
  }
  static CenterToRef(value1, value2, ref) {
    return ref.copyFromFloats((value1._x + value2._x) / 2, (value1._y + value2._y) / 2, (value1._z + value2._z) / 2);
  }
  static RotationFromAxis(axis1, axis2, axis3) {
    const rotation = new axis1.constructor();
    Vector3.RotationFromAxisToRef(axis1, axis2, axis3, rotation);
    return rotation;
  }
  static RotationFromAxisToRef(axis1, axis2, axis3, ref) {
    const quat = MathTmp.Quaternion[0];
    Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);
    quat.toEulerAnglesToRef(ref);
    return ref;
  }
};
Vector3._UpReadOnly = Vector3.Up();
Vector3._DownReadOnly = Vector3.Down();
Vector3._LeftHandedForwardReadOnly = Vector3.Forward(false);
Vector3._RightHandedForwardReadOnly = Vector3.Forward(true);
Vector3._RightReadOnly = Vector3.Right();
Vector3._LeftReadOnly = Vector3.Left();
Vector3._ZeroReadOnly = Vector3.Zero();
var Vector4 = class {
  constructor(x = 0, y = 0, z = 0, w = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  toString() {
    return `{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}`;
  }
  getClassName() {
    return "Vector4";
  }
  getHashCode() {
    const x = _ExtractAsInt(this.x);
    const y = _ExtractAsInt(this.y);
    const z = _ExtractAsInt(this.z);
    const w = _ExtractAsInt(this.w);
    let hash = x;
    hash = hash * 397 ^ y;
    hash = hash * 397 ^ z;
    hash = hash * 397 ^ w;
    return hash;
  }
  asArray() {
    const result = new Array();
    this.toArray(result, 0);
    return result;
  }
  toArray(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this.x;
    array[index + 1] = this.y;
    array[index + 2] = this.z;
    array[index + 3] = this.w;
    return this;
  }
  fromArray(array, index = 0) {
    Vector4.FromArrayToRef(array, index, this);
    return this;
  }
  addInPlace(otherVector) {
    this.x += otherVector.x;
    this.y += otherVector.y;
    this.z += otherVector.z;
    this.w += otherVector.w;
    return this;
  }
  add(otherVector) {
    return new this.constructor(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);
  }
  addToRef(otherVector, result) {
    result.x = this.x + otherVector.x;
    result.y = this.y + otherVector.y;
    result.z = this.z + otherVector.z;
    result.w = this.w + otherVector.w;
    return result;
  }
  subtractInPlace(otherVector) {
    this.x -= otherVector.x;
    this.y -= otherVector.y;
    this.z -= otherVector.z;
    this.w -= otherVector.w;
    return this;
  }
  subtract(otherVector) {
    return new this.constructor(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);
  }
  subtractToRef(otherVector, result) {
    result.x = this.x - otherVector.x;
    result.y = this.y - otherVector.y;
    result.z = this.z - otherVector.z;
    result.w = this.w - otherVector.w;
    return result;
  }
  subtractFromFloats(x, y, z, w) {
    return new this.constructor(this.x - x, this.y - y, this.z - z, this.w - w);
  }
  subtractFromFloatsToRef(x, y, z, w, result) {
    result.x = this.x - x;
    result.y = this.y - y;
    result.z = this.z - z;
    result.w = this.w - w;
    return result;
  }
  negate() {
    return new this.constructor(-this.x, -this.y, -this.z, -this.w);
  }
  negateInPlace() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    this.w *= -1;
    return this;
  }
  negateToRef(result) {
    return result.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);
  }
  scaleInPlace(scale) {
    this.x *= scale;
    this.y *= scale;
    this.z *= scale;
    this.w *= scale;
    return this;
  }
  scale(scale) {
    return new this.constructor(this.x * scale, this.y * scale, this.z * scale, this.w * scale);
  }
  scaleToRef(scale, result) {
    result.x = this.x * scale;
    result.y = this.y * scale;
    result.z = this.z * scale;
    result.w = this.w * scale;
    return result;
  }
  scaleAndAddToRef(scale, result) {
    result.x += this.x * scale;
    result.y += this.y * scale;
    result.z += this.z * scale;
    result.w += this.w * scale;
    return result;
  }
  equals(otherVector) {
    return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;
  }
  equalsWithEpsilon(otherVector, epsilon = Epsilon) {
    return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) && Scalar.WithinEpsilon(this.z, otherVector.z, epsilon) && Scalar.WithinEpsilon(this.w, otherVector.w, epsilon);
  }
  equalsToFloats(x, y, z, w) {
    return this.x === x && this.y === y && this.z === z && this.w === w;
  }
  multiplyInPlace(otherVector) {
    this.x *= otherVector.x;
    this.y *= otherVector.y;
    this.z *= otherVector.z;
    this.w *= otherVector.w;
    return this;
  }
  multiply(otherVector) {
    return new this.constructor(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);
  }
  multiplyToRef(otherVector, result) {
    result.x = this.x * otherVector.x;
    result.y = this.y * otherVector.y;
    result.z = this.z * otherVector.z;
    result.w = this.w * otherVector.w;
    return result;
  }
  multiplyByFloats(x, y, z, w) {
    return new this.constructor(this.x * x, this.y * y, this.z * z, this.w * w);
  }
  divide(otherVector) {
    return new this.constructor(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);
  }
  divideToRef(otherVector, result) {
    result.x = this.x / otherVector.x;
    result.y = this.y / otherVector.y;
    result.z = this.z / otherVector.z;
    result.w = this.w / otherVector.w;
    return result;
  }
  divideInPlace(otherVector) {
    return this.divideToRef(otherVector, this);
  }
  minimizeInPlace(other) {
    if (other.x < this.x) {
      this.x = other.x;
    }
    if (other.y < this.y) {
      this.y = other.y;
    }
    if (other.z < this.z) {
      this.z = other.z;
    }
    if (other.w < this.w) {
      this.w = other.w;
    }
    return this;
  }
  maximizeInPlace(other) {
    if (other.x > this.x) {
      this.x = other.x;
    }
    if (other.y > this.y) {
      this.y = other.y;
    }
    if (other.z > this.z) {
      this.z = other.z;
    }
    if (other.w > this.w) {
      this.w = other.w;
    }
    return this;
  }
  floor() {
    return new this.constructor(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));
  }
  fract() {
    return new this.constructor(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  lengthSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  normalize() {
    const len = this.length();
    if (len === 0) {
      return this;
    }
    return this.scaleInPlace(1 / len);
  }
  toVector3() {
    return new Vector3(this.x, this.y, this.z);
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copyFrom(source) {
    this.x = source.x;
    this.y = source.y;
    this.z = source.z;
    this.w = source.w;
    return this;
  }
  copyFromFloats(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  set(x, y, z, w) {
    return this.copyFromFloats(x, y, z, w);
  }
  setAll(v) {
    this.x = this.y = this.z = this.w = v;
    return this;
  }
  static FromArray(array, offset) {
    if (!offset) {
      offset = 0;
    }
    return new Vector4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
  }
  static FromArrayToRef(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
    result.z = array[offset + 2];
    result.w = array[offset + 3];
    return result;
  }
  static FromFloatArrayToRef(array, offset, result) {
    Vector4.FromArrayToRef(array, offset, result);
    return result;
  }
  static FromFloatsToRef(x, y, z, w, result) {
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
  }
  static Zero() {
    return new Vector4(0, 0, 0, 0);
  }
  static One() {
    return new Vector4(1, 1, 1, 1);
  }
  static get ZeroReadOnly() {
    return Vector4._ZeroReadOnly;
  }
  static Normalize(vector) {
    const result = Vector4.Zero();
    Vector4.NormalizeToRef(vector, result);
    return result;
  }
  static NormalizeToRef(vector, result) {
    result.copyFrom(vector);
    result.normalize();
    return result;
  }
  static Minimize(left, right) {
    const min = new left.constructor();
    min.copyFrom(left);
    min.minimizeInPlace(right);
    return min;
  }
  static Maximize(left, right) {
    const max = new left.constructor();
    max.copyFrom(left);
    max.maximizeInPlace(right);
    return max;
  }
  static Distance(value1, value2) {
    return Math.sqrt(Vector4.DistanceSquared(value1, value2));
  }
  static DistanceSquared(value1, value2) {
    const x = value1.x - value2.x;
    const y = value1.y - value2.y;
    const z = value1.z - value2.z;
    const w = value1.w - value2.w;
    return x * x + y * y + z * z + w * w;
  }
  static Center(value1, value2) {
    return Vector4.CenterToRef(value1, value2, Vector4.Zero());
  }
  static CenterToRef(value1, value2, ref) {
    return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2, (value1.z + value2.z) / 2, (value1.w + value2.w) / 2);
  }
  static TransformCoordinates(vector, transformation) {
    const result = Vector4.Zero();
    Vector4.TransformCoordinatesToRef(vector, transformation, result);
    return result;
  }
  static TransformCoordinatesToRef(vector, transformation, result) {
    Vector4.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
    return result;
  }
  static TransformCoordinatesFromFloatsToRef(x, y, z, transformation, result) {
    const m = transformation.m;
    const rx = x * m[0] + y * m[4] + z * m[8] + m[12];
    const ry = x * m[1] + y * m[5] + z * m[9] + m[13];
    const rz = x * m[2] + y * m[6] + z * m[10] + m[14];
    const rw = x * m[3] + y * m[7] + z * m[11] + m[15];
    result.x = rx;
    result.y = ry;
    result.z = rz;
    result.w = rw;
    return result;
  }
  static TransformNormal(vector, transformation) {
    const result = new vector.constructor();
    Vector4.TransformNormalToRef(vector, transformation, result);
    return result;
  }
  static TransformNormalToRef(vector, transformation, result) {
    const m = transformation.m;
    const x = vector.x * m[0] + vector.y * m[4] + vector.z * m[8];
    const y = vector.x * m[1] + vector.y * m[5] + vector.z * m[9];
    const z = vector.x * m[2] + vector.y * m[6] + vector.z * m[10];
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = vector.w;
    return result;
  }
  static TransformNormalFromFloatsToRef(x, y, z, w, transformation, result) {
    const m = transformation.m;
    result.x = x * m[0] + y * m[4] + z * m[8];
    result.y = x * m[1] + y * m[5] + z * m[9];
    result.z = x * m[2] + y * m[6] + z * m[10];
    result.w = w;
    return result;
  }
  static FromVector3(source, w = 0) {
    return new Vector4(source._x, source._y, source._z, w);
  }
};
Vector4._ZeroReadOnly = Vector4.Zero();
var Quaternion = class {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this._isDirty = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._isDirty = true;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._isDirty = true;
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._isDirty = true;
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._isDirty = true;
  }
  toString() {
    return `{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`;
  }
  getClassName() {
    return "Quaternion";
  }
  getHashCode() {
    const x = _ExtractAsInt(this._x);
    const y = _ExtractAsInt(this._y);
    const z = _ExtractAsInt(this._z);
    const w = _ExtractAsInt(this._w);
    let hash = x;
    hash = hash * 397 ^ y;
    hash = hash * 397 ^ z;
    hash = hash * 397 ^ w;
    return hash;
  }
  asArray() {
    return [this._x, this._y, this._z, this._w];
  }
  toArray(array, index = 0) {
    array[index] = this.x;
    array[index + 1] = this.y;
    array[index + 2] = this.z;
    array[index + 3] = this.w;
    return this;
  }
  equals(otherQuaternion) {
    return otherQuaternion && this._x === otherQuaternion._x && this._y === otherQuaternion._y && this._z === otherQuaternion._z && this._w === otherQuaternion._w;
  }
  equalsWithEpsilon(otherQuaternion, epsilon = Epsilon) {
    return otherQuaternion && Scalar.WithinEpsilon(this._x, otherQuaternion._x, epsilon) && Scalar.WithinEpsilon(this._y, otherQuaternion._y, epsilon) && Scalar.WithinEpsilon(this._z, otherQuaternion._z, epsilon) && Scalar.WithinEpsilon(this._w, otherQuaternion._w, epsilon);
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copyFrom(other) {
    this.x = other._x;
    this.y = other._y;
    this.z = other._z;
    this.w = other._w;
    return this;
  }
  copyFromFloats(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  set(x, y, z, w) {
    return this.copyFromFloats(x, y, z, w);
  }
  add(other) {
    return new this.constructor(this._x + other._x, this._y + other._y, this._z + other._z, this._w + other._w);
  }
  addInPlace(other) {
    this._x += other._x;
    this._y += other._y;
    this._z += other._z;
    this._w += other._w;
    return this;
  }
  subtract(other) {
    return new this.constructor(this._x - other._x, this._y - other._y, this._z - other._z, this._w - other._w);
  }
  subtractInPlace(other) {
    this._x -= other._x;
    this._y -= other._y;
    this._z -= other._z;
    this._w -= other._w;
    return this;
  }
  scale(value) {
    return new this.constructor(this._x * value, this._y * value, this._z * value, this._w * value);
  }
  scaleToRef(scale, result) {
    result.x = this._x * scale;
    result.y = this._y * scale;
    result.z = this._z * scale;
    result.w = this._w * scale;
    return result;
  }
  scaleInPlace(value) {
    this.x *= value;
    this.y *= value;
    this.z *= value;
    this.w *= value;
    return this;
  }
  scaleAndAddToRef(scale, result) {
    result.x += this._x * scale;
    result.y += this._y * scale;
    result.z += this._z * scale;
    result.w += this._w * scale;
    return result;
  }
  multiply(q1) {
    const result = new this.constructor(0, 0, 0, 1);
    this.multiplyToRef(q1, result);
    return result;
  }
  multiplyToRef(q1, result) {
    const x = this._x * q1._w + this._y * q1._z - this._z * q1._y + this._w * q1._x;
    const y = -this._x * q1._z + this._y * q1._w + this._z * q1._x + this._w * q1._y;
    const z = this._x * q1._y - this._y * q1._x + this._z * q1._w + this._w * q1._z;
    const w = -this._x * q1._x - this._y * q1._y - this._z * q1._z + this._w * q1._w;
    result.copyFromFloats(x, y, z, w);
    return result;
  }
  multiplyInPlace(q1) {
    this.multiplyToRef(q1, this);
    return this;
  }
  conjugateToRef(ref) {
    ref.copyFromFloats(-this._x, -this._y, -this._z, this._w);
    return ref;
  }
  conjugateInPlace() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    return this;
  }
  conjugate() {
    return new this.constructor(-this._x, -this._y, -this._z, this._w);
  }
  invert() {
    const conjugate = this.conjugate();
    const lengthSquared = this.lengthSquared();
    if (lengthSquared == 0 || lengthSquared == 1) {
      return conjugate;
    }
    conjugate.scaleInPlace(1 / lengthSquared);
    return conjugate;
  }
  invertInPlace() {
    this.conjugateInPlace();
    const lengthSquared = this.lengthSquared();
    if (lengthSquared == 0 || lengthSquared == 1) {
      return this;
    }
    this.scaleInPlace(1 / lengthSquared);
    return this;
  }
  lengthSquared() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this.lengthSquared());
  }
  normalize() {
    const len = this.length();
    if (len === 0) {
      return this;
    }
    const inv = 1 / len;
    this.scaleInPlace(inv);
    return this;
  }
  normalizeToNew() {
    const len = this.length();
    if (len === 0) {
      return this.clone();
    }
    const inv = 1 / len;
    return this.scale(inv);
  }
  toEulerAngles() {
    const result = Vector3.Zero();
    this.toEulerAnglesToRef(result);
    return result;
  }
  toEulerAnglesToRef(result) {
    const qz = this._z;
    const qx = this._x;
    const qy = this._y;
    const qw = this._w;
    const zAxisY = qy * qz - qx * qw;
    const limit = 0.4999999;
    if (zAxisY < -limit) {
      result.y = 2 * Math.atan2(qy, qw);
      result.x = Math.PI / 2;
      result.z = 0;
    } else if (zAxisY > limit) {
      result.y = 2 * Math.atan2(qy, qw);
      result.x = -Math.PI / 2;
      result.z = 0;
    } else {
      const sqw = qw * qw;
      const sqz = qz * qz;
      const sqx = qx * qx;
      const sqy = qy * qy;
      result.z = Math.atan2(2 * (qx * qy + qz * qw), -sqz - sqx + sqy + sqw);
      result.x = Math.asin(-2 * zAxisY);
      result.y = Math.atan2(2 * (qz * qx + qy * qw), sqz - sqx - sqy + sqw);
    }
    return result;
  }
  toRotationMatrix(result) {
    Matrix.FromQuaternionToRef(this, result);
    return result;
  }
  fromRotationMatrix(matrix) {
    Quaternion.FromRotationMatrixToRef(matrix, this);
    return this;
  }
  static FromRotationMatrix(matrix) {
    const result = new Quaternion();
    Quaternion.FromRotationMatrixToRef(matrix, result);
    return result;
  }
  static FromRotationMatrixToRef(matrix, result) {
    const data = matrix.m;
    const m11 = data[0], m12 = data[4], m13 = data[8];
    const m21 = data[1], m22 = data[5], m23 = data[9];
    const m31 = data[2], m32 = data[6], m33 = data[10];
    const trace = m11 + m22 + m33;
    let s;
    if (trace > 0) {
      s = 0.5 / Math.sqrt(trace + 1);
      result.w = 0.25 / s;
      result.x = (m32 - m23) * s;
      result.y = (m13 - m31) * s;
      result.z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      result.w = (m32 - m23) / s;
      result.x = 0.25 * s;
      result.y = (m12 + m21) / s;
      result.z = (m13 + m31) / s;
    } else if (m22 > m33) {
      s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      result.w = (m13 - m31) / s;
      result.x = (m12 + m21) / s;
      result.y = 0.25 * s;
      result.z = (m23 + m32) / s;
    } else {
      s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      result.w = (m21 - m12) / s;
      result.x = (m13 + m31) / s;
      result.y = (m23 + m32) / s;
      result.z = 0.25 * s;
    }
    return result;
  }
  static Dot(left, right) {
    return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
  }
  static AreClose(quat0, quat1, epsilon = 0.1) {
    const dot = Quaternion.Dot(quat0, quat1);
    return 1 - dot * dot <= epsilon;
  }
  static SmoothToRef(source, goal, deltaTime, lerpTime, result) {
    let slerp = lerpTime === 0 ? 1 : deltaTime / lerpTime;
    slerp = Scalar.Clamp(slerp, 0, 1);
    Quaternion.SlerpToRef(source, goal, slerp, result);
    return result;
  }
  static Zero() {
    return new Quaternion(0, 0, 0, 0);
  }
  static Inverse(q) {
    return new q.constructor(-q._x, -q._y, -q._z, q._w);
  }
  static InverseToRef(q, result) {
    result.set(-q._x, -q._y, -q._z, q._w);
    return result;
  }
  static Identity() {
    return new Quaternion(0, 0, 0, 1);
  }
  static IsIdentity(quaternion) {
    return quaternion && quaternion._x === 0 && quaternion._y === 0 && quaternion._z === 0 && quaternion._w === 1;
  }
  static RotationAxis(axis, angle) {
    return Quaternion.RotationAxisToRef(axis, angle, new Quaternion());
  }
  static RotationAxisToRef(axis, angle, result) {
    const sin = Math.sin(angle / 2);
    axis.normalize();
    result.w = Math.cos(angle / 2);
    result.x = axis._x * sin;
    result.y = axis._y * sin;
    result.z = axis._z * sin;
    return result;
  }
  static FromArray(array, offset) {
    if (!offset) {
      offset = 0;
    }
    return new Quaternion(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
  }
  static FromArrayToRef(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
    result.z = array[offset + 2];
    result.w = array[offset + 3];
    return result;
  }
  static FromEulerAngles(x, y, z) {
    const q = new Quaternion();
    Quaternion.RotationYawPitchRollToRef(y, x, z, q);
    return q;
  }
  static FromEulerAnglesToRef(x, y, z, result) {
    Quaternion.RotationYawPitchRollToRef(y, x, z, result);
    return result;
  }
  static FromEulerVector(vec) {
    const q = new Quaternion();
    Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, q);
    return q;
  }
  static FromEulerVectorToRef(vec, result) {
    Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, result);
    return result;
  }
  static FromUnitVectorsToRef(vecFrom, vecTo, result) {
    const r = Vector3.Dot(vecFrom, vecTo) + 1;
    if (r < Epsilon) {
      if (Math.abs(vecFrom.x) > Math.abs(vecFrom.z)) {
        result.set(-vecFrom.y, vecFrom.x, 0, 0);
      } else {
        result.set(0, -vecFrom.z, vecFrom.y, 0);
      }
    } else {
      Vector3.CrossToRef(vecFrom, vecTo, TmpVectors.Vector3[0]);
      result.set(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z, r);
    }
    return result.normalize();
  }
  static RotationYawPitchRoll(yaw, pitch, roll) {
    const q = new Quaternion();
    Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, q);
    return q;
  }
  static RotationYawPitchRollToRef(yaw, pitch, roll, result) {
    const halfRoll = roll * 0.5;
    const halfPitch = pitch * 0.5;
    const halfYaw = yaw * 0.5;
    const sinRoll = Math.sin(halfRoll);
    const cosRoll = Math.cos(halfRoll);
    const sinPitch = Math.sin(halfPitch);
    const cosPitch = Math.cos(halfPitch);
    const sinYaw = Math.sin(halfYaw);
    const cosYaw = Math.cos(halfYaw);
    result.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
    result.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
    result.z = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
    result.w = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;
    return result;
  }
  static RotationAlphaBetaGamma(alpha, beta, gamma) {
    const result = new Quaternion();
    Quaternion.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);
    return result;
  }
  static RotationAlphaBetaGammaToRef(alpha, beta, gamma, result) {
    const halfGammaPlusAlpha = (gamma + alpha) * 0.5;
    const halfGammaMinusAlpha = (gamma - alpha) * 0.5;
    const halfBeta = beta * 0.5;
    result.x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);
    result.y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);
    result.z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);
    result.w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);
    return result;
  }
  static RotationQuaternionFromAxis(axis1, axis2, axis3) {
    const quat = new Quaternion(0, 0, 0, 0);
    Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);
    return quat;
  }
  static RotationQuaternionFromAxisToRef(axis1, axis2, axis3, ref) {
    const rotMat = MathTmp.Matrix[0];
    Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);
    Quaternion.FromRotationMatrixToRef(rotMat, ref);
    return ref;
  }
  static FromLookDirectionLH(forward, up) {
    const quat = new Quaternion();
    Quaternion.FromLookDirectionLHToRef(forward, up, quat);
    return quat;
  }
  static FromLookDirectionLHToRef(forward, up, ref) {
    const rotMat = MathTmp.Matrix[0];
    Matrix.LookDirectionLHToRef(forward, up, rotMat);
    Quaternion.FromRotationMatrixToRef(rotMat, ref);
    return ref;
  }
  static FromLookDirectionRH(forward, up) {
    const quat = new Quaternion();
    Quaternion.FromLookDirectionRHToRef(forward, up, quat);
    return quat;
  }
  static FromLookDirectionRHToRef(forward, up, ref) {
    const rotMat = MathTmp.Matrix[0];
    Matrix.LookDirectionRHToRef(forward, up, rotMat);
    return Quaternion.FromRotationMatrixToRef(rotMat, ref);
  }
  static Slerp(left, right, amount) {
    const result = Quaternion.Identity();
    Quaternion.SlerpToRef(left, right, amount, result);
    return result;
  }
  static SlerpToRef(left, right, amount, result) {
    let num2;
    let num3;
    let num4 = left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
    let flag = false;
    if (num4 < 0) {
      flag = true;
      num4 = -num4;
    }
    if (num4 > 0.999999) {
      num3 = 1 - amount;
      num2 = flag ? -amount : amount;
    } else {
      const num5 = Math.acos(num4);
      const num6 = 1 / Math.sin(num5);
      num3 = Math.sin((1 - amount) * num5) * num6;
      num2 = flag ? -Math.sin(amount * num5) * num6 : Math.sin(amount * num5) * num6;
    }
    result.x = num3 * left._x + num2 * right._x;
    result.y = num3 * left._y + num2 * right._y;
    result.z = num3 * left._z + num2 * right._z;
    result.w = num3 * left._w + num2 * right._w;
    return result;
  }
  static Hermite(value1, tangent1, value2, tangent2, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const part1 = 2 * cubed - 3 * squared + 1;
    const part2 = -2 * cubed + 3 * squared;
    const part3 = cubed - 2 * squared + amount;
    const part4 = cubed - squared;
    const x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;
    const y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;
    const z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;
    const w = value1._w * part1 + value2._w * part2 + tangent1._w * part3 + tangent2._w * part4;
    return new value1.constructor(x, y, z, w);
  }
  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
    const result = new value1.constructor();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  }
  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
    const t2 = time * time;
    result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
    result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
    result.z = (t2 - time) * 6 * value1.z + (3 * t2 - 4 * time + 1) * tangent1.z + (-t2 + time) * 6 * value2.z + (3 * t2 - 2 * time) * tangent2.z;
    result.w = (t2 - time) * 6 * value1.w + (3 * t2 - 4 * time + 1) * tangent1.w + (-t2 + time) * 6 * value2.w + (3 * t2 - 2 * time) * tangent2.w;
    return result;
  }
};
var Matrix = class {
  constructor() {
    this._isIdentity = false;
    this._isIdentityDirty = true;
    this._isIdentity3x2 = true;
    this._isIdentity3x2Dirty = true;
    this.updateFlag = -1;
    if (PerformanceConfigurator.MatrixTrackPrecisionChange) {
      PerformanceConfigurator.MatrixTrackedMatrices.push(this);
    }
    this._m = new PerformanceConfigurator.MatrixCurrentType(16);
    this.markAsUpdated();
  }
  static get Use64Bits() {
    return PerformanceConfigurator.MatrixUse64Bits;
  }
  get m() {
    return this._m;
  }
  markAsUpdated() {
    this.updateFlag = Matrix._UpdateFlagSeed++;
    this._isIdentity = false;
    this._isIdentity3x2 = false;
    this._isIdentityDirty = true;
    this._isIdentity3x2Dirty = true;
  }
  _updateIdentityStatus(isIdentity, isIdentityDirty = false, isIdentity3x2 = false, isIdentity3x2Dirty = true) {
    this._isIdentity = isIdentity;
    this._isIdentity3x2 = isIdentity || isIdentity3x2;
    this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;
    this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;
  }
  isIdentity() {
    if (this._isIdentityDirty) {
      this._isIdentityDirty = false;
      const m = this._m;
      this._isIdentity = m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
    }
    return this._isIdentity;
  }
  isIdentityAs3x2() {
    if (this._isIdentity3x2Dirty) {
      this._isIdentity3x2Dirty = false;
      if (this._m[0] !== 1 || this._m[5] !== 1 || this._m[15] !== 1) {
        this._isIdentity3x2 = false;
      } else if (this._m[1] !== 0 || this._m[2] !== 0 || this._m[3] !== 0 || this._m[4] !== 0 || this._m[6] !== 0 || this._m[7] !== 0 || this._m[8] !== 0 || this._m[9] !== 0 || this._m[10] !== 0 || this._m[11] !== 0 || this._m[12] !== 0 || this._m[13] !== 0 || this._m[14] !== 0) {
        this._isIdentity3x2 = false;
      } else {
        this._isIdentity3x2 = true;
      }
    }
    return this._isIdentity3x2;
  }
  determinant() {
    if (this._isIdentity === true) {
      return 1;
    }
    const m = this._m;
    const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
    const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
    const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
    const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
    const det_22_33 = m22 * m33 - m32 * m23;
    const det_21_33 = m21 * m33 - m31 * m23;
    const det_21_32 = m21 * m32 - m31 * m22;
    const det_20_33 = m20 * m33 - m30 * m23;
    const det_20_32 = m20 * m32 - m22 * m30;
    const det_20_31 = m20 * m31 - m30 * m21;
    const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
    const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
    const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
    const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
    return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
  }
  toArray() {
    return this._m;
  }
  asArray() {
    return this._m;
  }
  invert() {
    this.invertToRef(this);
    return this;
  }
  reset() {
    Matrix.FromValuesToRef(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, this);
    this._updateIdentityStatus(false);
    return this;
  }
  add(other) {
    const result = new this.constructor();
    this.addToRef(other, result);
    return result;
  }
  addToRef(other, result) {
    const m = this._m;
    const resultM = result._m;
    const otherM = other.m;
    for (let index = 0; index < 16; index++) {
      resultM[index] = m[index] + otherM[index];
    }
    result.markAsUpdated();
    return result;
  }
  addToSelf(other) {
    const m = this._m;
    const otherM = other.m;
    for (let index = 0; index < 16; index++) {
      m[index] += otherM[index];
    }
    this.markAsUpdated();
    return this;
  }
  invertToRef(other) {
    if (this._isIdentity === true) {
      Matrix.IdentityToRef(other);
      return other;
    }
    const m = this._m;
    const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
    const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
    const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
    const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
    const det_22_33 = m22 * m33 - m32 * m23;
    const det_21_33 = m21 * m33 - m31 * m23;
    const det_21_32 = m21 * m32 - m31 * m22;
    const det_20_33 = m20 * m33 - m30 * m23;
    const det_20_32 = m20 * m32 - m22 * m30;
    const det_20_31 = m20 * m31 - m30 * m21;
    const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
    const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
    const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
    const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
    const det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
    if (det === 0) {
      other.copyFrom(this);
      return other;
    }
    const detInv = 1 / det;
    const det_12_33 = m12 * m33 - m32 * m13;
    const det_11_33 = m11 * m33 - m31 * m13;
    const det_11_32 = m11 * m32 - m31 * m12;
    const det_10_33 = m10 * m33 - m30 * m13;
    const det_10_32 = m10 * m32 - m30 * m12;
    const det_10_31 = m10 * m31 - m30 * m11;
    const det_12_23 = m12 * m23 - m22 * m13;
    const det_11_23 = m11 * m23 - m21 * m13;
    const det_11_22 = m11 * m22 - m21 * m12;
    const det_10_23 = m10 * m23 - m20 * m13;
    const det_10_22 = m10 * m22 - m20 * m12;
    const det_10_21 = m10 * m21 - m20 * m11;
    const cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);
    const cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);
    const cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);
    const cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);
    const cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);
    const cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);
    const cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);
    const cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);
    const cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);
    const cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);
    const cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);
    const cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);
    Matrix.FromValuesToRef(cofact_00 * detInv, cofact_10 * detInv, cofact_20 * detInv, cofact_30 * detInv, cofact_01 * detInv, cofact_11 * detInv, cofact_21 * detInv, cofact_31 * detInv, cofact_02 * detInv, cofact_12 * detInv, cofact_22 * detInv, cofact_32 * detInv, cofact_03 * detInv, cofact_13 * detInv, cofact_23 * detInv, cofact_33 * detInv, other);
    return other;
  }
  addAtIndex(index, value) {
    this._m[index] += value;
    this.markAsUpdated();
    return this;
  }
  multiplyAtIndex(index, value) {
    this._m[index] *= value;
    this.markAsUpdated();
    return this;
  }
  setTranslationFromFloats(x, y, z) {
    this._m[12] = x;
    this._m[13] = y;
    this._m[14] = z;
    this.markAsUpdated();
    return this;
  }
  addTranslationFromFloats(x, y, z) {
    this._m[12] += x;
    this._m[13] += y;
    this._m[14] += z;
    this.markAsUpdated();
    return this;
  }
  setTranslation(vector3) {
    return this.setTranslationFromFloats(vector3._x, vector3._y, vector3._z);
  }
  getTranslation() {
    return new Vector3(this._m[12], this._m[13], this._m[14]);
  }
  getTranslationToRef(result) {
    result.x = this._m[12];
    result.y = this._m[13];
    result.z = this._m[14];
    return result;
  }
  removeRotationAndScaling() {
    const m = this.m;
    Matrix.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, m[12], m[13], m[14], m[15], this);
    this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);
    return this;
  }
  multiply(other) {
    const result = new this.constructor();
    this.multiplyToRef(other, result);
    return result;
  }
  copyFrom(other) {
    other.copyToArray(this._m);
    const o = other;
    this.updateFlag = o.updateFlag;
    this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);
    return this;
  }
  copyToArray(array, offset = 0) {
    const source = this._m;
    array[offset] = source[0];
    array[offset + 1] = source[1];
    array[offset + 2] = source[2];
    array[offset + 3] = source[3];
    array[offset + 4] = source[4];
    array[offset + 5] = source[5];
    array[offset + 6] = source[6];
    array[offset + 7] = source[7];
    array[offset + 8] = source[8];
    array[offset + 9] = source[9];
    array[offset + 10] = source[10];
    array[offset + 11] = source[11];
    array[offset + 12] = source[12];
    array[offset + 13] = source[13];
    array[offset + 14] = source[14];
    array[offset + 15] = source[15];
    return this;
  }
  multiplyToRef(other, result) {
    if (this._isIdentity) {
      result.copyFrom(other);
      return result;
    }
    if (other._isIdentity) {
      result.copyFrom(this);
      return result;
    }
    this.multiplyToArray(other, result._m, 0);
    result.markAsUpdated();
    return result;
  }
  multiplyToArray(other, result, offset) {
    const m = this._m;
    const otherM = other.m;
    const tm0 = m[0], tm1 = m[1], tm2 = m[2], tm3 = m[3];
    const tm4 = m[4], tm5 = m[5], tm6 = m[6], tm7 = m[7];
    const tm8 = m[8], tm9 = m[9], tm10 = m[10], tm11 = m[11];
    const tm12 = m[12], tm13 = m[13], tm14 = m[14], tm15 = m[15];
    const om0 = otherM[0], om1 = otherM[1], om2 = otherM[2], om3 = otherM[3];
    const om4 = otherM[4], om5 = otherM[5], om6 = otherM[6], om7 = otherM[7];
    const om8 = otherM[8], om9 = otherM[9], om10 = otherM[10], om11 = otherM[11];
    const om12 = otherM[12], om13 = otherM[13], om14 = otherM[14], om15 = otherM[15];
    result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;
    result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;
    result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;
    result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;
    result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;
    result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;
    result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;
    result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;
    result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;
    result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;
    result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;
    result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;
    result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;
    result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;
    result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;
    result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;
    return this;
  }
  equals(value) {
    const other = value;
    if (!other) {
      return false;
    }
    if (this._isIdentity || other._isIdentity) {
      if (!this._isIdentityDirty && !other._isIdentityDirty) {
        return this._isIdentity && other._isIdentity;
      }
    }
    const m = this.m;
    const om = other.m;
    return m[0] === om[0] && m[1] === om[1] && m[2] === om[2] && m[3] === om[3] && m[4] === om[4] && m[5] === om[5] && m[6] === om[6] && m[7] === om[7] && m[8] === om[8] && m[9] === om[9] && m[10] === om[10] && m[11] === om[11] && m[12] === om[12] && m[13] === om[13] && m[14] === om[14] && m[15] === om[15];
  }
  clone() {
    const matrix = new this.constructor();
    matrix.copyFrom(this);
    return matrix;
  }
  getClassName() {
    return "Matrix";
  }
  getHashCode() {
    let hash = _ExtractAsInt(this._m[0]);
    for (let i = 1; i < 16; i++) {
      hash = hash * 397 ^ _ExtractAsInt(this._m[i]);
    }
    return hash;
  }
  decomposeToTransformNode(node) {
    node.rotationQuaternion = node.rotationQuaternion || new Quaternion();
    return this.decompose(node.scaling, node.rotationQuaternion, node.position);
  }
  decompose(scale, rotation, translation, preserveScalingNode) {
    if (this._isIdentity) {
      if (translation) {
        translation.setAll(0);
      }
      if (scale) {
        scale.setAll(1);
      }
      if (rotation) {
        rotation.copyFromFloats(0, 0, 0, 1);
      }
      return true;
    }
    const m = this._m;
    if (translation) {
      translation.copyFromFloats(m[12], m[13], m[14]);
    }
    scale = scale || MathTmp.Vector3[0];
    scale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);
    scale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);
    scale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);
    if (preserveScalingNode) {
      const signX = preserveScalingNode.scaling.x < 0 ? -1 : 1;
      const signY = preserveScalingNode.scaling.y < 0 ? -1 : 1;
      const signZ = preserveScalingNode.scaling.z < 0 ? -1 : 1;
      scale.x *= signX;
      scale.y *= signY;
      scale.z *= signZ;
    } else {
      if (this.determinant() <= 0) {
        scale.y *= -1;
      }
    }
    if (scale._x === 0 || scale._y === 0 || scale._z === 0) {
      if (rotation) {
        rotation.copyFromFloats(0, 0, 0, 1);
      }
      return false;
    }
    if (rotation) {
      const sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;
      Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0, m[4] * sy, m[5] * sy, m[6] * sy, 0, m[8] * sz, m[9] * sz, m[10] * sz, 0, 0, 0, 0, 1, MathTmp.Matrix[0]);
      Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0], rotation);
    }
    return true;
  }
  getRow(index) {
    if (index < 0 || index > 3) {
      return null;
    }
    const i = index * 4;
    return new Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);
  }
  getRowToRef(index, rowVector) {
    if (index >= 0 && index < 3) {
      const i = index * 4;
      rowVector.x = this._m[i + 0];
      rowVector.y = this._m[i + 1];
      rowVector.z = this._m[i + 2];
      rowVector.w = this._m[i + 3];
    }
    return rowVector;
  }
  setRow(index, row) {
    return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);
  }
  transpose() {
    const result = new this.constructor();
    Matrix.TransposeToRef(this, result);
    return result;
  }
  transposeToRef(result) {
    Matrix.TransposeToRef(this, result);
    return result;
  }
  setRowFromFloats(index, x, y, z, w) {
    if (index < 0 || index > 3) {
      return this;
    }
    const i = index * 4;
    this._m[i + 0] = x;
    this._m[i + 1] = y;
    this._m[i + 2] = z;
    this._m[i + 3] = w;
    this.markAsUpdated();
    return this;
  }
  scale(scale) {
    const result = new this.constructor();
    this.scaleToRef(scale, result);
    return result;
  }
  scaleToRef(scale, result) {
    for (let index = 0; index < 16; index++) {
      result._m[index] = this._m[index] * scale;
    }
    result.markAsUpdated();
    return result;
  }
  scaleAndAddToRef(scale, result) {
    for (let index = 0; index < 16; index++) {
      result._m[index] += this._m[index] * scale;
    }
    result.markAsUpdated();
    return result;
  }
  toNormalMatrix(ref) {
    const tmp = MathTmp.Matrix[0];
    this.invertToRef(tmp);
    tmp.transposeToRef(ref);
    const m = ref._m;
    Matrix.FromValuesToRef(m[0], m[1], m[2], 0, m[4], m[5], m[6], 0, m[8], m[9], m[10], 0, 0, 0, 0, 1, ref);
    return ref;
  }
  getRotationMatrix() {
    const result = new this.constructor();
    this.getRotationMatrixToRef(result);
    return result;
  }
  getRotationMatrixToRef(result) {
    const scale = MathTmp.Vector3[0];
    if (!this.decompose(scale)) {
      Matrix.IdentityToRef(result);
      return result;
    }
    const m = this._m;
    const sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;
    Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0, m[4] * sy, m[5] * sy, m[6] * sy, 0, m[8] * sz, m[9] * sz, m[10] * sz, 0, 0, 0, 0, 1, result);
    return result;
  }
  toggleModelMatrixHandInPlace() {
    const m = this._m;
    m[2] *= -1;
    m[6] *= -1;
    m[8] *= -1;
    m[9] *= -1;
    m[14] *= -1;
    this.markAsUpdated();
    return this;
  }
  toggleProjectionMatrixHandInPlace() {
    const m = this._m;
    m[8] *= -1;
    m[9] *= -1;
    m[10] *= -1;
    m[11] *= -1;
    this.markAsUpdated();
    return this;
  }
  static FromArray(array, offset = 0) {
    const result = new Matrix();
    Matrix.FromArrayToRef(array, offset, result);
    return result;
  }
  static FromArrayToRef(array, offset, result) {
    for (let index = 0; index < 16; index++) {
      result._m[index] = array[index + offset];
    }
    result.markAsUpdated();
    return result;
  }
  static FromFloat32ArrayToRefScaled(array, offset, scale, result) {
    for (let index = 0; index < 16; index++) {
      result._m[index] = array[index + offset] * scale;
    }
    result.markAsUpdated();
    return result;
  }
  static get IdentityReadOnly() {
    return Matrix._IdentityReadOnly;
  }
  static FromValuesToRef(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {
    const m = result._m;
    m[0] = initialM11;
    m[1] = initialM12;
    m[2] = initialM13;
    m[3] = initialM14;
    m[4] = initialM21;
    m[5] = initialM22;
    m[6] = initialM23;
    m[7] = initialM24;
    m[8] = initialM31;
    m[9] = initialM32;
    m[10] = initialM33;
    m[11] = initialM34;
    m[12] = initialM41;
    m[13] = initialM42;
    m[14] = initialM43;
    m[15] = initialM44;
    result.markAsUpdated();
  }
  static FromValues(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {
    const result = new Matrix();
    const m = result._m;
    m[0] = initialM11;
    m[1] = initialM12;
    m[2] = initialM13;
    m[3] = initialM14;
    m[4] = initialM21;
    m[5] = initialM22;
    m[6] = initialM23;
    m[7] = initialM24;
    m[8] = initialM31;
    m[9] = initialM32;
    m[10] = initialM33;
    m[11] = initialM34;
    m[12] = initialM41;
    m[13] = initialM42;
    m[14] = initialM43;
    m[15] = initialM44;
    result.markAsUpdated();
    return result;
  }
  static Compose(scale, rotation, translation) {
    const result = new Matrix();
    Matrix.ComposeToRef(scale, rotation, translation, result);
    return result;
  }
  static ComposeToRef(scale, rotation, translation, result) {
    const m = result._m;
    const x = rotation._x, y = rotation._y, z = rotation._z, w = rotation._w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    const sx = scale._x, sy = scale._y, sz = scale._z;
    m[0] = (1 - (yy + zz)) * sx;
    m[1] = (xy + wz) * sx;
    m[2] = (xz - wy) * sx;
    m[3] = 0;
    m[4] = (xy - wz) * sy;
    m[5] = (1 - (xx + zz)) * sy;
    m[6] = (yz + wx) * sy;
    m[7] = 0;
    m[8] = (xz + wy) * sz;
    m[9] = (yz - wx) * sz;
    m[10] = (1 - (xx + yy)) * sz;
    m[11] = 0;
    m[12] = translation._x;
    m[13] = translation._y;
    m[14] = translation._z;
    m[15] = 1;
    result.markAsUpdated();
    return result;
  }
  static Identity() {
    const identity = Matrix.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    identity._updateIdentityStatus(true);
    return identity;
  }
  static IdentityToRef(result) {
    Matrix.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(true);
    return result;
  }
  static Zero() {
    const zero = Matrix.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    zero._updateIdentityStatus(false);
    return zero;
  }
  static RotationX(angle) {
    const result = new Matrix();
    Matrix.RotationXToRef(angle, result);
    return result;
  }
  static Invert(source) {
    const result = new source.constructor();
    source.invertToRef(result);
    return result;
  }
  static RotationXToRef(angle, result) {
    const s = Math.sin(angle);
    const c = Math.cos(angle);
    Matrix.FromValuesToRef(1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(c === 1 && s === 0);
    return result;
  }
  static RotationY(angle) {
    const result = new Matrix();
    Matrix.RotationYToRef(angle, result);
    return result;
  }
  static RotationYToRef(angle, result) {
    const s = Math.sin(angle);
    const c = Math.cos(angle);
    Matrix.FromValuesToRef(c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(c === 1 && s === 0);
    return result;
  }
  static RotationZ(angle) {
    const result = new Matrix();
    Matrix.RotationZToRef(angle, result);
    return result;
  }
  static RotationZToRef(angle, result) {
    const s = Math.sin(angle);
    const c = Math.cos(angle);
    Matrix.FromValuesToRef(c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(c === 1 && s === 0);
    return result;
  }
  static RotationAxis(axis, angle) {
    const result = new Matrix();
    Matrix.RotationAxisToRef(axis, angle, result);
    return result;
  }
  static RotationAxisToRef(axis, angle, result) {
    const s = Math.sin(-angle);
    const c = Math.cos(-angle);
    const c1 = 1 - c;
    axis.normalize();
    const m = result._m;
    m[0] = axis._x * axis._x * c1 + c;
    m[1] = axis._x * axis._y * c1 - axis._z * s;
    m[2] = axis._x * axis._z * c1 + axis._y * s;
    m[3] = 0;
    m[4] = axis._y * axis._x * c1 + axis._z * s;
    m[5] = axis._y * axis._y * c1 + c;
    m[6] = axis._y * axis._z * c1 - axis._x * s;
    m[7] = 0;
    m[8] = axis._z * axis._x * c1 - axis._y * s;
    m[9] = axis._z * axis._y * c1 + axis._x * s;
    m[10] = axis._z * axis._z * c1 + c;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    result.markAsUpdated();
    return result;
  }
  static RotationAlignToRef(from, to, result) {
    const c = Vector3.Dot(to, from);
    const m = result._m;
    if (c < -1 + Epsilon) {
      m[0] = -1;
      m[1] = 0;
      m[2] = 0;
      m[3] = 0;
      m[4] = 0;
      m[5] = -1;
      m[6] = 0;
      m[7] = 0;
      m[8] = 0;
      m[9] = 0;
      m[10] = 1;
      m[11] = 0;
    } else {
      const v = Vector3.Cross(to, from);
      const k = 1 / (1 + c);
      m[0] = v._x * v._x * k + c;
      m[1] = v._y * v._x * k - v._z;
      m[2] = v._z * v._x * k + v._y;
      m[3] = 0;
      m[4] = v._x * v._y * k + v._z;
      m[5] = v._y * v._y * k + c;
      m[6] = v._z * v._y * k - v._x;
      m[7] = 0;
      m[8] = v._x * v._z * k - v._y;
      m[9] = v._y * v._z * k + v._x;
      m[10] = v._z * v._z * k + c;
      m[11] = 0;
    }
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    result.markAsUpdated();
    return result;
  }
  static RotationYawPitchRoll(yaw, pitch, roll) {
    const result = new Matrix();
    Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, result);
    return result;
  }
  static RotationYawPitchRollToRef(yaw, pitch, roll, result) {
    Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, MathTmp.Quaternion[0]);
    MathTmp.Quaternion[0].toRotationMatrix(result);
    return result;
  }
  static Scaling(x, y, z) {
    const result = new Matrix();
    Matrix.ScalingToRef(x, y, z, result);
    return result;
  }
  static ScalingToRef(x, y, z, result) {
    Matrix.FromValuesToRef(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(x === 1 && y === 1 && z === 1);
    return result;
  }
  static Translation(x, y, z) {
    const result = new Matrix();
    Matrix.TranslationToRef(x, y, z, result);
    return result;
  }
  static TranslationToRef(x, y, z, result) {
    Matrix.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1, result);
    result._updateIdentityStatus(x === 0 && y === 0 && z === 0);
    return result;
  }
  static Lerp(startValue, endValue, gradient) {
    const result = new startValue.constructor();
    Matrix.LerpToRef(startValue, endValue, gradient, result);
    return result;
  }
  static LerpToRef(startValue, endValue, gradient, result) {
    const resultM = result._m;
    const startM = startValue.m;
    const endM = endValue.m;
    for (let index = 0; index < 16; index++) {
      resultM[index] = startM[index] * (1 - gradient) + endM[index] * gradient;
    }
    result.markAsUpdated();
    return result;
  }
  static DecomposeLerp(startValue, endValue, gradient) {
    const result = new startValue.constructor();
    Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);
    return result;
  }
  static DecomposeLerpToRef(startValue, endValue, gradient, result) {
    const startScale = MathTmp.Vector3[0];
    const startRotation = MathTmp.Quaternion[0];
    const startTranslation = MathTmp.Vector3[1];
    startValue.decompose(startScale, startRotation, startTranslation);
    const endScale = MathTmp.Vector3[2];
    const endRotation = MathTmp.Quaternion[1];
    const endTranslation = MathTmp.Vector3[3];
    endValue.decompose(endScale, endRotation, endTranslation);
    const resultScale = MathTmp.Vector3[4];
    Vector3.LerpToRef(startScale, endScale, gradient, resultScale);
    const resultRotation = MathTmp.Quaternion[2];
    Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);
    const resultTranslation = MathTmp.Vector3[5];
    Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);
    Matrix.ComposeToRef(resultScale, resultRotation, resultTranslation, result);
    return result;
  }
  static LookAtLH(eye, target, up) {
    const result = new Matrix();
    Matrix.LookAtLHToRef(eye, target, up, result);
    return result;
  }
  static LookAtLHToRef(eye, target, up, result) {
    const xAxis = MathTmp.Vector3[0];
    const yAxis = MathTmp.Vector3[1];
    const zAxis = MathTmp.Vector3[2];
    target.subtractToRef(eye, zAxis);
    zAxis.normalize();
    Vector3.CrossToRef(up, zAxis, xAxis);
    const xSquareLength = xAxis.lengthSquared();
    if (xSquareLength === 0) {
      xAxis.x = 1;
    } else {
      xAxis.normalizeFromLength(Math.sqrt(xSquareLength));
    }
    Vector3.CrossToRef(zAxis, xAxis, yAxis);
    yAxis.normalize();
    const ex = -Vector3.Dot(xAxis, eye);
    const ey = -Vector3.Dot(yAxis, eye);
    const ez = -Vector3.Dot(zAxis, eye);
    Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0, xAxis._y, yAxis._y, zAxis._y, 0, xAxis._z, yAxis._z, zAxis._z, 0, ex, ey, ez, 1, result);
  }
  static LookAtRH(eye, target, up) {
    const result = new Matrix();
    Matrix.LookAtRHToRef(eye, target, up, result);
    return result;
  }
  static LookAtRHToRef(eye, target, up, result) {
    const xAxis = MathTmp.Vector3[0];
    const yAxis = MathTmp.Vector3[1];
    const zAxis = MathTmp.Vector3[2];
    eye.subtractToRef(target, zAxis);
    zAxis.normalize();
    Vector3.CrossToRef(up, zAxis, xAxis);
    const xSquareLength = xAxis.lengthSquared();
    if (xSquareLength === 0) {
      xAxis.x = 1;
    } else {
      xAxis.normalizeFromLength(Math.sqrt(xSquareLength));
    }
    Vector3.CrossToRef(zAxis, xAxis, yAxis);
    yAxis.normalize();
    const ex = -Vector3.Dot(xAxis, eye);
    const ey = -Vector3.Dot(yAxis, eye);
    const ez = -Vector3.Dot(zAxis, eye);
    Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0, xAxis._y, yAxis._y, zAxis._y, 0, xAxis._z, yAxis._z, zAxis._z, 0, ex, ey, ez, 1, result);
    return result;
  }
  static LookDirectionLH(forward, up) {
    const result = new Matrix();
    Matrix.LookDirectionLHToRef(forward, up, result);
    return result;
  }
  static LookDirectionLHToRef(forward, up, result) {
    const back = MathTmp.Vector3[0];
    back.copyFrom(forward);
    back.scaleInPlace(-1);
    const left = MathTmp.Vector3[1];
    Vector3.CrossToRef(up, back, left);
    Matrix.FromValuesToRef(left._x, left._y, left._z, 0, up._x, up._y, up._z, 0, back._x, back._y, back._z, 0, 0, 0, 0, 1, result);
    return result;
  }
  static LookDirectionRH(forward, up) {
    const result = new Matrix();
    Matrix.LookDirectionRHToRef(forward, up, result);
    return result;
  }
  static LookDirectionRHToRef(forward, up, result) {
    const right = MathTmp.Vector3[2];
    Vector3.CrossToRef(up, forward, right);
    Matrix.FromValuesToRef(right._x, right._y, right._z, 0, up._x, up._y, up._z, 0, forward._x, forward._y, forward._z, 0, 0, 0, 0, 1, result);
    return result;
  }
  static OrthoLH(width, height, znear, zfar, halfZRange) {
    const matrix = new Matrix();
    Matrix.OrthoLHToRef(width, height, znear, zfar, matrix, halfZRange);
    return matrix;
  }
  static OrthoLHToRef(width, height, znear, zfar, result, halfZRange) {
    const n = znear;
    const f = zfar;
    const a = 2 / width;
    const b = 2 / height;
    const c = 2 / (f - n);
    const d = -(f + n) / (f - n);
    Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, d, 1, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);
    return result;
  }
  static OrthoOffCenterLH(left, right, bottom, top, znear, zfar, halfZRange) {
    const matrix = new Matrix();
    Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);
    return matrix;
  }
  static OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result, halfZRange) {
    const n = znear;
    const f = zfar;
    const a = 2 / (right - left);
    const b = 2 / (top - bottom);
    const c = 2 / (f - n);
    const d = -(f + n) / (f - n);
    const i0 = (left + right) / (left - right);
    const i1 = (top + bottom) / (bottom - top);
    Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, i0, i1, d, 1, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result.markAsUpdated();
    return result;
  }
  static OrthoOffCenterRH(left, right, bottom, top, znear, zfar, halfZRange) {
    const matrix = new Matrix();
    Matrix.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);
    return matrix;
  }
  static OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, result, halfZRange) {
    Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result, halfZRange);
    result._m[10] *= -1;
    return result;
  }
  static PerspectiveLH(width, height, znear, zfar, halfZRange, projectionPlaneTilt = 0) {
    const matrix = new Matrix();
    const n = znear;
    const f = zfar;
    const a = 2 * n / width;
    const b = 2 * n / height;
    const c = (f + n) / (f - n);
    const d = -2 * f * n / (f - n);
    const rot = Math.tan(projectionPlaneTilt);
    Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, 1, 0, 0, d, 0, matrix);
    if (halfZRange) {
      matrix.multiplyToRef(mtxConvertNDCToHalfZRange, matrix);
    }
    matrix._updateIdentityStatus(false);
    return matrix;
  }
  static PerspectiveFovLH(fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {
    const matrix = new Matrix();
    Matrix.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);
    return matrix;
  }
  static PerspectiveFovLHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {
    const n = znear;
    const f = zfar;
    const t = 1 / Math.tan(fov * 0.5);
    const a = isVerticalFovFixed ? t / aspect : t;
    const b = isVerticalFovFixed ? t : t * aspect;
    const c = reverseDepthBufferMode && n === 0 ? -1 : f !== 0 ? (f + n) / (f - n) : 1;
    const d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? -2 * f * n / (f - n) : -2 * n;
    const rot = Math.tan(projectionPlaneTilt);
    Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, 1, 0, 0, d, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
    return result;
  }
  static PerspectiveFovReverseLHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0) {
    const t = 1 / Math.tan(fov * 0.5);
    const a = isVerticalFovFixed ? t / aspect : t;
    const b = isVerticalFovFixed ? t : t * aspect;
    const rot = Math.tan(projectionPlaneTilt);
    Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, -znear, 1, 0, 0, 1, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
    return result;
  }
  static PerspectiveFovRH(fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {
    const matrix = new Matrix();
    Matrix.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);
    return matrix;
  }
  static PerspectiveFovRHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {
    const n = znear;
    const f = zfar;
    const t = 1 / Math.tan(fov * 0.5);
    const a = isVerticalFovFixed ? t / aspect : t;
    const b = isVerticalFovFixed ? t : t * aspect;
    const c = reverseDepthBufferMode && n === 0 ? 1 : f !== 0 ? -(f + n) / (f - n) : -1;
    const d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? -2 * f * n / (f - n) : -2 * n;
    const rot = Math.tan(projectionPlaneTilt);
    Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, -1, 0, 0, d, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
    return result;
  }
  static PerspectiveFovReverseRHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0) {
    const t = 1 / Math.tan(fov * 0.5);
    const a = isVerticalFovFixed ? t / aspect : t;
    const b = isVerticalFovFixed ? t : t * aspect;
    const rot = Math.tan(projectionPlaneTilt);
    Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, -znear, -1, 0, 0, -1, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
    return result;
  }
  static PerspectiveFovWebVRToRef(fov, znear, zfar, result, rightHanded = false, halfZRange, projectionPlaneTilt = 0) {
    const rightHandedFactor = rightHanded ? -1 : 1;
    const upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    const downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    const leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    const rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    const xScale = 2 / (leftTan + rightTan);
    const yScale = 2 / (upTan + downTan);
    const rot = Math.tan(projectionPlaneTilt);
    const m = result._m;
    m[0] = xScale;
    m[1] = m[2] = m[3] = m[4] = 0;
    m[5] = yScale;
    m[6] = 0;
    m[7] = rot;
    m[8] = (leftTan - rightTan) * xScale * 0.5;
    m[9] = -((upTan - downTan) * yScale * 0.5);
    m[10] = -zfar / (znear - zfar);
    m[11] = 1 * rightHandedFactor;
    m[12] = m[13] = m[15] = 0;
    m[14] = -(2 * zfar * znear) / (zfar - znear);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result.markAsUpdated();
    return result;
  }
  static GetFinalMatrix(viewport, world, view, projection, zmin, zmax) {
    const cw = viewport.width;
    const ch = viewport.height;
    const cx = viewport.x;
    const cy = viewport.y;
    const viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, -ch / 2, 0, 0, 0, 0, zmax - zmin, 0, cx + cw / 2, ch / 2 + cy, zmin, 1);
    const matrix = new world.constructor();
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    return matrix.multiplyToRef(viewportMatrix, matrix);
  }
  static GetAsMatrix2x2(matrix) {
    const m = matrix.m;
    const arr = [m[0], m[1], m[4], m[5]];
    return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);
  }
  static GetAsMatrix3x3(matrix) {
    const m = matrix.m;
    const arr = [m[0], m[1], m[2], m[4], m[5], m[6], m[8], m[9], m[10]];
    return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);
  }
  static Transpose(matrix) {
    const result = new matrix.constructor();
    Matrix.TransposeToRef(matrix, result);
    return result;
  }
  static TransposeToRef(matrix, result) {
    const rm = result._m;
    const mm = matrix.m;
    rm[0] = mm[0];
    rm[1] = mm[4];
    rm[2] = mm[8];
    rm[3] = mm[12];
    rm[4] = mm[1];
    rm[5] = mm[5];
    rm[6] = mm[9];
    rm[7] = mm[13];
    rm[8] = mm[2];
    rm[9] = mm[6];
    rm[10] = mm[10];
    rm[11] = mm[14];
    rm[12] = mm[3];
    rm[13] = mm[7];
    rm[14] = mm[11];
    rm[15] = mm[15];
    result.markAsUpdated();
    result._updateIdentityStatus(matrix._isIdentity, matrix._isIdentityDirty);
    return result;
  }
  static Reflection(plane) {
    const matrix = new Matrix();
    Matrix.ReflectionToRef(plane, matrix);
    return matrix;
  }
  static ReflectionToRef(plane, result) {
    plane.normalize();
    const x = plane.normal.x;
    const y = plane.normal.y;
    const z = plane.normal.z;
    const temp = -2 * x;
    const temp2 = -2 * y;
    const temp3 = -2 * z;
    Matrix.FromValuesToRef(temp * x + 1, temp2 * x, temp3 * x, 0, temp * y, temp2 * y + 1, temp3 * y, 0, temp * z, temp2 * z, temp3 * z + 1, 0, temp * plane.d, temp2 * plane.d, temp3 * plane.d, 1, result);
    return result;
  }
  static FromXYZAxesToRef(xaxis, yaxis, zaxis, result) {
    Matrix.FromValuesToRef(xaxis._x, xaxis._y, xaxis._z, 0, yaxis._x, yaxis._y, yaxis._z, 0, zaxis._x, zaxis._y, zaxis._z, 0, 0, 0, 0, 1, result);
    return result;
  }
  static FromQuaternionToRef(quat, result) {
    const xx = quat._x * quat._x;
    const yy = quat._y * quat._y;
    const zz = quat._z * quat._z;
    const xy = quat._x * quat._y;
    const zw = quat._z * quat._w;
    const zx = quat._z * quat._x;
    const yw = quat._y * quat._w;
    const yz = quat._y * quat._z;
    const xw = quat._x * quat._w;
    result._m[0] = 1 - 2 * (yy + zz);
    result._m[1] = 2 * (xy + zw);
    result._m[2] = 2 * (zx - yw);
    result._m[3] = 0;
    result._m[4] = 2 * (xy - zw);
    result._m[5] = 1 - 2 * (zz + xx);
    result._m[6] = 2 * (yz + xw);
    result._m[7] = 0;
    result._m[8] = 2 * (zx + yw);
    result._m[9] = 2 * (yz - xw);
    result._m[10] = 1 - 2 * (yy + xx);
    result._m[11] = 0;
    result._m[12] = 0;
    result._m[13] = 0;
    result._m[14] = 0;
    result._m[15] = 1;
    result.markAsUpdated();
    return result;
  }
};
Matrix._UpdateFlagSeed = 0;
Matrix._IdentityReadOnly = Matrix.Identity();
var MathTmp = class {
};
MathTmp.Vector3 = ArrayTools.BuildTuple(11, Vector3.Zero);
MathTmp.Matrix = ArrayTools.BuildTuple(2, Matrix.Identity);
MathTmp.Quaternion = ArrayTools.BuildTuple(3, Quaternion.Zero);
var TmpVectors = class {
};
TmpVectors.Vector2 = ArrayTools.BuildTuple(3, Vector2.Zero);
TmpVectors.Vector3 = ArrayTools.BuildTuple(13, Vector3.Zero);
TmpVectors.Vector4 = ArrayTools.BuildTuple(3, Vector4.Zero);
TmpVectors.Quaternion = ArrayTools.BuildTuple(2, Quaternion.Zero);
TmpVectors.Matrix = ArrayTools.BuildTuple(8, Matrix.Identity);
RegisterClass("BABYLON.Vector2", Vector2);
RegisterClass("BABYLON.Vector3", Vector3);
RegisterClass("BABYLON.Vector4", Vector4);
RegisterClass("BABYLON.Matrix", Matrix);
var mtxConvertNDCToHalfZRange = Matrix.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);

// node_modules/@babylonjs/core/Maths/math.color.js
var Color3 = class {
  constructor(r = 0, g = 0, b = 0) {
    this.r = r;
    this.g = g;
    this.b = b;
  }
  toString() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}";
  }
  getClassName() {
    return "Color3";
  }
  getHashCode() {
    let hash = this.r * 255 | 0;
    hash = hash * 397 ^ (this.g * 255 | 0);
    hash = hash * 397 ^ (this.b * 255 | 0);
    return hash;
  }
  toArray(array, index = 0) {
    array[index] = this.r;
    array[index + 1] = this.g;
    array[index + 2] = this.b;
    return this;
  }
  fromArray(array, offset = 0) {
    Color3.FromArrayToRef(array, offset, this);
    return this;
  }
  toColor4(alpha = 1) {
    return new Color4(this.r, this.g, this.b, alpha);
  }
  asArray() {
    return [this.r, this.g, this.b];
  }
  toLuminance() {
    return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
  }
  multiply(otherColor) {
    return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);
  }
  multiplyToRef(otherColor, result) {
    result.r = this.r * otherColor.r;
    result.g = this.g * otherColor.g;
    result.b = this.b * otherColor.b;
    return this;
  }
  equals(otherColor) {
    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;
  }
  equalsFloats(r, g, b) {
    return this.r === r && this.g === g && this.b === b;
  }
  scale(scale) {
    return new Color3(this.r * scale, this.g * scale, this.b * scale);
  }
  scaleInPlace(scale) {
    this.r *= scale;
    this.g *= scale;
    this.b *= scale;
    return this;
  }
  scaleToRef(scale, result) {
    result.r = this.r * scale;
    result.g = this.g * scale;
    result.b = this.b * scale;
    return this;
  }
  scaleAndAddToRef(scale, result) {
    result.r += this.r * scale;
    result.g += this.g * scale;
    result.b += this.b * scale;
    return this;
  }
  clampToRef(min = 0, max = 1, result) {
    result.r = Scalar.Clamp(this.r, min, max);
    result.g = Scalar.Clamp(this.g, min, max);
    result.b = Scalar.Clamp(this.b, min, max);
    return this;
  }
  add(otherColor) {
    return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);
  }
  addToRef(otherColor, result) {
    result.r = this.r + otherColor.r;
    result.g = this.g + otherColor.g;
    result.b = this.b + otherColor.b;
    return this;
  }
  subtract(otherColor) {
    return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);
  }
  subtractToRef(otherColor, result) {
    result.r = this.r - otherColor.r;
    result.g = this.g - otherColor.g;
    result.b = this.b - otherColor.b;
    return this;
  }
  clone() {
    return new Color3(this.r, this.g, this.b);
  }
  copyFrom(source) {
    this.r = source.r;
    this.g = source.g;
    this.b = source.b;
    return this;
  }
  copyFromFloats(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  }
  set(r, g, b) {
    return this.copyFromFloats(r, g, b);
  }
  toHexString() {
    const intR = Math.round(this.r * 255);
    const intG = Math.round(this.g * 255);
    const intB = Math.round(this.b * 255);
    return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);
  }
  toLinearSpace() {
    const convertedColor = new Color3();
    this.toLinearSpaceToRef(convertedColor);
    return convertedColor;
  }
  toHSV() {
    const result = new Color3();
    this.toHSVToRef(result);
    return result;
  }
  toHSVToRef(result) {
    const r = this.r;
    const g = this.g;
    const b = this.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h = 0;
    let s = 0;
    const v = max;
    const dm = max - min;
    if (max !== 0) {
      s = dm / max;
    }
    if (max != min) {
      if (max == r) {
        h = (g - b) / dm;
        if (g < b) {
          h += 6;
        }
      } else if (max == g) {
        h = (b - r) / dm + 2;
      } else if (max == b) {
        h = (r - g) / dm + 4;
      }
      h *= 60;
    }
    result.r = h;
    result.g = s;
    result.b = v;
  }
  toLinearSpaceToRef(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToLinearSpace);
    convertedColor.g = Math.pow(this.g, ToLinearSpace);
    convertedColor.b = Math.pow(this.b, ToLinearSpace);
    return this;
  }
  toGammaSpace() {
    const convertedColor = new Color3();
    this.toGammaSpaceToRef(convertedColor);
    return convertedColor;
  }
  toGammaSpaceToRef(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToGammaSpace);
    convertedColor.g = Math.pow(this.g, ToGammaSpace);
    convertedColor.b = Math.pow(this.b, ToGammaSpace);
    return this;
  }
  static HSVtoRGBToRef(hue, saturation, value, result) {
    const chroma = value * saturation;
    const h = hue / 60;
    const x = chroma * (1 - Math.abs(h % 2 - 1));
    let r = 0;
    let g = 0;
    let b = 0;
    if (h >= 0 && h <= 1) {
      r = chroma;
      g = x;
    } else if (h >= 1 && h <= 2) {
      r = x;
      g = chroma;
    } else if (h >= 2 && h <= 3) {
      g = chroma;
      b = x;
    } else if (h >= 3 && h <= 4) {
      g = x;
      b = chroma;
    } else if (h >= 4 && h <= 5) {
      r = x;
      b = chroma;
    } else if (h >= 5 && h <= 6) {
      r = chroma;
      b = x;
    }
    const m = value - chroma;
    result.set(r + m, g + m, b + m);
  }
  static FromHSV(hue, saturation, value) {
    const result = new Color3(0, 0, 0);
    Color3.HSVtoRGBToRef(hue, saturation, value, result);
    return result;
  }
  static FromHexString(hex) {
    if (hex.substring(0, 1) !== "#" || hex.length !== 7) {
      return new Color3(0, 0, 0);
    }
    const r = parseInt(hex.substring(1, 3), 16);
    const g = parseInt(hex.substring(3, 5), 16);
    const b = parseInt(hex.substring(5, 7), 16);
    return Color3.FromInts(r, g, b);
  }
  static FromArray(array, offset = 0) {
    return new Color3(array[offset], array[offset + 1], array[offset + 2]);
  }
  static FromArrayToRef(array, offset = 0, result) {
    result.r = array[offset];
    result.g = array[offset + 1];
    result.b = array[offset + 2];
  }
  static FromInts(r, g, b) {
    return new Color3(r / 255, g / 255, b / 255);
  }
  static Lerp(start, end, amount) {
    const result = new Color3(0, 0, 0);
    Color3.LerpToRef(start, end, amount, result);
    return result;
  }
  static LerpToRef(left, right, amount, result) {
    result.r = left.r + (right.r - left.r) * amount;
    result.g = left.g + (right.g - left.g) * amount;
    result.b = left.b + (right.b - left.b) * amount;
  }
  static Hermite(value1, tangent1, value2, tangent2, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const part1 = 2 * cubed - 3 * squared + 1;
    const part2 = -2 * cubed + 3 * squared;
    const part3 = cubed - 2 * squared + amount;
    const part4 = cubed - squared;
    const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;
    const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;
    const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;
    return new Color3(r, g, b);
  }
  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
    const result = Color3.Black();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  }
  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
    const t2 = time * time;
    result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;
    result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;
    result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;
  }
  static Red() {
    return new Color3(1, 0, 0);
  }
  static Green() {
    return new Color3(0, 1, 0);
  }
  static Blue() {
    return new Color3(0, 0, 1);
  }
  static Black() {
    return new Color3(0, 0, 0);
  }
  static get BlackReadOnly() {
    return Color3._BlackReadOnly;
  }
  static White() {
    return new Color3(1, 1, 1);
  }
  static Purple() {
    return new Color3(0.5, 0, 0.5);
  }
  static Magenta() {
    return new Color3(1, 0, 1);
  }
  static Yellow() {
    return new Color3(1, 1, 0);
  }
  static Gray() {
    return new Color3(0.5, 0.5, 0.5);
  }
  static Teal() {
    return new Color3(0, 1, 1);
  }
  static Random() {
    return new Color3(Math.random(), Math.random(), Math.random());
  }
};
Color3._BlackReadOnly = Color3.Black();
var Color4 = class {
  constructor(r = 0, g = 0, b = 0, a = 1) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  addInPlace(right) {
    this.r += right.r;
    this.g += right.g;
    this.b += right.b;
    this.a += right.a;
    return this;
  }
  asArray() {
    return [this.r, this.g, this.b, this.a];
  }
  toArray(array, index = 0) {
    array[index] = this.r;
    array[index + 1] = this.g;
    array[index + 2] = this.b;
    array[index + 3] = this.a;
    return this;
  }
  fromArray(array, offset = 0) {
    Color4.FromArrayToRef(array, offset, this);
    return this;
  }
  equals(otherColor) {
    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;
  }
  add(right) {
    return new Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);
  }
  subtract(right) {
    return new Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);
  }
  subtractToRef(right, result) {
    result.r = this.r - right.r;
    result.g = this.g - right.g;
    result.b = this.b - right.b;
    result.a = this.a - right.a;
    return this;
  }
  scale(scale) {
    return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);
  }
  scaleInPlace(scale) {
    this.r *= scale;
    this.g *= scale;
    this.b *= scale;
    this.a *= scale;
    return this;
  }
  scaleToRef(scale, result) {
    result.r = this.r * scale;
    result.g = this.g * scale;
    result.b = this.b * scale;
    result.a = this.a * scale;
    return this;
  }
  scaleAndAddToRef(scale, result) {
    result.r += this.r * scale;
    result.g += this.g * scale;
    result.b += this.b * scale;
    result.a += this.a * scale;
    return this;
  }
  clampToRef(min = 0, max = 1, result) {
    result.r = Scalar.Clamp(this.r, min, max);
    result.g = Scalar.Clamp(this.g, min, max);
    result.b = Scalar.Clamp(this.b, min, max);
    result.a = Scalar.Clamp(this.a, min, max);
    return this;
  }
  multiply(color) {
    return new Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);
  }
  multiplyToRef(color, result) {
    result.r = this.r * color.r;
    result.g = this.g * color.g;
    result.b = this.b * color.b;
    result.a = this.a * color.a;
    return result;
  }
  toString() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}";
  }
  getClassName() {
    return "Color4";
  }
  getHashCode() {
    let hash = this.r * 255 | 0;
    hash = hash * 397 ^ (this.g * 255 | 0);
    hash = hash * 397 ^ (this.b * 255 | 0);
    hash = hash * 397 ^ (this.a * 255 | 0);
    return hash;
  }
  clone() {
    return new Color4(this.r, this.g, this.b, this.a);
  }
  copyFrom(source) {
    this.r = source.r;
    this.g = source.g;
    this.b = source.b;
    this.a = source.a;
    return this;
  }
  copyFromFloats(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    return this;
  }
  set(r, g, b, a) {
    return this.copyFromFloats(r, g, b, a);
  }
  toHexString(returnAsColor3 = false) {
    const intR = Math.round(this.r * 255);
    const intG = Math.round(this.g * 255);
    const intB = Math.round(this.b * 255);
    if (returnAsColor3) {
      return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);
    }
    const intA = Math.round(this.a * 255);
    return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB) + Scalar.ToHex(intA);
  }
  toLinearSpace() {
    const convertedColor = new Color4();
    this.toLinearSpaceToRef(convertedColor);
    return convertedColor;
  }
  toLinearSpaceToRef(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToLinearSpace);
    convertedColor.g = Math.pow(this.g, ToLinearSpace);
    convertedColor.b = Math.pow(this.b, ToLinearSpace);
    convertedColor.a = this.a;
    return this;
  }
  toGammaSpace() {
    const convertedColor = new Color4();
    this.toGammaSpaceToRef(convertedColor);
    return convertedColor;
  }
  toGammaSpaceToRef(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToGammaSpace);
    convertedColor.g = Math.pow(this.g, ToGammaSpace);
    convertedColor.b = Math.pow(this.b, ToGammaSpace);
    convertedColor.a = this.a;
    return this;
  }
  static FromHexString(hex) {
    if (hex.substring(0, 1) !== "#" || hex.length !== 9 && hex.length !== 7) {
      return new Color4(0, 0, 0, 0);
    }
    const r = parseInt(hex.substring(1, 3), 16);
    const g = parseInt(hex.substring(3, 5), 16);
    const b = parseInt(hex.substring(5, 7), 16);
    const a = hex.length === 9 ? parseInt(hex.substring(7, 9), 16) : 255;
    return Color4.FromInts(r, g, b, a);
  }
  static Lerp(left, right, amount) {
    const result = new Color4(0, 0, 0, 0);
    Color4.LerpToRef(left, right, amount, result);
    return result;
  }
  static LerpToRef(left, right, amount, result) {
    result.r = left.r + (right.r - left.r) * amount;
    result.g = left.g + (right.g - left.g) * amount;
    result.b = left.b + (right.b - left.b) * amount;
    result.a = left.a + (right.a - left.a) * amount;
  }
  static Hermite(value1, tangent1, value2, tangent2, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const part1 = 2 * cubed - 3 * squared + 1;
    const part2 = -2 * cubed + 3 * squared;
    const part3 = cubed - 2 * squared + amount;
    const part4 = cubed - squared;
    const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;
    const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;
    const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;
    const a = value1.a * part1 + value2.a * part2 + tangent1.a * part3 + tangent2.a * part4;
    return new Color4(r, g, b, a);
  }
  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
    const result = new Color4();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  }
  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
    const t2 = time * time;
    result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;
    result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;
    result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;
    result.a = (t2 - time) * 6 * value1.a + (3 * t2 - 4 * time + 1) * tangent1.a + (-t2 + time) * 6 * value2.a + (3 * t2 - 2 * time) * tangent2.a;
  }
  static FromColor3(color3, alpha = 1) {
    return new Color4(color3.r, color3.g, color3.b, alpha);
  }
  static FromArray(array, offset = 0) {
    return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
  }
  static FromArrayToRef(array, offset = 0, result) {
    result.r = array[offset];
    result.g = array[offset + 1];
    result.b = array[offset + 2];
    result.a = array[offset + 3];
  }
  static FromInts(r, g, b, a) {
    return new Color4(r / 255, g / 255, b / 255, a / 255);
  }
  static CheckColors4(colors, count) {
    if (colors.length === count * 3) {
      const colors4 = [];
      for (let index = 0; index < colors.length; index += 3) {
        const newIndex = index / 3 * 4;
        colors4[newIndex] = colors[index];
        colors4[newIndex + 1] = colors[index + 1];
        colors4[newIndex + 2] = colors[index + 2];
        colors4[newIndex + 3] = 1;
      }
      return colors4;
    }
    return colors;
  }
};
var TmpColors = class {
};
TmpColors.Color3 = ArrayTools.BuildArray(3, Color3.Black);
TmpColors.Color4 = ArrayTools.BuildArray(3, () => new Color4(0, 0, 0, 0));
RegisterClass("BABYLON.Color3", Color3);
RegisterClass("BABYLON.Color4", Color4);

// node_modules/@babylonjs/core/Actions/actionEvent.js
var ActionEvent = class {
  constructor(source, pointerX, pointerY, meshUnderPointer, sourceEvent, additionalData) {
    this.source = source;
    this.pointerX = pointerX;
    this.pointerY = pointerY;
    this.meshUnderPointer = meshUnderPointer;
    this.sourceEvent = sourceEvent;
    this.additionalData = additionalData;
  }
  static CreateNew(source, evt, additionalData) {
    const scene = source.getScene();
    return new ActionEvent(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer || source, evt, additionalData);
  }
  static CreateNewFromSprite(source, scene, evt, additionalData) {
    return new ActionEvent(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt, additionalData);
  }
  static CreateNewFromScene(scene, evt) {
    return new ActionEvent(null, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt);
  }
  static CreateNewFromPrimitive(prim, pointerPos, evt, additionalData) {
    return new ActionEvent(prim, pointerPos.x, pointerPos.y, null, evt, additionalData);
  }
};

// node_modules/@babylonjs/core/Misc/logger.js
var Logger = class {
  static _CheckLimit(message, limit) {
    let entry = Logger._LogLimitOutputs[message];
    if (!entry) {
      entry = { limit, current: 1 };
      Logger._LogLimitOutputs[message] = entry;
    } else {
      entry.current++;
    }
    return entry.current <= entry.limit;
  }
  static _GenerateLimitMessage(message, level = 1) {
    var _a;
    const entry = Logger._LogLimitOutputs[message];
    if (!entry || !Logger.MessageLimitReached) {
      return;
    }
    const type = this._Levels[level];
    if (entry.current === entry.limit) {
      Logger[type.name](Logger.MessageLimitReached.replace(/%LIMIT%/g, "" + entry.limit).replace(/%TYPE%/g, (_a = type.name) !== null && _a !== void 0 ? _a : ""));
    }
  }
  static _AddLogEntry(entry) {
    Logger._LogCache = entry + Logger._LogCache;
    if (Logger.OnNewCacheEntry) {
      Logger.OnNewCacheEntry(entry);
    }
  }
  static _FormatMessage(message) {
    const padStr = (i) => i < 10 ? "0" + i : "" + i;
    const date = new Date();
    return "[" + padStr(date.getHours()) + ":" + padStr(date.getMinutes()) + ":" + padStr(date.getSeconds()) + "]: " + message;
  }
  static _LogDisabled(message, limit) {
  }
  static _LogEnabled(level = 1, message, limit) {
    if (limit !== void 0 && !Logger._CheckLimit(message, limit)) {
      return;
    }
    const formattedMessage = Logger._FormatMessage(message);
    const type = this._Levels[level];
    type.logFunc && type.logFunc("BJS - " + formattedMessage);
    const entry = `<div style='color:${type.color}'>${formattedMessage}</div><br>`;
    Logger._AddLogEntry(entry);
    Logger._GenerateLimitMessage(message, level);
  }
  static get LogCache() {
    return Logger._LogCache;
  }
  static ClearLogCache() {
    Logger._LogCache = "";
    Logger._LogLimitOutputs = {};
    Logger.errorsCount = 0;
  }
  static set LogLevels(level) {
    Logger.Log = Logger._LogDisabled;
    Logger.Warn = Logger._LogDisabled;
    Logger.Error = Logger._LogDisabled;
    [Logger.MessageLogLevel, Logger.WarningLogLevel, Logger.ErrorLogLevel].forEach((l) => {
      if ((level & l) === l) {
        const type = this._Levels[l];
        Logger[type.name] = Logger._LogEnabled.bind(Logger, l);
      }
    });
  }
};
Logger.NoneLogLevel = 0;
Logger.MessageLogLevel = 1;
Logger.WarningLogLevel = 2;
Logger.ErrorLogLevel = 4;
Logger.AllLogLevel = 7;
Logger.MessageLimitReached = "Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.";
Logger._LogCache = "";
Logger._LogLimitOutputs = {};
Logger._Levels = [
  {},
  { color: "white", logFunc: console.log, name: "Log" },
  { color: "orange", logFunc: console.warn, name: "Warn" },
  {},
  { color: "red", logFunc: console.error, name: "Error" }
];
Logger.errorsCount = 0;
Logger.Log = Logger._LogEnabled.bind(Logger, Logger.MessageLogLevel);
Logger.Warn = Logger._LogEnabled.bind(Logger, Logger.WarningLogLevel);
Logger.Error = Logger._LogEnabled.bind(Logger, Logger.ErrorLogLevel);

// node_modules/@babylonjs/core/Misc/deepCopier.js
var CloneValue = (source, destinationObject) => {
  if (!source) {
    return null;
  }
  if (source.getClassName && source.getClassName() === "Mesh") {
    return null;
  }
  if (source.getClassName && source.getClassName() === "SubMesh") {
    return source.clone(destinationObject);
  } else if (source.clone) {
    return source.clone();
  }
  return null;
};
function GetAllPropertyNames(obj) {
  const props = [];
  do {
    Object.getOwnPropertyNames(obj).forEach(function(prop) {
      if (props.indexOf(prop) === -1) {
        props.push(prop);
      }
    });
  } while (obj = Object.getPrototypeOf(obj));
  return props;
}
var DeepCopier = class {
  static DeepCopy(source, destination, doNotCopyList, mustCopyList) {
    const properties = GetAllPropertyNames(source);
    for (const prop of properties) {
      if (prop[0] === "_" && (!mustCopyList || mustCopyList.indexOf(prop) === -1)) {
        continue;
      }
      if (prop.endsWith("Observable")) {
        continue;
      }
      if (doNotCopyList && doNotCopyList.indexOf(prop) !== -1) {
        continue;
      }
      const sourceValue = source[prop];
      const typeOfSourceValue = typeof sourceValue;
      if (typeOfSourceValue === "function") {
        continue;
      }
      try {
        if (typeOfSourceValue === "object") {
          if (sourceValue instanceof Array) {
            destination[prop] = [];
            if (sourceValue.length > 0) {
              if (typeof sourceValue[0] == "object") {
                for (let index = 0; index < sourceValue.length; index++) {
                  const clonedValue = CloneValue(sourceValue[index], destination);
                  if (destination[prop].indexOf(clonedValue) === -1) {
                    destination[prop].push(clonedValue);
                  }
                }
              } else {
                destination[prop] = sourceValue.slice(0);
              }
            }
          } else {
            destination[prop] = CloneValue(sourceValue, destination);
          }
        } else {
          destination[prop] = sourceValue;
        }
      } catch (e) {
        Logger.Warn(e.message);
      }
    }
  }
};

// node_modules/@babylonjs/core/Misc/andOrNotEvaluator.js
var AndOrNotEvaluator = class {
  static Eval(query, evaluateCallback) {
    if (!query.match(/\([^()]*\)/g)) {
      query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);
    } else {
      query = query.replace(/\([^()]*\)/g, (r) => {
        r = r.slice(1, r.length - 1);
        return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);
      });
    }
    if (query === "true") {
      return true;
    }
    if (query === "false") {
      return false;
    }
    return AndOrNotEvaluator.Eval(query, evaluateCallback);
  }
  static _HandleParenthesisContent(parenthesisContent, evaluateCallback) {
    evaluateCallback = evaluateCallback || ((r) => {
      return r === "true" ? true : false;
    });
    let result;
    const or = parenthesisContent.split("||");
    for (const i in or) {
      if (Object.prototype.hasOwnProperty.call(or, i)) {
        let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());
        const and = ori.split("&&");
        if (and.length > 1) {
          for (let j = 0; j < and.length; ++j) {
            const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());
            if (andj !== "true" && andj !== "false") {
              if (andj[0] === "!") {
                result = !evaluateCallback(andj.substring(1));
              } else {
                result = evaluateCallback(andj);
              }
            } else {
              result = andj === "true" ? true : false;
            }
            if (!result) {
              ori = "false";
              break;
            }
          }
        }
        if (result || ori === "true") {
          result = true;
          break;
        }
        if (ori !== "true" && ori !== "false") {
          if (ori[0] === "!") {
            result = !evaluateCallback(ori.substring(1));
          } else {
            result = evaluateCallback(ori);
          }
        } else {
          result = ori === "true" ? true : false;
        }
      }
    }
    return result ? "true" : "false";
  }
  static _SimplifyNegation(booleanString) {
    booleanString = booleanString.replace(/^[\s!]+/, (r) => {
      r = r.replace(/[\s]/g, () => "");
      return r.length % 2 ? "!" : "";
    });
    booleanString = booleanString.trim();
    if (booleanString === "!true") {
      booleanString = "false";
    } else if (booleanString === "!false") {
      booleanString = "true";
    }
    return booleanString;
  }
};

// node_modules/@babylonjs/core/Misc/tags.js
var Tags = class {
  static EnableFor(obj) {
    obj._tags = obj._tags || {};
    obj.hasTags = () => {
      return Tags.HasTags(obj);
    };
    obj.addTags = (tagsString) => {
      return Tags.AddTagsTo(obj, tagsString);
    };
    obj.removeTags = (tagsString) => {
      return Tags.RemoveTagsFrom(obj, tagsString);
    };
    obj.matchesTagsQuery = (tagsQuery) => {
      return Tags.MatchesQuery(obj, tagsQuery);
    };
  }
  static DisableFor(obj) {
    delete obj._tags;
    delete obj.hasTags;
    delete obj.addTags;
    delete obj.removeTags;
    delete obj.matchesTagsQuery;
  }
  static HasTags(obj) {
    if (!obj._tags) {
      return false;
    }
    const tags = obj._tags;
    for (const i in tags) {
      if (Object.prototype.hasOwnProperty.call(tags, i)) {
        return true;
      }
    }
    return false;
  }
  static GetTags(obj, asString = true) {
    if (!obj._tags) {
      return null;
    }
    if (asString) {
      const tagsArray = [];
      for (const tag in obj._tags) {
        if (Object.prototype.hasOwnProperty.call(obj._tags, tag) && obj._tags[tag] === true) {
          tagsArray.push(tag);
        }
      }
      return tagsArray.join(" ");
    } else {
      return obj._tags;
    }
  }
  static AddTagsTo(obj, tagsString) {
    if (!tagsString) {
      return;
    }
    if (typeof tagsString !== "string") {
      return;
    }
    const tags = tagsString.split(" ");
    tags.forEach(function(tag) {
      Tags._AddTagTo(obj, tag);
    });
  }
  static _AddTagTo(obj, tag) {
    tag = tag.trim();
    if (tag === "" || tag === "true" || tag === "false") {
      return;
    }
    if (tag.match(/[\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {
      return;
    }
    Tags.EnableFor(obj);
    obj._tags[tag] = true;
  }
  static RemoveTagsFrom(obj, tagsString) {
    if (!Tags.HasTags(obj)) {
      return;
    }
    const tags = tagsString.split(" ");
    for (const t in tags) {
      Tags._RemoveTagFrom(obj, tags[t]);
    }
  }
  static _RemoveTagFrom(obj, tag) {
    delete obj._tags[tag];
  }
  static MatchesQuery(obj, tagsQuery) {
    if (tagsQuery === void 0) {
      return true;
    }
    if (tagsQuery === "") {
      return Tags.HasTags(obj);
    }
    return AndOrNotEvaluator.Eval(tagsQuery, (r) => Tags.HasTags(obj) && obj._tags[r]);
  }
};

// node_modules/@babylonjs/core/Misc/devTools.js
function _WarnImport(name63) {
  return `${name63} needs to be imported before as it contains a side-effect required by your code.`;
}

// node_modules/@babylonjs/core/Misc/decorators.js
var __decoratorInitialStore = {};
var __mergedStore = {};
var _copySource = function(creationFunction, source, instanciate) {
  const destination = creationFunction();
  if (Tags) {
    Tags.AddTagsTo(destination, source.tags);
  }
  const classStore = getMergedStore(destination);
  for (const property in classStore) {
    const propertyDescriptor = classStore[property];
    const sourceProperty = source[property];
    const propertyType = propertyDescriptor.type;
    if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper.AllowLoadingUniqueId)) {
      switch (propertyType) {
        case 0:
        case 6:
        case 11:
          destination[property] = sourceProperty;
          break;
        case 1:
          destination[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 7:
        case 10:
        case 12:
          destination[property] = instanciate ? sourceProperty : sourceProperty.clone();
          break;
      }
    }
  }
  return destination;
};
function getDirectStore(target) {
  const classKey = target.getClassName();
  if (!__decoratorInitialStore[classKey]) {
    __decoratorInitialStore[classKey] = {};
  }
  return __decoratorInitialStore[classKey];
}
function getMergedStore(target) {
  const classKey = target.getClassName();
  if (__mergedStore[classKey]) {
    return __mergedStore[classKey];
  }
  __mergedStore[classKey] = {};
  const store = __mergedStore[classKey];
  let currentTarget = target;
  let currentKey = classKey;
  while (currentKey) {
    const initialStore = __decoratorInitialStore[currentKey];
    for (const property in initialStore) {
      store[property] = initialStore[property];
    }
    let parent;
    let done = false;
    do {
      parent = Object.getPrototypeOf(currentTarget);
      if (!parent.getClassName) {
        done = true;
        break;
      }
      if (parent.getClassName() !== currentKey) {
        break;
      }
      currentTarget = parent;
    } while (parent);
    if (done) {
      break;
    }
    currentKey = parent.getClassName();
    currentTarget = parent;
  }
  return store;
}
function generateSerializableMember(type, sourceName) {
  return (target, propertyKey) => {
    const classStore = getDirectStore(target);
    if (!classStore[propertyKey]) {
      classStore[propertyKey] = { type, sourceName };
    }
  };
}
function generateExpandMember(setCallback, targetKey = null) {
  return (target, propertyKey) => {
    const key = targetKey || "_" + propertyKey;
    Object.defineProperty(target, propertyKey, {
      get: function() {
        return this[key];
      },
      set: function(value) {
        if (typeof this.equals === "function") {
          if (this.equals(value)) {
            return;
          }
        }
        if (this[key] === value) {
          return;
        }
        this[key] = value;
        target[setCallback].apply(this);
      },
      enumerable: true,
      configurable: true
    });
  };
}
function expandToProperty(callback, targetKey = null) {
  return generateExpandMember(callback, targetKey);
}
function serialize(sourceName) {
  return generateSerializableMember(0, sourceName);
}
function serializeAsTexture(sourceName) {
  return generateSerializableMember(1, sourceName);
}
function serializeAsColor3(sourceName) {
  return generateSerializableMember(2, sourceName);
}
function serializeAsFresnelParameters(sourceName) {
  return generateSerializableMember(3, sourceName);
}
function serializeAsVector2(sourceName) {
  return generateSerializableMember(4, sourceName);
}
function serializeAsVector3(sourceName) {
  return generateSerializableMember(5, sourceName);
}
function serializeAsMeshReference(sourceName) {
  return generateSerializableMember(6, sourceName);
}
function serializeAsColorCurves(sourceName) {
  return generateSerializableMember(7, sourceName);
}
function serializeAsColor4(sourceName) {
  return generateSerializableMember(8, sourceName);
}
function serializeAsImageProcessingConfiguration(sourceName) {
  return generateSerializableMember(9, sourceName);
}
function serializeAsQuaternion(sourceName) {
  return generateSerializableMember(10, sourceName);
}
function serializeAsMatrix(sourceName) {
  return generateSerializableMember(12, sourceName);
}
function serializeAsCameraReference(sourceName) {
  return generateSerializableMember(11, sourceName);
}
var SerializationHelper = class {
  static AppendSerializedAnimations(source, destination) {
    if (source.animations) {
      destination.animations = [];
      for (let animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {
        const animation = source.animations[animationIndex];
        destination.animations.push(animation.serialize());
      }
    }
  }
  static Serialize(entity, serializationObject) {
    if (!serializationObject) {
      serializationObject = {};
    }
    if (Tags) {
      serializationObject.tags = Tags.GetTags(entity);
    }
    const serializedProperties = getMergedStore(entity);
    for (const property in serializedProperties) {
      const propertyDescriptor = serializedProperties[property];
      const targetPropertyName = propertyDescriptor.sourceName || property;
      const propertyType = propertyDescriptor.type;
      const sourceProperty = entity[property];
      if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper.AllowLoadingUniqueId)) {
        switch (propertyType) {
          case 0:
            serializationObject[targetPropertyName] = sourceProperty;
            break;
          case 1:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 2:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 3:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 4:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 5:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 6:
            serializationObject[targetPropertyName] = sourceProperty.id;
            break;
          case 7:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 8:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 9:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 10:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 11:
            serializationObject[targetPropertyName] = sourceProperty.id;
            break;
          case 12:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
        }
      }
    }
    return serializationObject;
  }
  static Parse(creationFunction, source, scene, rootUrl = null) {
    const destination = creationFunction();
    if (!rootUrl) {
      rootUrl = "";
    }
    if (Tags) {
      Tags.AddTagsTo(destination, source.tags);
    }
    const classStore = getMergedStore(destination);
    for (const property in classStore) {
      const propertyDescriptor = classStore[property];
      const sourceProperty = source[propertyDescriptor.sourceName || property];
      const propertyType = propertyDescriptor.type;
      if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper.AllowLoadingUniqueId)) {
        const dest = destination;
        switch (propertyType) {
          case 0:
            dest[property] = sourceProperty;
            break;
          case 1:
            if (scene) {
              dest[property] = SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);
            }
            break;
          case 2:
            dest[property] = Color3.FromArray(sourceProperty);
            break;
          case 3:
            dest[property] = SerializationHelper._FresnelParametersParser(sourceProperty);
            break;
          case 4:
            dest[property] = Vector2.FromArray(sourceProperty);
            break;
          case 5:
            dest[property] = Vector3.FromArray(sourceProperty);
            break;
          case 6:
            if (scene) {
              dest[property] = scene.getLastMeshById(sourceProperty);
            }
            break;
          case 7:
            dest[property] = SerializationHelper._ColorCurvesParser(sourceProperty);
            break;
          case 8:
            dest[property] = Color4.FromArray(sourceProperty);
            break;
          case 9:
            dest[property] = SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);
            break;
          case 10:
            dest[property] = Quaternion.FromArray(sourceProperty);
            break;
          case 11:
            if (scene) {
              dest[property] = scene.getCameraById(sourceProperty);
            }
            break;
          case 12:
            dest[property] = Matrix.FromArray(sourceProperty);
            break;
        }
      }
    }
    return destination;
  }
  static Clone(creationFunction, source) {
    return _copySource(creationFunction, source, false);
  }
  static Instanciate(creationFunction, source) {
    return _copySource(creationFunction, source, true);
  }
};
SerializationHelper.AllowLoadingUniqueId = false;
SerializationHelper._ImageProcessingConfigurationParser = (sourceProperty) => {
  throw _WarnImport("ImageProcessingConfiguration");
};
SerializationHelper._FresnelParametersParser = (sourceProperty) => {
  throw _WarnImport("FresnelParameters");
};
SerializationHelper._ColorCurvesParser = (sourceProperty) => {
  throw _WarnImport("ColorCurves");
};
SerializationHelper._TextureParser = (sourceProperty, scene, rootUrl) => {
  throw _WarnImport("Texture");
};
function nativeOverride(target, propertyKey, descriptor, predicate) {
  const jsFunc = descriptor.value;
  descriptor.value = (...params) => {
    let func = jsFunc;
    if (typeof _native !== "undefined" && _native[propertyKey]) {
      const nativeFunc = _native[propertyKey];
      if (predicate) {
        func = (...params2) => predicate(...params2) ? nativeFunc(...params2) : jsFunc(...params2);
      } else {
        func = nativeFunc;
      }
    }
    target[propertyKey] = func;
    return func(...params);
  };
}
nativeOverride.filter = function(predicate) {
  return (target, propertyKey, descriptor) => nativeOverride(target, propertyKey, descriptor, predicate);
};

// node_modules/@babylonjs/core/Animations/animationKey.js
var AnimationKeyInterpolation;
(function(AnimationKeyInterpolation2) {
  AnimationKeyInterpolation2[AnimationKeyInterpolation2["NONE"] = 0] = "NONE";
  AnimationKeyInterpolation2[AnimationKeyInterpolation2["STEP"] = 1] = "STEP";
})(AnimationKeyInterpolation || (AnimationKeyInterpolation = {}));

// node_modules/@babylonjs/core/Animations/animationRange.js
var AnimationRange = class {
  constructor(name63, from, to) {
    this.name = name63;
    this.from = from;
    this.to = to;
  }
  clone() {
    return new AnimationRange(this.name, this.from, this.to);
  }
};

// node_modules/@babylonjs/core/tslib.es6.js
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// node_modules/@babylonjs/core/node.js
var _InternalNodeDataInfo = class {
  constructor() {
    this._doNotSerialize = false;
    this._isDisposed = false;
    this._sceneRootNodesIndex = -1;
    this._isEnabled = true;
    this._isParentEnabled = true;
    this._isReady = true;
    this._onEnabledStateChangedObservable = new Observable();
    this._onClonedObservable = new Observable();
  }
};
var Node = class {
  constructor(name63, scene = null) {
    this._isDirty = false;
    this._nodeDataStorage = new _InternalNodeDataInfo();
    this.state = "";
    this.metadata = null;
    this.reservedDataStore = null;
    this._accessibilityTag = null;
    this.onAccessibilityTagChangedObservable = new Observable();
    this._parentContainer = null;
    this.animations = new Array();
    this._ranges = {};
    this.onReady = null;
    this._currentRenderId = -1;
    this._parentUpdateId = -1;
    this._childUpdateId = -1;
    this._waitingParentId = null;
    this._waitingParentInstanceIndex = null;
    this._waitingParsedUniqueId = null;
    this._cache = {};
    this._parentNode = null;
    this._children = null;
    this._worldMatrix = Matrix.Identity();
    this._worldMatrixDeterminant = 0;
    this._worldMatrixDeterminantIsDirty = true;
    this._animationPropertiesOverride = null;
    this._isNode = true;
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this._behaviors = new Array();
    this.name = name63;
    this.id = name63;
    this._scene = scene || EngineStore.LastCreatedScene;
    this.uniqueId = this._scene.getUniqueId();
    this._initCache();
  }
  static AddNodeConstructor(type, constructorFunc) {
    this._NodeConstructors[type] = constructorFunc;
  }
  static Construct(type, name63, scene, options) {
    const constructorFunc = this._NodeConstructors[type];
    if (!constructorFunc) {
      return null;
    }
    return constructorFunc(name63, scene, options);
  }
  set accessibilityTag(value) {
    this._accessibilityTag = value;
    this.onAccessibilityTagChangedObservable.notifyObservers(value);
  }
  get accessibilityTag() {
    return this._accessibilityTag;
  }
  get doNotSerialize() {
    if (this._nodeDataStorage._doNotSerialize) {
      return true;
    }
    if (this._parentNode) {
      return this._parentNode.doNotSerialize;
    }
    return false;
  }
  set doNotSerialize(value) {
    this._nodeDataStorage._doNotSerialize = value;
  }
  isDisposed() {
    return this._nodeDataStorage._isDisposed;
  }
  set parent(parent) {
    if (this._parentNode === parent) {
      return;
    }
    const previousParentNode = this._parentNode;
    if (this._parentNode && this._parentNode._children !== void 0 && this._parentNode._children !== null) {
      const index = this._parentNode._children.indexOf(this);
      if (index !== -1) {
        this._parentNode._children.splice(index, 1);
      }
      if (!parent && !this._nodeDataStorage._isDisposed) {
        this._addToSceneRootNodes();
      }
    }
    this._parentNode = parent;
    if (this._parentNode) {
      if (this._parentNode._children === void 0 || this._parentNode._children === null) {
        this._parentNode._children = new Array();
      }
      this._parentNode._children.push(this);
      if (!previousParentNode) {
        this._removeFromSceneRootNodes();
      }
    }
    this._syncParentEnabledState();
  }
  get parent() {
    return this._parentNode;
  }
  _serializeAsParent(serializationObject) {
    serializationObject.parentId = this.uniqueId;
  }
  _addToSceneRootNodes() {
    if (this._nodeDataStorage._sceneRootNodesIndex === -1) {
      this._nodeDataStorage._sceneRootNodesIndex = this._scene.rootNodes.length;
      this._scene.rootNodes.push(this);
    }
  }
  _removeFromSceneRootNodes() {
    if (this._nodeDataStorage._sceneRootNodesIndex !== -1) {
      const rootNodes = this._scene.rootNodes;
      const lastIdx = rootNodes.length - 1;
      rootNodes[this._nodeDataStorage._sceneRootNodesIndex] = rootNodes[lastIdx];
      rootNodes[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex = this._nodeDataStorage._sceneRootNodesIndex;
      this._scene.rootNodes.pop();
      this._nodeDataStorage._sceneRootNodesIndex = -1;
    }
  }
  get animationPropertiesOverride() {
    if (!this._animationPropertiesOverride) {
      return this._scene.animationPropertiesOverride;
    }
    return this._animationPropertiesOverride;
  }
  set animationPropertiesOverride(value) {
    this._animationPropertiesOverride = value;
  }
  getClassName() {
    return "Node";
  }
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  get onEnabledStateChangedObservable() {
    return this._nodeDataStorage._onEnabledStateChangedObservable;
  }
  get onClonedObservable() {
    return this._nodeDataStorage._onClonedObservable;
  }
  getScene() {
    return this._scene;
  }
  getEngine() {
    return this._scene.getEngine();
  }
  addBehavior(behavior, attachImmediately = false) {
    const index = this._behaviors.indexOf(behavior);
    if (index !== -1) {
      return this;
    }
    behavior.init();
    if (this._scene.isLoading && !attachImmediately) {
      this._scene.onDataLoadedObservable.addOnce(() => {
        behavior.attach(this);
      });
    } else {
      behavior.attach(this);
    }
    this._behaviors.push(behavior);
    return this;
  }
  removeBehavior(behavior) {
    const index = this._behaviors.indexOf(behavior);
    if (index === -1) {
      return this;
    }
    this._behaviors[index].detach();
    this._behaviors.splice(index, 1);
    return this;
  }
  get behaviors() {
    return this._behaviors;
  }
  getBehaviorByName(name63) {
    for (const behavior of this._behaviors) {
      if (behavior.name === name63) {
        return behavior;
      }
    }
    return null;
  }
  getWorldMatrix() {
    if (this._currentRenderId !== this._scene.getRenderId()) {
      this.computeWorldMatrix();
    }
    return this._worldMatrix;
  }
  _getWorldMatrixDeterminant() {
    if (this._worldMatrixDeterminantIsDirty) {
      this._worldMatrixDeterminantIsDirty = false;
      this._worldMatrixDeterminant = this._worldMatrix.determinant();
    }
    return this._worldMatrixDeterminant;
  }
  get worldMatrixFromCache() {
    return this._worldMatrix;
  }
  _initCache() {
    this._cache = {};
    this._cache.parent = void 0;
  }
  updateCache(force) {
    if (!force && this.isSynchronized()) {
      return;
    }
    this._cache.parent = this.parent;
    this._updateCache();
  }
  _getActionManagerForTrigger(trigger, _initialCall = true) {
    if (!this.parent) {
      return null;
    }
    return this.parent._getActionManagerForTrigger(trigger, false);
  }
  _updateCache(_ignoreParentClass) {
  }
  _isSynchronized() {
    return true;
  }
  _markSyncedWithParent() {
    if (this._parentNode) {
      this._parentUpdateId = this._parentNode._childUpdateId;
    }
  }
  isSynchronizedWithParent() {
    if (!this._parentNode) {
      return true;
    }
    if (this._parentNode._isDirty || this._parentUpdateId !== this._parentNode._childUpdateId) {
      return false;
    }
    return this._parentNode.isSynchronized();
  }
  isSynchronized() {
    if (this._cache.parent !== this._parentNode) {
      this._cache.parent = this._parentNode;
      return false;
    }
    if (this._parentNode && !this.isSynchronizedWithParent()) {
      return false;
    }
    return this._isSynchronized();
  }
  isReady(_completeCheck = false) {
    return this._nodeDataStorage._isReady;
  }
  markAsDirty(_property) {
    this._currentRenderId = Number.MAX_VALUE;
    this._isDirty = true;
    return this;
  }
  isEnabled(checkAncestors = true) {
    if (checkAncestors === false) {
      return this._nodeDataStorage._isEnabled;
    }
    if (!this._nodeDataStorage._isEnabled) {
      return false;
    }
    return this._nodeDataStorage._isParentEnabled;
  }
  _syncParentEnabledState() {
    this._nodeDataStorage._isParentEnabled = this._parentNode ? this._parentNode.isEnabled() : true;
    if (this._children) {
      this._children.forEach((c) => {
        c._syncParentEnabledState();
      });
    }
  }
  setEnabled(value) {
    if (this._nodeDataStorage._isEnabled === value) {
      return;
    }
    this._nodeDataStorage._isEnabled = value;
    this._syncParentEnabledState();
    this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(value);
  }
  isDescendantOf(ancestor) {
    if (this.parent) {
      if (this.parent === ancestor) {
        return true;
      }
      return this.parent.isDescendantOf(ancestor);
    }
    return false;
  }
  _getDescendants(results, directDescendantsOnly = false, predicate) {
    if (!this._children) {
      return;
    }
    for (let index = 0; index < this._children.length; index++) {
      const item = this._children[index];
      if (!predicate || predicate(item)) {
        results.push(item);
      }
      if (!directDescendantsOnly) {
        item._getDescendants(results, false, predicate);
      }
    }
  }
  getDescendants(directDescendantsOnly, predicate) {
    const results = new Array();
    this._getDescendants(results, directDescendantsOnly, predicate);
    return results;
  }
  getChildMeshes(directDescendantsOnly, predicate) {
    const results = [];
    this._getDescendants(results, directDescendantsOnly, (node) => {
      return (!predicate || predicate(node)) && node.cullingStrategy !== void 0;
    });
    return results;
  }
  getChildren(predicate, directDescendantsOnly = true) {
    return this.getDescendants(directDescendantsOnly, predicate);
  }
  _setReady(state) {
    if (state === this._nodeDataStorage._isReady) {
      return;
    }
    if (!state) {
      this._nodeDataStorage._isReady = false;
      return;
    }
    if (this.onReady) {
      this.onReady(this);
    }
    this._nodeDataStorage._isReady = true;
  }
  getAnimationByName(name63) {
    for (let i = 0; i < this.animations.length; i++) {
      const animation = this.animations[i];
      if (animation.name === name63) {
        return animation;
      }
    }
    return null;
  }
  createAnimationRange(name63, from, to) {
    if (!this._ranges[name63]) {
      this._ranges[name63] = Node._AnimationRangeFactory(name63, from, to);
      for (let i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
        if (this.animations[i]) {
          this.animations[i].createRange(name63, from, to);
        }
      }
    }
  }
  deleteAnimationRange(name63, deleteFrames = true) {
    for (let i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
      if (this.animations[i]) {
        this.animations[i].deleteRange(name63, deleteFrames);
      }
    }
    this._ranges[name63] = null;
  }
  getAnimationRange(name63) {
    return this._ranges[name63] || null;
  }
  getAnimationRanges() {
    const animationRanges = [];
    let name63;
    for (name63 in this._ranges) {
      animationRanges.push(this._ranges[name63]);
    }
    return animationRanges;
  }
  beginAnimation(name63, loop, speedRatio, onAnimationEnd) {
    const range = this.getAnimationRange(name63);
    if (!range) {
      return null;
    }
    return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);
  }
  serializeAnimationRanges() {
    const serializationRanges = [];
    for (const name63 in this._ranges) {
      const localRange = this._ranges[name63];
      if (!localRange) {
        continue;
      }
      const range = {};
      range.name = name63;
      range.from = localRange.from;
      range.to = localRange.to;
      serializationRanges.push(range);
    }
    return serializationRanges;
  }
  computeWorldMatrix(_force) {
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    return this._worldMatrix;
  }
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this._nodeDataStorage._isDisposed = true;
    if (!doNotRecurse) {
      const nodes = this.getDescendants(true);
      for (const node of nodes) {
        node.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
    }
    if (!this.parent) {
      this._removeFromSceneRootNodes();
    } else {
      this.parent = null;
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onEnabledStateChangedObservable.clear();
    this.onClonedObservable.clear();
    for (const behavior of this._behaviors) {
      behavior.detach();
    }
    this._behaviors.length = 0;
    this.metadata = null;
  }
  static ParseAnimationRanges(node, parsedNode, _scene) {
    if (parsedNode.ranges) {
      for (let index = 0; index < parsedNode.ranges.length; index++) {
        const data = parsedNode.ranges[index];
        node.createAnimationRange(data.name, data.from, data.to);
      }
    }
  }
  getHierarchyBoundingVectors(includeDescendants = true, predicate = null) {
    this.getScene().incrementRenderId();
    this.computeWorldMatrix(true);
    let min;
    let max;
    const thisAbstractMesh = this;
    if (thisAbstractMesh.getBoundingInfo && thisAbstractMesh.subMeshes) {
      const boundingInfo = thisAbstractMesh.getBoundingInfo();
      min = boundingInfo.boundingBox.minimumWorld.clone();
      max = boundingInfo.boundingBox.maximumWorld.clone();
    } else {
      min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    }
    if (includeDescendants) {
      const descendants = this.getDescendants(false);
      for (const descendant of descendants) {
        const childMesh = descendant;
        childMesh.computeWorldMatrix(true);
        if (predicate && !predicate(childMesh)) {
          continue;
        }
        if (!childMesh.getBoundingInfo || childMesh.getTotalVertices() === 0) {
          continue;
        }
        const childBoundingInfo = childMesh.getBoundingInfo();
        const boundingBox = childBoundingInfo.boundingBox;
        const minBox = boundingBox.minimumWorld;
        const maxBox = boundingBox.maximumWorld;
        Vector3.CheckExtends(minBox, min, max);
        Vector3.CheckExtends(maxBox, min, max);
      }
    }
    return {
      min,
      max
    };
  }
};
Node._AnimationRangeFactory = (_name, _from, _to) => {
  throw _WarnImport("AnimationRange");
};
Node._NodeConstructors = {};
__decorate([
  serialize()
], Node.prototype, "name", void 0);
__decorate([
  serialize()
], Node.prototype, "id", void 0);
__decorate([
  serialize()
], Node.prototype, "uniqueId", void 0);
__decorate([
  serialize()
], Node.prototype, "state", void 0);
__decorate([
  serialize()
], Node.prototype, "metadata", void 0);

// node_modules/@babylonjs/core/Maths/math.size.js
var Size = class {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }
  toString() {
    return `{W: ${this.width}, H: ${this.height}}`;
  }
  getClassName() {
    return "Size";
  }
  getHashCode() {
    let hash = this.width | 0;
    hash = hash * 397 ^ (this.height | 0);
    return hash;
  }
  copyFrom(src) {
    this.width = src.width;
    this.height = src.height;
  }
  copyFromFloats(width, height) {
    this.width = width;
    this.height = height;
    return this;
  }
  set(width, height) {
    return this.copyFromFloats(width, height);
  }
  multiplyByFloats(w, h) {
    return new Size(this.width * w, this.height * h);
  }
  clone() {
    return new Size(this.width, this.height);
  }
  equals(other) {
    if (!other) {
      return false;
    }
    return this.width === other.width && this.height === other.height;
  }
  get surface() {
    return this.width * this.height;
  }
  static Zero() {
    return new Size(0, 0);
  }
  add(otherSize) {
    const r = new Size(this.width + otherSize.width, this.height + otherSize.height);
    return r;
  }
  subtract(otherSize) {
    const r = new Size(this.width - otherSize.width, this.height - otherSize.height);
    return r;
  }
  static Lerp(start, end, amount) {
    const w = start.width + (end.width - start.width) * amount;
    const h = start.height + (end.height - start.height) * amount;
    return new Size(w, h);
  }
};

// node_modules/@babylonjs/core/Misc/webRequest.js
function createXMLHttpRequest() {
  if (typeof _native !== "undefined" && _native.XMLHttpRequest) {
    return new _native.XMLHttpRequest();
  } else {
    return new XMLHttpRequest();
  }
}
var WebRequest = class {
  constructor() {
    this._xhr = createXMLHttpRequest();
    this._requestURL = "";
  }
  _injectCustomRequestHeaders() {
    if (this._shouldSkipRequestModifications(this._requestURL)) {
      return;
    }
    for (const key in WebRequest.CustomRequestHeaders) {
      const val = WebRequest.CustomRequestHeaders[key];
      if (val) {
        this._xhr.setRequestHeader(key, val);
      }
    }
  }
  _shouldSkipRequestModifications(url) {
    return WebRequest.SkipRequestModificationForBabylonCDN && (url.includes("preview.babylonjs.com") || url.includes("cdn.babylonjs.com"));
  }
  get onprogress() {
    return this._xhr.onprogress;
  }
  set onprogress(value) {
    this._xhr.onprogress = value;
  }
  get readyState() {
    return this._xhr.readyState;
  }
  get status() {
    return this._xhr.status;
  }
  get statusText() {
    return this._xhr.statusText;
  }
  get response() {
    return this._xhr.response;
  }
  get responseURL() {
    return this._xhr.responseURL;
  }
  get responseText() {
    return this._xhr.responseText;
  }
  get responseType() {
    return this._xhr.responseType;
  }
  set responseType(value) {
    this._xhr.responseType = value;
  }
  get timeout() {
    return this._xhr.timeout;
  }
  set timeout(value) {
    this._xhr.timeout = value;
  }
  addEventListener(type, listener, options) {
    this._xhr.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    this._xhr.removeEventListener(type, listener, options);
  }
  abort() {
    this._xhr.abort();
  }
  send(body) {
    if (WebRequest.CustomRequestHeaders) {
      this._injectCustomRequestHeaders();
    }
    this._xhr.send(body);
  }
  open(method, url) {
    for (const update of WebRequest.CustomRequestModifiers) {
      if (this._shouldSkipRequestModifications(url)) {
        return;
      }
      update(this._xhr, url);
    }
    url = url.replace("file:http:", "http:");
    url = url.replace("file:https:", "https:");
    this._requestURL = url;
    return this._xhr.open(method, url, true);
  }
  setRequestHeader(name63, value) {
    this._xhr.setRequestHeader(name63, value);
  }
  getResponseHeader(name63) {
    return this._xhr.getResponseHeader(name63);
  }
};
WebRequest.CustomRequestHeaders = {};
WebRequest.CustomRequestModifiers = new Array();
WebRequest.SkipRequestModificationForBabylonCDN = true;

// node_modules/@babylonjs/core/Animations/animation.js
var _IAnimationState = class {
};
var Animation = class {
  constructor(name63, targetProperty, framePerSecond, dataType, loopMode, enableBlending) {
    this.name = name63;
    this.targetProperty = targetProperty;
    this.framePerSecond = framePerSecond;
    this.dataType = dataType;
    this.loopMode = loopMode;
    this.enableBlending = enableBlending;
    this._easingFunction = null;
    this._runtimeAnimations = new Array();
    this._events = new Array();
    this.blendingSpeed = 0.01;
    this._ranges = {};
    this.targetPropertyPath = targetProperty.split(".");
    this.dataType = dataType;
    this.loopMode = loopMode === void 0 ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;
    this.uniqueId = Animation._UniqueIdGenerator++;
  }
  static _PrepareAnimation(name63, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction) {
    let dataType = void 0;
    if (!isNaN(parseFloat(from)) && isFinite(from)) {
      dataType = Animation.ANIMATIONTYPE_FLOAT;
    } else if (from instanceof Quaternion) {
      dataType = Animation.ANIMATIONTYPE_QUATERNION;
    } else if (from instanceof Vector3) {
      dataType = Animation.ANIMATIONTYPE_VECTOR3;
    } else if (from instanceof Vector2) {
      dataType = Animation.ANIMATIONTYPE_VECTOR2;
    } else if (from instanceof Color3) {
      dataType = Animation.ANIMATIONTYPE_COLOR3;
    } else if (from instanceof Color4) {
      dataType = Animation.ANIMATIONTYPE_COLOR4;
    } else if (from instanceof Size) {
      dataType = Animation.ANIMATIONTYPE_SIZE;
    }
    if (dataType == void 0) {
      return null;
    }
    const animation = new Animation(name63, targetProperty, framePerSecond, dataType, loopMode);
    const keys = [
      { frame: 0, value: from },
      { frame: totalFrame, value: to }
    ];
    animation.setKeys(keys);
    if (easingFunction !== void 0) {
      animation.setEasingFunction(easingFunction);
    }
    return animation;
  }
  static CreateAnimation(property, animationType, framePerSecond, easingFunction) {
    const animation = new Animation(property + "Animation", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);
    animation.setEasingFunction(easingFunction);
    return animation;
  }
  static CreateAndStartAnimation(name63, target, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd, scene) {
    const animation = Animation._PrepareAnimation(name63, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
    if (!animation) {
      return null;
    }
    if (target.getScene) {
      scene = target.getScene();
    }
    if (!scene) {
      return null;
    }
    return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
  }
  static CreateAndStartHierarchyAnimation(name63, node, directDescendantsOnly, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {
    const animation = Animation._PrepareAnimation(name63, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
    if (!animation) {
      return null;
    }
    const scene = node.getScene();
    return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
  }
  static CreateMergeAndStartAnimation(name63, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {
    const animation = Animation._PrepareAnimation(name63, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
    if (!animation) {
      return null;
    }
    node.animations.push(animation);
    return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
  }
  static MakeAnimationAdditive(sourceAnimation, referenceFrame = 0, range, cloneOriginal = false, clonedName) {
    let animation = sourceAnimation;
    if (cloneOriginal) {
      animation = sourceAnimation.clone();
      animation.name = clonedName || animation.name;
    }
    if (!animation._keys.length) {
      return animation;
    }
    referenceFrame = referenceFrame >= 0 ? referenceFrame : 0;
    let startIndex = 0;
    const firstKey = animation._keys[0];
    let endIndex = animation._keys.length - 1;
    const lastKey = animation._keys[endIndex];
    const valueStore = {
      referenceValue: firstKey.value,
      referencePosition: TmpVectors.Vector3[0],
      referenceQuaternion: TmpVectors.Quaternion[0],
      referenceScaling: TmpVectors.Vector3[1],
      keyPosition: TmpVectors.Vector3[2],
      keyQuaternion: TmpVectors.Quaternion[1],
      keyScaling: TmpVectors.Vector3[3]
    };
    let referenceFound = false;
    let from = firstKey.frame;
    let to = lastKey.frame;
    if (range) {
      const rangeValue = animation.getRange(range);
      if (rangeValue) {
        from = rangeValue.from;
        to = rangeValue.to;
      }
    }
    let fromKeyFound = firstKey.frame === from;
    let toKeyFound = lastKey.frame === to;
    if (animation._keys.length === 1) {
      const value = animation._getKeyValue(animation._keys[0]);
      valueStore.referenceValue = value.clone ? value.clone() : value;
      referenceFound = true;
    } else if (referenceFrame <= firstKey.frame) {
      const value = animation._getKeyValue(firstKey.value);
      valueStore.referenceValue = value.clone ? value.clone() : value;
      referenceFound = true;
    } else if (referenceFrame >= lastKey.frame) {
      const value = animation._getKeyValue(lastKey.value);
      valueStore.referenceValue = value.clone ? value.clone() : value;
      referenceFound = true;
    }
    let index = 0;
    while (!referenceFound || !fromKeyFound || !toKeyFound && index < animation._keys.length - 1) {
      const currentKey = animation._keys[index];
      const nextKey = animation._keys[index + 1];
      if (!referenceFound && referenceFrame >= currentKey.frame && referenceFrame <= nextKey.frame) {
        let value;
        if (referenceFrame === currentKey.frame) {
          value = animation._getKeyValue(currentKey.value);
        } else if (referenceFrame === nextKey.frame) {
          value = animation._getKeyValue(nextKey.value);
        } else {
          const animationState = {
            key: index,
            repeatCount: 0,
            loopMode: this.ANIMATIONLOOPMODE_CONSTANT
          };
          value = animation._interpolate(referenceFrame, animationState);
        }
        valueStore.referenceValue = value.clone ? value.clone() : value;
        referenceFound = true;
      }
      if (!fromKeyFound && from >= currentKey.frame && from <= nextKey.frame) {
        if (from === currentKey.frame) {
          startIndex = index;
        } else if (from === nextKey.frame) {
          startIndex = index + 1;
        } else {
          const animationState = {
            key: index,
            repeatCount: 0,
            loopMode: this.ANIMATIONLOOPMODE_CONSTANT
          };
          const value = animation._interpolate(from, animationState);
          const key = {
            frame: from,
            value: value.clone ? value.clone() : value
          };
          animation._keys.splice(index + 1, 0, key);
          startIndex = index + 1;
        }
        fromKeyFound = true;
      }
      if (!toKeyFound && to >= currentKey.frame && to <= nextKey.frame) {
        if (to === currentKey.frame) {
          endIndex = index;
        } else if (to === nextKey.frame) {
          endIndex = index + 1;
        } else {
          const animationState = {
            key: index,
            repeatCount: 0,
            loopMode: this.ANIMATIONLOOPMODE_CONSTANT
          };
          const value = animation._interpolate(to, animationState);
          const key = {
            frame: to,
            value: value.clone ? value.clone() : value
          };
          animation._keys.splice(index + 1, 0, key);
          endIndex = index + 1;
        }
        toKeyFound = true;
      }
      index++;
    }
    if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {
      valueStore.referenceValue.normalize().conjugateInPlace();
    } else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {
      valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);
      valueStore.referenceQuaternion.normalize().conjugateInPlace();
    }
    for (index = startIndex; index <= endIndex; index++) {
      const key = animation._keys[index];
      if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {
        continue;
      }
      switch (animation.dataType) {
        case Animation.ANIMATIONTYPE_MATRIX:
          key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);
          valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);
          valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);
          valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);
          Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);
          break;
        case Animation.ANIMATIONTYPE_QUATERNION:
          valueStore.referenceValue.multiplyToRef(key.value, key.value);
          break;
        case Animation.ANIMATIONTYPE_VECTOR2:
        case Animation.ANIMATIONTYPE_VECTOR3:
        case Animation.ANIMATIONTYPE_COLOR3:
        case Animation.ANIMATIONTYPE_COLOR4:
          key.value.subtractToRef(valueStore.referenceValue, key.value);
          break;
        case Animation.ANIMATIONTYPE_SIZE:
          key.value.width -= valueStore.referenceValue.width;
          key.value.height -= valueStore.referenceValue.height;
          break;
        default:
          key.value -= valueStore.referenceValue;
      }
    }
    return animation;
  }
  static TransitionTo(property, targetValue, host, scene, frameRate, transition, duration, onAnimationEnd = null) {
    if (duration <= 0) {
      host[property] = targetValue;
      if (onAnimationEnd) {
        onAnimationEnd();
      }
      return null;
    }
    const endFrame = frameRate * (duration / 1e3);
    transition.setKeys([
      {
        frame: 0,
        value: host[property].clone ? host[property].clone() : host[property]
      },
      {
        frame: endFrame,
        value: targetValue
      }
    ]);
    if (!host.animations) {
      host.animations = [];
    }
    host.animations.push(transition);
    const animation = scene.beginAnimation(host, 0, endFrame, false);
    animation.onAnimationEnd = onAnimationEnd;
    return animation;
  }
  get runtimeAnimations() {
    return this._runtimeAnimations;
  }
  get hasRunningRuntimeAnimations() {
    for (const runtimeAnimation of this._runtimeAnimations) {
      if (!runtimeAnimation.isStopped()) {
        return true;
      }
    }
    return false;
  }
  toString(fullDetails) {
    let ret = "Name: " + this.name + ", property: " + this.targetProperty;
    ret += ", datatype: " + ["Float", "Vector3", "Quaternion", "Matrix", "Color3", "Vector2"][this.dataType];
    ret += ", nKeys: " + (this._keys ? this._keys.length : "none");
    ret += ", nRanges: " + (this._ranges ? Object.keys(this._ranges).length : "none");
    if (fullDetails) {
      ret += ", Ranges: {";
      let first = true;
      for (const name63 in this._ranges) {
        if (first) {
          ret += ", ";
          first = false;
        }
        ret += name63;
      }
      ret += "}";
    }
    return ret;
  }
  addEvent(event) {
    this._events.push(event);
    this._events.sort((a, b) => a.frame - b.frame);
  }
  removeEvents(frame) {
    for (let index = 0; index < this._events.length; index++) {
      if (this._events[index].frame === frame) {
        this._events.splice(index, 1);
        index--;
      }
    }
  }
  getEvents() {
    return this._events;
  }
  createRange(name63, from, to) {
    if (!this._ranges[name63]) {
      this._ranges[name63] = new AnimationRange(name63, from, to);
    }
  }
  deleteRange(name63, deleteFrames = true) {
    const range = this._ranges[name63];
    if (!range) {
      return;
    }
    if (deleteFrames) {
      const from = range.from;
      const to = range.to;
      for (let key = this._keys.length - 1; key >= 0; key--) {
        if (this._keys[key].frame >= from && this._keys[key].frame <= to) {
          this._keys.splice(key, 1);
        }
      }
    }
    this._ranges[name63] = null;
  }
  getRange(name63) {
    return this._ranges[name63];
  }
  getKeys() {
    return this._keys;
  }
  getHighestFrame() {
    let ret = 0;
    for (let key = 0, nKeys = this._keys.length; key < nKeys; key++) {
      if (ret < this._keys[key].frame) {
        ret = this._keys[key].frame;
      }
    }
    return ret;
  }
  getEasingFunction() {
    return this._easingFunction;
  }
  setEasingFunction(easingFunction) {
    this._easingFunction = easingFunction;
  }
  floatInterpolateFunction(startValue, endValue, gradient) {
    return Scalar.Lerp(startValue, endValue, gradient);
  }
  floatInterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  }
  quaternionInterpolateFunction(startValue, endValue, gradient) {
    return Quaternion.Slerp(startValue, endValue, gradient);
  }
  quaternionInterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();
  }
  vector3InterpolateFunction(startValue, endValue, gradient) {
    return Vector3.Lerp(startValue, endValue, gradient);
  }
  vector3InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  }
  vector2InterpolateFunction(startValue, endValue, gradient) {
    return Vector2.Lerp(startValue, endValue, gradient);
  }
  vector2InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  }
  sizeInterpolateFunction(startValue, endValue, gradient) {
    return Size.Lerp(startValue, endValue, gradient);
  }
  color3InterpolateFunction(startValue, endValue, gradient) {
    return Color3.Lerp(startValue, endValue, gradient);
  }
  color3InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  }
  color4InterpolateFunction(startValue, endValue, gradient) {
    return Color4.Lerp(startValue, endValue, gradient);
  }
  color4InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  }
  _getKeyValue(value) {
    if (typeof value === "function") {
      return value();
    }
    return value;
  }
  evaluate(currentFrame) {
    return this._interpolate(currentFrame, {
      key: 0,
      repeatCount: 0,
      loopMode: Animation.ANIMATIONLOOPMODE_CONSTANT
    });
  }
  _interpolate(currentFrame, state) {
    if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {
      return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;
    }
    const keys = this._keys;
    const keysLength = keys.length;
    let key = state.key;
    while (key >= 0 && currentFrame < keys[key].frame) {
      --key;
    }
    while (key + 1 <= keysLength - 1 && currentFrame >= keys[key + 1].frame) {
      ++key;
    }
    state.key = key;
    if (key < 0) {
      return this._getKeyValue(keys[0].value);
    } else if (key + 1 > keysLength - 1) {
      return this._getKeyValue(keys[keysLength - 1].value);
    }
    const startKey = keys[key];
    const endKey = keys[key + 1];
    const startValue = this._getKeyValue(startKey.value);
    const endValue = this._getKeyValue(endKey.value);
    if (startKey.interpolation === AnimationKeyInterpolation.STEP) {
      if (endKey.frame > currentFrame) {
        return startValue;
      } else {
        return endValue;
      }
    }
    const useTangent = startKey.outTangent !== void 0 && endKey.inTangent !== void 0;
    const frameDelta = endKey.frame - startKey.frame;
    let gradient = (currentFrame - startKey.frame) / frameDelta;
    const easingFunction = this.getEasingFunction();
    if (easingFunction !== null) {
      gradient = easingFunction.ease(gradient);
    }
    switch (this.dataType) {
      case Animation.ANIMATIONTYPE_FLOAT: {
        const floatValue = useTangent ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient) : this.floatInterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case Animation.ANIMATIONLOOPMODE_CYCLE:
          case Animation.ANIMATIONLOOPMODE_CONSTANT:
            return floatValue;
          case Animation.ANIMATIONLOOPMODE_RELATIVE:
            return state.offsetValue * state.repeatCount + floatValue;
        }
        break;
      }
      case Animation.ANIMATIONTYPE_QUATERNION: {
        const quatValue = useTangent ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.quaternionInterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case Animation.ANIMATIONLOOPMODE_CYCLE:
          case Animation.ANIMATIONLOOPMODE_CONSTANT:
            return quatValue;
          case Animation.ANIMATIONLOOPMODE_RELATIVE:
            return quatValue.addInPlace(state.offsetValue.scale(state.repeatCount));
        }
        return quatValue;
      }
      case Animation.ANIMATIONTYPE_VECTOR3: {
        const vec3Value = useTangent ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector3InterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case Animation.ANIMATIONLOOPMODE_CYCLE:
          case Animation.ANIMATIONLOOPMODE_CONSTANT:
            return vec3Value;
          case Animation.ANIMATIONLOOPMODE_RELATIVE:
            return vec3Value.add(state.offsetValue.scale(state.repeatCount));
        }
        break;
      }
      case Animation.ANIMATIONTYPE_VECTOR2: {
        const vec2Value = useTangent ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector2InterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case Animation.ANIMATIONLOOPMODE_CYCLE:
          case Animation.ANIMATIONLOOPMODE_CONSTANT:
            return vec2Value;
          case Animation.ANIMATIONLOOPMODE_RELATIVE:
            return vec2Value.add(state.offsetValue.scale(state.repeatCount));
        }
        break;
      }
      case Animation.ANIMATIONTYPE_SIZE: {
        switch (state.loopMode) {
          case Animation.ANIMATIONLOOPMODE_CYCLE:
          case Animation.ANIMATIONLOOPMODE_CONSTANT:
            return this.sizeInterpolateFunction(startValue, endValue, gradient);
          case Animation.ANIMATIONLOOPMODE_RELATIVE:
            return this.sizeInterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));
        }
        break;
      }
      case Animation.ANIMATIONTYPE_COLOR3: {
        const color3Value = useTangent ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color3InterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case Animation.ANIMATIONLOOPMODE_CYCLE:
          case Animation.ANIMATIONLOOPMODE_CONSTANT:
            return color3Value;
          case Animation.ANIMATIONLOOPMODE_RELATIVE:
            return color3Value.add(state.offsetValue.scale(state.repeatCount));
        }
        break;
      }
      case Animation.ANIMATIONTYPE_COLOR4: {
        const color4Value = useTangent ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color4InterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case Animation.ANIMATIONLOOPMODE_CYCLE:
          case Animation.ANIMATIONLOOPMODE_CONSTANT:
            return color4Value;
          case Animation.ANIMATIONLOOPMODE_RELATIVE:
            return color4Value.add(state.offsetValue.scale(state.repeatCount));
        }
        break;
      }
      case Animation.ANIMATIONTYPE_MATRIX: {
        switch (state.loopMode) {
          case Animation.ANIMATIONLOOPMODE_CYCLE:
          case Animation.ANIMATIONLOOPMODE_CONSTANT: {
            if (Animation.AllowMatricesInterpolation) {
              return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);
            }
            return startValue;
          }
          case Animation.ANIMATIONLOOPMODE_RELATIVE: {
            return startValue;
          }
        }
        break;
      }
    }
    return 0;
  }
  matrixInterpolateFunction(startValue, endValue, gradient, result) {
    if (Animation.AllowMatrixDecomposeForInterpolation) {
      if (result) {
        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);
        return result;
      }
      return Matrix.DecomposeLerp(startValue, endValue, gradient);
    }
    if (result) {
      Matrix.LerpToRef(startValue, endValue, gradient, result);
      return result;
    }
    return Matrix.Lerp(startValue, endValue, gradient);
  }
  clone() {
    const clone = new Animation(this.name, this.targetPropertyPath.join("."), this.framePerSecond, this.dataType, this.loopMode);
    clone.enableBlending = this.enableBlending;
    clone.blendingSpeed = this.blendingSpeed;
    if (this._keys) {
      clone.setKeys(this._keys);
    }
    if (this._ranges) {
      clone._ranges = {};
      for (const name63 in this._ranges) {
        const range = this._ranges[name63];
        if (!range) {
          continue;
        }
        clone._ranges[name63] = range.clone();
      }
    }
    return clone;
  }
  setKeys(values) {
    this._keys = values.slice(0);
  }
  serialize() {
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.property = this.targetProperty;
    serializationObject.framePerSecond = this.framePerSecond;
    serializationObject.dataType = this.dataType;
    serializationObject.loopBehavior = this.loopMode;
    serializationObject.enableBlending = this.enableBlending;
    serializationObject.blendingSpeed = this.blendingSpeed;
    const dataType = this.dataType;
    serializationObject.keys = [];
    const keys = this.getKeys();
    for (let index = 0; index < keys.length; index++) {
      const animationKey = keys[index];
      const key = {};
      key.frame = animationKey.frame;
      switch (dataType) {
        case Animation.ANIMATIONTYPE_FLOAT:
          key.values = [animationKey.value];
          if (animationKey.inTangent !== void 0) {
            key.values.push(animationKey.inTangent);
          }
          if (animationKey.outTangent !== void 0) {
            if (animationKey.inTangent === void 0) {
              key.values.push(void 0);
            }
            key.values.push(animationKey.outTangent);
          }
          if (animationKey.interpolation !== void 0) {
            if (animationKey.inTangent === void 0) {
              key.values.push(void 0);
            }
            if (animationKey.outTangent === void 0) {
              key.values.push(void 0);
            }
            key.values.push(animationKey.interpolation);
          }
          break;
        case Animation.ANIMATIONTYPE_QUATERNION:
        case Animation.ANIMATIONTYPE_MATRIX:
        case Animation.ANIMATIONTYPE_VECTOR3:
        case Animation.ANIMATIONTYPE_COLOR3:
        case Animation.ANIMATIONTYPE_COLOR4:
          key.values = animationKey.value.asArray();
          if (animationKey.inTangent != void 0) {
            key.values.push(animationKey.inTangent.asArray());
          }
          if (animationKey.outTangent != void 0) {
            if (animationKey.inTangent === void 0) {
              key.values.push(void 0);
            }
            key.values.push(animationKey.outTangent.asArray());
          }
          if (animationKey.interpolation !== void 0) {
            if (animationKey.inTangent === void 0) {
              key.values.push(void 0);
            }
            if (animationKey.outTangent === void 0) {
              key.values.push(void 0);
            }
            key.values.push(animationKey.interpolation);
          }
          break;
      }
      serializationObject.keys.push(key);
    }
    serializationObject.ranges = [];
    for (const name63 in this._ranges) {
      const source = this._ranges[name63];
      if (!source) {
        continue;
      }
      const range = {};
      range.name = name63;
      range.from = source.from;
      range.to = source.to;
      serializationObject.ranges.push(range);
    }
    return serializationObject;
  }
  static _UniversalLerp(left, right, amount) {
    const constructor = left.constructor;
    if (constructor.Lerp) {
      return constructor.Lerp(left, right, amount);
    } else if (constructor.Slerp) {
      return constructor.Slerp(left, right, amount);
    } else if (left.toFixed) {
      return left * (1 - amount) + amount * right;
    } else {
      return right;
    }
  }
  static Parse(parsedAnimation) {
    const animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);
    const dataType = parsedAnimation.dataType;
    const keys = [];
    let data;
    let index;
    if (parsedAnimation.enableBlending) {
      animation.enableBlending = parsedAnimation.enableBlending;
    }
    if (parsedAnimation.blendingSpeed) {
      animation.blendingSpeed = parsedAnimation.blendingSpeed;
    }
    for (index = 0; index < parsedAnimation.keys.length; index++) {
      const key = parsedAnimation.keys[index];
      let inTangent = void 0;
      let outTangent = void 0;
      let interpolation = void 0;
      switch (dataType) {
        case Animation.ANIMATIONTYPE_FLOAT:
          data = key.values[0];
          if (key.values.length >= 2) {
            inTangent = key.values[1];
          }
          if (key.values.length >= 3) {
            outTangent = key.values[2];
          }
          if (key.values.length >= 4) {
            interpolation = key.values[3];
          }
          break;
        case Animation.ANIMATIONTYPE_QUATERNION:
          data = Quaternion.FromArray(key.values);
          if (key.values.length >= 8) {
            const _inTangent = Quaternion.FromArray(key.values.slice(4, 8));
            if (!_inTangent.equals(Quaternion.Zero())) {
              inTangent = _inTangent;
            }
          }
          if (key.values.length >= 12) {
            const _outTangent = Quaternion.FromArray(key.values.slice(8, 12));
            if (!_outTangent.equals(Quaternion.Zero())) {
              outTangent = _outTangent;
            }
          }
          if (key.values.length >= 13) {
            interpolation = key.values[12];
          }
          break;
        case Animation.ANIMATIONTYPE_MATRIX:
          data = Matrix.FromArray(key.values);
          if (key.values.length >= 17) {
            interpolation = key.values[16];
          }
          break;
        case Animation.ANIMATIONTYPE_COLOR3:
          data = Color3.FromArray(key.values);
          if (key.values[3]) {
            inTangent = Color3.FromArray(key.values[3]);
          }
          if (key.values[4]) {
            outTangent = Color3.FromArray(key.values[4]);
          }
          if (key.values[5]) {
            interpolation = key.values[5];
          }
          break;
        case Animation.ANIMATIONTYPE_COLOR4:
          data = Color4.FromArray(key.values);
          if (key.values[4]) {
            inTangent = Color4.FromArray(key.values[4]);
          }
          if (key.values[5]) {
            outTangent = Color4.FromArray(key.values[5]);
          }
          if (key.values[6]) {
            interpolation = Color4.FromArray(key.values[6]);
          }
          break;
        case Animation.ANIMATIONTYPE_VECTOR3:
        default:
          data = Vector3.FromArray(key.values);
          if (key.values[3]) {
            inTangent = Vector3.FromArray(key.values[3]);
          }
          if (key.values[4]) {
            outTangent = Vector3.FromArray(key.values[4]);
          }
          if (key.values[5]) {
            interpolation = key.values[5];
          }
          break;
      }
      const keyData = {};
      keyData.frame = key.frame;
      keyData.value = data;
      if (inTangent != void 0) {
        keyData.inTangent = inTangent;
      }
      if (outTangent != void 0) {
        keyData.outTangent = outTangent;
      }
      if (interpolation != void 0) {
        keyData.interpolation = interpolation;
      }
      keys.push(keyData);
    }
    animation.setKeys(keys);
    if (parsedAnimation.ranges) {
      for (index = 0; index < parsedAnimation.ranges.length; index++) {
        data = parsedAnimation.ranges[index];
        animation.createRange(data.name, data.from, data.to);
      }
    }
    return animation;
  }
  static AppendSerializedAnimations(source, destination) {
    SerializationHelper.AppendSerializedAnimations(source, destination);
  }
  static ParseFromFileAsync(name63, url) {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            let serializationObject = JSON.parse(request.responseText);
            if (serializationObject.animations) {
              serializationObject = serializationObject.animations;
            }
            if (serializationObject.length) {
              const output = new Array();
              for (const serializedAnimation of serializationObject) {
                output.push(this.Parse(serializedAnimation));
              }
              resolve(output);
            } else {
              const output = this.Parse(serializationObject);
              if (name63) {
                output.name = name63;
              }
              resolve(output);
            }
          } else {
            reject("Unable to load the animation");
          }
        }
      });
      request.open("GET", url);
      request.send();
    });
  }
  static ParseFromSnippetAsync(snippetId) {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            if (snippet.animations) {
              const serializationObject = JSON.parse(snippet.animations);
              const outputs = new Array();
              for (const serializedAnimation of serializationObject.animations) {
                const output = this.Parse(serializedAnimation);
                output.snippetId = snippetId;
                outputs.push(output);
              }
              resolve(outputs);
            } else {
              const serializationObject = JSON.parse(snippet.animation);
              const output = this.Parse(serializationObject);
              output.snippetId = snippetId;
              resolve(output);
            }
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  }
};
Animation._UniqueIdGenerator = 0;
Animation.AllowMatricesInterpolation = false;
Animation.AllowMatrixDecomposeForInterpolation = true;
Animation.SnippetUrl = `https://snippet.babylonjs.com`;
Animation.ANIMATIONTYPE_FLOAT = 0;
Animation.ANIMATIONTYPE_VECTOR3 = 1;
Animation.ANIMATIONTYPE_QUATERNION = 2;
Animation.ANIMATIONTYPE_MATRIX = 3;
Animation.ANIMATIONTYPE_COLOR3 = 4;
Animation.ANIMATIONTYPE_COLOR4 = 7;
Animation.ANIMATIONTYPE_VECTOR2 = 5;
Animation.ANIMATIONTYPE_SIZE = 6;
Animation.ANIMATIONLOOPMODE_RELATIVE = 0;
Animation.ANIMATIONLOOPMODE_CYCLE = 1;
Animation.ANIMATIONLOOPMODE_CONSTANT = 2;
Animation.CreateFromSnippetAsync = Animation.ParseFromSnippetAsync;
RegisterClass("BABYLON.Animation", Animation);
Node._AnimationRangeFactory = (name63, from, to) => new AnimationRange(name63, from, to);

// node_modules/@babylonjs/core/Misc/domManagement.js
function IsWindowObjectExist() {
  return typeof window !== "undefined";
}
function IsNavigatorAvailable() {
  return typeof navigator !== "undefined";
}
function IsDocumentAvailable() {
  return typeof document !== "undefined";
}
function GetDOMTextContent(element) {
  let result = "";
  let child = element.firstChild;
  while (child) {
    if (child.nodeType === 3) {
      result += child.textContent;
    }
    child = child.nextSibling;
  }
  return result;
}
var DomManagement = {
  IsWindowObjectExist,
  IsNavigatorAvailable,
  IsDocumentAvailable,
  GetDOMTextContent
};

// node_modules/@babylonjs/core/Misc/precisionDate.js
var PrecisionDate = class {
  static get Now() {
    if (DomManagement.IsWindowObjectExist() && window.performance && window.performance.now) {
      return window.performance.now();
    }
    return Date.now();
  }
};

// node_modules/@babylonjs/core/Misc/filesInputStore.js
var FilesInputStore = class {
};
FilesInputStore.FilesToLoad = {};

// node_modules/@babylonjs/core/Misc/retryStrategy.js
var RetryStrategy = class {
  static ExponentialBackoff(maxRetries = 3, baseInterval = 500) {
    return (url, request, retryIndex) => {
      if (request.status !== 0 || retryIndex >= maxRetries || url.indexOf("file:") !== -1) {
        return -1;
      }
      return Math.pow(2, retryIndex) * baseInterval;
    };
  }
};

// node_modules/@babylonjs/core/Misc/error.js
var BaseError = class extends Error {
};
BaseError._setPrototypeOf = Object.setPrototypeOf || ((o, proto) => {
  o.__proto__ = proto;
  return o;
});
var ErrorCodes = {
  MeshInvalidPositionsError: 0,
  UnsupportedTextureError: 1e3,
  GLTFLoaderUnexpectedMagicError: 2e3,
  SceneLoaderError: 3e3,
  LoadFileError: 4e3,
  RequestFileError: 4001,
  ReadFileError: 4002
};
var RuntimeError = class extends BaseError {
  constructor(message, errorCode, innerError) {
    super(message);
    this.errorCode = errorCode;
    this.innerError = innerError;
    this.name = "RuntimeError";
    BaseError._setPrototypeOf(this, RuntimeError.prototype);
  }
};

// node_modules/@babylonjs/core/Misc/stringTools.js
var EndsWith = (str, suffix) => {
  return str.endsWith(suffix);
};
var StartsWith = (str, suffix) => {
  if (!str) {
    return false;
  }
  return str.startsWith(suffix);
};
var Decode = (buffer) => {
  if (typeof TextDecoder !== "undefined") {
    return new TextDecoder().decode(buffer);
  }
  let result = "";
  for (let i = 0; i < buffer.byteLength; i++) {
    result += String.fromCharCode(buffer[i]);
  }
  return result;
};
var EncodeArrayBufferToBase64 = (buffer) => {
  const keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let output = "";
  let chr1, chr2, chr3, enc1, enc2, enc3, enc4;
  let i = 0;
  const bytes = ArrayBuffer.isView(buffer) ? new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength) : new Uint8Array(buffer);
  while (i < bytes.length) {
    chr1 = bytes[i++];
    chr2 = i < bytes.length ? bytes[i++] : Number.NaN;
    chr3 = i < bytes.length ? bytes[i++] : Number.NaN;
    enc1 = chr1 >> 2;
    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    enc3 = (chr2 & 15) << 2 | chr3 >> 6;
    enc4 = chr3 & 63;
    if (isNaN(chr2)) {
      enc3 = enc4 = 64;
    } else if (isNaN(chr3)) {
      enc4 = 64;
    }
    output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
  }
  return output;
};
var DecodeBase64ToString = (base64Data) => {
  return atob(base64Data);
};
var DecodeBase64ToBinary = (base64Data) => {
  const decodedString = DecodeBase64ToString(base64Data);
  const bufferLength = decodedString.length;
  const bufferView = new Uint8Array(new ArrayBuffer(bufferLength));
  for (let i = 0; i < bufferLength; i++) {
    bufferView[i] = decodedString.charCodeAt(i);
  }
  return bufferView.buffer;
};
var PadNumber = (num, length) => {
  let str = String(num);
  while (str.length < length) {
    str = "0" + str;
  }
  return str;
};
var StringTools = {
  EndsWith,
  StartsWith,
  Decode,
  EncodeArrayBufferToBase64,
  DecodeBase64ToString,
  DecodeBase64ToBinary,
  PadNumber
};

// node_modules/@babylonjs/core/Materials/shaderLanguage.js
var ShaderLanguage;
(function(ShaderLanguage2) {
  ShaderLanguage2[ShaderLanguage2["GLSL"] = 0] = "GLSL";
  ShaderLanguage2[ShaderLanguage2["WGSL"] = 1] = "WGSL";
})(ShaderLanguage || (ShaderLanguage = {}));

// node_modules/@babylonjs/core/Engines/shaderStore.js
var ShaderStore = class {
  static GetShadersRepository(shaderLanguage = ShaderLanguage.GLSL) {
    return shaderLanguage === ShaderLanguage.GLSL ? ShaderStore.ShadersRepository : ShaderStore.ShadersRepositoryWGSL;
  }
  static GetShadersStore(shaderLanguage = ShaderLanguage.GLSL) {
    return shaderLanguage === ShaderLanguage.GLSL ? ShaderStore.ShadersStore : ShaderStore.ShadersStoreWGSL;
  }
  static GetIncludesShadersStore(shaderLanguage = ShaderLanguage.GLSL) {
    return shaderLanguage === ShaderLanguage.GLSL ? ShaderStore.IncludesShadersStore : ShaderStore.IncludesShadersStoreWGSL;
  }
};
ShaderStore.ShadersRepository = "src/Shaders/";
ShaderStore.ShadersStore = {};
ShaderStore.IncludesShadersStore = {};
ShaderStore.ShadersRepositoryWGSL = "src/ShadersWGSL/";
ShaderStore.ShadersStoreWGSL = {};
ShaderStore.IncludesShadersStoreWGSL = {};

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeNode.js
var defaultAttributeKeywordName = "attribute";
var defaultVaryingKeywordName = "varying";
var ShaderCodeNode = class {
  constructor() {
    this.children = [];
  }
  isValid(preprocessors) {
    return true;
  }
  process(preprocessors, options) {
    var _a, _b, _c, _d, _e, _f;
    let result = "";
    if (this.line) {
      let value = this.line;
      const processor = options.processor;
      if (processor) {
        if (processor.lineProcessor) {
          value = processor.lineProcessor(value, options.isFragment, options.processingContext);
        }
        const attributeKeyword = (_b = (_a = options.processor) === null || _a === void 0 ? void 0 : _a.attributeKeywordName) !== null && _b !== void 0 ? _b : defaultAttributeKeywordName;
        const varyingKeyword = options.isFragment && ((_c = options.processor) === null || _c === void 0 ? void 0 : _c.varyingFragmentKeywordName) ? (_d = options.processor) === null || _d === void 0 ? void 0 : _d.varyingFragmentKeywordName : !options.isFragment && ((_e = options.processor) === null || _e === void 0 ? void 0 : _e.varyingVertexKeywordName) ? (_f = options.processor) === null || _f === void 0 ? void 0 : _f.varyingVertexKeywordName : defaultVaryingKeywordName;
        if (!options.isFragment && processor.attributeProcessor && this.line.startsWith(attributeKeyword)) {
          value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);
        } else if (processor.varyingProcessor && this.line.startsWith(varyingKeyword)) {
          value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
        } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {
          if (!options.lookForClosingBracketForUniformBuffer) {
            value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
          }
        } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {
          if (!options.lookForClosingBracketForUniformBuffer) {
            value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);
            options.lookForClosingBracketForUniformBuffer = true;
          }
        } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {
          value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
        } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && this.line.startsWith("uniform") && !options.lookForClosingBracketForUniformBuffer) {
          const regex = /uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/;
          if (regex.test(this.line)) {
            if (processor.uniformProcessor) {
              value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
            }
          } else {
            if (processor.uniformBufferProcessor) {
              value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);
              options.lookForClosingBracketForUniformBuffer = true;
            }
          }
        }
        if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf("}") !== -1) {
          options.lookForClosingBracketForUniformBuffer = false;
          if (processor.endOfUniformBufferProcessor) {
            value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);
          }
        }
      }
      result += value + "\r\n";
    }
    this.children.forEach((child) => {
      result += child.process(preprocessors, options);
    });
    if (this.additionalDefineKey) {
      preprocessors[this.additionalDefineKey] = this.additionalDefineValue || "true";
    }
    return result;
  }
};

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeCursor.js
var ShaderCodeCursor = class {
  constructor() {
    this._lines = [];
  }
  get currentLine() {
    return this._lines[this.lineIndex];
  }
  get canRead() {
    return this.lineIndex < this._lines.length - 1;
  }
  set lines(value) {
    this._lines.length = 0;
    for (const line of value) {
      if (line[0] === "#") {
        this._lines.push(line);
        continue;
      }
      if (line.trim().startsWith("//")) {
        this._lines.push(line);
        continue;
      }
      const split = line.split(";");
      for (let index = 0; index < split.length; index++) {
        let subLine = split[index];
        subLine = subLine.trim();
        if (!subLine) {
          continue;
        }
        this._lines.push(subLine + (index !== split.length - 1 ? ";" : ""));
      }
    }
  }
};

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeConditionNode.js
var ShaderCodeConditionNode = class extends ShaderCodeNode {
  process(preprocessors, options) {
    for (let index = 0; index < this.children.length; index++) {
      const node = this.children[index];
      if (node.isValid(preprocessors)) {
        return node.process(preprocessors, options);
      }
    }
    return "";
  }
};

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeTestNode.js
var ShaderCodeTestNode = class extends ShaderCodeNode {
  isValid(preprocessors) {
    return this.testExpression.isTrue(preprocessors);
  }
};

// node_modules/@babylonjs/core/Engines/Processors/Expressions/shaderDefineExpression.js
var ShaderDefineExpression = class {
  isTrue(preprocessors) {
    return true;
  }
  static postfixToInfix(postfix) {
    const stack = [];
    for (const c of postfix) {
      if (ShaderDefineExpression._OperatorPriority[c] === void 0) {
        stack.push(c);
      } else {
        const v1 = stack[stack.length - 1], v2 = stack[stack.length - 2];
        stack.length -= 2;
        stack.push(`(${v2}${c}${v1})`);
      }
    }
    return stack[stack.length - 1];
  }
  static infixToPostfix(infix) {
    const result = [];
    let stackIdx = -1;
    const pushOperand = () => {
      operand = operand.trim();
      if (operand !== "") {
        result.push(operand);
        operand = "";
      }
    };
    const push = (s) => {
      if (stackIdx < ShaderDefineExpression._Stack.length - 1) {
        ShaderDefineExpression._Stack[++stackIdx] = s;
      }
    };
    const peek = () => ShaderDefineExpression._Stack[stackIdx];
    const pop = () => stackIdx === -1 ? "!!INVALID EXPRESSION!!" : ShaderDefineExpression._Stack[stackIdx--];
    let idx = 0, operand = "";
    while (idx < infix.length) {
      const c = infix.charAt(idx), token = idx < infix.length - 1 ? infix.substr(idx, 2) : "";
      if (c === "(") {
        operand = "";
        push(c);
      } else if (c === ")") {
        pushOperand();
        while (stackIdx !== -1 && peek() !== "(") {
          result.push(pop());
        }
        pop();
      } else if (ShaderDefineExpression._OperatorPriority[token] > 1) {
        pushOperand();
        while (stackIdx !== -1 && ShaderDefineExpression._OperatorPriority[peek()] >= ShaderDefineExpression._OperatorPriority[token]) {
          result.push(pop());
        }
        push(token);
        idx++;
      } else {
        operand += c;
      }
      idx++;
    }
    pushOperand();
    while (stackIdx !== -1) {
      if (peek() === "(") {
        pop();
      } else {
        result.push(pop());
      }
    }
    return result;
  }
};
ShaderDefineExpression._OperatorPriority = {
  ")": 0,
  "(": 1,
  "||": 2,
  "&&": 3
};
ShaderDefineExpression._Stack = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineIsDefinedOperator.js
var ShaderDefineIsDefinedOperator = class extends ShaderDefineExpression {
  constructor(define, not = false) {
    super();
    this.define = define;
    this.not = not;
  }
  isTrue(preprocessors) {
    let condition = preprocessors[this.define] !== void 0;
    if (this.not) {
      condition = !condition;
    }
    return condition;
  }
};

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineOrOperator.js
var ShaderDefineOrOperator = class extends ShaderDefineExpression {
  isTrue(preprocessors) {
    return this.leftOperand.isTrue(preprocessors) || this.rightOperand.isTrue(preprocessors);
  }
};

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineAndOperator.js
var ShaderDefineAndOperator = class extends ShaderDefineExpression {
  isTrue(preprocessors) {
    return this.leftOperand.isTrue(preprocessors) && this.rightOperand.isTrue(preprocessors);
  }
};

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineArithmeticOperator.js
var ShaderDefineArithmeticOperator = class extends ShaderDefineExpression {
  constructor(define, operand, testValue) {
    super();
    this.define = define;
    this.operand = operand;
    this.testValue = testValue;
  }
  isTrue(preprocessors) {
    let value = preprocessors[this.define];
    if (value === void 0) {
      value = this.define;
    }
    let condition = false;
    const left = parseInt(value);
    const right = parseInt(this.testValue);
    switch (this.operand) {
      case ">":
        condition = left > right;
        break;
      case "<":
        condition = left < right;
        break;
      case "<=":
        condition = left <= right;
        break;
      case ">=":
        condition = left >= right;
        break;
      case "==":
        condition = left === right;
        break;
    }
    return condition;
  }
};

// node_modules/@babylonjs/core/Engines/Processors/shaderProcessor.js
var regexSE = /defined\s*?\((.+?)\)/g;
var regexSERevert = /defined\s*?\[(.+?)\]/g;
var regexShaderInclude = /#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g;
var ShaderProcessor = class {
  static Initialize(options) {
    if (options.processor && options.processor.initializeShaders) {
      options.processor.initializeShaders(options.processingContext);
    }
  }
  static Process(sourceCode, options, callback, engine) {
    var _a;
    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessShaderCode) {
      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);
    }
    this._ProcessIncludes(sourceCode, options, (codeWithIncludes) => {
      if (options.processCodeAfterIncludes) {
        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? "fragment" : "vertex", codeWithIncludes);
      }
      const migratedCode = this._ProcessShaderConversion(codeWithIncludes, options, engine);
      callback(migratedCode, codeWithIncludes);
    });
  }
  static PreProcess(sourceCode, options, callback, engine) {
    var _a;
    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessShaderCode) {
      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);
    }
    this._ProcessIncludes(sourceCode, options, (codeWithIncludes) => {
      if (options.processCodeAfterIncludes) {
        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? "fragment" : "vertex", codeWithIncludes);
      }
      const migratedCode = this._ApplyPreProcessing(codeWithIncludes, options, engine);
      callback(migratedCode, codeWithIncludes);
    });
  }
  static Finalize(vertexCode, fragmentCode, options) {
    if (!options.processor || !options.processor.finalizeShaders) {
      return { vertexCode, fragmentCode };
    }
    return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);
  }
  static _ProcessPrecision(source, options) {
    var _a;
    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.noPrecision) {
      return source;
    }
    const shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;
    if (source.indexOf("precision highp float") === -1) {
      if (!shouldUseHighPrecisionShader) {
        source = "precision mediump float;\n" + source;
      } else {
        source = "precision highp float;\n" + source;
      }
    } else {
      if (!shouldUseHighPrecisionShader) {
        source = source.replace("precision highp float", "precision mediump float");
      }
    }
    return source;
  }
  static _ExtractOperation(expression) {
    const regex = /defined\((.+)\)/;
    const match = regex.exec(expression);
    if (match && match.length) {
      return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === "!");
    }
    const operators = ["==", ">=", "<=", "<", ">"];
    let operator = "";
    let indexOperator = 0;
    for (operator of operators) {
      indexOperator = expression.indexOf(operator);
      if (indexOperator > -1) {
        break;
      }
    }
    if (indexOperator === -1) {
      return new ShaderDefineIsDefinedOperator(expression);
    }
    const define = expression.substring(0, indexOperator).trim();
    const value = expression.substring(indexOperator + operator.length).trim();
    return new ShaderDefineArithmeticOperator(define, operator, value);
  }
  static _BuildSubExpression(expression) {
    expression = expression.replace(regexSE, "defined[$1]");
    const postfix = ShaderDefineExpression.infixToPostfix(expression);
    const stack = [];
    for (const c of postfix) {
      if (c !== "||" && c !== "&&") {
        stack.push(c);
      } else if (stack.length >= 2) {
        let v1 = stack[stack.length - 1], v2 = stack[stack.length - 2];
        stack.length -= 2;
        const operator = c == "&&" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();
        if (typeof v1 === "string") {
          v1 = v1.replace(regexSERevert, "defined($1)");
        }
        if (typeof v2 === "string") {
          v2 = v2.replace(regexSERevert, "defined($1)");
        }
        operator.leftOperand = typeof v2 === "string" ? this._ExtractOperation(v2) : v2;
        operator.rightOperand = typeof v1 === "string" ? this._ExtractOperation(v1) : v1;
        stack.push(operator);
      }
    }
    let result = stack[stack.length - 1];
    if (typeof result === "string") {
      result = result.replace(regexSERevert, "defined($1)");
    }
    return typeof result === "string" ? this._ExtractOperation(result) : result;
  }
  static _BuildExpression(line, start) {
    const node = new ShaderCodeTestNode();
    const command = line.substring(0, start);
    let expression = line.substring(start);
    expression = expression.substring(0, (expression.indexOf("//") + 1 || expression.length + 1) - 1).trim();
    if (command === "#ifdef") {
      node.testExpression = new ShaderDefineIsDefinedOperator(expression);
    } else if (command === "#ifndef") {
      node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);
    } else {
      node.testExpression = this._BuildSubExpression(expression);
    }
    return node;
  }
  static _MoveCursorWithinIf(cursor, rootNode, ifNode) {
    let line = cursor.currentLine;
    while (this._MoveCursor(cursor, ifNode)) {
      line = cursor.currentLine;
      const first5 = line.substring(0, 5).toLowerCase();
      if (first5 === "#else") {
        const elseNode = new ShaderCodeNode();
        rootNode.children.push(elseNode);
        this._MoveCursor(cursor, elseNode);
        return;
      } else if (first5 === "#elif") {
        const elifNode = this._BuildExpression(line, 5);
        rootNode.children.push(elifNode);
        ifNode = elifNode;
      }
    }
  }
  static _MoveCursor(cursor, rootNode) {
    while (cursor.canRead) {
      cursor.lineIndex++;
      const line = cursor.currentLine;
      const keywords = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;
      const matches = keywords.exec(line);
      if (matches && matches.length) {
        const keyword = matches[0];
        switch (keyword) {
          case "#ifdef": {
            const newRootNode = new ShaderCodeConditionNode();
            rootNode.children.push(newRootNode);
            const ifNode = this._BuildExpression(line, 6);
            newRootNode.children.push(ifNode);
            this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
            break;
          }
          case "#else":
          case "#elif":
            return true;
          case "#endif":
            return false;
          case "#ifndef": {
            const newRootNode = new ShaderCodeConditionNode();
            rootNode.children.push(newRootNode);
            const ifNode = this._BuildExpression(line, 7);
            newRootNode.children.push(ifNode);
            this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
            break;
          }
          case "#if": {
            const newRootNode = new ShaderCodeConditionNode();
            const ifNode = this._BuildExpression(line, 3);
            rootNode.children.push(newRootNode);
            newRootNode.children.push(ifNode);
            this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
            break;
          }
        }
      } else {
        const newNode = new ShaderCodeNode();
        newNode.line = line;
        rootNode.children.push(newNode);
        if (line[0] === "#" && line[1] === "d") {
          const split = line.replace(";", "").split(" ");
          newNode.additionalDefineKey = split[1];
          if (split.length === 3) {
            newNode.additionalDefineValue = split[2];
          }
        }
      }
    }
    return false;
  }
  static _EvaluatePreProcessors(sourceCode, preprocessors, options) {
    const rootNode = new ShaderCodeNode();
    const cursor = new ShaderCodeCursor();
    cursor.lineIndex = -1;
    cursor.lines = sourceCode.split("\n");
    this._MoveCursor(cursor, rootNode);
    return rootNode.process(preprocessors, options);
  }
  static _PreparePreProcessors(options, engine) {
    var _a;
    const defines = options.defines;
    const preprocessors = {};
    for (const define of defines) {
      const keyValue = define.replace("#define", "").replace(";", "").trim();
      const split = keyValue.split(" ");
      preprocessors[split[0]] = split.length > 1 ? split[1] : "";
    }
    if (((_a = options.processor) === null || _a === void 0 ? void 0 : _a.shaderLanguage) === ShaderLanguage.GLSL) {
      preprocessors["GL_ES"] = "true";
    }
    preprocessors["__VERSION__"] = options.version;
    preprocessors[options.platformName] = "true";
    engine._getGlobalDefines(preprocessors);
    return preprocessors;
  }
  static _ProcessShaderConversion(sourceCode, options, engine) {
    let preparedSourceCode = this._ProcessPrecision(sourceCode, options);
    if (!options.processor) {
      return preparedSourceCode;
    }
    if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf("#version 3") !== -1) {
      preparedSourceCode = preparedSourceCode.replace("#version 300 es", "");
      if (!options.processor.parseGLES3) {
        return preparedSourceCode;
      }
    }
    const defines = options.defines;
    const preprocessors = this._PreparePreProcessors(options, engine);
    if (options.processor.preProcessor) {
      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);
    }
    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);
    if (options.processor.postProcessor) {
      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);
    }
    if (engine._features.needShaderCodeInlining) {
      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);
    }
    return preparedSourceCode;
  }
  static _ApplyPreProcessing(sourceCode, options, engine) {
    var _a, _b;
    let preparedSourceCode = sourceCode;
    const defines = options.defines;
    const preprocessors = this._PreparePreProcessors(options, engine);
    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessor) {
      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);
    }
    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);
    if ((_b = options.processor) === null || _b === void 0 ? void 0 : _b.postProcessor) {
      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);
    }
    if (engine._features.needShaderCodeInlining) {
      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);
    }
    return preparedSourceCode;
  }
  static _ProcessIncludes(sourceCode, options, callback) {
    let match = regexShaderInclude.exec(sourceCode);
    let returnValue = new String(sourceCode);
    let keepProcessing = false;
    while (match != null) {
      let includeFile = match[1];
      if (includeFile.indexOf("__decl__") !== -1) {
        includeFile = includeFile.replace(/__decl__/, "");
        if (options.supportsUniformBuffers) {
          includeFile = includeFile.replace(/Vertex/, "Ubo");
          includeFile = includeFile.replace(/Fragment/, "Ubo");
        }
        includeFile = includeFile + "Declaration";
      }
      if (options.includesShadersStore[includeFile]) {
        let includeContent = options.includesShadersStore[includeFile];
        if (match[2]) {
          const splits = match[3].split(",");
          for (let index = 0; index < splits.length; index += 2) {
            const source = new RegExp(splits[index], "g");
            const dest = splits[index + 1];
            includeContent = includeContent.replace(source, dest);
          }
        }
        if (match[4]) {
          const indexString = match[5];
          if (indexString.indexOf("..") !== -1) {
            const indexSplits = indexString.split("..");
            const minIndex = parseInt(indexSplits[0]);
            let maxIndex = parseInt(indexSplits[1]);
            let sourceIncludeContent = includeContent.slice(0);
            includeContent = "";
            if (isNaN(maxIndex)) {
              maxIndex = options.indexParameters[indexSplits[1]];
            }
            for (let i = minIndex; i < maxIndex; i++) {
              if (!options.supportsUniformBuffers) {
                sourceIncludeContent = sourceIncludeContent.replace(/light\{X\}.(\w*)/g, (str, p1) => {
                  return p1 + "{X}";
                });
              }
              includeContent += sourceIncludeContent.replace(/\{X\}/g, i.toString()) + "\n";
            }
          } else {
            if (!options.supportsUniformBuffers) {
              includeContent = includeContent.replace(/light\{X\}.(\w*)/g, (str, p1) => {
                return p1 + "{X}";
              });
            }
            includeContent = includeContent.replace(/\{X\}/g, indexString);
          }
        }
        returnValue = returnValue.replace(match[0], includeContent);
        keepProcessing = keepProcessing || includeContent.indexOf("#include<") >= 0 || includeContent.indexOf("#include <") >= 0;
      } else {
        const includeShaderUrl = options.shadersRepository + "ShadersInclude/" + includeFile + ".fx";
        ShaderProcessor._FileToolsLoadFile(includeShaderUrl, (fileContent) => {
          options.includesShadersStore[includeFile] = fileContent;
          this._ProcessIncludes(returnValue, options, callback);
        });
        return;
      }
      match = regexShaderInclude.exec(sourceCode);
    }
    if (keepProcessing) {
      this._ProcessIncludes(returnValue.toString(), options, callback);
    } else {
      callback(returnValue);
    }
  }
  static _FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    throw _WarnImport("FileTools");
  }
};

// node_modules/@babylonjs/core/Materials/effect.js
var Effect = class {
  constructor(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers = null, engine, defines = null, fallbacks = null, onCompiled = null, onError = null, indexParameters, key = "", shaderLanguage = ShaderLanguage.GLSL) {
    var _a, _b, _c;
    this.name = null;
    this.defines = "";
    this.onCompiled = null;
    this.onError = null;
    this.onBind = null;
    this.uniqueId = 0;
    this.onCompileObservable = new Observable();
    this.onErrorObservable = new Observable();
    this._onBindObservable = null;
    this._wasPreviouslyReady = false;
    this._wasPreviouslyUsingInstances = null;
    this._isDisposed = false;
    this._bonesComputationForcedToCPU = false;
    this._uniformBuffersNames = {};
    this._multiTarget = false;
    this._samplers = {};
    this._isReady = false;
    this._compilationError = "";
    this._allFallbacksProcessed = false;
    this._uniforms = {};
    this._key = "";
    this._fallbacks = null;
    this._vertexSourceCodeOverride = "";
    this._fragmentSourceCodeOverride = "";
    this._transformFeedbackVaryings = null;
    this._pipelineContext = null;
    this._vertexSourceCode = "";
    this._fragmentSourceCode = "";
    this._vertexSourceCodeBeforeMigration = "";
    this._fragmentSourceCodeBeforeMigration = "";
    this._rawVertexSourceCode = "";
    this._rawFragmentSourceCode = "";
    this.name = baseName;
    this._key = key;
    let processCodeAfterIncludes = void 0;
    let processFinalCode = null;
    if (attributesNamesOrOptions.attributes) {
      const options = attributesNamesOrOptions;
      this._engine = uniformsNamesOrEngine;
      this._attributesNames = options.attributes;
      this._uniformsNames = options.uniformsNames.concat(options.samplers);
      this._samplerList = options.samplers.slice();
      this.defines = options.defines;
      this.onError = options.onError;
      this.onCompiled = options.onCompiled;
      this._fallbacks = options.fallbacks;
      this._indexParameters = options.indexParameters;
      this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;
      this._multiTarget = !!options.multiTarget;
      this._shaderLanguage = (_a = options.shaderLanguage) !== null && _a !== void 0 ? _a : ShaderLanguage.GLSL;
      if (options.uniformBuffersNames) {
        this._uniformBuffersNamesList = options.uniformBuffersNames.slice();
        for (let i = 0; i < options.uniformBuffersNames.length; i++) {
          this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;
        }
      }
      processFinalCode = (_b = options.processFinalCode) !== null && _b !== void 0 ? _b : null;
      processCodeAfterIncludes = (_c = options.processCodeAfterIncludes) !== null && _c !== void 0 ? _c : void 0;
    } else {
      this._engine = engine;
      this.defines = defines == null ? "" : defines;
      this._uniformsNames = uniformsNamesOrEngine.concat(samplers);
      this._samplerList = samplers ? samplers.slice() : [];
      this._attributesNames = attributesNamesOrOptions;
      this._uniformBuffersNamesList = [];
      this._shaderLanguage = shaderLanguage;
      this.onError = onError;
      this.onCompiled = onCompiled;
      this._indexParameters = indexParameters;
      this._fallbacks = fallbacks;
    }
    this._attributeLocationByName = {};
    this.uniqueId = Effect._UniqueIdSeed++;
    let vertexSource;
    let fragmentSource;
    const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;
    if (baseName.vertexSource) {
      vertexSource = "source:" + baseName.vertexSource;
    } else if (baseName.vertexElement) {
      vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;
      if (!vertexSource) {
        vertexSource = baseName.vertexElement;
      }
    } else {
      vertexSource = baseName.vertex || baseName;
    }
    if (baseName.fragmentSource) {
      fragmentSource = "source:" + baseName.fragmentSource;
    } else if (baseName.fragmentElement) {
      fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;
      if (!fragmentSource) {
        fragmentSource = baseName.fragmentElement;
      }
    } else {
      fragmentSource = baseName.fragment || baseName;
    }
    this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);
    const processorOptions = {
      defines: this.defines.split("\n"),
      indexParameters: this._indexParameters,
      isFragment: false,
      shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
      processor: this._engine._getShaderProcessor(this._shaderLanguage),
      supportsUniformBuffers: this._engine.supportsUniformBuffers,
      shadersRepository: ShaderStore.GetShadersRepository(this._shaderLanguage),
      includesShadersStore: ShaderStore.GetIncludesShadersStore(this._shaderLanguage),
      version: (this._engine.version * 100).toString(),
      platformName: this._engine.shaderPlatformName,
      processingContext: this._processingContext,
      isNDCHalfZRange: this._engine.isNDCHalfZRange,
      useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
      processCodeAfterIncludes
    };
    const shaderCodes = [void 0, void 0];
    const shadersLoaded = () => {
      if (shaderCodes[0] && shaderCodes[1]) {
        processorOptions.isFragment = true;
        const [migratedVertexCode, fragmentCode] = shaderCodes;
        ShaderProcessor.Process(fragmentCode, processorOptions, (migratedFragmentCode, codeBeforeMigration) => {
          this._fragmentSourceCodeBeforeMigration = codeBeforeMigration;
          if (processFinalCode) {
            migratedFragmentCode = processFinalCode("fragment", migratedFragmentCode);
          }
          const finalShaders = ShaderProcessor.Finalize(migratedVertexCode, migratedFragmentCode, processorOptions);
          this._useFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName);
        }, this._engine);
      }
    };
    this._loadShader(vertexSource, "Vertex", "", (vertexCode) => {
      ShaderProcessor.Initialize(processorOptions);
      ShaderProcessor.Process(vertexCode, processorOptions, (migratedVertexCode, codeBeforeMigration) => {
        this._rawVertexSourceCode = vertexCode;
        this._vertexSourceCodeBeforeMigration = codeBeforeMigration;
        if (processFinalCode) {
          migratedVertexCode = processFinalCode("vertex", migratedVertexCode);
        }
        shaderCodes[0] = migratedVertexCode;
        shadersLoaded();
      }, this._engine);
    });
    this._loadShader(fragmentSource, "Fragment", "Pixel", (fragmentCode) => {
      this._rawFragmentSourceCode = fragmentCode;
      shaderCodes[1] = fragmentCode;
      shadersLoaded();
    });
    const proxyFunction = function(functionName) {
      return function() {
        if (this._pipelineContext) {
          const func = this._pipelineContext[functionName];
          func.apply(this._pipelineContext, arguments);
        }
        return this;
      };
    };
    ["Int?", "IntArray?", "Array?", "Color?", "Vector?", "Float?", "Matrices", "Matrix", "Matrix3x3", "Matrix2x2", "Quaternion", "DirectColor4"].forEach((functionName) => {
      const name63 = `set${functionName}`;
      if (name63.endsWith("?")) {
        ["", 2, 3, 4].forEach((n) => {
          this[name63.slice(0, -1) + n] = this[name63.slice(0, -1) + n] || proxyFunction(name63.slice(0, -1) + n).bind(this);
        });
      } else {
        this[name63] = this[name63] || proxyFunction(name63).bind(this);
      }
    });
  }
  static get ShadersRepository() {
    return ShaderStore.ShadersRepository;
  }
  static set ShadersRepository(repo) {
    ShaderStore.ShadersRepository = repo;
  }
  get onBindObservable() {
    if (!this._onBindObservable) {
      this._onBindObservable = new Observable();
    }
    return this._onBindObservable;
  }
  _useFinalCode(migratedVertexCode, migratedFragmentCode, baseName) {
    if (baseName) {
      const vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;
      const fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;
      this._vertexSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? "//" : "") + "#define SHADER_NAME vertex:" + vertex + "\n" + migratedVertexCode;
      this._fragmentSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? "//" : "") + "#define SHADER_NAME fragment:" + fragment + "\n" + migratedFragmentCode;
    } else {
      this._vertexSourceCode = migratedVertexCode;
      this._fragmentSourceCode = migratedFragmentCode;
    }
    this._prepareEffect();
  }
  get key() {
    return this._key;
  }
  isReady() {
    try {
      return this._isReadyInternal();
    } catch (_a) {
      return false;
    }
  }
  _isReadyInternal() {
    if (this._isReady) {
      return true;
    }
    if (this._pipelineContext) {
      return this._pipelineContext.isReady;
    }
    return false;
  }
  getEngine() {
    return this._engine;
  }
  getPipelineContext() {
    return this._pipelineContext;
  }
  getAttributesNames() {
    return this._attributesNames;
  }
  getAttributeLocation(index) {
    return this._attributes[index];
  }
  getAttributeLocationByName(name63) {
    return this._attributeLocationByName[name63];
  }
  getAttributesCount() {
    return this._attributes.length;
  }
  getUniformIndex(uniformName) {
    return this._uniformsNames.indexOf(uniformName);
  }
  getUniform(uniformName) {
    return this._uniforms[uniformName];
  }
  getSamplers() {
    return this._samplerList;
  }
  getUniformNames() {
    return this._uniformsNames;
  }
  getUniformBuffersNames() {
    return this._uniformBuffersNamesList;
  }
  getIndexParameters() {
    return this._indexParameters;
  }
  getCompilationError() {
    return this._compilationError;
  }
  allFallbacksProcessed() {
    return this._allFallbacksProcessed;
  }
  executeWhenCompiled(func) {
    if (this.isReady()) {
      func(this);
      return;
    }
    this.onCompileObservable.add((effect) => {
      func(effect);
    });
    if (!this._pipelineContext || this._pipelineContext.isAsync) {
      setTimeout(() => {
        this._checkIsReady(null);
      }, 16);
    }
  }
  _checkIsReady(previousPipelineContext) {
    try {
      if (this._isReadyInternal()) {
        return;
      }
    } catch (e) {
      this._processCompilationErrors(e, previousPipelineContext);
      return;
    }
    if (this._isDisposed) {
      return;
    }
    setTimeout(() => {
      this._checkIsReady(previousPipelineContext);
    }, 16);
  }
  _loadShader(shader63, key, optionalKey, callback) {
    if (typeof HTMLElement !== "undefined") {
      if (shader63 instanceof HTMLElement) {
        const shaderCode = GetDOMTextContent(shader63);
        callback(shaderCode);
        return;
      }
    }
    if (shader63.substr(0, 7) === "source:") {
      callback(shader63.substr(7));
      return;
    }
    if (shader63.substr(0, 7) === "base64:") {
      const shaderBinary = window.atob(shader63.substr(7));
      callback(shaderBinary);
      return;
    }
    const shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);
    if (shaderStore[shader63 + key + "Shader"]) {
      callback(shaderStore[shader63 + key + "Shader"]);
      return;
    }
    if (optionalKey && shaderStore[shader63 + optionalKey + "Shader"]) {
      callback(shaderStore[shader63 + optionalKey + "Shader"]);
      return;
    }
    let shaderUrl;
    if (shader63[0] === "." || shader63[0] === "/" || shader63.indexOf("http") > -1) {
      shaderUrl = shader63;
    } else {
      shaderUrl = ShaderStore.GetShadersRepository(this._shaderLanguage) + shader63;
    }
    this._engine._loadFile(shaderUrl + "." + key.toLowerCase() + ".fx", callback);
  }
  get vertexSourceCode() {
    var _a, _b;
    return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getVertexShaderCode()) !== null && _b !== void 0 ? _b : this._vertexSourceCode;
  }
  get fragmentSourceCode() {
    var _a, _b;
    return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getFragmentShaderCode()) !== null && _b !== void 0 ? _b : this._fragmentSourceCode;
  }
  get vertexSourceCodeBeforeMigration() {
    return this._vertexSourceCodeBeforeMigration;
  }
  get fragmentSourceCodeBeforeMigration() {
    return this._fragmentSourceCodeBeforeMigration;
  }
  get rawVertexSourceCode() {
    return this._rawVertexSourceCode;
  }
  get rawFragmentSourceCode() {
    return this._rawFragmentSourceCode;
  }
  _rebuildProgram(vertexSourceCode, fragmentSourceCode, onCompiled, onError) {
    this._isReady = false;
    this._vertexSourceCodeOverride = vertexSourceCode;
    this._fragmentSourceCodeOverride = fragmentSourceCode;
    this.onError = (effect, error) => {
      if (onError) {
        onError(error);
      }
    };
    this.onCompiled = () => {
      const scenes = this.getEngine().scenes;
      if (scenes) {
        for (let i = 0; i < scenes.length; i++) {
          scenes[i].markAllMaterialsAsDirty(63);
        }
      }
      this._pipelineContext._handlesSpectorRebuildCallback(onCompiled);
    };
    this._fallbacks = null;
    this._prepareEffect();
  }
  _prepareEffect() {
    const attributesNames = this._attributesNames;
    const defines = this.defines;
    const previousPipelineContext = this._pipelineContext;
    this._isReady = false;
    try {
      const engine = this._engine;
      this._pipelineContext = engine.createPipelineContext(this._processingContext);
      this._pipelineContext._name = this._key;
      const rebuildRebind = this._rebuildProgram.bind(this);
      if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {
        engine._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, true, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, null, this._transformFeedbackVaryings, this._key);
      } else {
        engine._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, false, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, defines, this._transformFeedbackVaryings, this._key);
      }
      engine._executeWhenRenderingStateIsCompiled(this._pipelineContext, () => {
        this._attributes = [];
        this._pipelineContext._fillEffectInformation(this, this._uniformBuffersNames, this._uniformsNames, this._uniforms, this._samplerList, this._samplers, attributesNames, this._attributes);
        if (attributesNames) {
          for (let i = 0; i < attributesNames.length; i++) {
            const name63 = attributesNames[i];
            this._attributeLocationByName[name63] = this._attributes[i];
          }
        }
        engine.bindSamplers(this);
        this._compilationError = "";
        this._isReady = true;
        if (this.onCompiled) {
          this.onCompiled(this);
        }
        this.onCompileObservable.notifyObservers(this);
        this.onCompileObservable.clear();
        if (this._fallbacks) {
          this._fallbacks.unBindMesh();
        }
        if (previousPipelineContext) {
          this.getEngine()._deletePipelineContext(previousPipelineContext);
        }
      });
      if (this._pipelineContext.isAsync) {
        this._checkIsReady(previousPipelineContext);
      }
    } catch (e) {
      this._processCompilationErrors(e, previousPipelineContext);
    }
  }
  _getShaderCodeAndErrorLine(code, error, isFragment) {
    const regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\d+?):/ : /VERTEX SHADER ERROR: 0:(\d+?):/;
    let errorLine = null;
    if (error && code) {
      const res = error.match(regexp);
      if (res && res.length === 2) {
        const lineNumber = parseInt(res[1]);
        const lines = code.split("\n", -1);
        if (lines.length >= lineNumber) {
          errorLine = `Offending line [${lineNumber}] in ${isFragment ? "fragment" : "vertex"} code: ${lines[lineNumber - 1]}`;
        }
      }
    }
    return [code, errorLine];
  }
  _processCompilationErrors(e, previousPipelineContext = null) {
    var _a, _b, _c;
    this._compilationError = e.message;
    const attributesNames = this._attributesNames;
    const fallbacks = this._fallbacks;
    Logger.Error("Unable to compile effect:");
    Logger.Error("Uniforms: " + this._uniformsNames.map(function(uniform) {
      return " " + uniform;
    }));
    Logger.Error("Attributes: " + attributesNames.map(function(attribute) {
      return " " + attribute;
    }));
    Logger.Error("Defines:\r\n" + this.defines);
    if (Effect.LogShaderCodeOnCompilationError) {
      let lineErrorVertex = null, lineErrorFragment = null, code = null;
      if ((_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getVertexShaderCode()) {
        [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false);
        if (code) {
          Logger.Error("Vertex code:");
          Logger.Error(code);
        }
      }
      if ((_b = this._pipelineContext) === null || _b === void 0 ? void 0 : _b._getFragmentShaderCode()) {
        [code, lineErrorFragment] = this._getShaderCodeAndErrorLine((_c = this._pipelineContext) === null || _c === void 0 ? void 0 : _c._getFragmentShaderCode(), this._compilationError, true);
        if (code) {
          Logger.Error("Fragment code:");
          Logger.Error(code);
        }
      }
      if (lineErrorVertex) {
        Logger.Error(lineErrorVertex);
      }
      if (lineErrorFragment) {
        Logger.Error(lineErrorFragment);
      }
    }
    Logger.Error("Error: " + this._compilationError);
    const notifyErrors = () => {
      if (this.onError) {
        this.onError(this, this._compilationError);
      }
      this.onErrorObservable.notifyObservers(this);
    };
    if (previousPipelineContext) {
      this._pipelineContext = previousPipelineContext;
      this._isReady = true;
      notifyErrors();
    }
    if (fallbacks) {
      this._pipelineContext = null;
      if (fallbacks.hasMoreFallbacks) {
        this._allFallbacksProcessed = false;
        Logger.Error("Trying next fallback.");
        this.defines = fallbacks.reduce(this.defines, this);
        this._prepareEffect();
      } else {
        this._allFallbacksProcessed = true;
        notifyErrors();
        this.onErrorObservable.clear();
        if (this._fallbacks) {
          this._fallbacks.unBindMesh();
        }
      }
    } else {
      this._allFallbacksProcessed = true;
      if (!previousPipelineContext) {
        notifyErrors();
      }
    }
  }
  get isSupported() {
    return this._compilationError === "";
  }
  _bindTexture(channel, texture) {
    this._engine._bindTexture(this._samplers[channel], texture, channel);
  }
  setTexture(channel, texture) {
    this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture, channel);
  }
  setDepthStencilTexture(channel, texture) {
    this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);
  }
  setTextureArray(channel, textures) {
    const exName = channel + "Ex";
    if (this._samplerList.indexOf(exName + "0") === -1) {
      const initialPos = this._samplerList.indexOf(channel);
      for (let index = 1; index < textures.length; index++) {
        const currentExName = exName + (index - 1).toString();
        this._samplerList.splice(initialPos + index, 0, currentExName);
      }
      let channelIndex = 0;
      for (const key of this._samplerList) {
        this._samplers[key] = channelIndex;
        channelIndex += 1;
      }
    }
    this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures, channel);
  }
  setTextureFromPostProcess(channel, postProcess) {
    this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);
  }
  setTextureFromPostProcessOutput(channel, postProcess) {
    this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);
  }
  bindUniformBuffer(buffer, name63) {
    const bufferName = this._uniformBuffersNames[name63];
    if (bufferName === void 0 || Effect._BaseCache[bufferName] === buffer && this._engine._features.useUBOBindingCache) {
      return;
    }
    Effect._BaseCache[bufferName] = buffer;
    this._engine.bindUniformBufferBase(buffer, bufferName, name63);
  }
  bindUniformBlock(blockName, index) {
    this._engine.bindUniformBlock(this._pipelineContext, blockName, index);
  }
  setFloatArray(uniformName, array) {
    this._pipelineContext.setArray(uniformName, array);
    return this;
  }
  setFloatArray2(uniformName, array) {
    this._pipelineContext.setArray2(uniformName, array);
    return this;
  }
  setFloatArray3(uniformName, array) {
    this._pipelineContext.setArray3(uniformName, array);
    return this;
  }
  setFloatArray4(uniformName, array) {
    this._pipelineContext.setArray4(uniformName, array);
    return this;
  }
  setBool(uniformName, bool) {
    this._pipelineContext.setInt(uniformName, bool ? 1 : 0);
    return this;
  }
  dispose() {
    var _a;
    (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a.dispose();
    this._engine._releaseEffect(this);
    this._isDisposed = true;
  }
  static RegisterShader(name63, pixelShader, vertexShader, shaderLanguage = ShaderLanguage.GLSL) {
    if (pixelShader) {
      ShaderStore.GetShadersStore(shaderLanguage)[`${name63}PixelShader`] = pixelShader;
    }
    if (vertexShader) {
      ShaderStore.GetShadersStore(shaderLanguage)[`${name63}VertexShader`] = vertexShader;
    }
  }
  static ResetCache() {
    Effect._BaseCache = {};
  }
};
Effect.LogShaderCodeOnCompilationError = true;
Effect._UniqueIdSeed = 0;
Effect._BaseCache = {};
Effect.ShadersStore = ShaderStore.ShadersStore;
Effect.IncludesShadersStore = ShaderStore.IncludesShadersStore;

// node_modules/@babylonjs/core/States/depthCullingState.js
var DepthCullingState = class {
  constructor(reset = true) {
    this._isDepthTestDirty = false;
    this._isDepthMaskDirty = false;
    this._isDepthFuncDirty = false;
    this._isCullFaceDirty = false;
    this._isCullDirty = false;
    this._isZOffsetDirty = false;
    this._isFrontFaceDirty = false;
    if (reset) {
      this.reset();
    }
  }
  get isDirty() {
    return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty || this._isFrontFaceDirty;
  }
  get zOffset() {
    return this._zOffset;
  }
  set zOffset(value) {
    if (this._zOffset === value) {
      return;
    }
    this._zOffset = value;
    this._isZOffsetDirty = true;
  }
  get zOffsetUnits() {
    return this._zOffsetUnits;
  }
  set zOffsetUnits(value) {
    if (this._zOffsetUnits === value) {
      return;
    }
    this._zOffsetUnits = value;
    this._isZOffsetDirty = true;
  }
  get cullFace() {
    return this._cullFace;
  }
  set cullFace(value) {
    if (this._cullFace === value) {
      return;
    }
    this._cullFace = value;
    this._isCullFaceDirty = true;
  }
  get cull() {
    return this._cull;
  }
  set cull(value) {
    if (this._cull === value) {
      return;
    }
    this._cull = value;
    this._isCullDirty = true;
  }
  get depthFunc() {
    return this._depthFunc;
  }
  set depthFunc(value) {
    if (this._depthFunc === value) {
      return;
    }
    this._depthFunc = value;
    this._isDepthFuncDirty = true;
  }
  get depthMask() {
    return this._depthMask;
  }
  set depthMask(value) {
    if (this._depthMask === value) {
      return;
    }
    this._depthMask = value;
    this._isDepthMaskDirty = true;
  }
  get depthTest() {
    return this._depthTest;
  }
  set depthTest(value) {
    if (this._depthTest === value) {
      return;
    }
    this._depthTest = value;
    this._isDepthTestDirty = true;
  }
  get frontFace() {
    return this._frontFace;
  }
  set frontFace(value) {
    if (this._frontFace === value) {
      return;
    }
    this._frontFace = value;
    this._isFrontFaceDirty = true;
  }
  reset() {
    this._depthMask = true;
    this._depthTest = true;
    this._depthFunc = null;
    this._cullFace = null;
    this._cull = null;
    this._zOffset = 0;
    this._zOffsetUnits = 0;
    this._frontFace = null;
    this._isDepthTestDirty = true;
    this._isDepthMaskDirty = true;
    this._isDepthFuncDirty = false;
    this._isCullFaceDirty = false;
    this._isCullDirty = false;
    this._isZOffsetDirty = true;
    this._isFrontFaceDirty = false;
  }
  apply(gl) {
    if (!this.isDirty) {
      return;
    }
    if (this._isCullDirty) {
      if (this.cull) {
        gl.enable(gl.CULL_FACE);
      } else {
        gl.disable(gl.CULL_FACE);
      }
      this._isCullDirty = false;
    }
    if (this._isCullFaceDirty) {
      gl.cullFace(this.cullFace);
      this._isCullFaceDirty = false;
    }
    if (this._isDepthMaskDirty) {
      gl.depthMask(this.depthMask);
      this._isDepthMaskDirty = false;
    }
    if (this._isDepthTestDirty) {
      if (this.depthTest) {
        gl.enable(gl.DEPTH_TEST);
      } else {
        gl.disable(gl.DEPTH_TEST);
      }
      this._isDepthTestDirty = false;
    }
    if (this._isDepthFuncDirty) {
      gl.depthFunc(this.depthFunc);
      this._isDepthFuncDirty = false;
    }
    if (this._isZOffsetDirty) {
      if (this.zOffset || this.zOffsetUnits) {
        gl.enable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(this.zOffset, this.zOffsetUnits);
      } else {
        gl.disable(gl.POLYGON_OFFSET_FILL);
      }
      this._isZOffsetDirty = false;
    }
    if (this._isFrontFaceDirty) {
      gl.frontFace(this.frontFace);
      this._isFrontFaceDirty = false;
    }
  }
};

// node_modules/@babylonjs/core/States/stencilState.js
var StencilState = class {
  constructor() {
    this.reset();
  }
  reset() {
    this.enabled = false;
    this.mask = 255;
    this.func = StencilState.ALWAYS;
    this.funcRef = 1;
    this.funcMask = 255;
    this.opStencilFail = StencilState.KEEP;
    this.opDepthFail = StencilState.KEEP;
    this.opStencilDepthPass = StencilState.REPLACE;
  }
  get stencilFunc() {
    return this.func;
  }
  set stencilFunc(value) {
    this.func = value;
  }
  get stencilFuncRef() {
    return this.funcRef;
  }
  set stencilFuncRef(value) {
    this.funcRef = value;
  }
  get stencilFuncMask() {
    return this.funcMask;
  }
  set stencilFuncMask(value) {
    this.funcMask = value;
  }
  get stencilOpStencilFail() {
    return this.opStencilFail;
  }
  set stencilOpStencilFail(value) {
    this.opStencilFail = value;
  }
  get stencilOpDepthFail() {
    return this.opDepthFail;
  }
  set stencilOpDepthFail(value) {
    this.opDepthFail = value;
  }
  get stencilOpStencilDepthPass() {
    return this.opStencilDepthPass;
  }
  set stencilOpStencilDepthPass(value) {
    this.opStencilDepthPass = value;
  }
  get stencilMask() {
    return this.mask;
  }
  set stencilMask(value) {
    this.mask = value;
  }
  get stencilTest() {
    return this.enabled;
  }
  set stencilTest(value) {
    this.enabled = value;
  }
};
StencilState.ALWAYS = 519;
StencilState.KEEP = 7680;
StencilState.REPLACE = 7681;

// node_modules/@babylonjs/core/States/alphaCullingState.js
var AlphaState = class {
  constructor() {
    this._blendFunctionParameters = new Array(4);
    this._blendEquationParameters = new Array(2);
    this._blendConstants = new Array(4);
    this._isBlendConstantsDirty = false;
    this._alphaBlend = false;
    this._isAlphaBlendDirty = false;
    this._isBlendFunctionParametersDirty = false;
    this._isBlendEquationParametersDirty = false;
    this.reset();
  }
  get isDirty() {
    return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty;
  }
  get alphaBlend() {
    return this._alphaBlend;
  }
  set alphaBlend(value) {
    if (this._alphaBlend === value) {
      return;
    }
    this._alphaBlend = value;
    this._isAlphaBlendDirty = true;
  }
  setAlphaBlendConstants(r, g, b, a) {
    if (this._blendConstants[0] === r && this._blendConstants[1] === g && this._blendConstants[2] === b && this._blendConstants[3] === a) {
      return;
    }
    this._blendConstants[0] = r;
    this._blendConstants[1] = g;
    this._blendConstants[2] = b;
    this._blendConstants[3] = a;
    this._isBlendConstantsDirty = true;
  }
  setAlphaBlendFunctionParameters(value0, value1, value2, value3) {
    if (this._blendFunctionParameters[0] === value0 && this._blendFunctionParameters[1] === value1 && this._blendFunctionParameters[2] === value2 && this._blendFunctionParameters[3] === value3) {
      return;
    }
    this._blendFunctionParameters[0] = value0;
    this._blendFunctionParameters[1] = value1;
    this._blendFunctionParameters[2] = value2;
    this._blendFunctionParameters[3] = value3;
    this._isBlendFunctionParametersDirty = true;
  }
  setAlphaEquationParameters(rgb, alpha) {
    if (this._blendEquationParameters[0] === rgb && this._blendEquationParameters[1] === alpha) {
      return;
    }
    this._blendEquationParameters[0] = rgb;
    this._blendEquationParameters[1] = alpha;
    this._isBlendEquationParametersDirty = true;
  }
  reset() {
    this._alphaBlend = false;
    this._blendFunctionParameters[0] = null;
    this._blendFunctionParameters[1] = null;
    this._blendFunctionParameters[2] = null;
    this._blendFunctionParameters[3] = null;
    this._blendEquationParameters[0] = null;
    this._blendEquationParameters[1] = null;
    this._blendConstants[0] = null;
    this._blendConstants[1] = null;
    this._blendConstants[2] = null;
    this._blendConstants[3] = null;
    this._isAlphaBlendDirty = true;
    this._isBlendFunctionParametersDirty = false;
    this._isBlendEquationParametersDirty = false;
    this._isBlendConstantsDirty = false;
  }
  apply(gl) {
    if (!this.isDirty) {
      return;
    }
    if (this._isAlphaBlendDirty) {
      if (this._alphaBlend) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
      this._isAlphaBlendDirty = false;
    }
    if (this._isBlendFunctionParametersDirty) {
      gl.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]);
      this._isBlendFunctionParametersDirty = false;
    }
    if (this._isBlendEquationParametersDirty) {
      gl.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]);
      this._isBlendEquationParametersDirty = false;
    }
    if (this._isBlendConstantsDirty) {
      gl.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]);
      this._isBlendConstantsDirty = false;
    }
  }
};

// node_modules/@babylonjs/core/Materials/Textures/textureSampler.js
var TextureSampler = class {
  constructor() {
    this.samplingMode = -1;
    this._useMipMaps = true;
    this._cachedWrapU = null;
    this._cachedWrapV = null;
    this._cachedWrapR = null;
    this._cachedAnisotropicFilteringLevel = null;
    this._comparisonFunction = 0;
  }
  get wrapU() {
    return this._cachedWrapU;
  }
  set wrapU(value) {
    this._cachedWrapU = value;
  }
  get wrapV() {
    return this._cachedWrapV;
  }
  set wrapV(value) {
    this._cachedWrapV = value;
  }
  get wrapR() {
    return this._cachedWrapR;
  }
  set wrapR(value) {
    this._cachedWrapR = value;
  }
  get anisotropicFilteringLevel() {
    return this._cachedAnisotropicFilteringLevel;
  }
  set anisotropicFilteringLevel(value) {
    this._cachedAnisotropicFilteringLevel = value;
  }
  get comparisonFunction() {
    return this._comparisonFunction;
  }
  set comparisonFunction(value) {
    this._comparisonFunction = value;
  }
  get useMipMaps() {
    return this._useMipMaps;
  }
  set useMipMaps(value) {
    this._useMipMaps = value;
  }
  setParameters(wrapU = 1, wrapV = 1, wrapR = 1, anisotropicFilteringLevel = 1, samplingMode = 2, comparisonFunction = 0) {
    this._cachedWrapU = wrapU;
    this._cachedWrapV = wrapV;
    this._cachedWrapR = wrapR;
    this._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;
    this.samplingMode = samplingMode;
    this._comparisonFunction = comparisonFunction;
    return this;
  }
  compareSampler(other) {
    return this._cachedWrapU === other._cachedWrapU && this._cachedWrapV === other._cachedWrapV && this._cachedWrapR === other._cachedWrapR && this._cachedAnisotropicFilteringLevel === other._cachedAnisotropicFilteringLevel && this.samplingMode === other.samplingMode && this._comparisonFunction === other._comparisonFunction && this._useMipMaps === other._useMipMaps;
  }
};

// node_modules/@babylonjs/core/Materials/Textures/internalTexture.js
var InternalTextureSource;
(function(InternalTextureSource2) {
  InternalTextureSource2[InternalTextureSource2["Unknown"] = 0] = "Unknown";
  InternalTextureSource2[InternalTextureSource2["Url"] = 1] = "Url";
  InternalTextureSource2[InternalTextureSource2["Temp"] = 2] = "Temp";
  InternalTextureSource2[InternalTextureSource2["Raw"] = 3] = "Raw";
  InternalTextureSource2[InternalTextureSource2["Dynamic"] = 4] = "Dynamic";
  InternalTextureSource2[InternalTextureSource2["RenderTarget"] = 5] = "RenderTarget";
  InternalTextureSource2[InternalTextureSource2["MultiRenderTarget"] = 6] = "MultiRenderTarget";
  InternalTextureSource2[InternalTextureSource2["Cube"] = 7] = "Cube";
  InternalTextureSource2[InternalTextureSource2["CubeRaw"] = 8] = "CubeRaw";
  InternalTextureSource2[InternalTextureSource2["CubePrefiltered"] = 9] = "CubePrefiltered";
  InternalTextureSource2[InternalTextureSource2["Raw3D"] = 10] = "Raw3D";
  InternalTextureSource2[InternalTextureSource2["Raw2DArray"] = 11] = "Raw2DArray";
  InternalTextureSource2[InternalTextureSource2["DepthStencil"] = 12] = "DepthStencil";
  InternalTextureSource2[InternalTextureSource2["CubeRawRGBD"] = 13] = "CubeRawRGBD";
  InternalTextureSource2[InternalTextureSource2["Depth"] = 14] = "Depth";
})(InternalTextureSource || (InternalTextureSource = {}));
var InternalTexture = class extends TextureSampler {
  constructor(engine, source, delayAllocation = false) {
    super();
    this.isReady = false;
    this.isCube = false;
    this.is3D = false;
    this.is2DArray = false;
    this.isMultiview = false;
    this.url = "";
    this.generateMipMaps = false;
    this.samples = 0;
    this.type = -1;
    this.format = -1;
    this.onLoadedObservable = new Observable();
    this.onErrorObservable = new Observable();
    this.onRebuildCallback = null;
    this.width = 0;
    this.height = 0;
    this.depth = 0;
    this.baseWidth = 0;
    this.baseHeight = 0;
    this.baseDepth = 0;
    this.invertY = false;
    this._invertVScale = false;
    this._associatedChannel = -1;
    this._source = InternalTextureSource.Unknown;
    this._buffer = null;
    this._bufferView = null;
    this._bufferViewArray = null;
    this._bufferViewArrayArray = null;
    this._size = 0;
    this._extension = "";
    this._files = null;
    this._workingCanvas = null;
    this._workingContext = null;
    this._cachedCoordinatesMode = null;
    this._isDisabled = false;
    this._compression = null;
    this._sphericalPolynomial = null;
    this._sphericalPolynomialPromise = null;
    this._sphericalPolynomialComputed = false;
    this._lodGenerationScale = 0;
    this._lodGenerationOffset = 0;
    this._useSRGBBuffer = false;
    this._lodTextureHigh = null;
    this._lodTextureMid = null;
    this._lodTextureLow = null;
    this._isRGBD = false;
    this._linearSpecularLOD = false;
    this._irradianceTexture = null;
    this._hardwareTexture = null;
    this._maxLodLevel = null;
    this._references = 1;
    this._gammaSpace = null;
    this._engine = engine;
    this._source = source;
    this._uniqueId = InternalTexture._Counter++;
    if (!delayAllocation) {
      this._hardwareTexture = engine._createHardwareTexture();
    }
  }
  get useMipMaps() {
    return this.generateMipMaps;
  }
  set useMipMaps(value) {
    this.generateMipMaps = value;
  }
  get uniqueId() {
    return this._uniqueId;
  }
  _setUniqueId(id) {
    this._uniqueId = id;
  }
  getEngine() {
    return this._engine;
  }
  get source() {
    return this._source;
  }
  incrementReferences() {
    this._references++;
  }
  updateSize(width, height, depth = 1) {
    this._engine.updateTextureDimensions(this, width, height, depth);
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.baseWidth = width;
    this.baseHeight = height;
    this.baseDepth = depth;
    this._size = width * height * depth;
  }
  _rebuild() {
    var _a;
    this.isReady = false;
    this._cachedCoordinatesMode = null;
    this._cachedWrapU = null;
    this._cachedWrapV = null;
    this._cachedWrapR = null;
    this._cachedAnisotropicFilteringLevel = null;
    if (this.onRebuildCallback) {
      const data = this.onRebuildCallback(this);
      const swapAndSetIsReady = (proxyInternalTexture) => {
        proxyInternalTexture._swapAndDie(this, false);
        this.isReady = data.isReady;
      };
      if (data.isAsync) {
        data.proxy.then(swapAndSetIsReady);
      } else {
        swapAndSetIsReady(data.proxy);
      }
      return;
    }
    let proxy;
    switch (this.source) {
      case InternalTextureSource.Temp:
        break;
      case InternalTextureSource.Url:
        proxy = this._engine.createTexture(
          (_a = this._originalUrl) !== null && _a !== void 0 ? _a : this.url,
          !this.generateMipMaps,
          this.invertY,
          null,
          this.samplingMode,
          (temp) => {
            temp._swapAndDie(this, false);
            this.isReady = true;
          },
          null,
          this._buffer,
          void 0,
          this.format,
          this._extension,
          void 0,
          void 0,
          void 0,
          this._useSRGBBuffer
        );
        return;
      case InternalTextureSource.Raw:
        proxy = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type, void 0, this._useSRGBBuffer);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.Raw3D:
        proxy = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.Raw2DArray:
        proxy = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.Dynamic:
        proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode);
        proxy._swapAndDie(this, false);
        this._engine.updateDynamicTexture(this, this._engine.getRenderingCanvas(), this.invertY, void 0, void 0, true);
        break;
      case InternalTextureSource.Cube:
        proxy = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, () => {
          proxy._swapAndDie(this, false);
          this.isReady = true;
        }, null, this.format, this._extension, false, 0, 0, null, void 0, this._useSRGBBuffer);
        return;
      case InternalTextureSource.CubeRaw:
        proxy = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.CubeRawRGBD:
        return;
      case InternalTextureSource.CubePrefiltered:
        proxy = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, (proxy2) => {
          if (proxy2) {
            proxy2._swapAndDie(this, false);
          }
          this.isReady = true;
        }, null, this.format, this._extension);
        proxy._sphericalPolynomial = this._sphericalPolynomial;
        return;
    }
  }
  _swapAndDie(target, swapAll = true) {
    var _a;
    (_a = this._hardwareTexture) === null || _a === void 0 ? void 0 : _a.setUsage(target._source, this.generateMipMaps, this.isCube, this.width, this.height);
    target._hardwareTexture = this._hardwareTexture;
    if (swapAll) {
      target._isRGBD = this._isRGBD;
    }
    if (this._lodTextureHigh) {
      if (target._lodTextureHigh) {
        target._lodTextureHigh.dispose();
      }
      target._lodTextureHigh = this._lodTextureHigh;
    }
    if (this._lodTextureMid) {
      if (target._lodTextureMid) {
        target._lodTextureMid.dispose();
      }
      target._lodTextureMid = this._lodTextureMid;
    }
    if (this._lodTextureLow) {
      if (target._lodTextureLow) {
        target._lodTextureLow.dispose();
      }
      target._lodTextureLow = this._lodTextureLow;
    }
    if (this._irradianceTexture) {
      if (target._irradianceTexture) {
        target._irradianceTexture.dispose();
      }
      target._irradianceTexture = this._irradianceTexture;
    }
    const cache = this._engine.getLoadedTexturesCache();
    let index = cache.indexOf(this);
    if (index !== -1) {
      cache.splice(index, 1);
    }
    index = cache.indexOf(target);
    if (index === -1) {
      cache.push(target);
    }
  }
  dispose() {
    this._references--;
    this.onLoadedObservable.clear();
    this.onErrorObservable.clear();
    if (this._references === 0) {
      this._engine._releaseTexture(this);
      this._hardwareTexture = null;
    }
  }
};
InternalTexture._Counter = 0;

// node_modules/@babylonjs/core/Engines/WebGL/webGL2ShaderProcessors.js
var WebGL2ShaderProcessor = class {
  constructor() {
    this.shaderLanguage = ShaderLanguage.GLSL;
  }
  attributeProcessor(attribute) {
    return attribute.replace("attribute", "in");
  }
  varyingProcessor(varying, isFragment) {
    return varying.replace("varying", isFragment ? "in" : "out");
  }
  postProcessor(code, defines, isFragment) {
    const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;
    const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;
    code = code.replace(regex, "");
    code = code.replace(/texture2D\s*\(/g, "texture(");
    if (isFragment) {
      code = code.replace(/texture2DLodEXT\s*\(/g, "textureLod(");
      code = code.replace(/textureCubeLodEXT\s*\(/g, "textureLod(");
      code = code.replace(/textureCube\s*\(/g, "texture(");
      code = code.replace(/gl_FragDepthEXT/g, "gl_FragDepth");
      code = code.replace(/gl_FragColor/g, "glFragColor");
      code = code.replace(/gl_FragData/g, "glFragData");
      code = code.replace(/void\s+?main\s*\(/g, (hasDrawBuffersExtension ? "" : "layout(location = 0) out vec4 glFragColor;\n") + "void main(");
    } else {
      const hasMultiviewExtension = defines.indexOf("#define MULTIVIEW") !== -1;
      if (hasMultiviewExtension) {
        return "#extension GL_OVR_multiview2 : require\nlayout (num_views = 2) in;\n" + code;
      }
    }
    return code;
  }
};

// node_modules/@babylonjs/core/Buffers/dataBuffer.js
var DataBuffer = class {
  constructor() {
    this.references = 0;
    this.capacity = 0;
    this.is32Bits = false;
    this.uniqueId = DataBuffer._Counter++;
  }
  get underlyingResource() {
    return null;
  }
};
DataBuffer._Counter = 0;

// node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js
var WebGLDataBuffer = class extends DataBuffer {
  constructor(resource) {
    super();
    this._buffer = resource;
  }
  get underlyingResource() {
    return this._buffer;
  }
};

// node_modules/@babylonjs/core/Engines/WebGL/webGLPipelineContext.js
var floatNCache = [
  "Int2",
  "Int",
  "Int3",
  "Int4",
  "Vector2",
  "Vector3",
  "Vector4",
  "Float2",
  "Float",
  "Float3",
  "Float4",
  "Quaternion",
  "Color3",
  "Color4",
  "DirectColor4"
];
var WebGLPipelineContext = class {
  constructor() {
    this._valueCache = {};
    this.vertexCompilationError = null;
    this.fragmentCompilationError = null;
    this.programLinkError = null;
    this.programValidationError = null;
    const args = [];
    const prepareArray = function() {
      args.length = 0;
      Array.prototype.push.apply(args, arguments);
      args[0] = this._uniforms[args[0]];
    };
    const proxyFunction = (functionName) => {
      const cacheFunction = floatNCache.includes(functionName.substring(3)) && "FloatN";
      if (cacheFunction) {
        const cacheFunc = this[`_cache${cacheFunction}`];
        return function() {
          const func = this.engine[functionName];
          prepareArray.apply(this, arguments);
          if (cacheFunc.apply(this, arguments)) {
            if (!func.apply(this.engine, args)) {
              this._valueCache[arguments[0]] = null;
            }
          }
        };
      } else {
        return function() {
          const func = this.engine[functionName];
          prepareArray.apply(this, arguments);
          if (arguments[1] !== void 0) {
            this._valueCache[arguments[0]] = null;
            func.apply(this.engine, args);
          }
        };
      }
    };
    ["Int?", "IntArray?", "Array?", "Float?", "Matrices", "Matrix3x3", "Matrix2x2"].forEach((functionName) => {
      const name63 = `set${functionName}`;
      if (this[name63]) {
        return;
      }
      if (name63.endsWith("?")) {
        ["", 2, 3, 4].forEach((n) => {
          this[name63.slice(0, -1) + n] = this[name63.slice(0, -1) + n] || proxyFunction(name63.slice(0, -1) + n).bind(this);
        });
      } else {
        this[name63] = this[name63] || proxyFunction(name63).bind(this);
      }
    });
  }
  get isAsync() {
    return this.isParallelCompiled;
  }
  get isReady() {
    if (this.program) {
      if (this.isParallelCompiled) {
        return this.engine._isRenderingStateCompiled(this);
      }
      return true;
    }
    return false;
  }
  _handlesSpectorRebuildCallback(onCompiled) {
    if (onCompiled && this.program) {
      onCompiled(this.program);
    }
  }
  _fillEffectInformation(effect, uniformBuffersNames, uniformsNames, uniforms, samplerList, samplers, attributesNames, attributes) {
    const engine = this.engine;
    if (engine.supportsUniformBuffers) {
      for (const name63 in uniformBuffersNames) {
        effect.bindUniformBlock(name63, uniformBuffersNames[name63]);
      }
    }
    const effectAvailableUniforms = this.engine.getUniforms(this, uniformsNames);
    effectAvailableUniforms.forEach((uniform, index2) => {
      uniforms[uniformsNames[index2]] = uniform;
    });
    this._uniforms = uniforms;
    let index;
    for (index = 0; index < samplerList.length; index++) {
      const sampler = effect.getUniform(samplerList[index]);
      if (sampler == null) {
        samplerList.splice(index, 1);
        index--;
      }
    }
    samplerList.forEach((name63, index2) => {
      samplers[name63] = index2;
    });
    for (const attr of engine.getAttributes(this, attributesNames)) {
      attributes.push(attr);
    }
  }
  dispose() {
    this._uniforms = {};
  }
  _cacheMatrix(uniformName, matrix) {
    const cache = this._valueCache[uniformName];
    const flag = matrix.updateFlag;
    if (cache !== void 0 && cache === flag) {
      return false;
    }
    this._valueCache[uniformName] = flag;
    return true;
  }
  _cacheFloatN(_uniformName, _x, _y, _z, _w) {
    let cache = this._valueCache[arguments[0]];
    if (!cache || cache.length !== arguments.length - 1) {
      cache = Array.prototype.slice.call(arguments, 1);
      this._valueCache[arguments[0]] = cache;
      return true;
    }
    let changed = false;
    for (let i = 0; i < cache.length; ++i) {
      if (cache[i] !== arguments[i + 1]) {
        cache[i] = arguments[i + 1];
        changed = true;
      }
    }
    return changed;
  }
  _cacheFloat2(uniformName, x, y) {
    return this._cacheFloatN(uniformName, x, y);
  }
  _cacheFloat3(uniformName, x, y, z) {
    return this._cacheFloatN(uniformName, x, y, z);
  }
  _cacheFloat4(uniformName, x, y, z, w) {
    return this._cacheFloatN(uniformName, x, y, z, w);
  }
  setMatrix(uniformName, matrix) {
    if (this._cacheMatrix(uniformName, matrix)) {
      if (!this.engine.setMatrices(this._uniforms[uniformName], matrix.toArray())) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  setVector2(uniformName, vector2) {
    this.setFloat2(uniformName, vector2.x, vector2.y);
  }
  setVector3(uniformName, vector3) {
    this.setFloat3(uniformName, vector3.x, vector3.y, vector3.z);
  }
  setVector4(uniformName, vector4) {
    this.setFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w);
  }
  setQuaternion(uniformName, quaternion) {
    this.setFloat4(uniformName, quaternion.x, quaternion.y, quaternion.z, quaternion.w);
  }
  setColor3(uniformName, color3) {
    this.setFloat3(uniformName, color3.r, color3.g, color3.b);
  }
  setColor4(uniformName, color3, alpha) {
    this.setFloat4(uniformName, color3.r, color3.g, color3.b, alpha);
  }
  setDirectColor4(uniformName, color4) {
    this.setFloat4(uniformName, color4.r, color4.g, color4.b, color4.a);
  }
  _getVertexShaderCode() {
    return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null;
  }
  _getFragmentShaderCode() {
    return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null;
  }
};

// node_modules/@babylonjs/core/Engines/WebGL/webGLHardwareTexture.js
var WebGLHardwareTexture = class {
  constructor(existingTexture = null, context) {
    this._MSAARenderBuffer = null;
    this._context = context;
    if (!existingTexture) {
      existingTexture = context.createTexture();
      if (!existingTexture) {
        throw new Error("Unable to create webGL texture");
      }
    }
    this.set(existingTexture);
  }
  get underlyingResource() {
    return this._webGLTexture;
  }
  setUsage() {
  }
  set(hardwareTexture) {
    this._webGLTexture = hardwareTexture;
  }
  reset() {
    this._webGLTexture = null;
    this._MSAARenderBuffer = null;
  }
  release() {
    if (this._MSAARenderBuffer) {
      this._context.deleteRenderbuffer(this._MSAARenderBuffer);
      this._MSAARenderBuffer = null;
    }
    if (this._webGLTexture) {
      this._context.deleteTexture(this._webGLTexture);
    }
    this.reset();
  }
};

// node_modules/@babylonjs/core/Materials/drawWrapper.js
var DrawWrapper = class {
  constructor(engine, createMaterialContext = true) {
    this.effect = null;
    this.defines = null;
    this.drawContext = engine.createDrawContext();
    if (createMaterialContext) {
      this.materialContext = engine.createMaterialContext();
    }
  }
  static IsWrapper(effect) {
    return effect.getPipelineContext === void 0;
  }
  static GetEffect(effect) {
    return effect.getPipelineContext === void 0 ? effect.effect : effect;
  }
  setEffect(effect, defines, resetContext = true) {
    var _a;
    this.effect = effect;
    if (defines !== void 0) {
      this.defines = defines;
    }
    if (resetContext) {
      (_a = this.drawContext) === null || _a === void 0 ? void 0 : _a.reset();
    }
  }
  dispose() {
    var _a;
    (_a = this.drawContext) === null || _a === void 0 ? void 0 : _a.dispose();
  }
};

// node_modules/@babylonjs/core/States/stencilStateComposer.js
var StencilStateComposer = class {
  constructor(reset = true) {
    this._isStencilTestDirty = false;
    this._isStencilMaskDirty = false;
    this._isStencilFuncDirty = false;
    this._isStencilOpDirty = false;
    this.useStencilGlobalOnly = false;
    if (reset) {
      this.reset();
    }
  }
  get isDirty() {
    return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty;
  }
  get func() {
    return this._func;
  }
  set func(value) {
    if (this._func === value) {
      return;
    }
    this._func = value;
    this._isStencilFuncDirty = true;
  }
  get funcRef() {
    return this._funcRef;
  }
  set funcRef(value) {
    if (this._funcRef === value) {
      return;
    }
    this._funcRef = value;
    this._isStencilFuncDirty = true;
  }
  get funcMask() {
    return this._funcMask;
  }
  set funcMask(value) {
    if (this._funcMask === value) {
      return;
    }
    this._funcMask = value;
    this._isStencilFuncDirty = true;
  }
  get opStencilFail() {
    return this._opStencilFail;
  }
  set opStencilFail(value) {
    if (this._opStencilFail === value) {
      return;
    }
    this._opStencilFail = value;
    this._isStencilOpDirty = true;
  }
  get opDepthFail() {
    return this._opDepthFail;
  }
  set opDepthFail(value) {
    if (this._opDepthFail === value) {
      return;
    }
    this._opDepthFail = value;
    this._isStencilOpDirty = true;
  }
  get opStencilDepthPass() {
    return this._opStencilDepthPass;
  }
  set opStencilDepthPass(value) {
    if (this._opStencilDepthPass === value) {
      return;
    }
    this._opStencilDepthPass = value;
    this._isStencilOpDirty = true;
  }
  get mask() {
    return this._mask;
  }
  set mask(value) {
    if (this._mask === value) {
      return;
    }
    this._mask = value;
    this._isStencilMaskDirty = true;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled === value) {
      return;
    }
    this._enabled = value;
    this._isStencilTestDirty = true;
  }
  reset() {
    var _a;
    this.stencilMaterial = void 0;
    (_a = this.stencilGlobal) === null || _a === void 0 ? void 0 : _a.reset();
    this._isStencilTestDirty = true;
    this._isStencilMaskDirty = true;
    this._isStencilFuncDirty = true;
    this._isStencilOpDirty = true;
  }
  apply(gl) {
    var _a;
    if (!gl) {
      return;
    }
    const stencilMaterialEnabled = !this.useStencilGlobalOnly && !!((_a = this.stencilMaterial) === null || _a === void 0 ? void 0 : _a.enabled);
    this.enabled = stencilMaterialEnabled ? this.stencilMaterial.enabled : this.stencilGlobal.enabled;
    this.func = stencilMaterialEnabled ? this.stencilMaterial.func : this.stencilGlobal.func;
    this.funcRef = stencilMaterialEnabled ? this.stencilMaterial.funcRef : this.stencilGlobal.funcRef;
    this.funcMask = stencilMaterialEnabled ? this.stencilMaterial.funcMask : this.stencilGlobal.funcMask;
    this.opStencilFail = stencilMaterialEnabled ? this.stencilMaterial.opStencilFail : this.stencilGlobal.opStencilFail;
    this.opDepthFail = stencilMaterialEnabled ? this.stencilMaterial.opDepthFail : this.stencilGlobal.opDepthFail;
    this.opStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass;
    this.mask = stencilMaterialEnabled ? this.stencilMaterial.mask : this.stencilGlobal.mask;
    if (!this.isDirty) {
      return;
    }
    if (this._isStencilTestDirty) {
      if (this.enabled) {
        gl.enable(gl.STENCIL_TEST);
      } else {
        gl.disable(gl.STENCIL_TEST);
      }
      this._isStencilTestDirty = false;
    }
    if (this._isStencilMaskDirty) {
      gl.stencilMask(this.mask);
      this._isStencilMaskDirty = false;
    }
    if (this._isStencilFuncDirty) {
      gl.stencilFunc(this.func, this.funcRef, this.funcMask);
      this._isStencilFuncDirty = false;
    }
    if (this._isStencilOpDirty) {
      gl.stencilOp(this.opStencilFail, this.opDepthFail, this.opStencilDepthPass);
      this._isStencilOpDirty = false;
    }
  }
};

// node_modules/@babylonjs/core/Engines/WebGL/webGLShaderProcessors.js
var WebGLShaderProcessor = class {
  constructor() {
    this.shaderLanguage = ShaderLanguage.GLSL;
  }
  postProcessor(code, defines, isFragment, processingContext, engine) {
    if (!engine.getCaps().drawBuffersExtension) {
      const regex = /#extension.+GL_EXT_draw_buffers.+(enable|require)/g;
      code = code.replace(regex, "");
    }
    return code;
  }
};

// node_modules/@babylonjs/core/Engines/thinEngine.js
var BufferPointer = class {
};
var ThinEngine = class {
  constructor(canvasOrContext, antialias, options, adaptToDeviceRatio) {
    this._name = "WebGL";
    this.forcePOTTextures = false;
    this.isFullscreen = false;
    this.cullBackFaces = null;
    this.renderEvenInBackground = true;
    this.preventCacheWipeBetweenFrames = false;
    this.validateShaderPrograms = false;
    this._useReverseDepthBuffer = false;
    this.isNDCHalfZRange = false;
    this.hasOriginBottomLeft = true;
    this.disableUniformBuffers = false;
    this.onDisposeObservable = new Observable();
    this._frameId = 0;
    this._uniformBuffers = new Array();
    this._storageBuffers = new Array();
    this._webGLVersion = 1;
    this._windowIsBackground = false;
    this._highPrecisionShadersAllowed = true;
    this._badOS = false;
    this._badDesktopOS = false;
    this._renderingQueueLaunched = false;
    this._activeRenderLoops = new Array();
    this.onContextLostObservable = new Observable();
    this.onContextRestoredObservable = new Observable();
    this._contextWasLost = false;
    this._doNotHandleContextLost = false;
    this.disableVertexArrayObjects = false;
    this._colorWrite = true;
    this._colorWriteChanged = true;
    this._depthCullingState = new DepthCullingState();
    this._stencilStateComposer = new StencilStateComposer();
    this._stencilState = new StencilState();
    this._alphaState = new AlphaState();
    this._alphaMode = 1;
    this._alphaEquation = 0;
    this._internalTexturesCache = new Array();
    this._renderTargetWrapperCache = new Array();
    this._activeChannel = 0;
    this._currentTextureChannel = -1;
    this._boundTexturesCache = {};
    this._compiledEffects = {};
    this._vertexAttribArraysEnabled = [];
    this._uintIndicesCurrentlySet = false;
    this._currentBoundBuffer = new Array();
    this._currentFramebuffer = null;
    this._dummyFramebuffer = null;
    this._currentBufferPointers = new Array();
    this._currentInstanceLocations = new Array();
    this._currentInstanceBuffers = new Array();
    this._vaoRecordInProgress = false;
    this._mustWipeVertexAttributes = false;
    this._nextFreeTextureSlots = new Array();
    this._maxSimultaneousTextures = 0;
    this._maxMSAASamplesOverride = null;
    this._activeRequests = new Array();
    this.adaptToDeviceRatio = false;
    this._lastDevicePixelRatio = 1;
    this._transformTextureUrl = null;
    this.hostInformation = {
      isMobile: false
    };
    this.premultipliedAlpha = true;
    this.onBeforeTextureInitObservable = new Observable();
    this._isWebGPU = false;
    this._snapshotRenderingMode = 0;
    this._useExactSrgbConversions = false;
    this._viewportCached = { x: 0, y: 0, z: 0, w: 0 };
    this._unpackFlipYCached = null;
    this.enableUnpackFlipYCached = true;
    this._boundUniforms = {};
    this.startTime = PrecisionDate.Now;
    let canvas = null;
    options = options || {};
    this._creationOptions = options;
    this.adaptToDeviceRatio = adaptToDeviceRatio !== null && adaptToDeviceRatio !== void 0 ? adaptToDeviceRatio : false;
    this._stencilStateComposer.stencilGlobal = this._stencilState;
    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);
    if (!canvasOrContext) {
      return;
    }
    adaptToDeviceRatio = adaptToDeviceRatio || options.adaptToDeviceRatio || false;
    if (canvasOrContext.getContext) {
      canvas = canvasOrContext;
      this._renderingCanvas = canvas;
      if (antialias !== void 0) {
        options.antialias = antialias;
      }
      if (options.deterministicLockstep === void 0) {
        options.deterministicLockstep = false;
      }
      if (options.lockstepMaxSteps === void 0) {
        options.lockstepMaxSteps = 4;
      }
      if (options.timeStep === void 0) {
        options.timeStep = 1 / 60;
      }
      if (options.preserveDrawingBuffer === void 0) {
        options.preserveDrawingBuffer = false;
      }
      if (options.audioEngine === void 0) {
        options.audioEngine = true;
      }
      if (options.audioEngineOptions !== void 0 && options.audioEngineOptions.audioContext !== void 0) {
        this._audioContext = options.audioEngineOptions.audioContext;
      }
      if (options.audioEngineOptions !== void 0 && options.audioEngineOptions.audioDestination !== void 0) {
        this._audioDestination = options.audioEngineOptions.audioDestination;
      }
      if (options.stencil === void 0) {
        options.stencil = true;
      }
      if (options.premultipliedAlpha === false) {
        this.premultipliedAlpha = false;
      }
      if (options.xrCompatible === void 0) {
        options.xrCompatible = true;
      }
      if (options.useExactSrgbConversions !== void 0) {
        this._useExactSrgbConversions = options.useExactSrgbConversions;
      }
      this._doNotHandleContextLost = options.doNotHandleContextLost ? true : false;
      if (navigator && navigator.userAgent) {
        this._checkForMobile = () => {
          const currentUA = navigator.userAgent;
          this.hostInformation.isMobile = currentUA.indexOf("Mobile") !== -1 || currentUA.indexOf("Mac") !== -1 && IsDocumentAvailable() && "ontouchend" in document;
        };
        this._checkForMobile();
        if (IsWindowObjectExist()) {
          window.addEventListener("resize", this._checkForMobile);
        }
        const ua = navigator.userAgent;
        for (const exception of ThinEngine.ExceptionList) {
          const key = exception.key;
          const targets = exception.targets;
          const check = new RegExp(key);
          if (check.test(ua)) {
            if (exception.capture && exception.captureConstraint) {
              const capture = exception.capture;
              const constraint = exception.captureConstraint;
              const regex = new RegExp(capture);
              const matches = regex.exec(ua);
              if (matches && matches.length > 0) {
                const capturedValue = parseInt(matches[matches.length - 1]);
                if (capturedValue >= constraint) {
                  continue;
                }
              }
            }
            for (const target of targets) {
              switch (target) {
                case "uniformBuffer":
                  this.disableUniformBuffers = true;
                  break;
                case "vao":
                  this.disableVertexArrayObjects = true;
                  break;
                case "antialias":
                  options.antialias = false;
                  break;
                case "maxMSAASamples":
                  this._maxMSAASamplesOverride = 1;
                  break;
              }
            }
          }
        }
      }
      if (!this._doNotHandleContextLost) {
        this._onContextLost = (evt) => {
          evt.preventDefault();
          this._contextWasLost = true;
          Logger.Warn("WebGL context lost.");
          this.onContextLostObservable.notifyObservers(this);
        };
        this._onContextRestored = () => {
          this._restoreEngineAfterContextLost(this._initGLContext.bind(this));
        };
        canvas.addEventListener("webglcontextlost", this._onContextLost, false);
        canvas.addEventListener("webglcontextrestored", this._onContextRestored, false);
        options.powerPreference = "high-performance";
      }
      this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (this._badDesktopOS) {
        options.xrCompatible = false;
      }
      if (!options.disableWebGL2Support) {
        try {
          this._gl = canvas.getContext("webgl2", options) || canvas.getContext("experimental-webgl2", options);
          if (this._gl) {
            this._webGLVersion = 2;
            this._shaderPlatformName = "WEBGL2";
            if (!this._gl.deleteQuery) {
              this._webGLVersion = 1;
              this._shaderPlatformName = "WEBGL1";
            }
          }
        } catch (e) {
        }
      }
      if (!this._gl) {
        if (!canvas) {
          throw new Error("The provided canvas is null or undefined.");
        }
        try {
          this._gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
        } catch (e) {
          throw new Error("WebGL not supported");
        }
      }
      if (!this._gl) {
        throw new Error("WebGL not supported");
      }
    } else {
      this._gl = canvasOrContext;
      this._renderingCanvas = this._gl.canvas;
      if (this._gl.renderbufferStorageMultisample) {
        this._webGLVersion = 2;
        this._shaderPlatformName = "WEBGL2";
      } else {
        this._shaderPlatformName = "WEBGL1";
      }
      const attributes = this._gl.getContextAttributes();
      if (attributes) {
        options.stencil = attributes.stencil;
      }
    }
    this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
    if (options.useHighPrecisionFloats !== void 0) {
      this._highPrecisionShadersAllowed = options.useHighPrecisionFloats;
    }
    const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1 : 1;
    const limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;
    this._hardwareScalingLevel = adaptToDeviceRatio ? 1 / Math.min(limitDeviceRatio, devicePixelRatio) : 1;
    this._lastDevicePixelRatio = devicePixelRatio;
    this.resize();
    this._isStencilEnable = options.stencil ? true : false;
    this._initGLContext();
    this._initFeatures();
    for (let i = 0; i < this._caps.maxVertexAttribs; i++) {
      this._currentBufferPointers[i] = new BufferPointer();
    }
    this._shaderProcessor = this.webGLVersion > 1 ? new WebGL2ShaderProcessor() : new WebGLShaderProcessor();
    this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent);
    const versionToLog = `Babylon.js v${ThinEngine.Version}`;
    console.log(versionToLog + ` - ${this.description}`);
    if (this._renderingCanvas && this._renderingCanvas.setAttribute) {
      this._renderingCanvas.setAttribute("data-engine", versionToLog);
    }
  }
  static get NpmPackage() {
    return "babylonjs@5.42.0";
  }
  static get Version() {
    return "5.42.0";
  }
  get description() {
    let description = this.name + this.webGLVersion;
    if (this._caps.parallelShaderCompile) {
      description += " - Parallel shader compilation";
    }
    return description;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get version() {
    return this._webGLVersion;
  }
  static get ShadersRepository() {
    return Effect.ShadersRepository;
  }
  static set ShadersRepository(value) {
    Effect.ShadersRepository = value;
  }
  _getShaderProcessor(shaderLanguage) {
    return this._shaderProcessor;
  }
  get useReverseDepthBuffer() {
    return this._useReverseDepthBuffer;
  }
  set useReverseDepthBuffer(useReverse) {
    if (useReverse === this._useReverseDepthBuffer) {
      return;
    }
    this._useReverseDepthBuffer = useReverse;
    if (useReverse) {
      this._depthCullingState.depthFunc = 518;
    } else {
      this._depthCullingState.depthFunc = 515;
    }
  }
  get frameId() {
    return this._frameId;
  }
  get supportsUniformBuffers() {
    return this.webGLVersion > 1 && !this.disableUniformBuffers;
  }
  getCreationOptions() {
    return this._creationOptions;
  }
  get _shouldUseHighPrecisionShader() {
    return !!(this._caps.highPrecisionShaderSupported && this._highPrecisionShadersAllowed);
  }
  get needPOTTextures() {
    return this._webGLVersion < 2 || this.forcePOTTextures;
  }
  get activeRenderLoops() {
    return this._activeRenderLoops;
  }
  get doNotHandleContextLost() {
    return this._doNotHandleContextLost;
  }
  set doNotHandleContextLost(value) {
    this._doNotHandleContextLost = value;
  }
  get _supportsHardwareTextureRescaling() {
    return false;
  }
  set framebufferDimensionsObject(dimensions) {
    this._framebufferDimensionsObject = dimensions;
  }
  get currentViewport() {
    return this._cachedViewport;
  }
  get emptyTexture() {
    if (!this._emptyTexture) {
      this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, 5, false, false, 1);
    }
    return this._emptyTexture;
  }
  get emptyTexture3D() {
    if (!this._emptyTexture3D) {
      this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);
    }
    return this._emptyTexture3D;
  }
  get emptyTexture2DArray() {
    if (!this._emptyTexture2DArray) {
      this._emptyTexture2DArray = this.createRawTexture2DArray(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);
    }
    return this._emptyTexture2DArray;
  }
  get emptyCubeTexture() {
    if (!this._emptyCubeTexture) {
      const faceData = new Uint8Array(4);
      const cubeData = [faceData, faceData, faceData, faceData, faceData, faceData];
      this._emptyCubeTexture = this.createRawCubeTexture(cubeData, 1, 5, 0, false, false, 1);
    }
    return this._emptyCubeTexture;
  }
  get isWebGPU() {
    return this._isWebGPU;
  }
  get shaderPlatformName() {
    return this._shaderPlatformName;
  }
  get snapshotRendering() {
    return false;
  }
  set snapshotRendering(activate) {
  }
  get snapshotRenderingMode() {
    return this._snapshotRenderingMode;
  }
  set snapshotRenderingMode(mode) {
    this._snapshotRenderingMode = mode;
  }
  get useExactSrgbConversions() {
    return this._useExactSrgbConversions;
  }
  snapshotRenderingReset() {
    this.snapshotRendering = false;
  }
  static _CreateCanvas(width, height) {
    if (typeof document === "undefined") {
      return new OffscreenCanvas(width, height);
    }
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }
  createCanvas(width, height) {
    return ThinEngine._CreateCanvas(width, height);
  }
  createCanvasImage() {
    return document.createElement("img");
  }
  _restoreEngineAfterContextLost(initEngine) {
    setTimeout(async () => {
      var _a;
      this._dummyFramebuffer = null;
      const depthTest = this._depthCullingState.depthTest;
      const depthFunc = this._depthCullingState.depthFunc;
      const depthMask = this._depthCullingState.depthMask;
      const stencilTest = this._stencilState.stencilTest;
      await initEngine();
      this.wipeCaches(true);
      this._rebuildEffects();
      (_a = this._rebuildComputeEffects) === null || _a === void 0 ? void 0 : _a.call(this);
      this._rebuildBuffers();
      this._rebuildInternalTextures();
      this._rebuildRenderTargetWrappers();
      this.wipeCaches(true);
      this._depthCullingState.depthTest = depthTest;
      this._depthCullingState.depthFunc = depthFunc;
      this._depthCullingState.depthMask = depthMask;
      this._stencilState.stencilTest = stencilTest;
      Logger.Warn(this.name + " context successfully restored.");
      this.onContextRestoredObservable.notifyObservers(this);
      this._contextWasLost = false;
    }, 0);
  }
  _sharedInit(canvas, doNotHandleTouchAction, audioEngine) {
    this._renderingCanvas = canvas;
  }
  _getShaderProcessingContext(shaderLanguage) {
    return null;
  }
  _rebuildInternalTextures() {
    const currentState = this._internalTexturesCache.slice();
    for (const internalTexture of currentState) {
      internalTexture._rebuild();
    }
  }
  _rebuildRenderTargetWrappers() {
    const currentState = this._renderTargetWrapperCache.slice();
    for (const renderTargetWrapper of currentState) {
      renderTargetWrapper._rebuild();
    }
  }
  _rebuildEffects() {
    for (const key in this._compiledEffects) {
      const effect = this._compiledEffects[key];
      effect._pipelineContext = null;
      effect._wasPreviouslyReady = false;
      effect._prepareEffect();
    }
    Effect.ResetCache();
  }
  areAllEffectsReady() {
    for (const key in this._compiledEffects) {
      const effect = this._compiledEffects[key];
      if (!effect.isReady()) {
        return false;
      }
    }
    return true;
  }
  _rebuildBuffers() {
    for (const uniformBuffer of this._uniformBuffers) {
      uniformBuffer._rebuild();
    }
    for (const storageBuffer of this._storageBuffers) {
      storageBuffer._rebuild();
    }
  }
  _initGLContext() {
    var _a;
    this._caps = {
      maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),
      maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
      maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),
      maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1,
      maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),
      maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),
      maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),
      maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),
      maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),
      maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),
      parallelShaderCompile: this._gl.getExtension("KHR_parallel_shader_compile") || void 0,
      standardDerivatives: this._webGLVersion > 1 || this._gl.getExtension("OES_standard_derivatives") !== null,
      maxAnisotropy: 1,
      astc: this._gl.getExtension("WEBGL_compressed_texture_astc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),
      bptc: this._gl.getExtension("EXT_texture_compression_bptc") || this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),
      s3tc: this._gl.getExtension("WEBGL_compressed_texture_s3tc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
      s3tc_srgb: this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),
      pvrtc: this._gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      etc1: this._gl.getExtension("WEBGL_compressed_texture_etc1") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
      etc2: this._gl.getExtension("WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBGL_compressed_texture_es3_0"),
      textureAnisotropicFilterExtension: this._gl.getExtension("EXT_texture_filter_anisotropic") || this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),
      uintIndices: this._webGLVersion > 1 || this._gl.getExtension("OES_element_index_uint") !== null,
      fragmentDepthSupported: this._webGLVersion > 1 || this._gl.getExtension("EXT_frag_depth") !== null,
      highPrecisionShaderSupported: false,
      timerQuery: this._gl.getExtension("EXT_disjoint_timer_query_webgl2") || this._gl.getExtension("EXT_disjoint_timer_query"),
      supportOcclusionQuery: this._webGLVersion > 1,
      canUseTimestampForTimerQuery: false,
      drawBuffersExtension: false,
      maxMSAASamples: 1,
      colorBufferFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_float")),
      textureFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_float") ? true : false,
      textureHalfFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_half_float") ? true : false,
      textureHalfFloatRender: false,
      textureFloatLinearFiltering: false,
      textureFloatRender: false,
      textureHalfFloatLinearFiltering: false,
      vertexArrayObject: false,
      instancedArrays: false,
      textureLOD: this._webGLVersion > 1 || this._gl.getExtension("EXT_shader_texture_lod") ? true : false,
      blendMinMax: false,
      multiview: this._gl.getExtension("OVR_multiview2"),
      oculusMultiview: this._gl.getExtension("OCULUS_multiview"),
      depthTextureExtension: false,
      canUseGLInstanceID: this._webGLVersion > 1,
      canUseGLVertexID: this._webGLVersion > 1,
      supportComputeShaders: false,
      supportSRGBBuffers: false,
      supportTransformFeedbacks: this._webGLVersion > 1,
      textureMaxLevel: this._webGLVersion > 1,
      texture2DArrayMaxLayerCount: this._webGLVersion > 1 ? 256 : 128
    };
    this._glVersion = this._gl.getParameter(this._gl.VERSION);
    const rendererInfo = this._gl.getExtension("WEBGL_debug_renderer_info");
    if (rendererInfo != null) {
      this._glRenderer = this._gl.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL);
      this._glVendor = this._gl.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL);
    }
    if (!this._glVendor) {
      this._glVendor = this._gl.getParameter(this._gl.VENDOR) || "Unknown vendor";
    }
    if (!this._glRenderer) {
      this._glRenderer = this._gl.getParameter(this._gl.RENDERER) || "Unknown renderer";
    }
    if (this._gl.HALF_FLOAT_OES !== 36193) {
      this._gl.HALF_FLOAT_OES = 36193;
    }
    if (this._gl.RGBA16F !== 34842) {
      this._gl.RGBA16F = 34842;
    }
    if (this._gl.RGBA32F !== 34836) {
      this._gl.RGBA32F = 34836;
    }
    if (this._gl.DEPTH24_STENCIL8 !== 35056) {
      this._gl.DEPTH24_STENCIL8 = 35056;
    }
    if (this._caps.timerQuery) {
      if (this._webGLVersion === 1) {
        this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery);
      }
      this._caps.canUseTimestampForTimerQuery = ((_a = this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT)) !== null && _a !== void 0 ? _a : 0) > 0;
    }
    this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
    this._caps.textureFloatLinearFiltering = this._caps.textureFloat && this._gl.getExtension("OES_texture_float_linear") ? true : false;
    this._caps.textureFloatRender = this._caps.textureFloat && this._canRenderToFloatFramebuffer() ? true : false;
    this._caps.textureHalfFloatLinearFiltering = this._webGLVersion > 1 || this._caps.textureHalfFloat && this._gl.getExtension("OES_texture_half_float_linear") ? true : false;
    if (this._caps.astc) {
      this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
    }
    if (this._caps.bptc) {
      this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
    }
    if (this._caps.s3tc_srgb) {
      this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT;
      this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
      this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
    }
    if (this._caps.etc2) {
      this._gl.COMPRESSED_SRGB8_ETC2 = this._caps.etc2.COMPRESSED_SRGB8_ETC2;
      this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
    }
    if (this._webGLVersion > 1) {
      if (this._gl.HALF_FLOAT_OES !== 5131) {
        this._gl.HALF_FLOAT_OES = 5131;
      }
    }
    this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer();
    if (this._webGLVersion > 1) {
      this._caps.drawBuffersExtension = true;
      this._caps.maxMSAASamples = this._maxMSAASamplesOverride !== null ? this._maxMSAASamplesOverride : this._gl.getParameter(this._gl.MAX_SAMPLES);
    } else {
      const drawBuffersExtension = this._gl.getExtension("WEBGL_draw_buffers");
      if (drawBuffersExtension !== null) {
        this._caps.drawBuffersExtension = true;
        this._gl.drawBuffers = drawBuffersExtension.drawBuffersWEBGL.bind(drawBuffersExtension);
        this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER;
        for (let i = 0; i < 16; i++) {
          this._gl["COLOR_ATTACHMENT" + i + "_WEBGL"] = drawBuffersExtension["COLOR_ATTACHMENT" + i + "_WEBGL"];
        }
      }
    }
    if (this._webGLVersion > 1) {
      this._caps.depthTextureExtension = true;
    } else {
      const depthTextureExtension = this._gl.getExtension("WEBGL_depth_texture");
      if (depthTextureExtension != null) {
        this._caps.depthTextureExtension = true;
        this._gl.UNSIGNED_INT_24_8 = depthTextureExtension.UNSIGNED_INT_24_8_WEBGL;
      }
    }
    if (this.disableVertexArrayObjects) {
      this._caps.vertexArrayObject = false;
    } else if (this._webGLVersion > 1) {
      this._caps.vertexArrayObject = true;
    } else {
      const vertexArrayObjectExtension = this._gl.getExtension("OES_vertex_array_object");
      if (vertexArrayObjectExtension != null) {
        this._caps.vertexArrayObject = true;
        this._gl.createVertexArray = vertexArrayObjectExtension.createVertexArrayOES.bind(vertexArrayObjectExtension);
        this._gl.bindVertexArray = vertexArrayObjectExtension.bindVertexArrayOES.bind(vertexArrayObjectExtension);
        this._gl.deleteVertexArray = vertexArrayObjectExtension.deleteVertexArrayOES.bind(vertexArrayObjectExtension);
      }
    }
    if (this._webGLVersion > 1) {
      this._caps.instancedArrays = true;
    } else {
      const instanceExtension = this._gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExtension != null) {
        this._caps.instancedArrays = true;
        this._gl.drawArraysInstanced = instanceExtension.drawArraysInstancedANGLE.bind(instanceExtension);
        this._gl.drawElementsInstanced = instanceExtension.drawElementsInstancedANGLE.bind(instanceExtension);
        this._gl.vertexAttribDivisor = instanceExtension.vertexAttribDivisorANGLE.bind(instanceExtension);
      } else {
        this._caps.instancedArrays = false;
      }
    }
    if (this._gl.getShaderPrecisionFormat) {
      const vertexhighp = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT);
      const fragmenthighp = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);
      if (vertexhighp && fragmenthighp) {
        this._caps.highPrecisionShaderSupported = vertexhighp.precision !== 0 && fragmenthighp.precision !== 0;
      }
    }
    if (this._webGLVersion > 1) {
      this._caps.blendMinMax = true;
    } else {
      const blendMinMaxExtension = this._gl.getExtension("EXT_blend_minmax");
      if (blendMinMaxExtension != null) {
        this._caps.blendMinMax = true;
        this._gl.MAX = blendMinMaxExtension.MAX_EXT;
        this._gl.MIN = blendMinMaxExtension.MIN_EXT;
      }
    }
    if (!this._caps.supportSRGBBuffers) {
      if (this._webGLVersion > 1) {
        this._caps.supportSRGBBuffers = true;
      } else {
        const sRGBExtension = this._gl.getExtension("EXT_sRGB");
        if (sRGBExtension != null) {
          this._caps.supportSRGBBuffers = true;
          this._gl.SRGB = sRGBExtension.SRGB_EXT;
          this._gl.SRGB8 = sRGBExtension.SRGB_ALPHA_EXT;
          this._gl.SRGB8_ALPHA8 = sRGBExtension.SRGB_ALPHA_EXT;
        }
      }
      this._caps.supportSRGBBuffers = this._caps.supportSRGBBuffers && !!(this._creationOptions && this._creationOptions.forceSRGBBufferSupportState);
    }
    this._depthCullingState.depthTest = true;
    this._depthCullingState.depthFunc = this._gl.LEQUAL;
    this._depthCullingState.depthMask = true;
    this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;
    for (let slot = 0; slot < this._maxSimultaneousTextures; slot++) {
      this._nextFreeTextureSlots.push(slot);
    }
  }
  _initFeatures() {
    this._features = {
      forceBitmapOverHTMLImageElement: false,
      supportRenderAndCopyToLodForFloatTextures: this._webGLVersion !== 1,
      supportDepthStencilTexture: this._webGLVersion !== 1,
      supportShadowSamplers: this._webGLVersion !== 1,
      uniformBufferHardCheckMatrix: false,
      allowTexturePrefiltering: this._webGLVersion !== 1,
      trackUbosInFrame: false,
      checkUbosContentBeforeUpload: false,
      supportCSM: this._webGLVersion !== 1,
      basisNeedsPOT: this._webGLVersion === 1,
      support3DTextures: this._webGLVersion !== 1,
      needTypeSuffixInShaderConstants: this._webGLVersion !== 1,
      supportMSAA: this._webGLVersion !== 1,
      supportSSAO2: this._webGLVersion !== 1,
      supportExtendedTextureFormats: this._webGLVersion !== 1,
      supportSwitchCaseInShader: this._webGLVersion !== 1,
      supportSyncTextureRead: true,
      needsInvertingBitmap: true,
      useUBOBindingCache: true,
      needShaderCodeInlining: false,
      needToAlwaysBindUniformBuffers: false,
      supportRenderPasses: false,
      supportSpriteInstancing: true,
      _collectUbosUpdatedInFrame: false
    };
  }
  get webGLVersion() {
    return this._webGLVersion;
  }
  getClassName() {
    return "ThinEngine";
  }
  get isStencilEnable() {
    return this._isStencilEnable;
  }
  _prepareWorkingCanvas() {
    if (this._workingCanvas) {
      return;
    }
    this._workingCanvas = this.createCanvas(1, 1);
    const context = this._workingCanvas.getContext("2d");
    if (context) {
      this._workingContext = context;
    }
  }
  resetTextureCache() {
    for (const key in this._boundTexturesCache) {
      if (!Object.prototype.hasOwnProperty.call(this._boundTexturesCache, key)) {
        continue;
      }
      this._boundTexturesCache[key] = null;
    }
    this._currentTextureChannel = -1;
  }
  getInfo() {
    return this.getGlInfo();
  }
  getGlInfo() {
    return {
      vendor: this._glVendor,
      renderer: this._glRenderer,
      version: this._glVersion
    };
  }
  setHardwareScalingLevel(level) {
    this._hardwareScalingLevel = level;
    this.resize();
  }
  getHardwareScalingLevel() {
    return this._hardwareScalingLevel;
  }
  getLoadedTexturesCache() {
    return this._internalTexturesCache;
  }
  getCaps() {
    return this._caps;
  }
  stopRenderLoop(renderFunction) {
    if (!renderFunction) {
      this._activeRenderLoops = [];
      return;
    }
    const index = this._activeRenderLoops.indexOf(renderFunction);
    if (index >= 0) {
      this._activeRenderLoops.splice(index, 1);
    }
  }
  _renderLoop() {
    if (!this._contextWasLost) {
      let shouldRender = true;
      if (!this.renderEvenInBackground && this._windowIsBackground) {
        shouldRender = false;
      }
      if (shouldRender) {
        this.beginFrame();
        for (let index = 0; index < this._activeRenderLoops.length; index++) {
          const renderFunction = this._activeRenderLoops[index];
          renderFunction();
        }
        this.endFrame();
      }
    }
    if (this._activeRenderLoops.length > 0) {
      this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
    } else {
      this._renderingQueueLaunched = false;
    }
  }
  getRenderingCanvas() {
    return this._renderingCanvas;
  }
  getAudioContext() {
    return this._audioContext;
  }
  getAudioDestination() {
    return this._audioDestination;
  }
  getHostWindow() {
    if (!IsWindowObjectExist()) {
      return null;
    }
    if (this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView) {
      return this._renderingCanvas.ownerDocument.defaultView;
    }
    return window;
  }
  getRenderWidth(useScreen = false) {
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.width;
    }
    return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth;
  }
  getRenderHeight(useScreen = false) {
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.height;
    }
    return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight;
  }
  _queueNewFrame(bindedRenderFunction, requester) {
    return ThinEngine.QueueNewFrame(bindedRenderFunction, requester);
  }
  runRenderLoop(renderFunction) {
    if (this._activeRenderLoops.indexOf(renderFunction) !== -1) {
      return;
    }
    this._activeRenderLoops.push(renderFunction);
    if (!this._renderingQueueLaunched) {
      this._renderingQueueLaunched = true;
      this._boundRenderFunction = this._renderLoop.bind(this);
      this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
    }
  }
  clear(color, backBuffer, depth, stencil = false) {
    const useStencilGlobalOnly = this.stencilStateComposer.useStencilGlobalOnly;
    this.stencilStateComposer.useStencilGlobalOnly = true;
    this.applyStates();
    this.stencilStateComposer.useStencilGlobalOnly = useStencilGlobalOnly;
    let mode = 0;
    if (backBuffer && color) {
      this._gl.clearColor(color.r, color.g, color.b, color.a !== void 0 ? color.a : 1);
      mode |= this._gl.COLOR_BUFFER_BIT;
    }
    if (depth) {
      if (this.useReverseDepthBuffer) {
        this._depthCullingState.depthFunc = this._gl.GEQUAL;
        this._gl.clearDepth(0);
      } else {
        this._gl.clearDepth(1);
      }
      mode |= this._gl.DEPTH_BUFFER_BIT;
    }
    if (stencil) {
      this._gl.clearStencil(0);
      mode |= this._gl.STENCIL_BUFFER_BIT;
    }
    this._gl.clear(mode);
  }
  _viewport(x, y, width, height) {
    if (x !== this._viewportCached.x || y !== this._viewportCached.y || width !== this._viewportCached.z || height !== this._viewportCached.w) {
      this._viewportCached.x = x;
      this._viewportCached.y = y;
      this._viewportCached.z = width;
      this._viewportCached.w = height;
      this._gl.viewport(x, y, width, height);
    }
  }
  setViewport(viewport, requiredWidth, requiredHeight) {
    const width = requiredWidth || this.getRenderWidth();
    const height = requiredHeight || this.getRenderHeight();
    const x = viewport.x || 0;
    const y = viewport.y || 0;
    this._cachedViewport = viewport;
    this._viewport(x * width, y * height, width * viewport.width, height * viewport.height);
  }
  beginFrame() {
  }
  endFrame() {
    if (this._badOS) {
      this.flushFramebuffer();
    }
    this._frameId++;
  }
  resize(forceSetSize = false) {
    let width;
    let height;
    if (this.adaptToDeviceRatio) {
      const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1 : 1;
      const changeRatio = this._lastDevicePixelRatio / devicePixelRatio;
      this._lastDevicePixelRatio = devicePixelRatio;
      this._hardwareScalingLevel *= changeRatio;
    }
    if (IsWindowObjectExist()) {
      width = this._renderingCanvas ? this._renderingCanvas.clientWidth || this._renderingCanvas.width : window.innerWidth;
      height = this._renderingCanvas ? this._renderingCanvas.clientHeight || this._renderingCanvas.height : window.innerHeight;
    } else {
      width = this._renderingCanvas ? this._renderingCanvas.width : 100;
      height = this._renderingCanvas ? this._renderingCanvas.height : 100;
    }
    this.setSize(width / this._hardwareScalingLevel, height / this._hardwareScalingLevel, forceSetSize);
  }
  setSize(width, height, forceSetSize = false) {
    if (!this._renderingCanvas) {
      return false;
    }
    width = width | 0;
    height = height | 0;
    if (!forceSetSize && this._renderingCanvas.width === width && this._renderingCanvas.height === height) {
      return false;
    }
    this._renderingCanvas.width = width;
    this._renderingCanvas.height = height;
    return true;
  }
  bindFramebuffer(texture, faceIndex = 0, requiredWidth, requiredHeight, forceFullscreenViewport, lodLevel = 0, layer = 0) {
    var _a, _b, _c, _d, _e;
    const webglRTWrapper = texture;
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    }
    this._currentRenderTarget = texture;
    this._bindUnboundFramebuffer(webglRTWrapper._MSAAFramebuffer ? webglRTWrapper._MSAAFramebuffer : webglRTWrapper._framebuffer);
    const gl = this._gl;
    if (texture.is2DArray) {
      gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, (_a = texture.texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource, lodLevel, layer);
    } else if (texture.isCube) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_b = texture.texture._hardwareTexture) === null || _b === void 0 ? void 0 : _b.underlyingResource, lodLevel);
    }
    const depthStencilTexture = texture._depthStencilTexture;
    if (depthStencilTexture) {
      const attachment = texture._depthStencilTextureWithStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
      if (texture.is2DArray) {
        gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, (_c = depthStencilTexture._hardwareTexture) === null || _c === void 0 ? void 0 : _c.underlyingResource, lodLevel, layer);
      } else if (texture.isCube) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_d = depthStencilTexture._hardwareTexture) === null || _d === void 0 ? void 0 : _d.underlyingResource, lodLevel);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, (_e = depthStencilTexture._hardwareTexture) === null || _e === void 0 ? void 0 : _e.underlyingResource, lodLevel);
      }
    }
    if (this._cachedViewport && !forceFullscreenViewport) {
      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);
    } else {
      if (!requiredWidth) {
        requiredWidth = texture.width;
        if (lodLevel) {
          requiredWidth = requiredWidth / Math.pow(2, lodLevel);
        }
      }
      if (!requiredHeight) {
        requiredHeight = texture.height;
        if (lodLevel) {
          requiredHeight = requiredHeight / Math.pow(2, lodLevel);
        }
      }
      this._viewport(0, 0, requiredWidth, requiredHeight);
    }
    this.wipeCaches();
  }
  setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {
    var _a, _b;
    if (this._depthCullingState.cull !== culling || force) {
      this._depthCullingState.cull = culling;
    }
    const cullFace = ((_b = (_a = this.cullBackFaces) !== null && _a !== void 0 ? _a : cullBackFaces) !== null && _b !== void 0 ? _b : true) ? this._gl.BACK : this._gl.FRONT;
    if (this._depthCullingState.cullFace !== cullFace || force) {
      this._depthCullingState.cullFace = cullFace;
    }
    this.setZOffset(zOffset);
    this.setZOffsetUnits(zOffsetUnits);
    const frontFace = reverseSide ? this._gl.CW : this._gl.CCW;
    if (this._depthCullingState.frontFace !== frontFace || force) {
      this._depthCullingState.frontFace = frontFace;
    }
    this._stencilStateComposer.stencilMaterial = stencil;
  }
  getDepthBuffer() {
    return this._depthCullingState.depthTest;
  }
  setDepthBuffer(enable) {
    this._depthCullingState.depthTest = enable;
  }
  setZOffset(value) {
    this._depthCullingState.zOffset = this.useReverseDepthBuffer ? -value : value;
  }
  getZOffset() {
    const zOffset = this._depthCullingState.zOffset;
    return this.useReverseDepthBuffer ? -zOffset : zOffset;
  }
  setZOffsetUnits(value) {
    this._depthCullingState.zOffsetUnits = this.useReverseDepthBuffer ? -value : value;
  }
  getZOffsetUnits() {
    const zOffsetUnits = this._depthCullingState.zOffsetUnits;
    return this.useReverseDepthBuffer ? -zOffsetUnits : zOffsetUnits;
  }
  _bindUnboundFramebuffer(framebuffer) {
    if (this._currentFramebuffer !== framebuffer) {
      this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);
      this._currentFramebuffer = framebuffer;
    }
  }
  _currentFrameBufferIsDefaultFrameBuffer() {
    return this._currentFramebuffer === null;
  }
  generateMipmaps(texture) {
    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  }
  unBindFramebuffer(texture, disableGenerateMipMaps = false, onBeforeUnbind) {
    var _a;
    const webglRTWrapper = texture;
    this._currentRenderTarget = null;
    const gl = this._gl;
    if (webglRTWrapper._MSAAFramebuffer) {
      if (texture.isMulti) {
        this.unBindMultiColorAttachmentFramebuffer(texture, disableGenerateMipMaps, onBeforeUnbind);
        return;
      }
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, webglRTWrapper._MSAAFramebuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, webglRTWrapper._framebuffer);
      gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
    }
    if (((_a = texture.texture) === null || _a === void 0 ? void 0 : _a.generateMipMaps) && !disableGenerateMipMaps && !texture.isCube) {
      this.generateMipmaps(texture.texture);
    }
    if (onBeforeUnbind) {
      if (webglRTWrapper._MSAAFramebuffer) {
        this._bindUnboundFramebuffer(webglRTWrapper._framebuffer);
      }
      onBeforeUnbind();
    }
    this._bindUnboundFramebuffer(null);
  }
  flushFramebuffer() {
    this._gl.flush();
  }
  restoreDefaultFramebuffer() {
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    } else {
      this._bindUnboundFramebuffer(null);
    }
    if (this._cachedViewport) {
      this.setViewport(this._cachedViewport);
    }
    this.wipeCaches();
  }
  _resetVertexBufferBinding() {
    this.bindArrayBuffer(null);
    this._cachedVertexBuffers = null;
  }
  createVertexBuffer(data) {
    return this._createVertexBuffer(data, this._gl.STATIC_DRAW);
  }
  _createVertexBuffer(data, usage) {
    const vbo = this._gl.createBuffer();
    if (!vbo) {
      throw new Error("Unable to create vertex buffer");
    }
    const dataBuffer = new WebGLDataBuffer(vbo);
    this.bindArrayBuffer(dataBuffer);
    if (data instanceof Array) {
      this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(data), usage);
    } else {
      this._gl.bufferData(this._gl.ARRAY_BUFFER, data, usage);
    }
    this._resetVertexBufferBinding();
    dataBuffer.references = 1;
    return dataBuffer;
  }
  createDynamicVertexBuffer(data) {
    return this._createVertexBuffer(data, this._gl.DYNAMIC_DRAW);
  }
  _resetIndexBufferBinding() {
    this.bindIndexBuffer(null);
    this._cachedIndexBuffer = null;
  }
  createIndexBuffer(indices, updatable) {
    const vbo = this._gl.createBuffer();
    const dataBuffer = new WebGLDataBuffer(vbo);
    if (!vbo) {
      throw new Error("Unable to create index buffer");
    }
    this.bindIndexBuffer(dataBuffer);
    const data = this._normalizeIndexData(indices);
    this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, data, updatable ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW);
    this._resetIndexBufferBinding();
    dataBuffer.references = 1;
    dataBuffer.is32Bits = data.BYTES_PER_ELEMENT === 4;
    return dataBuffer;
  }
  _normalizeIndexData(indices) {
    const bytesPerElement = indices.BYTES_PER_ELEMENT;
    if (bytesPerElement === 2) {
      return indices;
    }
    if (this._caps.uintIndices) {
      if (indices instanceof Uint32Array) {
        return indices;
      } else {
        for (let index = 0; index < indices.length; index++) {
          if (indices[index] >= 65535) {
            return new Uint32Array(indices);
          }
        }
        return new Uint16Array(indices);
      }
    }
    return new Uint16Array(indices);
  }
  bindArrayBuffer(buffer) {
    if (!this._vaoRecordInProgress) {
      this._unbindVertexArrayObject();
    }
    this._bindBuffer(buffer, this._gl.ARRAY_BUFFER);
  }
  bindUniformBlock(pipelineContext, blockName, index) {
    const program = pipelineContext.program;
    const uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
    this._gl.uniformBlockBinding(program, uniformLocation, index);
  }
  bindIndexBuffer(buffer) {
    if (!this._vaoRecordInProgress) {
      this._unbindVertexArrayObject();
    }
    this._bindBuffer(buffer, this._gl.ELEMENT_ARRAY_BUFFER);
  }
  _bindBuffer(buffer, target) {
    if (this._vaoRecordInProgress || this._currentBoundBuffer[target] !== buffer) {
      this._gl.bindBuffer(target, buffer ? buffer.underlyingResource : null);
      this._currentBoundBuffer[target] = buffer;
    }
  }
  updateArrayBuffer(data) {
    this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
  }
  _vertexAttribPointer(buffer, indx, size, type, normalized, stride, offset) {
    const pointer = this._currentBufferPointers[indx];
    if (!pointer) {
      return;
    }
    let changed = false;
    if (!pointer.active) {
      changed = true;
      pointer.active = true;
      pointer.index = indx;
      pointer.size = size;
      pointer.type = type;
      pointer.normalized = normalized;
      pointer.stride = stride;
      pointer.offset = offset;
      pointer.buffer = buffer;
    } else {
      if (pointer.buffer !== buffer) {
        pointer.buffer = buffer;
        changed = true;
      }
      if (pointer.size !== size) {
        pointer.size = size;
        changed = true;
      }
      if (pointer.type !== type) {
        pointer.type = type;
        changed = true;
      }
      if (pointer.normalized !== normalized) {
        pointer.normalized = normalized;
        changed = true;
      }
      if (pointer.stride !== stride) {
        pointer.stride = stride;
        changed = true;
      }
      if (pointer.offset !== offset) {
        pointer.offset = offset;
        changed = true;
      }
    }
    if (changed || this._vaoRecordInProgress) {
      this.bindArrayBuffer(buffer);
      if (type === this._gl.UNSIGNED_INT || type === this._gl.INT) {
        this._gl.vertexAttribIPointer(indx, size, type, stride, offset);
      } else {
        this._gl.vertexAttribPointer(indx, size, type, normalized, stride, offset);
      }
    }
  }
  _bindIndexBufferWithCache(indexBuffer) {
    if (indexBuffer == null) {
      return;
    }
    if (this._cachedIndexBuffer !== indexBuffer) {
      this._cachedIndexBuffer = indexBuffer;
      this.bindIndexBuffer(indexBuffer);
      this._uintIndicesCurrentlySet = indexBuffer.is32Bits;
    }
  }
  _bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers) {
    const attributes = effect.getAttributesNames();
    if (!this._vaoRecordInProgress) {
      this._unbindVertexArrayObject();
    }
    this.unbindAllAttributes();
    for (let index = 0; index < attributes.length; index++) {
      const order = effect.getAttributeLocation(index);
      if (order >= 0) {
        const ai = attributes[index];
        let vertexBuffer = null;
        if (overrideVertexBuffers) {
          vertexBuffer = overrideVertexBuffers[ai];
        }
        if (!vertexBuffer) {
          vertexBuffer = vertexBuffers[ai];
        }
        if (!vertexBuffer) {
          continue;
        }
        this._gl.enableVertexAttribArray(order);
        if (!this._vaoRecordInProgress) {
          this._vertexAttribArraysEnabled[order] = true;
        }
        const buffer = vertexBuffer.getBuffer();
        if (buffer) {
          this._vertexAttribPointer(buffer, order, vertexBuffer.getSize(), vertexBuffer.type, vertexBuffer.normalized, vertexBuffer.byteStride, vertexBuffer.byteOffset);
          if (vertexBuffer.getIsInstanced()) {
            this._gl.vertexAttribDivisor(order, vertexBuffer.getInstanceDivisor());
            if (!this._vaoRecordInProgress) {
              this._currentInstanceLocations.push(order);
              this._currentInstanceBuffers.push(buffer);
            }
          }
        }
      }
    }
  }
  recordVertexArrayObject(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
    const vao = this._gl.createVertexArray();
    if (!vao) {
      throw new Error("Unable to create VAO");
    }
    this._vaoRecordInProgress = true;
    this._gl.bindVertexArray(vao);
    this._mustWipeVertexAttributes = true;
    this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);
    this.bindIndexBuffer(indexBuffer);
    this._vaoRecordInProgress = false;
    this._gl.bindVertexArray(null);
    return vao;
  }
  bindVertexArrayObject(vertexArrayObject, indexBuffer) {
    if (this._cachedVertexArrayObject !== vertexArrayObject) {
      this._cachedVertexArrayObject = vertexArrayObject;
      this._gl.bindVertexArray(vertexArrayObject);
      this._cachedVertexBuffers = null;
      this._cachedIndexBuffer = null;
      this._uintIndicesCurrentlySet = indexBuffer != null && indexBuffer.is32Bits;
      this._mustWipeVertexAttributes = true;
    }
  }
  bindBuffersDirectly(vertexBuffer, indexBuffer, vertexDeclaration, vertexStrideSize, effect) {
    if (this._cachedVertexBuffers !== vertexBuffer || this._cachedEffectForVertexBuffers !== effect) {
      this._cachedVertexBuffers = vertexBuffer;
      this._cachedEffectForVertexBuffers = effect;
      const attributesCount = effect.getAttributesCount();
      this._unbindVertexArrayObject();
      this.unbindAllAttributes();
      let offset = 0;
      for (let index = 0; index < attributesCount; index++) {
        if (index < vertexDeclaration.length) {
          const order = effect.getAttributeLocation(index);
          if (order >= 0) {
            this._gl.enableVertexAttribArray(order);
            this._vertexAttribArraysEnabled[order] = true;
            this._vertexAttribPointer(vertexBuffer, order, vertexDeclaration[index], this._gl.FLOAT, false, vertexStrideSize, offset);
          }
          offset += vertexDeclaration[index] * 4;
        }
      }
    }
    this._bindIndexBufferWithCache(indexBuffer);
  }
  _unbindVertexArrayObject() {
    if (!this._cachedVertexArrayObject) {
      return;
    }
    this._cachedVertexArrayObject = null;
    this._gl.bindVertexArray(null);
  }
  bindBuffers(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
    if (this._cachedVertexBuffers !== vertexBuffers || this._cachedEffectForVertexBuffers !== effect) {
      this._cachedVertexBuffers = vertexBuffers;
      this._cachedEffectForVertexBuffers = effect;
      this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);
    }
    this._bindIndexBufferWithCache(indexBuffer);
  }
  unbindInstanceAttributes() {
    let boundBuffer;
    for (let i = 0, ul = this._currentInstanceLocations.length; i < ul; i++) {
      const instancesBuffer = this._currentInstanceBuffers[i];
      if (boundBuffer != instancesBuffer && instancesBuffer.references) {
        boundBuffer = instancesBuffer;
        this.bindArrayBuffer(instancesBuffer);
      }
      const offsetLocation = this._currentInstanceLocations[i];
      this._gl.vertexAttribDivisor(offsetLocation, 0);
    }
    this._currentInstanceBuffers.length = 0;
    this._currentInstanceLocations.length = 0;
  }
  releaseVertexArrayObject(vao) {
    this._gl.deleteVertexArray(vao);
  }
  _releaseBuffer(buffer) {
    buffer.references--;
    if (buffer.references === 0) {
      this._deleteBuffer(buffer);
      return true;
    }
    return false;
  }
  _deleteBuffer(buffer) {
    this._gl.deleteBuffer(buffer.underlyingResource);
  }
  updateAndBindInstancesBuffer(instancesBuffer, data, offsetLocations) {
    this.bindArrayBuffer(instancesBuffer);
    if (data) {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
    }
    if (offsetLocations[0].index !== void 0) {
      this.bindInstancesBuffer(instancesBuffer, offsetLocations, true);
    } else {
      for (let index = 0; index < 4; index++) {
        const offsetLocation = offsetLocations[index];
        if (!this._vertexAttribArraysEnabled[offsetLocation]) {
          this._gl.enableVertexAttribArray(offsetLocation);
          this._vertexAttribArraysEnabled[offsetLocation] = true;
        }
        this._vertexAttribPointer(instancesBuffer, offsetLocation, 4, this._gl.FLOAT, false, 64, index * 16);
        this._gl.vertexAttribDivisor(offsetLocation, 1);
        this._currentInstanceLocations.push(offsetLocation);
        this._currentInstanceBuffers.push(instancesBuffer);
      }
    }
  }
  bindInstancesBuffer(instancesBuffer, attributesInfo, computeStride = true) {
    this.bindArrayBuffer(instancesBuffer);
    let stride = 0;
    if (computeStride) {
      for (let i = 0; i < attributesInfo.length; i++) {
        const ai = attributesInfo[i];
        stride += ai.attributeSize * 4;
      }
    }
    for (let i = 0; i < attributesInfo.length; i++) {
      const ai = attributesInfo[i];
      if (ai.index === void 0) {
        ai.index = this._currentEffect.getAttributeLocationByName(ai.attributeName);
      }
      if (ai.index < 0) {
        continue;
      }
      if (!this._vertexAttribArraysEnabled[ai.index]) {
        this._gl.enableVertexAttribArray(ai.index);
        this._vertexAttribArraysEnabled[ai.index] = true;
      }
      this._vertexAttribPointer(instancesBuffer, ai.index, ai.attributeSize, ai.attributeType || this._gl.FLOAT, ai.normalized || false, stride, ai.offset);
      this._gl.vertexAttribDivisor(ai.index, ai.divisor === void 0 ? 1 : ai.divisor);
      this._currentInstanceLocations.push(ai.index);
      this._currentInstanceBuffers.push(instancesBuffer);
    }
  }
  disableInstanceAttributeByName(name63) {
    if (!this._currentEffect) {
      return;
    }
    const attributeLocation = this._currentEffect.getAttributeLocationByName(name63);
    this.disableInstanceAttribute(attributeLocation);
  }
  disableInstanceAttribute(attributeLocation) {
    let shouldClean = false;
    let index;
    while ((index = this._currentInstanceLocations.indexOf(attributeLocation)) !== -1) {
      this._currentInstanceLocations.splice(index, 1);
      this._currentInstanceBuffers.splice(index, 1);
      shouldClean = true;
      index = this._currentInstanceLocations.indexOf(attributeLocation);
    }
    if (shouldClean) {
      this._gl.vertexAttribDivisor(attributeLocation, 0);
      this.disableAttributeByIndex(attributeLocation);
    }
  }
  disableAttributeByIndex(attributeLocation) {
    this._gl.disableVertexAttribArray(attributeLocation);
    this._vertexAttribArraysEnabled[attributeLocation] = false;
    this._currentBufferPointers[attributeLocation].active = false;
  }
  draw(useTriangles, indexStart, indexCount, instancesCount) {
    this.drawElementsType(useTriangles ? 0 : 1, indexStart, indexCount, instancesCount);
  }
  drawPointClouds(verticesStart, verticesCount, instancesCount) {
    this.drawArraysType(2, verticesStart, verticesCount, instancesCount);
  }
  drawUnIndexed(useTriangles, verticesStart, verticesCount, instancesCount) {
    this.drawArraysType(useTriangles ? 0 : 1, verticesStart, verticesCount, instancesCount);
  }
  drawElementsType(fillMode, indexStart, indexCount, instancesCount) {
    this.applyStates();
    this._reportDrawCall();
    const drawMode = this._drawMode(fillMode);
    const indexFormat = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT;
    const mult = this._uintIndicesCurrentlySet ? 4 : 2;
    if (instancesCount) {
      this._gl.drawElementsInstanced(drawMode, indexCount, indexFormat, indexStart * mult, instancesCount);
    } else {
      this._gl.drawElements(drawMode, indexCount, indexFormat, indexStart * mult);
    }
  }
  drawArraysType(fillMode, verticesStart, verticesCount, instancesCount) {
    this.applyStates();
    this._reportDrawCall();
    const drawMode = this._drawMode(fillMode);
    if (instancesCount) {
      this._gl.drawArraysInstanced(drawMode, verticesStart, verticesCount, instancesCount);
    } else {
      this._gl.drawArrays(drawMode, verticesStart, verticesCount);
    }
  }
  _drawMode(fillMode) {
    switch (fillMode) {
      case 0:
        return this._gl.TRIANGLES;
      case 2:
        return this._gl.POINTS;
      case 1:
        return this._gl.LINES;
      case 3:
        return this._gl.POINTS;
      case 4:
        return this._gl.LINES;
      case 5:
        return this._gl.LINE_LOOP;
      case 6:
        return this._gl.LINE_STRIP;
      case 7:
        return this._gl.TRIANGLE_STRIP;
      case 8:
        return this._gl.TRIANGLE_FAN;
      default:
        return this._gl.TRIANGLES;
    }
  }
  _reportDrawCall() {
  }
  _releaseEffect(effect) {
    if (this._compiledEffects[effect._key]) {
      delete this._compiledEffects[effect._key];
    }
    const pipelineContext = effect.getPipelineContext();
    if (pipelineContext) {
      this._deletePipelineContext(pipelineContext);
    }
  }
  _deletePipelineContext(pipelineContext) {
    const webGLPipelineContext = pipelineContext;
    if (webGLPipelineContext && webGLPipelineContext.program) {
      webGLPipelineContext.program.__SPECTOR_rebuildProgram = null;
      this._gl.deleteProgram(webGLPipelineContext.program);
    }
  }
  _getGlobalDefines(defines) {
    if (defines) {
      if (this.isNDCHalfZRange) {
        defines["IS_NDC_HALF_ZRANGE"] = "";
      } else {
        delete defines["IS_NDC_HALF_ZRANGE"];
      }
      if (this.useReverseDepthBuffer) {
        defines["USE_REVERSE_DEPTHBUFFER"] = "";
      } else {
        delete defines["USE_REVERSE_DEPTHBUFFER"];
      }
      if (this.useExactSrgbConversions) {
        defines["USE_EXACT_SRGB_CONVERSIONS"] = "";
      } else {
        delete defines["USE_EXACT_SRGB_CONVERSIONS"];
      }
      return;
    } else {
      let s = "";
      if (this.isNDCHalfZRange) {
        s += "#define IS_NDC_HALF_ZRANGE";
      }
      if (this.useReverseDepthBuffer) {
        if (s) {
          s += "\n";
        }
        s += "#define USE_REVERSE_DEPTHBUFFER";
      }
      if (this.useExactSrgbConversions) {
        if (s) {
          s += "\n";
        }
        s += "#define USE_EXACT_SRGB_CONVERSIONS";
      }
      return s;
    }
  }
  createEffect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters, shaderLanguage = ShaderLanguage.GLSL) {
    var _a;
    const vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;
    const fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;
    const globalDefines = this._getGlobalDefines();
    let fullDefines = (_a = defines !== null && defines !== void 0 ? defines : attributesNamesOrOptions.defines) !== null && _a !== void 0 ? _a : "";
    if (globalDefines) {
      fullDefines += globalDefines;
    }
    const name63 = vertex + "+" + fragment + "@" + fullDefines;
    if (this._compiledEffects[name63]) {
      const compiledEffect = this._compiledEffects[name63];
      if (onCompiled && compiledEffect.isReady()) {
        onCompiled(compiledEffect);
      }
      return compiledEffect;
    }
    const effect = new Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters, name63, shaderLanguage);
    this._compiledEffects[name63] = effect;
    return effect;
  }
  static _ConcatenateShader(source, defines, shaderVersion = "") {
    return shaderVersion + (defines ? defines + "\n" : "") + source;
  }
  _compileShader(source, type, defines, shaderVersion) {
    return this._compileRawShader(ThinEngine._ConcatenateShader(source, defines, shaderVersion), type);
  }
  _compileRawShader(source, type) {
    const gl = this._gl;
    const shader63 = gl.createShader(type === "vertex" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
    if (!shader63) {
      let error = gl.NO_ERROR;
      let tempError = gl.NO_ERROR;
      while ((tempError = gl.getError()) !== gl.NO_ERROR) {
        error = tempError;
      }
      throw new Error(`Something went wrong while creating a gl ${type} shader object. gl error=${error}, gl isContextLost=${gl.isContextLost()}, _contextWasLost=${this._contextWasLost}`);
    }
    gl.shaderSource(shader63, source);
    gl.compileShader(shader63);
    return shader63;
  }
  _getShaderSource(shader63) {
    return this._gl.getShaderSource(shader63);
  }
  createRawShaderProgram(pipelineContext, vertexCode, fragmentCode, context, transformFeedbackVaryings = null) {
    context = context || this._gl;
    const vertexShader = this._compileRawShader(vertexCode, "vertex");
    const fragmentShader = this._compileRawShader(fragmentCode, "fragment");
    return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);
  }
  createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings = null) {
    context = context || this._gl;
    const shaderVersion = this._webGLVersion > 1 ? "#version 300 es\n#define WEBGL2 \n" : "";
    const vertexShader = this._compileShader(vertexCode, "vertex", defines, shaderVersion);
    const fragmentShader = this._compileShader(fragmentCode, "fragment", defines, shaderVersion);
    return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);
  }
  inlineShaderCode(code) {
    return code;
  }
  createPipelineContext(shaderProcessingContext) {
    const pipelineContext = new WebGLPipelineContext();
    pipelineContext.engine = this;
    if (this._caps.parallelShaderCompile) {
      pipelineContext.isParallelCompiled = true;
    }
    return pipelineContext;
  }
  createMaterialContext() {
    return void 0;
  }
  createDrawContext() {
    return void 0;
  }
  _createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings = null) {
    const shaderProgram = context.createProgram();
    pipelineContext.program = shaderProgram;
    if (!shaderProgram) {
      throw new Error("Unable to create program");
    }
    context.attachShader(shaderProgram, vertexShader);
    context.attachShader(shaderProgram, fragmentShader);
    context.linkProgram(shaderProgram);
    pipelineContext.context = context;
    pipelineContext.vertexShader = vertexShader;
    pipelineContext.fragmentShader = fragmentShader;
    if (!pipelineContext.isParallelCompiled) {
      this._finalizePipelineContext(pipelineContext);
    }
    return shaderProgram;
  }
  _finalizePipelineContext(pipelineContext) {
    const context = pipelineContext.context;
    const vertexShader = pipelineContext.vertexShader;
    const fragmentShader = pipelineContext.fragmentShader;
    const program = pipelineContext.program;
    const linked = context.getProgramParameter(program, context.LINK_STATUS);
    if (!linked) {
      if (!this._gl.getShaderParameter(vertexShader, this._gl.COMPILE_STATUS)) {
        const log = this._gl.getShaderInfoLog(vertexShader);
        if (log) {
          pipelineContext.vertexCompilationError = log;
          throw new Error("VERTEX SHADER " + log);
        }
      }
      if (!this._gl.getShaderParameter(fragmentShader, this._gl.COMPILE_STATUS)) {
        const log = this._gl.getShaderInfoLog(fragmentShader);
        if (log) {
          pipelineContext.fragmentCompilationError = log;
          throw new Error("FRAGMENT SHADER " + log);
        }
      }
      const error = context.getProgramInfoLog(program);
      if (error) {
        pipelineContext.programLinkError = error;
        throw new Error(error);
      }
    }
    if (this.validateShaderPrograms) {
      context.validateProgram(program);
      const validated = context.getProgramParameter(program, context.VALIDATE_STATUS);
      if (!validated) {
        const error = context.getProgramInfoLog(program);
        if (error) {
          pipelineContext.programValidationError = error;
          throw new Error(error);
        }
      }
    }
    context.deleteShader(vertexShader);
    context.deleteShader(fragmentShader);
    pipelineContext.vertexShader = void 0;
    pipelineContext.fragmentShader = void 0;
    if (pipelineContext.onCompiled) {
      pipelineContext.onCompiled();
      pipelineContext.onCompiled = void 0;
    }
  }
  _preparePipelineContext(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rawVertexSourceCode, rawFragmentSourceCode, rebuildRebind, defines, transformFeedbackVaryings, key) {
    const webGLRenderingState = pipelineContext;
    if (createAsRaw) {
      webGLRenderingState.program = this.createRawShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, void 0, transformFeedbackVaryings);
    } else {
      webGLRenderingState.program = this.createShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, defines, void 0, transformFeedbackVaryings);
    }
    webGLRenderingState.program.__SPECTOR_rebuildProgram = rebuildRebind;
  }
  _isRenderingStateCompiled(pipelineContext) {
    const webGLPipelineContext = pipelineContext;
    if (this._gl.getProgramParameter(webGLPipelineContext.program, this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR)) {
      this._finalizePipelineContext(webGLPipelineContext);
      return true;
    }
    return false;
  }
  _executeWhenRenderingStateIsCompiled(pipelineContext, action) {
    const webGLPipelineContext = pipelineContext;
    if (!webGLPipelineContext.isParallelCompiled) {
      action();
      return;
    }
    const oldHandler = webGLPipelineContext.onCompiled;
    if (oldHandler) {
      webGLPipelineContext.onCompiled = () => {
        oldHandler();
        action();
      };
    } else {
      webGLPipelineContext.onCompiled = action;
    }
  }
  getUniforms(pipelineContext, uniformsNames) {
    const results = new Array();
    const webGLPipelineContext = pipelineContext;
    for (let index = 0; index < uniformsNames.length; index++) {
      results.push(this._gl.getUniformLocation(webGLPipelineContext.program, uniformsNames[index]));
    }
    return results;
  }
  getAttributes(pipelineContext, attributesNames) {
    const results = [];
    const webGLPipelineContext = pipelineContext;
    for (let index = 0; index < attributesNames.length; index++) {
      try {
        results.push(this._gl.getAttribLocation(webGLPipelineContext.program, attributesNames[index]));
      } catch (e) {
        results.push(-1);
      }
    }
    return results;
  }
  enableEffect(effect) {
    effect = effect !== null && DrawWrapper.IsWrapper(effect) ? effect.effect : effect;
    if (!effect || effect === this._currentEffect) {
      return;
    }
    this._stencilStateComposer.stencilMaterial = void 0;
    effect = effect;
    this.bindSamplers(effect);
    this._currentEffect = effect;
    if (effect.onBind) {
      effect.onBind(effect);
    }
    if (effect._onBindObservable) {
      effect._onBindObservable.notifyObservers(effect);
    }
  }
  setInt(uniform, value) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1i(uniform, value);
    return true;
  }
  setInt2(uniform, x, y) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform2i(uniform, x, y);
    return true;
  }
  setInt3(uniform, x, y, z) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform3i(uniform, x, y, z);
    return true;
  }
  setInt4(uniform, x, y, z, w) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform4i(uniform, x, y, z, w);
    return true;
  }
  setIntArray(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1iv(uniform, array);
    return true;
  }
  setIntArray2(uniform, array) {
    if (!uniform || array.length % 2 !== 0) {
      return false;
    }
    this._gl.uniform2iv(uniform, array);
    return true;
  }
  setIntArray3(uniform, array) {
    if (!uniform || array.length % 3 !== 0) {
      return false;
    }
    this._gl.uniform3iv(uniform, array);
    return true;
  }
  setIntArray4(uniform, array) {
    if (!uniform || array.length % 4 !== 0) {
      return false;
    }
    this._gl.uniform4iv(uniform, array);
    return true;
  }
  setArray(uniform, array) {
    if (!uniform) {
      return false;
    }
    if (array.length < 1) {
      return false;
    }
    this._gl.uniform1fv(uniform, array);
    return true;
  }
  setArray2(uniform, array) {
    if (!uniform || array.length % 2 !== 0) {
      return false;
    }
    this._gl.uniform2fv(uniform, array);
    return true;
  }
  setArray3(uniform, array) {
    if (!uniform || array.length % 3 !== 0) {
      return false;
    }
    this._gl.uniform3fv(uniform, array);
    return true;
  }
  setArray4(uniform, array) {
    if (!uniform || array.length % 4 !== 0) {
      return false;
    }
    this._gl.uniform4fv(uniform, array);
    return true;
  }
  setMatrices(uniform, matrices) {
    if (!uniform) {
      return false;
    }
    this._gl.uniformMatrix4fv(uniform, false, matrices);
    return true;
  }
  setMatrix3x3(uniform, matrix) {
    if (!uniform) {
      return false;
    }
    this._gl.uniformMatrix3fv(uniform, false, matrix);
    return true;
  }
  setMatrix2x2(uniform, matrix) {
    if (!uniform) {
      return false;
    }
    this._gl.uniformMatrix2fv(uniform, false, matrix);
    return true;
  }
  setFloat(uniform, value) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1f(uniform, value);
    return true;
  }
  setFloat2(uniform, x, y) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform2f(uniform, x, y);
    return true;
  }
  setFloat3(uniform, x, y, z) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform3f(uniform, x, y, z);
    return true;
  }
  setFloat4(uniform, x, y, z, w) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform4f(uniform, x, y, z, w);
    return true;
  }
  applyStates() {
    this._depthCullingState.apply(this._gl);
    this._stencilStateComposer.apply(this._gl);
    this._alphaState.apply(this._gl);
    if (this._colorWriteChanged) {
      this._colorWriteChanged = false;
      const enable = this._colorWrite;
      this._gl.colorMask(enable, enable, enable, enable);
    }
  }
  setColorWrite(enable) {
    if (enable !== this._colorWrite) {
      this._colorWriteChanged = true;
      this._colorWrite = enable;
    }
  }
  getColorWrite() {
    return this._colorWrite;
  }
  get depthCullingState() {
    return this._depthCullingState;
  }
  get alphaState() {
    return this._alphaState;
  }
  get stencilState() {
    return this._stencilState;
  }
  get stencilStateComposer() {
    return this._stencilStateComposer;
  }
  clearInternalTexturesCache() {
    this._internalTexturesCache.length = 0;
  }
  wipeCaches(bruteForce) {
    if (this.preventCacheWipeBetweenFrames && !bruteForce) {
      return;
    }
    this._currentEffect = null;
    this._viewportCached.x = 0;
    this._viewportCached.y = 0;
    this._viewportCached.z = 0;
    this._viewportCached.w = 0;
    this._unbindVertexArrayObject();
    if (bruteForce) {
      this._currentProgram = null;
      this.resetTextureCache();
      this._stencilStateComposer.reset();
      this._depthCullingState.reset();
      this._depthCullingState.depthFunc = this._gl.LEQUAL;
      this._alphaState.reset();
      this._alphaMode = 1;
      this._alphaEquation = 0;
      this._colorWrite = true;
      this._colorWriteChanged = true;
      this._unpackFlipYCached = null;
      this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
      this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
      this._mustWipeVertexAttributes = true;
      this.unbindAllAttributes();
    }
    this._resetVertexBufferBinding();
    this._cachedIndexBuffer = null;
    this._cachedEffectForVertexBuffers = null;
    this.bindIndexBuffer(null);
  }
  _getSamplingParameters(samplingMode, generateMipMaps) {
    const gl = this._gl;
    let magFilter = gl.NEAREST;
    let minFilter = gl.NEAREST;
    switch (samplingMode) {
      case 11:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_NEAREST;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 3:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_LINEAR;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 8:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_LINEAR;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 4:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_NEAREST;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 5:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_NEAREST;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 6:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_LINEAR;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 7:
        magFilter = gl.NEAREST;
        minFilter = gl.LINEAR;
        break;
      case 1:
        magFilter = gl.NEAREST;
        minFilter = gl.NEAREST;
        break;
      case 9:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_NEAREST;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 10:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_LINEAR;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 2:
        magFilter = gl.LINEAR;
        minFilter = gl.LINEAR;
        break;
      case 12:
        magFilter = gl.LINEAR;
        minFilter = gl.NEAREST;
        break;
    }
    return {
      min: minFilter,
      mag: magFilter
    };
  }
  _createTexture() {
    const texture = this._gl.createTexture();
    if (!texture) {
      throw new Error("Unable to create texture");
    }
    return texture;
  }
  _createHardwareTexture() {
    return new WebGLHardwareTexture(this._createTexture(), this._gl);
  }
  _createInternalTexture(size, options, delayGPUTextureCreation = true, source = InternalTextureSource.Unknown) {
    var _a;
    let generateMipMaps = false;
    let type = 0;
    let samplingMode = 3;
    let format = 5;
    let useSRGBBuffer = false;
    let samples = 1;
    if (options !== void 0 && typeof options === "object") {
      generateMipMaps = !!options.generateMipMaps;
      type = options.type === void 0 ? 0 : options.type;
      samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
      format = options.format === void 0 ? 5 : options.format;
      useSRGBBuffer = options.useSRGBBuffer === void 0 ? false : options.useSRGBBuffer;
      samples = (_a = options.samples) !== null && _a !== void 0 ? _a : 1;
    } else {
      generateMipMaps = !!options;
    }
    useSRGBBuffer && (useSRGBBuffer = this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU));
    if (type === 1 && !this._caps.textureFloatLinearFiltering) {
      samplingMode = 1;
    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
      samplingMode = 1;
    }
    if (type === 1 && !this._caps.textureFloat) {
      type = 0;
      Logger.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE");
    }
    const gl = this._gl;
    const texture = new InternalTexture(this, source);
    const width = size.width || size;
    const height = size.height || size;
    const layers = size.layers || 0;
    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
    const target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
    const sizedFormat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);
    const internalFormat = this._getInternalFormat(format);
    const textureType = this._getWebGLTextureType(type);
    this._bindTextureDirectly(target, texture);
    if (layers !== 0) {
      texture.is2DArray = true;
      gl.texImage3D(target, 0, sizedFormat, width, height, layers, 0, internalFormat, textureType, null);
    } else {
      gl.texImage2D(target, 0, sizedFormat, width, height, 0, internalFormat, textureType, null);
    }
    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);
    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);
    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    if (generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    texture._useSRGBBuffer = useSRGBBuffer;
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.depth = layers;
    texture.isReady = true;
    texture.samples = samples;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    texture.type = type;
    texture.format = format;
    this._internalTexturesCache.push(texture);
    return texture;
  }
  _getUseSRGBBuffer(useSRGBBuffer, noMipmap) {
    return useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || noMipmap);
  }
  _createTextureBase(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, prepareTexture, prepareTextureProcessFunction, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, useSRGBBuffer) {
    url = url || "";
    const fromData = url.substr(0, 5) === "data:";
    const fromBlob = url.substr(0, 5) === "blob:";
    const isBase64 = fromData && url.indexOf(";base64,") !== -1;
    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);
    const originalUrl = url;
    if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {
      url = this._transformTextureUrl(url);
    }
    if (originalUrl !== url) {
      texture._originalUrl = originalUrl;
    }
    const lastDot = url.lastIndexOf(".");
    let extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : "";
    let loader = null;
    const queryStringIndex = extension.indexOf("?");
    if (queryStringIndex > -1) {
      extension = extension.split("?")[0];
    }
    for (const availableLoader of ThinEngine._TextureLoaders) {
      if (availableLoader.canLoad(extension, mimeType)) {
        loader = availableLoader;
        break;
      }
    }
    if (scene) {
      scene.addPendingData(texture);
    }
    texture.url = url;
    texture.generateMipMaps = !noMipmap;
    texture.samplingMode = samplingMode;
    texture.invertY = invertY;
    texture._useSRGBBuffer = this._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);
    if (!this._doNotHandleContextLost) {
      texture._buffer = buffer;
    }
    let onLoadObserver = null;
    if (onLoad && !fallback) {
      onLoadObserver = texture.onLoadedObservable.add(onLoad);
    }
    if (!fallback) {
      this._internalTexturesCache.push(texture);
    }
    const onInternalError = (message, exception) => {
      if (scene) {
        scene.removePendingData(texture);
      }
      if (url === originalUrl) {
        if (onLoadObserver) {
          texture.onLoadedObservable.remove(onLoadObserver);
        }
        if (EngineStore.UseFallbackTexture) {
          this._createTextureBase(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, prepareTexture, prepareTextureProcessFunction, buffer, texture);
        }
        message = (message || "Unknown error") + (EngineStore.UseFallbackTexture ? " - Fallback texture was used" : "");
        texture.onErrorObservable.notifyObservers({ message, exception });
        if (onError) {
          onError(message, exception);
        }
      } else {
        Logger.Warn(`Failed to load ${url}, falling back to ${originalUrl}`);
        this._createTextureBase(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, prepareTexture, prepareTextureProcessFunction, buffer, texture, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);
      }
    };
    if (loader) {
      const callback = (data) => {
        loader.loadData(data, texture, (width, height, loadMipmap, isCompressed, done, loadFailed) => {
          if (loadFailed) {
            onInternalError("TextureLoader failed to load data");
          } else {
            prepareTexture(texture, extension, scene, { width, height }, texture.invertY, !loadMipmap, isCompressed, () => {
              done();
              return false;
            }, samplingMode);
          }
        }, loaderOptions);
      };
      if (!buffer) {
        this._loadFile(url, (data) => callback(new Uint8Array(data)), void 0, scene ? scene.offlineProvider : void 0, true, (request, exception) => {
          onInternalError("Unable to load " + (request ? request.responseURL : url, exception));
        });
      } else {
        if (buffer instanceof ArrayBuffer) {
          callback(new Uint8Array(buffer));
        } else if (ArrayBuffer.isView(buffer)) {
          callback(buffer);
        } else {
          if (onError) {
            onError("Unable to load: only ArrayBuffer or ArrayBufferView is supported", null);
          }
        }
      }
    } else {
      const onload = (img) => {
        if (fromBlob && !this._doNotHandleContextLost) {
          texture._buffer = img;
        }
        prepareTexture(texture, extension, scene, img, texture.invertY, noMipmap, false, prepareTextureProcessFunction, samplingMode);
      };
      if (!fromData || isBase64) {
        if (buffer && (typeof buffer.decoding === "string" || buffer.close)) {
          onload(buffer);
        } else {
          ThinEngine._FileToolsLoadImage(url, onload, onInternalError, scene ? scene.offlineProvider : null, mimeType, texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0);
        }
      } else if (typeof buffer === "string" || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer) || buffer instanceof Blob) {
        ThinEngine._FileToolsLoadImage(buffer, onload, onInternalError, scene ? scene.offlineProvider : null, mimeType, texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0);
      } else if (buffer) {
        onload(buffer);
      }
    }
    return texture;
  }
  createTexture(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, creationFlags, useSRGBBuffer) {
    return this._createTextureBase(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, this._prepareWebGLTexture.bind(this), (potWidth, potHeight, img, extension, texture, continuationCallback) => {
      const gl = this._gl;
      const isPot = img.width === potWidth && img.height === potHeight;
      const internalFormat = format ? this._getInternalFormat(format, texture._useSRGBBuffer) : extension === ".jpg" && !texture._useSRGBBuffer ? gl.RGB : texture._useSRGBBuffer ? gl.SRGB8_ALPHA8 : gl.RGBA;
      let texelFormat = format ? this._getInternalFormat(format) : extension === ".jpg" && !texture._useSRGBBuffer ? gl.RGB : gl.RGBA;
      if (texture._useSRGBBuffer && this.webGLVersion === 1) {
        texelFormat = internalFormat;
      }
      if (isPot) {
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, img);
        return false;
      }
      const maxTextureSize = this._caps.maxTextureSize;
      if (img.width > maxTextureSize || img.height > maxTextureSize || !this._supportsHardwareTextureRescaling) {
        this._prepareWorkingCanvas();
        if (!this._workingCanvas || !this._workingContext) {
          return false;
        }
        this._workingCanvas.width = potWidth;
        this._workingCanvas.height = potHeight;
        this._workingContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, potWidth, potHeight);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, this._workingCanvas);
        texture.width = potWidth;
        texture.height = potHeight;
        return false;
      } else {
        const source = new InternalTexture(this, InternalTextureSource.Temp);
        this._bindTextureDirectly(gl.TEXTURE_2D, source, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, img);
        this._rescaleTexture(source, texture, scene, internalFormat, () => {
          this._releaseTexture(source);
          this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
          continuationCallback();
        });
      }
      return true;
    }, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);
  }
  static _FileToolsLoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
    throw _WarnImport("FileTools");
  }
  _rescaleTexture(source, destination, scene, internalFormat, onComplete) {
  }
  createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {
    throw _WarnImport("Engine.RawTexture");
  }
  createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression = null) {
    throw _WarnImport("Engine.RawTexture");
  }
  createRawTexture3D(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {
    throw _WarnImport("Engine.RawTexture");
  }
  createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {
    throw _WarnImport("Engine.RawTexture");
  }
  _unpackFlipY(value) {
    if (this._unpackFlipYCached !== value) {
      this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, value ? 1 : 0);
      if (this.enableUnpackFlipYCached) {
        this._unpackFlipYCached = value;
      }
    }
  }
  _getUnpackAlignement() {
    return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT);
  }
  _getTextureTarget(texture) {
    if (texture.isCube) {
      return this._gl.TEXTURE_CUBE_MAP;
    } else if (texture.is3D) {
      return this._gl.TEXTURE_3D;
    } else if (texture.is2DArray || texture.isMultiview) {
      return this._gl.TEXTURE_2D_ARRAY;
    }
    return this._gl.TEXTURE_2D;
  }
  updateTextureSamplingMode(samplingMode, texture, generateMipMaps = false) {
    const target = this._getTextureTarget(texture);
    const filters = this._getSamplingParameters(samplingMode, texture.generateMipMaps || generateMipMaps);
    this._setTextureParameterInteger(target, this._gl.TEXTURE_MAG_FILTER, filters.mag, texture);
    this._setTextureParameterInteger(target, this._gl.TEXTURE_MIN_FILTER, filters.min);
    if (generateMipMaps) {
      texture.generateMipMaps = true;
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    texture.samplingMode = samplingMode;
  }
  updateTextureDimensions(texture, width, height, depth = 1) {
  }
  updateTextureWrappingMode(texture, wrapU, wrapV = null, wrapR = null) {
    const target = this._getTextureTarget(texture);
    if (wrapU !== null) {
      this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(wrapU), texture);
      texture._cachedWrapU = wrapU;
    }
    if (wrapV !== null) {
      this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(wrapV), texture);
      texture._cachedWrapV = wrapV;
    }
    if ((texture.is2DArray || texture.is3D) && wrapR !== null) {
      this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(wrapR), texture);
      texture._cachedWrapR = wrapR;
    }
    this._bindTextureDirectly(target, null);
  }
  _setupDepthStencilTexture(internalTexture, size, generateStencil, bilinearFiltering, comparisonFunction, samples = 1) {
    const width = size.width || size;
    const height = size.height || size;
    const layers = size.layers || 0;
    internalTexture.baseWidth = width;
    internalTexture.baseHeight = height;
    internalTexture.width = width;
    internalTexture.height = height;
    internalTexture.is2DArray = layers > 0;
    internalTexture.depth = layers;
    internalTexture.isReady = true;
    internalTexture.samples = samples;
    internalTexture.generateMipMaps = false;
    internalTexture.samplingMode = bilinearFiltering ? 2 : 1;
    internalTexture.type = 0;
    internalTexture._comparisonFunction = comparisonFunction;
    const gl = this._gl;
    const target = this._getTextureTarget(internalTexture);
    const samplingParameters = this._getSamplingParameters(internalTexture.samplingMode, false);
    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, samplingParameters.mag);
    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, samplingParameters.min);
    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    if (this.webGLVersion > 1) {
      if (comparisonFunction === 0) {
        gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, 515);
        gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.NONE);
      } else {
        gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
        gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
      }
    }
  }
  _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, data, faceIndex = 0, lod = 0) {
    const gl = this._gl;
    let target = gl.TEXTURE_2D;
    if (texture.isCube) {
      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    if (texture._useSRGBBuffer) {
      switch (internalFormat) {
        case 37492:
        case 36196:
          if (this._caps.etc2) {
            internalFormat = gl.COMPRESSED_SRGB8_ETC2;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        case 37496:
          if (this._caps.etc2) {
            internalFormat = gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        case 36492:
          internalFormat = gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
          break;
        case 37808:
          internalFormat = gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
          break;
        case 33776:
          if (this._caps.s3tc_srgb) {
            internalFormat = gl.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        case 33777:
          if (this._caps.s3tc_srgb) {
            internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        case 33779:
          if (this._caps.s3tc_srgb) {
            internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        default:
          texture._useSRGBBuffer = false;
          break;
      }
    }
    this._gl.compressedTexImage2D(target, lod, internalFormat, width, height, 0, data);
  }
  _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0, babylonInternalFormat, useTextureWidthAndHeight = false) {
    const gl = this._gl;
    const textureType = this._getWebGLTextureType(texture.type);
    const format = this._getInternalFormat(texture.format);
    const internalFormat = babylonInternalFormat === void 0 ? this._getRGBABufferInternalSizedFormat(texture.type, texture.format, texture._useSRGBBuffer) : this._getInternalFormat(babylonInternalFormat, texture._useSRGBBuffer);
    this._unpackFlipY(texture.invertY);
    let target = gl.TEXTURE_2D;
    if (texture.isCube) {
      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    const lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);
    const lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);
    const width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));
    const height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));
    gl.texImage2D(target, lod, internalFormat, width, height, 0, format, textureType, imageData);
  }
  updateTextureData(texture, imageData, xOffset, yOffset, width, height, faceIndex = 0, lod = 0, generateMipMaps = false) {
    const gl = this._gl;
    const textureType = this._getWebGLTextureType(texture.type);
    const format = this._getInternalFormat(texture.format);
    this._unpackFlipY(texture.invertY);
    let targetForBinding = gl.TEXTURE_2D;
    let target = gl.TEXTURE_2D;
    if (texture.isCube) {
      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
      targetForBinding = gl.TEXTURE_CUBE_MAP;
    }
    this._bindTextureDirectly(targetForBinding, texture, true);
    gl.texSubImage2D(target, lod, xOffset, yOffset, width, height, format, textureType, imageData);
    if (generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(targetForBinding, null);
  }
  _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {
    const gl = this._gl;
    const bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
    this._bindTextureDirectly(bindTarget, texture, true);
    this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);
    this._bindTextureDirectly(bindTarget, null, true);
  }
  _prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode) {
    const gl = this._gl;
    if (!gl) {
      return;
    }
    const filters = this._getSamplingParameters(samplingMode, !noMipmap);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);
    if (!noMipmap && !isCompressed) {
      gl.generateMipmap(gl.TEXTURE_2D);
    }
    this._bindTextureDirectly(gl.TEXTURE_2D, null);
    if (scene) {
      scene.removePendingData(texture);
    }
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
  }
  _prepareWebGLTexture(texture, extension, scene, img, invertY, noMipmap, isCompressed, processFunction, samplingMode = 3) {
    const maxTextureSize = this.getCaps().maxTextureSize;
    const potWidth = Math.min(maxTextureSize, this.needPOTTextures ? ThinEngine.GetExponentOfTwo(img.width, maxTextureSize) : img.width);
    const potHeight = Math.min(maxTextureSize, this.needPOTTextures ? ThinEngine.GetExponentOfTwo(img.height, maxTextureSize) : img.height);
    const gl = this._gl;
    if (!gl) {
      return;
    }
    if (!texture._hardwareTexture) {
      if (scene) {
        scene.removePendingData(texture);
      }
      return;
    }
    this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
    this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
    texture.baseWidth = img.width;
    texture.baseHeight = img.height;
    texture.width = potWidth;
    texture.height = potHeight;
    texture.isReady = true;
    if (processFunction(potWidth, potHeight, img, extension, texture, () => {
      this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
    })) {
      return;
    }
    this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
  }
  _setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height, samples = 1) {
    const gl = this._gl;
    if (generateStencilBuffer && generateDepthBuffer) {
      return this._createRenderBuffer(width, height, samples, gl.DEPTH_STENCIL, gl.DEPTH24_STENCIL8, gl.DEPTH_STENCIL_ATTACHMENT);
    }
    if (generateDepthBuffer) {
      let depthFormat = gl.DEPTH_COMPONENT16;
      if (this._webGLVersion > 1) {
        depthFormat = gl.DEPTH_COMPONENT32F;
      }
      return this._createRenderBuffer(width, height, samples, depthFormat, depthFormat, gl.DEPTH_ATTACHMENT);
    }
    if (generateStencilBuffer) {
      return this._createRenderBuffer(width, height, samples, gl.STENCIL_INDEX8, gl.STENCIL_INDEX8, gl.STENCIL_ATTACHMENT);
    }
    return null;
  }
  _createRenderBuffer(width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer = true) {
    const gl = this._gl;
    const renderBuffer = gl.createRenderbuffer();
    return this._updateRenderBuffer(renderBuffer, width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer);
  }
  _updateRenderBuffer(renderBuffer, width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer = true) {
    const gl = this._gl;
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);
    if (samples > 1 && gl.renderbufferStorageMultisample) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, msInternalFormat, width, height);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
    }
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, renderBuffer);
    if (unbindBuffer) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    }
    return renderBuffer;
  }
  _releaseTexture(texture) {
    var _a;
    this._deleteTexture((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource);
    this.unbindAllTextures();
    const index = this._internalTexturesCache.indexOf(texture);
    if (index !== -1) {
      this._internalTexturesCache.splice(index, 1);
    }
    if (texture._lodTextureHigh) {
      texture._lodTextureHigh.dispose();
    }
    if (texture._lodTextureMid) {
      texture._lodTextureMid.dispose();
    }
    if (texture._lodTextureLow) {
      texture._lodTextureLow.dispose();
    }
    if (texture._irradianceTexture) {
      texture._irradianceTexture.dispose();
    }
  }
  _releaseRenderTargetWrapper(rtWrapper) {
    const index = this._renderTargetWrapperCache.indexOf(rtWrapper);
    if (index !== -1) {
      this._renderTargetWrapperCache.splice(index, 1);
    }
  }
  _deleteTexture(texture) {
    if (texture) {
      this._gl.deleteTexture(texture);
    }
  }
  _setProgram(program) {
    if (this._currentProgram !== program) {
      this._gl.useProgram(program);
      this._currentProgram = program;
    }
  }
  bindSamplers(effect) {
    const webGLPipelineContext = effect.getPipelineContext();
    this._setProgram(webGLPipelineContext.program);
    const samplers = effect.getSamplers();
    for (let index = 0; index < samplers.length; index++) {
      const uniform = effect.getUniform(samplers[index]);
      if (uniform) {
        this._boundUniforms[index] = uniform;
      }
    }
    this._currentEffect = null;
  }
  _activateCurrentTexture() {
    if (this._currentTextureChannel !== this._activeChannel) {
      this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel);
      this._currentTextureChannel = this._activeChannel;
    }
  }
  _bindTextureDirectly(target, texture, forTextureDataUpdate = false, force = false) {
    var _a, _b;
    let wasPreviouslyBound = false;
    const isTextureForRendering = texture && texture._associatedChannel > -1;
    if (forTextureDataUpdate && isTextureForRendering) {
      this._activeChannel = texture._associatedChannel;
    }
    const currentTextureBound = this._boundTexturesCache[this._activeChannel];
    if (currentTextureBound !== texture || force) {
      this._activateCurrentTexture();
      if (texture && texture.isMultiview) {
        console.error(target, texture);
        throw "_bindTextureDirectly called with a multiview texture!";
      } else {
        this._gl.bindTexture(target, (_b = (_a = texture === null || texture === void 0 ? void 0 : texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource) !== null && _b !== void 0 ? _b : null);
      }
      this._boundTexturesCache[this._activeChannel] = texture;
      if (texture) {
        texture._associatedChannel = this._activeChannel;
      }
    } else if (forTextureDataUpdate) {
      wasPreviouslyBound = true;
      this._activateCurrentTexture();
    }
    if (isTextureForRendering && !forTextureDataUpdate) {
      this._bindSamplerUniformToChannel(texture._associatedChannel, this._activeChannel);
    }
    return wasPreviouslyBound;
  }
  _bindTexture(channel, texture, name63) {
    if (channel === void 0) {
      return;
    }
    if (texture) {
      texture._associatedChannel = channel;
    }
    this._activeChannel = channel;
    const target = texture ? this._getTextureTarget(texture) : this._gl.TEXTURE_2D;
    this._bindTextureDirectly(target, texture);
  }
  unbindAllTextures() {
    for (let channel = 0; channel < this._maxSimultaneousTextures; channel++) {
      this._activeChannel = channel;
      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
      if (this.webGLVersion > 1) {
        this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
        this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
      }
    }
  }
  setTexture(channel, uniform, texture, name63) {
    if (channel === void 0) {
      return;
    }
    if (uniform) {
      this._boundUniforms[channel] = uniform;
    }
    this._setTexture(channel, texture);
  }
  _bindSamplerUniformToChannel(sourceSlot, destination) {
    const uniform = this._boundUniforms[sourceSlot];
    if (!uniform || uniform._currentState === destination) {
      return;
    }
    this._gl.uniform1i(uniform, destination);
    uniform._currentState = destination;
  }
  _getTextureWrapMode(mode) {
    switch (mode) {
      case 1:
        return this._gl.REPEAT;
      case 0:
        return this._gl.CLAMP_TO_EDGE;
      case 2:
        return this._gl.MIRRORED_REPEAT;
    }
    return this._gl.REPEAT;
  }
  _setTexture(channel, texture, isPartOfTextureArray = false, depthStencilTexture = false, name63 = "") {
    if (!texture) {
      if (this._boundTexturesCache[channel] != null) {
        this._activeChannel = channel;
        this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
        this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
        if (this.webGLVersion > 1) {
          this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
          this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
        }
      }
      return false;
    }
    if (texture.video) {
      this._activeChannel = channel;
      texture.update();
    } else if (texture.delayLoadState === 4) {
      texture.delayLoad();
      return false;
    }
    let internalTexture;
    if (depthStencilTexture) {
      internalTexture = texture.depthStencilTexture;
    } else if (texture.isReady()) {
      internalTexture = texture.getInternalTexture();
    } else if (texture.isCube) {
      internalTexture = this.emptyCubeTexture;
    } else if (texture.is3D) {
      internalTexture = this.emptyTexture3D;
    } else if (texture.is2DArray) {
      internalTexture = this.emptyTexture2DArray;
    } else {
      internalTexture = this.emptyTexture;
    }
    if (!isPartOfTextureArray && internalTexture) {
      internalTexture._associatedChannel = channel;
    }
    let needToBind = true;
    if (this._boundTexturesCache[channel] === internalTexture) {
      if (!isPartOfTextureArray) {
        this._bindSamplerUniformToChannel(internalTexture._associatedChannel, channel);
      }
      needToBind = false;
    }
    this._activeChannel = channel;
    const target = this._getTextureTarget(internalTexture);
    if (needToBind) {
      this._bindTextureDirectly(target, internalTexture, isPartOfTextureArray);
    }
    if (internalTexture && !internalTexture.isMultiview) {
      if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {
        internalTexture._cachedCoordinatesMode = texture.coordinatesMode;
        const textureWrapMode = texture.coordinatesMode !== 3 && texture.coordinatesMode !== 5 ? 1 : 0;
        texture.wrapU = textureWrapMode;
        texture.wrapV = textureWrapMode;
      }
      if (internalTexture._cachedWrapU !== texture.wrapU) {
        internalTexture._cachedWrapU = texture.wrapU;
        this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(texture.wrapU), internalTexture);
      }
      if (internalTexture._cachedWrapV !== texture.wrapV) {
        internalTexture._cachedWrapV = texture.wrapV;
        this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(texture.wrapV), internalTexture);
      }
      if (internalTexture.is3D && internalTexture._cachedWrapR !== texture.wrapR) {
        internalTexture._cachedWrapR = texture.wrapR;
        this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(texture.wrapR), internalTexture);
      }
      this._setAnisotropicLevel(target, internalTexture, texture.anisotropicFilteringLevel);
    }
    return true;
  }
  setTextureArray(channel, uniform, textures, name63) {
    if (channel === void 0 || !uniform) {
      return;
    }
    if (!this._textureUnits || this._textureUnits.length !== textures.length) {
      this._textureUnits = new Int32Array(textures.length);
    }
    for (let i = 0; i < textures.length; i++) {
      const texture = textures[i].getInternalTexture();
      if (texture) {
        this._textureUnits[i] = channel + i;
        texture._associatedChannel = channel + i;
      } else {
        this._textureUnits[i] = -1;
      }
    }
    this._gl.uniform1iv(uniform, this._textureUnits);
    for (let index = 0; index < textures.length; index++) {
      this._setTexture(this._textureUnits[index], textures[index], true);
    }
  }
  _setAnisotropicLevel(target, internalTexture, anisotropicFilteringLevel) {
    const anisotropicFilterExtension = this._caps.textureAnisotropicFilterExtension;
    if (internalTexture.samplingMode !== 11 && internalTexture.samplingMode !== 3 && internalTexture.samplingMode !== 2) {
      anisotropicFilteringLevel = 1;
    }
    if (anisotropicFilterExtension && internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {
      this._setTextureParameterFloat(target, anisotropicFilterExtension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy), internalTexture);
      internalTexture._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;
    }
  }
  _setTextureParameterFloat(target, parameter, value, texture) {
    this._bindTextureDirectly(target, texture, true, true);
    this._gl.texParameterf(target, parameter, value);
  }
  _setTextureParameterInteger(target, parameter, value, texture) {
    if (texture) {
      this._bindTextureDirectly(target, texture, true, true);
    }
    this._gl.texParameteri(target, parameter, value);
  }
  unbindAllAttributes() {
    if (this._mustWipeVertexAttributes) {
      this._mustWipeVertexAttributes = false;
      for (let i = 0; i < this._caps.maxVertexAttribs; i++) {
        this.disableAttributeByIndex(i);
      }
      return;
    }
    for (let i = 0, ul = this._vertexAttribArraysEnabled.length; i < ul; i++) {
      if (i >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[i]) {
        continue;
      }
      this.disableAttributeByIndex(i);
    }
  }
  releaseEffects() {
    for (const name63 in this._compiledEffects) {
      const webGLPipelineContext = this._compiledEffects[name63].getPipelineContext();
      this._deletePipelineContext(webGLPipelineContext);
    }
    this._compiledEffects = {};
  }
  dispose() {
    var _a;
    this.stopRenderLoop();
    if (this.onBeforeTextureInitObservable) {
      this.onBeforeTextureInitObservable.clear();
    }
    if (this._emptyTexture) {
      this._releaseTexture(this._emptyTexture);
      this._emptyTexture = null;
    }
    if (this._emptyCubeTexture) {
      this._releaseTexture(this._emptyCubeTexture);
      this._emptyCubeTexture = null;
    }
    if (this._dummyFramebuffer) {
      this._gl.deleteFramebuffer(this._dummyFramebuffer);
    }
    this.releaseEffects();
    (_a = this.releaseComputeEffects) === null || _a === void 0 ? void 0 : _a.call(this);
    this.unbindAllAttributes();
    this._boundUniforms = {};
    if (IsWindowObjectExist()) {
      if (this._renderingCanvas) {
        if (!this._doNotHandleContextLost) {
          this._renderingCanvas.removeEventListener("webglcontextlost", this._onContextLost);
          this._renderingCanvas.removeEventListener("webglcontextrestored", this._onContextRestored);
        }
        window.removeEventListener("resize", this._checkForMobile);
      }
    }
    this._workingCanvas = null;
    this._workingContext = null;
    this._currentBufferPointers.length = 0;
    this._renderingCanvas = null;
    this._currentProgram = null;
    this._boundRenderFunction = null;
    Effect.ResetCache();
    for (const request of this._activeRequests) {
      request.abort();
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
  }
  attachContextLostEvent(callback) {
    if (this._renderingCanvas) {
      this._renderingCanvas.addEventListener("webglcontextlost", callback, false);
    }
  }
  attachContextRestoredEvent(callback) {
    if (this._renderingCanvas) {
      this._renderingCanvas.addEventListener("webglcontextrestored", callback, false);
    }
  }
  getError() {
    return this._gl.getError();
  }
  _canRenderToFloatFramebuffer() {
    if (this._webGLVersion > 1) {
      return this._caps.colorBufferFloat;
    }
    return this._canRenderToFramebuffer(1);
  }
  _canRenderToHalfFloatFramebuffer() {
    if (this._webGLVersion > 1) {
      return this._caps.colorBufferFloat;
    }
    return this._canRenderToFramebuffer(2);
  }
  _canRenderToFramebuffer(type) {
    const gl = this._gl;
    while (gl.getError() !== gl.NO_ERROR) {
    }
    let successful = true;
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), 1, 1, 0, gl.RGBA, this._getWebGLTextureType(type), null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    successful = successful && status === gl.FRAMEBUFFER_COMPLETE;
    successful = successful && gl.getError() === gl.NO_ERROR;
    if (successful) {
      gl.clear(gl.COLOR_BUFFER_BIT);
      successful = successful && gl.getError() === gl.NO_ERROR;
    }
    if (successful) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      const readFormat = gl.RGBA;
      const readType = gl.UNSIGNED_BYTE;
      const buffer = new Uint8Array(4);
      gl.readPixels(0, 0, 1, 1, readFormat, readType, buffer);
      successful = successful && gl.getError() === gl.NO_ERROR;
    }
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(fb);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    while (!successful && gl.getError() !== gl.NO_ERROR) {
    }
    return successful;
  }
  _getWebGLTextureType(type) {
    if (this._webGLVersion === 1) {
      switch (type) {
        case 1:
          return this._gl.FLOAT;
        case 2:
          return this._gl.HALF_FLOAT_OES;
        case 0:
          return this._gl.UNSIGNED_BYTE;
        case 8:
          return this._gl.UNSIGNED_SHORT_4_4_4_4;
        case 9:
          return this._gl.UNSIGNED_SHORT_5_5_5_1;
        case 10:
          return this._gl.UNSIGNED_SHORT_5_6_5;
      }
      return this._gl.UNSIGNED_BYTE;
    }
    switch (type) {
      case 3:
        return this._gl.BYTE;
      case 0:
        return this._gl.UNSIGNED_BYTE;
      case 4:
        return this._gl.SHORT;
      case 5:
        return this._gl.UNSIGNED_SHORT;
      case 6:
        return this._gl.INT;
      case 7:
        return this._gl.UNSIGNED_INT;
      case 1:
        return this._gl.FLOAT;
      case 2:
        return this._gl.HALF_FLOAT;
      case 8:
        return this._gl.UNSIGNED_SHORT_4_4_4_4;
      case 9:
        return this._gl.UNSIGNED_SHORT_5_5_5_1;
      case 10:
        return this._gl.UNSIGNED_SHORT_5_6_5;
      case 11:
        return this._gl.UNSIGNED_INT_2_10_10_10_REV;
      case 12:
        return this._gl.UNSIGNED_INT_24_8;
      case 13:
        return this._gl.UNSIGNED_INT_10F_11F_11F_REV;
      case 14:
        return this._gl.UNSIGNED_INT_5_9_9_9_REV;
      case 15:
        return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
    }
    return this._gl.UNSIGNED_BYTE;
  }
  _getInternalFormat(format, useSRGBBuffer = false) {
    let internalFormat = useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA;
    switch (format) {
      case 0:
        internalFormat = this._gl.ALPHA;
        break;
      case 1:
        internalFormat = this._gl.LUMINANCE;
        break;
      case 2:
        internalFormat = this._gl.LUMINANCE_ALPHA;
        break;
      case 6:
        internalFormat = this._gl.RED;
        break;
      case 7:
        internalFormat = this._gl.RG;
        break;
      case 4:
        internalFormat = useSRGBBuffer ? this._gl.SRGB : this._gl.RGB;
        break;
      case 5:
        internalFormat = useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA;
        break;
    }
    if (this._webGLVersion > 1) {
      switch (format) {
        case 8:
          internalFormat = this._gl.RED_INTEGER;
          break;
        case 9:
          internalFormat = this._gl.RG_INTEGER;
          break;
        case 10:
          internalFormat = this._gl.RGB_INTEGER;
          break;
        case 11:
          internalFormat = this._gl.RGBA_INTEGER;
          break;
      }
    }
    return internalFormat;
  }
  _getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer = false) {
    if (this._webGLVersion === 1) {
      if (format !== void 0) {
        switch (format) {
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          case 4:
            return useSRGBBuffer ? this._gl.SRGB : this._gl.RGB;
        }
      }
      return this._gl.RGBA;
    }
    switch (type) {
      case 3:
        switch (format) {
          case 6:
            return this._gl.R8_SNORM;
          case 7:
            return this._gl.RG8_SNORM;
          case 4:
            return this._gl.RGB8_SNORM;
          case 8:
            return this._gl.R8I;
          case 9:
            return this._gl.RG8I;
          case 10:
            return this._gl.RGB8I;
          case 11:
            return this._gl.RGBA8I;
          default:
            return this._gl.RGBA8_SNORM;
        }
      case 0:
        switch (format) {
          case 6:
            return this._gl.R8;
          case 7:
            return this._gl.RG8;
          case 4:
            return useSRGBBuffer ? this._gl.SRGB8 : this._gl.RGB8;
          case 5:
            return useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA8;
          case 8:
            return this._gl.R8UI;
          case 9:
            return this._gl.RG8UI;
          case 10:
            return this._gl.RGB8UI;
          case 11:
            return this._gl.RGBA8UI;
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          default:
            return this._gl.RGBA8;
        }
      case 4:
        switch (format) {
          case 8:
            return this._gl.R16I;
          case 9:
            return this._gl.RG16I;
          case 10:
            return this._gl.RGB16I;
          case 11:
            return this._gl.RGBA16I;
          default:
            return this._gl.RGBA16I;
        }
      case 5:
        switch (format) {
          case 8:
            return this._gl.R16UI;
          case 9:
            return this._gl.RG16UI;
          case 10:
            return this._gl.RGB16UI;
          case 11:
            return this._gl.RGBA16UI;
          default:
            return this._gl.RGBA16UI;
        }
      case 6:
        switch (format) {
          case 8:
            return this._gl.R32I;
          case 9:
            return this._gl.RG32I;
          case 10:
            return this._gl.RGB32I;
          case 11:
            return this._gl.RGBA32I;
          default:
            return this._gl.RGBA32I;
        }
      case 7:
        switch (format) {
          case 8:
            return this._gl.R32UI;
          case 9:
            return this._gl.RG32UI;
          case 10:
            return this._gl.RGB32UI;
          case 11:
            return this._gl.RGBA32UI;
          default:
            return this._gl.RGBA32UI;
        }
      case 1:
        switch (format) {
          case 6:
            return this._gl.R32F;
          case 7:
            return this._gl.RG32F;
          case 4:
            return this._gl.RGB32F;
          case 5:
            return this._gl.RGBA32F;
          default:
            return this._gl.RGBA32F;
        }
      case 2:
        switch (format) {
          case 6:
            return this._gl.R16F;
          case 7:
            return this._gl.RG16F;
          case 4:
            return this._gl.RGB16F;
          case 5:
            return this._gl.RGBA16F;
          default:
            return this._gl.RGBA16F;
        }
      case 10:
        return this._gl.RGB565;
      case 13:
        return this._gl.R11F_G11F_B10F;
      case 14:
        return this._gl.RGB9_E5;
      case 8:
        return this._gl.RGBA4;
      case 9:
        return this._gl.RGB5_A1;
      case 11:
        switch (format) {
          case 5:
            return this._gl.RGB10_A2;
          case 11:
            return this._gl.RGB10_A2UI;
          default:
            return this._gl.RGB10_A2;
        }
    }
    return useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA8;
  }
  _getRGBAMultiSampleBufferFormat(type) {
    if (type === 1) {
      return this._gl.RGBA32F;
    } else if (type === 2) {
      return this._gl.RGBA16F;
    }
    return this._gl.RGBA8;
  }
  _loadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    const request = ThinEngine._FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);
    this._activeRequests.push(request);
    request.onCompleteObservable.add((request2) => {
      this._activeRequests.splice(this._activeRequests.indexOf(request2), 1);
    });
    return request;
  }
  static _FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    throw _WarnImport("FileTools");
  }
  readPixels(x, y, width, height, hasAlpha = true, flushRenderer = true) {
    const numChannels = hasAlpha ? 4 : 3;
    const format = hasAlpha ? this._gl.RGBA : this._gl.RGB;
    const data = new Uint8Array(height * width * numChannels);
    if (flushRenderer) {
      this.flushFramebuffer();
    }
    this._gl.readPixels(x, y, width, height, format, this._gl.UNSIGNED_BYTE, data);
    return Promise.resolve(data);
  }
  static get IsSupportedAsync() {
    return Promise.resolve(this.isSupported());
  }
  static get IsSupported() {
    return this.isSupported();
  }
  static isSupported() {
    if (this._HasMajorPerformanceCaveat !== null) {
      return !this._HasMajorPerformanceCaveat;
    }
    if (this._IsSupported === null) {
      try {
        const tempcanvas = this._CreateCanvas(1, 1);
        const gl = tempcanvas.getContext("webgl") || tempcanvas.getContext("experimental-webgl");
        this._IsSupported = gl != null && !!window.WebGLRenderingContext;
      } catch (e) {
        this._IsSupported = false;
      }
    }
    return this._IsSupported;
  }
  static get HasMajorPerformanceCaveat() {
    if (this._HasMajorPerformanceCaveat === null) {
      try {
        const tempcanvas = this._CreateCanvas(1, 1);
        const gl = tempcanvas.getContext("webgl", { failIfMajorPerformanceCaveat: true }) || tempcanvas.getContext("experimental-webgl", { failIfMajorPerformanceCaveat: true });
        this._HasMajorPerformanceCaveat = !gl;
      } catch (e) {
        this._HasMajorPerformanceCaveat = false;
      }
    }
    return this._HasMajorPerformanceCaveat;
  }
  static CeilingPOT(x) {
    x--;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x++;
    return x;
  }
  static FloorPOT(x) {
    x = x | x >> 1;
    x = x | x >> 2;
    x = x | x >> 4;
    x = x | x >> 8;
    x = x | x >> 16;
    return x - (x >> 1);
  }
  static NearestPOT(x) {
    const c = ThinEngine.CeilingPOT(x);
    const f = ThinEngine.FloorPOT(x);
    return c - x > x - f ? f : c;
  }
  static GetExponentOfTwo(value, max, mode = 2) {
    let pot;
    switch (mode) {
      case 1:
        pot = ThinEngine.FloorPOT(value);
        break;
      case 2:
        pot = ThinEngine.NearestPOT(value);
        break;
      case 3:
      default:
        pot = ThinEngine.CeilingPOT(value);
        break;
    }
    return Math.min(pot, max);
  }
  static QueueNewFrame(func, requester) {
    if (!IsWindowObjectExist()) {
      if (typeof requestAnimationFrame === "function") {
        return requestAnimationFrame(func);
      }
    } else {
      const { requestPostAnimationFrame, requestAnimationFrame: requestAnimationFrame2 } = requester || window;
      if (typeof requestPostAnimationFrame === "function") {
        return requestPostAnimationFrame(func);
      }
      if (typeof requestAnimationFrame2 === "function") {
        return requestAnimationFrame2(func);
      }
    }
    return setTimeout(func, 16);
  }
  getHostDocument() {
    if (this._renderingCanvas && this._renderingCanvas.ownerDocument) {
      return this._renderingCanvas.ownerDocument;
    }
    return IsDocumentAvailable() ? document : null;
  }
};
ThinEngine.ExceptionList = [
  { key: "Chrome/63.0", capture: "63\\.0\\.3239\\.(\\d+)", captureConstraint: 108, targets: ["uniformBuffer"] },
  { key: "Firefox/58", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
  { key: "Firefox/59", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
  { key: "Chrome/72.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Chrome/73.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Chrome/74.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Mac OS.+Chrome/71", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Mac OS.+Chrome/72", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Mac OS.+Chrome", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
  { key: ".*AppleWebKit.*(15.4).*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] },
  { key: ".*(15.4).*AppleWebKit.*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] }
];
ThinEngine._TextureLoaders = [];
ThinEngine.CollisionsEpsilon = 1e-3;
ThinEngine._IsSupported = null;
ThinEngine._HasMajorPerformanceCaveat = null;

// node_modules/@babylonjs/core/Misc/timingTools.js
var TimingTools = class {
  static SetImmediate(action) {
    if (IsWindowObjectExist() && window.setImmediate) {
      window.setImmediate(action);
    } else {
      setTimeout(action, 1);
    }
  }
};

// node_modules/@babylonjs/core/Misc/fileTools.js
var Base64DataUrlRegEx = new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i);
var LoadFileError = class extends RuntimeError {
  constructor(message, object) {
    super(message, ErrorCodes.LoadFileError);
    this.name = "LoadFileError";
    BaseError._setPrototypeOf(this, LoadFileError.prototype);
    if (object instanceof WebRequest) {
      this.request = object;
    } else {
      this.file = object;
    }
  }
};
var RequestFileError = class extends RuntimeError {
  constructor(message, request) {
    super(message, ErrorCodes.RequestFileError);
    this.request = request;
    this.name = "RequestFileError";
    BaseError._setPrototypeOf(this, RequestFileError.prototype);
  }
};
var ReadFileError = class extends RuntimeError {
  constructor(message, file) {
    super(message, ErrorCodes.ReadFileError);
    this.file = file;
    this.name = "ReadFileError";
    BaseError._setPrototypeOf(this, ReadFileError.prototype);
  }
};
var FileToolsOptions = {
  DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),
  BaseUrl: "",
  CorsBehavior: "anonymous",
  PreprocessUrl: (url) => {
    return url;
  }
};
var _CleanUrl = (url) => {
  url = url.replace(/#/gm, "%23");
  return url;
};
var SetCorsBehavior = (url, element) => {
  if (url && url.indexOf("data:") === 0) {
    return;
  }
  if (FileToolsOptions.CorsBehavior) {
    if (typeof FileToolsOptions.CorsBehavior === "string" || FileToolsOptions.CorsBehavior instanceof String) {
      element.crossOrigin = FileToolsOptions.CorsBehavior;
    } else {
      const result = FileToolsOptions.CorsBehavior(url);
      if (result) {
        element.crossOrigin = result;
      }
    }
  }
};
var LoadImage = (input, onLoad, onError, offlineProvider, mimeType = "", imageBitmapOptions) => {
  var _a;
  let url;
  let usingObjectURL = false;
  if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
    if (typeof Blob !== "undefined" && typeof URL !== "undefined") {
      url = URL.createObjectURL(new Blob([input], { type: mimeType }));
      usingObjectURL = true;
    } else {
      url = `data:${mimeType};base64,` + EncodeArrayBufferToBase64(input);
    }
  } else if (input instanceof Blob) {
    url = URL.createObjectURL(input);
    usingObjectURL = true;
  } else {
    url = _CleanUrl(input);
    url = FileToolsOptions.PreprocessUrl(input);
  }
  const engine = EngineStore.LastCreatedEngine;
  const onErrorHandler = (exception) => {
    if (onError) {
      const inputText = url || input.toString();
      onError(`Error while trying to load image: ${inputText.indexOf("http") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + "..."}`, exception);
    }
  };
  if (typeof Image === "undefined" || ((_a = engine === null || engine === void 0 ? void 0 : engine._features.forceBitmapOverHTMLImageElement) !== null && _a !== void 0 ? _a : false)) {
    LoadFile(url, (data) => {
      engine.createImageBitmap(new Blob([data], { type: mimeType }), { premultiplyAlpha: "none", ...imageBitmapOptions }).then((imgBmp) => {
        onLoad(imgBmp);
        if (usingObjectURL) {
          URL.revokeObjectURL(url);
        }
      }).catch((reason) => {
        if (onError) {
          onError("Error while trying to load image: " + input, reason);
        }
      });
    }, void 0, offlineProvider || void 0, true, (request, exception) => {
      onErrorHandler(exception);
    });
    return null;
  }
  const img = new Image();
  SetCorsBehavior(url, img);
  const handlersList = [];
  const loadHandlersList = () => {
    handlersList.forEach((handler) => {
      handler.target.addEventListener(handler.name, handler.handler);
    });
  };
  const unloadHandlersList = () => {
    handlersList.forEach((handler) => {
      handler.target.removeEventListener(handler.name, handler.handler);
    });
    handlersList.length = 0;
  };
  const loadHandler = () => {
    unloadHandlersList();
    onLoad(img);
    if (usingObjectURL && img.src) {
      URL.revokeObjectURL(img.src);
    }
  };
  const errorHandler = (err) => {
    unloadHandlersList();
    onErrorHandler(err);
    if (usingObjectURL && img.src) {
      URL.revokeObjectURL(img.src);
    }
  };
  const cspHandler = (err) => {
    unloadHandlersList();
    const cspException = new Error(`CSP violation of policy ${err.effectiveDirective} ${err.blockedURI}. Current policy is ${err.originalPolicy}`);
    EngineStore.UseFallbackTexture = false;
    onErrorHandler(cspException);
    if (usingObjectURL && img.src) {
      URL.revokeObjectURL(img.src);
    }
    img.src = "";
  };
  handlersList.push({ target: img, name: "load", handler: loadHandler });
  handlersList.push({ target: img, name: "error", handler: errorHandler });
  handlersList.push({ target: document, name: "securitypolicyviolation", handler: cspHandler });
  loadHandlersList();
  const fromBlob = url.substring(0, 5) === "blob:";
  const fromData = url.substring(0, 5) === "data:";
  const noOfflineSupport = () => {
    if (fromBlob || fromData) {
      img.src = url;
    } else {
      LoadFile(url, (data, _, contentType) => {
        const type = !mimeType && contentType ? contentType : mimeType;
        const blob = new Blob([data], { type });
        const url2 = URL.createObjectURL(blob);
        usingObjectURL = true;
        img.src = url2;
      }, void 0, offlineProvider || void 0, true, (request, exception) => {
        onErrorHandler(exception);
      });
    }
  };
  const loadFromOfflineSupport = () => {
    if (offlineProvider) {
      offlineProvider.loadImage(url, img);
    }
  };
  if (!fromBlob && !fromData && offlineProvider && offlineProvider.enableTexturesOffline) {
    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);
  } else {
    if (url.indexOf("file:") !== -1) {
      const textureName = decodeURIComponent(url.substring(5).toLowerCase());
      if (FilesInputStore.FilesToLoad[textureName] && typeof URL !== "undefined") {
        try {
          let blobURL;
          try {
            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
          } catch (ex) {
            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
          }
          img.src = blobURL;
          usingObjectURL = true;
        } catch (e) {
          img.src = "";
        }
        return img;
      }
    }
    noOfflineSupport();
  }
  return img;
};
var ReadFile = (file, onSuccess, onProgress, useArrayBuffer, onError) => {
  const reader = new FileReader();
  const fileRequest = {
    onCompleteObservable: new Observable(),
    abort: () => reader.abort()
  };
  reader.onloadend = () => fileRequest.onCompleteObservable.notifyObservers(fileRequest);
  if (onError) {
    reader.onerror = () => {
      onError(new ReadFileError(`Unable to read ${file.name}`, file));
    };
  }
  reader.onload = (e) => {
    onSuccess(e.target["result"]);
  };
  if (onProgress) {
    reader.onprogress = onProgress;
  }
  if (!useArrayBuffer) {
    reader.readAsText(file);
  } else {
    reader.readAsArrayBuffer(file);
  }
  return fileRequest;
};
var LoadFile = (fileOrUrl, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {
  if (fileOrUrl.name) {
    return ReadFile(fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError ? (error) => {
      onError(void 0, error);
    } : void 0);
  }
  const url = fileOrUrl;
  if (url.indexOf("file:") !== -1) {
    let fileName = decodeURIComponent(url.substring(5).toLowerCase());
    if (fileName.indexOf("./") === 0) {
      fileName = fileName.substring(2);
    }
    const file = FilesInputStore.FilesToLoad[fileName];
    if (file) {
      return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? (error) => onError(void 0, new LoadFileError(error.message, error.file)) : void 0);
    }
  }
  const { match, type } = TestBase64DataUrl(url);
  if (match) {
    const fileRequest = {
      onCompleteObservable: new Observable(),
      abort: () => () => {
      }
    };
    try {
      const data = useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url);
      onSuccess(data, void 0, type);
    } catch (error) {
      if (onError) {
        onError(void 0, error);
      } else {
        Logger.Error(error.message || "Failed to parse the Data URL");
      }
    }
    TimingTools.SetImmediate(() => {
      fileRequest.onCompleteObservable.notifyObservers(fileRequest);
    });
    return fileRequest;
  }
  return RequestFile(url, (data, request) => {
    onSuccess(data, request === null || request === void 0 ? void 0 : request.responseURL, request === null || request === void 0 ? void 0 : request.getResponseHeader("content-type"));
  }, onProgress, offlineProvider, useArrayBuffer, onError ? (error) => {
    onError(error.request, new LoadFileError(error.message, error.request));
  } : void 0, onOpened);
};
var RequestFile = (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {
  url = _CleanUrl(url);
  url = FileToolsOptions.PreprocessUrl(url);
  const loadUrl = FileToolsOptions.BaseUrl + url;
  let aborted = false;
  const fileRequest = {
    onCompleteObservable: new Observable(),
    abort: () => aborted = true
  };
  const requestFile = () => {
    let request = new WebRequest();
    let retryHandle = null;
    let onReadyStateChange;
    const unbindEvents = () => {
      if (!request) {
        return;
      }
      if (onProgress) {
        request.removeEventListener("progress", onProgress);
      }
      if (onReadyStateChange) {
        request.removeEventListener("readystatechange", onReadyStateChange);
      }
      request.removeEventListener("loadend", onLoadEnd);
    };
    let onLoadEnd = () => {
      unbindEvents();
      fileRequest.onCompleteObservable.notifyObservers(fileRequest);
      fileRequest.onCompleteObservable.clear();
      onProgress = void 0;
      onReadyStateChange = null;
      onLoadEnd = null;
      onError = void 0;
      onOpened = void 0;
      onSuccess = void 0;
    };
    fileRequest.abort = () => {
      aborted = true;
      if (onLoadEnd) {
        onLoadEnd();
      }
      if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {
        request.abort();
      }
      if (retryHandle !== null) {
        clearTimeout(retryHandle);
        retryHandle = null;
      }
      request = null;
    };
    const handleError = (error) => {
      const message = error.message || "Unknown error";
      if (onError && request) {
        onError(new RequestFileError(message, request));
      } else {
        Logger.Error(message);
      }
    };
    const retryLoop = (retryIndex) => {
      if (!request) {
        return;
      }
      request.open("GET", loadUrl);
      if (onOpened) {
        try {
          onOpened(request);
        } catch (e) {
          handleError(e);
          return;
        }
      }
      if (useArrayBuffer) {
        request.responseType = "arraybuffer";
      }
      if (onProgress) {
        request.addEventListener("progress", onProgress);
      }
      if (onLoadEnd) {
        request.addEventListener("loadend", onLoadEnd);
      }
      onReadyStateChange = () => {
        if (aborted || !request) {
          return;
        }
        if (request.readyState === (XMLHttpRequest.DONE || 4)) {
          if (onReadyStateChange) {
            request.removeEventListener("readystatechange", onReadyStateChange);
          }
          if (request.status >= 200 && request.status < 300 || request.status === 0 && (!IsWindowObjectExist() || IsFileURL())) {
            try {
              if (onSuccess) {
                onSuccess(useArrayBuffer ? request.response : request.responseText, request);
              }
            } catch (e) {
              handleError(e);
            }
            return;
          }
          const retryStrategy = FileToolsOptions.DefaultRetryStrategy;
          if (retryStrategy) {
            const waitTime = retryStrategy(loadUrl, request, retryIndex);
            if (waitTime !== -1) {
              unbindEvents();
              request = new WebRequest();
              retryHandle = setTimeout(() => retryLoop(retryIndex + 1), waitTime);
              return;
            }
          }
          const error = new RequestFileError("Error status: " + request.status + " " + request.statusText + " - Unable to load " + loadUrl, request);
          if (onError) {
            onError(error);
          }
        }
      };
      request.addEventListener("readystatechange", onReadyStateChange);
      request.send();
    };
    retryLoop(0);
  };
  if (offlineProvider && offlineProvider.enableSceneOffline) {
    const noOfflineSupport = (request) => {
      if (request && request.status > 400) {
        if (onError) {
          onError(request);
        }
      } else {
        requestFile();
      }
    };
    const loadFromOfflineSupport = () => {
      if (offlineProvider) {
        offlineProvider.loadFile(FileToolsOptions.BaseUrl + url, (data) => {
          if (!aborted && onSuccess) {
            onSuccess(data);
          }
          fileRequest.onCompleteObservable.notifyObservers(fileRequest);
        }, onProgress ? (event) => {
          if (!aborted && onProgress) {
            onProgress(event);
          }
        } : void 0, noOfflineSupport, useArrayBuffer);
      }
    };
    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);
  } else {
    requestFile();
  }
  return fileRequest;
};
var IsFileURL = () => {
  return typeof location !== "undefined" && location.protocol === "file:";
};
var IsBase64DataUrl = (uri) => {
  return Base64DataUrlRegEx.test(uri);
};
var TestBase64DataUrl = (uri) => {
  const results = Base64DataUrlRegEx.exec(uri);
  if (results === null || results.length === 0) {
    return { match: false, type: "" };
  } else {
    const type = results[0].replace("data:", "").replace("base64,", "");
    return { match: true, type };
  }
};
function DecodeBase64UrlToBinary(uri) {
  return DecodeBase64ToBinary(uri.split(",")[1]);
}
var DecodeBase64UrlToString = (uri) => {
  return DecodeBase64ToString(uri.split(",")[1]);
};
var initSideEffects = () => {
  ThinEngine._FileToolsLoadImage = LoadImage;
  ThinEngine._FileToolsLoadFile = LoadFile;
  ShaderProcessor._FileToolsLoadFile = LoadFile;
};
initSideEffects();
var FileTools;
var _injectLTSFileTools = (DecodeBase64UrlToBinary2, DecodeBase64UrlToString2, FileToolsOptions2, IsBase64DataUrl2, IsFileURL2, LoadFile2, LoadImage2, ReadFile2, RequestFile2, SetCorsBehavior2) => {
  FileTools = {
    DecodeBase64UrlToBinary: DecodeBase64UrlToBinary2,
    DecodeBase64UrlToString: DecodeBase64UrlToString2,
    DefaultRetryStrategy: FileToolsOptions2.DefaultRetryStrategy,
    BaseUrl: FileToolsOptions2.BaseUrl,
    CorsBehavior: FileToolsOptions2.CorsBehavior,
    PreprocessUrl: FileToolsOptions2.PreprocessUrl,
    IsBase64DataUrl: IsBase64DataUrl2,
    IsFileURL: IsFileURL2,
    LoadFile: LoadFile2,
    LoadImage: LoadImage2,
    ReadFile: ReadFile2,
    RequestFile: RequestFile2,
    SetCorsBehavior: SetCorsBehavior2
  };
  Object.defineProperty(FileTools, "DefaultRetryStrategy", {
    get: function() {
      return FileToolsOptions2.DefaultRetryStrategy;
    },
    set: function(value) {
      FileToolsOptions2.DefaultRetryStrategy = value;
    }
  });
  Object.defineProperty(FileTools, "BaseUrl", {
    get: function() {
      return FileToolsOptions2.BaseUrl;
    },
    set: function(value) {
      FileToolsOptions2.BaseUrl = value;
    }
  });
  Object.defineProperty(FileTools, "PreprocessUrl", {
    get: function() {
      return FileToolsOptions2.PreprocessUrl;
    },
    set: function(value) {
      FileToolsOptions2.PreprocessUrl = value;
    }
  });
  Object.defineProperty(FileTools, "CorsBehavior", {
    get: function() {
      return FileToolsOptions2.CorsBehavior;
    },
    set: function(value) {
      FileToolsOptions2.CorsBehavior = value;
    }
  });
};
_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);

// node_modules/@babylonjs/core/Misc/guid.js
function RandomGUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var GUID = {
  RandomId: RandomGUID
};

// node_modules/@babylonjs/core/Misc/instantiationTools.js
var InstantiationTools = class {
  static Instantiate(className2) {
    if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[className2]) {
      return this.RegisteredExternalClasses[className2];
    }
    const internalClass = GetClass(className2);
    if (internalClass) {
      return internalClass;
    }
    Logger.Warn(className2 + " not found, you may have missed an import.");
    const arr = className2.split(".");
    let fn = window || this;
    for (let i = 0, len = arr.length; i < len; i++) {
      fn = fn[arr[i]];
    }
    if (typeof fn !== "function") {
      return null;
    }
    return fn;
  }
};
InstantiationTools.RegisteredExternalClasses = {};

// node_modules/@babylonjs/core/Misc/tools.js
var Tools = class {
  static get BaseUrl() {
    return FileToolsOptions.BaseUrl;
  }
  static set BaseUrl(value) {
    FileToolsOptions.BaseUrl = value;
  }
  static get DefaultRetryStrategy() {
    return FileToolsOptions.DefaultRetryStrategy;
  }
  static set DefaultRetryStrategy(strategy) {
    FileToolsOptions.DefaultRetryStrategy = strategy;
  }
  static get CorsBehavior() {
    return FileToolsOptions.CorsBehavior;
  }
  static set CorsBehavior(value) {
    FileToolsOptions.CorsBehavior = value;
  }
  static get UseFallbackTexture() {
    return EngineStore.UseFallbackTexture;
  }
  static set UseFallbackTexture(value) {
    EngineStore.UseFallbackTexture = value;
  }
  static get RegisteredExternalClasses() {
    return InstantiationTools.RegisteredExternalClasses;
  }
  static set RegisteredExternalClasses(classes) {
    InstantiationTools.RegisteredExternalClasses = classes;
  }
  static get fallbackTexture() {
    return EngineStore.FallbackTexture;
  }
  static set fallbackTexture(value) {
    EngineStore.FallbackTexture = value;
  }
  static FetchToRef(u, v, width, height, pixels, color) {
    const wrappedU = Math.abs(u) * width % width | 0;
    const wrappedV = Math.abs(v) * height % height | 0;
    const position = (wrappedU + wrappedV * width) * 4;
    color.r = pixels[position] / 255;
    color.g = pixels[position + 1] / 255;
    color.b = pixels[position + 2] / 255;
    color.a = pixels[position + 3] / 255;
  }
  static Mix(a, b, alpha) {
    return a * (1 - alpha) + b * alpha;
  }
  static Instantiate(className2) {
    return InstantiationTools.Instantiate(className2);
  }
  static SetImmediate(action) {
    TimingTools.SetImmediate(action);
  }
  static IsExponentOfTwo(value) {
    let count = 1;
    do {
      count *= 2;
    } while (count < value);
    return count === value;
  }
  static FloatRound(value) {
    if (Math.fround) {
      return Math.fround(value);
    }
    return Tools._TmpFloatArray[0] = value, Tools._TmpFloatArray[0];
  }
  static GetFilename(path) {
    const index = path.lastIndexOf("/");
    if (index < 0) {
      return path;
    }
    return path.substring(index + 1);
  }
  static GetFolderPath(uri, returnUnchangedIfNoSlash = false) {
    const index = uri.lastIndexOf("/");
    if (index < 0) {
      if (returnUnchangedIfNoSlash) {
        return uri;
      }
      return "";
    }
    return uri.substring(0, index + 1);
  }
  static ToDegrees(angle) {
    return angle * 180 / Math.PI;
  }
  static ToRadians(angle) {
    return angle * Math.PI / 180;
  }
  static SmoothAngleChange(previousAngle, newAngle, smoothFactor = 0.9) {
    const previousAngleRad = this.ToRadians(previousAngle);
    const newAngleRad = this.ToRadians(newAngle);
    return this.ToDegrees(Math.atan2((1 - smoothFactor) * Math.sin(newAngleRad) + smoothFactor * Math.sin(previousAngleRad), (1 - smoothFactor) * Math.cos(newAngleRad) + smoothFactor * Math.cos(previousAngleRad)));
  }
  static MakeArray(obj, allowsNullUndefined) {
    if (allowsNullUndefined !== true && (obj === void 0 || obj == null)) {
      return null;
    }
    return Array.isArray(obj) ? obj : [obj];
  }
  static GetPointerPrefix(engine) {
    let eventPrefix = "pointer";
    if (IsWindowObjectExist() && !window.PointerEvent) {
      eventPrefix = "mouse";
    }
    if (engine._badDesktopOS && !engine._badOS && !(document && "ontouchend" in document)) {
      eventPrefix = "mouse";
    }
    return eventPrefix;
  }
  static SetCorsBehavior(url, element) {
    SetCorsBehavior(url, element);
  }
  static SetReferrerPolicyBehavior(referrerPolicy, element) {
    element.referrerPolicy = referrerPolicy;
  }
  static CleanUrl(url) {
    url = url.replace(/#/gm, "%23");
    return url;
  }
  static get PreprocessUrl() {
    return FileToolsOptions.PreprocessUrl;
  }
  static set PreprocessUrl(processor) {
    FileToolsOptions.PreprocessUrl = processor;
  }
  static LoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
    return LoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions);
  }
  static LoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    return LoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);
  }
  static LoadFileAsync(url, useArrayBuffer = true) {
    return new Promise((resolve, reject) => {
      LoadFile(url, (data) => {
        resolve(data);
      }, void 0, void 0, useArrayBuffer, (request, exception) => {
        reject(exception);
      });
    });
  }
  static LoadScript(scriptUrl, onSuccess, onError, scriptId) {
    if (typeof importScripts === "function") {
      try {
        importScripts(scriptUrl);
        onSuccess();
      } catch (e) {
        onError === null || onError === void 0 ? void 0 : onError(`Unable to load script '${scriptUrl}' in worker`, e);
      }
      return;
    } else if (!IsWindowObjectExist()) {
      onError === null || onError === void 0 ? void 0 : onError(`Cannot load script '${scriptUrl}' outside of a window or a worker`);
      return;
    }
    const head = document.getElementsByTagName("head")[0];
    const script = document.createElement("script");
    script.setAttribute("type", "text/javascript");
    script.setAttribute("src", scriptUrl);
    if (scriptId) {
      script.id = scriptId;
    }
    script.onload = () => {
      if (onSuccess) {
        onSuccess();
      }
    };
    script.onerror = (e) => {
      if (onError) {
        onError(`Unable to load script '${scriptUrl}'`, e);
      }
    };
    head.appendChild(script);
  }
  static LoadScriptAsync(scriptUrl) {
    return new Promise((resolve, reject) => {
      this.LoadScript(scriptUrl, () => {
        resolve();
      }, (message, exception) => {
        reject(exception || new Error(message));
      });
    });
  }
  static ReadFileAsDataURL(fileToLoad, callback, progressCallback) {
    const reader = new FileReader();
    const request = {
      onCompleteObservable: new Observable(),
      abort: () => reader.abort()
    };
    reader.onloadend = () => {
      request.onCompleteObservable.notifyObservers(request);
    };
    reader.onload = (e) => {
      callback(e.target["result"]);
    };
    reader.onprogress = progressCallback;
    reader.readAsDataURL(fileToLoad);
    return request;
  }
  static ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError) {
    return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);
  }
  static FileAsURL(content) {
    const fileBlob = new Blob([content]);
    const url = window.URL;
    const link = url.createObjectURL(fileBlob);
    return link;
  }
  static Format(value, decimals = 2) {
    return value.toFixed(decimals);
  }
  static DeepCopy(source, destination, doNotCopyList, mustCopyList) {
    DeepCopier.DeepCopy(source, destination, doNotCopyList, mustCopyList);
  }
  static IsEmpty(obj) {
    for (const i in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, i)) {
        return false;
      }
    }
    return true;
  }
  static RegisterTopRootEvents(windowElement, events) {
    for (let index = 0; index < events.length; index++) {
      const event = events[index];
      windowElement.addEventListener(event.name, event.handler, false);
      try {
        if (window.parent) {
          window.parent.addEventListener(event.name, event.handler, false);
        }
      } catch (e) {
      }
    }
  }
  static UnregisterTopRootEvents(windowElement, events) {
    for (let index = 0; index < events.length; index++) {
      const event = events[index];
      windowElement.removeEventListener(event.name, event.handler);
      try {
        if (windowElement.parent) {
          windowElement.parent.removeEventListener(event.name, event.handler);
        }
      } catch (e) {
      }
    }
  }
  static async DumpFramebuffer(width, height, engine, successCallback, mimeType = "image/png", fileName) {
    throw _WarnImport("DumpTools");
  }
  static DumpData(width, height, data, successCallback, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
    throw _WarnImport("DumpTools");
  }
  static DumpDataAsync(width, height, data, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
    throw _WarnImport("DumpTools");
  }
  static ToBlob(canvas, successCallback, mimeType = "image/png", quality) {
    if (!canvas.toBlob) {
      canvas.toBlob = function(callback, type, quality2) {
        setTimeout(() => {
          const binStr = atob(this.toDataURL(type, quality2).split(",")[1]), len = binStr.length, arr = new Uint8Array(len);
          for (let i = 0; i < len; i++) {
            arr[i] = binStr.charCodeAt(i);
          }
          callback(new Blob([arr]));
        });
      };
    }
    canvas.toBlob(function(blob) {
      successCallback(blob);
    }, mimeType, quality);
  }
  static DownloadBlob(blob, fileName) {
    if ("download" in document.createElement("a")) {
      if (!fileName) {
        const date = new Date();
        const stringDate = (date.getFullYear() + "-" + (date.getMonth() + 1)).slice(2) + "-" + date.getDate() + "_" + date.getHours() + "-" + ("0" + date.getMinutes()).slice(-2);
        fileName = "screenshot_" + stringDate + ".png";
      }
      Tools.Download(blob, fileName);
    } else {
      if (blob && typeof URL !== "undefined") {
        const url = URL.createObjectURL(blob);
        const newWindow = window.open("");
        if (!newWindow) {
          return;
        }
        const img = newWindow.document.createElement("img");
        img.onload = function() {
          URL.revokeObjectURL(url);
        };
        img.src = url;
        newWindow.document.body.appendChild(img);
      }
    }
  }
  static EncodeScreenshotCanvasData(canvas, successCallback, mimeType = "image/png", fileName, quality) {
    if (successCallback) {
      const base64Image = canvas.toDataURL(mimeType, quality);
      successCallback(base64Image);
    } else {
      this.ToBlob(canvas, function(blob) {
        if (blob) {
          Tools.DownloadBlob(blob, fileName);
        }
      }, mimeType, quality);
    }
  }
  static Download(blob, fileName) {
    if (typeof URL === "undefined") {
      return;
    }
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement("a");
    document.body.appendChild(a);
    a.style.display = "none";
    a.href = url;
    a.download = fileName;
    a.addEventListener("click", () => {
      if (a.parentElement) {
        a.parentElement.removeChild(a);
      }
    });
    a.click();
    window.URL.revokeObjectURL(url);
  }
  static BackCompatCameraNoPreventDefault(args) {
    if (typeof args[0] === "boolean") {
      return args[0];
    } else if (typeof args[1] === "boolean") {
      return args[1];
    }
    return false;
  }
  static CreateScreenshot(engine, camera, size, successCallback, mimeType = "image/png") {
    throw _WarnImport("ScreenshotTools");
  }
  static CreateScreenshotAsync(engine, camera, size, mimeType = "image/png") {
    throw _WarnImport("ScreenshotTools");
  }
  static CreateScreenshotUsingRenderTarget(engine, camera, size, successCallback, mimeType = "image/png", samples = 1, antialiasing = false, fileName) {
    throw _WarnImport("ScreenshotTools");
  }
  static CreateScreenshotUsingRenderTargetAsync(engine, camera, size, mimeType = "image/png", samples = 1, antialiasing = false, fileName) {
    throw _WarnImport("ScreenshotTools");
  }
  static RandomId() {
    return RandomGUID();
  }
  static IsBase64(uri) {
    return IsBase64DataUrl(uri);
  }
  static DecodeBase64(uri) {
    return DecodeBase64UrlToBinary(uri);
  }
  static get errorsCount() {
    return Logger.errorsCount;
  }
  static Log(message) {
    Logger.Log(message);
  }
  static Warn(message) {
    Logger.Warn(message);
  }
  static Error(message) {
    Logger.Error(message);
  }
  static get LogCache() {
    return Logger.LogCache;
  }
  static ClearLogCache() {
    Logger.ClearLogCache();
  }
  static set LogLevels(level) {
    Logger.LogLevels = level;
  }
  static set PerformanceLogLevel(level) {
    if ((level & Tools.PerformanceUserMarkLogLevel) === Tools.PerformanceUserMarkLogLevel) {
      Tools.StartPerformanceCounter = Tools._StartUserMark;
      Tools.EndPerformanceCounter = Tools._EndUserMark;
      return;
    }
    if ((level & Tools.PerformanceConsoleLogLevel) === Tools.PerformanceConsoleLogLevel) {
      Tools.StartPerformanceCounter = Tools._StartPerformanceConsole;
      Tools.EndPerformanceCounter = Tools._EndPerformanceConsole;
      return;
    }
    Tools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;
    Tools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;
  }
  static _StartPerformanceCounterDisabled(counterName, condition) {
  }
  static _EndPerformanceCounterDisabled(counterName, condition) {
  }
  static _StartUserMark(counterName, condition = true) {
    if (!Tools._Performance) {
      if (!IsWindowObjectExist()) {
        return;
      }
      Tools._Performance = window.performance;
    }
    if (!condition || !Tools._Performance.mark) {
      return;
    }
    Tools._Performance.mark(counterName + "-Begin");
  }
  static _EndUserMark(counterName, condition = true) {
    if (!condition || !Tools._Performance.mark) {
      return;
    }
    Tools._Performance.mark(counterName + "-End");
    Tools._Performance.measure(counterName, counterName + "-Begin", counterName + "-End");
  }
  static _StartPerformanceConsole(counterName, condition = true) {
    if (!condition) {
      return;
    }
    Tools._StartUserMark(counterName, condition);
    if (console.time) {
      console.time(counterName);
    }
  }
  static _EndPerformanceConsole(counterName, condition = true) {
    if (!condition) {
      return;
    }
    Tools._EndUserMark(counterName, condition);
    console.timeEnd(counterName);
  }
  static get Now() {
    return PrecisionDate.Now;
  }
  static GetClassName(object, isType = false) {
    let name63 = null;
    if (!isType && object.getClassName) {
      name63 = object.getClassName();
    } else {
      if (object instanceof Object) {
        const classObj = isType ? object : Object.getPrototypeOf(object);
        name63 = classObj.constructor["__bjsclassName__"];
      }
      if (!name63) {
        name63 = typeof object;
      }
    }
    return name63;
  }
  static First(array, predicate) {
    for (const el of array) {
      if (predicate(el)) {
        return el;
      }
    }
    return null;
  }
  static getFullClassName(object, isType = false) {
    let className2 = null;
    let moduleName = null;
    if (!isType && object.getClassName) {
      className2 = object.getClassName();
    } else {
      if (object instanceof Object) {
        const classObj = isType ? object : Object.getPrototypeOf(object);
        className2 = classObj.constructor["__bjsclassName__"];
        moduleName = classObj.constructor["__bjsmoduleName__"];
      }
      if (!className2) {
        className2 = typeof object;
      }
    }
    if (!className2) {
      return null;
    }
    return (moduleName != null ? moduleName + "." : "") + className2;
  }
  static DelayAsync(delay) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, delay);
    });
  }
  static IsSafari() {
    if (!IsNavigatorAvailable()) {
      return false;
    }
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  }
};
Tools.UseCustomRequestHeaders = false;
Tools.CustomRequestHeaders = WebRequest.CustomRequestHeaders;
Tools._TmpFloatArray = new Float32Array(1);
Tools.GetDOMTextContent = GetDOMTextContent;
Tools.GetAbsoluteUrl = typeof document === "object" ? (url) => {
  const a = document.createElement("a");
  a.href = url;
  return a.href;
} : typeof URL === "function" && typeof location === "object" ? (url) => new URL(url, location.origin).href : () => {
  throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.");
};
Tools.NoneLogLevel = Logger.NoneLogLevel;
Tools.MessageLogLevel = Logger.MessageLogLevel;
Tools.WarningLogLevel = Logger.WarningLogLevel;
Tools.ErrorLogLevel = Logger.ErrorLogLevel;
Tools.AllLogLevel = Logger.AllLogLevel;
Tools.IsWindowObjectExist = IsWindowObjectExist;
Tools.PerformanceNoneLogLevel = 0;
Tools.PerformanceUserMarkLogLevel = 1;
Tools.PerformanceConsoleLogLevel = 2;
Tools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;
Tools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;
function className(name63, module) {
  return (target) => {
    target["__bjsclassName__"] = name63;
    target["__bjsmoduleName__"] = module != null ? module : null;
  };
}
var AsyncLoop = class {
  constructor(iterations, func, successCallback, offset = 0) {
    this.iterations = iterations;
    this.index = offset - 1;
    this._done = false;
    this._fn = func;
    this._successCallback = successCallback;
  }
  executeNext() {
    if (!this._done) {
      if (this.index + 1 < this.iterations) {
        ++this.index;
        this._fn(this);
      } else {
        this.breakLoop();
      }
    }
  }
  breakLoop() {
    this._done = true;
    this._successCallback();
  }
  static Run(iterations, fn, successCallback, offset = 0) {
    const loop = new AsyncLoop(iterations, fn, successCallback, offset);
    loop.executeNext();
    return loop;
  }
  static SyncAsyncForLoop(iterations, syncedIterations, fn, callback, breakFunction, timeout = 0) {
    return AsyncLoop.Run(Math.ceil(iterations / syncedIterations), (loop) => {
      if (breakFunction && breakFunction()) {
        loop.breakLoop();
      } else {
        setTimeout(() => {
          for (let i = 0; i < syncedIterations; ++i) {
            const iteration = loop.index * syncedIterations + i;
            if (iteration >= iterations) {
              break;
            }
            fn(iteration);
            if (breakFunction && breakFunction()) {
              loop.breakLoop();
              break;
            }
          }
          loop.executeNext();
        }, timeout);
      }
    }, callback);
  }
};
EngineStore.FallbackTexture = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";

// node_modules/@babylonjs/core/Misc/smartArray.js
var SmartArray = class {
  constructor(capacity) {
    this.length = 0;
    this.data = new Array(capacity);
    this._id = SmartArray._GlobalId++;
  }
  push(value) {
    this.data[this.length++] = value;
    if (this.length > this.data.length) {
      this.data.length *= 2;
    }
  }
  forEach(func) {
    for (let index = 0; index < this.length; index++) {
      func(this.data[index]);
    }
  }
  sort(compareFn) {
    this.data.sort(compareFn);
  }
  reset() {
    this.length = 0;
  }
  dispose() {
    this.reset();
    if (this.data) {
      this.data.length = 0;
    }
  }
  concat(array) {
    if (array.length === 0) {
      return;
    }
    if (this.length + array.length > this.data.length) {
      this.data.length = (this.length + array.length) * 2;
    }
    for (let index = 0; index < array.length; index++) {
      this.data[this.length++] = (array.data || array)[index];
    }
  }
  indexOf(value) {
    const position = this.data.indexOf(value);
    if (position >= this.length) {
      return -1;
    }
    return position;
  }
  contains(value) {
    return this.indexOf(value) !== -1;
  }
};
SmartArray._GlobalId = 0;
var SmartArrayNoDuplicate = class extends SmartArray {
  constructor() {
    super(...arguments);
    this._duplicateId = 0;
  }
  push(value) {
    super.push(value);
    if (!value.__smartArrayFlags) {
      value.__smartArrayFlags = {};
    }
    value.__smartArrayFlags[this._id] = this._duplicateId;
  }
  pushNoDuplicate(value) {
    if (value.__smartArrayFlags && value.__smartArrayFlags[this._id] === this._duplicateId) {
      return false;
    }
    this.push(value);
    return true;
  }
  reset() {
    super.reset();
    this._duplicateId++;
  }
  concatWithNoDuplicate(array) {
    if (array.length === 0) {
      return;
    }
    if (this.length + array.length > this.data.length) {
      this.data.length = (this.length + array.length) * 2;
    }
    for (let index = 0; index < array.length; index++) {
      const item = (array.data || array)[index];
      this.pushNoDuplicate(item);
    }
  }
};

// node_modules/@babylonjs/core/Misc/stringDictionary.js
var StringDictionary = class {
  constructor() {
    this._count = 0;
    this._data = {};
  }
  copyFrom(source) {
    this.clear();
    source.forEach((t, v) => this.add(t, v));
  }
  get(key) {
    const val = this._data[key];
    if (val !== void 0) {
      return val;
    }
    return void 0;
  }
  getOrAddWithFactory(key, factory) {
    let val = this.get(key);
    if (val !== void 0) {
      return val;
    }
    val = factory(key);
    if (val) {
      this.add(key, val);
    }
    return val;
  }
  getOrAdd(key, val) {
    const curVal = this.get(key);
    if (curVal !== void 0) {
      return curVal;
    }
    this.add(key, val);
    return val;
  }
  contains(key) {
    return this._data[key] !== void 0;
  }
  add(key, value) {
    if (this._data[key] !== void 0) {
      return false;
    }
    this._data[key] = value;
    ++this._count;
    return true;
  }
  set(key, value) {
    if (this._data[key] === void 0) {
      return false;
    }
    this._data[key] = value;
    return true;
  }
  getAndRemove(key) {
    const val = this.get(key);
    if (val !== void 0) {
      delete this._data[key];
      --this._count;
      return val;
    }
    return null;
  }
  remove(key) {
    if (this.contains(key)) {
      delete this._data[key];
      --this._count;
      return true;
    }
    return false;
  }
  clear() {
    this._data = {};
    this._count = 0;
  }
  get count() {
    return this._count;
  }
  forEach(callback) {
    for (const cur in this._data) {
      const val = this._data[cur];
      callback(cur, val);
    }
  }
  first(callback) {
    for (const cur in this._data) {
      const val = this._data[cur];
      const res = callback(cur, val);
      if (res) {
        return res;
      }
    }
    return null;
  }
};

// node_modules/@babylonjs/core/Materials/materialDefines.js
var MaterialDefines = class {
  constructor(externalProperties) {
    this._keys = [];
    this._isDirty = true;
    this._areLightsDirty = true;
    this._areLightsDisposed = false;
    this._areAttributesDirty = true;
    this._areTexturesDirty = true;
    this._areFresnelDirty = true;
    this._areMiscDirty = true;
    this._arePrePassDirty = true;
    this._areImageProcessingDirty = true;
    this._normals = false;
    this._uvs = false;
    this._needNormals = false;
    this._needUVs = false;
    this._externalProperties = externalProperties;
    if (externalProperties) {
      for (const prop in externalProperties) {
        if (Object.prototype.hasOwnProperty.call(externalProperties, prop)) {
          this._setDefaultValue(prop);
        }
      }
    }
  }
  get isDirty() {
    return this._isDirty;
  }
  markAsProcessed() {
    this._isDirty = false;
    this._areAttributesDirty = false;
    this._areTexturesDirty = false;
    this._areFresnelDirty = false;
    this._areLightsDirty = false;
    this._areLightsDisposed = false;
    this._areMiscDirty = false;
    this._arePrePassDirty = false;
    this._areImageProcessingDirty = false;
  }
  markAsUnprocessed() {
    this._isDirty = true;
  }
  markAllAsDirty() {
    this._areTexturesDirty = true;
    this._areAttributesDirty = true;
    this._areLightsDirty = true;
    this._areFresnelDirty = true;
    this._areMiscDirty = true;
    this._areImageProcessingDirty = true;
    this._isDirty = true;
  }
  markAsImageProcessingDirty() {
    this._areImageProcessingDirty = true;
    this._isDirty = true;
  }
  markAsLightDirty(disposed = false) {
    this._areLightsDirty = true;
    this._areLightsDisposed = this._areLightsDisposed || disposed;
    this._isDirty = true;
  }
  markAsAttributesDirty() {
    this._areAttributesDirty = true;
    this._isDirty = true;
  }
  markAsTexturesDirty() {
    this._areTexturesDirty = true;
    this._isDirty = true;
  }
  markAsFresnelDirty() {
    this._areFresnelDirty = true;
    this._isDirty = true;
  }
  markAsMiscDirty() {
    this._areMiscDirty = true;
    this._isDirty = true;
  }
  markAsPrePassDirty() {
    this._arePrePassDirty = true;
    this._isDirty = true;
  }
  rebuild() {
    this._keys.length = 0;
    for (const key of Object.keys(this)) {
      if (key[0] === "_") {
        continue;
      }
      this._keys.push(key);
    }
    if (this._externalProperties) {
      for (const name63 in this._externalProperties) {
        if (this._keys.indexOf(name63) === -1) {
          this._keys.push(name63);
        }
      }
    }
  }
  isEqual(other) {
    if (this._keys.length !== other._keys.length) {
      return false;
    }
    for (let index = 0; index < this._keys.length; index++) {
      const prop = this._keys[index];
      if (this[prop] !== other[prop]) {
        return false;
      }
    }
    return true;
  }
  cloneTo(other) {
    if (this._keys.length !== other._keys.length) {
      other._keys = this._keys.slice(0);
    }
    for (let index = 0; index < this._keys.length; index++) {
      const prop = this._keys[index];
      other[prop] = this[prop];
    }
  }
  reset() {
    this._keys.forEach((prop) => this._setDefaultValue(prop));
  }
  _setDefaultValue(prop) {
    var _a, _b, _c, _d, _e;
    const type = (_c = (_b = (_a = this._externalProperties) === null || _a === void 0 ? void 0 : _a[prop]) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : typeof this[prop];
    const defValue = (_e = (_d = this._externalProperties) === null || _d === void 0 ? void 0 : _d[prop]) === null || _e === void 0 ? void 0 : _e.default;
    switch (type) {
      case "number":
        this[prop] = defValue !== null && defValue !== void 0 ? defValue : 0;
        break;
      case "string":
        this[prop] = defValue !== null && defValue !== void 0 ? defValue : "";
        break;
      default:
        this[prop] = defValue !== null && defValue !== void 0 ? defValue : false;
        break;
    }
  }
  toString() {
    let result = "";
    for (let index = 0; index < this._keys.length; index++) {
      const prop = this._keys[index];
      const value = this[prop];
      const type = typeof value;
      switch (type) {
        case "number":
        case "string":
          result += "#define " + prop + " " + value + "\n";
          break;
        default:
          if (value) {
            result += "#define " + prop + "\n";
          }
          break;
      }
    }
    return result;
  }
};

// node_modules/@babylonjs/core/Materials/colorCurves.js
var ColorCurves = class {
  constructor() {
    this._dirty = true;
    this._tempColor = new Color4(0, 0, 0, 0);
    this._globalCurve = new Color4(0, 0, 0, 0);
    this._highlightsCurve = new Color4(0, 0, 0, 0);
    this._midtonesCurve = new Color4(0, 0, 0, 0);
    this._shadowsCurve = new Color4(0, 0, 0, 0);
    this._positiveCurve = new Color4(0, 0, 0, 0);
    this._negativeCurve = new Color4(0, 0, 0, 0);
    this._globalHue = 30;
    this._globalDensity = 0;
    this._globalSaturation = 0;
    this._globalExposure = 0;
    this._highlightsHue = 30;
    this._highlightsDensity = 0;
    this._highlightsSaturation = 0;
    this._highlightsExposure = 0;
    this._midtonesHue = 30;
    this._midtonesDensity = 0;
    this._midtonesSaturation = 0;
    this._midtonesExposure = 0;
    this._shadowsHue = 30;
    this._shadowsDensity = 0;
    this._shadowsSaturation = 0;
    this._shadowsExposure = 0;
  }
  get globalHue() {
    return this._globalHue;
  }
  set globalHue(value) {
    this._globalHue = value;
    this._dirty = true;
  }
  get globalDensity() {
    return this._globalDensity;
  }
  set globalDensity(value) {
    this._globalDensity = value;
    this._dirty = true;
  }
  get globalSaturation() {
    return this._globalSaturation;
  }
  set globalSaturation(value) {
    this._globalSaturation = value;
    this._dirty = true;
  }
  get globalExposure() {
    return this._globalExposure;
  }
  set globalExposure(value) {
    this._globalExposure = value;
    this._dirty = true;
  }
  get highlightsHue() {
    return this._highlightsHue;
  }
  set highlightsHue(value) {
    this._highlightsHue = value;
    this._dirty = true;
  }
  get highlightsDensity() {
    return this._highlightsDensity;
  }
  set highlightsDensity(value) {
    this._highlightsDensity = value;
    this._dirty = true;
  }
  get highlightsSaturation() {
    return this._highlightsSaturation;
  }
  set highlightsSaturation(value) {
    this._highlightsSaturation = value;
    this._dirty = true;
  }
  get highlightsExposure() {
    return this._highlightsExposure;
  }
  set highlightsExposure(value) {
    this._highlightsExposure = value;
    this._dirty = true;
  }
  get midtonesHue() {
    return this._midtonesHue;
  }
  set midtonesHue(value) {
    this._midtonesHue = value;
    this._dirty = true;
  }
  get midtonesDensity() {
    return this._midtonesDensity;
  }
  set midtonesDensity(value) {
    this._midtonesDensity = value;
    this._dirty = true;
  }
  get midtonesSaturation() {
    return this._midtonesSaturation;
  }
  set midtonesSaturation(value) {
    this._midtonesSaturation = value;
    this._dirty = true;
  }
  get midtonesExposure() {
    return this._midtonesExposure;
  }
  set midtonesExposure(value) {
    this._midtonesExposure = value;
    this._dirty = true;
  }
  get shadowsHue() {
    return this._shadowsHue;
  }
  set shadowsHue(value) {
    this._shadowsHue = value;
    this._dirty = true;
  }
  get shadowsDensity() {
    return this._shadowsDensity;
  }
  set shadowsDensity(value) {
    this._shadowsDensity = value;
    this._dirty = true;
  }
  get shadowsSaturation() {
    return this._shadowsSaturation;
  }
  set shadowsSaturation(value) {
    this._shadowsSaturation = value;
    this._dirty = true;
  }
  get shadowsExposure() {
    return this._shadowsExposure;
  }
  set shadowsExposure(value) {
    this._shadowsExposure = value;
    this._dirty = true;
  }
  getClassName() {
    return "ColorCurves";
  }
  static Bind(colorCurves, effect, positiveUniform = "vCameraColorCurvePositive", neutralUniform = "vCameraColorCurveNeutral", negativeUniform = "vCameraColorCurveNegative") {
    if (colorCurves._dirty) {
      colorCurves._dirty = false;
      colorCurves._getColorGradingDataToRef(colorCurves._globalHue, colorCurves._globalDensity, colorCurves._globalSaturation, colorCurves._globalExposure, colorCurves._globalCurve);
      colorCurves._getColorGradingDataToRef(colorCurves._highlightsHue, colorCurves._highlightsDensity, colorCurves._highlightsSaturation, colorCurves._highlightsExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._highlightsCurve);
      colorCurves._getColorGradingDataToRef(colorCurves._midtonesHue, colorCurves._midtonesDensity, colorCurves._midtonesSaturation, colorCurves._midtonesExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._midtonesCurve);
      colorCurves._getColorGradingDataToRef(colorCurves._shadowsHue, colorCurves._shadowsDensity, colorCurves._shadowsSaturation, colorCurves._shadowsExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._shadowsCurve);
      colorCurves._highlightsCurve.subtractToRef(colorCurves._midtonesCurve, colorCurves._positiveCurve);
      colorCurves._midtonesCurve.subtractToRef(colorCurves._shadowsCurve, colorCurves._negativeCurve);
    }
    if (effect) {
      effect.setFloat4(positiveUniform, colorCurves._positiveCurve.r, colorCurves._positiveCurve.g, colorCurves._positiveCurve.b, colorCurves._positiveCurve.a);
      effect.setFloat4(neutralUniform, colorCurves._midtonesCurve.r, colorCurves._midtonesCurve.g, colorCurves._midtonesCurve.b, colorCurves._midtonesCurve.a);
      effect.setFloat4(negativeUniform, colorCurves._negativeCurve.r, colorCurves._negativeCurve.g, colorCurves._negativeCurve.b, colorCurves._negativeCurve.a);
    }
  }
  static PrepareUniforms(uniformsList) {
    uniformsList.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative");
  }
  _getColorGradingDataToRef(hue, density, saturation, exposure, result) {
    if (hue == null) {
      return;
    }
    hue = ColorCurves._Clamp(hue, 0, 360);
    density = ColorCurves._Clamp(density, -100, 100);
    saturation = ColorCurves._Clamp(saturation, -100, 100);
    exposure = ColorCurves._Clamp(exposure, -100, 100);
    density = ColorCurves._ApplyColorGradingSliderNonlinear(density);
    density *= 0.5;
    exposure = ColorCurves._ApplyColorGradingSliderNonlinear(exposure);
    if (density < 0) {
      density *= -1;
      hue = (hue + 180) % 360;
    }
    ColorCurves._FromHSBToRef(hue, density, 50 + 0.25 * exposure, result);
    result.scaleToRef(2, result);
    result.a = 1 + 0.01 * saturation;
  }
  static _ApplyColorGradingSliderNonlinear(value) {
    value /= 100;
    let x = Math.abs(value);
    x = Math.pow(x, 2);
    if (value < 0) {
      x *= -1;
    }
    x *= 100;
    return x;
  }
  static _FromHSBToRef(hue, saturation, brightness, result) {
    let h = ColorCurves._Clamp(hue, 0, 360);
    const s = ColorCurves._Clamp(saturation / 100, 0, 1);
    const v = ColorCurves._Clamp(brightness / 100, 0, 1);
    if (s === 0) {
      result.r = v;
      result.g = v;
      result.b = v;
    } else {
      h /= 60;
      const i = Math.floor(h);
      const f = h - i;
      const p = v * (1 - s);
      const q = v * (1 - s * f);
      const t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          result.r = v;
          result.g = t;
          result.b = p;
          break;
        case 1:
          result.r = q;
          result.g = v;
          result.b = p;
          break;
        case 2:
          result.r = p;
          result.g = v;
          result.b = t;
          break;
        case 3:
          result.r = p;
          result.g = q;
          result.b = v;
          break;
        case 4:
          result.r = t;
          result.g = p;
          result.b = v;
          break;
        default:
          result.r = v;
          result.g = p;
          result.b = q;
          break;
      }
    }
    result.a = 1;
  }
  static _Clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }
  clone() {
    return SerializationHelper.Clone(() => new ColorCurves(), this);
  }
  serialize() {
    return SerializationHelper.Serialize(this);
  }
  static Parse(source) {
    return SerializationHelper.Parse(() => new ColorCurves(), source, null, null);
  }
};
__decorate([
  serialize()
], ColorCurves.prototype, "_globalHue", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_globalDensity", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_globalSaturation", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_globalExposure", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsHue", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsDensity", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsSaturation", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsExposure", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesHue", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesDensity", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesSaturation", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesExposure", void 0);
SerializationHelper._ColorCurvesParser = ColorCurves.Parse;

// node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.js
var ImageProcessingConfigurationDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.IMAGEPROCESSING = false;
    this.VIGNETTE = false;
    this.VIGNETTEBLENDMODEMULTIPLY = false;
    this.VIGNETTEBLENDMODEOPAQUE = false;
    this.TONEMAPPING = false;
    this.TONEMAPPING_ACES = false;
    this.CONTRAST = false;
    this.COLORCURVES = false;
    this.COLORGRADING = false;
    this.COLORGRADING3D = false;
    this.SAMPLER3DGREENDEPTH = false;
    this.SAMPLER3DBGRMAP = false;
    this.DITHER = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.EXPOSURE = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.rebuild();
  }
};
var ImageProcessingConfiguration = class {
  constructor() {
    this.colorCurves = new ColorCurves();
    this._colorCurvesEnabled = false;
    this._colorGradingEnabled = false;
    this._colorGradingWithGreenDepth = true;
    this._colorGradingBGR = true;
    this._exposure = 1;
    this._toneMappingEnabled = false;
    this._toneMappingType = ImageProcessingConfiguration.TONEMAPPING_STANDARD;
    this._contrast = 1;
    this.vignetteStretch = 0;
    this.vignetteCenterX = 0;
    this.vignetteCenterY = 0;
    this.vignetteWeight = 1.5;
    this.vignetteColor = new Color4(0, 0, 0, 0);
    this.vignetteCameraFov = 0.5;
    this._vignetteBlendMode = ImageProcessingConfiguration.VIGNETTEMODE_MULTIPLY;
    this._vignetteEnabled = false;
    this._ditheringEnabled = false;
    this._ditheringIntensity = 1 / 255;
    this._skipFinalColorClamp = false;
    this._applyByPostProcess = false;
    this._isEnabled = true;
    this.onUpdateParameters = new Observable();
  }
  get colorCurvesEnabled() {
    return this._colorCurvesEnabled;
  }
  set colorCurvesEnabled(value) {
    if (this._colorCurvesEnabled === value) {
      return;
    }
    this._colorCurvesEnabled = value;
    this._updateParameters();
  }
  get colorGradingTexture() {
    return this._colorGradingTexture;
  }
  set colorGradingTexture(value) {
    if (this._colorGradingTexture === value) {
      return;
    }
    this._colorGradingTexture = value;
    this._updateParameters();
  }
  get colorGradingEnabled() {
    return this._colorGradingEnabled;
  }
  set colorGradingEnabled(value) {
    if (this._colorGradingEnabled === value) {
      return;
    }
    this._colorGradingEnabled = value;
    this._updateParameters();
  }
  get colorGradingWithGreenDepth() {
    return this._colorGradingWithGreenDepth;
  }
  set colorGradingWithGreenDepth(value) {
    if (this._colorGradingWithGreenDepth === value) {
      return;
    }
    this._colorGradingWithGreenDepth = value;
    this._updateParameters();
  }
  get colorGradingBGR() {
    return this._colorGradingBGR;
  }
  set colorGradingBGR(value) {
    if (this._colorGradingBGR === value) {
      return;
    }
    this._colorGradingBGR = value;
    this._updateParameters();
  }
  get exposure() {
    return this._exposure;
  }
  set exposure(value) {
    if (this._exposure === value) {
      return;
    }
    this._exposure = value;
    this._updateParameters();
  }
  get toneMappingEnabled() {
    return this._toneMappingEnabled;
  }
  set toneMappingEnabled(value) {
    if (this._toneMappingEnabled === value) {
      return;
    }
    this._toneMappingEnabled = value;
    this._updateParameters();
  }
  get toneMappingType() {
    return this._toneMappingType;
  }
  set toneMappingType(value) {
    if (this._toneMappingType === value) {
      return;
    }
    this._toneMappingType = value;
    this._updateParameters();
  }
  get contrast() {
    return this._contrast;
  }
  set contrast(value) {
    if (this._contrast === value) {
      return;
    }
    this._contrast = value;
    this._updateParameters();
  }
  get vignetteCentreY() {
    return this.vignetteCenterY;
  }
  set vignetteCentreY(value) {
    this.vignetteCenterY = value;
  }
  get vignetteCentreX() {
    return this.vignetteCenterX;
  }
  set vignetteCentreX(value) {
    this.vignetteCenterX = value;
  }
  get vignetteBlendMode() {
    return this._vignetteBlendMode;
  }
  set vignetteBlendMode(value) {
    if (this._vignetteBlendMode === value) {
      return;
    }
    this._vignetteBlendMode = value;
    this._updateParameters();
  }
  get vignetteEnabled() {
    return this._vignetteEnabled;
  }
  set vignetteEnabled(value) {
    if (this._vignetteEnabled === value) {
      return;
    }
    this._vignetteEnabled = value;
    this._updateParameters();
  }
  get ditheringEnabled() {
    return this._ditheringEnabled;
  }
  set ditheringEnabled(value) {
    if (this._ditheringEnabled === value) {
      return;
    }
    this._ditheringEnabled = value;
    this._updateParameters();
  }
  get ditheringIntensity() {
    return this._ditheringIntensity;
  }
  set ditheringIntensity(value) {
    if (this._ditheringIntensity === value) {
      return;
    }
    this._ditheringIntensity = value;
    this._updateParameters();
  }
  get skipFinalColorClamp() {
    return this._skipFinalColorClamp;
  }
  set skipFinalColorClamp(value) {
    if (this._skipFinalColorClamp === value) {
      return;
    }
    this._skipFinalColorClamp = value;
    this._updateParameters();
  }
  get applyByPostProcess() {
    return this._applyByPostProcess;
  }
  set applyByPostProcess(value) {
    if (this._applyByPostProcess === value) {
      return;
    }
    this._applyByPostProcess = value;
    this._updateParameters();
  }
  get isEnabled() {
    return this._isEnabled;
  }
  set isEnabled(value) {
    if (this._isEnabled === value) {
      return;
    }
    this._isEnabled = value;
    this._updateParameters();
  }
  _updateParameters() {
    this.onUpdateParameters.notifyObservers(this);
  }
  getClassName() {
    return "ImageProcessingConfiguration";
  }
  static PrepareUniforms(uniforms, defines) {
    if (defines.EXPOSURE) {
      uniforms.push("exposureLinear");
    }
    if (defines.CONTRAST) {
      uniforms.push("contrast");
    }
    if (defines.COLORGRADING) {
      uniforms.push("colorTransformSettings");
    }
    if (defines.VIGNETTE || defines.DITHER) {
      uniforms.push("vInverseScreenSize");
    }
    if (defines.VIGNETTE) {
      uniforms.push("vignetteSettings1");
      uniforms.push("vignetteSettings2");
    }
    if (defines.COLORCURVES) {
      ColorCurves.PrepareUniforms(uniforms);
    }
    if (defines.DITHER) {
      uniforms.push("ditherIntensity");
    }
  }
  static PrepareSamplers(samplersList, defines) {
    if (defines.COLORGRADING) {
      samplersList.push("txColorTransform");
    }
  }
  prepareDefines(defines, forPostProcess = false) {
    if (forPostProcess !== this.applyByPostProcess || !this._isEnabled) {
      defines.VIGNETTE = false;
      defines.TONEMAPPING = false;
      defines.TONEMAPPING_ACES = false;
      defines.CONTRAST = false;
      defines.EXPOSURE = false;
      defines.COLORCURVES = false;
      defines.COLORGRADING = false;
      defines.COLORGRADING3D = false;
      defines.DITHER = false;
      defines.IMAGEPROCESSING = false;
      defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
      defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled;
      return;
    }
    defines.VIGNETTE = this.vignetteEnabled;
    defines.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === ImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY;
    defines.VIGNETTEBLENDMODEOPAQUE = !defines.VIGNETTEBLENDMODEMULTIPLY;
    defines.TONEMAPPING = this.toneMappingEnabled;
    switch (this._toneMappingType) {
      case ImageProcessingConfiguration.TONEMAPPING_ACES:
        defines.TONEMAPPING_ACES = true;
        break;
      default:
        defines.TONEMAPPING_ACES = false;
        break;
    }
    defines.CONTRAST = this.contrast !== 1;
    defines.EXPOSURE = this.exposure !== 1;
    defines.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves;
    defines.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture;
    if (defines.COLORGRADING) {
      defines.COLORGRADING3D = this.colorGradingTexture.is3D;
    } else {
      defines.COLORGRADING3D = false;
    }
    defines.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth;
    defines.SAMPLER3DBGRMAP = this.colorGradingBGR;
    defines.DITHER = this._ditheringEnabled;
    defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess;
    defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
    defines.IMAGEPROCESSING = defines.VIGNETTE || defines.TONEMAPPING || defines.CONTRAST || defines.EXPOSURE || defines.COLORCURVES || defines.COLORGRADING || defines.DITHER;
  }
  isReady() {
    return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();
  }
  bind(effect, overrideAspectRatio) {
    if (this._colorCurvesEnabled && this.colorCurves) {
      ColorCurves.Bind(this.colorCurves, effect);
    }
    if (this._vignetteEnabled || this._ditheringEnabled) {
      const inverseWidth = 1 / effect.getEngine().getRenderWidth();
      const inverseHeight = 1 / effect.getEngine().getRenderHeight();
      effect.setFloat2("vInverseScreenSize", inverseWidth, inverseHeight);
      if (this._ditheringEnabled) {
        effect.setFloat("ditherIntensity", 0.5 * this._ditheringIntensity);
      }
      if (this._vignetteEnabled) {
        const aspectRatio = overrideAspectRatio != null ? overrideAspectRatio : inverseHeight / inverseWidth;
        let vignetteScaleY = Math.tan(this.vignetteCameraFov * 0.5);
        let vignetteScaleX = vignetteScaleY * aspectRatio;
        const vignetteScaleGeometricMean = Math.sqrt(vignetteScaleX * vignetteScaleY);
        vignetteScaleX = Tools.Mix(vignetteScaleX, vignetteScaleGeometricMean, this.vignetteStretch);
        vignetteScaleY = Tools.Mix(vignetteScaleY, vignetteScaleGeometricMean, this.vignetteStretch);
        effect.setFloat4("vignetteSettings1", vignetteScaleX, vignetteScaleY, -vignetteScaleX * this.vignetteCenterX, -vignetteScaleY * this.vignetteCenterY);
        const vignettePower = -2 * this.vignetteWeight;
        effect.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, vignettePower);
      }
    }
    effect.setFloat("exposureLinear", this.exposure);
    effect.setFloat("contrast", this.contrast);
    if (this.colorGradingTexture) {
      effect.setTexture("txColorTransform", this.colorGradingTexture);
      const textureSize = this.colorGradingTexture.getSize().height;
      effect.setFloat4(
        "colorTransformSettings",
        (textureSize - 1) / textureSize,
        0.5 / textureSize,
        textureSize,
        this.colorGradingTexture.level
      );
    }
  }
  clone() {
    return SerializationHelper.Clone(() => new ImageProcessingConfiguration(), this);
  }
  serialize() {
    return SerializationHelper.Serialize(this);
  }
  static Parse(source) {
    const parsed = SerializationHelper.Parse(() => new ImageProcessingConfiguration(), source, null, null);
    if (source.vignetteCentreX !== void 0) {
      parsed.vignetteCenterX = source.vignetteCentreX;
    }
    if (source.vignetteCentreY !== void 0) {
      parsed.vignetteCenterY = source.vignetteCentreY;
    }
    return parsed;
  }
  static get VIGNETTEMODE_MULTIPLY() {
    return this._VIGNETTEMODE_MULTIPLY;
  }
  static get VIGNETTEMODE_OPAQUE() {
    return this._VIGNETTEMODE_OPAQUE;
  }
};
ImageProcessingConfiguration.TONEMAPPING_STANDARD = 0;
ImageProcessingConfiguration.TONEMAPPING_ACES = 1;
ImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY = 0;
ImageProcessingConfiguration._VIGNETTEMODE_OPAQUE = 1;
__decorate([
  serializeAsColorCurves()
], ImageProcessingConfiguration.prototype, "colorCurves", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorCurvesEnabled", void 0);
__decorate([
  serializeAsTexture("colorGradingTexture")
], ImageProcessingConfiguration.prototype, "_colorGradingTexture", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorGradingEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorGradingWithGreenDepth", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorGradingBGR", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_exposure", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_toneMappingEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_toneMappingType", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_contrast", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteStretch", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteCenterX", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteCenterY", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteWeight", void 0);
__decorate([
  serializeAsColor4()
], ImageProcessingConfiguration.prototype, "vignetteColor", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteCameraFov", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_vignetteBlendMode", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_vignetteEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_ditheringEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_ditheringIntensity", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_skipFinalColorClamp", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_applyByPostProcess", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_isEnabled", void 0);
SerializationHelper._ImageProcessingConfigurationParser = ImageProcessingConfiguration.Parse;

// node_modules/@babylonjs/core/Engines/Extensions/engine.uniformBuffer.js
ThinEngine.prototype.createUniformBuffer = function(elements) {
  const ubo = this._gl.createBuffer();
  if (!ubo) {
    throw new Error("Unable to create uniform buffer");
  }
  const result = new WebGLDataBuffer(ubo);
  this.bindUniformBuffer(result);
  if (elements instanceof Float32Array) {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.STATIC_DRAW);
  } else {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.STATIC_DRAW);
  }
  this.bindUniformBuffer(null);
  result.references = 1;
  return result;
};
ThinEngine.prototype.createDynamicUniformBuffer = function(elements) {
  const ubo = this._gl.createBuffer();
  if (!ubo) {
    throw new Error("Unable to create dynamic uniform buffer");
  }
  const result = new WebGLDataBuffer(ubo);
  this.bindUniformBuffer(result);
  if (elements instanceof Float32Array) {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.DYNAMIC_DRAW);
  } else {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.DYNAMIC_DRAW);
  }
  this.bindUniformBuffer(null);
  result.references = 1;
  return result;
};
ThinEngine.prototype.updateUniformBuffer = function(uniformBuffer, elements, offset, count) {
  this.bindUniformBuffer(uniformBuffer);
  if (offset === void 0) {
    offset = 0;
  }
  if (count === void 0) {
    if (elements instanceof Float32Array) {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, elements);
    } else {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, new Float32Array(elements));
    }
  } else {
    if (elements instanceof Float32Array) {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, elements.subarray(offset, offset + count));
    } else {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(elements).subarray(offset, offset + count));
    }
  }
  this.bindUniformBuffer(null);
};
ThinEngine.prototype.bindUniformBuffer = function(buffer) {
  this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, buffer ? buffer.underlyingResource : null);
};
ThinEngine.prototype.bindUniformBufferBase = function(buffer, location2, name63) {
  this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, location2, buffer ? buffer.underlyingResource : null);
};
ThinEngine.prototype.bindUniformBlock = function(pipelineContext, blockName, index) {
  const program = pipelineContext.program;
  const uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
  if (uniformLocation !== 4294967295) {
    this._gl.uniformBlockBinding(program, uniformLocation, index);
  }
};

// node_modules/@babylonjs/core/Materials/uniformBuffer.js
var UniformBuffer = class {
  constructor(engine, data, dynamic, name63, forceNoUniformBuffer = false) {
    this._valueCache = {};
    this._engine = engine;
    this._noUBO = !engine.supportsUniformBuffers || forceNoUniformBuffer;
    this._dynamic = dynamic;
    this._name = name63 !== null && name63 !== void 0 ? name63 : "no-name";
    this._data = data || [];
    this._uniformLocations = {};
    this._uniformSizes = {};
    this._uniformArraySizes = {};
    this._uniformLocationPointer = 0;
    this._needSync = false;
    if (this._engine._features.trackUbosInFrame) {
      this._buffers = [];
      this._bufferIndex = -1;
      this._createBufferOnWrite = false;
      this._currentFrameId = 0;
    }
    if (this._noUBO) {
      this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;
      this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;
      this.updateFloat = this._updateFloatForEffect;
      this.updateFloat2 = this._updateFloat2ForEffect;
      this.updateFloat3 = this._updateFloat3ForEffect;
      this.updateFloat4 = this._updateFloat4ForEffect;
      this.updateFloatArray = this._updateFloatArrayForEffect;
      this.updateArray = this._updateArrayForEffect;
      this.updateIntArray = this._updateIntArrayForEffect;
      this.updateMatrix = this._updateMatrixForEffect;
      this.updateMatrices = this._updateMatricesForEffect;
      this.updateVector3 = this._updateVector3ForEffect;
      this.updateVector4 = this._updateVector4ForEffect;
      this.updateColor3 = this._updateColor3ForEffect;
      this.updateColor4 = this._updateColor4ForEffect;
      this.updateDirectColor4 = this._updateDirectColor4ForEffect;
      this.updateInt = this._updateIntForEffect;
      this.updateInt2 = this._updateInt2ForEffect;
      this.updateInt3 = this._updateInt3ForEffect;
      this.updateInt4 = this._updateInt4ForEffect;
    } else {
      this._engine._uniformBuffers.push(this);
      this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;
      this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;
      this.updateFloat = this._updateFloatForUniform;
      this.updateFloat2 = this._updateFloat2ForUniform;
      this.updateFloat3 = this._updateFloat3ForUniform;
      this.updateFloat4 = this._updateFloat4ForUniform;
      this.updateFloatArray = this._updateFloatArrayForUniform;
      this.updateArray = this._updateArrayForUniform;
      this.updateIntArray = this._updateIntArrayForUniform;
      this.updateMatrix = this._updateMatrixForUniform;
      this.updateMatrices = this._updateMatricesForUniform;
      this.updateVector3 = this._updateVector3ForUniform;
      this.updateVector4 = this._updateVector4ForUniform;
      this.updateColor3 = this._updateColor3ForUniform;
      this.updateColor4 = this._updateColor4ForUniform;
      this.updateDirectColor4 = this._updateDirectColor4ForUniform;
      this.updateInt = this._updateIntForUniform;
      this.updateInt2 = this._updateInt2ForUniform;
      this.updateInt3 = this._updateInt3ForUniform;
      this.updateInt4 = this._updateInt4ForUniform;
    }
  }
  get useUbo() {
    return !this._noUBO;
  }
  get isSync() {
    return !this._needSync;
  }
  isDynamic() {
    return this._dynamic !== void 0;
  }
  getData() {
    return this._bufferData;
  }
  getBuffer() {
    return this._buffer;
  }
  _fillAlignment(size) {
    let alignment;
    if (size <= 2) {
      alignment = size;
    } else {
      alignment = 4;
    }
    if (this._uniformLocationPointer % alignment !== 0) {
      const oldPointer = this._uniformLocationPointer;
      this._uniformLocationPointer += alignment - this._uniformLocationPointer % alignment;
      const diff = this._uniformLocationPointer - oldPointer;
      for (let i = 0; i < diff; i++) {
        this._data.push(0);
      }
    }
  }
  addUniform(name63, size, arraySize = 0) {
    if (this._noUBO) {
      return;
    }
    if (this._uniformLocations[name63] !== void 0) {
      return;
    }
    let data;
    if (arraySize > 0) {
      if (size instanceof Array) {
        throw "addUniform should not be use with Array in UBO: " + name63;
      }
      this._fillAlignment(4);
      this._uniformArraySizes[name63] = { strideSize: size, arraySize };
      if (size == 16) {
        size = size * arraySize;
      } else {
        const perElementPadding = 4 - size;
        const totalPadding = perElementPadding * arraySize;
        size = size * arraySize + totalPadding;
      }
      data = [];
      for (let i = 0; i < size; i++) {
        data.push(0);
      }
    } else {
      if (size instanceof Array) {
        data = size;
        size = data.length;
      } else {
        size = size;
        data = [];
        for (let i = 0; i < size; i++) {
          data.push(0);
        }
      }
      this._fillAlignment(size);
    }
    this._uniformSizes[name63] = size;
    this._uniformLocations[name63] = this._uniformLocationPointer;
    this._uniformLocationPointer += size;
    for (let i = 0; i < size; i++) {
      this._data.push(data[i]);
    }
    this._needSync = true;
  }
  addMatrix(name63, mat) {
    this.addUniform(name63, Array.prototype.slice.call(mat.toArray()));
  }
  addFloat2(name63, x, y) {
    const temp = [x, y];
    this.addUniform(name63, temp);
  }
  addFloat3(name63, x, y, z) {
    const temp = [x, y, z];
    this.addUniform(name63, temp);
  }
  addColor3(name63, color) {
    const temp = [color.r, color.g, color.b];
    this.addUniform(name63, temp);
  }
  addColor4(name63, color, alpha) {
    const temp = [color.r, color.g, color.b, alpha];
    this.addUniform(name63, temp);
  }
  addVector3(name63, vector) {
    const temp = [vector.x, vector.y, vector.z];
    this.addUniform(name63, temp);
  }
  addMatrix3x3(name63) {
    this.addUniform(name63, 12);
  }
  addMatrix2x2(name63) {
    this.addUniform(name63, 8);
  }
  create() {
    if (this._noUBO) {
      return;
    }
    if (this._buffer) {
      return;
    }
    this._fillAlignment(4);
    this._bufferData = new Float32Array(this._data);
    this._rebuild();
    this._needSync = true;
  }
  _rebuild() {
    if (this._noUBO || !this._bufferData) {
      return;
    }
    if (this._dynamic) {
      this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData);
    } else {
      this._buffer = this._engine.createUniformBuffer(this._bufferData);
    }
    if (this._engine._features.trackUbosInFrame) {
      this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : void 0]);
      this._bufferIndex = this._buffers.length - 1;
      this._createBufferOnWrite = false;
    }
  }
  get _numBuffers() {
    return this._buffers.length;
  }
  get _indexBuffer() {
    return this._bufferIndex;
  }
  get name() {
    return this._name;
  }
  _buffersEqual(buf1, buf2) {
    for (let i = 0; i < buf1.length; ++i) {
      if (buf1[i] !== buf2[i]) {
        return false;
      }
    }
    return true;
  }
  _copyBuffer(src, dst) {
    for (let i = 0; i < src.length; ++i) {
      dst[i] = src[i];
    }
  }
  update() {
    if (this._noUBO) {
      return;
    }
    this.bindUniformBuffer();
    if (!this._buffer) {
      this.create();
      return;
    }
    if (!this._dynamic && !this._needSync) {
      this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
      return;
    }
    if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {
      if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1])) {
        this._needSync = false;
        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
        return;
      } else {
        this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]);
      }
    }
    this._engine.updateUniformBuffer(this._buffer, this._bufferData);
    if (this._engine._features._collectUbosUpdatedInFrame) {
      if (!UniformBuffer._UpdatedUbosInFrame[this._name]) {
        UniformBuffer._UpdatedUbosInFrame[this._name] = 0;
      }
      UniformBuffer._UpdatedUbosInFrame[this._name]++;
    }
    this._needSync = false;
    this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
  }
  _createNewBuffer() {
    if (this._bufferIndex + 1 < this._buffers.length) {
      this._bufferIndex++;
      this._buffer = this._buffers[this._bufferIndex][0];
      this._createBufferOnWrite = false;
      this._needSync = true;
    } else {
      this._rebuild();
    }
  }
  _checkNewFrame() {
    if (this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId) {
      this._currentFrameId = this._engine.frameId;
      this._createBufferOnWrite = false;
      if (this._buffers && this._buffers.length > 0) {
        this._needSync = this._bufferIndex !== 0;
        this._bufferIndex = 0;
        this._buffer = this._buffers[this._bufferIndex][0];
      } else {
        this._bufferIndex = -1;
      }
    }
  }
  updateUniform(uniformName, data, size) {
    this._checkNewFrame();
    let location2 = this._uniformLocations[uniformName];
    if (location2 === void 0) {
      if (this._buffer) {
        Logger.Error("Cannot add an uniform after UBO has been created.");
        return;
      }
      this.addUniform(uniformName, size);
      location2 = this._uniformLocations[uniformName];
    }
    if (!this._buffer) {
      this.create();
    }
    if (!this._dynamic) {
      let changed = false;
      for (let i = 0; i < size; i++) {
        if (size === 16 && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[location2 + i] !== Tools.FloatRound(data[i])) {
          changed = true;
          if (this._createBufferOnWrite) {
            this._createNewBuffer();
          }
          this._bufferData[location2 + i] = data[i];
        }
      }
      this._needSync = this._needSync || changed;
    } else {
      for (let i = 0; i < size; i++) {
        this._bufferData[location2 + i] = data[i];
      }
    }
  }
  updateUniformArray(uniformName, data, size) {
    this._checkNewFrame();
    const location2 = this._uniformLocations[uniformName];
    if (location2 === void 0) {
      Logger.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.");
      return;
    }
    if (!this._buffer) {
      this.create();
    }
    const arraySizes = this._uniformArraySizes[uniformName];
    if (!this._dynamic) {
      let changed = false;
      let countToFour = 0;
      let baseStride = 0;
      for (let i = 0; i < size; i++) {
        if (this._bufferData[location2 + baseStride * 4 + countToFour] !== Tools.FloatRound(data[i])) {
          changed = true;
          if (this._createBufferOnWrite) {
            this._createNewBuffer();
          }
          this._bufferData[location2 + baseStride * 4 + countToFour] = data[i];
        }
        countToFour++;
        if (countToFour === arraySizes.strideSize) {
          for (; countToFour < 4; countToFour++) {
            this._bufferData[location2 + baseStride * 4 + countToFour] = 0;
          }
          countToFour = 0;
          baseStride++;
        }
      }
      this._needSync = this._needSync || changed;
    } else {
      for (let i = 0; i < size; i++) {
        this._bufferData[location2 + i] = data[i];
      }
    }
  }
  _cacheMatrix(name63, matrix) {
    this._checkNewFrame();
    const cache = this._valueCache[name63];
    const flag = matrix.updateFlag;
    if (cache !== void 0 && cache === flag) {
      return false;
    }
    this._valueCache[name63] = flag;
    return true;
  }
  _updateMatrix3x3ForUniform(name63, matrix) {
    for (let i = 0; i < 3; i++) {
      UniformBuffer._TempBuffer[i * 4] = matrix[i * 3];
      UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 3 + 1];
      UniformBuffer._TempBuffer[i * 4 + 2] = matrix[i * 3 + 2];
      UniformBuffer._TempBuffer[i * 4 + 3] = 0;
    }
    this.updateUniform(name63, UniformBuffer._TempBuffer, 12);
  }
  _updateMatrix3x3ForEffect(name63, matrix) {
    this._currentEffect.setMatrix3x3(name63, matrix);
  }
  _updateMatrix2x2ForEffect(name63, matrix) {
    this._currentEffect.setMatrix2x2(name63, matrix);
  }
  _updateMatrix2x2ForUniform(name63, matrix) {
    for (let i = 0; i < 2; i++) {
      UniformBuffer._TempBuffer[i * 4] = matrix[i * 2];
      UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 2 + 1];
      UniformBuffer._TempBuffer[i * 4 + 2] = 0;
      UniformBuffer._TempBuffer[i * 4 + 3] = 0;
    }
    this.updateUniform(name63, UniformBuffer._TempBuffer, 8);
  }
  _updateFloatForEffect(name63, x) {
    this._currentEffect.setFloat(name63, x);
  }
  _updateFloatForUniform(name63, x) {
    UniformBuffer._TempBuffer[0] = x;
    this.updateUniform(name63, UniformBuffer._TempBuffer, 1);
  }
  _updateFloat2ForEffect(name63, x, y, suffix = "") {
    this._currentEffect.setFloat2(name63 + suffix, x, y);
  }
  _updateFloat2ForUniform(name63, x, y) {
    UniformBuffer._TempBuffer[0] = x;
    UniformBuffer._TempBuffer[1] = y;
    this.updateUniform(name63, UniformBuffer._TempBuffer, 2);
  }
  _updateFloat3ForEffect(name63, x, y, z, suffix = "") {
    this._currentEffect.setFloat3(name63 + suffix, x, y, z);
  }
  _updateFloat3ForUniform(name63, x, y, z) {
    UniformBuffer._TempBuffer[0] = x;
    UniformBuffer._TempBuffer[1] = y;
    UniformBuffer._TempBuffer[2] = z;
    this.updateUniform(name63, UniformBuffer._TempBuffer, 3);
  }
  _updateFloat4ForEffect(name63, x, y, z, w, suffix = "") {
    this._currentEffect.setFloat4(name63 + suffix, x, y, z, w);
  }
  _updateFloat4ForUniform(name63, x, y, z, w) {
    UniformBuffer._TempBuffer[0] = x;
    UniformBuffer._TempBuffer[1] = y;
    UniformBuffer._TempBuffer[2] = z;
    UniformBuffer._TempBuffer[3] = w;
    this.updateUniform(name63, UniformBuffer._TempBuffer, 4);
  }
  _updateFloatArrayForEffect(name63, array) {
    this._currentEffect.setFloatArray(name63, array);
  }
  _updateFloatArrayForUniform(name63, array) {
    this.updateUniformArray(name63, array, array.length);
  }
  _updateArrayForEffect(name63, array) {
    this._currentEffect.setArray(name63, array);
  }
  _updateArrayForUniform(name63, array) {
    this.updateUniformArray(name63, array, array.length);
  }
  _updateIntArrayForEffect(name63, array) {
    this._currentEffect.setIntArray(name63, array);
  }
  _updateIntArrayForUniform(name63, array) {
    UniformBuffer._TempBufferInt32View.set(array);
    this.updateUniformArray(name63, UniformBuffer._TempBuffer, array.length);
  }
  _updateMatrixForEffect(name63, mat) {
    this._currentEffect.setMatrix(name63, mat);
  }
  _updateMatrixForUniform(name63, mat) {
    if (this._cacheMatrix(name63, mat)) {
      this.updateUniform(name63, mat.toArray(), 16);
    }
  }
  _updateMatricesForEffect(name63, mat) {
    this._currentEffect.setMatrices(name63, mat);
  }
  _updateMatricesForUniform(name63, mat) {
    this.updateUniform(name63, mat, mat.length);
  }
  _updateVector3ForEffect(name63, vector) {
    this._currentEffect.setVector3(name63, vector);
  }
  _updateVector3ForUniform(name63, vector) {
    UniformBuffer._TempBuffer[0] = vector.x;
    UniformBuffer._TempBuffer[1] = vector.y;
    UniformBuffer._TempBuffer[2] = vector.z;
    this.updateUniform(name63, UniformBuffer._TempBuffer, 3);
  }
  _updateVector4ForEffect(name63, vector) {
    this._currentEffect.setVector4(name63, vector);
  }
  _updateVector4ForUniform(name63, vector) {
    UniformBuffer._TempBuffer[0] = vector.x;
    UniformBuffer._TempBuffer[1] = vector.y;
    UniformBuffer._TempBuffer[2] = vector.z;
    UniformBuffer._TempBuffer[3] = vector.w;
    this.updateUniform(name63, UniformBuffer._TempBuffer, 4);
  }
  _updateColor3ForEffect(name63, color, suffix = "") {
    this._currentEffect.setColor3(name63 + suffix, color);
  }
  _updateColor3ForUniform(name63, color) {
    UniformBuffer._TempBuffer[0] = color.r;
    UniformBuffer._TempBuffer[1] = color.g;
    UniformBuffer._TempBuffer[2] = color.b;
    this.updateUniform(name63, UniformBuffer._TempBuffer, 3);
  }
  _updateColor4ForEffect(name63, color, alpha, suffix = "") {
    this._currentEffect.setColor4(name63 + suffix, color, alpha);
  }
  _updateDirectColor4ForEffect(name63, color, suffix = "") {
    this._currentEffect.setDirectColor4(name63 + suffix, color);
  }
  _updateColor4ForUniform(name63, color, alpha) {
    UniformBuffer._TempBuffer[0] = color.r;
    UniformBuffer._TempBuffer[1] = color.g;
    UniformBuffer._TempBuffer[2] = color.b;
    UniformBuffer._TempBuffer[3] = alpha;
    this.updateUniform(name63, UniformBuffer._TempBuffer, 4);
  }
  _updateDirectColor4ForUniform(name63, color) {
    UniformBuffer._TempBuffer[0] = color.r;
    UniformBuffer._TempBuffer[1] = color.g;
    UniformBuffer._TempBuffer[2] = color.b;
    UniformBuffer._TempBuffer[3] = color.a;
    this.updateUniform(name63, UniformBuffer._TempBuffer, 4);
  }
  _updateIntForEffect(name63, x, suffix = "") {
    this._currentEffect.setInt(name63 + suffix, x);
  }
  _updateIntForUniform(name63, x) {
    UniformBuffer._TempBufferInt32View[0] = x;
    this.updateUniform(name63, UniformBuffer._TempBuffer, 1);
  }
  _updateInt2ForEffect(name63, x, y, suffix = "") {
    this._currentEffect.setInt2(name63 + suffix, x, y);
  }
  _updateInt2ForUniform(name63, x, y) {
    UniformBuffer._TempBufferInt32View[0] = x;
    UniformBuffer._TempBufferInt32View[1] = y;
    this.updateUniform(name63, UniformBuffer._TempBuffer, 2);
  }
  _updateInt3ForEffect(name63, x, y, z, suffix = "") {
    this._currentEffect.setInt3(name63 + suffix, x, y, z);
  }
  _updateInt3ForUniform(name63, x, y, z) {
    UniformBuffer._TempBufferInt32View[0] = x;
    UniformBuffer._TempBufferInt32View[1] = y;
    UniformBuffer._TempBufferInt32View[2] = z;
    this.updateUniform(name63, UniformBuffer._TempBuffer, 3);
  }
  _updateInt4ForEffect(name63, x, y, z, w, suffix = "") {
    this._currentEffect.setInt4(name63 + suffix, x, y, z, w);
  }
  _updateInt4ForUniform(name63, x, y, z, w) {
    UniformBuffer._TempBufferInt32View[0] = x;
    UniformBuffer._TempBufferInt32View[1] = y;
    UniformBuffer._TempBufferInt32View[2] = z;
    UniformBuffer._TempBufferInt32View[3] = w;
    this.updateUniform(name63, UniformBuffer._TempBuffer, 4);
  }
  setTexture(name63, texture) {
    this._currentEffect.setTexture(name63, texture);
  }
  updateUniformDirectly(uniformName, data) {
    this.updateUniform(uniformName, data, data.length);
    this.update();
  }
  bindToEffect(effect, name63) {
    this._currentEffect = effect;
    this._currentEffectName = name63;
  }
  bindUniformBuffer() {
    if (!this._noUBO && this._buffer && this._currentEffect) {
      this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);
    }
  }
  unbindEffect() {
    this._currentEffect = void 0;
    this._currentEffectName = void 0;
  }
  setDataBuffer(dataBuffer) {
    if (!this._buffers) {
      return this._buffer === dataBuffer;
    }
    for (let b = 0; b < this._buffers.length; ++b) {
      const buffer = this._buffers[b];
      if (buffer[0] === dataBuffer) {
        this._bufferIndex = b;
        this._buffer = dataBuffer;
        this._createBufferOnWrite = false;
        this._currentEffect = void 0;
        return true;
      }
    }
    return false;
  }
  dispose() {
    if (this._noUBO) {
      return;
    }
    const uniformBuffers = this._engine._uniformBuffers;
    const index = uniformBuffers.indexOf(this);
    if (index !== -1) {
      uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];
      uniformBuffers.pop();
    }
    if (this._engine._features.trackUbosInFrame && this._buffers) {
      for (let i = 0; i < this._buffers.length; ++i) {
        const buffer = this._buffers[i][0];
        this._engine._releaseBuffer(buffer);
      }
    } else if (this._buffer && this._engine._releaseBuffer(this._buffer)) {
      this._buffer = null;
    }
  }
};
UniformBuffer._UpdatedUbosInFrame = {};
UniformBuffer._MAX_UNIFORM_SIZE = 256;
UniformBuffer._TempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);
UniformBuffer._TempBufferInt32View = new Uint32Array(UniformBuffer._TempBuffer.buffer);

// node_modules/@babylonjs/core/Buffers/buffer.js
var Buffer = class {
  constructor(engine, data, updatable, stride = 0, postponeInternalCreation = false, instanced = false, useBytes = false, divisor) {
    this._isAlreadyOwned = false;
    if (engine.getScene) {
      this._engine = engine.getScene().getEngine();
    } else {
      this._engine = engine;
    }
    this._updatable = updatable;
    this._instanced = instanced;
    this._divisor = divisor || 1;
    if (data instanceof DataBuffer) {
      this._data = null;
      this._buffer = data;
    } else {
      this._data = data;
      this._buffer = null;
    }
    this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;
    if (!postponeInternalCreation) {
      this.create();
    }
  }
  createVertexBuffer(kind, offset, size, stride, instanced, useBytes = false, divisor) {
    const byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;
    const byteStride = stride ? useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT : this.byteStride;
    return new VertexBuffer(this._engine, this, kind, this._updatable, true, byteStride, instanced === void 0 ? this._instanced : instanced, byteOffset, size, void 0, void 0, true, this._divisor || divisor);
  }
  isUpdatable() {
    return this._updatable;
  }
  getData() {
    return this._data;
  }
  getBuffer() {
    return this._buffer;
  }
  getStrideSize() {
    return this.byteStride / Float32Array.BYTES_PER_ELEMENT;
  }
  create(data = null) {
    if (!data && this._buffer) {
      return;
    }
    data = data || this._data;
    if (!data) {
      return;
    }
    if (!this._buffer) {
      if (this._updatable) {
        this._buffer = this._engine.createDynamicVertexBuffer(data);
        this._data = data;
      } else {
        this._buffer = this._engine.createVertexBuffer(data);
      }
    } else if (this._updatable) {
      this._engine.updateDynamicVertexBuffer(this._buffer, data);
      this._data = data;
    }
  }
  _rebuild() {
    this._buffer = null;
    this.create(this._data);
  }
  update(data) {
    this.create(data);
  }
  updateDirectly(data, offset, vertexCount, useBytes = false) {
    if (!this._buffer) {
      return;
    }
    if (this._updatable) {
      this._engine.updateDynamicVertexBuffer(this._buffer, data, useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT, vertexCount ? vertexCount * this.byteStride : void 0);
      if (offset === 0 && vertexCount === void 0) {
        this._data = data;
      } else {
        this._data = null;
      }
    }
  }
  _increaseReferences() {
    if (!this._buffer) {
      return;
    }
    if (!this._isAlreadyOwned) {
      this._isAlreadyOwned = true;
      return;
    }
    this._buffer.references++;
  }
  dispose() {
    if (!this._buffer) {
      return;
    }
    if (this._engine._releaseBuffer(this._buffer)) {
      this._buffer = null;
      this._data = null;
    }
  }
};
var VertexBuffer = class {
  constructor(engine, data, kind, updatable, postponeInternalCreation, stride, instanced, offset, size, type, normalized = false, useBytes = false, divisor = 1, takeBufferOwnership = false) {
    if (data instanceof Buffer) {
      this._buffer = data;
      this._ownsBuffer = takeBufferOwnership;
    } else {
      this._buffer = new Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes);
      this._ownsBuffer = true;
    }
    this.uniqueId = VertexBuffer._Counter++;
    this._kind = kind;
    if (type == void 0) {
      const vertexData = this.getData();
      this.type = VertexBuffer.FLOAT;
      if (vertexData instanceof Int8Array) {
        this.type = VertexBuffer.BYTE;
      } else if (vertexData instanceof Uint8Array) {
        this.type = VertexBuffer.UNSIGNED_BYTE;
      } else if (vertexData instanceof Int16Array) {
        this.type = VertexBuffer.SHORT;
      } else if (vertexData instanceof Uint16Array) {
        this.type = VertexBuffer.UNSIGNED_SHORT;
      } else if (vertexData instanceof Int32Array) {
        this.type = VertexBuffer.INT;
      } else if (vertexData instanceof Uint32Array) {
        this.type = VertexBuffer.UNSIGNED_INT;
      }
    } else {
      this.type = type;
    }
    const typeByteLength = VertexBuffer.GetTypeByteLength(this.type);
    if (useBytes) {
      this._size = size || (stride ? stride / typeByteLength : VertexBuffer.DeduceStride(kind));
      this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;
      this.byteOffset = offset || 0;
    } else {
      this._size = size || stride || VertexBuffer.DeduceStride(kind);
      this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;
      this.byteOffset = (offset || 0) * typeByteLength;
    }
    this.normalized = normalized;
    this._instanced = instanced !== void 0 ? instanced : false;
    this._instanceDivisor = instanced ? divisor : 0;
    this._computeHashCode();
  }
  get instanceDivisor() {
    return this._instanceDivisor;
  }
  set instanceDivisor(value) {
    const isInstanced = value != 0;
    this._instanceDivisor = value;
    if (isInstanced !== this._instanced) {
      this._instanced = isInstanced;
      this._computeHashCode();
    }
  }
  _computeHashCode() {
    this.hashCode = (this.type - 5120 << 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + (this.byteStride << 12);
  }
  _rebuild() {
    if (!this._buffer) {
      return;
    }
    this._buffer._rebuild();
  }
  getKind() {
    return this._kind;
  }
  isUpdatable() {
    return this._buffer.isUpdatable();
  }
  getData() {
    return this._buffer.getData();
  }
  getFloatData(totalVertices, forceCopy) {
    const data = this.getData();
    if (!data) {
      return null;
    }
    const tightlyPackedByteStride = this.getSize() * VertexBuffer.GetTypeByteLength(this.type);
    const count = totalVertices * this.getSize();
    if (this.type !== VertexBuffer.FLOAT || this.byteStride !== tightlyPackedByteStride) {
      const copy = new Float32Array(count);
      this.forEach(count, (value, index) => copy[index] = value);
      return copy;
    }
    if (!(data instanceof Array || data instanceof Float32Array) || this.byteOffset !== 0 || data.length !== count) {
      if (data instanceof Array) {
        const offset = this.byteOffset / 4;
        return data.slice(offset, offset + count);
      } else if (data instanceof ArrayBuffer) {
        return new Float32Array(data, this.byteOffset, count);
      } else {
        let offset = data.byteOffset + this.byteOffset;
        if (forceCopy) {
          const result = new Float32Array(count);
          const source = new Float32Array(data.buffer, offset, count);
          result.set(source);
          return result;
        }
        const remainder = offset % 4;
        if (remainder) {
          offset = Math.max(0, offset - remainder);
        }
        return new Float32Array(data.buffer, offset, count);
      }
    }
    if (forceCopy) {
      return data.slice();
    }
    return data;
  }
  getBuffer() {
    return this._buffer.getBuffer();
  }
  getStrideSize() {
    return this.byteStride / VertexBuffer.GetTypeByteLength(this.type);
  }
  getOffset() {
    return this.byteOffset / VertexBuffer.GetTypeByteLength(this.type);
  }
  getSize(sizeInBytes = false) {
    return sizeInBytes ? this._size * VertexBuffer.GetTypeByteLength(this.type) : this._size;
  }
  getIsInstanced() {
    return this._instanced;
  }
  getInstanceDivisor() {
    return this._instanceDivisor;
  }
  create(data) {
    this._buffer.create(data);
  }
  update(data) {
    this._buffer.update(data);
  }
  updateDirectly(data, offset, useBytes = false) {
    this._buffer.updateDirectly(data, offset, void 0, useBytes);
  }
  dispose() {
    if (this._ownsBuffer) {
      this._buffer.dispose();
    }
  }
  forEach(count, callback) {
    VertexBuffer.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, callback);
  }
  static DeduceStride(kind) {
    switch (kind) {
      case VertexBuffer.UVKind:
      case VertexBuffer.UV2Kind:
      case VertexBuffer.UV3Kind:
      case VertexBuffer.UV4Kind:
      case VertexBuffer.UV5Kind:
      case VertexBuffer.UV6Kind:
        return 2;
      case VertexBuffer.NormalKind:
      case VertexBuffer.PositionKind:
        return 3;
      case VertexBuffer.ColorKind:
      case VertexBuffer.MatricesIndicesKind:
      case VertexBuffer.MatricesIndicesExtraKind:
      case VertexBuffer.MatricesWeightsKind:
      case VertexBuffer.MatricesWeightsExtraKind:
      case VertexBuffer.TangentKind:
        return 4;
      default:
        throw new Error("Invalid kind '" + kind + "'");
    }
  }
  static GetTypeByteLength(type) {
    switch (type) {
      case VertexBuffer.BYTE:
      case VertexBuffer.UNSIGNED_BYTE:
        return 1;
      case VertexBuffer.SHORT:
      case VertexBuffer.UNSIGNED_SHORT:
        return 2;
      case VertexBuffer.INT:
      case VertexBuffer.UNSIGNED_INT:
      case VertexBuffer.FLOAT:
        return 4;
      default:
        throw new Error(`Invalid type '${type}'`);
    }
  }
  static ForEach(data, byteOffset, byteStride, componentCount, componentType, count, normalized, callback) {
    if (data instanceof Array) {
      let offset = byteOffset / 4;
      const stride = byteStride / 4;
      for (let index = 0; index < count; index += componentCount) {
        for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {
          callback(data[offset + componentIndex], index + componentIndex);
        }
        offset += stride;
      }
    } else {
      const dataView = data instanceof ArrayBuffer ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);
      const componentByteLength = VertexBuffer.GetTypeByteLength(componentType);
      for (let index = 0; index < count; index += componentCount) {
        let componentByteOffset = byteOffset;
        for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {
          const value = VertexBuffer._GetFloatValue(dataView, componentType, componentByteOffset, normalized);
          callback(value, index + componentIndex);
          componentByteOffset += componentByteLength;
        }
        byteOffset += byteStride;
      }
    }
  }
  static _GetFloatValue(dataView, type, byteOffset, normalized) {
    switch (type) {
      case VertexBuffer.BYTE: {
        let value = dataView.getInt8(byteOffset);
        if (normalized) {
          value = Math.max(value / 127, -1);
        }
        return value;
      }
      case VertexBuffer.UNSIGNED_BYTE: {
        let value = dataView.getUint8(byteOffset);
        if (normalized) {
          value = value / 255;
        }
        return value;
      }
      case VertexBuffer.SHORT: {
        let value = dataView.getInt16(byteOffset, true);
        if (normalized) {
          value = Math.max(value / 32767, -1);
        }
        return value;
      }
      case VertexBuffer.UNSIGNED_SHORT: {
        let value = dataView.getUint16(byteOffset, true);
        if (normalized) {
          value = value / 65535;
        }
        return value;
      }
      case VertexBuffer.INT: {
        return dataView.getInt32(byteOffset, true);
      }
      case VertexBuffer.UNSIGNED_INT: {
        return dataView.getUint32(byteOffset, true);
      }
      case VertexBuffer.FLOAT: {
        return dataView.getFloat32(byteOffset, true);
      }
      default: {
        throw new Error(`Invalid component type ${type}`);
      }
    }
  }
};
VertexBuffer._Counter = 0;
VertexBuffer.BYTE = 5120;
VertexBuffer.UNSIGNED_BYTE = 5121;
VertexBuffer.SHORT = 5122;
VertexBuffer.UNSIGNED_SHORT = 5123;
VertexBuffer.INT = 5124;
VertexBuffer.UNSIGNED_INT = 5125;
VertexBuffer.FLOAT = 5126;
VertexBuffer.PositionKind = "position";
VertexBuffer.NormalKind = "normal";
VertexBuffer.TangentKind = "tangent";
VertexBuffer.UVKind = "uv";
VertexBuffer.UV2Kind = "uv2";
VertexBuffer.UV3Kind = "uv3";
VertexBuffer.UV4Kind = "uv4";
VertexBuffer.UV5Kind = "uv5";
VertexBuffer.UV6Kind = "uv6";
VertexBuffer.ColorKind = "color";
VertexBuffer.ColorInstanceKind = "instanceColor";
VertexBuffer.MatricesIndicesKind = "matricesIndices";
VertexBuffer.MatricesWeightsKind = "matricesWeights";
VertexBuffer.MatricesIndicesExtraKind = "matricesIndicesExtra";
VertexBuffer.MatricesWeightsExtraKind = "matricesWeightsExtra";

// node_modules/@babylonjs/core/Collisions/pickingInfo.js
var PickingInfo = class {
  constructor() {
    this.hit = false;
    this.distance = 0;
    this.pickedPoint = null;
    this.pickedMesh = null;
    this.bu = 0;
    this.bv = 0;
    this.faceId = -1;
    this.subMeshFaceId = -1;
    this.subMeshId = 0;
    this.pickedSprite = null;
    this.thinInstanceIndex = -1;
    this.ray = null;
    this.originMesh = null;
    this.aimTransform = null;
    this.gripTransform = null;
  }
  getNormal(useWorldCoordinates = false, useVerticesNormals = true) {
    if (!this.pickedMesh || useVerticesNormals && !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      return null;
    }
    const indices = this.pickedMesh.getIndices();
    if (!indices) {
      return null;
    }
    let result;
    if (useVerticesNormals) {
      const normals = this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);
      let normal0 = Vector3.FromArray(normals, indices[this.faceId * 3] * 3);
      let normal1 = Vector3.FromArray(normals, indices[this.faceId * 3 + 1] * 3);
      let normal2 = Vector3.FromArray(normals, indices[this.faceId * 3 + 2] * 3);
      normal0 = normal0.scale(this.bu);
      normal1 = normal1.scale(this.bv);
      normal2 = normal2.scale(1 - this.bu - this.bv);
      result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);
    } else {
      const positions = this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);
      const vertex1 = Vector3.FromArray(positions, indices[this.faceId * 3] * 3);
      const vertex2 = Vector3.FromArray(positions, indices[this.faceId * 3 + 1] * 3);
      const vertex3 = Vector3.FromArray(positions, indices[this.faceId * 3 + 2] * 3);
      const p1p2 = vertex1.subtract(vertex2);
      const p3p2 = vertex3.subtract(vertex2);
      result = Vector3.Cross(p1p2, p3p2);
    }
    const transformNormalToWorld = (pickedMesh, n) => {
      let wm = pickedMesh.getWorldMatrix();
      if (pickedMesh.nonUniformScaling) {
        TmpVectors.Matrix[0].copyFrom(wm);
        wm = TmpVectors.Matrix[0];
        wm.setTranslationFromFloats(0, 0, 0);
        wm.invert();
        wm.transposeToRef(TmpVectors.Matrix[1]);
        wm = TmpVectors.Matrix[1];
      }
      Vector3.TransformNormalToRef(n, wm, n);
    };
    if (useWorldCoordinates) {
      transformNormalToWorld(this.pickedMesh, result);
    }
    if (this.ray) {
      const normalForDirectionChecking = TmpVectors.Vector3[0].copyFrom(result);
      if (!useWorldCoordinates) {
        transformNormalToWorld(this.pickedMesh, normalForDirectionChecking);
      }
      if (Vector3.Dot(normalForDirectionChecking, this.ray.direction) > 0) {
        result.negateInPlace();
      }
    }
    result.normalize();
    return result;
  }
  getTextureCoordinates() {
    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
      return null;
    }
    const indices = this.pickedMesh.getIndices();
    if (!indices) {
      return null;
    }
    const uvs = this.pickedMesh.getVerticesData(VertexBuffer.UVKind);
    if (!uvs) {
      return null;
    }
    let uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);
    let uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);
    let uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);
    uv0 = uv0.scale(this.bu);
    uv1 = uv1.scale(this.bv);
    uv2 = uv2.scale(1 - this.bu - this.bv);
    return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);
  }
};

// node_modules/@babylonjs/core/PostProcesses/postProcessManager.js
var PostProcessManager = class {
  constructor(scene) {
    this._vertexBuffers = {};
    this._scene = scene;
  }
  _prepareBuffers() {
    if (this._vertexBuffers[VertexBuffer.PositionKind]) {
      return;
    }
    const vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._scene.getEngine(), vertices, VertexBuffer.PositionKind, false, false, 2);
    this._buildIndexBuffer();
  }
  _buildIndexBuffer() {
    const indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);
  }
  _rebuild() {
    const vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (!vb) {
      return;
    }
    vb._rebuild();
    this._buildIndexBuffer();
  }
  _prepareFrame(sourceTexture = null, postProcesses = null) {
    const camera = this._scene.activeCamera;
    if (!camera) {
      return false;
    }
    postProcesses = postProcesses || camera._postProcesses.filter((pp) => {
      return pp != null;
    });
    if (!postProcesses || postProcesses.length === 0 || !this._scene.postProcessesEnabled) {
      return false;
    }
    postProcesses[0].activate(camera, sourceTexture, postProcesses !== null && postProcesses !== void 0);
    return true;
  }
  directRender(postProcesses, targetTexture = null, forceFullscreenViewport = false, faceIndex = 0, lodLevel = 0, doNotBindFrambuffer = false) {
    var _a;
    const engine = this._scene.getEngine();
    for (let index = 0; index < postProcesses.length; index++) {
      if (index < postProcesses.length - 1) {
        postProcesses[index + 1].activate(this._scene.activeCamera, targetTexture === null || targetTexture === void 0 ? void 0 : targetTexture.texture);
      } else {
        if (targetTexture) {
          engine.bindFramebuffer(targetTexture, faceIndex, void 0, void 0, forceFullscreenViewport, lodLevel);
        } else if (!doNotBindFrambuffer) {
          engine.restoreDefaultFramebuffer();
        }
        (_a = engine._debugInsertMarker) === null || _a === void 0 ? void 0 : _a.call(engine, `post process ${postProcesses[index].name} output`);
      }
      const pp = postProcesses[index];
      const effect = pp.apply();
      if (effect) {
        pp.onBeforeRenderObservable.notifyObservers(effect);
        this._prepareBuffers();
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
        engine.drawElementsType(0, 0, 6);
        pp.onAfterRenderObservable.notifyObservers(effect);
      }
    }
    engine.setDepthBuffer(true);
    engine.setDepthWrite(true);
  }
  _finalizeFrame(doNotPresent, targetTexture, faceIndex, postProcesses, forceFullscreenViewport = false) {
    var _a;
    const camera = this._scene.activeCamera;
    if (!camera) {
      return;
    }
    postProcesses = postProcesses || camera._postProcesses.filter((pp) => {
      return pp != null;
    });
    if (postProcesses.length === 0 || !this._scene.postProcessesEnabled) {
      return;
    }
    const engine = this._scene.getEngine();
    for (let index = 0, len = postProcesses.length; index < len; index++) {
      const pp = postProcesses[index];
      if (index < len - 1) {
        pp._outputTexture = postProcesses[index + 1].activate(camera, targetTexture === null || targetTexture === void 0 ? void 0 : targetTexture.texture);
      } else {
        if (targetTexture) {
          engine.bindFramebuffer(targetTexture, faceIndex, void 0, void 0, forceFullscreenViewport);
          pp._outputTexture = targetTexture;
        } else {
          engine.restoreDefaultFramebuffer();
          pp._outputTexture = null;
        }
        (_a = engine._debugInsertMarker) === null || _a === void 0 ? void 0 : _a.call(engine, `post process ${postProcesses[index].name} output`);
      }
      if (doNotPresent) {
        break;
      }
      const effect = pp.apply();
      if (effect) {
        pp.onBeforeRenderObservable.notifyObservers(effect);
        this._prepareBuffers();
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
        engine.drawElementsType(0, 0, 6);
        pp.onAfterRenderObservable.notifyObservers(effect);
      }
    }
    engine.setDepthBuffer(true);
    engine.setDepthWrite(true);
    engine.setAlphaMode(0);
  }
  dispose() {
    const buffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (buffer) {
      buffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer) {
      this._scene.getEngine()._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
  }
};

// node_modules/@babylonjs/core/Rendering/renderingGroup.js
var RenderingGroup = class {
  constructor(index, scene, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
    this.index = index;
    this._opaqueSubMeshes = new SmartArray(256);
    this._transparentSubMeshes = new SmartArray(256);
    this._alphaTestSubMeshes = new SmartArray(256);
    this._depthOnlySubMeshes = new SmartArray(256);
    this._particleSystems = new SmartArray(256);
    this._spriteManagers = new SmartArray(256);
    this._empty = true;
    this._edgesRenderers = new SmartArrayNoDuplicate(16);
    this._scene = scene;
    this.opaqueSortCompareFn = opaqueSortCompareFn;
    this.alphaTestSortCompareFn = alphaTestSortCompareFn;
    this.transparentSortCompareFn = transparentSortCompareFn;
  }
  set opaqueSortCompareFn(value) {
    if (value) {
      this._opaqueSortCompareFn = value;
    } else {
      this._opaqueSortCompareFn = RenderingGroup.PainterSortCompare;
    }
    this._renderOpaque = this._renderOpaqueSorted;
  }
  set alphaTestSortCompareFn(value) {
    if (value) {
      this._alphaTestSortCompareFn = value;
    } else {
      this._alphaTestSortCompareFn = RenderingGroup.PainterSortCompare;
    }
    this._renderAlphaTest = this._renderAlphaTestSorted;
  }
  set transparentSortCompareFn(value) {
    if (value) {
      this._transparentSortCompareFn = value;
    } else {
      this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;
    }
    this._renderTransparent = this._renderTransparentSorted;
  }
  render(customRenderFunction, renderSprites, renderParticles, activeMeshes) {
    if (customRenderFunction) {
      customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);
      return;
    }
    const engine = this._scene.getEngine();
    if (this._depthOnlySubMeshes.length !== 0) {
      engine.setColorWrite(false);
      this._renderAlphaTest(this._depthOnlySubMeshes);
      engine.setColorWrite(true);
    }
    if (this._opaqueSubMeshes.length !== 0) {
      this._renderOpaque(this._opaqueSubMeshes);
    }
    if (this._alphaTestSubMeshes.length !== 0) {
      this._renderAlphaTest(this._alphaTestSubMeshes);
    }
    const stencilState = engine.getStencilBuffer();
    engine.setStencilBuffer(false);
    if (renderSprites) {
      this._renderSprites();
    }
    if (renderParticles) {
      this._renderParticles(activeMeshes);
    }
    if (this.onBeforeTransparentRendering) {
      this.onBeforeTransparentRendering();
    }
    if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {
      engine.setStencilBuffer(stencilState);
      if (this._scene.useOrderIndependentTransparency) {
        const excludedMeshes = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);
        if (excludedMeshes.length) {
          this._renderTransparent(excludedMeshes);
        }
      } else {
        this._renderTransparent(this._transparentSubMeshes);
      }
      engine.setAlphaMode(0);
    }
    engine.setStencilBuffer(false);
    if (this._edgesRenderers.length) {
      for (let edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {
        this._edgesRenderers.data[edgesRendererIndex].render();
      }
      engine.setAlphaMode(0);
    }
    engine.setStencilBuffer(stencilState);
  }
  _renderOpaqueSorted(subMeshes) {
    return RenderingGroup._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);
  }
  _renderAlphaTestSorted(subMeshes) {
    return RenderingGroup._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);
  }
  _renderTransparentSorted(subMeshes) {
    return RenderingGroup._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);
  }
  static _RenderSorted(subMeshes, sortCompareFn, camera, transparent) {
    let subIndex = 0;
    let subMesh;
    const cameraPosition = camera ? camera.globalPosition : RenderingGroup._ZeroVector;
    if (transparent) {
      for (; subIndex < subMeshes.length; subIndex++) {
        subMesh = subMeshes.data[subIndex];
        subMesh._alphaIndex = subMesh.getMesh().alphaIndex;
        subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);
      }
    }
    const sortedArray = subMeshes.length === subMeshes.data.length ? subMeshes.data : subMeshes.data.slice(0, subMeshes.length);
    if (sortCompareFn) {
      sortedArray.sort(sortCompareFn);
    }
    const scene = sortedArray[0].getMesh().getScene();
    for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {
      subMesh = sortedArray[subIndex];
      if (scene._activeMeshesFrozenButKeepClipping && !subMesh.isInFrustum(scene._frustumPlanes)) {
        continue;
      }
      if (transparent) {
        const material = subMesh.getMaterial();
        if (material && material.needDepthPrePass) {
          const engine = material.getScene().getEngine();
          engine.setColorWrite(false);
          engine.setAlphaMode(0);
          subMesh.render(false);
          engine.setColorWrite(true);
        }
      }
      subMesh.render(transparent);
    }
  }
  static defaultTransparentSortCompare(a, b) {
    if (a._alphaIndex > b._alphaIndex) {
      return 1;
    }
    if (a._alphaIndex < b._alphaIndex) {
      return -1;
    }
    return RenderingGroup.backToFrontSortCompare(a, b);
  }
  static backToFrontSortCompare(a, b) {
    if (a._distanceToCamera < b._distanceToCamera) {
      return 1;
    }
    if (a._distanceToCamera > b._distanceToCamera) {
      return -1;
    }
    return 0;
  }
  static frontToBackSortCompare(a, b) {
    if (a._distanceToCamera < b._distanceToCamera) {
      return -1;
    }
    if (a._distanceToCamera > b._distanceToCamera) {
      return 1;
    }
    return 0;
  }
  static PainterSortCompare(a, b) {
    const meshA = a.getMesh();
    const meshB = b.getMesh();
    if (meshA.material && meshB.material) {
      return meshA.material.uniqueId - meshB.material.uniqueId;
    }
    return meshA.uniqueId - meshB.uniqueId;
  }
  prepare() {
    this._opaqueSubMeshes.reset();
    this._transparentSubMeshes.reset();
    this._alphaTestSubMeshes.reset();
    this._depthOnlySubMeshes.reset();
    this._particleSystems.reset();
    this.prepareSprites();
    this._edgesRenderers.reset();
    this._empty = true;
  }
  prepareSprites() {
    this._spriteManagers.reset();
  }
  dispose() {
    this._opaqueSubMeshes.dispose();
    this._transparentSubMeshes.dispose();
    this._alphaTestSubMeshes.dispose();
    this._depthOnlySubMeshes.dispose();
    this._particleSystems.dispose();
    this._spriteManagers.dispose();
    this._edgesRenderers.dispose();
  }
  dispatch(subMesh, mesh, material) {
    if (mesh === void 0) {
      mesh = subMesh.getMesh();
    }
    if (material === void 0) {
      material = subMesh.getMaterial();
    }
    if (material === null || material === void 0) {
      return;
    }
    if (material.needAlphaBlendingForMesh(mesh)) {
      this._transparentSubMeshes.push(subMesh);
    } else if (material.needAlphaTesting()) {
      if (material.needDepthPrePass) {
        this._depthOnlySubMeshes.push(subMesh);
      }
      this._alphaTestSubMeshes.push(subMesh);
    } else {
      if (material.needDepthPrePass) {
        this._depthOnlySubMeshes.push(subMesh);
      }
      this._opaqueSubMeshes.push(subMesh);
    }
    mesh._renderingGroup = this;
    if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {
      this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);
    }
    this._empty = false;
  }
  dispatchSprites(spriteManager) {
    this._spriteManagers.push(spriteManager);
    this._empty = false;
  }
  dispatchParticles(particleSystem) {
    this._particleSystems.push(particleSystem);
    this._empty = false;
  }
  _renderParticles(activeMeshes) {
    if (this._particleSystems.length === 0) {
      return;
    }
    const activeCamera = this._scene.activeCamera;
    this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);
    for (let particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {
      const particleSystem = this._particleSystems.data[particleIndex];
      if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {
        continue;
      }
      const emitter = particleSystem.emitter;
      if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {
        this._scene._activeParticles.addCount(particleSystem.render(), false);
      }
    }
    this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);
  }
  _renderSprites() {
    if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {
      return;
    }
    const activeCamera = this._scene.activeCamera;
    this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);
    for (let id = 0; id < this._spriteManagers.length; id++) {
      const spriteManager = this._spriteManagers.data[id];
      if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {
        spriteManager.render();
      }
    }
    this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);
  }
};
RenderingGroup._ZeroVector = Vector3.Zero();

// node_modules/@babylonjs/core/Rendering/renderingManager.js
var RenderingGroupInfo = class {
};
var RenderingManager = class {
  constructor(scene) {
    this._useSceneAutoClearSetup = false;
    this._renderingGroups = new Array();
    this._autoClearDepthStencil = {};
    this._customOpaqueSortCompareFn = {};
    this._customAlphaTestSortCompareFn = {};
    this._customTransparentSortCompareFn = {};
    this._renderingGroupInfo = new RenderingGroupInfo();
    this._maintainStateBetweenFrames = false;
    this._scene = scene;
    for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {
      this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };
    }
  }
  get maintainStateBetweenFrames() {
    return this._maintainStateBetweenFrames;
  }
  set maintainStateBetweenFrames(value) {
    if (value === this._maintainStateBetweenFrames) {
      return;
    }
    this._maintainStateBetweenFrames = value;
    if (!this._maintainStateBetweenFrames) {
      for (const mesh of this._scene.meshes) {
        if (mesh.subMeshes) {
          for (const subMesh of mesh.subMeshes) {
            subMesh._wasDispatched = false;
          }
        }
      }
      for (const spriteManager of this._scene.spriteManagers) {
        spriteManager._wasDispatched = false;
      }
      for (const particleSystem of this._scene.particleSystems) {
        particleSystem._wasDispatched = false;
      }
    }
  }
  getRenderingGroup(id) {
    const renderingGroupId = id || 0;
    this._prepareRenderingGroup(renderingGroupId);
    return this._renderingGroups[renderingGroupId];
  }
  _clearDepthStencilBuffer(depth = true, stencil = true) {
    if (this._depthStencilBufferAlreadyCleaned) {
      return;
    }
    this._scene.getEngine().clear(null, false, depth, stencil);
    this._depthStencilBufferAlreadyCleaned = true;
  }
  render(customRenderFunction, activeMeshes, renderParticles, renderSprites) {
    const info = this._renderingGroupInfo;
    info.scene = this._scene;
    info.camera = this._scene.activeCamera;
    if (this._scene.spriteManagers && renderSprites) {
      for (let index = 0; index < this._scene.spriteManagers.length; index++) {
        const manager = this._scene.spriteManagers[index];
        this.dispatchSprites(manager);
      }
    }
    for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {
      this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;
      const renderingGroup = this._renderingGroups[index];
      if (!renderingGroup || renderingGroup._empty) {
        continue;
      }
      const renderingGroupMask = Math.pow(2, index);
      info.renderingGroupId = index;
      this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);
      if (RenderingManager.AUTOCLEAR) {
        const autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];
        if (autoClear && autoClear.autoClear) {
          this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);
        }
      }
      for (const step of this._scene._beforeRenderingGroupDrawStage) {
        step.action(index);
      }
      renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);
      for (const step of this._scene._afterRenderingGroupDrawStage) {
        step.action(index);
      }
      this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);
    }
  }
  reset() {
    if (this.maintainStateBetweenFrames) {
      return;
    }
    for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {
      const renderingGroup = this._renderingGroups[index];
      if (renderingGroup) {
        renderingGroup.prepare();
      }
    }
  }
  resetSprites() {
    if (this.maintainStateBetweenFrames) {
      return;
    }
    for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {
      const renderingGroup = this._renderingGroups[index];
      if (renderingGroup) {
        renderingGroup.prepareSprites();
      }
    }
  }
  dispose() {
    this.freeRenderingGroups();
    this._renderingGroups.length = 0;
    this._renderingGroupInfo = null;
  }
  freeRenderingGroups() {
    for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {
      const renderingGroup = this._renderingGroups[index];
      if (renderingGroup) {
        renderingGroup.dispose();
      }
    }
  }
  _prepareRenderingGroup(renderingGroupId) {
    if (this._renderingGroups[renderingGroupId] === void 0) {
      this._renderingGroups[renderingGroupId] = new RenderingGroup(renderingGroupId, this._scene, this._customOpaqueSortCompareFn[renderingGroupId], this._customAlphaTestSortCompareFn[renderingGroupId], this._customTransparentSortCompareFn[renderingGroupId]);
    }
  }
  dispatchSprites(spriteManager) {
    if (this.maintainStateBetweenFrames && spriteManager._wasDispatched) {
      return;
    }
    spriteManager._wasDispatched = true;
    this.getRenderingGroup(spriteManager.renderingGroupId).dispatchSprites(spriteManager);
  }
  dispatchParticles(particleSystem) {
    if (this.maintainStateBetweenFrames && particleSystem._wasDispatched) {
      return;
    }
    particleSystem._wasDispatched = true;
    this.getRenderingGroup(particleSystem.renderingGroupId).dispatchParticles(particleSystem);
  }
  dispatch(subMesh, mesh, material) {
    if (mesh === void 0) {
      mesh = subMesh.getMesh();
    }
    if (this.maintainStateBetweenFrames && subMesh._wasDispatched) {
      return;
    }
    subMesh._wasDispatched = true;
    this.getRenderingGroup(mesh.renderingGroupId).dispatch(subMesh, mesh, material);
  }
  setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
    this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;
    this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;
    this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;
    if (this._renderingGroups[renderingGroupId]) {
      const group = this._renderingGroups[renderingGroupId];
      group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];
      group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];
      group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];
    }
  }
  setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth = true, stencil = true) {
    this._autoClearDepthStencil[renderingGroupId] = {
      autoClear: autoClearDepthStencil,
      depth,
      stencil
    };
  }
  getAutoClearDepthStencilSetup(index) {
    return this._autoClearDepthStencil[index];
  }
};
RenderingManager.MAX_RENDERINGGROUPS = 4;
RenderingManager.MIN_RENDERINGGROUPS = 0;
RenderingManager.AUTOCLEAR = true;

// node_modules/@babylonjs/core/sceneComponent.js
var SceneComponentConstants = class {
};
SceneComponentConstants.NAME_EFFECTLAYER = "EffectLayer";
SceneComponentConstants.NAME_LAYER = "Layer";
SceneComponentConstants.NAME_LENSFLARESYSTEM = "LensFlareSystem";
SceneComponentConstants.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer";
SceneComponentConstants.NAME_PARTICLESYSTEM = "ParticleSystem";
SceneComponentConstants.NAME_GAMEPAD = "Gamepad";
SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue";
SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer";
SceneComponentConstants.NAME_PREPASSRENDERER = "PrePassRenderer";
SceneComponentConstants.NAME_DEPTHRENDERER = "DepthRenderer";
SceneComponentConstants.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer";
SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager";
SceneComponentConstants.NAME_SPRITE = "Sprite";
SceneComponentConstants.NAME_SUBSURFACE = "SubSurface";
SceneComponentConstants.NAME_OUTLINERENDERER = "Outline";
SceneComponentConstants.NAME_PROCEDURALTEXTURE = "ProceduralTexture";
SceneComponentConstants.NAME_SHADOWGENERATOR = "ShadowGenerator";
SceneComponentConstants.NAME_OCTREE = "Octree";
SceneComponentConstants.NAME_PHYSICSENGINE = "PhysicsEngine";
SceneComponentConstants.NAME_AUDIO = "Audio";
SceneComponentConstants.NAME_FLUIDRENDERER = "FluidRenderer";
SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER = 0;
SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1;
SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS = 0;
SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1;
SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER = 2;
SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0;
SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER = 1;
SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS = 0;
SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE = 1;
SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE = 1;
SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0;
SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1;
SceneComponentConstants.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0;
SceneComponentConstants.STEP_BEFORECAMERAUPDATE_GAMEPAD = 1;
SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0;
SceneComponentConstants.STEP_BEFORECLEAR_PREPASS = 1;
SceneComponentConstants.STEP_BEFORERENDERTARGETCLEAR_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER = 1;
SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS = 0;
SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1;
SceneComponentConstants.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2;
SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3;
SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER = 4;
SceneComponentConstants.STEP_AFTERCAMERADRAW_FLUIDRENDERER = 5;
SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER = 0;
SceneComponentConstants.STEP_AFTERRENDER_AUDIO = 0;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER = 1;
SceneComponentConstants.STEP_POINTERMOVE_SPRITE = 0;
SceneComponentConstants.STEP_POINTERDOWN_SPRITE = 0;
SceneComponentConstants.STEP_POINTERUP_SPRITE = 0;
var Stage = class extends Array {
  constructor(items) {
    super(...items);
  }
  static Create() {
    return Object.create(Stage.prototype);
  }
  registerStep(index, component, action) {
    let i = 0;
    let maxIndex = Number.MAX_VALUE;
    for (; i < this.length; i++) {
      const step = this[i];
      maxIndex = step.index;
      if (index < maxIndex) {
        break;
      }
    }
    this.splice(i, 0, { index, component, action: action.bind(component) });
  }
  clear() {
    this.length = 0;
  }
};

// node_modules/@babylonjs/core/Events/pointerEvents.js
var PointerEventTypes = class {
};
PointerEventTypes.POINTERDOWN = 1;
PointerEventTypes.POINTERUP = 2;
PointerEventTypes.POINTERMOVE = 4;
PointerEventTypes.POINTERWHEEL = 8;
PointerEventTypes.POINTERPICK = 16;
PointerEventTypes.POINTERTAP = 32;
PointerEventTypes.POINTERDOUBLETAP = 64;
var PointerInfoBase = class {
  constructor(type, event) {
    this.type = type;
    this.event = event;
  }
};
var PointerInfoPre = class extends PointerInfoBase {
  constructor(type, event, localX, localY) {
    super(type, event);
    this.ray = null;
    this.originalPickingInfo = null;
    this.skipOnPointerObservable = false;
    this.localPosition = new Vector2(localX, localY);
  }
};
var PointerInfo = class extends PointerInfoBase {
  constructor(type, event, pickInfo, inputManager = null) {
    super(type, event);
    this._pickInfo = pickInfo;
    this._inputManager = inputManager;
  }
  get pickInfo() {
    if (!this._pickInfo) {
      this._generatePickInfo();
    }
    return this._pickInfo;
  }
  _generatePickInfo() {
    if (this._inputManager) {
      this._pickInfo = this._inputManager._pickMove(this.event.pointerId);
      this._inputManager._setRayOnPointerInfo(this._pickInfo, this.event);
      this._inputManager = null;
    }
  }
};

// node_modules/@babylonjs/core/Events/keyboardEvents.js
var KeyboardEventTypes = class {
};
KeyboardEventTypes.KEYDOWN = 1;
KeyboardEventTypes.KEYUP = 2;
var KeyboardInfo = class {
  constructor(type, event) {
    this.type = type;
    this.event = event;
  }
};
var KeyboardInfoPre = class extends KeyboardInfo {
  constructor(type, event) {
    super(type, event);
    this.type = type;
    this.event = event;
    this.skipOnKeyboardObservable = false;
  }
  get skipOnPointerObservable() {
    return this.skipOnKeyboardObservable;
  }
  set skipOnPointerObservable(value) {
    this.skipOnKeyboardObservable = value;
  }
};

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceEnums.js
var DeviceType;
(function(DeviceType2) {
  DeviceType2[DeviceType2["Generic"] = 0] = "Generic";
  DeviceType2[DeviceType2["Keyboard"] = 1] = "Keyboard";
  DeviceType2[DeviceType2["Mouse"] = 2] = "Mouse";
  DeviceType2[DeviceType2["Touch"] = 3] = "Touch";
  DeviceType2[DeviceType2["DualShock"] = 4] = "DualShock";
  DeviceType2[DeviceType2["Xbox"] = 5] = "Xbox";
  DeviceType2[DeviceType2["Switch"] = 6] = "Switch";
  DeviceType2[DeviceType2["DualSense"] = 7] = "DualSense";
})(DeviceType || (DeviceType = {}));
var PointerInput;
(function(PointerInput2) {
  PointerInput2[PointerInput2["Horizontal"] = 0] = "Horizontal";
  PointerInput2[PointerInput2["Vertical"] = 1] = "Vertical";
  PointerInput2[PointerInput2["LeftClick"] = 2] = "LeftClick";
  PointerInput2[PointerInput2["MiddleClick"] = 3] = "MiddleClick";
  PointerInput2[PointerInput2["RightClick"] = 4] = "RightClick";
  PointerInput2[PointerInput2["BrowserBack"] = 5] = "BrowserBack";
  PointerInput2[PointerInput2["BrowserForward"] = 6] = "BrowserForward";
  PointerInput2[PointerInput2["MouseWheelX"] = 7] = "MouseWheelX";
  PointerInput2[PointerInput2["MouseWheelY"] = 8] = "MouseWheelY";
  PointerInput2[PointerInput2["MouseWheelZ"] = 9] = "MouseWheelZ";
  PointerInput2[PointerInput2["Move"] = 12] = "Move";
})(PointerInput || (PointerInput = {}));
var NativePointerInput;
(function(NativePointerInput2) {
  NativePointerInput2[NativePointerInput2["Horizontal"] = 0] = "Horizontal";
  NativePointerInput2[NativePointerInput2["Vertical"] = 1] = "Vertical";
  NativePointerInput2[NativePointerInput2["LeftClick"] = 2] = "LeftClick";
  NativePointerInput2[NativePointerInput2["MiddleClick"] = 3] = "MiddleClick";
  NativePointerInput2[NativePointerInput2["RightClick"] = 4] = "RightClick";
  NativePointerInput2[NativePointerInput2["BrowserBack"] = 5] = "BrowserBack";
  NativePointerInput2[NativePointerInput2["BrowserForward"] = 6] = "BrowserForward";
  NativePointerInput2[NativePointerInput2["MouseWheelX"] = 7] = "MouseWheelX";
  NativePointerInput2[NativePointerInput2["MouseWheelY"] = 8] = "MouseWheelY";
  NativePointerInput2[NativePointerInput2["MouseWheelZ"] = 9] = "MouseWheelZ";
  NativePointerInput2[NativePointerInput2["DeltaHorizontal"] = 10] = "DeltaHorizontal";
  NativePointerInput2[NativePointerInput2["DeltaVertical"] = 11] = "DeltaVertical";
})(NativePointerInput || (NativePointerInput = {}));
var DualShockInput;
(function(DualShockInput2) {
  DualShockInput2[DualShockInput2["Cross"] = 0] = "Cross";
  DualShockInput2[DualShockInput2["Circle"] = 1] = "Circle";
  DualShockInput2[DualShockInput2["Square"] = 2] = "Square";
  DualShockInput2[DualShockInput2["Triangle"] = 3] = "Triangle";
  DualShockInput2[DualShockInput2["L1"] = 4] = "L1";
  DualShockInput2[DualShockInput2["R1"] = 5] = "R1";
  DualShockInput2[DualShockInput2["L2"] = 6] = "L2";
  DualShockInput2[DualShockInput2["R2"] = 7] = "R2";
  DualShockInput2[DualShockInput2["Share"] = 8] = "Share";
  DualShockInput2[DualShockInput2["Options"] = 9] = "Options";
  DualShockInput2[DualShockInput2["L3"] = 10] = "L3";
  DualShockInput2[DualShockInput2["R3"] = 11] = "R3";
  DualShockInput2[DualShockInput2["DPadUp"] = 12] = "DPadUp";
  DualShockInput2[DualShockInput2["DPadDown"] = 13] = "DPadDown";
  DualShockInput2[DualShockInput2["DPadLeft"] = 14] = "DPadLeft";
  DualShockInput2[DualShockInput2["DPadRight"] = 15] = "DPadRight";
  DualShockInput2[DualShockInput2["Home"] = 16] = "Home";
  DualShockInput2[DualShockInput2["TouchPad"] = 17] = "TouchPad";
  DualShockInput2[DualShockInput2["LStickXAxis"] = 18] = "LStickXAxis";
  DualShockInput2[DualShockInput2["LStickYAxis"] = 19] = "LStickYAxis";
  DualShockInput2[DualShockInput2["RStickXAxis"] = 20] = "RStickXAxis";
  DualShockInput2[DualShockInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(DualShockInput || (DualShockInput = {}));
var DualSenseInput;
(function(DualSenseInput2) {
  DualSenseInput2[DualSenseInput2["Cross"] = 0] = "Cross";
  DualSenseInput2[DualSenseInput2["Circle"] = 1] = "Circle";
  DualSenseInput2[DualSenseInput2["Square"] = 2] = "Square";
  DualSenseInput2[DualSenseInput2["Triangle"] = 3] = "Triangle";
  DualSenseInput2[DualSenseInput2["L1"] = 4] = "L1";
  DualSenseInput2[DualSenseInput2["R1"] = 5] = "R1";
  DualSenseInput2[DualSenseInput2["L2"] = 6] = "L2";
  DualSenseInput2[DualSenseInput2["R2"] = 7] = "R2";
  DualSenseInput2[DualSenseInput2["Create"] = 8] = "Create";
  DualSenseInput2[DualSenseInput2["Options"] = 9] = "Options";
  DualSenseInput2[DualSenseInput2["L3"] = 10] = "L3";
  DualSenseInput2[DualSenseInput2["R3"] = 11] = "R3";
  DualSenseInput2[DualSenseInput2["DPadUp"] = 12] = "DPadUp";
  DualSenseInput2[DualSenseInput2["DPadDown"] = 13] = "DPadDown";
  DualSenseInput2[DualSenseInput2["DPadLeft"] = 14] = "DPadLeft";
  DualSenseInput2[DualSenseInput2["DPadRight"] = 15] = "DPadRight";
  DualSenseInput2[DualSenseInput2["Home"] = 16] = "Home";
  DualSenseInput2[DualSenseInput2["TouchPad"] = 17] = "TouchPad";
  DualSenseInput2[DualSenseInput2["LStickXAxis"] = 18] = "LStickXAxis";
  DualSenseInput2[DualSenseInput2["LStickYAxis"] = 19] = "LStickYAxis";
  DualSenseInput2[DualSenseInput2["RStickXAxis"] = 20] = "RStickXAxis";
  DualSenseInput2[DualSenseInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(DualSenseInput || (DualSenseInput = {}));
var XboxInput;
(function(XboxInput2) {
  XboxInput2[XboxInput2["A"] = 0] = "A";
  XboxInput2[XboxInput2["B"] = 1] = "B";
  XboxInput2[XboxInput2["X"] = 2] = "X";
  XboxInput2[XboxInput2["Y"] = 3] = "Y";
  XboxInput2[XboxInput2["LB"] = 4] = "LB";
  XboxInput2[XboxInput2["RB"] = 5] = "RB";
  XboxInput2[XboxInput2["LT"] = 6] = "LT";
  XboxInput2[XboxInput2["RT"] = 7] = "RT";
  XboxInput2[XboxInput2["Back"] = 8] = "Back";
  XboxInput2[XboxInput2["Start"] = 9] = "Start";
  XboxInput2[XboxInput2["LS"] = 10] = "LS";
  XboxInput2[XboxInput2["RS"] = 11] = "RS";
  XboxInput2[XboxInput2["DPadUp"] = 12] = "DPadUp";
  XboxInput2[XboxInput2["DPadDown"] = 13] = "DPadDown";
  XboxInput2[XboxInput2["DPadLeft"] = 14] = "DPadLeft";
  XboxInput2[XboxInput2["DPadRight"] = 15] = "DPadRight";
  XboxInput2[XboxInput2["Home"] = 16] = "Home";
  XboxInput2[XboxInput2["LStickXAxis"] = 17] = "LStickXAxis";
  XboxInput2[XboxInput2["LStickYAxis"] = 18] = "LStickYAxis";
  XboxInput2[XboxInput2["RStickXAxis"] = 19] = "RStickXAxis";
  XboxInput2[XboxInput2["RStickYAxis"] = 20] = "RStickYAxis";
})(XboxInput || (XboxInput = {}));
var SwitchInput;
(function(SwitchInput2) {
  SwitchInput2[SwitchInput2["B"] = 0] = "B";
  SwitchInput2[SwitchInput2["A"] = 1] = "A";
  SwitchInput2[SwitchInput2["Y"] = 2] = "Y";
  SwitchInput2[SwitchInput2["X"] = 3] = "X";
  SwitchInput2[SwitchInput2["L"] = 4] = "L";
  SwitchInput2[SwitchInput2["R"] = 5] = "R";
  SwitchInput2[SwitchInput2["ZL"] = 6] = "ZL";
  SwitchInput2[SwitchInput2["ZR"] = 7] = "ZR";
  SwitchInput2[SwitchInput2["Minus"] = 8] = "Minus";
  SwitchInput2[SwitchInput2["Plus"] = 9] = "Plus";
  SwitchInput2[SwitchInput2["LS"] = 10] = "LS";
  SwitchInput2[SwitchInput2["RS"] = 11] = "RS";
  SwitchInput2[SwitchInput2["DPadUp"] = 12] = "DPadUp";
  SwitchInput2[SwitchInput2["DPadDown"] = 13] = "DPadDown";
  SwitchInput2[SwitchInput2["DPadLeft"] = 14] = "DPadLeft";
  SwitchInput2[SwitchInput2["DPadRight"] = 15] = "DPadRight";
  SwitchInput2[SwitchInput2["Home"] = 16] = "Home";
  SwitchInput2[SwitchInput2["Capture"] = 17] = "Capture";
  SwitchInput2[SwitchInput2["LStickXAxis"] = 18] = "LStickXAxis";
  SwitchInput2[SwitchInput2["LStickYAxis"] = 19] = "LStickYAxis";
  SwitchInput2[SwitchInput2["RStickXAxis"] = 20] = "RStickXAxis";
  SwitchInput2[SwitchInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(SwitchInput || (SwitchInput = {}));

// node_modules/@babylonjs/core/Events/deviceInputEvents.js
var DeviceInputEventType;
(function(DeviceInputEventType2) {
  DeviceInputEventType2[DeviceInputEventType2["PointerMove"] = 0] = "PointerMove";
  DeviceInputEventType2[DeviceInputEventType2["PointerDown"] = 1] = "PointerDown";
  DeviceInputEventType2[DeviceInputEventType2["PointerUp"] = 2] = "PointerUp";
})(DeviceInputEventType || (DeviceInputEventType = {}));
var EventConstants = class {
};
EventConstants.DOM_DELTA_PIXEL = 0;
EventConstants.DOM_DELTA_LINE = 1;
EventConstants.DOM_DELTA_PAGE = 2;

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceSource.js
var DeviceSource = class {
  constructor(deviceInputSystem, deviceType, deviceSlot = 0) {
    this.deviceType = deviceType;
    this.deviceSlot = deviceSlot;
    this.onInputChangedObservable = new Observable();
    this._deviceInputSystem = deviceInputSystem;
  }
  getInput(inputIndex) {
    return this._deviceInputSystem.pollInput(this.deviceType, this.deviceSlot, inputIndex);
  }
};

// node_modules/@babylonjs/core/DeviceInput/eventFactory.js
var DeviceEventFactory = class {
  static CreateDeviceEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    switch (deviceType) {
      case DeviceType.Keyboard:
        return this._CreateKeyboardEvent(inputIndex, currentState, deviceInputSystem, elementToAttachTo);
      case DeviceType.Mouse:
        if (inputIndex === PointerInput.MouseWheelX || inputIndex === PointerInput.MouseWheelY || inputIndex === PointerInput.MouseWheelZ) {
          return this._CreateWheelEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
        }
      case DeviceType.Touch:
        return this._CreatePointerEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
      default:
        throw `Unable to generate event for device ${DeviceType[deviceType]}`;
    }
  }
  static _CreatePointerEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    const evt = this._CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
    if (deviceType === DeviceType.Mouse) {
      evt.deviceType = DeviceType.Mouse;
      evt.pointerId = 1;
      evt.pointerType = "mouse";
    } else {
      evt.deviceType = DeviceType.Touch;
      evt.pointerId = deviceSlot;
      evt.pointerType = "touch";
    }
    if (inputIndex === PointerInput.Move) {
      evt.type = "pointermove";
    } else if (inputIndex >= PointerInput.LeftClick && inputIndex <= PointerInput.RightClick) {
      evt.type = currentState === 1 ? "pointerdown" : "pointerup";
      evt.button = inputIndex - 2;
    }
    return evt;
  }
  static _CreateWheelEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    const evt = this._CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
    evt.type = "wheel";
    evt.deltaMode = EventConstants.DOM_DELTA_PIXEL;
    evt.deltaX = 0;
    evt.deltaY = 0;
    evt.deltaZ = 0;
    switch (inputIndex) {
      case PointerInput.MouseWheelX:
        evt.deltaX = currentState;
        break;
      case PointerInput.MouseWheelY:
        evt.deltaY = currentState;
        break;
      case PointerInput.MouseWheelZ:
        evt.deltaZ = currentState;
        break;
    }
    return evt;
  }
  static _CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    const evt = this._CreateEvent(elementToAttachTo);
    const pointerX = deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.Horizontal);
    const pointerY = deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.Vertical);
    if (elementToAttachTo) {
      evt.movementX = 0;
      evt.movementY = 0;
      evt.offsetX = evt.movementX - elementToAttachTo.getBoundingClientRect().x;
      evt.offsetY = evt.movementY - elementToAttachTo.getBoundingClientRect().y;
    } else {
      evt.movementX = deviceInputSystem.pollInput(deviceType, deviceSlot, NativePointerInput.DeltaHorizontal);
      evt.movementY = deviceInputSystem.pollInput(deviceType, deviceSlot, NativePointerInput.DeltaVertical);
      evt.offsetX = 0;
      evt.offsetY = 0;
    }
    this._CheckNonCharacterKeys(evt, deviceInputSystem);
    evt.clientX = pointerX;
    evt.clientY = pointerY;
    evt.x = pointerX;
    evt.y = pointerY;
    evt.deviceType = deviceType;
    evt.deviceSlot = deviceSlot;
    evt.inputIndex = inputIndex;
    return evt;
  }
  static _CreateKeyboardEvent(inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    const evt = this._CreateEvent(elementToAttachTo);
    this._CheckNonCharacterKeys(evt, deviceInputSystem);
    evt.deviceType = DeviceType.Keyboard;
    evt.deviceSlot = 0;
    evt.inputIndex = inputIndex;
    evt.type = currentState === 1 ? "keydown" : "keyup";
    evt.key = String.fromCharCode(inputIndex);
    evt.keyCode = inputIndex;
    return evt;
  }
  static _CheckNonCharacterKeys(evt, deviceInputSystem) {
    const isKeyboardActive = deviceInputSystem.isDeviceAvailable(DeviceType.Keyboard);
    const altKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 18) === 1;
    const ctrlKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 17) === 1;
    const metaKey = isKeyboardActive && (deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 91) === 1 || deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 92) === 1 || deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 93) === 1);
    const shiftKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 16) === 1;
    evt.altKey = altKey;
    evt.ctrlKey = ctrlKey;
    evt.metaKey = metaKey;
    evt.shiftKey = shiftKey;
  }
  static _CreateEvent(elementToAttachTo) {
    const evt = {};
    evt.preventDefault = () => {
    };
    evt.target = elementToAttachTo;
    return evt;
  }
};

// node_modules/@babylonjs/core/DeviceInput/nativeDeviceInputSystem.js
var NativeDeviceInputSystem = class {
  constructor(onDeviceConnected, onDeviceDisconnected, onInputChanged) {
    this._nativeInput = _native.DeviceInputSystem ? new _native.DeviceInputSystem(onDeviceConnected, onDeviceDisconnected, (deviceType, deviceSlot, inputIndex, currentState) => {
      const evt = DeviceEventFactory.CreateDeviceEvent(deviceType, deviceSlot, inputIndex, currentState, this);
      onInputChanged(deviceType, deviceSlot, evt);
    }) : this._createDummyNativeInput();
  }
  pollInput(deviceType, deviceSlot, inputIndex) {
    return this._nativeInput.pollInput(deviceType, deviceSlot, inputIndex);
  }
  isDeviceAvailable(deviceType) {
    return deviceType === DeviceType.Mouse || deviceType === DeviceType.Touch;
  }
  dispose() {
    this._nativeInput.dispose();
  }
  _createDummyNativeInput() {
    const nativeInput = {
      pollInput: () => {
        return 0;
      },
      isDeviceAvailable: () => {
        return false;
      },
      dispose: () => {
      }
    };
    return nativeInput;
  }
};

// node_modules/@babylonjs/core/DeviceInput/webDeviceInputSystem.js
var MAX_KEYCODES = 255;
var MAX_POINTER_INPUTS = Object.keys(PointerInput).length / 2;
var WebDeviceInputSystem = class {
  constructor(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged) {
    this._inputs = [];
    this._keyboardActive = false;
    this._pointerActive = false;
    this._usingSafari = Tools.IsSafari();
    this._usingMacOS = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
    this._keyboardDownEvent = (evt) => {
    };
    this._keyboardUpEvent = (evt) => {
    };
    this._keyboardBlurEvent = (evt) => {
    };
    this._pointerMoveEvent = (evt) => {
    };
    this._pointerDownEvent = (evt) => {
    };
    this._pointerUpEvent = (evt) => {
    };
    this._pointerCancelEvent = (evt) => {
    };
    this._pointerWheelEvent = (evt) => {
    };
    this._pointerBlurEvent = (evt) => {
    };
    this._eventsAttached = false;
    this._mouseId = -1;
    this._isUsingFirefox = DomManagement.IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf("Firefox") !== -1;
    this._maxTouchPoints = 0;
    this._pointerInputClearObserver = null;
    this._gamepadConnectedEvent = (evt) => {
    };
    this._gamepadDisconnectedEvent = (evt) => {
    };
    this._eventPrefix = Tools.GetPointerPrefix(engine);
    this._engine = engine;
    this._onDeviceConnected = onDeviceConnected;
    this._onDeviceDisconnected = onDeviceDisconnected;
    this._onInputChanged = onInputChanged;
    this._enableEvents();
    if (this._usingMacOS) {
      this._metaKeys = [];
    }
    if (!this._engine._onEngineViewChanged) {
      this._engine._onEngineViewChanged = () => {
        this._enableEvents();
      };
    }
  }
  pollInput(deviceType, deviceSlot, inputIndex) {
    const device = this._inputs[deviceType][deviceSlot];
    if (!device) {
      throw `Unable to find device ${DeviceType[deviceType]}`;
    }
    if (deviceType >= DeviceType.DualShock && deviceType <= DeviceType.DualSense) {
      this._updateDevice(deviceType, deviceSlot, inputIndex);
    }
    const currentValue = device[inputIndex];
    if (currentValue === void 0) {
      throw `Unable to find input ${inputIndex} for device ${DeviceType[deviceType]} in slot ${deviceSlot}`;
    }
    if (inputIndex === PointerInput.Move) {
      Tools.Warn(`Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data.`);
    }
    return currentValue;
  }
  isDeviceAvailable(deviceType) {
    return this._inputs[deviceType] !== void 0;
  }
  dispose() {
    this._onDeviceConnected = () => {
    };
    this._onDeviceDisconnected = () => {
    };
    this._onInputChanged = () => {
    };
    delete this._engine._onEngineViewChanged;
    if (this._elementToAttachTo) {
      this._disableEvents();
    }
  }
  _enableEvents() {
    const inputElement = this === null || this === void 0 ? void 0 : this._engine.getInputElement();
    if (inputElement && (!this._eventsAttached || this._elementToAttachTo !== inputElement)) {
      this._disableEvents();
      if (this._inputs) {
        for (const inputs of this._inputs) {
          if (inputs) {
            for (const deviceSlotKey in inputs) {
              const deviceSlot = +deviceSlotKey;
              const device = inputs[deviceSlot];
              if (device) {
                for (let inputIndex = 0; inputIndex < device.length; inputIndex++) {
                  device[inputIndex] = 0;
                }
              }
            }
          }
        }
      }
      this._elementToAttachTo = inputElement;
      this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex;
      this._handleKeyActions();
      this._handlePointerActions();
      this._handleGamepadActions();
      this._eventsAttached = true;
      this._checkForConnectedDevices();
    }
  }
  _disableEvents() {
    if (this._elementToAttachTo) {
      this._elementToAttachTo.removeEventListener("blur", this._keyboardBlurEvent);
      this._elementToAttachTo.removeEventListener("blur", this._pointerBlurEvent);
      this._elementToAttachTo.removeEventListener("keydown", this._keyboardDownEvent);
      this._elementToAttachTo.removeEventListener("keyup", this._keyboardUpEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "down", this._pointerDownEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "up", this._pointerUpEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent);
      this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent);
      window.removeEventListener("gamepadconnected", this._gamepadConnectedEvent);
      window.removeEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
    }
    if (this._pointerInputClearObserver) {
      this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver);
    }
    this._eventsAttached = false;
  }
  _checkForConnectedDevices() {
    if (navigator.getGamepads) {
      const gamepads = navigator.getGamepads();
      for (const gamepad of gamepads) {
        if (gamepad) {
          this._addGamePad(gamepad);
        }
      }
    }
    if (typeof matchMedia === "function" && matchMedia("(pointer:fine)").matches) {
      this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);
    }
  }
  _addGamePad(gamepad) {
    const deviceType = this._getGamepadDeviceType(gamepad.id);
    const deviceSlot = gamepad.index;
    this._gamepads = this._gamepads || new Array(gamepad.index + 1);
    this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);
    this._gamepads[deviceSlot] = deviceType;
  }
  _addPointerDevice(deviceType, deviceSlot, currentX, currentY) {
    if (!this._pointerActive) {
      this._pointerActive = true;
    }
    this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);
    const pointer = this._inputs[deviceType][deviceSlot];
    pointer[0] = currentX;
    pointer[1] = currentY;
  }
  _registerDevice(deviceType, deviceSlot, numberOfInputs) {
    if (deviceSlot === void 0) {
      throw `Unable to register device ${DeviceType[deviceType]} to undefined slot.`;
    }
    if (!this._inputs[deviceType]) {
      this._inputs[deviceType] = {};
    }
    if (!this._inputs[deviceType][deviceSlot]) {
      const device = new Array(numberOfInputs);
      device.fill(0);
      this._inputs[deviceType][deviceSlot] = device;
      this._onDeviceConnected(deviceType, deviceSlot);
    }
  }
  _unregisterDevice(deviceType, deviceSlot) {
    if (this._inputs[deviceType][deviceSlot]) {
      delete this._inputs[deviceType][deviceSlot];
      this._onDeviceDisconnected(deviceType, deviceSlot);
    }
  }
  _handleKeyActions() {
    this._keyboardDownEvent = (evt) => {
      if (!this._keyboardActive) {
        this._keyboardActive = true;
        this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);
      }
      const kbKey = this._inputs[DeviceType.Keyboard][0];
      if (kbKey) {
        kbKey[evt.keyCode] = 1;
        const deviceEvent = evt;
        deviceEvent.inputIndex = evt.keyCode;
        if (this._usingMacOS && evt.metaKey && evt.key !== "Meta") {
          if (!this._metaKeys.includes(evt.keyCode)) {
            this._metaKeys.push(evt.keyCode);
          }
        }
        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
      }
    };
    this._keyboardUpEvent = (evt) => {
      if (!this._keyboardActive) {
        this._keyboardActive = true;
        this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);
      }
      const kbKey = this._inputs[DeviceType.Keyboard][0];
      if (kbKey) {
        kbKey[evt.keyCode] = 0;
        const deviceEvent = evt;
        deviceEvent.inputIndex = evt.keyCode;
        if (this._usingMacOS && evt.key === "Meta" && this._metaKeys.length > 0) {
          for (const keyCode of this._metaKeys) {
            const deviceEvent2 = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, keyCode, 0, this, this._elementToAttachTo);
            kbKey[keyCode] = 0;
            this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent2);
          }
          this._metaKeys.splice(0, this._metaKeys.length);
        }
        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
      }
    };
    this._keyboardBlurEvent = () => {
      if (this._keyboardActive) {
        const kbKey = this._inputs[DeviceType.Keyboard][0];
        for (let i = 0; i < kbKey.length; i++) {
          if (kbKey[i] !== 0) {
            kbKey[i] = 0;
            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, i, 0, this, this._elementToAttachTo);
            this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
          }
        }
        if (this._usingMacOS) {
          this._metaKeys.splice(0, this._metaKeys.length);
        }
      }
    };
    this._elementToAttachTo.addEventListener("keydown", this._keyboardDownEvent);
    this._elementToAttachTo.addEventListener("keyup", this._keyboardUpEvent);
    this._elementToAttachTo.addEventListener("blur", this._keyboardBlurEvent);
  }
  _handlePointerActions() {
    this._maxTouchPoints = DomManagement.IsNavigatorAvailable() && navigator.maxTouchPoints || 2;
    if (!this._activeTouchIds) {
      this._activeTouchIds = new Array(this._maxTouchPoints);
    }
    for (let i = 0; i < this._maxTouchPoints; i++) {
      this._activeTouchIds[i] = -1;
    }
    this._pointerMoveEvent = (evt) => {
      const deviceType = this._getPointerType(evt);
      const deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);
      if (!this._inputs[deviceType]) {
        this._inputs[deviceType] = {};
      }
      if (!this._inputs[deviceType][deviceSlot]) {
        this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
      }
      const pointer = this._inputs[deviceType][deviceSlot];
      if (pointer) {
        const deviceEvent = evt;
        deviceEvent.inputIndex = PointerInput.Move;
        pointer[PointerInput.Horizontal] = evt.clientX;
        pointer[PointerInput.Vertical] = evt.clientY;
        this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        if (!this._usingSafari && evt.button !== -1) {
          deviceEvent.inputIndex = evt.button + 2;
          pointer[evt.button + 2] = pointer[evt.button + 2] ? 0 : 1;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
      }
    };
    this._pointerDownEvent = (evt) => {
      const deviceType = this._getPointerType(evt);
      let deviceSlot = deviceType === DeviceType.Mouse ? 0 : evt.pointerId;
      if (deviceType === DeviceType.Touch) {
        const idx = this._activeTouchIds.indexOf(-1);
        if (idx >= 0) {
          deviceSlot = idx;
          this._activeTouchIds[idx] = evt.pointerId;
        } else {
          Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);
          return;
        }
      }
      if (!this._inputs[deviceType]) {
        this._inputs[deviceType] = {};
      }
      if (!this._inputs[deviceType][deviceSlot]) {
        this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
      } else if (deviceType === DeviceType.Touch) {
        this._onDeviceConnected(deviceType, deviceSlot);
      }
      const pointer = this._inputs[deviceType][deviceSlot];
      if (pointer) {
        const previousHorizontal = pointer[PointerInput.Horizontal];
        const previousVertical = pointer[PointerInput.Vertical];
        if (deviceType === DeviceType.Mouse) {
          if (this._mouseId === -1) {
            if (evt.pointerId === void 0) {
              this._mouseId = this._isUsingFirefox ? 0 : 1;
            } else {
              this._mouseId = evt.pointerId;
            }
          }
          if (!document.pointerLockElement) {
            try {
              this._elementToAttachTo.setPointerCapture(this._mouseId);
            } catch (e) {
            }
          }
        } else {
          if (evt.pointerId && !document.pointerLockElement) {
            try {
              this._elementToAttachTo.setPointerCapture(evt.pointerId);
            } catch (e) {
            }
          }
        }
        pointer[PointerInput.Horizontal] = evt.clientX;
        pointer[PointerInput.Vertical] = evt.clientY;
        pointer[evt.button + 2] = 1;
        const deviceEvent = evt;
        deviceEvent.inputIndex = evt.button + 2;
        this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = PointerInput.Move;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
      }
    };
    this._pointerUpEvent = (evt) => {
      var _a, _b, _c, _d, _e;
      const deviceType = this._getPointerType(evt);
      const deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);
      if (deviceType === DeviceType.Touch) {
        if (deviceSlot === -1) {
          return;
        } else {
          this._activeTouchIds[deviceSlot] = -1;
        }
      }
      const pointer = (_a = this._inputs[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot];
      if (pointer && pointer[evt.button + 2] !== 0) {
        const previousHorizontal = pointer[PointerInput.Horizontal];
        const previousVertical = pointer[PointerInput.Vertical];
        pointer[PointerInput.Horizontal] = evt.clientX;
        pointer[PointerInput.Vertical] = evt.clientY;
        pointer[evt.button + 2] = 0;
        const deviceEvent = evt;
        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = PointerInput.Move;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
        deviceEvent.inputIndex = evt.button + 2;
        if (deviceType === DeviceType.Mouse && this._mouseId >= 0 && ((_c = (_b = this._elementToAttachTo).hasPointerCapture) === null || _c === void 0 ? void 0 : _c.call(_b, this._mouseId))) {
          this._elementToAttachTo.releasePointerCapture(this._mouseId);
        } else if (evt.pointerId && ((_e = (_d = this._elementToAttachTo).hasPointerCapture) === null || _e === void 0 ? void 0 : _e.call(_d, evt.pointerId))) {
          this._elementToAttachTo.releasePointerCapture(evt.pointerId);
        }
        this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        if (deviceType === DeviceType.Touch) {
          this._onDeviceDisconnected(deviceType, deviceSlot);
        }
      }
    };
    this._pointerCancelEvent = (evt) => {
      var _a, _b, _c, _d;
      if (evt.pointerType === "mouse") {
        const pointer = this._inputs[DeviceType.Mouse][0];
        if (this._mouseId >= 0 && ((_b = (_a = this._elementToAttachTo).hasPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a, this._mouseId))) {
          this._elementToAttachTo.releasePointerCapture(this._mouseId);
        }
        for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {
          if (pointer[inputIndex] === 1) {
            pointer[inputIndex] = 0;
            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);
            this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);
          }
        }
      } else {
        const deviceSlot = this._activeTouchIds.indexOf(evt.pointerId);
        if ((_d = (_c = this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c, evt.pointerId)) {
          this._elementToAttachTo.releasePointerCapture(evt.pointerId);
        }
        this._inputs[DeviceType.Touch][deviceSlot][PointerInput.LeftClick] = 0;
        const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo);
        this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);
        this._activeTouchIds[deviceSlot] = -1;
        this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);
      }
    };
    this._wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
    let passiveSupported = false;
    const noop = function() {
    };
    try {
      const options = Object.defineProperty({}, "passive", {
        get: function() {
          passiveSupported = true;
        }
      });
      this._elementToAttachTo.addEventListener("test", noop, options);
      this._elementToAttachTo.removeEventListener("test", noop, options);
    } catch (e) {
    }
    this._pointerBlurEvent = () => {
      var _a, _b, _c, _d, _e;
      if (this.isDeviceAvailable(DeviceType.Mouse)) {
        const pointer = this._inputs[DeviceType.Mouse][0];
        if (this._mouseId >= 0 && ((_b = (_a = this._elementToAttachTo).hasPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a, this._mouseId))) {
          this._elementToAttachTo.releasePointerCapture(this._mouseId);
        }
        for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {
          if (pointer[inputIndex] === 1) {
            pointer[inputIndex] = 0;
            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);
            this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);
          }
        }
      }
      if (this.isDeviceAvailable(DeviceType.Touch)) {
        const pointer = this._inputs[DeviceType.Touch];
        for (let deviceSlot = 0; deviceSlot < this._activeTouchIds.length; deviceSlot++) {
          const pointerId = this._activeTouchIds[deviceSlot];
          if ((_d = (_c = this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c, pointerId)) {
            this._elementToAttachTo.releasePointerCapture(pointerId);
          }
          if (pointerId !== -1 && ((_e = pointer[deviceSlot]) === null || _e === void 0 ? void 0 : _e[PointerInput.LeftClick]) === 1) {
            pointer[deviceSlot][PointerInput.LeftClick] = 0;
            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo);
            this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);
            this._activeTouchIds[deviceSlot] = -1;
            this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);
          }
        }
      }
    };
    this._pointerWheelEvent = (evt) => {
      const deviceType = DeviceType.Mouse;
      const deviceSlot = 0;
      if (!this._inputs[deviceType]) {
        this._inputs[deviceType] = [];
      }
      if (!this._inputs[deviceType][deviceSlot]) {
        this._pointerActive = true;
        this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);
      }
      const pointer = this._inputs[deviceType][deviceSlot];
      if (pointer) {
        pointer[PointerInput.MouseWheelX] = evt.deltaX || 0;
        pointer[PointerInput.MouseWheelY] = evt.deltaY || evt.wheelDelta || 0;
        pointer[PointerInput.MouseWheelZ] = evt.deltaZ || 0;
        const deviceEvent = evt;
        if (pointer[PointerInput.MouseWheelX] !== 0) {
          deviceEvent.inputIndex = PointerInput.MouseWheelX;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
        if (pointer[PointerInput.MouseWheelY] !== 0) {
          deviceEvent.inputIndex = PointerInput.MouseWheelY;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
        if (pointer[PointerInput.MouseWheelZ] !== 0) {
          deviceEvent.inputIndex = PointerInput.MouseWheelZ;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
      }
    };
    this._elementToAttachTo.addEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "down", this._pointerDownEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "up", this._pointerUpEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent);
    this._elementToAttachTo.addEventListener("blur", this._pointerBlurEvent);
    this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, passiveSupported ? { passive: false } : false);
    this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(() => {
      if (this.isDeviceAvailable(DeviceType.Mouse)) {
        const pointer = this._inputs[DeviceType.Mouse][0];
        pointer[PointerInput.MouseWheelX] = 0;
        pointer[PointerInput.MouseWheelY] = 0;
        pointer[PointerInput.MouseWheelZ] = 0;
      }
    });
  }
  _handleGamepadActions() {
    this._gamepadConnectedEvent = (evt) => {
      this._addGamePad(evt.gamepad);
    };
    this._gamepadDisconnectedEvent = (evt) => {
      if (this._gamepads) {
        const deviceType = this._getGamepadDeviceType(evt.gamepad.id);
        const deviceSlot = evt.gamepad.index;
        this._unregisterDevice(deviceType, deviceSlot);
        delete this._gamepads[deviceSlot];
      }
    };
    window.addEventListener("gamepadconnected", this._gamepadConnectedEvent);
    window.addEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
  }
  _updateDevice(deviceType, deviceSlot, inputIndex) {
    const gp = navigator.getGamepads()[deviceSlot];
    if (gp && deviceType === this._gamepads[deviceSlot]) {
      const device = this._inputs[deviceType][deviceSlot];
      if (inputIndex >= gp.buttons.length) {
        device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();
      } else {
        device[inputIndex] = gp.buttons[inputIndex].value;
      }
    }
  }
  _getGamepadDeviceType(deviceName) {
    if (deviceName.indexOf("054c") !== -1) {
      return deviceName.indexOf("0ce6") !== -1 ? DeviceType.DualSense : DeviceType.DualShock;
    } else if (deviceName.indexOf("Xbox One") !== -1 || deviceName.search("Xbox 360") !== -1 || deviceName.search("xinput") !== -1) {
      return DeviceType.Xbox;
    } else if (deviceName.indexOf("057e") !== -1) {
      return DeviceType.Switch;
    }
    return DeviceType.Generic;
  }
  _getPointerType(evt) {
    let deviceType = DeviceType.Mouse;
    if (evt.pointerType === "touch" || evt.pointerType === "pen" || evt.touches) {
      deviceType = DeviceType.Touch;
    }
    return deviceType;
  }
};

// node_modules/@babylonjs/core/DeviceInput/internalDeviceSourceManager.js
var InternalDeviceSourceManager = class {
  constructor(engine) {
    this._registeredManagers = new Array();
    this._refCount = 0;
    this.registerManager = (manager) => {
      for (let deviceType = 0; deviceType < this._devices.length; deviceType++) {
        const device = this._devices[deviceType];
        for (const deviceSlotKey in device) {
          const deviceSlot = +deviceSlotKey;
          manager._addDevice(new DeviceSource(this._deviceInputSystem, deviceType, deviceSlot));
        }
      }
      this._registeredManagers.push(manager);
    };
    this.unregisterManager = (manager) => {
      const idx = this._registeredManagers.indexOf(manager);
      if (idx > -1) {
        this._registeredManagers.splice(idx, 1);
      }
    };
    const numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
    this._devices = new Array(numberOfDeviceTypes);
    const onDeviceConnected = (deviceType, deviceSlot) => {
      if (!this._devices[deviceType]) {
        this._devices[deviceType] = new Array();
      }
      if (!this._devices[deviceType][deviceSlot]) {
        this._devices[deviceType][deviceSlot] = deviceSlot;
      }
      for (const manager of this._registeredManagers) {
        const deviceSource = new DeviceSource(this._deviceInputSystem, deviceType, deviceSlot);
        manager._addDevice(deviceSource);
      }
    };
    const onDeviceDisconnected = (deviceType, deviceSlot) => {
      var _a;
      if ((_a = this._devices[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot]) {
        delete this._devices[deviceType][deviceSlot];
      }
      for (const manager of this._registeredManagers) {
        manager._removeDevice(deviceType, deviceSlot);
      }
    };
    const onInputChanged = (deviceType, deviceSlot, eventData) => {
      if (eventData) {
        for (const manager of this._registeredManagers) {
          manager._onInputChanged(deviceType, deviceSlot, eventData);
        }
      }
    };
    if (typeof _native !== "undefined") {
      this._deviceInputSystem = new NativeDeviceInputSystem(onDeviceConnected, onDeviceDisconnected, onInputChanged);
    } else {
      this._deviceInputSystem = new WebDeviceInputSystem(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged);
    }
  }
  dispose() {
    this._deviceInputSystem.dispose();
  }
};

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceSourceManager.js
var DeviceSourceManager = class {
  constructor(engine) {
    const numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
    this._devices = new Array(numberOfDeviceTypes);
    this._firstDevice = new Array(numberOfDeviceTypes);
    this._engine = engine;
    if (!this._engine._deviceSourceManager) {
      this._engine._deviceSourceManager = new InternalDeviceSourceManager(engine);
    }
    this._engine._deviceSourceManager._refCount++;
    this.onDeviceConnectedObservable = new Observable((observer) => {
      for (const devices of this._devices) {
        if (devices) {
          for (const device of devices) {
            if (device) {
              this.onDeviceConnectedObservable.notifyObserver(observer, device);
            }
          }
        }
      }
    });
    this.onDeviceDisconnectedObservable = new Observable();
    this._engine._deviceSourceManager.registerManager(this);
    this._onDisposeObserver = engine.onDisposeObservable.add(() => {
      this.dispose();
    });
  }
  getDeviceSource(deviceType, deviceSlot) {
    if (deviceSlot === void 0) {
      if (this._firstDevice[deviceType] === void 0) {
        return null;
      }
      deviceSlot = this._firstDevice[deviceType];
    }
    if (!this._devices[deviceType] || this._devices[deviceType][deviceSlot] === void 0) {
      return null;
    }
    return this._devices[deviceType][deviceSlot];
  }
  getDeviceSources(deviceType) {
    if (!this._devices[deviceType]) {
      return [];
    }
    return this._devices[deviceType].filter((source) => {
      return !!source;
    });
  }
  dispose() {
    this.onDeviceConnectedObservable.clear();
    this.onDeviceDisconnectedObservable.clear();
    if (this._engine._deviceSourceManager) {
      this._engine._deviceSourceManager.unregisterManager(this);
      if (--this._engine._deviceSourceManager._refCount < 1) {
        this._engine._deviceSourceManager.dispose();
        delete this._engine._deviceSourceManager;
      }
    }
    this._engine.onDisposeObservable.remove(this._onDisposeObserver);
  }
  _addDevice(deviceSource) {
    if (!this._devices[deviceSource.deviceType]) {
      this._devices[deviceSource.deviceType] = new Array();
    }
    if (!this._devices[deviceSource.deviceType][deviceSource.deviceSlot]) {
      this._devices[deviceSource.deviceType][deviceSource.deviceSlot] = deviceSource;
      this._updateFirstDevices(deviceSource.deviceType);
    }
    this.onDeviceConnectedObservable.notifyObservers(deviceSource);
  }
  _removeDevice(deviceType, deviceSlot) {
    var _a, _b;
    const deviceSource = (_a = this._devices[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot];
    this.onDeviceDisconnectedObservable.notifyObservers(deviceSource);
    if ((_b = this._devices[deviceType]) === null || _b === void 0 ? void 0 : _b[deviceSlot]) {
      delete this._devices[deviceType][deviceSlot];
    }
    this._updateFirstDevices(deviceType);
  }
  _onInputChanged(deviceType, deviceSlot, eventData) {
    var _a, _b;
    (_b = (_a = this._devices[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot]) === null || _b === void 0 ? void 0 : _b.onInputChangedObservable.notifyObservers(eventData);
  }
  _updateFirstDevices(type) {
    switch (type) {
      case DeviceType.Keyboard:
      case DeviceType.Mouse:
        this._firstDevice[type] = 0;
        break;
      case DeviceType.Touch:
      case DeviceType.DualSense:
      case DeviceType.DualShock:
      case DeviceType.Xbox:
      case DeviceType.Switch:
      case DeviceType.Generic: {
        delete this._firstDevice[type];
        const devices = this._devices[type];
        if (devices) {
          for (let i = 0; i < devices.length; i++) {
            if (devices[i]) {
              this._firstDevice[type] = i;
              break;
            }
          }
        }
        break;
      }
    }
  }
};

// node_modules/@babylonjs/core/Misc/perfCounter.js
var PerfCounter = class {
  constructor() {
    this._startMonitoringTime = 0;
    this._min = 0;
    this._max = 0;
    this._average = 0;
    this._lastSecAverage = 0;
    this._current = 0;
    this._totalValueCount = 0;
    this._totalAccumulated = 0;
    this._lastSecAccumulated = 0;
    this._lastSecTime = 0;
    this._lastSecValueCount = 0;
  }
  get min() {
    return this._min;
  }
  get max() {
    return this._max;
  }
  get average() {
    return this._average;
  }
  get lastSecAverage() {
    return this._lastSecAverage;
  }
  get current() {
    return this._current;
  }
  get total() {
    return this._totalAccumulated;
  }
  get count() {
    return this._totalValueCount;
  }
  fetchNewFrame() {
    this._totalValueCount++;
    this._current = 0;
    this._lastSecValueCount++;
  }
  addCount(newCount, fetchResult) {
    if (!PerfCounter.Enabled) {
      return;
    }
    this._current += newCount;
    if (fetchResult) {
      this._fetchResult();
    }
  }
  beginMonitoring() {
    if (!PerfCounter.Enabled) {
      return;
    }
    this._startMonitoringTime = PrecisionDate.Now;
  }
  endMonitoring(newFrame = true) {
    if (!PerfCounter.Enabled) {
      return;
    }
    if (newFrame) {
      this.fetchNewFrame();
    }
    const currentTime = PrecisionDate.Now;
    this._current = currentTime - this._startMonitoringTime;
    if (newFrame) {
      this._fetchResult();
    }
  }
  _fetchResult() {
    this._totalAccumulated += this._current;
    this._lastSecAccumulated += this._current;
    this._min = Math.min(this._min, this._current);
    this._max = Math.max(this._max, this._current);
    this._average = this._totalAccumulated / this._totalValueCount;
    const now = PrecisionDate.Now;
    if (now - this._lastSecTime > 1e3) {
      this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount;
      this._lastSecTime = now;
      this._lastSecAccumulated = 0;
      this._lastSecValueCount = 0;
    }
  }
};
PerfCounter.Enabled = true;

// node_modules/@babylonjs/core/Maths/math.plane.js
var Plane = class {
  constructor(a, b, c, d) {
    this.normal = new Vector3(a, b, c);
    this.d = d;
  }
  asArray() {
    return [this.normal.x, this.normal.y, this.normal.z, this.d];
  }
  clone() {
    return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);
  }
  getClassName() {
    return "Plane";
  }
  getHashCode() {
    let hash = this.normal.getHashCode();
    hash = hash * 397 ^ (this.d | 0);
    return hash;
  }
  normalize() {
    const norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);
    let magnitude = 0;
    if (norm !== 0) {
      magnitude = 1 / norm;
    }
    this.normal.x *= magnitude;
    this.normal.y *= magnitude;
    this.normal.z *= magnitude;
    this.d *= magnitude;
    return this;
  }
  transform(transformation) {
    const invertedMatrix = Plane._TmpMatrix;
    transformation.invertToRef(invertedMatrix);
    const m = invertedMatrix.m;
    const x = this.normal.x;
    const y = this.normal.y;
    const z = this.normal.z;
    const d = this.d;
    const normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];
    const normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];
    const normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];
    const finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];
    return new Plane(normalX, normalY, normalZ, finalD);
  }
  dotCoordinate(point) {
    return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;
  }
  copyFromPoints(point1, point2, point3) {
    const x1 = point2.x - point1.x;
    const y1 = point2.y - point1.y;
    const z1 = point2.z - point1.z;
    const x2 = point3.x - point1.x;
    const y2 = point3.y - point1.y;
    const z2 = point3.z - point1.z;
    const yz = y1 * z2 - z1 * y2;
    const xz = z1 * x2 - x1 * z2;
    const xy = x1 * y2 - y1 * x2;
    const pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);
    let invPyth;
    if (pyth !== 0) {
      invPyth = 1 / pyth;
    } else {
      invPyth = 0;
    }
    this.normal.x = yz * invPyth;
    this.normal.y = xz * invPyth;
    this.normal.z = xy * invPyth;
    this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);
    return this;
  }
  isFrontFacingTo(direction, epsilon) {
    const dot = Vector3.Dot(this.normal, direction);
    return dot <= epsilon;
  }
  signedDistanceTo(point) {
    return Vector3.Dot(point, this.normal) + this.d;
  }
  static FromArray(array) {
    return new Plane(array[0], array[1], array[2], array[3]);
  }
  static FromPoints(point1, point2, point3) {
    const result = new Plane(0, 0, 0, 0);
    result.copyFromPoints(point1, point2, point3);
    return result;
  }
  static FromPositionAndNormal(origin, normal) {
    const result = new Plane(0, 0, 0, 0);
    normal.normalize();
    result.normal = normal;
    result.d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);
    return result;
  }
  static SignedDistanceToPlaneFromPositionAndNormal(origin, normal, point) {
    const d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);
    return Vector3.Dot(point, normal) + d;
  }
};
Plane._TmpMatrix = Matrix.Identity();

// node_modules/@babylonjs/core/Maths/math.frustum.js
var Frustum = class {
  static GetPlanes(transform) {
    const frustumPlanes = [];
    for (let index = 0; index < 6; index++) {
      frustumPlanes.push(new Plane(0, 0, 0, 0));
    }
    Frustum.GetPlanesToRef(transform, frustumPlanes);
    return frustumPlanes;
  }
  static GetNearPlaneToRef(transform, frustumPlane) {
    const m = transform.m;
    frustumPlane.normal.x = m[3] + m[2];
    frustumPlane.normal.y = m[7] + m[6];
    frustumPlane.normal.z = m[11] + m[10];
    frustumPlane.d = m[15] + m[14];
    frustumPlane.normalize();
  }
  static GetFarPlaneToRef(transform, frustumPlane) {
    const m = transform.m;
    frustumPlane.normal.x = m[3] - m[2];
    frustumPlane.normal.y = m[7] - m[6];
    frustumPlane.normal.z = m[11] - m[10];
    frustumPlane.d = m[15] - m[14];
    frustumPlane.normalize();
  }
  static GetLeftPlaneToRef(transform, frustumPlane) {
    const m = transform.m;
    frustumPlane.normal.x = m[3] + m[0];
    frustumPlane.normal.y = m[7] + m[4];
    frustumPlane.normal.z = m[11] + m[8];
    frustumPlane.d = m[15] + m[12];
    frustumPlane.normalize();
  }
  static GetRightPlaneToRef(transform, frustumPlane) {
    const m = transform.m;
    frustumPlane.normal.x = m[3] - m[0];
    frustumPlane.normal.y = m[7] - m[4];
    frustumPlane.normal.z = m[11] - m[8];
    frustumPlane.d = m[15] - m[12];
    frustumPlane.normalize();
  }
  static GetTopPlaneToRef(transform, frustumPlane) {
    const m = transform.m;
    frustumPlane.normal.x = m[3] - m[1];
    frustumPlane.normal.y = m[7] - m[5];
    frustumPlane.normal.z = m[11] - m[9];
    frustumPlane.d = m[15] - m[13];
    frustumPlane.normalize();
  }
  static GetBottomPlaneToRef(transform, frustumPlane) {
    const m = transform.m;
    frustumPlane.normal.x = m[3] + m[1];
    frustumPlane.normal.y = m[7] + m[5];
    frustumPlane.normal.z = m[11] + m[9];
    frustumPlane.d = m[15] + m[13];
    frustumPlane.normalize();
  }
  static GetPlanesToRef(transform, frustumPlanes) {
    Frustum.GetNearPlaneToRef(transform, frustumPlanes[0]);
    Frustum.GetFarPlaneToRef(transform, frustumPlanes[1]);
    Frustum.GetLeftPlaneToRef(transform, frustumPlanes[2]);
    Frustum.GetRightPlaneToRef(transform, frustumPlanes[3]);
    Frustum.GetTopPlaneToRef(transform, frustumPlanes[4]);
    Frustum.GetBottomPlaneToRef(transform, frustumPlanes[5]);
  }
};

// node_modules/@babylonjs/core/Inputs/scene.inputManager.js
var _ClickInfo = class {
  constructor() {
    this._singleClick = false;
    this._doubleClick = false;
    this._hasSwiped = false;
    this._ignore = false;
  }
  get singleClick() {
    return this._singleClick;
  }
  get doubleClick() {
    return this._doubleClick;
  }
  get hasSwiped() {
    return this._hasSwiped;
  }
  get ignore() {
    return this._ignore;
  }
  set singleClick(b) {
    this._singleClick = b;
  }
  set doubleClick(b) {
    this._doubleClick = b;
  }
  set hasSwiped(b) {
    this._hasSwiped = b;
  }
  set ignore(b) {
    this._ignore = b;
  }
};
var InputManager = class {
  constructor(scene) {
    this._alreadyAttached = false;
    this._meshPickProceed = false;
    this._currentPickResult = null;
    this._previousPickResult = null;
    this._totalPointersPressed = 0;
    this._doubleClickOccured = false;
    this._isSwiping = false;
    this._swipeButtonPressed = -1;
    this._skipPointerTap = false;
    this._pointerX = 0;
    this._pointerY = 0;
    this._startingPointerPosition = new Vector2(0, 0);
    this._previousStartingPointerPosition = new Vector2(0, 0);
    this._startingPointerTime = 0;
    this._previousStartingPointerTime = 0;
    this._pointerCaptures = {};
    this._meshUnderPointerId = {};
    this._movePointerInfo = null;
    this._cameraObserverCount = 0;
    this._deviceSourceManager = null;
    this._scene = scene || EngineStore.LastCreatedScene;
    if (!this._scene) {
      return;
    }
  }
  get meshUnderPointer() {
    if (this._movePointerInfo) {
      this._movePointerInfo._generatePickInfo();
      this._movePointerInfo = null;
    }
    return this._pointerOverMesh;
  }
  getMeshUnderPointerByPointerId(pointerId) {
    return this._meshUnderPointerId[pointerId] || null;
  }
  get unTranslatedPointer() {
    return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);
  }
  get pointerX() {
    return this._pointerX;
  }
  set pointerX(value) {
    this._pointerX = value;
  }
  get pointerY() {
    return this._pointerY;
  }
  set pointerY(value) {
    this._pointerY = value;
  }
  _updatePointerPosition(evt) {
    const canvasRect = this._scene.getEngine().getInputElementClientRect();
    if (!canvasRect) {
      return;
    }
    this._pointerX = evt.clientX - canvasRect.left;
    this._pointerY = evt.clientY - canvasRect.top;
    this._unTranslatedPointerX = this._pointerX;
    this._unTranslatedPointerY = this._pointerY;
  }
  _processPointerMove(pickResult, evt) {
    const scene = this._scene;
    const engine = scene.getEngine();
    const canvas = engine.getInputElement();
    if (canvas) {
      canvas.tabIndex = engine.canvasTabIndex;
      if (!scene.doNotHandleCursors) {
        canvas.style.cursor = scene.defaultCursor;
      }
    }
    this._setCursorAndPointerOverMesh(pickResult, evt.pointerId, scene);
    for (const step of scene._pointerMoveStage) {
      const isMeshPicked = (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) ? true : false;
      pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);
    }
    const type = evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;
    if (scene.onPointerMove) {
      pickResult = pickResult || this._pickMove(evt.pointerId);
      scene.onPointerMove(evt, pickResult, type);
    }
    let pointerInfo;
    if (pickResult) {
      pointerInfo = new PointerInfo(type, evt, pickResult);
      this._setRayOnPointerInfo(pickResult, evt);
    } else {
      pointerInfo = new PointerInfo(type, evt, null, this);
      this._movePointerInfo = pointerInfo;
    }
    if (scene.onPointerObservable.hasObservers()) {
      scene.onPointerObservable.notifyObservers(pointerInfo, type);
    }
  }
  _setRayOnPointerInfo(pickInfo, event) {
    const scene = this._scene;
    if (pickInfo && scene._pickingAvailable) {
      if (!pickInfo.ray) {
        pickInfo.ray = scene.createPickingRay(event.offsetX, event.offsetY, Matrix.Identity(), scene.activeCamera);
      }
    }
  }
  _addCameraPointerObserver(observer, mask) {
    this._cameraObserverCount++;
    return this._scene.onPointerObservable.add(observer, mask);
  }
  _removeCameraPointerObserver(observer) {
    this._cameraObserverCount--;
    return this._scene.onPointerObservable.remove(observer);
  }
  _checkForPicking() {
    return !!(this._scene.onPointerObservable.observers.length > this._cameraObserverCount || this._scene.onPointerPick);
  }
  _checkPrePointerObservable(pickResult, evt, type) {
    const scene = this._scene;
    const pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);
    if (pickResult) {
      pi.originalPickingInfo = pickResult;
      pi.ray = pickResult.ray;
      if (pickResult.originMesh) {
        pi.nearInteractionPickingInfo = pickResult;
      }
    }
    scene.onPrePointerObservable.notifyObservers(pi, type);
    if (pi.skipOnPointerObservable) {
      return true;
    } else {
      return false;
    }
  }
  _pickMove(pointerId) {
    const scene = this._scene;
    const pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerMovePredicate, false, scene.cameraToUseForPointers, scene.pointerMoveTrianglePredicate);
    this._setCursorAndPointerOverMesh(pickResult, pointerId, scene);
    return pickResult;
  }
  _setCursorAndPointerOverMesh(pickResult, pointerId, scene) {
    const engine = scene.getEngine();
    const canvas = engine.getInputElement();
    if (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) {
      this.setPointerOverMesh(pickResult.pickedMesh, pointerId, pickResult);
      if (!scene.doNotHandleCursors && canvas && this._pointerOverMesh) {
        const actionManager = this._pointerOverMesh._getActionManagerForTrigger();
        if (actionManager && actionManager.hasPointerTriggers) {
          canvas.style.cursor = actionManager.hoverCursor || scene.hoverCursor;
        }
      }
    } else {
      this.setPointerOverMesh(null, pointerId, pickResult);
    }
  }
  simulatePointerMove(pickResult, pointerEventInit) {
    const evt = new PointerEvent("pointermove", pointerEventInit);
    evt.inputIndex = PointerInput.Move;
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {
      return;
    }
    this._processPointerMove(pickResult, evt);
  }
  simulatePointerDown(pickResult, pointerEventInit) {
    const evt = new PointerEvent("pointerdown", pointerEventInit);
    evt.inputIndex = evt.button + 2;
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {
      return;
    }
    this._processPointerDown(pickResult, evt);
  }
  _processPointerDown(pickResult, evt) {
    const scene = this._scene;
    if (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) {
      this._pickedDownMesh = pickResult.pickedMesh;
      const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();
      if (actionManager) {
        if (actionManager.hasPickTriggers) {
          actionManager.processTrigger(5, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
          switch (evt.button) {
            case 0:
              actionManager.processTrigger(2, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
              break;
            case 1:
              actionManager.processTrigger(4, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
              break;
            case 2:
              actionManager.processTrigger(3, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
              break;
          }
        }
        if (actionManager.hasSpecificTrigger(8)) {
          window.setTimeout(() => {
            const pickResult2 = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, (mesh) => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh === this._pickedDownMesh, false, scene.cameraToUseForPointers);
            if ((pickResult2 === null || pickResult2 === void 0 ? void 0 : pickResult2.pickedMesh) && actionManager) {
              if (this._totalPointersPressed !== 0 && Date.now() - this._startingPointerTime > InputManager.LongPressDelay && !this._isPointerSwiping()) {
                this._startingPointerTime = 0;
                actionManager.processTrigger(8, ActionEvent.CreateNew(pickResult2.pickedMesh, evt));
              }
            }
          }, InputManager.LongPressDelay);
        }
      }
    } else {
      for (const step of scene._pointerDownStage) {
        pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, false);
      }
    }
    let pointerInfo;
    const type = PointerEventTypes.POINTERDOWN;
    if (pickResult) {
      if (scene.onPointerDown) {
        scene.onPointerDown(evt, pickResult, type);
      }
      pointerInfo = new PointerInfo(type, evt, pickResult);
      this._setRayOnPointerInfo(pickResult, evt);
    } else {
      pointerInfo = new PointerInfo(type, evt, null, this);
    }
    if (scene.onPointerObservable.hasObservers()) {
      scene.onPointerObservable.notifyObservers(pointerInfo, type);
    }
  }
  _isPointerSwiping() {
    return this._isSwiping;
  }
  simulatePointerUp(pickResult, pointerEventInit, doubleTap) {
    const evt = new PointerEvent("pointerup", pointerEventInit);
    evt.inputIndex = PointerInput.Move;
    const clickInfo = new _ClickInfo();
    if (doubleTap) {
      clickInfo.doubleClick = true;
    } else {
      clickInfo.singleClick = true;
    }
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {
      return;
    }
    this._processPointerUp(pickResult, evt, clickInfo);
  }
  _processPointerUp(pickResult, evt, clickInfo) {
    const scene = this._scene;
    if (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) {
      this._pickedUpMesh = pickResult.pickedMesh;
      if (this._pickedDownMesh === this._pickedUpMesh) {
        if (scene.onPointerPick) {
          scene.onPointerPick(evt, pickResult);
        }
        if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.observers.length > this._cameraObserverCount) {
          const type = PointerEventTypes.POINTERPICK;
          const pi = new PointerInfo(type, evt, pickResult);
          this._setRayOnPointerInfo(pickResult, evt);
          scene.onPointerObservable.notifyObservers(pi, type);
        }
      }
      const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();
      if (actionManager && !clickInfo.ignore) {
        actionManager.processTrigger(7, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
        if (!clickInfo.hasSwiped && clickInfo.singleClick) {
          actionManager.processTrigger(1, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
        }
        const doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);
        if (clickInfo.doubleClick && doubleClickActionManager) {
          doubleClickActionManager.processTrigger(6, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
        }
      }
    } else {
      if (!clickInfo.ignore) {
        for (const step of scene._pointerUpStage) {
          pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, clickInfo.doubleClick);
        }
      }
    }
    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {
      const pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);
      if (pickedDownActionManager) {
        pickedDownActionManager.processTrigger(16, ActionEvent.CreateNew(this._pickedDownMesh, evt));
      }
    }
    if (!clickInfo.ignore) {
      const pi = new PointerInfo(PointerEventTypes.POINTERUP, evt, pickResult);
      this._setRayOnPointerInfo(pickResult, evt);
      scene.onPointerObservable.notifyObservers(pi, PointerEventTypes.POINTERUP);
      if (scene.onPointerUp) {
        scene.onPointerUp(evt, pickResult, PointerEventTypes.POINTERUP);
      }
      if (!clickInfo.hasSwiped && !this._skipPointerTap) {
        let type = 0;
        if (clickInfo.singleClick) {
          type = PointerEventTypes.POINTERTAP;
        } else if (clickInfo.doubleClick) {
          type = PointerEventTypes.POINTERDOUBLETAP;
        }
        if (type) {
          const pi2 = new PointerInfo(type, evt, pickResult);
          if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {
            scene.onPointerObservable.notifyObservers(pi2, type);
          }
        }
      }
    }
  }
  isPointerCaptured(pointerId = 0) {
    return this._pointerCaptures[pointerId];
  }
  attachControl(attachUp = true, attachDown = true, attachMove = true, elementToAttachTo = null) {
    const scene = this._scene;
    const engine = scene.getEngine();
    if (!elementToAttachTo) {
      elementToAttachTo = engine.getInputElement();
    }
    if (this._alreadyAttached) {
      this.detachControl();
    }
    if (elementToAttachTo) {
      this._alreadyAttachedTo = elementToAttachTo;
    }
    this._deviceSourceManager = new DeviceSourceManager(engine);
    this._initActionManager = (act) => {
      if (!this._meshPickProceed) {
        const pickResult = scene.skipPointerUpPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerUp ? null : scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerUpPredicate, false, scene.cameraToUseForPointers);
        this._currentPickResult = pickResult;
        if (pickResult) {
          act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;
        }
        this._meshPickProceed = true;
      }
      return act;
    };
    this._delayedSimpleClick = (btn, clickInfo, cb) => {
      if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay && !this._doubleClickOccured || btn !== this._previousButtonPressed) {
        this._doubleClickOccured = false;
        clickInfo.singleClick = true;
        clickInfo.ignore = false;
        cb(clickInfo, this._currentPickResult);
      }
    };
    this._initClickEvent = (obs1, obs2, evt, cb) => {
      const clickInfo = new _ClickInfo();
      this._currentPickResult = null;
      let act = null;
      let checkPicking = obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
      if (!checkPicking && AbstractActionManager) {
        act = this._initActionManager(act, clickInfo);
        if (act) {
          checkPicking = act.hasPickTriggers;
        }
      }
      let needToIgnoreNext = false;
      if (checkPicking) {
        const btn = evt.button;
        clickInfo.hasSwiped = this._isPointerSwiping();
        if (!clickInfo.hasSwiped) {
          let checkSingleClickImmediately = !InputManager.ExclusiveDoubleClickMode;
          if (!checkSingleClickImmediately) {
            checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
            if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(6)) {
              act = this._initActionManager(act, clickInfo);
              if (act) {
                checkSingleClickImmediately = !act.hasSpecificTrigger(6);
              }
            }
          }
          if (checkSingleClickImmediately) {
            if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay || btn !== this._previousButtonPressed) {
              clickInfo.singleClick = true;
              cb(clickInfo, this._currentPickResult);
              needToIgnoreNext = true;
            }
          } else {
            this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout;
            this._delayedSimpleClickTimeout = window.setTimeout(this._delayedSimpleClick.bind(this, btn, clickInfo, cb), InputManager.DoubleClickDelay);
          }
          let checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
          if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(6)) {
            act = this._initActionManager(act, clickInfo);
            if (act) {
              checkDoubleClick = act.hasSpecificTrigger(6);
            }
          }
          if (checkDoubleClick) {
            if (btn === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < InputManager.DoubleClickDelay && !this._doubleClickOccured) {
              if (!clickInfo.hasSwiped && !this._isPointerSwiping()) {
                this._previousStartingPointerTime = 0;
                this._doubleClickOccured = true;
                clickInfo.doubleClick = true;
                clickInfo.ignore = false;
                if (InputManager.ExclusiveDoubleClickMode && this._previousDelayedSimpleClickTimeout) {
                  clearTimeout(this._previousDelayedSimpleClickTimeout);
                }
                this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout;
                cb(clickInfo, this._currentPickResult);
              } else {
                this._doubleClickOccured = false;
                this._previousStartingPointerTime = this._startingPointerTime;
                this._previousStartingPointerPosition.x = this._startingPointerPosition.x;
                this._previousStartingPointerPosition.y = this._startingPointerPosition.y;
                this._previousButtonPressed = btn;
                if (InputManager.ExclusiveDoubleClickMode) {
                  if (this._previousDelayedSimpleClickTimeout) {
                    clearTimeout(this._previousDelayedSimpleClickTimeout);
                  }
                  this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout;
                  cb(clickInfo, this._previousPickResult);
                } else {
                  cb(clickInfo, this._currentPickResult);
                }
              }
              needToIgnoreNext = true;
            } else {
              this._doubleClickOccured = false;
              this._previousStartingPointerTime = this._startingPointerTime;
              this._previousStartingPointerPosition.x = this._startingPointerPosition.x;
              this._previousStartingPointerPosition.y = this._startingPointerPosition.y;
              this._previousButtonPressed = btn;
            }
          }
        }
      }
      if (!needToIgnoreNext) {
        cb(clickInfo, this._currentPickResult);
      }
    };
    this._onPointerMove = (evt) => {
      if (evt.pointerId === void 0) {
        evt.pointerId = 0;
      }
      this._updatePointerPosition(evt);
      if (!this._isSwiping && this._swipeButtonPressed !== -1) {
        this._isSwiping = Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager.DragMovementThreshold;
      }
      if (this._checkPrePointerObservable(null, evt, evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE)) {
        return;
      }
      if (!scene.cameraToUseForPointers && !scene.activeCamera) {
        return;
      }
      if (scene.skipPointerMovePicking) {
        this._processPointerMove(new PickingInfo(), evt);
        return;
      }
      if (!scene.pointerMovePredicate) {
        scene.pointerMovePredicate = (mesh) => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
      }
      const pickResult = scene._registeredActions > 0 ? this._pickMove(evt.pointerId) : null;
      this._processPointerMove(pickResult, evt);
    };
    this._onPointerDown = (evt) => {
      this._totalPointersPressed++;
      this._pickedDownMesh = null;
      this._meshPickProceed = false;
      if (evt.pointerId === void 0) {
        evt.pointerId = 0;
      }
      this._updatePointerPosition(evt);
      if (this._swipeButtonPressed === -1) {
        this._swipeButtonPressed = evt.button;
      }
      if (scene.preventDefaultOnPointerDown && elementToAttachTo) {
        evt.preventDefault();
        elementToAttachTo.focus();
      }
      this._startingPointerPosition.x = this._pointerX;
      this._startingPointerPosition.y = this._pointerY;
      this._startingPointerTime = Date.now();
      if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {
        return;
      }
      if (!scene.cameraToUseForPointers && !scene.activeCamera) {
        return;
      }
      this._pointerCaptures[evt.pointerId] = true;
      if (!scene.pointerDownPredicate) {
        scene.pointerDownPredicate = (mesh) => {
          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
        };
      }
      this._pickedDownMesh = null;
      let pickResult;
      if (scene.skipPointerDownPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerDown) {
        pickResult = new PickingInfo();
      } else {
        pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);
      }
      this._processPointerDown(pickResult, evt);
    };
    this._onPointerUp = (evt) => {
      if (this._totalPointersPressed === 0) {
        return;
      }
      this._totalPointersPressed--;
      this._pickedUpMesh = null;
      this._meshPickProceed = false;
      if (evt.pointerId === void 0) {
        evt.pointerId = 0;
      }
      this._updatePointerPosition(evt);
      if (scene.preventDefaultOnPointerUp && elementToAttachTo) {
        evt.preventDefault();
        elementToAttachTo.focus();
      }
      this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, (clickInfo, pickResult) => {
        if (scene.onPrePointerObservable.hasObservers()) {
          this._skipPointerTap = false;
          if (!clickInfo.ignore) {
            if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {
              if (this._swipeButtonPressed === evt.button) {
                this._isSwiping = false;
                this._swipeButtonPressed = -1;
              }
              return;
            }
            if (!clickInfo.hasSwiped) {
              if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {
                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {
                  this._skipPointerTap = true;
                }
              }
              if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {
                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {
                  this._skipPointerTap = true;
                }
              }
            }
          }
        }
        this._pointerCaptures[evt.pointerId] = false;
        if (!scene.cameraToUseForPointers && !scene.activeCamera) {
          return;
        }
        if (!scene.pointerUpPredicate) {
          scene.pointerUpPredicate = (mesh) => {
            return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
          };
        }
        if (!this._meshPickProceed && (AbstractActionManager && AbstractActionManager.HasTriggers || this._checkForPicking() || scene.onPointerUp)) {
          this._initActionManager(null, clickInfo);
        }
        if (!pickResult) {
          pickResult = this._currentPickResult;
        }
        this._processPointerUp(pickResult, evt, clickInfo);
        this._previousPickResult = this._currentPickResult;
        if (this._swipeButtonPressed === evt.button) {
          this._isSwiping = false;
          this._swipeButtonPressed = -1;
        }
      });
    };
    this._onKeyDown = (evt) => {
      const type = KeyboardEventTypes.KEYDOWN;
      if (scene.onPreKeyboardObservable.hasObservers()) {
        const pi = new KeyboardInfoPre(type, evt);
        scene.onPreKeyboardObservable.notifyObservers(pi, type);
        if (pi.skipOnKeyboardObservable) {
          return;
        }
      }
      if (scene.onKeyboardObservable.hasObservers()) {
        const pi = new KeyboardInfo(type, evt);
        scene.onKeyboardObservable.notifyObservers(pi, type);
      }
      if (scene.actionManager) {
        scene.actionManager.processTrigger(14, ActionEvent.CreateNewFromScene(scene, evt));
      }
    };
    this._onKeyUp = (evt) => {
      const type = KeyboardEventTypes.KEYUP;
      if (scene.onPreKeyboardObservable.hasObservers()) {
        const pi = new KeyboardInfoPre(type, evt);
        scene.onPreKeyboardObservable.notifyObservers(pi, type);
        if (pi.skipOnKeyboardObservable) {
          return;
        }
      }
      if (scene.onKeyboardObservable.hasObservers()) {
        const pi = new KeyboardInfo(type, evt);
        scene.onKeyboardObservable.notifyObservers(pi, type);
      }
      if (scene.actionManager) {
        scene.actionManager.processTrigger(15, ActionEvent.CreateNewFromScene(scene, evt));
      }
    };
    this._deviceSourceManager.onDeviceConnectedObservable.add((deviceSource) => {
      if (deviceSource.deviceType === DeviceType.Mouse) {
        deviceSource.onInputChangedObservable.add((eventData) => {
          if (eventData.inputIndex === PointerInput.LeftClick || eventData.inputIndex === PointerInput.MiddleClick || eventData.inputIndex === PointerInput.RightClick || eventData.inputIndex === PointerInput.BrowserBack || eventData.inputIndex === PointerInput.BrowserForward) {
            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {
              this._onPointerDown(eventData);
            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {
              this._onPointerUp(eventData);
            }
          } else if (attachMove) {
            if (eventData.inputIndex === PointerInput.Move) {
              this._onPointerMove(eventData);
            } else if (eventData.inputIndex === PointerInput.MouseWheelX || eventData.inputIndex === PointerInput.MouseWheelY || eventData.inputIndex === PointerInput.MouseWheelZ) {
              this._onPointerMove(eventData);
            }
          }
        });
      } else if (deviceSource.deviceType === DeviceType.Touch) {
        deviceSource.onInputChangedObservable.add((eventData) => {
          if (eventData.inputIndex === PointerInput.LeftClick) {
            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {
              this._onPointerDown(eventData);
            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {
              this._onPointerUp(eventData);
            }
          }
          if (attachMove && eventData.inputIndex === PointerInput.Move) {
            this._onPointerMove(eventData);
          }
        });
      } else if (deviceSource.deviceType === DeviceType.Keyboard) {
        deviceSource.onInputChangedObservable.add((eventData) => {
          if (eventData.type === "keydown") {
            this._onKeyDown(eventData);
          } else if (eventData.type === "keyup") {
            this._onKeyUp(eventData);
          }
        });
      }
    });
    this._alreadyAttached = true;
  }
  detachControl() {
    if (this._alreadyAttached) {
      this._deviceSourceManager.dispose();
      this._deviceSourceManager = null;
      if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {
        this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;
      }
      this._alreadyAttached = false;
      this._alreadyAttachedTo = null;
    }
  }
  setPointerOverMesh(mesh, pointerId = 0, pickResult) {
    if (this._meshUnderPointerId[pointerId] === mesh && (!mesh || !mesh._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting)) {
      return;
    }
    const underPointerMesh = this._meshUnderPointerId[pointerId];
    let actionManager;
    if (underPointerMesh) {
      actionManager = underPointerMesh._getActionManagerForTrigger(10);
      if (actionManager) {
        actionManager.processTrigger(10, ActionEvent.CreateNew(underPointerMesh, void 0, { pointerId }));
      }
    }
    if (mesh) {
      this._meshUnderPointerId[pointerId] = mesh;
      this._pointerOverMesh = mesh;
      actionManager = mesh._getActionManagerForTrigger(9);
      if (actionManager) {
        actionManager.processTrigger(9, ActionEvent.CreateNew(mesh, void 0, { pointerId, pickResult }));
      }
    } else {
      delete this._meshUnderPointerId[pointerId];
      this._pointerOverMesh = null;
    }
  }
  getPointerOverMesh() {
    return this.meshUnderPointer;
  }
  _invalidateMesh(mesh) {
    if (this._pointerOverMesh === mesh) {
      this._pointerOverMesh = null;
    }
    if (this._pickedDownMesh === mesh) {
      this._pickedDownMesh = null;
    }
    if (this._pickedUpMesh === mesh) {
      this._pickedUpMesh = null;
    }
    for (const pointerId in this._meshUnderPointerId) {
      if (this._meshUnderPointerId[pointerId] === mesh) {
        delete this._meshUnderPointerId[pointerId];
      }
    }
  }
};
InputManager.DragMovementThreshold = 10;
InputManager.LongPressDelay = 500;
InputManager.DoubleClickDelay = 300;
InputManager.ExclusiveDoubleClickMode = false;

// node_modules/@babylonjs/core/Misc/uniqueIdGenerator.js
var UniqueIdGenerator = class {
  static get UniqueId() {
    const result = this._UniqueIdCounter;
    this._UniqueIdCounter++;
    return result;
  }
};
UniqueIdGenerator._UniqueIdCounter = 1;

// node_modules/@babylonjs/core/Lights/lightConstants.js
var LightConstants = class {
  static CompareLightsPriority(a, b) {
    if (a.shadowEnabled !== b.shadowEnabled) {
      return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);
    }
    return b.renderPriority - a.renderPriority;
  }
};
LightConstants.FALLOFF_DEFAULT = 0;
LightConstants.FALLOFF_PHYSICAL = 1;
LightConstants.FALLOFF_GLTF = 2;
LightConstants.FALLOFF_STANDARD = 3;
LightConstants.LIGHTMAP_DEFAULT = 0;
LightConstants.LIGHTMAP_SPECULAR = 1;
LightConstants.LIGHTMAP_SHADOWSONLY = 2;
LightConstants.INTENSITYMODE_AUTOMATIC = 0;
LightConstants.INTENSITYMODE_LUMINOUSPOWER = 1;
LightConstants.INTENSITYMODE_LUMINOUSINTENSITY = 2;
LightConstants.INTENSITYMODE_ILLUMINANCE = 3;
LightConstants.INTENSITYMODE_LUMINANCE = 4;
LightConstants.LIGHTTYPEID_POINTLIGHT = 0;
LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT = 1;
LightConstants.LIGHTTYPEID_SPOTLIGHT = 2;
LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT = 3;

// node_modules/@babylonjs/core/scene.js
var ScenePerformancePriority;
(function(ScenePerformancePriority2) {
  ScenePerformancePriority2[ScenePerformancePriority2["BackwardCompatible"] = 0] = "BackwardCompatible";
  ScenePerformancePriority2[ScenePerformancePriority2["Intermediate"] = 1] = "Intermediate";
  ScenePerformancePriority2[ScenePerformancePriority2["Aggressive"] = 2] = "Aggressive";
})(ScenePerformancePriority || (ScenePerformancePriority = {}));
var Scene = class extends AbstractScene {
  constructor(engine, options) {
    super();
    this._inputManager = new InputManager(this);
    this.cameraToUseForPointers = null;
    this._isScene = true;
    this._blockEntityCollection = false;
    this.autoClear = true;
    this.autoClearDepthAndStencil = true;
    this.clearColor = new Color4(0.2, 0.2, 0.3, 1);
    this.ambientColor = new Color3(0, 0, 0);
    this.environmentIntensity = 1;
    this._performancePriority = ScenePerformancePriority.BackwardCompatible;
    this._forceWireframe = false;
    this._skipFrustumClipping = false;
    this._forcePointsCloud = false;
    this.animationsEnabled = true;
    this._animationPropertiesOverride = null;
    this.useConstantAnimationDeltaTime = false;
    this.constantlyUpdateMeshUnderPointer = false;
    this.hoverCursor = "pointer";
    this.defaultCursor = "";
    this.doNotHandleCursors = false;
    this.preventDefaultOnPointerDown = true;
    this.preventDefaultOnPointerUp = true;
    this.metadata = null;
    this.reservedDataStore = null;
    this.disableOfflineSupportExceptionRules = new Array();
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this.onBeforeRenderObservable = new Observable();
    this._onBeforeRenderObserver = null;
    this.onAfterRenderObservable = new Observable();
    this.onAfterRenderCameraObservable = new Observable();
    this._onAfterRenderObserver = null;
    this.onBeforeAnimationsObservable = new Observable();
    this.onAfterAnimationsObservable = new Observable();
    this.onBeforeDrawPhaseObservable = new Observable();
    this.onAfterDrawPhaseObservable = new Observable();
    this.onReadyObservable = new Observable();
    this.onBeforeCameraRenderObservable = new Observable();
    this._onBeforeCameraRenderObserver = null;
    this.onAfterCameraRenderObservable = new Observable();
    this._onAfterCameraRenderObserver = null;
    this.onBeforeActiveMeshesEvaluationObservable = new Observable();
    this.onAfterActiveMeshesEvaluationObservable = new Observable();
    this.onBeforeParticlesRenderingObservable = new Observable();
    this.onAfterParticlesRenderingObservable = new Observable();
    this.onDataLoadedObservable = new Observable();
    this.onNewCameraAddedObservable = new Observable();
    this.onCameraRemovedObservable = new Observable();
    this.onNewLightAddedObservable = new Observable();
    this.onLightRemovedObservable = new Observable();
    this.onNewGeometryAddedObservable = new Observable();
    this.onGeometryRemovedObservable = new Observable();
    this.onNewTransformNodeAddedObservable = new Observable();
    this.onTransformNodeRemovedObservable = new Observable();
    this.onNewMeshAddedObservable = new Observable();
    this.onMeshRemovedObservable = new Observable();
    this.onNewSkeletonAddedObservable = new Observable();
    this.onSkeletonRemovedObservable = new Observable();
    this.onNewMaterialAddedObservable = new Observable();
    this.onNewMultiMaterialAddedObservable = new Observable();
    this.onMaterialRemovedObservable = new Observable();
    this.onMultiMaterialRemovedObservable = new Observable();
    this.onNewTextureAddedObservable = new Observable();
    this.onTextureRemovedObservable = new Observable();
    this.onBeforeRenderTargetsRenderObservable = new Observable();
    this.onAfterRenderTargetsRenderObservable = new Observable();
    this.onBeforeStepObservable = new Observable();
    this.onAfterStepObservable = new Observable();
    this.onActiveCameraChanged = new Observable();
    this.onActiveCamerasChanged = new Observable();
    this.onBeforeRenderingGroupObservable = new Observable();
    this.onAfterRenderingGroupObservable = new Observable();
    this.onMeshImportedObservable = new Observable();
    this.onAnimationFileImportedObservable = new Observable();
    this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);
    this.skipPointerMovePicking = false;
    this.skipPointerDownPicking = false;
    this.skipPointerUpPicking = false;
    this.onPrePointerObservable = new Observable();
    this.onPointerObservable = new Observable();
    this.onPreKeyboardObservable = new Observable();
    this.onKeyboardObservable = new Observable();
    this._useRightHandedSystem = false;
    this._timeAccumulator = 0;
    this._currentStepId = 0;
    this._currentInternalStep = 0;
    this._fogEnabled = true;
    this._fogMode = Scene.FOGMODE_NONE;
    this.fogColor = new Color3(0.2, 0.2, 0.3);
    this.fogDensity = 0.1;
    this.fogStart = 0;
    this.fogEnd = 1e3;
    this.needsPreviousWorldMatrices = false;
    this._shadowsEnabled = true;
    this._lightsEnabled = true;
    this._unObserveActiveCameras = null;
    this._texturesEnabled = true;
    this.physicsEnabled = true;
    this.particlesEnabled = true;
    this.spritesEnabled = true;
    this._skeletonsEnabled = true;
    this.lensFlaresEnabled = true;
    this.collisionsEnabled = true;
    this.gravity = new Vector3(0, -9.807, 0);
    this.postProcessesEnabled = true;
    this.renderTargetsEnabled = true;
    this.dumpNextRenderTargets = false;
    this.customRenderTargets = new Array();
    this.importedMeshesFiles = new Array();
    this.probesEnabled = true;
    this._meshesForIntersections = new SmartArrayNoDuplicate(256);
    this.proceduralTexturesEnabled = true;
    this._totalVertices = new PerfCounter();
    this._activeIndices = new PerfCounter();
    this._activeParticles = new PerfCounter();
    this._activeBones = new PerfCounter();
    this._animationTime = 0;
    this.animationTimeScale = 1;
    this._renderId = 0;
    this._frameId = 0;
    this._executeWhenReadyTimeoutId = null;
    this._intermediateRendering = false;
    this._defaultFrameBufferCleared = false;
    this._viewUpdateFlag = -1;
    this._projectionUpdateFlag = -1;
    this._toBeDisposed = new Array(256);
    this._activeRequests = new Array();
    this._pendingData = new Array();
    this._isDisposed = false;
    this.dispatchAllSubMeshesOfActiveMeshes = false;
    this._activeMeshes = new SmartArray(256);
    this._processedMaterials = new SmartArray(256);
    this._renderTargets = new SmartArrayNoDuplicate(256);
    this._materialsRenderTargets = new SmartArrayNoDuplicate(256);
    this._activeParticleSystems = new SmartArray(256);
    this._activeSkeletons = new SmartArrayNoDuplicate(32);
    this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);
    this._activeAnimatables = new Array();
    this._transformMatrix = Matrix.Zero();
    this.requireLightSorting = false;
    this._components = [];
    this._serializableComponents = [];
    this._transientComponents = [];
    this._beforeCameraUpdateStage = Stage.Create();
    this._beforeClearStage = Stage.Create();
    this._beforeRenderTargetClearStage = Stage.Create();
    this._gatherRenderTargetsStage = Stage.Create();
    this._gatherActiveCameraRenderTargetsStage = Stage.Create();
    this._isReadyForMeshStage = Stage.Create();
    this._beforeEvaluateActiveMeshStage = Stage.Create();
    this._evaluateSubMeshStage = Stage.Create();
    this._preActiveMeshStage = Stage.Create();
    this._cameraDrawRenderTargetStage = Stage.Create();
    this._beforeCameraDrawStage = Stage.Create();
    this._beforeRenderTargetDrawStage = Stage.Create();
    this._beforeRenderingGroupDrawStage = Stage.Create();
    this._beforeRenderingMeshStage = Stage.Create();
    this._afterRenderingMeshStage = Stage.Create();
    this._afterRenderingGroupDrawStage = Stage.Create();
    this._afterCameraDrawStage = Stage.Create();
    this._afterCameraPostProcessStage = Stage.Create();
    this._afterRenderTargetDrawStage = Stage.Create();
    this._afterRenderTargetPostProcessStage = Stage.Create();
    this._afterRenderStage = Stage.Create();
    this._pointerMoveStage = Stage.Create();
    this._pointerDownStage = Stage.Create();
    this._pointerUpStage = Stage.Create();
    this._geometriesByUniqueId = null;
    this._defaultMeshCandidates = {
      data: [],
      length: 0
    };
    this._defaultSubMeshCandidates = {
      data: [],
      length: 0
    };
    this._preventFreeActiveMeshesAndRenderingGroups = false;
    this._activeMeshesFrozen = false;
    this._activeMeshesFrozenButKeepClipping = false;
    this._skipEvaluateActiveMeshesCompletely = false;
    this._allowPostProcessClearColor = true;
    this.getDeterministicFrameTime = () => {
      return this._engine.getTimeStep();
    };
    this._registeredActions = 0;
    this._blockMaterialDirtyMechanism = false;
    this._perfCollector = null;
    this.activeCameras = new Array();
    const fullOptions = {
      useGeometryUniqueIdsMap: true,
      useMaterialMeshMap: true,
      useClonedMeshMap: true,
      virtual: false,
      ...options
    };
    this._engine = engine || EngineStore.LastCreatedEngine;
    if (!fullOptions.virtual) {
      EngineStore._LastCreatedScene = this;
      this._engine.scenes.push(this);
    } else {
      this._engine._virtualScenes.push(this);
    }
    this._uid = null;
    this._renderingManager = new RenderingManager(this);
    if (PostProcessManager) {
      this.postProcessManager = new PostProcessManager(this);
    }
    if (IsWindowObjectExist()) {
      this.attachControl();
    }
    this._createUbo();
    if (ImageProcessingConfiguration) {
      this._imageProcessingConfiguration = new ImageProcessingConfiguration();
    }
    this.setDefaultCandidateProviders();
    if (fullOptions.useGeometryUniqueIdsMap) {
      this._geometriesByUniqueId = {};
    }
    this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;
    this.useClonedMeshMap = fullOptions.useClonedMeshMap;
    if (!options || !options.virtual) {
      this._engine.onNewSceneAddedObservable.notifyObservers(this);
    }
  }
  static DefaultMaterialFactory(scene) {
    throw _WarnImport("StandardMaterial");
  }
  static CollisionCoordinatorFactory() {
    throw _WarnImport("DefaultCollisionCoordinator");
  }
  get environmentTexture() {
    return this._environmentTexture;
  }
  set environmentTexture(value) {
    if (this._environmentTexture === value) {
      return;
    }
    this._environmentTexture = value;
    this.markAllMaterialsAsDirty(1);
  }
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  get performancePriority() {
    return this._performancePriority;
  }
  set performancePriority(value) {
    if (value === this._performancePriority) {
      return;
    }
    this._performancePriority = value;
    switch (value) {
      case ScenePerformancePriority.BackwardCompatible:
        this.skipFrustumClipping = false;
        this._renderingManager.maintainStateBetweenFrames = false;
        this.skipPointerMovePicking = false;
        this.autoClear = true;
        break;
      case ScenePerformancePriority.Intermediate:
        this.skipFrustumClipping = false;
        this._renderingManager.maintainStateBetweenFrames = false;
        this.skipPointerMovePicking = true;
        this.autoClear = false;
        break;
      case ScenePerformancePriority.Aggressive:
        this.skipFrustumClipping = true;
        this._renderingManager.maintainStateBetweenFrames = true;
        this.skipPointerMovePicking = true;
        this.autoClear = false;
        break;
    }
  }
  set forceWireframe(value) {
    if (this._forceWireframe === value) {
      return;
    }
    this._forceWireframe = value;
    this.markAllMaterialsAsDirty(16);
  }
  get forceWireframe() {
    return this._forceWireframe;
  }
  set skipFrustumClipping(value) {
    if (this._skipFrustumClipping === value) {
      return;
    }
    this._skipFrustumClipping = value;
  }
  get skipFrustumClipping() {
    return this._skipFrustumClipping;
  }
  set forcePointsCloud(value) {
    if (this._forcePointsCloud === value) {
      return;
    }
    this._forcePointsCloud = value;
    this.markAllMaterialsAsDirty(16);
  }
  get forcePointsCloud() {
    return this._forcePointsCloud;
  }
  get animationPropertiesOverride() {
    return this._animationPropertiesOverride;
  }
  set animationPropertiesOverride(value) {
    this._animationPropertiesOverride = value;
  }
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  set beforeRender(callback) {
    if (this._onBeforeRenderObserver) {
      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
    }
    if (callback) {
      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
    }
  }
  set afterRender(callback) {
    if (this._onAfterRenderObserver) {
      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
    }
    if (callback) {
      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
    }
  }
  set beforeCameraRender(callback) {
    if (this._onBeforeCameraRenderObserver) {
      this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
    }
    this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);
  }
  set afterCameraRender(callback) {
    if (this._onAfterCameraRenderObserver) {
      this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
    }
    this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);
  }
  get unTranslatedPointer() {
    return this._inputManager.unTranslatedPointer;
  }
  static get DragMovementThreshold() {
    return InputManager.DragMovementThreshold;
  }
  static set DragMovementThreshold(value) {
    InputManager.DragMovementThreshold = value;
  }
  static get LongPressDelay() {
    return InputManager.LongPressDelay;
  }
  static set LongPressDelay(value) {
    InputManager.LongPressDelay = value;
  }
  static get DoubleClickDelay() {
    return InputManager.DoubleClickDelay;
  }
  static set DoubleClickDelay(value) {
    InputManager.DoubleClickDelay = value;
  }
  static get ExclusiveDoubleClickMode() {
    return InputManager.ExclusiveDoubleClickMode;
  }
  static set ExclusiveDoubleClickMode(value) {
    InputManager.ExclusiveDoubleClickMode = value;
  }
  bindEyePosition(effect, variableName = "vEyePosition", isVector3 = false) {
    var _a;
    const eyePosition = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : (_a = this.activeCamera.globalPosition) !== null && _a !== void 0 ? _a : this.activeCamera.devicePosition;
    const invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);
    TmpVectors.Vector4[0].set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);
    if (effect) {
      if (isVector3) {
        effect.setFloat3(variableName, TmpVectors.Vector4[0].x, TmpVectors.Vector4[0].y, TmpVectors.Vector4[0].z);
      } else {
        effect.setVector4(variableName, TmpVectors.Vector4[0]);
      }
    }
    return TmpVectors.Vector4[0];
  }
  finalizeSceneUbo() {
    const ubo = this.getSceneUniformBuffer();
    const eyePosition = this.bindEyePosition(null);
    ubo.updateFloat4("vEyePosition", eyePosition.x, eyePosition.y, eyePosition.z, eyePosition.w);
    ubo.update();
    return ubo;
  }
  set useRightHandedSystem(value) {
    if (this._useRightHandedSystem === value) {
      return;
    }
    this._useRightHandedSystem = value;
    this.markAllMaterialsAsDirty(16);
  }
  get useRightHandedSystem() {
    return this._useRightHandedSystem;
  }
  setStepId(newStepId) {
    this._currentStepId = newStepId;
  }
  getStepId() {
    return this._currentStepId;
  }
  getInternalStep() {
    return this._currentInternalStep;
  }
  set fogEnabled(value) {
    if (this._fogEnabled === value) {
      return;
    }
    this._fogEnabled = value;
    this.markAllMaterialsAsDirty(16);
  }
  get fogEnabled() {
    return this._fogEnabled;
  }
  set fogMode(value) {
    if (this._fogMode === value) {
      return;
    }
    this._fogMode = value;
    this.markAllMaterialsAsDirty(16);
  }
  get fogMode() {
    return this._fogMode;
  }
  get prePass() {
    return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;
  }
  set shadowsEnabled(value) {
    if (this._shadowsEnabled === value) {
      return;
    }
    this._shadowsEnabled = value;
    this.markAllMaterialsAsDirty(2);
  }
  get shadowsEnabled() {
    return this._shadowsEnabled;
  }
  set lightsEnabled(value) {
    if (this._lightsEnabled === value) {
      return;
    }
    this._lightsEnabled = value;
    this.markAllMaterialsAsDirty(2);
  }
  get lightsEnabled() {
    return this._lightsEnabled;
  }
  get activeCameras() {
    return this._activeCameras;
  }
  set activeCameras(cameras) {
    if (this._unObserveActiveCameras) {
      this._unObserveActiveCameras();
      this._unObserveActiveCameras = null;
    }
    if (cameras) {
      this._unObserveActiveCameras = _ObserveArray(cameras, () => {
        this.onActiveCamerasChanged.notifyObservers(this);
      });
    }
    this._activeCameras = cameras;
  }
  get activeCamera() {
    return this._activeCamera;
  }
  set activeCamera(value) {
    if (value === this._activeCamera) {
      return;
    }
    this._activeCamera = value;
    this.onActiveCameraChanged.notifyObservers(this);
  }
  get defaultMaterial() {
    if (!this._defaultMaterial) {
      this._defaultMaterial = Scene.DefaultMaterialFactory(this);
    }
    return this._defaultMaterial;
  }
  set defaultMaterial(value) {
    this._defaultMaterial = value;
  }
  set texturesEnabled(value) {
    if (this._texturesEnabled === value) {
      return;
    }
    this._texturesEnabled = value;
    this.markAllMaterialsAsDirty(1);
  }
  get texturesEnabled() {
    return this._texturesEnabled;
  }
  set skeletonsEnabled(value) {
    if (this._skeletonsEnabled === value) {
      return;
    }
    this._skeletonsEnabled = value;
    this.markAllMaterialsAsDirty(8);
  }
  get skeletonsEnabled() {
    return this._skeletonsEnabled;
  }
  get collisionCoordinator() {
    if (!this._collisionCoordinator) {
      this._collisionCoordinator = Scene.CollisionCoordinatorFactory();
      this._collisionCoordinator.init(this);
    }
    return this._collisionCoordinator;
  }
  get renderingManager() {
    return this._renderingManager;
  }
  get frustumPlanes() {
    return this._frustumPlanes;
  }
  _registerTransientComponents() {
    if (this._transientComponents.length > 0) {
      for (const component of this._transientComponents) {
        component.register();
      }
      this._transientComponents.length = 0;
    }
  }
  _addComponent(component) {
    this._components.push(component);
    this._transientComponents.push(component);
    const serializableComponent = component;
    if (serializableComponent.addFromContainer && serializableComponent.serialize) {
      this._serializableComponents.push(serializableComponent);
    }
  }
  _getComponent(name63) {
    for (const component of this._components) {
      if (component.name === name63) {
        return component;
      }
    }
    return null;
  }
  getClassName() {
    return "Scene";
  }
  _getDefaultMeshCandidates() {
    this._defaultMeshCandidates.data = this.meshes;
    this._defaultMeshCandidates.length = this.meshes.length;
    return this._defaultMeshCandidates;
  }
  _getDefaultSubMeshCandidates(mesh) {
    this._defaultSubMeshCandidates.data = mesh.subMeshes;
    this._defaultSubMeshCandidates.length = mesh.subMeshes.length;
    return this._defaultSubMeshCandidates;
  }
  setDefaultCandidateProviders() {
    this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this);
    this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
    this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
    this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
  }
  get meshUnderPointer() {
    return this._inputManager.meshUnderPointer;
  }
  get pointerX() {
    return this._inputManager.pointerX;
  }
  set pointerX(value) {
    this._inputManager.pointerX = value;
  }
  get pointerY() {
    return this._inputManager.pointerY;
  }
  set pointerY(value) {
    this._inputManager.pointerY = value;
  }
  getCachedMaterial() {
    return this._cachedMaterial;
  }
  getCachedEffect() {
    return this._cachedEffect;
  }
  getCachedVisibility() {
    return this._cachedVisibility;
  }
  isCachedMaterialInvalid(material, effect, visibility = 1) {
    return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;
  }
  getEngine() {
    return this._engine;
  }
  getTotalVertices() {
    return this._totalVertices.current;
  }
  get totalVerticesPerfCounter() {
    return this._totalVertices;
  }
  getActiveIndices() {
    return this._activeIndices.current;
  }
  get totalActiveIndicesPerfCounter() {
    return this._activeIndices;
  }
  getActiveParticles() {
    return this._activeParticles.current;
  }
  get activeParticlesPerfCounter() {
    return this._activeParticles;
  }
  getActiveBones() {
    return this._activeBones.current;
  }
  get activeBonesPerfCounter() {
    return this._activeBones;
  }
  getActiveMeshes() {
    return this._activeMeshes;
  }
  getAnimationRatio() {
    return this._animationRatio !== void 0 ? this._animationRatio : 1;
  }
  getRenderId() {
    return this._renderId;
  }
  getFrameId() {
    return this._frameId;
  }
  incrementRenderId() {
    this._renderId++;
  }
  _createUbo() {
    this.setSceneUniformBuffer(this.createSceneUniformBuffer());
  }
  simulatePointerMove(pickResult, pointerEventInit) {
    this._inputManager.simulatePointerMove(pickResult, pointerEventInit);
    return this;
  }
  simulatePointerDown(pickResult, pointerEventInit) {
    this._inputManager.simulatePointerDown(pickResult, pointerEventInit);
    return this;
  }
  simulatePointerUp(pickResult, pointerEventInit, doubleTap) {
    this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);
    return this;
  }
  isPointerCaptured(pointerId = 0) {
    return this._inputManager.isPointerCaptured(pointerId);
  }
  attachControl(attachUp = true, attachDown = true, attachMove = true) {
    this._inputManager.attachControl(attachUp, attachDown, attachMove);
  }
  detachControl() {
    this._inputManager.detachControl();
  }
  isReady(checkRenderTargets = true) {
    if (this._isDisposed) {
      return false;
    }
    let index;
    const engine = this.getEngine();
    let isReady = true;
    if (this._pendingData.length > 0) {
      isReady = false;
    }
    if (checkRenderTargets) {
      this._processedMaterials.reset();
      this._materialsRenderTargets.reset();
    }
    for (index = 0; index < this.meshes.length; index++) {
      const mesh = this.meshes[index];
      if (!mesh.subMeshes || mesh.subMeshes.length === 0) {
        continue;
      }
      if (!mesh.isReady(true)) {
        isReady = false;
        continue;
      }
      const hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === "InstancedMesh" || mesh.getClassName() === "InstancedLinesMesh" || engine.getCaps().instancedArrays && mesh.instances.length > 0;
      for (const step of this._isReadyForMeshStage) {
        if (!step.action(mesh, hardwareInstancedRendering)) {
          isReady = false;
        }
      }
      if (!checkRenderTargets) {
        continue;
      }
      const mat = mesh.material || this.defaultMaterial;
      if (mat) {
        if (mat._storeEffectOnSubMeshes) {
          for (const subMesh of mesh.subMeshes) {
            const material = subMesh.getMaterial();
            if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {
              if (this._processedMaterials.indexOf(material) === -1) {
                this._processedMaterials.push(material);
                this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());
              }
            }
          }
        } else {
          if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {
            if (this._processedMaterials.indexOf(mat) === -1) {
              this._processedMaterials.push(mat);
              this._materialsRenderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures());
            }
          }
        }
      }
    }
    if (!isReady) {
      return false;
    }
    if (!engine.areAllEffectsReady()) {
      return false;
    }
    if (checkRenderTargets) {
      for (index = 0; index < this._materialsRenderTargets.length; ++index) {
        const rtt = this._materialsRenderTargets.data[index];
        if (!rtt.isReadyForRendering()) {
          return false;
        }
      }
    }
    for (index = 0; index < this.geometries.length; index++) {
      const geometry = this.geometries[index];
      if (geometry.delayLoadState === 2) {
        return false;
      }
    }
    if (this.activeCameras && this.activeCameras.length > 0) {
      for (const camera of this.activeCameras) {
        if (!camera.isReady(true)) {
          return false;
        }
      }
    } else if (this.activeCamera) {
      if (!this.activeCamera.isReady(true)) {
        return false;
      }
    }
    for (const particleSystem of this.particleSystems) {
      if (!particleSystem.isReady()) {
        return false;
      }
    }
    return true;
  }
  resetCachedMaterial() {
    this._cachedMaterial = null;
    this._cachedEffect = null;
    this._cachedVisibility = null;
  }
  registerBeforeRender(func) {
    this.onBeforeRenderObservable.add(func);
  }
  unregisterBeforeRender(func) {
    this.onBeforeRenderObservable.removeCallback(func);
  }
  registerAfterRender(func) {
    this.onAfterRenderObservable.add(func);
  }
  unregisterAfterRender(func) {
    this.onAfterRenderObservable.removeCallback(func);
  }
  _executeOnceBeforeRender(func) {
    const execFunc = () => {
      func();
      setTimeout(() => {
        this.unregisterBeforeRender(execFunc);
      });
    };
    this.registerBeforeRender(execFunc);
  }
  executeOnceBeforeRender(func, timeout) {
    if (timeout !== void 0) {
      setTimeout(() => {
        this._executeOnceBeforeRender(func);
      }, timeout);
    } else {
      this._executeOnceBeforeRender(func);
    }
  }
  addPendingData(data) {
    this._pendingData.push(data);
  }
  removePendingData(data) {
    const wasLoading = this.isLoading;
    const index = this._pendingData.indexOf(data);
    if (index !== -1) {
      this._pendingData.splice(index, 1);
    }
    if (wasLoading && !this.isLoading) {
      this.onDataLoadedObservable.notifyObservers(this);
    }
  }
  getWaitingItemsCount() {
    return this._pendingData.length;
  }
  get isLoading() {
    return this._pendingData.length > 0;
  }
  executeWhenReady(func, checkRenderTargets = false) {
    this.onReadyObservable.addOnce(func);
    if (this._executeWhenReadyTimeoutId !== null) {
      return;
    }
    this._checkIsReady(checkRenderTargets);
  }
  whenReadyAsync(checkRenderTargets = false) {
    return new Promise((resolve) => {
      this.executeWhenReady(() => {
        resolve();
      }, checkRenderTargets);
    });
  }
  _checkIsReady(checkRenderTargets = false) {
    this._registerTransientComponents();
    if (this.isReady(checkRenderTargets)) {
      this.onReadyObservable.notifyObservers(this);
      this.onReadyObservable.clear();
      this._executeWhenReadyTimeoutId = null;
      return;
    }
    if (this._isDisposed) {
      this.onReadyObservable.clear();
      this._executeWhenReadyTimeoutId = null;
      return;
    }
    this._executeWhenReadyTimeoutId = setTimeout(() => {
      this.incrementRenderId();
      this._checkIsReady(checkRenderTargets);
    }, 100);
  }
  get animatables() {
    return this._activeAnimatables;
  }
  resetLastAnimationTimeFrame() {
    this._animationTimeLast = PrecisionDate.Now;
  }
  getViewMatrix() {
    return this._viewMatrix;
  }
  getProjectionMatrix() {
    return this._projectionMatrix;
  }
  getTransformMatrix() {
    return this._transformMatrix;
  }
  setTransformMatrix(viewL, projectionL, viewR, projectionR) {
    if (!viewR && !projectionR && this._multiviewSceneUbo) {
      this._multiviewSceneUbo.dispose();
      this._multiviewSceneUbo = null;
    }
    if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {
      return;
    }
    this._viewUpdateFlag = viewL.updateFlag;
    this._projectionUpdateFlag = projectionL.updateFlag;
    this._viewMatrix = viewL;
    this._projectionMatrix = projectionL;
    this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    if (!this._frustumPlanes) {
      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
    } else {
      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
    }
    if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {
      this._updateMultiviewUbo(viewR, projectionR);
    } else if (this._sceneUbo.useUbo) {
      this._sceneUbo.updateMatrix("viewProjection", this._transformMatrix);
      this._sceneUbo.updateMatrix("view", this._viewMatrix);
      this._sceneUbo.updateMatrix("projection", this._projectionMatrix);
    }
  }
  getSceneUniformBuffer() {
    return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;
  }
  createSceneUniformBuffer(name63) {
    const sceneUbo = new UniformBuffer(this._engine, void 0, false, name63 !== null && name63 !== void 0 ? name63 : "scene");
    sceneUbo.addUniform("viewProjection", 16);
    sceneUbo.addUniform("view", 16);
    sceneUbo.addUniform("projection", 16);
    sceneUbo.addUniform("vEyePosition", 4);
    return sceneUbo;
  }
  setSceneUniformBuffer(ubo) {
    this._sceneUbo = ubo;
    this._viewUpdateFlag = -1;
    this._projectionUpdateFlag = -1;
  }
  getUniqueId() {
    return UniqueIdGenerator.UniqueId;
  }
  addMesh(newMesh, recursive = false) {
    if (this._blockEntityCollection) {
      return;
    }
    this.meshes.push(newMesh);
    newMesh._resyncLightSources();
    if (!newMesh.parent) {
      newMesh._addToSceneRootNodes();
    }
    this.onNewMeshAddedObservable.notifyObservers(newMesh);
    if (recursive) {
      newMesh.getChildMeshes().forEach((m) => {
        this.addMesh(m);
      });
    }
  }
  removeMesh(toRemove, recursive = false) {
    const index = this.meshes.indexOf(toRemove);
    if (index !== -1) {
      this.meshes[index] = this.meshes[this.meshes.length - 1];
      this.meshes.pop();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this._inputManager._invalidateMesh(toRemove);
    this.onMeshRemovedObservable.notifyObservers(toRemove);
    if (recursive) {
      toRemove.getChildMeshes().forEach((m) => {
        this.removeMesh(m);
      });
    }
    return index;
  }
  addTransformNode(newTransformNode) {
    if (this._blockEntityCollection) {
      return;
    }
    if (newTransformNode.getScene() === this && newTransformNode._indexInSceneTransformNodesArray !== -1) {
      return;
    }
    newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;
    this.transformNodes.push(newTransformNode);
    if (!newTransformNode.parent) {
      newTransformNode._addToSceneRootNodes();
    }
    this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);
  }
  removeTransformNode(toRemove) {
    const index = toRemove._indexInSceneTransformNodesArray;
    if (index !== -1) {
      if (index !== this.transformNodes.length - 1) {
        const lastNode = this.transformNodes[this.transformNodes.length - 1];
        this.transformNodes[index] = lastNode;
        lastNode._indexInSceneTransformNodesArray = index;
      }
      toRemove._indexInSceneTransformNodesArray = -1;
      this.transformNodes.pop();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this.onTransformNodeRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  removeSkeleton(toRemove) {
    const index = this.skeletons.indexOf(toRemove);
    if (index !== -1) {
      this.skeletons.splice(index, 1);
      this.onSkeletonRemovedObservable.notifyObservers(toRemove);
      this._executeActiveContainerCleanup(this._activeSkeletons);
    }
    return index;
  }
  removeMorphTargetManager(toRemove) {
    const index = this.morphTargetManagers.indexOf(toRemove);
    if (index !== -1) {
      this.morphTargetManagers.splice(index, 1);
    }
    return index;
  }
  removeLight(toRemove) {
    const index = this.lights.indexOf(toRemove);
    if (index !== -1) {
      for (const mesh of this.meshes) {
        mesh._removeLightSource(toRemove, false);
      }
      this.lights.splice(index, 1);
      this.sortLightsByPriority();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this.onLightRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  removeCamera(toRemove) {
    const index = this.cameras.indexOf(toRemove);
    if (index !== -1) {
      this.cameras.splice(index, 1);
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    if (this.activeCameras) {
      const index2 = this.activeCameras.indexOf(toRemove);
      if (index2 !== -1) {
        this.activeCameras.splice(index2, 1);
      }
    }
    if (this.activeCamera === toRemove) {
      if (this.cameras.length > 0) {
        this.activeCamera = this.cameras[0];
      } else {
        this.activeCamera = null;
      }
    }
    this.onCameraRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  removeParticleSystem(toRemove) {
    const index = this.particleSystems.indexOf(toRemove);
    if (index !== -1) {
      this.particleSystems.splice(index, 1);
      this._executeActiveContainerCleanup(this._activeParticleSystems);
    }
    return index;
  }
  removeAnimation(toRemove) {
    const index = this.animations.indexOf(toRemove);
    if (index !== -1) {
      this.animations.splice(index, 1);
    }
    return index;
  }
  stopAnimation(target, animationName, targetMask) {
  }
  removeAnimationGroup(toRemove) {
    const index = this.animationGroups.indexOf(toRemove);
    if (index !== -1) {
      this.animationGroups.splice(index, 1);
    }
    return index;
  }
  removeMultiMaterial(toRemove) {
    const index = this.multiMaterials.indexOf(toRemove);
    if (index !== -1) {
      this.multiMaterials.splice(index, 1);
    }
    this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  removeMaterial(toRemove) {
    const index = toRemove._indexInSceneMaterialArray;
    if (index !== -1 && index < this.materials.length) {
      if (index !== this.materials.length - 1) {
        const lastMaterial = this.materials[this.materials.length - 1];
        this.materials[index] = lastMaterial;
        lastMaterial._indexInSceneMaterialArray = index;
      }
      toRemove._indexInSceneMaterialArray = -1;
      this.materials.pop();
    }
    this.onMaterialRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  removeActionManager(toRemove) {
    const index = this.actionManagers.indexOf(toRemove);
    if (index !== -1) {
      this.actionManagers.splice(index, 1);
    }
    return index;
  }
  removeTexture(toRemove) {
    const index = this.textures.indexOf(toRemove);
    if (index !== -1) {
      this.textures.splice(index, 1);
    }
    this.onTextureRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  addLight(newLight) {
    if (this._blockEntityCollection) {
      return;
    }
    this.lights.push(newLight);
    this.sortLightsByPriority();
    if (!newLight.parent) {
      newLight._addToSceneRootNodes();
    }
    for (const mesh of this.meshes) {
      if (mesh.lightSources.indexOf(newLight) === -1) {
        mesh.lightSources.push(newLight);
        mesh._resyncLightSources();
      }
    }
    this.onNewLightAddedObservable.notifyObservers(newLight);
  }
  sortLightsByPriority() {
    if (this.requireLightSorting) {
      this.lights.sort(LightConstants.CompareLightsPriority);
    }
  }
  addCamera(newCamera) {
    if (this._blockEntityCollection) {
      return;
    }
    this.cameras.push(newCamera);
    this.onNewCameraAddedObservable.notifyObservers(newCamera);
    if (!newCamera.parent) {
      newCamera._addToSceneRootNodes();
    }
  }
  addSkeleton(newSkeleton) {
    if (this._blockEntityCollection) {
      return;
    }
    this.skeletons.push(newSkeleton);
    this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);
  }
  addParticleSystem(newParticleSystem) {
    if (this._blockEntityCollection) {
      return;
    }
    this.particleSystems.push(newParticleSystem);
  }
  addAnimation(newAnimation) {
    if (this._blockEntityCollection) {
      return;
    }
    this.animations.push(newAnimation);
  }
  addAnimationGroup(newAnimationGroup) {
    if (this._blockEntityCollection) {
      return;
    }
    this.animationGroups.push(newAnimationGroup);
  }
  addMultiMaterial(newMultiMaterial) {
    if (this._blockEntityCollection) {
      return;
    }
    this.multiMaterials.push(newMultiMaterial);
    this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);
  }
  addMaterial(newMaterial) {
    if (this._blockEntityCollection) {
      return;
    }
    if (newMaterial.getScene() === this && newMaterial._indexInSceneMaterialArray !== -1) {
      return;
    }
    newMaterial._indexInSceneMaterialArray = this.materials.length;
    this.materials.push(newMaterial);
    this.onNewMaterialAddedObservable.notifyObservers(newMaterial);
  }
  addMorphTargetManager(newMorphTargetManager) {
    if (this._blockEntityCollection) {
      return;
    }
    this.morphTargetManagers.push(newMorphTargetManager);
  }
  addGeometry(newGeometry) {
    if (this._blockEntityCollection) {
      return;
    }
    if (this._geometriesByUniqueId) {
      this._geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;
    }
    this.geometries.push(newGeometry);
  }
  addActionManager(newActionManager) {
    this.actionManagers.push(newActionManager);
  }
  addTexture(newTexture) {
    if (this._blockEntityCollection) {
      return;
    }
    this.textures.push(newTexture);
    this.onNewTextureAddedObservable.notifyObservers(newTexture);
  }
  switchActiveCamera(newCamera, attachControl = true) {
    const canvas = this._engine.getInputElement();
    if (!canvas) {
      return;
    }
    if (this.activeCamera) {
      this.activeCamera.detachControl();
    }
    this.activeCamera = newCamera;
    if (attachControl) {
      newCamera.attachControl();
    }
  }
  setActiveCameraById(id) {
    const camera = this.getCameraById(id);
    if (camera) {
      this.activeCamera = camera;
      return camera;
    }
    return null;
  }
  setActiveCameraByName(name63) {
    const camera = this.getCameraByName(name63);
    if (camera) {
      this.activeCamera = camera;
      return camera;
    }
    return null;
  }
  getAnimationGroupByName(name63) {
    for (let index = 0; index < this.animationGroups.length; index++) {
      if (this.animationGroups[index].name === name63) {
        return this.animationGroups[index];
      }
    }
    return null;
  }
  _getMaterial(allowMultiMaterials, predicate) {
    for (let index = 0; index < this.materials.length; index++) {
      const material = this.materials[index];
      if (predicate(material)) {
        return material;
      }
    }
    if (allowMultiMaterials) {
      for (let index = 0; index < this.multiMaterials.length; index++) {
        const material = this.multiMaterials[index];
        if (predicate(material)) {
          return material;
        }
      }
    }
    return null;
  }
  getMaterialByUniqueID(uniqueId, allowMultiMaterials = false) {
    return this._getMaterial(allowMultiMaterials, (m) => m.uniqueId === uniqueId);
  }
  getMaterialById(id, allowMultiMaterials = false) {
    return this._getMaterial(allowMultiMaterials, (m) => m.id === id);
  }
  getMaterialByName(name63, allowMultiMaterials = false) {
    return this._getMaterial(allowMultiMaterials, (m) => m.name === name63);
  }
  getLastMaterialById(id, allowMultiMaterials = false) {
    for (let index = this.materials.length - 1; index >= 0; index--) {
      if (this.materials[index].id === id) {
        return this.materials[index];
      }
    }
    if (allowMultiMaterials) {
      for (let index = this.multiMaterials.length - 1; index >= 0; index--) {
        if (this.multiMaterials[index].id === id) {
          return this.multiMaterials[index];
        }
      }
    }
    return null;
  }
  getTextureByUniqueId(uniqueId) {
    for (let index = 0; index < this.textures.length; index++) {
      if (this.textures[index].uniqueId === uniqueId) {
        return this.textures[index];
      }
    }
    return null;
  }
  getTextureByName(name63) {
    for (let index = 0; index < this.textures.length; index++) {
      if (this.textures[index].name === name63) {
        return this.textures[index];
      }
    }
    return null;
  }
  getCameraById(id) {
    for (let index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].id === id) {
        return this.cameras[index];
      }
    }
    return null;
  }
  getCameraByUniqueId(uniqueId) {
    for (let index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].uniqueId === uniqueId) {
        return this.cameras[index];
      }
    }
    return null;
  }
  getCameraByName(name63) {
    for (let index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].name === name63) {
        return this.cameras[index];
      }
    }
    return null;
  }
  getBoneById(id) {
    for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
      const skeleton = this.skeletons[skeletonIndex];
      for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
        if (skeleton.bones[boneIndex].id === id) {
          return skeleton.bones[boneIndex];
        }
      }
    }
    return null;
  }
  getBoneByName(name63) {
    for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
      const skeleton = this.skeletons[skeletonIndex];
      for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
        if (skeleton.bones[boneIndex].name === name63) {
          return skeleton.bones[boneIndex];
        }
      }
    }
    return null;
  }
  getLightByName(name63) {
    for (let index = 0; index < this.lights.length; index++) {
      if (this.lights[index].name === name63) {
        return this.lights[index];
      }
    }
    return null;
  }
  getLightById(id) {
    for (let index = 0; index < this.lights.length; index++) {
      if (this.lights[index].id === id) {
        return this.lights[index];
      }
    }
    return null;
  }
  getLightByUniqueId(uniqueId) {
    for (let index = 0; index < this.lights.length; index++) {
      if (this.lights[index].uniqueId === uniqueId) {
        return this.lights[index];
      }
    }
    return null;
  }
  getParticleSystemById(id) {
    for (let index = 0; index < this.particleSystems.length; index++) {
      if (this.particleSystems[index].id === id) {
        return this.particleSystems[index];
      }
    }
    return null;
  }
  getGeometryById(id) {
    for (let index = 0; index < this.geometries.length; index++) {
      if (this.geometries[index].id === id) {
        return this.geometries[index];
      }
    }
    return null;
  }
  _getGeometryByUniqueId(uniqueId) {
    if (this._geometriesByUniqueId) {
      const index = this._geometriesByUniqueId[uniqueId];
      if (index !== void 0) {
        return this.geometries[index];
      }
    } else {
      for (let index = 0; index < this.geometries.length; index++) {
        if (this.geometries[index].uniqueId === uniqueId) {
          return this.geometries[index];
        }
      }
    }
    return null;
  }
  pushGeometry(geometry, force) {
    if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {
      return false;
    }
    this.addGeometry(geometry);
    this.onNewGeometryAddedObservable.notifyObservers(geometry);
    return true;
  }
  removeGeometry(geometry) {
    let index;
    if (this._geometriesByUniqueId) {
      index = this._geometriesByUniqueId[geometry.uniqueId];
      if (index === void 0) {
        return false;
      }
    } else {
      index = this.geometries.indexOf(geometry);
      if (index < 0) {
        return false;
      }
    }
    if (index !== this.geometries.length - 1) {
      const lastGeometry = this.geometries[this.geometries.length - 1];
      if (lastGeometry) {
        this.geometries[index] = lastGeometry;
        if (this._geometriesByUniqueId) {
          this._geometriesByUniqueId[lastGeometry.uniqueId] = index;
        }
      }
    }
    if (this._geometriesByUniqueId) {
      this._geometriesByUniqueId[geometry.uniqueId] = void 0;
    }
    this.geometries.pop();
    this.onGeometryRemovedObservable.notifyObservers(geometry);
    return true;
  }
  getGeometries() {
    return this.geometries;
  }
  getMeshById(id) {
    for (let index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    return null;
  }
  getMeshesById(id) {
    return this.meshes.filter(function(m) {
      return m.id === id;
    });
  }
  getTransformNodeById(id) {
    for (let index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].id === id) {
        return this.transformNodes[index];
      }
    }
    return null;
  }
  getTransformNodeByUniqueId(uniqueId) {
    for (let index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].uniqueId === uniqueId) {
        return this.transformNodes[index];
      }
    }
    return null;
  }
  getTransformNodesById(id) {
    return this.transformNodes.filter(function(m) {
      return m.id === id;
    });
  }
  getMeshByUniqueId(uniqueId) {
    for (let index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].uniqueId === uniqueId) {
        return this.meshes[index];
      }
    }
    return null;
  }
  getLastMeshById(id) {
    for (let index = this.meshes.length - 1; index >= 0; index--) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    return null;
  }
  getLastEntryById(id) {
    let index;
    for (index = this.meshes.length - 1; index >= 0; index--) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    for (index = this.transformNodes.length - 1; index >= 0; index--) {
      if (this.transformNodes[index].id === id) {
        return this.transformNodes[index];
      }
    }
    for (index = this.cameras.length - 1; index >= 0; index--) {
      if (this.cameras[index].id === id) {
        return this.cameras[index];
      }
    }
    for (index = this.lights.length - 1; index >= 0; index--) {
      if (this.lights[index].id === id) {
        return this.lights[index];
      }
    }
    return null;
  }
  getNodeById(id) {
    const mesh = this.getMeshById(id);
    if (mesh) {
      return mesh;
    }
    const transformNode = this.getTransformNodeById(id);
    if (transformNode) {
      return transformNode;
    }
    const light = this.getLightById(id);
    if (light) {
      return light;
    }
    const camera = this.getCameraById(id);
    if (camera) {
      return camera;
    }
    const bone = this.getBoneById(id);
    if (bone) {
      return bone;
    }
    return null;
  }
  getNodeByName(name63) {
    const mesh = this.getMeshByName(name63);
    if (mesh) {
      return mesh;
    }
    const transformNode = this.getTransformNodeByName(name63);
    if (transformNode) {
      return transformNode;
    }
    const light = this.getLightByName(name63);
    if (light) {
      return light;
    }
    const camera = this.getCameraByName(name63);
    if (camera) {
      return camera;
    }
    const bone = this.getBoneByName(name63);
    if (bone) {
      return bone;
    }
    return null;
  }
  getMeshByName(name63) {
    for (let index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].name === name63) {
        return this.meshes[index];
      }
    }
    return null;
  }
  getTransformNodeByName(name63) {
    for (let index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].name === name63) {
        return this.transformNodes[index];
      }
    }
    return null;
  }
  getLastSkeletonById(id) {
    for (let index = this.skeletons.length - 1; index >= 0; index--) {
      if (this.skeletons[index].id === id) {
        return this.skeletons[index];
      }
    }
    return null;
  }
  getSkeletonByUniqueId(uniqueId) {
    for (let index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].uniqueId === uniqueId) {
        return this.skeletons[index];
      }
    }
    return null;
  }
  getSkeletonById(id) {
    for (let index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].id === id) {
        return this.skeletons[index];
      }
    }
    return null;
  }
  getSkeletonByName(name63) {
    for (let index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].name === name63) {
        return this.skeletons[index];
      }
    }
    return null;
  }
  getMorphTargetManagerById(id) {
    for (let index = 0; index < this.morphTargetManagers.length; index++) {
      if (this.morphTargetManagers[index].uniqueId === id) {
        return this.morphTargetManagers[index];
      }
    }
    return null;
  }
  getMorphTargetById(id) {
    for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
      const morphTargetManager = this.morphTargetManagers[managerIndex];
      for (let index = 0; index < morphTargetManager.numTargets; ++index) {
        const target = morphTargetManager.getTarget(index);
        if (target.id === id) {
          return target;
        }
      }
    }
    return null;
  }
  getMorphTargetByName(name63) {
    for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
      const morphTargetManager = this.morphTargetManagers[managerIndex];
      for (let index = 0; index < morphTargetManager.numTargets; ++index) {
        const target = morphTargetManager.getTarget(index);
        if (target.name === name63) {
          return target;
        }
      }
    }
    return null;
  }
  getPostProcessByName(name63) {
    for (let postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {
      const postProcess = this.postProcesses[postProcessIndex];
      if (postProcess.name === name63) {
        return postProcess;
      }
    }
    return null;
  }
  isActiveMesh(mesh) {
    return this._activeMeshes.indexOf(mesh) !== -1;
  }
  get uid() {
    if (!this._uid) {
      this._uid = Tools.RandomId();
    }
    return this._uid;
  }
  addExternalData(key, data) {
    if (!this._externalData) {
      this._externalData = new StringDictionary();
    }
    return this._externalData.add(key, data);
  }
  getExternalData(key) {
    if (!this._externalData) {
      return null;
    }
    return this._externalData.get(key);
  }
  getOrAddExternalDataWithFactory(key, factory) {
    if (!this._externalData) {
      this._externalData = new StringDictionary();
    }
    return this._externalData.getOrAddWithFactory(key, factory);
  }
  removeExternalData(key) {
    return this._externalData.remove(key);
  }
  _evaluateSubMesh(subMesh, mesh, initialMesh, forcePush) {
    if (forcePush || subMesh.isInFrustum(this._frustumPlanes)) {
      for (const step of this._evaluateSubMeshStage) {
        step.action(mesh, subMesh);
      }
      const material = subMesh.getMaterial();
      if (material !== null && material !== void 0) {
        if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {
          if (this._processedMaterials.indexOf(material) === -1) {
            this._processedMaterials.push(material);
            this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());
          }
        }
        this._renderingManager.dispatch(subMesh, mesh, material);
      }
    }
  }
  freeProcessedMaterials() {
    this._processedMaterials.dispose();
  }
  get blockfreeActiveMeshesAndRenderingGroups() {
    return this._preventFreeActiveMeshesAndRenderingGroups;
  }
  set blockfreeActiveMeshesAndRenderingGroups(value) {
    if (this._preventFreeActiveMeshesAndRenderingGroups === value) {
      return;
    }
    if (value) {
      this.freeActiveMeshes();
      this.freeRenderingGroups();
    }
    this._preventFreeActiveMeshesAndRenderingGroups = value;
  }
  freeActiveMeshes() {
    if (this.blockfreeActiveMeshesAndRenderingGroups) {
      return;
    }
    this._activeMeshes.dispose();
    if (this.activeCamera && this.activeCamera._activeMeshes) {
      this.activeCamera._activeMeshes.dispose();
    }
    if (this.activeCameras) {
      for (let i = 0; i < this.activeCameras.length; i++) {
        const activeCamera = this.activeCameras[i];
        if (activeCamera && activeCamera._activeMeshes) {
          activeCamera._activeMeshes.dispose();
        }
      }
    }
  }
  freeRenderingGroups() {
    if (this.blockfreeActiveMeshesAndRenderingGroups) {
      return;
    }
    if (this._renderingManager) {
      this._renderingManager.freeRenderingGroups();
    }
    if (this.textures) {
      for (let i = 0; i < this.textures.length; i++) {
        const texture = this.textures[i];
        if (texture && texture.renderList) {
          texture.freeRenderingGroups();
        }
      }
    }
  }
  _isInIntermediateRendering() {
    return this._intermediateRendering;
  }
  freezeActiveMeshes(skipEvaluateActiveMeshes = false, onSuccess, onError, freezeMeshes = true, keepFrustumCulling = false) {
    this.executeWhenReady(() => {
      if (!this.activeCamera) {
        onError && onError("No active camera found");
        return;
      }
      if (!this._frustumPlanes) {
        this.updateTransformMatrix();
      }
      this._evaluateActiveMeshes();
      this._activeMeshesFrozen = true;
      this._activeMeshesFrozenButKeepClipping = keepFrustumCulling;
      this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;
      if (freezeMeshes) {
        for (let index = 0; index < this._activeMeshes.length; index++) {
          this._activeMeshes.data[index]._freeze();
        }
      }
      onSuccess && onSuccess();
    });
    return this;
  }
  unfreezeActiveMeshes() {
    for (let index = 0; index < this.meshes.length; index++) {
      const mesh = this.meshes[index];
      if (mesh._internalAbstractMeshDataInfo) {
        mesh._internalAbstractMeshDataInfo._isActive = false;
      }
    }
    for (let index = 0; index < this._activeMeshes.length; index++) {
      this._activeMeshes.data[index]._unFreeze();
    }
    this._activeMeshesFrozen = false;
    return this;
  }
  _executeActiveContainerCleanup(container) {
    const isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;
    if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {
      return;
    }
    this.onBeforeRenderObservable.addOnce(() => container.dispose());
  }
  _evaluateActiveMeshes() {
    var _a;
    if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {
      if (this._activeMeshes.length > 0) {
        (_a = this.activeCamera) === null || _a === void 0 ? void 0 : _a._activeMeshes.reset();
        this._activeMeshes.reset();
        this._renderingManager.reset();
        this._processedMaterials.reset();
        this._activeParticleSystems.reset();
        this._activeSkeletons.reset();
        this._softwareSkinnedMeshes.reset();
      }
      return;
    }
    if (this._activeMeshesFrozen && this._activeMeshes.length) {
      if (!this._skipEvaluateActiveMeshesCompletely) {
        const len2 = this._activeMeshes.length;
        for (let i = 0; i < len2; i++) {
          const mesh = this._activeMeshes.data[i];
          mesh.computeWorldMatrix();
        }
      }
      if (this._activeParticleSystems) {
        const psLength = this._activeParticleSystems.length;
        for (let i = 0; i < psLength; i++) {
          this._activeParticleSystems.data[i].animate();
        }
      }
      this._renderingManager.resetSprites();
      return;
    }
    if (!this.activeCamera) {
      return;
    }
    this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);
    this.activeCamera._activeMeshes.reset();
    this._activeMeshes.reset();
    this._renderingManager.reset();
    this._processedMaterials.reset();
    this._activeParticleSystems.reset();
    this._activeSkeletons.reset();
    this._softwareSkinnedMeshes.reset();
    this._materialsRenderTargets.reset();
    for (const step of this._beforeEvaluateActiveMeshStage) {
      step.action();
    }
    const meshes = this.getActiveMeshCandidates();
    const len = meshes.length;
    for (let i = 0; i < len; i++) {
      const mesh = meshes.data[i];
      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;
      if (mesh.isBlocked) {
        continue;
      }
      this._totalVertices.addCount(mesh.getTotalVertices(), false);
      if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.hasAZeroComponent) {
        continue;
      }
      mesh.computeWorldMatrix();
      if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {
        this._meshesForIntersections.pushNoDuplicate(mesh);
      }
      let meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);
      mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;
      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;
      if (meshToRender === void 0 || meshToRender === null) {
        continue;
      }
      if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {
        meshToRender.computeWorldMatrix();
      }
      mesh._preActivate();
      if (mesh.isVisible && mesh.visibility > 0 && (mesh.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {
        this._activeMeshes.push(mesh);
        this.activeCamera._activeMeshes.push(mesh);
        if (meshToRender !== mesh) {
          meshToRender._activate(this._renderId, false);
        }
        for (const step of this._preActiveMeshStage) {
          step.action(mesh);
        }
        if (mesh._activate(this._renderId, false)) {
          if (!mesh.isAnInstance) {
            meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;
          } else {
            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {
              meshToRender = mesh;
            }
          }
          meshToRender._internalAbstractMeshDataInfo._isActive = true;
          this._activeMesh(mesh, meshToRender);
        }
        mesh._postActivate();
      }
    }
    if (this.particlesEnabled) {
      this.onBeforeParticlesRenderingObservable.notifyObservers(this);
      for (let particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {
        const particleSystem = this.particleSystems[particleIndex];
        if (!particleSystem.isStarted() || !particleSystem.emitter) {
          continue;
        }
        const emitter = particleSystem.emitter;
        if (!emitter.position || emitter.isEnabled()) {
          this._activeParticleSystems.push(particleSystem);
          particleSystem.animate();
          this._renderingManager.dispatchParticles(particleSystem);
        }
      }
      this.onAfterParticlesRenderingObservable.notifyObservers(this);
    }
  }
  _activeMesh(sourceMesh, mesh) {
    if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== void 0) {
      if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {
        mesh.skeleton.prepare();
        this._activeBones.addCount(mesh.skeleton.bones.length, false);
      }
      if (!mesh.computeBonesUsingShaders) {
        this._softwareSkinnedMeshes.pushNoDuplicate(mesh);
      }
    }
    let forcePush = sourceMesh.hasInstances || sourceMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh;
    if (mesh && mesh.subMeshes && mesh.subMeshes.length > 0) {
      const subMeshes = this.getActiveSubMeshCandidates(mesh);
      const len = subMeshes.length;
      forcePush = forcePush || len === 1;
      for (let i = 0; i < len; i++) {
        const subMesh = subMeshes.data[i];
        this._evaluateSubMesh(subMesh, mesh, sourceMesh, forcePush);
      }
    }
  }
  updateTransformMatrix(force) {
    if (!this.activeCamera) {
      return;
    }
    if (this.activeCamera._renderingMultiview) {
      const leftCamera = this.activeCamera._rigCameras[0];
      const rightCamera = this.activeCamera._rigCameras[1];
      this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));
    } else {
      this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));
    }
  }
  _bindFrameBuffer(camera, clear = true) {
    if (camera && camera._multiviewTexture) {
      camera._multiviewTexture._bindFrameBuffer();
    } else if (camera && camera.outputRenderTarget) {
      camera.outputRenderTarget._bindFrameBuffer();
    } else {
      if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {
        this._engine.restoreDefaultFramebuffer();
      }
    }
    if (clear) {
      this._clearFrameBuffer(camera);
    }
  }
  _clearFrameBuffer(camera) {
    if (camera && camera._multiviewTexture) {
    } else if (camera && camera.outputRenderTarget && !camera._renderingMultiview) {
      const rtt = camera.outputRenderTarget;
      if (rtt.onClearObservable.hasObservers()) {
        rtt.onClearObservable.notifyObservers(this._engine);
      } else if (!rtt.skipInitialClear) {
        if (this.autoClear) {
          this._engine.clear(rtt.clearColor || this.clearColor, !rtt._cleared, true, true);
        }
        rtt._cleared = true;
      }
    } else {
      if (!this._defaultFrameBufferCleared) {
        this._defaultFrameBufferCleared = true;
        this._clear();
      } else {
        this._engine.clear(null, false, true, true);
      }
    }
  }
  _renderForCamera(camera, rigParent, bindFrameBuffer = true) {
    var _a, _b, _c;
    if (camera && camera._skipRendering) {
      return;
    }
    const engine = this._engine;
    this._activeCamera = camera;
    if (!this.activeCamera) {
      throw new Error("Active camera not set");
    }
    engine.setViewport(this.activeCamera.viewport);
    this.resetCachedMaterial();
    this._renderId++;
    if (!this.prePass && bindFrameBuffer) {
      let skipInitialClear = true;
      if (camera._renderingMultiview && camera.outputRenderTarget) {
        skipInitialClear = camera.outputRenderTarget.skipInitialClear;
        if (this.autoClear) {
          camera.outputRenderTarget.skipInitialClear = false;
        }
      }
      this._bindFrameBuffer(this._activeCamera);
      if (camera._renderingMultiview && camera.outputRenderTarget) {
        camera.outputRenderTarget.skipInitialClear = skipInitialClear;
      }
    }
    this.updateTransformMatrix();
    this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);
    this._evaluateActiveMeshes();
    for (let softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {
      const mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];
      mesh.applySkeleton(mesh.skeleton);
    }
    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
    this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets);
    if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {
      this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);
    }
    if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {
      this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);
    }
    if (this.environmentTexture && this.environmentTexture.isRenderTarget) {
      this._renderTargets.pushNoDuplicate(this.environmentTexture);
    }
    for (const step of this._gatherActiveCameraRenderTargetsStage) {
      step.action(this._renderTargets);
    }
    let needRebind = false;
    if (this.renderTargetsEnabled) {
      this._intermediateRendering = true;
      if (this._renderTargets.length > 0) {
        Tools.StartPerformanceCounter("Render targets", this._renderTargets.length > 0);
        for (let renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {
          const renderTarget = this._renderTargets.data[renderIndex];
          if (renderTarget._shouldRender()) {
            this._renderId++;
            const hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;
            renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);
            needRebind = true;
          }
        }
        Tools.EndPerformanceCounter("Render targets", this._renderTargets.length > 0);
        this._renderId++;
      }
      for (const step of this._cameraDrawRenderTargetStage) {
        needRebind = step.action(this.activeCamera) || needRebind;
      }
      this._intermediateRendering = false;
    }
    this._engine.currentRenderPassId = (_c = (_b = (_a = camera.outputRenderTarget) === null || _a === void 0 ? void 0 : _a.renderPassId) !== null && _b !== void 0 ? _b : camera.renderPassId) !== null && _c !== void 0 ? _c : 0;
    if (needRebind && !this.prePass) {
      this._bindFrameBuffer(this._activeCamera, false);
    }
    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
    if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {
      this.postProcessManager._prepareFrame();
    }
    for (const step of this._beforeCameraDrawStage) {
      step.action(this.activeCamera);
    }
    this.onBeforeDrawPhaseObservable.notifyObservers(this);
    if (engine.snapshotRendering && engine.snapshotRenderingMode === 1) {
      this.finalizeSceneUbo();
    }
    this._renderingManager.render(null, null, true, true);
    this.onAfterDrawPhaseObservable.notifyObservers(this);
    for (const step of this._afterCameraDrawStage) {
      step.action(this.activeCamera);
    }
    if (this.postProcessManager && !camera._multiviewTexture) {
      const texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget : void 0;
      this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);
    }
    for (const step of this._afterCameraPostProcessStage) {
      step.action(this.activeCamera);
    }
    this._renderTargets.reset();
    this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);
  }
  _processSubCameras(camera, bindFrameBuffer = true) {
    if (camera.cameraRigMode === 0 || camera._renderingMultiview) {
      if (camera._renderingMultiview && !this._multiviewSceneUbo) {
        this._createMultiviewUbo();
      }
      this._renderForCamera(camera, void 0, bindFrameBuffer);
      this.onAfterRenderCameraObservable.notifyObservers(camera);
      return;
    }
    if (camera._useMultiviewToSingleView) {
      this._renderMultiviewToSingleView(camera);
    } else {
      this.onBeforeCameraRenderObservable.notifyObservers(camera);
      for (let index = 0; index < camera._rigCameras.length; index++) {
        this._renderForCamera(camera._rigCameras[index], camera);
      }
    }
    this._activeCamera = camera;
    this.updateTransformMatrix();
    this.onAfterRenderCameraObservable.notifyObservers(camera);
  }
  _checkIntersections() {
    for (let index = 0; index < this._meshesForIntersections.length; index++) {
      const sourceMesh = this._meshesForIntersections.data[index];
      if (!sourceMesh.actionManager) {
        continue;
      }
      for (let actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {
        const action = sourceMesh.actionManager.actions[actionIndex];
        if (action.trigger === 12 || action.trigger === 13) {
          const parameters = action.getTriggerParameter();
          const otherMesh = parameters.mesh ? parameters.mesh : parameters;
          const areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);
          const currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);
          if (areIntersecting && currentIntersectionInProgress === -1) {
            if (action.trigger === 12) {
              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh));
              sourceMesh._intersectionsInProgress.push(otherMesh);
            } else if (action.trigger === 13) {
              sourceMesh._intersectionsInProgress.push(otherMesh);
            }
          } else if (!areIntersecting && currentIntersectionInProgress > -1) {
            if (action.trigger === 13) {
              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh));
            }
            if (!sourceMesh.actionManager.hasSpecificTrigger(13, (parameter) => {
              const parameterMesh = parameter.mesh ? parameter.mesh : parameter;
              return otherMesh === parameterMesh;
            }) || action.trigger === 13) {
              sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);
            }
          }
        }
      }
    }
  }
  _advancePhysicsEngineStep(step) {
  }
  _animate() {
  }
  animate() {
    if (this._engine.isDeterministicLockStep()) {
      let deltaTime = Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime)) + this._timeAccumulator;
      const defaultFrameTime = this._engine.getTimeStep();
      const defaultFPS = 1e3 / defaultFrameTime / 1e3;
      let stepsTaken = 0;
      const maxSubSteps = this._engine.getLockstepMaxSteps();
      let internalSteps = Math.floor(deltaTime / defaultFrameTime);
      internalSteps = Math.min(internalSteps, maxSubSteps);
      while (deltaTime > 0 && stepsTaken < internalSteps) {
        this.onBeforeStepObservable.notifyObservers(this);
        this._animationRatio = defaultFrameTime * defaultFPS;
        this._animate();
        this.onAfterAnimationsObservable.notifyObservers(this);
        if (this.physicsEnabled) {
          this._advancePhysicsEngineStep(defaultFrameTime);
        }
        this.onAfterStepObservable.notifyObservers(this);
        this._currentStepId++;
        stepsTaken++;
        deltaTime -= defaultFrameTime;
      }
      this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;
    } else {
      const deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime));
      this._animationRatio = deltaTime * (60 / 1e3);
      this._animate();
      this.onAfterAnimationsObservable.notifyObservers(this);
      if (this.physicsEnabled) {
        this._advancePhysicsEngineStep(deltaTime);
      }
    }
  }
  _clear() {
    if (this.autoClearDepthAndStencil || this.autoClear) {
      this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);
    }
  }
  _checkCameraRenderTarget(camera) {
    var _a;
    if ((camera === null || camera === void 0 ? void 0 : camera.outputRenderTarget) && !(camera === null || camera === void 0 ? void 0 : camera.isRigCamera)) {
      camera.outputRenderTarget._cleared = false;
    }
    if ((_a = camera === null || camera === void 0 ? void 0 : camera.rigCameras) === null || _a === void 0 ? void 0 : _a.length) {
      for (let i = 0; i < camera.rigCameras.length; ++i) {
        const rtt = camera.rigCameras[i].outputRenderTarget;
        if (rtt) {
          rtt._cleared = false;
        }
      }
    }
  }
  resetDrawCache(passId) {
    if (!this.meshes) {
      return;
    }
    for (const mesh of this.meshes) {
      mesh.resetDrawCache(passId);
    }
  }
  render(updateCameras = true, ignoreAnimations = false) {
    var _a, _b, _c;
    if (this.isDisposed) {
      return;
    }
    if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {
      this._checkIsReady();
    }
    this._frameId++;
    this._defaultFrameBufferCleared = false;
    this._checkCameraRenderTarget(this.activeCamera);
    if ((_a = this.activeCameras) === null || _a === void 0 ? void 0 : _a.length) {
      this.activeCameras.forEach(this._checkCameraRenderTarget);
    }
    this._registerTransientComponents();
    this._activeParticles.fetchNewFrame();
    this._totalVertices.fetchNewFrame();
    this._activeIndices.fetchNewFrame();
    this._activeBones.fetchNewFrame();
    this._meshesForIntersections.reset();
    this.resetCachedMaterial();
    this.onBeforeAnimationsObservable.notifyObservers(this);
    if (this.actionManager) {
      this.actionManager.processTrigger(11);
    }
    if (!ignoreAnimations) {
      this.animate();
    }
    for (const step of this._beforeCameraUpdateStage) {
      step.action();
    }
    if (updateCameras) {
      if (this.activeCameras && this.activeCameras.length > 0) {
        for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
          const camera = this.activeCameras[cameraIndex];
          camera.update();
          if (camera.cameraRigMode !== 0) {
            for (let index = 0; index < camera._rigCameras.length; index++) {
              camera._rigCameras[index].update();
            }
          }
        }
      } else if (this.activeCamera) {
        this.activeCamera.update();
        if (this.activeCamera.cameraRigMode !== 0) {
          for (let index = 0; index < this.activeCamera._rigCameras.length; index++) {
            this.activeCamera._rigCameras[index].update();
          }
        }
      }
    }
    this.onBeforeRenderObservable.notifyObservers(this);
    const engine = this.getEngine();
    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
    const currentActiveCamera = ((_b = this.activeCameras) === null || _b === void 0 ? void 0 : _b.length) ? this.activeCameras[0] : this.activeCamera;
    if (this.renderTargetsEnabled) {
      Tools.StartPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
      this._intermediateRendering = true;
      for (let customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {
        const renderTarget = this.customRenderTargets[customIndex];
        if (renderTarget._shouldRender()) {
          this._renderId++;
          this.activeCamera = renderTarget.activeCamera || this.activeCamera;
          if (!this.activeCamera) {
            throw new Error("Active camera not set");
          }
          engine.setViewport(this.activeCamera.viewport);
          this.updateTransformMatrix();
          renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);
        }
      }
      Tools.EndPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
      this._intermediateRendering = false;
      this._renderId++;
    }
    this._engine.currentRenderPassId = (_c = currentActiveCamera === null || currentActiveCamera === void 0 ? void 0 : currentActiveCamera.renderPassId) !== null && _c !== void 0 ? _c : 0;
    this.activeCamera = currentActiveCamera;
    if (this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass) {
      this._bindFrameBuffer(this._activeCamera, false);
    }
    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
    for (const step of this._beforeClearStage) {
      step.action();
    }
    this._clearFrameBuffer(this.activeCamera);
    for (const step of this._gatherRenderTargetsStage) {
      step.action(this._renderTargets);
    }
    if (this.activeCameras && this.activeCameras.length > 0) {
      for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
        this._processSubCameras(this.activeCameras[cameraIndex], cameraIndex > 0);
      }
    } else {
      if (!this.activeCamera) {
        throw new Error("No camera defined");
      }
      this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);
    }
    this._checkIntersections();
    for (const step of this._afterRenderStage) {
      step.action();
    }
    if (this.afterRender) {
      this.afterRender();
    }
    this.onAfterRenderObservable.notifyObservers(this);
    if (this._toBeDisposed.length) {
      for (let index = 0; index < this._toBeDisposed.length; index++) {
        const data = this._toBeDisposed[index];
        if (data) {
          data.dispose();
        }
      }
      this._toBeDisposed.length = 0;
    }
    if (this.dumpNextRenderTargets) {
      this.dumpNextRenderTargets = false;
    }
    this._activeBones.addCount(0, true);
    this._activeIndices.addCount(0, true);
    this._activeParticles.addCount(0, true);
    this._engine.restoreDefaultFramebuffer();
  }
  freezeMaterials() {
    for (let i = 0; i < this.materials.length; i++) {
      this.materials[i].freeze();
    }
  }
  unfreezeMaterials() {
    for (let i = 0; i < this.materials.length; i++) {
      this.materials[i].unfreeze();
    }
  }
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.beforeRender = null;
    this.afterRender = null;
    this.metadata = null;
    this.skeletons.length = 0;
    this.morphTargetManagers.length = 0;
    this._transientComponents.length = 0;
    this._isReadyForMeshStage.clear();
    this._beforeEvaluateActiveMeshStage.clear();
    this._evaluateSubMeshStage.clear();
    this._preActiveMeshStage.clear();
    this._cameraDrawRenderTargetStage.clear();
    this._beforeCameraDrawStage.clear();
    this._beforeRenderTargetDrawStage.clear();
    this._beforeRenderingGroupDrawStage.clear();
    this._beforeRenderingMeshStage.clear();
    this._afterRenderingMeshStage.clear();
    this._afterRenderingGroupDrawStage.clear();
    this._afterCameraDrawStage.clear();
    this._afterRenderTargetDrawStage.clear();
    this._afterRenderStage.clear();
    this._beforeCameraUpdateStage.clear();
    this._beforeClearStage.clear();
    this._gatherRenderTargetsStage.clear();
    this._gatherActiveCameraRenderTargetsStage.clear();
    this._pointerMoveStage.clear();
    this._pointerDownStage.clear();
    this._pointerUpStage.clear();
    this.importedMeshesFiles = new Array();
    if (this.stopAllAnimations) {
      this.stopAllAnimations();
    }
    this.resetCachedMaterial();
    if (this.activeCamera) {
      this.activeCamera._activeMeshes.dispose();
      this.activeCamera = null;
    }
    this.activeCameras = null;
    this._activeMeshes.dispose();
    this._renderingManager.dispose();
    this._processedMaterials.dispose();
    this._activeParticleSystems.dispose();
    this._activeSkeletons.dispose();
    this._softwareSkinnedMeshes.dispose();
    this._renderTargets.dispose();
    this._materialsRenderTargets.dispose();
    this._registeredForLateAnimationBindings.dispose();
    this._meshesForIntersections.dispose();
    this._toBeDisposed.length = 0;
    const activeRequests = this._activeRequests.slice();
    for (const request of activeRequests) {
      request.abort();
    }
    this._activeRequests.length = 0;
    try {
      this.onDisposeObservable.notifyObservers(this);
    } catch (e) {
      console.error("An error occurred while calling onDisposeObservable!", e);
    }
    this.onDisposeObservable.clear();
    this.onBeforeRenderObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onBeforeRenderTargetsRenderObservable.clear();
    this.onAfterRenderTargetsRenderObservable.clear();
    this.onAfterStepObservable.clear();
    this.onBeforeStepObservable.clear();
    this.onBeforeActiveMeshesEvaluationObservable.clear();
    this.onAfterActiveMeshesEvaluationObservable.clear();
    this.onBeforeParticlesRenderingObservable.clear();
    this.onAfterParticlesRenderingObservable.clear();
    this.onBeforeDrawPhaseObservable.clear();
    this.onAfterDrawPhaseObservable.clear();
    this.onBeforeAnimationsObservable.clear();
    this.onAfterAnimationsObservable.clear();
    this.onDataLoadedObservable.clear();
    this.onBeforeRenderingGroupObservable.clear();
    this.onAfterRenderingGroupObservable.clear();
    this.onMeshImportedObservable.clear();
    this.onBeforeCameraRenderObservable.clear();
    this.onAfterCameraRenderObservable.clear();
    this.onReadyObservable.clear();
    this.onNewCameraAddedObservable.clear();
    this.onCameraRemovedObservable.clear();
    this.onNewLightAddedObservable.clear();
    this.onLightRemovedObservable.clear();
    this.onNewGeometryAddedObservable.clear();
    this.onGeometryRemovedObservable.clear();
    this.onNewTransformNodeAddedObservable.clear();
    this.onTransformNodeRemovedObservable.clear();
    this.onNewMeshAddedObservable.clear();
    this.onMeshRemovedObservable.clear();
    this.onNewSkeletonAddedObservable.clear();
    this.onSkeletonRemovedObservable.clear();
    this.onNewMaterialAddedObservable.clear();
    this.onNewMultiMaterialAddedObservable.clear();
    this.onMaterialRemovedObservable.clear();
    this.onMultiMaterialRemovedObservable.clear();
    this.onNewTextureAddedObservable.clear();
    this.onTextureRemovedObservable.clear();
    this.onPrePointerObservable.clear();
    this.onPointerObservable.clear();
    this.onPreKeyboardObservable.clear();
    this.onKeyboardObservable.clear();
    this.onActiveCameraChanged.clear();
    this.detachControl();
    const canvas = this._engine.getInputElement();
    if (canvas) {
      for (let index2 = 0; index2 < this.cameras.length; index2++) {
        this.cameras[index2].detachControl();
      }
    }
    this._disposeList(this.animationGroups);
    this._disposeList(this.lights);
    this._disposeList(this.meshes, (item) => item.dispose(true));
    this._disposeList(this.transformNodes, (item) => item.dispose(true));
    const cameras = this.cameras;
    this._disposeList(cameras);
    if (this._defaultMaterial) {
      this._defaultMaterial.dispose();
    }
    this._disposeList(this.multiMaterials);
    this._disposeList(this.materials);
    this._disposeList(this.particleSystems);
    this._disposeList(this.postProcesses);
    this._disposeList(this.textures);
    this._disposeList(this.morphTargetManagers);
    this._sceneUbo.dispose();
    if (this._multiviewSceneUbo) {
      this._multiviewSceneUbo.dispose();
    }
    this.postProcessManager.dispose();
    this._disposeList(this._components);
    let index = this._engine.scenes.indexOf(this);
    if (index > -1) {
      this._engine.scenes.splice(index, 1);
    }
    if (EngineStore._LastCreatedScene === this) {
      if (this._engine.scenes.length > 0) {
        EngineStore._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1];
      } else {
        EngineStore._LastCreatedScene = null;
      }
    }
    index = this._engine._virtualScenes.indexOf(this);
    if (index > -1) {
      this._engine._virtualScenes.splice(index, 1);
    }
    this._engine.wipeCaches(true);
    this._isDisposed = true;
  }
  _disposeList(items, callback) {
    const itemsCopy = items.slice(0);
    callback = callback !== null && callback !== void 0 ? callback : (item) => item.dispose();
    for (const item of itemsCopy) {
      callback(item);
    }
    items.length = 0;
  }
  get isDisposed() {
    return this._isDisposed;
  }
  clearCachedVertexData() {
    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
      const mesh = this.meshes[meshIndex];
      const geometry = mesh.geometry;
      if (geometry) {
        geometry.clearCachedData();
      }
    }
  }
  cleanCachedTextureBuffer() {
    for (const baseTexture of this.textures) {
      const buffer = baseTexture._buffer;
      if (buffer) {
        baseTexture._buffer = null;
      }
    }
  }
  getWorldExtends(filterPredicate) {
    const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    filterPredicate = filterPredicate || (() => true);
    this.meshes.filter(filterPredicate).forEach((mesh) => {
      mesh.computeWorldMatrix(true);
      if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {
        return;
      }
      const boundingInfo = mesh.getBoundingInfo();
      const minBox = boundingInfo.boundingBox.minimumWorld;
      const maxBox = boundingInfo.boundingBox.maximumWorld;
      Vector3.CheckExtends(minBox, min, max);
      Vector3.CheckExtends(maxBox, min, max);
    });
    return {
      min,
      max
    };
  }
  createPickingRay(x, y, world, camera, cameraViewSpace = false) {
    throw _WarnImport("Ray");
  }
  createPickingRayToRef(x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {
    throw _WarnImport("Ray");
  }
  createPickingRayInCameraSpace(x, y, camera) {
    throw _WarnImport("Ray");
  }
  createPickingRayInCameraSpaceToRef(x, y, result, camera) {
    throw _WarnImport("Ray");
  }
  get _pickingAvailable() {
    return false;
  }
  pick(x, y, predicate, fastCheck, camera, trianglePredicate) {
    return new PickingInfo();
  }
  pickWithBoundingInfo(x, y, predicate, fastCheck, camera) {
    return new PickingInfo();
  }
  pickWithRay(ray, predicate, fastCheck, trianglePredicate) {
    throw _WarnImport("Ray");
  }
  multiPick(x, y, predicate, camera, trianglePredicate) {
    throw _WarnImport("Ray");
  }
  multiPickWithRay(ray, predicate, trianglePredicate) {
    throw _WarnImport("Ray");
  }
  setPointerOverMesh(mesh, pointerId, pickResult) {
    this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);
  }
  getPointerOverMesh() {
    return this._inputManager.getPointerOverMesh();
  }
  _rebuildGeometries() {
    for (const geometry of this.geometries) {
      geometry._rebuild();
    }
    for (const mesh of this.meshes) {
      mesh._rebuild();
    }
    if (this.postProcessManager) {
      this.postProcessManager._rebuild();
    }
    for (const component of this._components) {
      component.rebuild();
    }
    for (const system of this.particleSystems) {
      system.rebuild();
    }
    if (this.spriteManagers) {
      for (const spriteMgr of this.spriteManagers) {
        spriteMgr.rebuild();
      }
    }
  }
  _rebuildTextures() {
    for (const texture of this.textures) {
      texture._rebuild();
    }
    this.markAllMaterialsAsDirty(1);
  }
  _getByTags(list, tagsQuery, forEach) {
    if (tagsQuery === void 0) {
      return list;
    }
    const listByTags = [];
    forEach = forEach || ((item) => {
      return;
    });
    for (const i in list) {
      const item = list[i];
      if (Tags && Tags.MatchesQuery(item, tagsQuery)) {
        listByTags.push(item);
        forEach(item);
      }
    }
    return listByTags;
  }
  getMeshesByTags(tagsQuery, forEach) {
    return this._getByTags(this.meshes, tagsQuery, forEach);
  }
  getCamerasByTags(tagsQuery, forEach) {
    return this._getByTags(this.cameras, tagsQuery, forEach);
  }
  getLightsByTags(tagsQuery, forEach) {
    return this._getByTags(this.lights, tagsQuery, forEach);
  }
  getMaterialByTags(tagsQuery, forEach) {
    return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));
  }
  getTransformNodesByTags(tagsQuery, forEach) {
    return this._getByTags(this.transformNodes, tagsQuery, forEach);
  }
  setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
  }
  setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth = true, stencil = true) {
    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);
  }
  getAutoClearDepthStencilSetup(index) {
    return this._renderingManager.getAutoClearDepthStencilSetup(index);
  }
  get blockMaterialDirtyMechanism() {
    return this._blockMaterialDirtyMechanism;
  }
  set blockMaterialDirtyMechanism(value) {
    if (this._blockMaterialDirtyMechanism === value) {
      return;
    }
    this._blockMaterialDirtyMechanism = value;
    if (!value) {
      this.markAllMaterialsAsDirty(63);
    }
  }
  markAllMaterialsAsDirty(flag, predicate) {
    if (this._blockMaterialDirtyMechanism) {
      return;
    }
    for (const material of this.materials) {
      if (predicate && !predicate(material)) {
        continue;
      }
      material.markAsDirty(flag);
    }
  }
  _loadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {
    const request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError, onOpened);
    this._activeRequests.push(request);
    request.onCompleteObservable.add((request2) => {
      this._activeRequests.splice(this._activeRequests.indexOf(request2), 1);
    });
    return request;
  }
  _loadFileAsync(fileOrUrl, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {
    return new Promise((resolve, reject) => {
      this._loadFile(fileOrUrl, (data) => {
        resolve(data);
      }, onProgress, useOfflineSupport, useArrayBuffer, (request, exception) => {
        reject(exception);
      }, onOpened);
    });
  }
  _requestFile(url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {
    const request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError, onOpened);
    this._activeRequests.push(request);
    request.onCompleteObservable.add((request2) => {
      this._activeRequests.splice(this._activeRequests.indexOf(request2), 1);
    });
    return request;
  }
  _requestFileAsync(url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {
    return new Promise((resolve, reject) => {
      this._requestFile(url, (data) => {
        resolve(data);
      }, onProgress, useOfflineSupport, useArrayBuffer, (error) => {
        reject(error);
      }, onOpened);
    });
  }
  _readFile(file, onSuccess, onProgress, useArrayBuffer, onError) {
    const request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);
    this._activeRequests.push(request);
    request.onCompleteObservable.add((request2) => {
      this._activeRequests.splice(this._activeRequests.indexOf(request2), 1);
    });
    return request;
  }
  _readFileAsync(file, onProgress, useArrayBuffer) {
    return new Promise((resolve, reject) => {
      this._readFile(file, (data) => {
        resolve(data);
      }, onProgress, useArrayBuffer, (error) => {
        reject(error);
      });
    });
  }
  getPerfCollector() {
    throw _WarnImport("performanceViewerSceneExtension");
  }
};
Scene.FOGMODE_NONE = 0;
Scene.FOGMODE_EXP = 1;
Scene.FOGMODE_EXP2 = 2;
Scene.FOGMODE_LINEAR = 3;
Scene.MinDeltaTime = 1;
Scene.MaxDeltaTime = 1e3;
Scene.prototype.setActiveCameraByID = function(id) {
  return this.setActiveCameraById(id);
};
Scene.prototype.getLastMaterialByID = function(id) {
  return this.getLastMaterialById(id);
};
Scene.prototype.getMaterialByID = function(id) {
  return this.getMaterialById(id);
};
Scene.prototype.getTextureByUniqueID = function(uniqueId) {
  return this.getTextureByUniqueId(uniqueId);
};
Scene.prototype.getCameraByID = function(id) {
  return this.getCameraById(id);
};
Scene.prototype.getCameraByUniqueID = function(uniqueId) {
  return this.getCameraByUniqueId(uniqueId);
};
Scene.prototype.getBoneByID = function(id) {
  return this.getBoneById(id);
};
Scene.prototype.getLightByID = function(id) {
  return this.getLightById(id);
};
Scene.prototype.getLightByUniqueID = function(uniqueId) {
  return this.getLightByUniqueId(uniqueId);
};
Scene.prototype.getParticleSystemByID = function(id) {
  return this.getParticleSystemById(id);
};
Scene.prototype.getGeometryByID = function(id) {
  return this.getGeometryById(id);
};
Scene.prototype.getMeshByID = function(id) {
  return this.getMeshById(id);
};
Scene.prototype.getMeshesByID = function(id) {
  return this.getMeshesById(id);
};
Scene.prototype.getTransformNodeByID = function(id) {
  return this.getTransformNodeById(id);
};
Scene.prototype.getTransformNodeByUniqueID = function(uniqueId) {
  return this.getTransformNodeByUniqueId(uniqueId);
};
Scene.prototype.getTransformNodesByID = function(id) {
  return this.getTransformNodesById(id);
};
Scene.prototype.getMeshByUniqueID = function(uniqueId) {
  return this.getMeshByUniqueId(uniqueId);
};
Scene.prototype.getLastMeshByID = function(id) {
  return this.getLastMeshById(id);
};
Scene.prototype.getLastEntryByID = function(id) {
  return this.getLastEntryById(id);
};
Scene.prototype.getNodeByID = function(id) {
  return this.getNodeById(id);
};
Scene.prototype.getLastSkeletonByID = function(id) {
  return this.getLastSkeletonById(id);
};

// node_modules/@babylonjs/core/Maths/math.axis.js
var Space;
(function(Space2) {
  Space2[Space2["LOCAL"] = 0] = "LOCAL";
  Space2[Space2["WORLD"] = 1] = "WORLD";
  Space2[Space2["BONE"] = 2] = "BONE";
})(Space || (Space = {}));
var Axis = class {
};
Axis.X = new Vector3(1, 0, 0);
Axis.Y = new Vector3(0, 1, 0);
Axis.Z = new Vector3(0, 0, 1);
var Coordinate;
(function(Coordinate2) {
  Coordinate2[Coordinate2["X"] = 0] = "X";
  Coordinate2[Coordinate2["Y"] = 1] = "Y";
  Coordinate2[Coordinate2["Z"] = 2] = "Z";
})(Coordinate || (Coordinate = {}));

// node_modules/@babylonjs/core/Maths/math.path.js
var Orientation;
(function(Orientation2) {
  Orientation2[Orientation2["CW"] = 0] = "CW";
  Orientation2[Orientation2["CCW"] = 1] = "CCW";
})(Orientation || (Orientation = {}));
var BezierCurve = class {
  static Interpolate(t, x1, y1, x2, y2) {
    const f0 = 1 - 3 * x2 + 3 * x1;
    const f1 = 3 * x2 - 6 * x1;
    const f2 = 3 * x1;
    let refinedT = t;
    for (let i = 0; i < 5; i++) {
      const refinedT2 = refinedT * refinedT;
      const refinedT3 = refinedT2 * refinedT;
      const x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;
      const slope = 1 / (3 * f0 * refinedT2 + 2 * f1 * refinedT + f2);
      refinedT -= (x - t) * slope;
      refinedT = Math.min(1, Math.max(0, refinedT));
    }
    return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);
  }
};
var Angle = class {
  constructor(radians) {
    this._radians = radians;
    if (this._radians < 0) {
      this._radians += 2 * Math.PI;
    }
  }
  degrees() {
    return this._radians * 180 / Math.PI;
  }
  radians() {
    return this._radians;
  }
  static BetweenTwoPoints(a, b) {
    const delta = b.subtract(a);
    const theta = Math.atan2(delta.y, delta.x);
    return new Angle(theta);
  }
  static FromRadians(radians) {
    return new Angle(radians);
  }
  static FromDegrees(degrees) {
    return new Angle(degrees * Math.PI / 180);
  }
};
var Arc2 = class {
  constructor(startPoint, midPoint, endPoint) {
    this.startPoint = startPoint;
    this.midPoint = midPoint;
    this.endPoint = endPoint;
    const temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);
    const startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;
    const midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;
    const det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);
    this.centerPoint = new Vector2((startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det, ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det);
    this.radius = this.centerPoint.subtract(this.startPoint).length();
    this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);
    const a1 = this.startAngle.degrees();
    let a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();
    let a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();
    if (a2 - a1 > 180) {
      a2 -= 360;
    }
    if (a2 - a1 < -180) {
      a2 += 360;
    }
    if (a3 - a2 > 180) {
      a3 -= 360;
    }
    if (a3 - a2 < -180) {
      a3 += 360;
    }
    this.orientation = a2 - a1 < 0 ? Orientation.CW : Orientation.CCW;
    this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);
  }
};
var Path2 = class {
  constructor(x, y) {
    this._points = new Array();
    this._length = 0;
    this.closed = false;
    this._points.push(new Vector2(x, y));
  }
  addLineTo(x, y) {
    if (this.closed) {
      return this;
    }
    const newPoint = new Vector2(x, y);
    const previousPoint = this._points[this._points.length - 1];
    this._points.push(newPoint);
    this._length += newPoint.subtract(previousPoint).length();
    return this;
  }
  addArcTo(midX, midY, endX, endY, numberOfSegments = 36) {
    if (this.closed) {
      return this;
    }
    const startPoint = this._points[this._points.length - 1];
    const midPoint = new Vector2(midX, midY);
    const endPoint = new Vector2(endX, endY);
    const arc = new Arc2(startPoint, midPoint, endPoint);
    let increment = arc.angle.radians() / numberOfSegments;
    if (arc.orientation === Orientation.CW) {
      increment *= -1;
    }
    let currentAngle = arc.startAngle.radians() + increment;
    for (let i = 0; i < numberOfSegments; i++) {
      const x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;
      const y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;
      this.addLineTo(x, y);
      currentAngle += increment;
    }
    return this;
  }
  close() {
    this.closed = true;
    return this;
  }
  length() {
    let result = this._length;
    if (this.closed) {
      const lastPoint = this._points[this._points.length - 1];
      const firstPoint = this._points[0];
      result += firstPoint.subtract(lastPoint).length();
    }
    return result;
  }
  getPoints() {
    return this._points;
  }
  getPointAtLengthPosition(normalizedLengthPosition) {
    if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {
      return Vector2.Zero();
    }
    const lengthPosition = normalizedLengthPosition * this.length();
    let previousOffset = 0;
    for (let i = 0; i < this._points.length; i++) {
      const j = (i + 1) % this._points.length;
      const a = this._points[i];
      const b = this._points[j];
      const bToA = b.subtract(a);
      const nextOffset = bToA.length() + previousOffset;
      if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {
        const dir = bToA.normalize();
        const localOffset = lengthPosition - previousOffset;
        return new Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);
      }
      previousOffset = nextOffset;
    }
    return Vector2.Zero();
  }
  static StartingAt(x, y) {
    return new Path2(x, y);
  }
};
var Path3D = class {
  constructor(path, firstNormal = null, raw, alignTangentsWithPath = false) {
    this.path = path;
    this._curve = new Array();
    this._distances = new Array();
    this._tangents = new Array();
    this._normals = new Array();
    this._binormals = new Array();
    this._pointAtData = {
      id: 0,
      point: Vector3.Zero(),
      previousPointArrayIndex: 0,
      position: 0,
      subPosition: 0,
      interpolateReady: false,
      interpolationMatrix: Matrix.Identity()
    };
    for (let p = 0; p < path.length; p++) {
      this._curve[p] = path[p].clone();
    }
    this._raw = raw || false;
    this._alignTangentsWithPath = alignTangentsWithPath;
    this._compute(firstNormal, alignTangentsWithPath);
  }
  getCurve() {
    return this._curve;
  }
  getPoints() {
    return this._curve;
  }
  length() {
    return this._distances[this._distances.length - 1];
  }
  getTangents() {
    return this._tangents;
  }
  getNormals() {
    return this._normals;
  }
  getBinormals() {
    return this._binormals;
  }
  getDistances() {
    return this._distances;
  }
  getPointAt(position) {
    return this._updatePointAtData(position).point;
  }
  getTangentAt(position, interpolated = false) {
    this._updatePointAtData(position, interpolated);
    return interpolated ? Vector3.TransformCoordinates(Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];
  }
  getNormalAt(position, interpolated = false) {
    this._updatePointAtData(position, interpolated);
    return interpolated ? Vector3.TransformCoordinates(Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];
  }
  getBinormalAt(position, interpolated = false) {
    this._updatePointAtData(position, interpolated);
    return interpolated ? Vector3.TransformCoordinates(Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];
  }
  getDistanceAt(position) {
    return this.length() * position;
  }
  getPreviousPointIndexAt(position) {
    this._updatePointAtData(position);
    return this._pointAtData.previousPointArrayIndex;
  }
  getSubPositionAt(position) {
    this._updatePointAtData(position);
    return this._pointAtData.subPosition;
  }
  getClosestPositionTo(target) {
    let smallestDistance = Number.MAX_VALUE;
    let closestPosition = 0;
    for (let i = 0; i < this._curve.length - 1; i++) {
      const point = this._curve[i + 0];
      const tangent = this._curve[i + 1].subtract(point).normalize();
      const subLength = this._distances[i + 1] - this._distances[i + 0];
      const subPosition = Math.min(Math.max(Vector3.Dot(tangent, target.subtract(point).normalize()), 0) * Vector3.Distance(point, target) / subLength, 1);
      const distance = Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);
      if (distance < smallestDistance) {
        smallestDistance = distance;
        closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();
      }
    }
    return closestPosition;
  }
  slice(start = 0, end = 1) {
    if (start < 0) {
      start = 1 - start * -1 % 1;
    }
    if (end < 0) {
      end = 1 - end * -1 % 1;
    }
    if (start > end) {
      const _start = start;
      start = end;
      end = _start;
    }
    const curvePoints = this.getCurve();
    const startPoint = this.getPointAt(start);
    let startIndex = this.getPreviousPointIndexAt(start);
    const endPoint = this.getPointAt(end);
    const endIndex = this.getPreviousPointIndexAt(end) + 1;
    const slicePoints = [];
    if (start !== 0) {
      startIndex++;
      slicePoints.push(startPoint);
    }
    slicePoints.push(...curvePoints.slice(startIndex, endIndex));
    if (end !== 1 || start === 1) {
      slicePoints.push(endPoint);
    }
    return new Path3D(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);
  }
  update(path, firstNormal = null, alignTangentsWithPath = false) {
    for (let p = 0; p < path.length; p++) {
      this._curve[p].x = path[p].x;
      this._curve[p].y = path[p].y;
      this._curve[p].z = path[p].z;
    }
    this._compute(firstNormal, alignTangentsWithPath);
    return this;
  }
  _compute(firstNormal, alignTangentsWithPath = false) {
    const l = this._curve.length;
    if (l < 2) {
      return;
    }
    this._tangents[0] = this._getFirstNonNullVector(0);
    if (!this._raw) {
      this._tangents[0].normalize();
    }
    this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);
    if (!this._raw) {
      this._tangents[l - 1].normalize();
    }
    const tg0 = this._tangents[0];
    const pp0 = this._normalVector(tg0, firstNormal);
    this._normals[0] = pp0;
    if (!this._raw) {
      this._normals[0].normalize();
    }
    this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);
    if (!this._raw) {
      this._binormals[0].normalize();
    }
    this._distances[0] = 0;
    let prev;
    let cur;
    let curTang;
    let prevNor;
    let prevBinor;
    for (let i = 1; i < l; i++) {
      prev = this._getLastNonNullVector(i);
      if (i < l - 1) {
        cur = this._getFirstNonNullVector(i);
        this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);
        this._tangents[i].normalize();
      }
      this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length();
      curTang = this._tangents[i];
      prevBinor = this._binormals[i - 1];
      this._normals[i] = Vector3.Cross(prevBinor, curTang);
      if (!this._raw) {
        if (this._normals[i].length() === 0) {
          prevNor = this._normals[i - 1];
          this._normals[i] = prevNor.clone();
        } else {
          this._normals[i].normalize();
        }
      }
      this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);
      if (!this._raw) {
        this._binormals[i].normalize();
      }
    }
    this._pointAtData.id = NaN;
  }
  _getFirstNonNullVector(index) {
    let i = 1;
    let nNVector = this._curve[index + i].subtract(this._curve[index]);
    while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {
      i++;
      nNVector = this._curve[index + i].subtract(this._curve[index]);
    }
    return nNVector;
  }
  _getLastNonNullVector(index) {
    let i = 1;
    let nLVector = this._curve[index].subtract(this._curve[index - i]);
    while (nLVector.length() === 0 && index > i + 1) {
      i++;
      nLVector = this._curve[index].subtract(this._curve[index - i]);
    }
    return nLVector;
  }
  _normalVector(vt, va) {
    let normal0;
    let tgl = vt.length();
    if (tgl === 0) {
      tgl = 1;
    }
    if (va === void 0 || va === null) {
      let point;
      if (!Scalar.WithinEpsilon(Math.abs(vt.y) / tgl, 1, Epsilon)) {
        point = new Vector3(0, -1, 0);
      } else if (!Scalar.WithinEpsilon(Math.abs(vt.x) / tgl, 1, Epsilon)) {
        point = new Vector3(1, 0, 0);
      } else if (!Scalar.WithinEpsilon(Math.abs(vt.z) / tgl, 1, Epsilon)) {
        point = new Vector3(0, 0, 1);
      } else {
        point = Vector3.Zero();
      }
      normal0 = Vector3.Cross(vt, point);
    } else {
      normal0 = Vector3.Cross(vt, va);
      Vector3.CrossToRef(normal0, vt, normal0);
    }
    normal0.normalize();
    return normal0;
  }
  _updatePointAtData(position, interpolateTNB = false) {
    if (this._pointAtData.id === position) {
      if (!this._pointAtData.interpolateReady) {
        this._updateInterpolationMatrix();
      }
      return this._pointAtData;
    } else {
      this._pointAtData.id = position;
    }
    const curvePoints = this.getPoints();
    if (position <= 0) {
      return this._setPointAtData(0, 0, curvePoints[0], 0, interpolateTNB);
    } else if (position >= 1) {
      return this._setPointAtData(1, 1, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);
    }
    let previousPoint = curvePoints[0];
    let currentPoint;
    let currentLength = 0;
    const targetLength = position * this.length();
    for (let i = 1; i < curvePoints.length; i++) {
      currentPoint = curvePoints[i];
      const distance = Vector3.Distance(previousPoint, currentPoint);
      currentLength += distance;
      if (currentLength === targetLength) {
        return this._setPointAtData(position, 1, currentPoint, i, interpolateTNB);
      } else if (currentLength > targetLength) {
        const toLength = currentLength - targetLength;
        const diff = toLength / distance;
        const dir = previousPoint.subtract(currentPoint);
        const point = currentPoint.add(dir.scaleInPlace(diff));
        return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);
      }
      previousPoint = currentPoint;
    }
    return this._pointAtData;
  }
  _setPointAtData(position, subPosition, point, parentIndex, interpolateTNB) {
    this._pointAtData.point = point;
    this._pointAtData.position = position;
    this._pointAtData.subPosition = subPosition;
    this._pointAtData.previousPointArrayIndex = parentIndex;
    this._pointAtData.interpolateReady = interpolateTNB;
    if (interpolateTNB) {
      this._updateInterpolationMatrix();
    }
    return this._pointAtData;
  }
  _updateInterpolationMatrix() {
    this._pointAtData.interpolationMatrix = Matrix.Identity();
    const parentIndex = this._pointAtData.previousPointArrayIndex;
    if (parentIndex !== this._tangents.length - 1) {
      const index = parentIndex + 1;
      const tangentFrom = this._tangents[parentIndex].clone();
      const normalFrom = this._normals[parentIndex].clone();
      const binormalFrom = this._binormals[parentIndex].clone();
      const tangentTo = this._tangents[index].clone();
      const normalTo = this._normals[index].clone();
      const binormalTo = this._binormals[index].clone();
      const quatFrom = Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);
      const quatTo = Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);
      const quatAt = Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);
      quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);
    }
  }
};
var Curve3 = class {
  constructor(points) {
    this._length = 0;
    this._points = points;
    this._length = this._computeLength(points);
  }
  static CreateQuadraticBezier(v0, v1, v2, nbPoints) {
    nbPoints = nbPoints > 2 ? nbPoints : 3;
    const bez = new Array();
    const equation = (t, val0, val1, val2) => {
      const res = (1 - t) * (1 - t) * val0 + 2 * t * (1 - t) * val1 + t * t * val2;
      return res;
    };
    for (let i = 0; i <= nbPoints; i++) {
      bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));
    }
    return new Curve3(bez);
  }
  static CreateCubicBezier(v0, v1, v2, v3, nbPoints) {
    nbPoints = nbPoints > 3 ? nbPoints : 4;
    const bez = new Array();
    const equation = (t, val0, val1, val2, val3) => {
      const res = (1 - t) * (1 - t) * (1 - t) * val0 + 3 * t * (1 - t) * (1 - t) * val1 + 3 * t * t * (1 - t) * val2 + t * t * t * val3;
      return res;
    };
    for (let i = 0; i <= nbPoints; i++) {
      bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));
    }
    return new Curve3(bez);
  }
  static CreateHermiteSpline(p1, t1, p2, t2, nSeg) {
    const hermite = new Array();
    const step = 1 / nSeg;
    for (let i = 0; i <= nSeg; i++) {
      hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));
    }
    return new Curve3(hermite);
  }
  static CreateCatmullRomSpline(points, nbPoints, closed) {
    const catmullRom = new Array();
    const step = 1 / nbPoints;
    let amount = 0;
    if (closed) {
      const pointsCount = points.length;
      for (let i = 0; i < pointsCount; i++) {
        amount = 0;
        for (let c = 0; c < nbPoints; c++) {
          catmullRom.push(Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));
          amount += step;
        }
      }
      catmullRom.push(catmullRom[0]);
    } else {
      const totalPoints = new Array();
      totalPoints.push(points[0].clone());
      Array.prototype.push.apply(totalPoints, points);
      totalPoints.push(points[points.length - 1].clone());
      let i = 0;
      for (; i < totalPoints.length - 3; i++) {
        amount = 0;
        for (let c = 0; c < nbPoints; c++) {
          catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));
          amount += step;
        }
      }
      i--;
      catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));
    }
    return new Curve3(catmullRom);
  }
  static ArcThru3Points(first, second, third, steps = 32, closed = false, fullCircle = false) {
    const arc = new Array();
    const vec1 = second.subtract(first);
    const vec2 = third.subtract(second);
    const vec3 = first.subtract(third);
    const zAxis = Vector3.Cross(vec1, vec2);
    const len4 = zAxis.length();
    if (len4 < Math.pow(10, -8)) {
      return new Curve3(arc);
    }
    const len1_sq = vec1.lengthSquared();
    const len2_sq = vec2.lengthSquared();
    const len3_sq = vec3.lengthSquared();
    const len4_sq = zAxis.lengthSquared();
    const len1 = vec1.length();
    const len2 = vec2.length();
    const len3 = vec3.length();
    const radius = 0.5 * len1 * len2 * len3 / len4;
    const dot1 = Vector3.Dot(vec1, vec3);
    const dot2 = Vector3.Dot(vec1, vec2);
    const dot3 = Vector3.Dot(vec2, vec3);
    const a = -0.5 * len2_sq * dot1 / len4_sq;
    const b = -0.5 * len3_sq * dot2 / len4_sq;
    const c = -0.5 * len1_sq * dot3 / len4_sq;
    const center = first.scale(a).add(second.scale(b)).add(third.scale(c));
    const radiusVec = first.subtract(center);
    const xAxis = radiusVec.normalize();
    const yAxis = Vector3.Cross(zAxis, xAxis).normalize();
    if (fullCircle) {
      const dStep = 2 * Math.PI / steps;
      for (let theta = 0; theta <= 2 * Math.PI; theta += dStep) {
        arc.push(center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta)))));
      }
      arc.push(first);
    } else {
      const dStep = 1 / steps;
      let theta = 0;
      let point = Vector3.Zero();
      do {
        point = center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta))));
        arc.push(point);
        theta += dStep;
      } while (!point.equalsWithEpsilon(third, radius * dStep * 1.1));
      arc.push(third);
      if (closed) {
        arc.push(first);
      }
    }
    return new Curve3(arc);
  }
  getPoints() {
    return this._points;
  }
  length() {
    return this._length;
  }
  continue(curve) {
    const lastPoint = this._points[this._points.length - 1];
    const continuedPoints = this._points.slice();
    const curvePoints = curve.getPoints();
    for (let i = 1; i < curvePoints.length; i++) {
      continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));
    }
    const continuedCurve = new Curve3(continuedPoints);
    return continuedCurve;
  }
  _computeLength(path) {
    let l = 0;
    for (let i = 1; i < path.length; i++) {
      l += path[i].subtract(path[i - 1]).length();
    }
    return l;
  }
};

// node_modules/@babylonjs/core/Animations/animationGroup.js
var TargetedAnimation = class {
  getClassName() {
    return "TargetedAnimation";
  }
  serialize() {
    const serializationObject = {};
    serializationObject.animation = this.animation.serialize();
    serializationObject.targetId = this.target.id;
    return serializationObject;
  }
};
var AnimationGroup = class {
  constructor(name63, scene = null) {
    this.name = name63;
    this._targetedAnimations = new Array();
    this._animatables = new Array();
    this._from = Number.MAX_VALUE;
    this._to = -Number.MAX_VALUE;
    this._speedRatio = 1;
    this._loopAnimation = false;
    this._isAdditive = false;
    this._parentContainer = null;
    this.onAnimationEndObservable = new Observable();
    this.onAnimationLoopObservable = new Observable();
    this.onAnimationGroupLoopObservable = new Observable();
    this.onAnimationGroupEndObservable = new Observable();
    this.onAnimationGroupPauseObservable = new Observable();
    this.onAnimationGroupPlayObservable = new Observable();
    this.metadata = null;
    this._animationLoopFlags = [];
    this._scene = scene || EngineStore.LastCreatedScene;
    this.uniqueId = this._scene.getUniqueId();
    this._scene.addAnimationGroup(this);
  }
  get from() {
    return this._from;
  }
  get to() {
    return this._to;
  }
  get isStarted() {
    return this._isStarted;
  }
  get isPlaying() {
    return this._isStarted && !this._isPaused;
  }
  get speedRatio() {
    return this._speedRatio;
  }
  set speedRatio(value) {
    if (this._speedRatio === value) {
      return;
    }
    this._speedRatio = value;
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.speedRatio = this._speedRatio;
    }
  }
  get loopAnimation() {
    return this._loopAnimation;
  }
  set loopAnimation(value) {
    if (this._loopAnimation === value) {
      return;
    }
    this._loopAnimation = value;
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.loopAnimation = this._loopAnimation;
    }
  }
  get isAdditive() {
    return this._isAdditive;
  }
  set isAdditive(value) {
    if (this._isAdditive === value) {
      return;
    }
    this._isAdditive = value;
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.isAdditive = this._isAdditive;
    }
  }
  get targetedAnimations() {
    return this._targetedAnimations;
  }
  get animatables() {
    return this._animatables;
  }
  get children() {
    return this._targetedAnimations;
  }
  addTargetedAnimation(animation, target) {
    const targetedAnimation = new TargetedAnimation();
    targetedAnimation.animation = animation;
    targetedAnimation.target = target;
    const keys = animation.getKeys();
    if (this._from > keys[0].frame) {
      this._from = keys[0].frame;
    }
    if (this._to < keys[keys.length - 1].frame) {
      this._to = keys[keys.length - 1].frame;
    }
    this._targetedAnimations.push(targetedAnimation);
    return targetedAnimation;
  }
  normalize(beginFrame = null, endFrame = null) {
    if (beginFrame == null) {
      beginFrame = this._from;
    }
    if (endFrame == null) {
      endFrame = this._to;
    }
    for (let index = 0; index < this._targetedAnimations.length; index++) {
      const targetedAnimation = this._targetedAnimations[index];
      const keys = targetedAnimation.animation.getKeys();
      const startKey = keys[0];
      const endKey = keys[keys.length - 1];
      if (startKey.frame > beginFrame) {
        const newKey = {
          frame: beginFrame,
          value: startKey.value,
          inTangent: startKey.inTangent,
          outTangent: startKey.outTangent,
          interpolation: startKey.interpolation
        };
        keys.splice(0, 0, newKey);
      }
      if (endKey.frame < endFrame) {
        const newKey = {
          frame: endFrame,
          value: endKey.value,
          inTangent: endKey.inTangent,
          outTangent: endKey.outTangent,
          interpolation: endKey.interpolation
        };
        keys.push(newKey);
      }
    }
    this._from = beginFrame;
    this._to = endFrame;
    return this;
  }
  _processLoop(animatable, targetedAnimation, index) {
    animatable.onAnimationLoop = () => {
      this.onAnimationLoopObservable.notifyObservers(targetedAnimation);
      if (this._animationLoopFlags[index]) {
        return;
      }
      this._animationLoopFlags[index] = true;
      this._animationLoopCount++;
      if (this._animationLoopCount === this._targetedAnimations.length) {
        this.onAnimationGroupLoopObservable.notifyObservers(this);
        this._animationLoopCount = 0;
        this._animationLoopFlags.length = 0;
      }
    };
  }
  start(loop = false, speedRatio = 1, from, to, isAdditive) {
    if (this._isStarted || this._targetedAnimations.length === 0) {
      return this;
    }
    this._loopAnimation = loop;
    this._animationLoopCount = 0;
    this._animationLoopFlags.length = 0;
    for (let index = 0; index < this._targetedAnimations.length; index++) {
      const targetedAnimation = this._targetedAnimations[index];
      const animatable = this._scene.beginDirectAnimation(targetedAnimation.target, [targetedAnimation.animation], from !== void 0 ? from : this._from, to !== void 0 ? to : this._to, loop, speedRatio, void 0, void 0, isAdditive !== void 0 ? isAdditive : this._isAdditive);
      animatable.onAnimationEnd = () => {
        this.onAnimationEndObservable.notifyObservers(targetedAnimation);
        this._checkAnimationGroupEnded(animatable);
      };
      this._processLoop(animatable, targetedAnimation, index);
      this._animatables.push(animatable);
    }
    this._speedRatio = speedRatio;
    this._isStarted = true;
    this._isPaused = false;
    this.onAnimationGroupPlayObservable.notifyObservers(this);
    return this;
  }
  pause() {
    if (!this._isStarted) {
      return this;
    }
    this._isPaused = true;
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.pause();
    }
    this.onAnimationGroupPauseObservable.notifyObservers(this);
    return this;
  }
  play(loop) {
    if (this.isStarted && this._animatables.length === this._targetedAnimations.length) {
      if (loop !== void 0) {
        this.loopAnimation = loop;
      }
      this.restart();
    } else {
      this.stop();
      this.start(loop, this._speedRatio);
    }
    this._isPaused = false;
    return this;
  }
  reset() {
    if (!this._isStarted) {
      this.play();
      this.goToFrame(0);
      this.stop();
      return this;
    }
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.reset();
    }
    return this;
  }
  restart() {
    if (!this._isStarted) {
      return this;
    }
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.restart();
    }
    this.onAnimationGroupPlayObservable.notifyObservers(this);
    return this;
  }
  stop() {
    if (!this._isStarted) {
      return this;
    }
    const list = this._animatables.slice();
    for (let index = 0; index < list.length; index++) {
      list[index].stop();
    }
    this._isStarted = false;
    return this;
  }
  setWeightForAllAnimatables(weight) {
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.weight = weight;
    }
    return this;
  }
  syncAllAnimationsWith(root) {
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.syncWith(root);
    }
    return this;
  }
  goToFrame(frame) {
    if (!this._isStarted) {
      return this;
    }
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.goToFrame(frame);
    }
    return this;
  }
  dispose() {
    this._targetedAnimations.length = 0;
    this._animatables.length = 0;
    const index = this._scene.animationGroups.indexOf(this);
    if (index > -1) {
      this._scene.animationGroups.splice(index, 1);
    }
    if (this._parentContainer) {
      const index2 = this._parentContainer.animationGroups.indexOf(this);
      if (index2 > -1) {
        this._parentContainer.animationGroups.splice(index2, 1);
      }
      this._parentContainer = null;
    }
    this.onAnimationEndObservable.clear();
    this.onAnimationGroupEndObservable.clear();
    this.onAnimationGroupPauseObservable.clear();
    this.onAnimationGroupPlayObservable.clear();
    this.onAnimationLoopObservable.clear();
    this.onAnimationGroupLoopObservable.clear();
  }
  _checkAnimationGroupEnded(animatable) {
    const idx = this._animatables.indexOf(animatable);
    if (idx > -1) {
      this._animatables.splice(idx, 1);
    }
    if (this._animatables.length === 0) {
      this._isStarted = false;
      this.onAnimationGroupEndObservable.notifyObservers(this);
    }
  }
  clone(newName, targetConverter, cloneAnimations = false) {
    const newGroup = new AnimationGroup(newName || this.name, this._scene);
    for (const targetAnimation of this._targetedAnimations) {
      newGroup.addTargetedAnimation(cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation, targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);
    }
    return newGroup;
  }
  serialize() {
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.from = this.from;
    serializationObject.to = this.to;
    serializationObject.targetedAnimations = [];
    for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {
      const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];
      serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();
    }
    if (Tags && Tags.HasTags(this)) {
      serializationObject.tags = Tags.GetTags(this);
    }
    if (this.metadata) {
      serializationObject.metadata = this.metadata;
    }
    return serializationObject;
  }
  static Parse(parsedAnimationGroup, scene) {
    const animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene);
    for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {
      const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];
      const animation = Animation.Parse(targetedAnimation.animation);
      const id = targetedAnimation.targetId;
      if (targetedAnimation.animation.property === "influence") {
        const morphTarget = scene.getMorphTargetById(id);
        if (morphTarget) {
          animationGroup.addTargetedAnimation(animation, morphTarget);
        }
      } else {
        const targetNode = scene.getNodeById(id);
        if (targetNode != null) {
          animationGroup.addTargetedAnimation(animation, targetNode);
        }
      }
    }
    if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {
      animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);
    }
    if (Tags) {
      Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);
    }
    if (parsedAnimationGroup.metadata !== void 0) {
      animationGroup.metadata = parsedAnimationGroup.metadata;
    }
    return animationGroup;
  }
  static MakeAnimationAdditive(sourceAnimationGroup, referenceFrame = 0, range, cloneOriginal = false, clonedName) {
    let animationGroup = sourceAnimationGroup;
    if (cloneOriginal) {
      animationGroup = sourceAnimationGroup.clone(clonedName || animationGroup.name);
    }
    const targetedAnimations = animationGroup.targetedAnimations;
    for (let index = 0; index < targetedAnimations.length; index++) {
      const targetedAnimation = targetedAnimations[index];
      Animation.MakeAnimationAdditive(targetedAnimation.animation, referenceFrame, range);
    }
    animationGroup.isAdditive = true;
    return animationGroup;
  }
  getClassName() {
    return "AnimationGroup";
  }
  toString(fullDetails) {
    let ret = "Name: " + this.name;
    ret += ", type: " + this.getClassName();
    if (fullDetails) {
      ret += ", from: " + this._from;
      ret += ", to: " + this._to;
      ret += ", isStarted: " + this._isStarted;
      ret += ", speedRatio: " + this._speedRatio;
      ret += ", targetedAnimations length: " + this._targetedAnimations.length;
      ret += ", animatables length: " + this._animatables;
    }
    return ret;
  }
};

// node_modules/@babylonjs/core/Misc/coroutine.js
function inlineScheduler(coroutine, onStep, onError) {
  try {
    const step = coroutine.next();
    if (step.done) {
      onStep(step);
    } else if (!step.value) {
      onStep(step);
    } else {
      step.value.then(() => {
        step.value = void 0;
        onStep(step);
      }, onError);
    }
  } catch (error) {
    onError(error);
  }
}
function createYieldingScheduler(yieldAfterMS = 25) {
  let startTime;
  return (coroutine, onStep, onError) => {
    const currentTime = performance.now();
    if (startTime === void 0 || currentTime - startTime > yieldAfterMS) {
      startTime = currentTime;
      setTimeout(() => {
        inlineScheduler(coroutine, onStep, onError);
      }, 0);
    } else {
      inlineScheduler(coroutine, onStep, onError);
    }
  };
}
function runCoroutine(coroutine, scheduler, onSuccess, onError, abortSignal) {
  const resume = () => {
    let reschedule;
    const onStep = (stepResult) => {
      if (stepResult.done) {
        onSuccess(stepResult.value);
      } else {
        if (reschedule === void 0) {
          reschedule = true;
        } else {
          resume();
        }
      }
    };
    do {
      reschedule = void 0;
      if (!abortSignal || !abortSignal.aborted) {
        scheduler(coroutine, onStep, onError);
      } else {
        onError(new Error("Aborted"));
      }
      if (reschedule === void 0) {
        reschedule = false;
      }
    } while (reschedule);
  };
  resume();
}
function runCoroutineSync(coroutine, abortSignal) {
  let result;
  runCoroutine(coroutine, inlineScheduler, (r) => result = r, (e) => {
    throw e;
  }, abortSignal);
  return result;
}
function runCoroutineAsync(coroutine, scheduler, abortSignal) {
  return new Promise((resolve, reject) => {
    runCoroutine(coroutine, scheduler, resolve, reject, abortSignal);
  });
}
function makeSyncFunction(coroutineFactory, abortSignal) {
  return (...params) => {
    return runCoroutineSync(coroutineFactory(...params), abortSignal);
  };
}
function makeAsyncFunction(coroutineFactory, scheduler, abortSignal) {
  return (...params) => {
    return runCoroutineAsync(coroutineFactory(...params), scheduler, abortSignal);
  };
}

// node_modules/@babylonjs/core/Maths/math.viewport.js
var Viewport = class {
  constructor(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  toGlobal(renderWidth, renderHeight) {
    return new Viewport(this.x * renderWidth, this.y * renderHeight, this.width * renderWidth, this.height * renderHeight);
  }
  toGlobalToRef(renderWidth, renderHeight, ref) {
    ref.x = this.x * renderWidth;
    ref.y = this.y * renderHeight;
    ref.width = this.width * renderWidth;
    ref.height = this.height * renderHeight;
    return this;
  }
  clone() {
    return new Viewport(this.x, this.y, this.width, this.height);
  }
};

// node_modules/@babylonjs/core/Cameras/camera.js
var Camera = class extends Node {
  constructor(name63, position, scene, setActiveOnSceneIfNoneActive = true) {
    super(name63, scene);
    this._position = Vector3.Zero();
    this._upVector = Vector3.Up();
    this._orthoLeft = null;
    this._orthoRight = null;
    this._orthoBottom = null;
    this._orthoTop = null;
    this.fov = 0.8;
    this.projectionPlaneTilt = 0;
    this.minZ = 1;
    this.maxZ = 1e4;
    this.inertia = 0.9;
    this._mode = Camera.PERSPECTIVE_CAMERA;
    this.isIntermediate = false;
    this.viewport = new Viewport(0, 0, 1, 1);
    this.layerMask = 268435455;
    this.fovMode = Camera.FOVMODE_VERTICAL_FIXED;
    this.cameraRigMode = Camera.RIG_MODE_NONE;
    this.customRenderTargets = new Array();
    this.outputRenderTarget = null;
    this.onViewMatrixChangedObservable = new Observable();
    this.onProjectionMatrixChangedObservable = new Observable();
    this.onAfterCheckInputsObservable = new Observable();
    this.onRestoreStateObservable = new Observable();
    this.isRigCamera = false;
    this._rigCameras = new Array();
    this._webvrViewMatrix = Matrix.Identity();
    this._skipRendering = false;
    this._projectionMatrix = new Matrix();
    this._postProcesses = new Array();
    this._activeMeshes = new SmartArray(256);
    this._globalPosition = Vector3.Zero();
    this._computedViewMatrix = Matrix.Identity();
    this._doNotComputeProjectionMatrix = false;
    this._transformMatrix = Matrix.Zero();
    this._refreshFrustumPlanes = true;
    this._absoluteRotation = Quaternion.Identity();
    this._isCamera = true;
    this._isLeftCamera = false;
    this._isRightCamera = false;
    this.getScene().addCamera(this);
    if (setActiveOnSceneIfNoneActive && !this.getScene().activeCamera) {
      this.getScene().activeCamera = this;
    }
    this.position = position;
    this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${name63}`);
  }
  get position() {
    return this._position;
  }
  set position(newPosition) {
    this._position = newPosition;
  }
  set upVector(vec) {
    this._upVector = vec;
  }
  get upVector() {
    return this._upVector;
  }
  get screenArea() {
    var _a, _b, _c, _d;
    let x = 0;
    let y = 0;
    if (this.mode === Camera.PERSPECTIVE_CAMERA) {
      if (this.fovMode === Camera.FOVMODE_VERTICAL_FIXED) {
        y = this.minZ * 2 * Math.tan(this.fov / 2);
        x = this.getEngine().getAspectRatio(this) * y;
      } else {
        x = this.minZ * 2 * Math.tan(this.fov / 2);
        y = x / this.getEngine().getAspectRatio(this);
      }
    } else {
      const halfWidth = this.getEngine().getRenderWidth() / 2;
      const halfHeight = this.getEngine().getRenderHeight() / 2;
      x = ((_a = this.orthoRight) !== null && _a !== void 0 ? _a : halfWidth) - ((_b = this.orthoLeft) !== null && _b !== void 0 ? _b : -halfWidth);
      y = ((_c = this.orthoTop) !== null && _c !== void 0 ? _c : halfHeight) - ((_d = this.orthoBottom) !== null && _d !== void 0 ? _d : -halfHeight);
    }
    return x * y;
  }
  set orthoLeft(value) {
    this._orthoLeft = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoLeft = value;
    }
  }
  get orthoLeft() {
    return this._orthoLeft;
  }
  set orthoRight(value) {
    this._orthoRight = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoRight = value;
    }
  }
  get orthoRight() {
    return this._orthoRight;
  }
  set orthoBottom(value) {
    this._orthoBottom = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoBottom = value;
    }
  }
  get orthoBottom() {
    return this._orthoBottom;
  }
  set orthoTop(value) {
    this._orthoTop = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoTop = value;
    }
  }
  get orthoTop() {
    return this._orthoTop;
  }
  set mode(mode) {
    this._mode = mode;
    for (const rigCamera of this._rigCameras) {
      rigCamera.mode = mode;
    }
  }
  get mode() {
    return this._mode;
  }
  storeState() {
    this._stateStored = true;
    this._storedFov = this.fov;
    return this;
  }
  _restoreStateValues() {
    if (!this._stateStored) {
      return false;
    }
    this.fov = this._storedFov;
    return true;
  }
  restoreState() {
    if (this._restoreStateValues()) {
      this.onRestoreStateObservable.notifyObservers(this);
      return true;
    }
    return false;
  }
  getClassName() {
    return "Camera";
  }
  toString(fullDetails) {
    let ret = "Name: " + this.name;
    ret += ", type: " + this.getClassName();
    if (this.animations) {
      for (let i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    return ret;
  }
  applyVerticalCorrection() {
    const rot = this.absoluteRotation.toEulerAngles();
    this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -rot.x : rot.x;
  }
  get globalPosition() {
    return this._globalPosition;
  }
  getActiveMeshes() {
    return this._activeMeshes;
  }
  isActiveMesh(mesh) {
    return this._activeMeshes.indexOf(mesh) !== -1;
  }
  isReady(completeCheck = false) {
    if (completeCheck) {
      for (const pp of this._postProcesses) {
        if (pp && !pp.isReady()) {
          return false;
        }
      }
    }
    return super.isReady(completeCheck);
  }
  _initCache() {
    super._initCache();
    this._cache.position = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.upVector = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.mode = void 0;
    this._cache.minZ = void 0;
    this._cache.maxZ = void 0;
    this._cache.fov = void 0;
    this._cache.fovMode = void 0;
    this._cache.aspectRatio = void 0;
    this._cache.orthoLeft = void 0;
    this._cache.orthoRight = void 0;
    this._cache.orthoBottom = void 0;
    this._cache.orthoTop = void 0;
    this._cache.renderWidth = void 0;
    this._cache.renderHeight = void 0;
  }
  _updateCache(ignoreParentClass) {
    if (!ignoreParentClass) {
      super._updateCache();
    }
    this._cache.position.copyFrom(this.position);
    this._cache.upVector.copyFrom(this.upVector);
  }
  _isSynchronized() {
    return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();
  }
  _isSynchronizedViewMatrix() {
    if (!super._isSynchronized()) {
      return false;
    }
    return this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();
  }
  _isSynchronizedProjectionMatrix() {
    let check = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;
    if (!check) {
      return false;
    }
    const engine = this.getEngine();
    if (this.mode === Camera.PERSPECTIVE_CAMERA) {
      check = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === engine.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt;
    } else {
      check = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === engine.getRenderWidth() && this._cache.renderHeight === engine.getRenderHeight();
    }
    return check;
  }
  attachControl(_ignored, _noPreventDefault) {
  }
  detachControl(_ignored) {
  }
  update() {
    this._checkInputs();
    if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {
      this._updateRigCameras();
    }
  }
  _checkInputs() {
    this.onAfterCheckInputsObservable.notifyObservers(this);
  }
  get rigCameras() {
    return this._rigCameras;
  }
  get rigPostProcess() {
    return this._rigPostProcess;
  }
  _getFirstPostProcess() {
    for (let ppIndex = 0; ppIndex < this._postProcesses.length; ppIndex++) {
      if (this._postProcesses[ppIndex] !== null) {
        return this._postProcesses[ppIndex];
      }
    }
    return null;
  }
  _cascadePostProcessesToRigCams() {
    const firstPostProcess = this._getFirstPostProcess();
    if (firstPostProcess) {
      firstPostProcess.markTextureDirty();
    }
    for (let i = 0, len = this._rigCameras.length; i < len; i++) {
      const cam = this._rigCameras[i];
      const rigPostProcess = cam._rigPostProcess;
      if (rigPostProcess) {
        const isPass = rigPostProcess.getEffectName() === "pass";
        if (isPass) {
          cam.isIntermediate = this._postProcesses.length === 0;
        }
        cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);
        rigPostProcess.markTextureDirty();
      } else {
        cam._postProcesses = this._postProcesses.slice(0);
      }
    }
  }
  attachPostProcess(postProcess, insertAt = null) {
    if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {
      Logger.Error("You're trying to reuse a post process not defined as reusable.");
      return 0;
    }
    if (insertAt == null || insertAt < 0) {
      this._postProcesses.push(postProcess);
    } else if (this._postProcesses[insertAt] === null) {
      this._postProcesses[insertAt] = postProcess;
    } else {
      this._postProcesses.splice(insertAt, 0, postProcess);
    }
    this._cascadePostProcessesToRigCams();
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    return this._postProcesses.indexOf(postProcess);
  }
  detachPostProcess(postProcess) {
    const idx = this._postProcesses.indexOf(postProcess);
    if (idx !== -1) {
      this._postProcesses[idx] = null;
    }
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    this._cascadePostProcessesToRigCams();
  }
  getWorldMatrix() {
    if (this._isSynchronizedViewMatrix()) {
      return this._worldMatrix;
    }
    this.getViewMatrix();
    return this._worldMatrix;
  }
  _getViewMatrix() {
    return Matrix.Identity();
  }
  getViewMatrix(force) {
    if (!force && this._isSynchronizedViewMatrix()) {
      return this._computedViewMatrix;
    }
    this.updateCache();
    this._computedViewMatrix = this._getViewMatrix();
    this._currentRenderId = this.getScene().getRenderId();
    this._childUpdateId++;
    this._refreshFrustumPlanes = true;
    if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {
      this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);
    }
    if (this.parent && this.parent.onViewMatrixChangedObservable) {
      this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent);
    }
    this.onViewMatrixChangedObservable.notifyObservers(this);
    this._computedViewMatrix.invertToRef(this._worldMatrix);
    return this._computedViewMatrix;
  }
  freezeProjectionMatrix(projection) {
    this._doNotComputeProjectionMatrix = true;
    if (projection !== void 0) {
      this._projectionMatrix = projection;
    }
  }
  unfreezeProjectionMatrix() {
    this._doNotComputeProjectionMatrix = false;
  }
  getProjectionMatrix(force) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this._doNotComputeProjectionMatrix || !force && this._isSynchronizedProjectionMatrix()) {
      return this._projectionMatrix;
    }
    this._cache.mode = this.mode;
    this._cache.minZ = this.minZ;
    this._cache.maxZ = this.maxZ;
    this._refreshFrustumPlanes = true;
    const engine = this.getEngine();
    const scene = this.getScene();
    const reverseDepth = engine.useReverseDepthBuffer;
    if (this.mode === Camera.PERSPECTIVE_CAMERA) {
      this._cache.fov = this.fov;
      this._cache.fovMode = this.fovMode;
      this._cache.aspectRatio = engine.getAspectRatio(this);
      this._cache.projectionPlaneTilt = this.projectionPlaneTilt;
      if (this.minZ <= 0) {
        this.minZ = 0.1;
      }
      let getProjectionMatrix;
      if (scene.useRightHandedSystem) {
        getProjectionMatrix = Matrix.PerspectiveFovRHToRef;
      } else {
        getProjectionMatrix = Matrix.PerspectiveFovLHToRef;
      }
      getProjectionMatrix(this.fov, engine.getAspectRatio(this), reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === Camera.FOVMODE_VERTICAL_FIXED, engine.isNDCHalfZRange, this.projectionPlaneTilt, reverseDepth);
    } else {
      const halfWidth = engine.getRenderWidth() / 2;
      const halfHeight = engine.getRenderHeight() / 2;
      if (scene.useRightHandedSystem) {
        Matrix.OrthoOffCenterRHToRef((_a = this.orthoLeft) !== null && _a !== void 0 ? _a : -halfWidth, (_b = this.orthoRight) !== null && _b !== void 0 ? _b : halfWidth, (_c = this.orthoBottom) !== null && _c !== void 0 ? _c : -halfHeight, (_d = this.orthoTop) !== null && _d !== void 0 ? _d : halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
      } else {
        Matrix.OrthoOffCenterLHToRef((_e = this.orthoLeft) !== null && _e !== void 0 ? _e : -halfWidth, (_f = this.orthoRight) !== null && _f !== void 0 ? _f : halfWidth, (_g = this.orthoBottom) !== null && _g !== void 0 ? _g : -halfHeight, (_h = this.orthoTop) !== null && _h !== void 0 ? _h : halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
      }
      this._cache.orthoLeft = this.orthoLeft;
      this._cache.orthoRight = this.orthoRight;
      this._cache.orthoBottom = this.orthoBottom;
      this._cache.orthoTop = this.orthoTop;
      this._cache.renderWidth = engine.getRenderWidth();
      this._cache.renderHeight = engine.getRenderHeight();
    }
    this.onProjectionMatrixChangedObservable.notifyObservers(this);
    return this._projectionMatrix;
  }
  getTransformationMatrix() {
    this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    return this._transformMatrix;
  }
  _updateFrustumPlanes() {
    if (!this._refreshFrustumPlanes) {
      return;
    }
    this.getTransformationMatrix();
    if (!this._frustumPlanes) {
      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
    } else {
      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
    }
    this._refreshFrustumPlanes = false;
  }
  isInFrustum(target, checkRigCameras = false) {
    this._updateFrustumPlanes();
    if (checkRigCameras && this.rigCameras.length > 0) {
      let result = false;
      this.rigCameras.forEach((cam) => {
        cam._updateFrustumPlanes();
        result = result || target.isInFrustum(cam._frustumPlanes);
      });
      return result;
    } else {
      return target.isInFrustum(this._frustumPlanes);
    }
  }
  isCompletelyInFrustum(target) {
    this._updateFrustumPlanes();
    return target.isCompletelyInFrustum(this._frustumPlanes);
  }
  getForwardRay(length = 100, transform, origin) {
    throw _WarnImport("Ray");
  }
  getForwardRayToRef(refRay, length = 100, transform, origin) {
    throw _WarnImport("Ray");
  }
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this.onViewMatrixChangedObservable.clear();
    this.onProjectionMatrixChangedObservable.clear();
    this.onAfterCheckInputsObservable.clear();
    this.onRestoreStateObservable.clear();
    if (this.inputs) {
      this.inputs.clear();
    }
    this.getScene().stopAnimation(this);
    this.getScene().removeCamera(this);
    while (this._rigCameras.length > 0) {
      const camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    if (this._parentContainer) {
      const index = this._parentContainer.cameras.indexOf(this);
      if (index > -1) {
        this._parentContainer.cameras.splice(index, 1);
      }
      this._parentContainer = null;
    }
    if (this._rigPostProcess) {
      this._rigPostProcess.dispose(this);
      this._rigPostProcess = null;
      this._postProcesses.length = 0;
    } else if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {
      this._rigPostProcess = null;
      this._postProcesses.length = 0;
    } else {
      let i2 = this._postProcesses.length;
      while (--i2 >= 0) {
        const postProcess = this._postProcesses[i2];
        if (postProcess) {
          postProcess.dispose(this);
        }
      }
    }
    let i = this.customRenderTargets.length;
    while (--i >= 0) {
      this.customRenderTargets[i].dispose();
    }
    this.customRenderTargets.length = 0;
    this._activeMeshes.dispose();
    this.getScene().getEngine().releaseRenderPassId(this.renderPassId);
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  get isLeftCamera() {
    return this._isLeftCamera;
  }
  get isRightCamera() {
    return this._isRightCamera;
  }
  get leftCamera() {
    if (this._rigCameras.length < 1) {
      return null;
    }
    return this._rigCameras[0];
  }
  get rightCamera() {
    if (this._rigCameras.length < 2) {
      return null;
    }
    return this._rigCameras[1];
  }
  getLeftTarget() {
    if (this._rigCameras.length < 1) {
      return null;
    }
    return this._rigCameras[0].getTarget();
  }
  getRightTarget() {
    if (this._rigCameras.length < 2) {
      return null;
    }
    return this._rigCameras[1].getTarget();
  }
  setCameraRigMode(mode, rigParams) {
    if (this.cameraRigMode === mode) {
      return;
    }
    while (this._rigCameras.length > 0) {
      const camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    this.cameraRigMode = mode;
    this._cameraRigParams = {};
    this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;
    this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);
    if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {
      const leftCamera = this.createRigCamera(this.name + "_L", 0);
      if (leftCamera) {
        leftCamera._isLeftCamera = true;
      }
      const rightCamera = this.createRigCamera(this.name + "_R", 1);
      if (rightCamera) {
        rightCamera._isRightCamera = true;
      }
      if (leftCamera && rightCamera) {
        this._rigCameras.push(leftCamera);
        this._rigCameras.push(rightCamera);
      }
    }
    this._setRigMode(rigParams);
    this._cascadePostProcessesToRigCams();
    this.update();
  }
  _setRigMode(rigParams) {
  }
  _getVRProjectionMatrix() {
    Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, true, this.getEngine().isNDCHalfZRange);
    this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);
    return this._projectionMatrix;
  }
  _updateCameraRotationMatrix() {
  }
  _updateWebVRCameraRotationMatrix() {
  }
  _getWebVRProjectionMatrix() {
    return Matrix.Identity();
  }
  _getWebVRViewMatrix() {
    return Matrix.Identity();
  }
  setCameraRigParameter(name63, value) {
    if (!this._cameraRigParams) {
      this._cameraRigParams = {};
    }
    this._cameraRigParams[name63] = value;
    if (name63 === "interaxialDistance") {
      this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(value / 0.0637);
    }
  }
  createRigCamera(name63, cameraIndex) {
    return null;
  }
  _updateRigCameras() {
    for (let i = 0; i < this._rigCameras.length; i++) {
      this._rigCameras[i].minZ = this.minZ;
      this._rigCameras[i].maxZ = this.maxZ;
      this._rigCameras[i].fov = this.fov;
      this._rigCameras[i].upVector.copyFrom(this.upVector);
    }
    if (this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {
      this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;
    }
  }
  _setupInputs() {
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getClassName();
    if (this.parent) {
      this.parent._serializeAsParent(serializationObject);
    }
    if (this.inputs) {
      this.inputs.serialize(serializationObject);
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.isEnabled = this.isEnabled();
    return serializationObject;
  }
  clone(name63, newParent = null) {
    const camera = SerializationHelper.Clone(Camera.GetConstructorFromName(this.getClassName(), name63, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
    camera.name = name63;
    camera.parent = newParent;
    this.onClonedObservable.notifyObservers(camera);
    return camera;
  }
  getDirection(localAxis) {
    const result = Vector3.Zero();
    this.getDirectionToRef(localAxis, result);
    return result;
  }
  get absoluteRotation() {
    this.getWorldMatrix().decompose(void 0, this._absoluteRotation);
    return this._absoluteRotation;
  }
  getDirectionToRef(localAxis, result) {
    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
  }
  static GetConstructorFromName(type, name63, scene, interaxial_distance = 0, isStereoscopicSideBySide = true) {
    const constructorFunc = Node.Construct(type, name63, scene, {
      interaxial_distance,
      isStereoscopicSideBySide
    });
    if (constructorFunc) {
      return constructorFunc;
    }
    return () => Camera._CreateDefaultParsedCamera(name63, scene);
  }
  computeWorldMatrix() {
    return this.getWorldMatrix();
  }
  static Parse(parsedCamera, scene) {
    const type = parsedCamera.type;
    const construct = Camera.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);
    const camera = SerializationHelper.Parse(construct, parsedCamera, scene);
    if (parsedCamera.parentId !== void 0) {
      camera._waitingParentId = parsedCamera.parentId;
    }
    if (parsedCamera.parentInstanceIndex !== void 0) {
      camera._waitingParentInstanceIndex = parsedCamera.parentInstanceIndex;
    }
    if (camera.inputs) {
      camera.inputs.parse(parsedCamera);
      camera._setupInputs();
    }
    if (parsedCamera.upVector) {
      camera.upVector = Vector3.FromArray(parsedCamera.upVector);
    }
    if (camera.setPosition) {
      camera.position.copyFromFloats(0, 0, 0);
      camera.setPosition(Vector3.FromArray(parsedCamera.position));
    }
    if (parsedCamera.target) {
      if (camera.setTarget) {
        camera.setTarget(Vector3.FromArray(parsedCamera.target));
      }
    }
    if (parsedCamera.cameraRigMode) {
      const rigParams = parsedCamera.interaxial_distance ? { interaxialDistance: parsedCamera.interaxial_distance } : {};
      camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);
    }
    if (parsedCamera.animations) {
      for (let animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {
        const parsedAnimation = parsedCamera.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          camera.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(camera, parsedCamera, scene);
    }
    if (parsedCamera.autoAnimate) {
      scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1);
    }
    if (parsedCamera.isEnabled !== void 0) {
      camera.setEnabled(parsedCamera.isEnabled);
    }
    return camera;
  }
};
Camera._CreateDefaultParsedCamera = (name63, scene) => {
  throw _WarnImport("UniversalCamera");
};
Camera.PERSPECTIVE_CAMERA = 0;
Camera.ORTHOGRAPHIC_CAMERA = 1;
Camera.FOVMODE_VERTICAL_FIXED = 0;
Camera.FOVMODE_HORIZONTAL_FIXED = 1;
Camera.RIG_MODE_NONE = 0;
Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
Camera.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
Camera.RIG_MODE_VR = 20;
Camera.RIG_MODE_WEBVR = 21;
Camera.RIG_MODE_CUSTOM = 22;
Camera.ForceAttachControlToAlwaysPreventDefault = false;
__decorate([
  serializeAsVector3("position")
], Camera.prototype, "_position", void 0);
__decorate([
  serializeAsVector3("upVector")
], Camera.prototype, "_upVector", void 0);
__decorate([
  serialize()
], Camera.prototype, "orthoLeft", null);
__decorate([
  serialize()
], Camera.prototype, "orthoRight", null);
__decorate([
  serialize()
], Camera.prototype, "orthoBottom", null);
__decorate([
  serialize()
], Camera.prototype, "orthoTop", null);
__decorate([
  serialize()
], Camera.prototype, "fov", void 0);
__decorate([
  serialize()
], Camera.prototype, "projectionPlaneTilt", void 0);
__decorate([
  serialize()
], Camera.prototype, "minZ", void 0);
__decorate([
  serialize()
], Camera.prototype, "maxZ", void 0);
__decorate([
  serialize()
], Camera.prototype, "inertia", void 0);
__decorate([
  serialize()
], Camera.prototype, "mode", null);
__decorate([
  serialize()
], Camera.prototype, "layerMask", void 0);
__decorate([
  serialize()
], Camera.prototype, "fovMode", void 0);
__decorate([
  serialize()
], Camera.prototype, "cameraRigMode", void 0);
__decorate([
  serialize()
], Camera.prototype, "interaxialDistance", void 0);
__decorate([
  serialize()
], Camera.prototype, "isStereoscopicSideBySide", void 0);

// node_modules/@babylonjs/core/Meshes/mesh.vertexData.js
var VertexData = class {
  constructor() {
    this._applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));
  }
  set(data, kind) {
    if (!data.length) {
      Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);
    }
    switch (kind) {
      case VertexBuffer.PositionKind:
        this.positions = data;
        break;
      case VertexBuffer.NormalKind:
        this.normals = data;
        break;
      case VertexBuffer.TangentKind:
        this.tangents = data;
        break;
      case VertexBuffer.UVKind:
        this.uvs = data;
        break;
      case VertexBuffer.UV2Kind:
        this.uvs2 = data;
        break;
      case VertexBuffer.UV3Kind:
        this.uvs3 = data;
        break;
      case VertexBuffer.UV4Kind:
        this.uvs4 = data;
        break;
      case VertexBuffer.UV5Kind:
        this.uvs5 = data;
        break;
      case VertexBuffer.UV6Kind:
        this.uvs6 = data;
        break;
      case VertexBuffer.ColorKind:
        this.colors = data;
        break;
      case VertexBuffer.MatricesIndicesKind:
        this.matricesIndices = data;
        break;
      case VertexBuffer.MatricesWeightsKind:
        this.matricesWeights = data;
        break;
      case VertexBuffer.MatricesIndicesExtraKind:
        this.matricesIndicesExtra = data;
        break;
      case VertexBuffer.MatricesWeightsExtraKind:
        this.matricesWeightsExtra = data;
        break;
    }
  }
  applyToMesh(mesh, updatable) {
    this._applyTo(mesh, updatable, false);
    return this;
  }
  applyToGeometry(geometry, updatable) {
    this._applyTo(geometry, updatable, false);
    return this;
  }
  updateMesh(mesh) {
    this._update(mesh);
    return this;
  }
  updateGeometry(geometry) {
    this._update(geometry);
    return this;
  }
  *_applyToCoroutine(meshOrGeometry, updatable = false, isAsync) {
    if (this.positions) {
      meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.normals) {
      meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.tangents) {
      meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs) {
      meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs2) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs3) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs4) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs5) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs6) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.colors) {
      meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.matricesIndices) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.matricesWeights) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.matricesIndicesExtra) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.matricesWeightsExtra) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.indices) {
      meshOrGeometry.setIndices(this.indices, null, updatable);
      if (isAsync) {
        yield;
      }
    } else {
      meshOrGeometry.setIndices([], null);
    }
    return this;
  }
  _update(meshOrGeometry, updateExtends, makeItUnique) {
    if (this.positions) {
      meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);
    }
    if (this.normals) {
      meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);
    }
    if (this.tangents) {
      meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);
    }
    if (this.uvs) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);
    }
    if (this.uvs2) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);
    }
    if (this.uvs3) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);
    }
    if (this.uvs4) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);
    }
    if (this.uvs5) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);
    }
    if (this.uvs6) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);
    }
    if (this.colors) {
      meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);
    }
    if (this.matricesIndices) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);
    }
    if (this.matricesWeights) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);
    }
    if (this.matricesIndicesExtra) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);
    }
    if (this.matricesWeightsExtra) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);
    }
    if (this.indices) {
      meshOrGeometry.setIndices(this.indices, null);
    }
    return this;
  }
  static _TransformVector3Coordinates(coordinates, transformation, offset = 0, length = coordinates.length) {
    const coordinate = TmpVectors.Vector3[0];
    const transformedCoordinate = TmpVectors.Vector3[1];
    for (let index = offset; index < offset + length; index += 3) {
      Vector3.FromArrayToRef(coordinates, index, coordinate);
      Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);
      coordinates[index] = transformedCoordinate.x;
      coordinates[index + 1] = transformedCoordinate.y;
      coordinates[index + 2] = transformedCoordinate.z;
    }
  }
  static _TransformVector3Normals(normals, transformation, offset = 0, length = normals.length) {
    const normal = TmpVectors.Vector3[0];
    const transformedNormal = TmpVectors.Vector3[1];
    for (let index = offset; index < offset + length; index += 3) {
      Vector3.FromArrayToRef(normals, index, normal);
      Vector3.TransformNormalToRef(normal, transformation, transformedNormal);
      normals[index] = transformedNormal.x;
      normals[index + 1] = transformedNormal.y;
      normals[index + 2] = transformedNormal.z;
    }
  }
  static _TransformVector4Normals(normals, transformation, offset = 0, length = normals.length) {
    const normal = TmpVectors.Vector4[0];
    const transformedNormal = TmpVectors.Vector4[1];
    for (let index = offset; index < offset + length; index += 4) {
      Vector4.FromArrayToRef(normals, index, normal);
      Vector4.TransformNormalToRef(normal, transformation, transformedNormal);
      normals[index] = transformedNormal.x;
      normals[index + 1] = transformedNormal.y;
      normals[index + 2] = transformedNormal.z;
      normals[index + 3] = transformedNormal.w;
    }
  }
  static _FlipFaces(indices, offset = 0, length = indices.length) {
    for (let index = offset; index < offset + length; index += 3) {
      const tmp = indices[index + 1];
      indices[index + 1] = indices[index + 2];
      indices[index + 2] = tmp;
    }
  }
  transform(matrix) {
    const flip = matrix.determinant() < 0;
    if (this.positions) {
      VertexData._TransformVector3Coordinates(this.positions, matrix);
    }
    if (this.normals) {
      VertexData._TransformVector3Normals(this.normals, matrix);
    }
    if (this.tangents) {
      VertexData._TransformVector4Normals(this.tangents, matrix);
    }
    if (flip && this.indices) {
      VertexData._FlipFaces(this.indices);
    }
    return this;
  }
  merge(others, use32BitsIndices = false, forceCloneIndices = false) {
    const vertexDatas = Array.isArray(others) ? others.map((other) => [other, void 0]) : [[others, void 0]];
    return runCoroutineSync(this._mergeCoroutine(void 0, vertexDatas, use32BitsIndices, false, forceCloneIndices));
  }
  *_mergeCoroutine(transform, vertexDatas, use32BitsIndices = false, isAsync, forceCloneIndices) {
    var _a, _b, _c, _d;
    this._validate();
    const others = vertexDatas.map((vertexData) => vertexData[0]);
    for (const other of others) {
      other._validate();
      if (!this.normals !== !other.normals || !this.tangents !== !other.tangents || !this.uvs !== !other.uvs || !this.uvs2 !== !other.uvs2 || !this.uvs3 !== !other.uvs3 || !this.uvs4 !== !other.uvs4 || !this.uvs5 !== !other.uvs5 || !this.uvs6 !== !other.uvs6 || !this.colors !== !other.colors || !this.matricesIndices !== !other.matricesIndices || !this.matricesWeights !== !other.matricesWeights || !this.matricesIndicesExtra !== !other.matricesIndicesExtra || !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {
        throw new Error("Cannot merge vertex data that do not have the same set of attributes");
      }
    }
    const totalIndices = others.reduce((indexSum, vertexData) => {
      var _a2, _b2;
      return indexSum + ((_b2 = (_a2 = vertexData.indices) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b2 !== void 0 ? _b2 : 0);
    }, (_b = (_a = this.indices) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
    const sliceIndices = forceCloneIndices || others.some((vertexData) => vertexData.indices === this.indices);
    let indices = sliceIndices ? (_c = this.indices) === null || _c === void 0 ? void 0 : _c.slice() : this.indices;
    if (totalIndices > 0) {
      let indicesOffset = (_d = indices === null || indices === void 0 ? void 0 : indices.length) !== null && _d !== void 0 ? _d : 0;
      if (!indices) {
        indices = new Array(totalIndices);
      }
      if (indices.length !== totalIndices) {
        if (Array.isArray(indices)) {
          indices.length = totalIndices;
        } else {
          const temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);
          temp.set(indices);
          indices = temp;
        }
        if (transform && transform.determinant() < 0) {
          VertexData._FlipFaces(indices, 0, indicesOffset);
        }
      }
      let positionsOffset = this.positions ? this.positions.length / 3 : 0;
      for (const [other, transform2] of vertexDatas) {
        if (other.indices) {
          for (let index = 0; index < other.indices.length; index++) {
            indices[indicesOffset + index] = other.indices[index] + positionsOffset;
          }
          if (transform2 && transform2.determinant() < 0) {
            VertexData._FlipFaces(indices, indicesOffset, other.indices.length);
          }
          positionsOffset += other.positions.length / 3;
          indicesOffset += other.indices.length;
          if (isAsync) {
            yield;
          }
        }
      }
    }
    this.indices = indices;
    this.positions = VertexData._MergeElement(VertexBuffer.PositionKind, this.positions, transform, vertexDatas.map((other) => [other[0].positions, other[1]]));
    if (isAsync) {
      yield;
    }
    this.normals = VertexData._MergeElement(VertexBuffer.NormalKind, this.normals, transform, vertexDatas.map((other) => [other[0].normals, other[1]]));
    if (isAsync) {
      yield;
    }
    this.tangents = VertexData._MergeElement(VertexBuffer.TangentKind, this.tangents, transform, vertexDatas.map((other) => [other[0].tangents, other[1]]));
    if (isAsync) {
      yield;
    }
    this.uvs = VertexData._MergeElement(VertexBuffer.UVKind, this.uvs, transform, vertexDatas.map((other) => [other[0].uvs, other[1]]));
    if (isAsync) {
      yield;
    }
    this.uvs2 = VertexData._MergeElement(VertexBuffer.UV2Kind, this.uvs2, transform, vertexDatas.map((other) => [other[0].uvs2, other[1]]));
    if (isAsync) {
      yield;
    }
    this.uvs3 = VertexData._MergeElement(VertexBuffer.UV3Kind, this.uvs3, transform, vertexDatas.map((other) => [other[0].uvs3, other[1]]));
    if (isAsync) {
      yield;
    }
    this.uvs4 = VertexData._MergeElement(VertexBuffer.UV4Kind, this.uvs4, transform, vertexDatas.map((other) => [other[0].uvs4, other[1]]));
    if (isAsync) {
      yield;
    }
    this.uvs5 = VertexData._MergeElement(VertexBuffer.UV5Kind, this.uvs5, transform, vertexDatas.map((other) => [other[0].uvs5, other[1]]));
    if (isAsync) {
      yield;
    }
    this.uvs6 = VertexData._MergeElement(VertexBuffer.UV6Kind, this.uvs6, transform, vertexDatas.map((other) => [other[0].uvs6, other[1]]));
    if (isAsync) {
      yield;
    }
    this.colors = VertexData._MergeElement(VertexBuffer.ColorKind, this.colors, transform, vertexDatas.map((other) => [other[0].colors, other[1]]));
    if (isAsync) {
      yield;
    }
    this.matricesIndices = VertexData._MergeElement(VertexBuffer.MatricesIndicesKind, this.matricesIndices, transform, vertexDatas.map((other) => [other[0].matricesIndices, other[1]]));
    if (isAsync) {
      yield;
    }
    this.matricesWeights = VertexData._MergeElement(VertexBuffer.MatricesWeightsKind, this.matricesWeights, transform, vertexDatas.map((other) => [other[0].matricesWeights, other[1]]));
    if (isAsync) {
      yield;
    }
    this.matricesIndicesExtra = VertexData._MergeElement(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, transform, vertexDatas.map((other) => [other[0].matricesIndicesExtra, other[1]]));
    if (isAsync) {
      yield;
    }
    this.matricesWeightsExtra = VertexData._MergeElement(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, transform, vertexDatas.map((other) => [other[0].matricesWeightsExtra, other[1]]));
    return this;
  }
  static _MergeElement(kind, source, transform, others) {
    const nonNullOthers = others.filter((other) => other[0] !== null && other[0] !== void 0);
    if (!source && nonNullOthers.length == 0) {
      return source;
    }
    if (!source) {
      return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));
    }
    const len = nonNullOthers.reduce((sumLen, elements) => sumLen + elements[0].length, source.length);
    const transformRange = kind === VertexBuffer.PositionKind ? VertexData._TransformVector3Coordinates : kind === VertexBuffer.NormalKind ? VertexData._TransformVector3Normals : kind === VertexBuffer.TangentKind ? VertexData._TransformVector4Normals : () => {
    };
    if (source instanceof Float32Array) {
      const ret32 = new Float32Array(len);
      ret32.set(source);
      transform && transformRange(ret32, transform, 0, source.length);
      let offset = source.length;
      for (const [vertexData, transform2] of nonNullOthers) {
        ret32.set(vertexData, offset);
        transform2 && transformRange(ret32, transform2, offset, vertexData.length);
        offset += vertexData.length;
      }
      return ret32;
    } else {
      const ret = new Array(len);
      for (let i = 0; i < source.length; i++) {
        ret[i] = source[i];
      }
      transform && transformRange(ret, transform, 0, source.length);
      let offset = source.length;
      for (const [vertexData, transform2] of nonNullOthers) {
        for (let i = 0; i < vertexData.length; i++) {
          ret[offset + i] = vertexData[i];
        }
        transform2 && transformRange(ret, transform2, offset, vertexData.length);
        offset += vertexData.length;
      }
      return ret;
    }
  }
  _validate() {
    if (!this.positions) {
      throw new RuntimeError("Positions are required", ErrorCodes.MeshInvalidPositionsError);
    }
    const getElementCount = (kind, values) => {
      const stride = VertexBuffer.DeduceStride(kind);
      if (values.length % stride !== 0) {
        throw new Error("The " + kind + "s array count must be a multiple of " + stride);
      }
      return values.length / stride;
    };
    const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);
    const validateElementCount = (kind, values) => {
      const elementCount = getElementCount(kind, values);
      if (elementCount !== positionsElementCount) {
        throw new Error("The " + kind + "s element count (" + elementCount + ") does not match the positions count (" + positionsElementCount + ")");
      }
    };
    if (this.normals) {
      validateElementCount(VertexBuffer.NormalKind, this.normals);
    }
    if (this.tangents) {
      validateElementCount(VertexBuffer.TangentKind, this.tangents);
    }
    if (this.uvs) {
      validateElementCount(VertexBuffer.UVKind, this.uvs);
    }
    if (this.uvs2) {
      validateElementCount(VertexBuffer.UV2Kind, this.uvs2);
    }
    if (this.uvs3) {
      validateElementCount(VertexBuffer.UV3Kind, this.uvs3);
    }
    if (this.uvs4) {
      validateElementCount(VertexBuffer.UV4Kind, this.uvs4);
    }
    if (this.uvs5) {
      validateElementCount(VertexBuffer.UV5Kind, this.uvs5);
    }
    if (this.uvs6) {
      validateElementCount(VertexBuffer.UV6Kind, this.uvs6);
    }
    if (this.colors) {
      validateElementCount(VertexBuffer.ColorKind, this.colors);
    }
    if (this.matricesIndices) {
      validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);
    }
    if (this.matricesWeights) {
      validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);
    }
    if (this.matricesIndicesExtra) {
      validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);
    }
    if (this.matricesWeightsExtra) {
      validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);
    }
  }
  serialize() {
    const serializationObject = {};
    if (this.positions) {
      serializationObject.positions = this.positions;
    }
    if (this.normals) {
      serializationObject.normals = this.normals;
    }
    if (this.tangents) {
      serializationObject.tangents = this.tangents;
    }
    if (this.uvs) {
      serializationObject.uvs = this.uvs;
    }
    if (this.uvs2) {
      serializationObject.uvs2 = this.uvs2;
    }
    if (this.uvs3) {
      serializationObject.uvs3 = this.uvs3;
    }
    if (this.uvs4) {
      serializationObject.uvs4 = this.uvs4;
    }
    if (this.uvs5) {
      serializationObject.uvs5 = this.uvs5;
    }
    if (this.uvs6) {
      serializationObject.uvs6 = this.uvs6;
    }
    if (this.colors) {
      serializationObject.colors = this.colors;
    }
    if (this.matricesIndices) {
      serializationObject.matricesIndices = this.matricesIndices;
      serializationObject.matricesIndices._isExpanded = true;
    }
    if (this.matricesWeights) {
      serializationObject.matricesWeights = this.matricesWeights;
    }
    if (this.matricesIndicesExtra) {
      serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;
      serializationObject.matricesIndicesExtra._isExpanded = true;
    }
    if (this.matricesWeightsExtra) {
      serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;
    }
    serializationObject.indices = this.indices;
    return serializationObject;
  }
  static ExtractFromMesh(mesh, copyWhenShared, forceCopy) {
    return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);
  }
  static ExtractFromGeometry(geometry, copyWhenShared, forceCopy) {
    return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);
  }
  static _ExtractFrom(meshOrGeometry, copyWhenShared, forceCopy) {
    const result = new VertexData();
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {
      result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
      result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {
      result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {
      result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {
      result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {
      result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {
      result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
      result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {
      result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {
      result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);
    }
    result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);
    return result;
  }
  static CreateRibbon(options) {
    throw _WarnImport("ribbonBuilder");
  }
  static CreateBox(options) {
    throw _WarnImport("boxBuilder");
  }
  static CreateTiledBox(options) {
    throw _WarnImport("tiledBoxBuilder");
  }
  static CreateTiledPlane(options) {
    throw _WarnImport("tiledPlaneBuilder");
  }
  static CreateSphere(options) {
    throw _WarnImport("sphereBuilder");
  }
  static CreateCylinder(options) {
    throw _WarnImport("cylinderBuilder");
  }
  static CreateTorus(options) {
    throw _WarnImport("torusBuilder");
  }
  static CreateLineSystem(options) {
    throw _WarnImport("linesBuilder");
  }
  static CreateDashedLines(options) {
    throw _WarnImport("linesBuilder");
  }
  static CreateGround(options) {
    throw _WarnImport("groundBuilder");
  }
  static CreateTiledGround(options) {
    throw _WarnImport("groundBuilder");
  }
  static CreateGroundFromHeightMap(options) {
    throw _WarnImport("groundBuilder");
  }
  static CreatePlane(options) {
    throw _WarnImport("planeBuilder");
  }
  static CreateDisc(options) {
    throw _WarnImport("discBuilder");
  }
  static CreatePolygon(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrap) {
    throw _WarnImport("polygonBuilder");
  }
  static CreateIcoSphere(options) {
    throw _WarnImport("icoSphereBuilder");
  }
  static CreatePolyhedron(options) {
    throw _WarnImport("polyhedronBuilder");
  }
  static CreateCapsule(options = {
    orientation: Vector3.Up(),
    subdivisions: 2,
    tessellation: 16,
    height: 1,
    radius: 0.25,
    capSubdivisions: 6
  }) {
    throw _WarnImport("capsuleBuilder");
  }
  static CreateTorusKnot(options) {
    throw _WarnImport("torusKnotBuilder");
  }
  static ComputeNormals(positions, indices, normals, options) {
    let index = 0;
    let p1p2x = 0;
    let p1p2y = 0;
    let p1p2z = 0;
    let p3p2x = 0;
    let p3p2y = 0;
    let p3p2z = 0;
    let faceNormalx = 0;
    let faceNormaly = 0;
    let faceNormalz = 0;
    let length = 0;
    let v1x = 0;
    let v1y = 0;
    let v1z = 0;
    let v2x = 0;
    let v2y = 0;
    let v2z = 0;
    let v3x = 0;
    let v3y = 0;
    let v3z = 0;
    let computeFacetNormals = false;
    let computeFacetPositions = false;
    let computeFacetPartitioning = false;
    let computeDepthSort = false;
    let faceNormalSign = 1;
    let ratio = 0;
    let distanceTo = null;
    if (options) {
      computeFacetNormals = options.facetNormals ? true : false;
      computeFacetPositions = options.facetPositions ? true : false;
      computeFacetPartitioning = options.facetPartitioning ? true : false;
      faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;
      ratio = options.ratio || 0;
      computeDepthSort = options.depthSort ? true : false;
      distanceTo = options.distanceTo;
      if (computeDepthSort) {
        if (distanceTo === void 0) {
          distanceTo = Vector3.Zero();
        }
      }
    }
    let xSubRatio = 0;
    let ySubRatio = 0;
    let zSubRatio = 0;
    let subSq = 0;
    if (computeFacetPartitioning && options && options.bbSize) {
      xSubRatio = options.subDiv.X * ratio / options.bbSize.x;
      ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;
      zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;
      subSq = options.subDiv.max * options.subDiv.max;
      options.facetPartitioning.length = 0;
    }
    for (index = 0; index < positions.length; index++) {
      normals[index] = 0;
    }
    const nbFaces = indices.length / 3 | 0;
    for (index = 0; index < nbFaces; index++) {
      v1x = indices[index * 3] * 3;
      v1y = v1x + 1;
      v1z = v1x + 2;
      v2x = indices[index * 3 + 1] * 3;
      v2y = v2x + 1;
      v2z = v2x + 2;
      v3x = indices[index * 3 + 2] * 3;
      v3y = v3x + 1;
      v3z = v3x + 2;
      p1p2x = positions[v1x] - positions[v2x];
      p1p2y = positions[v1y] - positions[v2y];
      p1p2z = positions[v1z] - positions[v2z];
      p3p2x = positions[v3x] - positions[v2x];
      p3p2y = positions[v3y] - positions[v2y];
      p3p2z = positions[v3z] - positions[v2z];
      faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);
      faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);
      faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);
      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
      length = length === 0 ? 1 : length;
      faceNormalx /= length;
      faceNormaly /= length;
      faceNormalz /= length;
      if (computeFacetNormals && options) {
        options.facetNormals[index].x = faceNormalx;
        options.facetNormals[index].y = faceNormaly;
        options.facetNormals[index].z = faceNormalz;
      }
      if (computeFacetPositions && options) {
        options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3;
        options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3;
        options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3;
      }
      if (computeFacetPartitioning && options) {
        const ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);
        const oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);
        const oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);
        const b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        const b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        const b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        const b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        const b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        const b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        const b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        const b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        const b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        const block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;
        const block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;
        const block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;
        const block_idx_o = ox + options.subDiv.max * oy + subSq * oz;
        options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();
        options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();
        options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();
        options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();
        options.facetPartitioning[block_idx_v1].push(index);
        if (block_idx_v2 != block_idx_v1) {
          options.facetPartitioning[block_idx_v2].push(index);
        }
        if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {
          options.facetPartitioning[block_idx_v3].push(index);
        }
        if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {
          options.facetPartitioning[block_idx_o].push(index);
        }
      }
      if (computeDepthSort && options && options.facetPositions) {
        const dsf = options.depthSortedFacets[index];
        dsf.ind = index * 3;
        dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo);
      }
      normals[v1x] += faceNormalx;
      normals[v1y] += faceNormaly;
      normals[v1z] += faceNormalz;
      normals[v2x] += faceNormalx;
      normals[v2y] += faceNormaly;
      normals[v2z] += faceNormalz;
      normals[v3x] += faceNormalx;
      normals[v3y] += faceNormaly;
      normals[v3z] += faceNormalz;
    }
    for (index = 0; index < normals.length / 3; index++) {
      faceNormalx = normals[index * 3];
      faceNormaly = normals[index * 3 + 1];
      faceNormalz = normals[index * 3 + 2];
      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
      length = length === 0 ? 1 : length;
      faceNormalx /= length;
      faceNormaly /= length;
      faceNormalz /= length;
      normals[index * 3] = faceNormalx;
      normals[index * 3 + 1] = faceNormaly;
      normals[index * 3 + 2] = faceNormalz;
    }
  }
  static _ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {
    const li = indices.length;
    const ln = normals.length;
    let i;
    let n;
    sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;
    switch (sideOrientation) {
      case VertexData.FRONTSIDE:
        break;
      case VertexData.BACKSIDE:
        for (i = 0; i < li; i += 3) {
          const tmp = indices[i];
          indices[i] = indices[i + 2];
          indices[i + 2] = tmp;
        }
        for (n = 0; n < ln; n++) {
          normals[n] = -normals[n];
        }
        break;
      case VertexData.DOUBLESIDE: {
        const lp = positions.length;
        const l = lp / 3;
        for (let p = 0; p < lp; p++) {
          positions[lp + p] = positions[p];
        }
        for (i = 0; i < li; i += 3) {
          indices[i + li] = indices[i + 2] + l;
          indices[i + 1 + li] = indices[i + 1] + l;
          indices[i + 2 + li] = indices[i] + l;
        }
        for (n = 0; n < ln; n++) {
          normals[ln + n] = -normals[n];
        }
        const lu = uvs.length;
        let u = 0;
        for (u = 0; u < lu; u++) {
          uvs[u + lu] = uvs[u];
        }
        frontUVs = frontUVs ? frontUVs : new Vector4(0, 0, 1, 1);
        backUVs = backUVs ? backUVs : new Vector4(0, 0, 1, 1);
        u = 0;
        for (i = 0; i < lu / 2; i++) {
          uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];
          uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];
          uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];
          uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];
          u += 2;
        }
        break;
      }
    }
  }
  static ImportVertexData(parsedVertexData, geometry) {
    const vertexData = new VertexData();
    const positions = parsedVertexData.positions;
    if (positions) {
      vertexData.set(positions, VertexBuffer.PositionKind);
    }
    const normals = parsedVertexData.normals;
    if (normals) {
      vertexData.set(normals, VertexBuffer.NormalKind);
    }
    const tangents = parsedVertexData.tangents;
    if (tangents) {
      vertexData.set(tangents, VertexBuffer.TangentKind);
    }
    const uvs = parsedVertexData.uvs;
    if (uvs) {
      vertexData.set(uvs, VertexBuffer.UVKind);
    }
    const uv2s = parsedVertexData.uv2s;
    if (uv2s) {
      vertexData.set(uv2s, VertexBuffer.UV2Kind);
    }
    const uv3s = parsedVertexData.uv3s;
    if (uv3s) {
      vertexData.set(uv3s, VertexBuffer.UV3Kind);
    }
    const uv4s = parsedVertexData.uv4s;
    if (uv4s) {
      vertexData.set(uv4s, VertexBuffer.UV4Kind);
    }
    const uv5s = parsedVertexData.uv5s;
    if (uv5s) {
      vertexData.set(uv5s, VertexBuffer.UV5Kind);
    }
    const uv6s = parsedVertexData.uv6s;
    if (uv6s) {
      vertexData.set(uv6s, VertexBuffer.UV6Kind);
    }
    const colors = parsedVertexData.colors;
    if (colors) {
      vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);
    }
    const matricesIndices = parsedVertexData.matricesIndices;
    if (matricesIndices) {
      vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);
    }
    const matricesWeights = parsedVertexData.matricesWeights;
    if (matricesWeights) {
      vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);
    }
    const indices = parsedVertexData.indices;
    if (indices) {
      vertexData.indices = indices;
    }
    geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);
  }
};
VertexData.FRONTSIDE = 0;
VertexData.BACKSIDE = 1;
VertexData.DOUBLESIDE = 2;
VertexData.DEFAULTSIDE = 0;
__decorate([
  nativeOverride.filter((...[coordinates]) => !Array.isArray(coordinates))
], VertexData, "_TransformVector3Coordinates", null);
__decorate([
  nativeOverride.filter((...[normals]) => !Array.isArray(normals))
], VertexData, "_TransformVector3Normals", null);
__decorate([
  nativeOverride.filter((...[normals]) => !Array.isArray(normals))
], VertexData, "_TransformVector4Normals", null);
__decorate([
  nativeOverride.filter((...[indices]) => !Array.isArray(indices))
], VertexData, "_FlipFaces", null);

// node_modules/@babylonjs/core/Collisions/intersectionInfo.js
var IntersectionInfo = class {
  constructor(bu, bv, distance) {
    this.bu = bu;
    this.bv = bv;
    this.distance = distance;
    this.faceId = 0;
    this.subMeshId = 0;
  }
};

// node_modules/@babylonjs/core/Culling/boundingBox.js
var BoundingBox = class {
  constructor(min, max, worldMatrix) {
    this.vectors = ArrayTools.BuildArray(8, Vector3.Zero);
    this.center = Vector3.Zero();
    this.centerWorld = Vector3.Zero();
    this.extendSize = Vector3.Zero();
    this.extendSizeWorld = Vector3.Zero();
    this.directions = ArrayTools.BuildArray(3, Vector3.Zero);
    this.vectorsWorld = ArrayTools.BuildArray(8, Vector3.Zero);
    this.minimumWorld = Vector3.Zero();
    this.maximumWorld = Vector3.Zero();
    this.minimum = Vector3.Zero();
    this.maximum = Vector3.Zero();
    this._drawWrapperFront = null;
    this._drawWrapperBack = null;
    this.reConstruct(min, max, worldMatrix);
  }
  reConstruct(min, max, worldMatrix) {
    const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    const vectors = this.vectors;
    this.minimum.copyFromFloats(minX, minY, minZ);
    this.maximum.copyFromFloats(maxX, maxY, maxZ);
    vectors[0].copyFromFloats(minX, minY, minZ);
    vectors[1].copyFromFloats(maxX, maxY, maxZ);
    vectors[2].copyFromFloats(maxX, minY, minZ);
    vectors[3].copyFromFloats(minX, maxY, minZ);
    vectors[4].copyFromFloats(minX, minY, maxZ);
    vectors[5].copyFromFloats(maxX, maxY, minZ);
    vectors[6].copyFromFloats(minX, maxY, maxZ);
    vectors[7].copyFromFloats(maxX, minY, maxZ);
    max.addToRef(min, this.center).scaleInPlace(0.5);
    max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);
    this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;
    this._update(this._worldMatrix);
  }
  scale(factor) {
    const tmpVectors = BoundingBox._TmpVector3;
    const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);
    const len = diff.length();
    diff.normalizeFromLength(len);
    const distance = len * factor;
    const newRadius = diff.scaleInPlace(distance * 0.5);
    const min = this.center.subtractToRef(newRadius, tmpVectors[1]);
    const max = this.center.addToRef(newRadius, tmpVectors[2]);
    this.reConstruct(min, max, this._worldMatrix);
    return this;
  }
  getWorldMatrix() {
    return this._worldMatrix;
  }
  _update(world) {
    const minWorld = this.minimumWorld;
    const maxWorld = this.maximumWorld;
    const directions = this.directions;
    const vectorsWorld = this.vectorsWorld;
    const vectors = this.vectors;
    if (!world.isIdentity()) {
      minWorld.setAll(Number.MAX_VALUE);
      maxWorld.setAll(-Number.MAX_VALUE);
      for (let index = 0; index < 8; ++index) {
        const v = vectorsWorld[index];
        Vector3.TransformCoordinatesToRef(vectors[index], world, v);
        minWorld.minimizeInPlace(v);
        maxWorld.maximizeInPlace(v);
      }
      maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);
      maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);
    } else {
      minWorld.copyFrom(this.minimum);
      maxWorld.copyFrom(this.maximum);
      for (let index = 0; index < 8; ++index) {
        vectorsWorld[index].copyFrom(vectors[index]);
      }
      this.extendSizeWorld.copyFrom(this.extendSize);
      this.centerWorld.copyFrom(this.center);
    }
    Vector3.FromArrayToRef(world.m, 0, directions[0]);
    Vector3.FromArrayToRef(world.m, 4, directions[1]);
    Vector3.FromArrayToRef(world.m, 8, directions[2]);
    this._worldMatrix = world;
  }
  isInFrustum(frustumPlanes) {
    return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);
  }
  isCompletelyInFrustum(frustumPlanes) {
    return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);
  }
  intersectsPoint(point) {
    const min = this.minimumWorld;
    const max = this.maximumWorld;
    const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    const pointX = point.x, pointY = point.y, pointZ = point.z;
    const delta = -Epsilon;
    if (maxX - pointX < delta || delta > pointX - minX) {
      return false;
    }
    if (maxY - pointY < delta || delta > pointY - minY) {
      return false;
    }
    if (maxZ - pointZ < delta || delta > pointZ - minZ) {
      return false;
    }
    return true;
  }
  intersectsSphere(sphere) {
    return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);
  }
  intersectsMinMax(min, max) {
    const myMin = this.minimumWorld;
    const myMax = this.maximumWorld;
    const myMinX = myMin.x, myMinY = myMin.y, myMinZ = myMin.z, myMaxX = myMax.x, myMaxY = myMax.y, myMaxZ = myMax.z;
    const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    if (myMaxX < minX || myMinX > maxX) {
      return false;
    }
    if (myMaxY < minY || myMinY > maxY) {
      return false;
    }
    if (myMaxZ < minZ || myMinZ > maxZ) {
      return false;
    }
    return true;
  }
  dispose() {
    var _a, _b;
    (_a = this._drawWrapperFront) === null || _a === void 0 ? void 0 : _a.dispose();
    (_b = this._drawWrapperBack) === null || _b === void 0 ? void 0 : _b.dispose();
  }
  static Intersects(box0, box1) {
    return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);
  }
  static IntersectsSphere(minPoint, maxPoint, sphereCenter, sphereRadius) {
    const vector = BoundingBox._TmpVector3[0];
    Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);
    const num = Vector3.DistanceSquared(sphereCenter, vector);
    return num <= sphereRadius * sphereRadius;
  }
  static IsCompletelyInFrustum(boundingVectors, frustumPlanes) {
    for (let p = 0; p < 6; ++p) {
      const frustumPlane = frustumPlanes[p];
      for (let i = 0; i < 8; ++i) {
        if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {
          return false;
        }
      }
    }
    return true;
  }
  static IsInFrustum(boundingVectors, frustumPlanes) {
    for (let p = 0; p < 6; ++p) {
      let canReturnFalse = true;
      const frustumPlane = frustumPlanes[p];
      for (let i = 0; i < 8; ++i) {
        if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {
          canReturnFalse = false;
          break;
        }
      }
      if (canReturnFalse) {
        return false;
      }
    }
    return true;
  }
};
BoundingBox._TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);

// node_modules/@babylonjs/core/Culling/boundingSphere.js
var BoundingSphere = class {
  constructor(min, max, worldMatrix) {
    this.center = Vector3.Zero();
    this.centerWorld = Vector3.Zero();
    this.minimum = Vector3.Zero();
    this.maximum = Vector3.Zero();
    this.reConstruct(min, max, worldMatrix);
  }
  reConstruct(min, max, worldMatrix) {
    this.minimum.copyFrom(min);
    this.maximum.copyFrom(max);
    const distance = Vector3.Distance(min, max);
    max.addToRef(min, this.center).scaleInPlace(0.5);
    this.radius = distance * 0.5;
    this._update(worldMatrix || Matrix.IdentityReadOnly);
  }
  scale(factor) {
    const newRadius = this.radius * factor;
    const tmpVectors = BoundingSphere._TmpVector3;
    const tempRadiusVector = tmpVectors[0].setAll(newRadius);
    const min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);
    const max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);
    this.reConstruct(min, max, this._worldMatrix);
    return this;
  }
  getWorldMatrix() {
    return this._worldMatrix;
  }
  _update(worldMatrix) {
    if (!worldMatrix.isIdentity()) {
      Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);
      const tempVector = BoundingSphere._TmpVector3[0];
      Vector3.TransformNormalFromFloatsToRef(1, 1, 1, worldMatrix, tempVector);
      this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;
    } else {
      this.centerWorld.copyFrom(this.center);
      this.radiusWorld = this.radius;
    }
  }
  isInFrustum(frustumPlanes) {
    const center = this.centerWorld;
    const radius = this.radiusWorld;
    for (let i = 0; i < 6; i++) {
      if (frustumPlanes[i].dotCoordinate(center) <= -radius) {
        return false;
      }
    }
    return true;
  }
  isCenterInFrustum(frustumPlanes) {
    const center = this.centerWorld;
    for (let i = 0; i < 6; i++) {
      if (frustumPlanes[i].dotCoordinate(center) < 0) {
        return false;
      }
    }
    return true;
  }
  intersectsPoint(point) {
    const squareDistance = Vector3.DistanceSquared(this.centerWorld, point);
    if (this.radiusWorld * this.radiusWorld < squareDistance) {
      return false;
    }
    return true;
  }
  static Intersects(sphere0, sphere1) {
    const squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);
    const radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;
    if (radiusSum * radiusSum < squareDistance) {
      return false;
    }
    return true;
  }
  static CreateFromCenterAndRadius(center, radius, matrix) {
    this._TmpVector3[0].copyFrom(center);
    this._TmpVector3[1].copyFromFloats(0, 0, radius);
    this._TmpVector3[2].copyFrom(center);
    this._TmpVector3[0].addInPlace(this._TmpVector3[1]);
    this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);
    const sphere = new BoundingSphere(this._TmpVector3[0], this._TmpVector3[2]);
    if (matrix) {
      sphere._worldMatrix = matrix;
    } else {
      sphere._worldMatrix = Matrix.Identity();
    }
    return sphere;
  }
};
BoundingSphere._TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);

// node_modules/@babylonjs/core/Culling/boundingInfo.js
var _result0 = { min: 0, max: 0 };
var _result1 = { min: 0, max: 0 };
var computeBoxExtents = (axis, box, result) => {
  const p = Vector3.Dot(box.centerWorld, axis);
  const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;
  const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;
  const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;
  const r = r0 + r1 + r2;
  result.min = p - r;
  result.max = p + r;
};
var axisOverlap = (axis, box0, box1) => {
  computeBoxExtents(axis, box0, _result0);
  computeBoxExtents(axis, box1, _result1);
  return !(_result0.min > _result1.max || _result1.min > _result0.max);
};
var BoundingInfo = class {
  constructor(minimum, maximum, worldMatrix) {
    this._isLocked = false;
    this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);
    this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);
  }
  reConstruct(min, max, worldMatrix) {
    this.boundingBox.reConstruct(min, max, worldMatrix);
    this.boundingSphere.reConstruct(min, max, worldMatrix);
  }
  get minimum() {
    return this.boundingBox.minimum;
  }
  get maximum() {
    return this.boundingBox.maximum;
  }
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(value) {
    this._isLocked = value;
  }
  update(world) {
    if (this._isLocked) {
      return;
    }
    this.boundingBox._update(world);
    this.boundingSphere._update(world);
  }
  centerOn(center, extend) {
    const minimum = BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);
    const maximum = BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);
    this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    return this;
  }
  encapsulate(point) {
    const minimum = Vector3.Minimize(this.minimum, point);
    const maximum = Vector3.Maximize(this.maximum, point);
    this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    return this;
  }
  encapsulateBoundingInfo(toEncapsulate) {
    this.encapsulate(toEncapsulate.boundingBox.centerWorld.subtract(toEncapsulate.boundingBox.extendSizeWorld));
    this.encapsulate(toEncapsulate.boundingBox.centerWorld.add(toEncapsulate.boundingBox.extendSizeWorld));
    return this;
  }
  scale(factor) {
    this.boundingBox.scale(factor);
    this.boundingSphere.scale(factor);
    return this;
  }
  isInFrustum(frustumPlanes, strategy = 0) {
    const inclusionTest = strategy === 2 || strategy === 3;
    if (inclusionTest) {
      if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {
        return true;
      }
    }
    if (!this.boundingSphere.isInFrustum(frustumPlanes)) {
      return false;
    }
    const bSphereOnlyTest = strategy === 1 || strategy === 3;
    if (bSphereOnlyTest) {
      return true;
    }
    return this.boundingBox.isInFrustum(frustumPlanes);
  }
  get diagonalLength() {
    const boundingBox = this.boundingBox;
    const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo._TmpVector3[0]);
    return diag.length();
  }
  isCompletelyInFrustum(frustumPlanes) {
    return this.boundingBox.isCompletelyInFrustum(frustumPlanes);
  }
  _checkCollision(collider) {
    return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);
  }
  intersectsPoint(point) {
    if (!this.boundingSphere.centerWorld) {
      return false;
    }
    if (!this.boundingSphere.intersectsPoint(point)) {
      return false;
    }
    if (!this.boundingBox.intersectsPoint(point)) {
      return false;
    }
    return true;
  }
  intersects(boundingInfo, precise) {
    if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {
      return false;
    }
    if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {
      return false;
    }
    if (!precise) {
      return true;
    }
    const box0 = this.boundingBox;
    const box1 = boundingInfo.boundingBox;
    if (!axisOverlap(box0.directions[0], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box0.directions[1], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box0.directions[2], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box1.directions[0], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box1.directions[1], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box1.directions[2], box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {
      return false;
    }
    return true;
  }
};
BoundingInfo._TmpVector3 = ArrayTools.BuildArray(2, Vector3.Zero);

// node_modules/@babylonjs/core/Maths/math.functions.js
var MathHelpers = class {
  static extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum) {
    for (let index = indexStart; index < indexStart + indexCount; index++) {
      const offset = indices[index] * 3;
      const x = positions[offset];
      const y = positions[offset + 1];
      const z = positions[offset + 2];
      minimum.minimizeInPlaceFromFloats(x, y, z);
      maximum.maximizeInPlaceFromFloats(x, y, z);
    }
  }
  static extractMinAndMax(positions, start, count, stride, minimum, maximum) {
    for (let index = start, offset = start * stride; index < start + count; index++, offset += stride) {
      const x = positions[offset];
      const y = positions[offset + 1];
      const z = positions[offset + 2];
      minimum.minimizeInPlaceFromFloats(x, y, z);
      maximum.maximizeInPlaceFromFloats(x, y, z);
    }
  }
};
__decorate([
  nativeOverride.filter((...[positions, indices]) => !Array.isArray(positions) && !Array.isArray(indices))
], MathHelpers, "extractMinAndMaxIndexed", null);
__decorate([
  nativeOverride.filter((...[positions]) => !Array.isArray(positions))
], MathHelpers, "extractMinAndMax", null);
function extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, bias = null) {
  const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);
  if (bias) {
    minimum.x -= minimum.x * bias.x + bias.y;
    minimum.y -= minimum.y * bias.x + bias.y;
    minimum.z -= minimum.z * bias.x + bias.y;
    maximum.x += maximum.x * bias.x + bias.y;
    maximum.y += maximum.y * bias.x + bias.y;
    maximum.z += maximum.z * bias.x + bias.y;
  }
  return {
    minimum,
    maximum
  };
}
function extractMinAndMax(positions, start, count, bias = null, stride) {
  const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  if (!stride) {
    stride = 3;
  }
  MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);
  if (bias) {
    minimum.x -= minimum.x * bias.x + bias.y;
    minimum.y -= minimum.y * bias.x + bias.y;
    minimum.z -= minimum.z * bias.x + bias.y;
    maximum.x += maximum.x * bias.x + bias.y;
    maximum.y += maximum.y * bias.x + bias.y;
    maximum.z += maximum.z * bias.x + bias.y;
  }
  return {
    minimum,
    maximum
  };
}

// node_modules/@babylonjs/core/Meshes/subMesh.js
var SubMesh = class {
  constructor(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox = true, addToMesh = true) {
    this.materialIndex = materialIndex;
    this.verticesStart = verticesStart;
    this.verticesCount = verticesCount;
    this.indexStart = indexStart;
    this.indexCount = indexCount;
    this._mainDrawWrapperOverride = null;
    this._linesIndexCount = 0;
    this._linesIndexBuffer = null;
    this._lastColliderWorldVertices = null;
    this._lastColliderTransformMatrix = null;
    this._wasDispatched = false;
    this._renderId = 0;
    this._alphaIndex = 0;
    this._distanceToCamera = 0;
    this._currentMaterial = null;
    this._mesh = mesh;
    this._renderingMesh = renderingMesh || mesh;
    if (addToMesh) {
      mesh.subMeshes.push(this);
    }
    this._engine = this._mesh.getScene().getEngine();
    this.resetDrawCache();
    this._trianglePlanes = [];
    this._id = mesh.subMeshes.length - 1;
    if (createBoundingBox) {
      this.refreshBoundingInfo();
      mesh.computeWorldMatrix(true);
    }
  }
  get materialDefines() {
    var _a;
    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.defines;
  }
  set materialDefines(defines) {
    var _a;
    const drawWrapper = (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(void 0, true);
    drawWrapper.defines = defines;
  }
  _getDrawWrapper(passId, createIfNotExisting = false) {
    passId = passId !== null && passId !== void 0 ? passId : this._engine.currentRenderPassId;
    let drawWrapper = this._drawWrappers[passId];
    if (!drawWrapper && createIfNotExisting) {
      this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());
    }
    return drawWrapper;
  }
  _removeDrawWrapper(passId, disposeWrapper = true) {
    var _a;
    if (disposeWrapper) {
      (_a = this._drawWrappers[passId]) === null || _a === void 0 ? void 0 : _a.dispose();
    }
    this._drawWrappers[passId] = void 0;
  }
  get effect() {
    var _a, _b;
    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (_b = (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : null;
  }
  get _drawWrapper() {
    var _a;
    return (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(void 0, true);
  }
  get _drawWrapperOverride() {
    return this._mainDrawWrapperOverride;
  }
  _setMainDrawWrapperOverride(wrapper) {
    this._mainDrawWrapperOverride = wrapper;
  }
  setEffect(effect, defines = null, materialContext, resetContext = true) {
    const drawWrapper = this._drawWrapper;
    drawWrapper.setEffect(effect, defines, resetContext);
    if (materialContext !== void 0) {
      drawWrapper.materialContext = materialContext;
    }
    if (!effect) {
      drawWrapper.defines = null;
      drawWrapper.materialContext = void 0;
    }
  }
  resetDrawCache(passId) {
    if (this._drawWrappers) {
      if (passId !== void 0) {
        this._removeDrawWrapper(passId);
        return;
      } else {
        for (const drawWrapper of this._drawWrappers) {
          drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();
        }
      }
    }
    this._drawWrappers = [];
  }
  static AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox = true) {
    return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);
  }
  get IsGlobal() {
    return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();
  }
  getBoundingInfo() {
    if (this.IsGlobal) {
      return this._mesh.getBoundingInfo();
    }
    return this._boundingInfo;
  }
  setBoundingInfo(boundingInfo) {
    this._boundingInfo = boundingInfo;
    return this;
  }
  getMesh() {
    return this._mesh;
  }
  getRenderingMesh() {
    return this._renderingMesh;
  }
  getReplacementMesh() {
    return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
  }
  getEffectiveMesh() {
    const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
    return replacementMesh ? replacementMesh : this._renderingMesh;
  }
  getMaterial(getDefaultMaterial = true) {
    var _a;
    const rootMaterial = (_a = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)) !== null && _a !== void 0 ? _a : this._renderingMesh.material;
    if (!rootMaterial) {
      return getDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;
    } else if (this._isMultiMaterial(rootMaterial)) {
      const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);
      if (this._currentMaterial !== effectiveMaterial) {
        this._currentMaterial = effectiveMaterial;
        this.resetDrawCache();
      }
      return effectiveMaterial;
    }
    return rootMaterial;
  }
  _isMultiMaterial(material) {
    return material.getSubMaterial !== void 0;
  }
  refreshBoundingInfo(data = null) {
    this._lastColliderWorldVertices = null;
    if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {
      return this;
    }
    if (!data) {
      data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);
    }
    if (!data) {
      this._boundingInfo = this._mesh.getBoundingInfo();
      return this;
    }
    const indices = this._renderingMesh.getIndices();
    let extend;
    if (this.indexStart === 0 && this.indexCount === indices.length) {
      const boundingInfo = this._renderingMesh.getBoundingInfo();
      extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };
    } else {
      extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);
    }
    if (this._boundingInfo) {
      this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
    } else {
      this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
    }
    return this;
  }
  _checkCollision(collider) {
    const boundingInfo = this.getBoundingInfo();
    return boundingInfo._checkCollision(collider);
  }
  updateBoundingInfo(world) {
    let boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      this.refreshBoundingInfo();
      boundingInfo = this.getBoundingInfo();
    }
    if (boundingInfo) {
      boundingInfo.update(world);
    }
    return this;
  }
  isInFrustum(frustumPlanes) {
    const boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      return false;
    }
    return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);
  }
  isCompletelyInFrustum(frustumPlanes) {
    const boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      return false;
    }
    return boundingInfo.isCompletelyInFrustum(frustumPlanes);
  }
  render(enableAlphaMode) {
    this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : void 0);
    return this;
  }
  _getLinesIndexBuffer(indices, engine) {
    if (!this._linesIndexBuffer) {
      const linesIndices = [];
      for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {
        linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);
      }
      this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);
      this._linesIndexCount = linesIndices.length;
    }
    return this._linesIndexBuffer;
  }
  canIntersects(ray) {
    const boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      return false;
    }
    return ray.intersectsBox(boundingInfo.boundingBox);
  }
  intersects(ray, positions, indices, fastCheck, trianglePredicate) {
    const material = this.getMaterial();
    if (!material) {
      return null;
    }
    let step = 3;
    let checkStopper = false;
    switch (material.fillMode) {
      case 3:
      case 5:
      case 6:
      case 8:
        return null;
      case 7:
        step = 1;
        checkStopper = true;
        break;
      default:
        break;
    }
    if (material.fillMode === 4) {
      if (!indices.length) {
        return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
      }
      return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
    } else {
      if (!indices.length && this._mesh._unIndexed) {
        return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);
      }
      return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);
    }
  }
  _intersectLines(ray, positions, indices, intersectionThreshold, fastCheck) {
    let intersectInfo = null;
    for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {
      const p0 = positions[indices[index]];
      const p1 = positions[indices[index + 1]];
      const length = ray.intersectionSegment(p0, p1, intersectionThreshold);
      if (length < 0) {
        continue;
      }
      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {
        intersectInfo = new IntersectionInfo(null, null, length);
        intersectInfo.faceId = index / 2;
        if (fastCheck) {
          break;
        }
      }
    }
    return intersectInfo;
  }
  _intersectUnIndexedLines(ray, positions, indices, intersectionThreshold, fastCheck) {
    let intersectInfo = null;
    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {
      const p0 = positions[index];
      const p1 = positions[index + 1];
      const length = ray.intersectionSegment(p0, p1, intersectionThreshold);
      if (length < 0) {
        continue;
      }
      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {
        intersectInfo = new IntersectionInfo(null, null, length);
        intersectInfo.faceId = index / 2;
        if (fastCheck) {
          break;
        }
      }
    }
    return intersectInfo;
  }
  _intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {
    let intersectInfo = null;
    let faceId = -1;
    for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {
      faceId++;
      const indexA = indices[index];
      const indexB = indices[index + 1];
      const indexC = indices[index + 2];
      if (checkStopper && indexC === 4294967295) {
        index += 2;
        continue;
      }
      const p0 = positions[indexA];
      const p1 = positions[indexB];
      const p2 = positions[indexC];
      if (!p0 || !p1 || !p2) {
        continue;
      }
      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, indexA, indexB, indexC)) {
        continue;
      }
      const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
      if (currentIntersectInfo) {
        if (currentIntersectInfo.distance < 0) {
          continue;
        }
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.faceId = faceId;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    return intersectInfo;
  }
  _intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate) {
    let intersectInfo = null;
    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {
      const p0 = positions[index];
      const p1 = positions[index + 1];
      const p2 = positions[index + 2];
      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, -1, -1, -1)) {
        continue;
      }
      const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
      if (currentIntersectInfo) {
        if (currentIntersectInfo.distance < 0) {
          continue;
        }
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.faceId = index / 3;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    return intersectInfo;
  }
  _rebuild() {
    if (this._linesIndexBuffer) {
      this._linesIndexBuffer = null;
    }
  }
  clone(newMesh, newRenderingMesh) {
    const result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);
    if (!this.IsGlobal) {
      const boundingInfo = this.getBoundingInfo();
      if (!boundingInfo) {
        return result;
      }
      result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);
    }
    return result;
  }
  dispose() {
    if (this._linesIndexBuffer) {
      this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);
      this._linesIndexBuffer = null;
    }
    const index = this._mesh.subMeshes.indexOf(this);
    this._mesh.subMeshes.splice(index, 1);
    this.resetDrawCache();
  }
  getClassName() {
    return "SubMesh";
  }
  static CreateFromIndices(materialIndex, startIndex, indexCount, mesh, renderingMesh, createBoundingBox = true) {
    let minVertexIndex = Number.MAX_VALUE;
    let maxVertexIndex = -Number.MAX_VALUE;
    const whatWillRender = renderingMesh || mesh;
    const indices = whatWillRender.getIndices();
    for (let index = startIndex; index < startIndex + indexCount; index++) {
      const vertexIndex = indices[index];
      if (vertexIndex < minVertexIndex) {
        minVertexIndex = vertexIndex;
      }
      if (vertexIndex > maxVertexIndex) {
        maxVertexIndex = vertexIndex;
      }
    }
    return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);
  }
};

// node_modules/@babylonjs/core/Loading/sceneLoaderFlags.js
var SceneLoaderFlags = class {
  static get ForceFullSceneLoadingForIncremental() {
    return SceneLoaderFlags._ForceFullSceneLoadingForIncremental;
  }
  static set ForceFullSceneLoadingForIncremental(value) {
    SceneLoaderFlags._ForceFullSceneLoadingForIncremental = value;
  }
  static get ShowLoadingScreen() {
    return SceneLoaderFlags._ShowLoadingScreen;
  }
  static set ShowLoadingScreen(value) {
    SceneLoaderFlags._ShowLoadingScreen = value;
  }
  static get loggingLevel() {
    return SceneLoaderFlags._LoggingLevel;
  }
  static set loggingLevel(value) {
    SceneLoaderFlags._LoggingLevel = value;
  }
  static get CleanBoneMatrixWeights() {
    return SceneLoaderFlags._CleanBoneMatrixWeights;
  }
  static set CleanBoneMatrixWeights(value) {
    SceneLoaderFlags._CleanBoneMatrixWeights = value;
  }
};
SceneLoaderFlags._ForceFullSceneLoadingForIncremental = false;
SceneLoaderFlags._ShowLoadingScreen = true;
SceneLoaderFlags._CleanBoneMatrixWeights = false;
SceneLoaderFlags._LoggingLevel = 0;

// node_modules/@babylonjs/core/Compat/compatibilityOptions.js
var CompatibilityOptions = class {
};
CompatibilityOptions.UseOpenGLOrientationForUV = false;

// node_modules/@babylonjs/core/Meshes/geometry.js
var Geometry = class {
  constructor(id, scene, vertexData, updatable = false, mesh = null) {
    this.delayLoadState = 0;
    this._totalVertices = 0;
    this._isDisposed = false;
    this._indexBufferIsUpdatable = false;
    this._positionsCache = [];
    this._parentContainer = null;
    this.useBoundingInfoFromGeometry = false;
    this._scene = scene || EngineStore.LastCreatedScene;
    if (!this._scene) {
      return;
    }
    this.id = id;
    this.uniqueId = this._scene.getUniqueId();
    this._engine = this._scene.getEngine();
    this._meshes = [];
    this._vertexBuffers = {};
    this._indices = [];
    this._updatable = updatable;
    if (vertexData) {
      this.setAllVerticesData(vertexData, updatable);
    } else {
      this._totalVertices = 0;
    }
    if (this._engine.getCaps().vertexArrayObject) {
      this._vertexArrayObjects = {};
    }
    if (mesh) {
      this.applyToMesh(mesh);
      mesh.computeWorldMatrix(true);
    }
  }
  get boundingBias() {
    return this._boundingBias;
  }
  set boundingBias(value) {
    if (this._boundingBias) {
      this._boundingBias.copyFrom(value);
    } else {
      this._boundingBias = value.clone();
    }
    this._updateBoundingInfo(true, null);
  }
  static CreateGeometryForMesh(mesh) {
    const geometry = new Geometry(Geometry.RandomId(), mesh.getScene());
    geometry.applyToMesh(mesh);
    return geometry;
  }
  get meshes() {
    return this._meshes;
  }
  get extend() {
    return this._extend;
  }
  getScene() {
    return this._scene;
  }
  getEngine() {
    return this._engine;
  }
  isReady() {
    return this.delayLoadState === 1 || this.delayLoadState === 0;
  }
  get doNotSerialize() {
    for (let index = 0; index < this._meshes.length; index++) {
      if (!this._meshes[index].doNotSerialize) {
        return false;
      }
    }
    return true;
  }
  _rebuild() {
    if (this._vertexArrayObjects) {
      this._vertexArrayObjects = {};
    }
    if (this._meshes.length !== 0 && this._indices) {
      this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);
    }
    for (const key in this._vertexBuffers) {
      const vertexBuffer = this._vertexBuffers[key];
      vertexBuffer._rebuild();
    }
  }
  setAllVerticesData(vertexData, updatable) {
    vertexData.applyToGeometry(this, updatable);
    this._notifyUpdate();
  }
  setVerticesData(kind, data, updatable = false, stride) {
    if (updatable && Array.isArray(data)) {
      data = new Float32Array(data);
    }
    const buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);
    this.setVerticesBuffer(buffer);
  }
  removeVerticesData(kind) {
    if (this._vertexBuffers[kind]) {
      this._vertexBuffers[kind].dispose();
      delete this._vertexBuffers[kind];
    }
    if (this._vertexArrayObjects) {
      this._disposeVertexArrayObjects();
    }
  }
  setVerticesBuffer(buffer, totalVertices = null, disposeExistingBuffer = true) {
    const kind = buffer.getKind();
    if (this._vertexBuffers[kind] && disposeExistingBuffer) {
      this._vertexBuffers[kind].dispose();
    }
    if (buffer._buffer) {
      buffer._buffer._increaseReferences();
    }
    this._vertexBuffers[kind] = buffer;
    const meshes = this._meshes;
    const numOfMeshes = meshes.length;
    if (kind === VertexBuffer.PositionKind) {
      const data = buffer.getData();
      if (totalVertices != null) {
        this._totalVertices = totalVertices;
      } else {
        if (data != null) {
          this._totalVertices = data.length / (buffer.type === VertexBuffer.BYTE ? buffer.byteStride : buffer.byteStride / 4);
        }
      }
      this._updateExtend(data);
      this._resetPointsArrayCache();
      for (let index = 0; index < numOfMeshes; index++) {
        const mesh = meshes[index];
        mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
        mesh._createGlobalSubMesh(mesh.isUnIndexed);
        mesh.computeWorldMatrix(true);
        mesh.synchronizeInstances();
      }
    }
    this._notifyUpdate(kind);
  }
  updateVerticesDataDirectly(kind, data, offset, useBytes = false) {
    const vertexBuffer = this.getVertexBuffer(kind);
    if (!vertexBuffer) {
      return;
    }
    vertexBuffer.updateDirectly(data, offset, useBytes);
    this._notifyUpdate(kind);
  }
  updateVerticesData(kind, data, updateExtends = false) {
    const vertexBuffer = this.getVertexBuffer(kind);
    if (!vertexBuffer) {
      return;
    }
    vertexBuffer.update(data);
    if (kind === VertexBuffer.PositionKind) {
      this._updateBoundingInfo(updateExtends, data);
    }
    this._notifyUpdate(kind);
  }
  _updateBoundingInfo(updateExtends, data) {
    if (updateExtends) {
      this._updateExtend(data);
    }
    this._resetPointsArrayCache();
    if (updateExtends) {
      const meshes = this._meshes;
      for (const mesh of meshes) {
        if (mesh.hasBoundingInfo) {
          mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);
        } else {
          mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
        }
        const subMeshes = mesh.subMeshes;
        for (const subMesh of subMeshes) {
          subMesh.refreshBoundingInfo();
        }
      }
    }
  }
  _bind(effect, indexToBind, overrideVertexBuffers, overrideVertexArrayObjects) {
    if (!effect) {
      return;
    }
    if (indexToBind === void 0) {
      indexToBind = this._indexBuffer;
    }
    const vbs = this.getVertexBuffers();
    if (!vbs) {
      return;
    }
    if (indexToBind != this._indexBuffer || !this._vertexArrayObjects && !overrideVertexArrayObjects) {
      this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);
      return;
    }
    const vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;
    if (!vaos[effect.key]) {
      vaos[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);
    }
    this._engine.bindVertexArrayObject(vaos[effect.key], indexToBind);
  }
  getTotalVertices() {
    if (!this.isReady()) {
      return 0;
    }
    return this._totalVertices;
  }
  getVerticesData(kind, copyWhenShared, forceCopy) {
    const vertexBuffer = this.getVertexBuffer(kind);
    if (!vertexBuffer) {
      return null;
    }
    return vertexBuffer.getFloatData(this._totalVertices, forceCopy || copyWhenShared && this._meshes.length !== 1);
  }
  isVertexBufferUpdatable(kind) {
    const vb = this._vertexBuffers[kind];
    if (!vb) {
      return false;
    }
    return vb.isUpdatable();
  }
  getVertexBuffer(kind) {
    if (!this.isReady()) {
      return null;
    }
    return this._vertexBuffers[kind];
  }
  getVertexBuffers() {
    if (!this.isReady()) {
      return null;
    }
    return this._vertexBuffers;
  }
  isVerticesDataPresent(kind) {
    if (!this._vertexBuffers) {
      if (this._delayInfo) {
        return this._delayInfo.indexOf(kind) !== -1;
      }
      return false;
    }
    return this._vertexBuffers[kind] !== void 0;
  }
  getVerticesDataKinds() {
    const result = [];
    let kind;
    if (!this._vertexBuffers && this._delayInfo) {
      for (kind in this._delayInfo) {
        result.push(kind);
      }
    } else {
      for (kind in this._vertexBuffers) {
        result.push(kind);
      }
    }
    return result;
  }
  updateIndices(indices, offset, gpuMemoryOnly = false) {
    if (!this._indexBuffer) {
      return;
    }
    if (!this._indexBufferIsUpdatable) {
      this.setIndices(indices, null, true);
    } else {
      const needToUpdateSubMeshes = indices.length !== this._indices.length;
      if (!gpuMemoryOnly) {
        this._indices = indices.slice();
      }
      this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);
      if (needToUpdateSubMeshes) {
        for (const mesh of this._meshes) {
          mesh._createGlobalSubMesh(true);
        }
      }
    }
  }
  setIndices(indices, totalVertices = null, updatable = false) {
    if (this._indexBuffer) {
      this._engine._releaseBuffer(this._indexBuffer);
    }
    this._indices = indices;
    this._indexBufferIsUpdatable = updatable;
    if (this._meshes.length !== 0 && this._indices) {
      this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);
    }
    if (totalVertices != void 0) {
      this._totalVertices = totalVertices;
    }
    for (const mesh of this._meshes) {
      mesh._createGlobalSubMesh(true);
      mesh.synchronizeInstances();
    }
    this._notifyUpdate();
  }
  getTotalIndices() {
    if (!this.isReady()) {
      return 0;
    }
    return this._indices.length;
  }
  getIndices(copyWhenShared, forceCopy) {
    if (!this.isReady()) {
      return null;
    }
    const orig = this._indices;
    if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {
      return orig;
    } else {
      return orig.slice();
    }
  }
  getIndexBuffer() {
    if (!this.isReady()) {
      return null;
    }
    return this._indexBuffer;
  }
  _releaseVertexArrayObject(effect = null) {
    if (!effect || !this._vertexArrayObjects) {
      return;
    }
    if (this._vertexArrayObjects[effect.key]) {
      this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);
      delete this._vertexArrayObjects[effect.key];
    }
  }
  releaseForMesh(mesh, shouldDispose) {
    const meshes = this._meshes;
    const index = meshes.indexOf(mesh);
    if (index === -1) {
      return;
    }
    meshes.splice(index, 1);
    if (this._vertexArrayObjects) {
      mesh._invalidateInstanceVertexArrayObject();
    }
    mesh._geometry = null;
    if (meshes.length === 0 && shouldDispose) {
      this.dispose();
    }
  }
  applyToMesh(mesh) {
    if (mesh._geometry === this) {
      return;
    }
    const previousGeometry = mesh._geometry;
    if (previousGeometry) {
      previousGeometry.releaseForMesh(mesh);
    }
    if (this._vertexArrayObjects) {
      mesh._invalidateInstanceVertexArrayObject();
    }
    const meshes = this._meshes;
    mesh._geometry = this;
    mesh._internalAbstractMeshDataInfo._positions = null;
    this._scene.pushGeometry(this);
    meshes.push(mesh);
    if (this.isReady()) {
      this._applyToMesh(mesh);
    } else if (this._boundingInfo) {
      mesh.setBoundingInfo(this._boundingInfo);
    }
  }
  _updateExtend(data = null) {
    if (this.useBoundingInfoFromGeometry && this._boundingInfo) {
      this._extend = {
        minimum: this._boundingInfo.minimum.clone(),
        maximum: this._boundingInfo.maximum.clone()
      };
    } else {
      if (!data) {
        data = this.getVerticesData(VertexBuffer.PositionKind);
        if (!data) {
          return;
        }
      }
      this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);
    }
  }
  _applyToMesh(mesh) {
    const numOfMeshes = this._meshes.length;
    for (const kind in this._vertexBuffers) {
      if (numOfMeshes === 1) {
        this._vertexBuffers[kind].create();
      }
      if (kind === VertexBuffer.PositionKind) {
        if (!this._extend) {
          this._updateExtend();
        }
        mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
        mesh._createGlobalSubMesh(mesh.isUnIndexed);
        mesh._updateBoundingInfo();
      }
    }
    if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {
      this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);
    }
    mesh._syncGeometryWithMorphTargetManager();
    mesh.synchronizeInstances();
  }
  _notifyUpdate(kind) {
    if (this.onGeometryUpdated) {
      this.onGeometryUpdated(this, kind);
    }
    if (this._vertexArrayObjects) {
      this._disposeVertexArrayObjects();
    }
    for (const mesh of this._meshes) {
      mesh._markSubMeshesAsAttributesDirty();
    }
  }
  load(scene, onLoaded) {
    if (this.delayLoadState === 2) {
      return;
    }
    if (this.isReady()) {
      if (onLoaded) {
        onLoaded();
      }
      return;
    }
    this.delayLoadState = 2;
    this._queueLoad(scene, onLoaded);
  }
  _queueLoad(scene, onLoaded) {
    if (!this.delayLoadingFile) {
      return;
    }
    scene.addPendingData(this);
    scene._loadFile(this.delayLoadingFile, (data) => {
      if (!this._delayLoadingFunction) {
        return;
      }
      this._delayLoadingFunction(JSON.parse(data), this);
      this.delayLoadState = 1;
      this._delayInfo = [];
      scene.removePendingData(this);
      const meshes = this._meshes;
      const numOfMeshes = meshes.length;
      for (let index = 0; index < numOfMeshes; index++) {
        this._applyToMesh(meshes[index]);
      }
      if (onLoaded) {
        onLoaded();
      }
    }, void 0, true);
  }
  toLeftHanded() {
    const tIndices = this.getIndices(false);
    if (tIndices != null && tIndices.length > 0) {
      for (let i = 0; i < tIndices.length; i += 3) {
        const tTemp = tIndices[i + 0];
        tIndices[i + 0] = tIndices[i + 2];
        tIndices[i + 2] = tTemp;
      }
      this.setIndices(tIndices);
    }
    const tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);
    if (tPositions != null && tPositions.length > 0) {
      for (let i = 0; i < tPositions.length; i += 3) {
        tPositions[i + 2] = -tPositions[i + 2];
      }
      this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);
    }
    const tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);
    if (tNormals != null && tNormals.length > 0) {
      for (let i = 0; i < tNormals.length; i += 3) {
        tNormals[i + 2] = -tNormals[i + 2];
      }
      this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);
    }
  }
  _resetPointsArrayCache() {
    this._positions = null;
  }
  _generatePointsArray() {
    if (this._positions) {
      return true;
    }
    const data = this.getVerticesData(VertexBuffer.PositionKind);
    if (!data || data.length === 0) {
      return false;
    }
    for (let index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {
      this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);
    }
    for (let index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {
      this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);
    }
    this._positionsCache.length = data.length / 3;
    this._positions = this._positionsCache;
    return true;
  }
  isDisposed() {
    return this._isDisposed;
  }
  _disposeVertexArrayObjects() {
    if (this._vertexArrayObjects) {
      for (const kind in this._vertexArrayObjects) {
        this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);
      }
      this._vertexArrayObjects = {};
      const meshes = this._meshes;
      const numOfMeshes = meshes.length;
      for (let index = 0; index < numOfMeshes; index++) {
        meshes[index]._invalidateInstanceVertexArrayObject();
      }
    }
  }
  dispose() {
    const meshes = this._meshes;
    const numOfMeshes = meshes.length;
    let index;
    for (index = 0; index < numOfMeshes; index++) {
      this.releaseForMesh(meshes[index]);
    }
    this._meshes.length = 0;
    this._disposeVertexArrayObjects();
    for (const kind in this._vertexBuffers) {
      this._vertexBuffers[kind].dispose();
    }
    this._vertexBuffers = {};
    this._totalVertices = 0;
    if (this._indexBuffer) {
      this._engine._releaseBuffer(this._indexBuffer);
    }
    this._indexBuffer = null;
    this._indices = [];
    this.delayLoadState = 0;
    this.delayLoadingFile = null;
    this._delayLoadingFunction = null;
    this._delayInfo = [];
    this._boundingInfo = null;
    this._scene.removeGeometry(this);
    if (this._parentContainer) {
      const index2 = this._parentContainer.geometries.indexOf(this);
      if (index2 > -1) {
        this._parentContainer.geometries.splice(index2, 1);
      }
      this._parentContainer = null;
    }
    this._isDisposed = true;
  }
  copy(id) {
    const vertexData = new VertexData();
    vertexData.indices = [];
    const indices = this.getIndices();
    if (indices) {
      for (let index = 0; index < indices.length; index++) {
        vertexData.indices.push(indices[index]);
      }
    }
    let updatable = false;
    let stopChecking = false;
    let kind;
    for (kind in this._vertexBuffers) {
      const data = this.getVerticesData(kind);
      if (data) {
        if (data instanceof Float32Array) {
          vertexData.set(new Float32Array(data), kind);
        } else {
          vertexData.set(data.slice(0), kind);
        }
        if (!stopChecking) {
          const vb = this.getVertexBuffer(kind);
          if (vb) {
            updatable = vb.isUpdatable();
            stopChecking = !updatable;
          }
        }
      }
    }
    const geometry = new Geometry(id, this._scene, vertexData, updatable);
    geometry.delayLoadState = this.delayLoadState;
    geometry.delayLoadingFile = this.delayLoadingFile;
    geometry._delayLoadingFunction = this._delayLoadingFunction;
    for (kind in this._delayInfo) {
      geometry._delayInfo = geometry._delayInfo || [];
      geometry._delayInfo.push(kind);
    }
    geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);
    return geometry;
  }
  serialize() {
    const serializationObject = {};
    serializationObject.id = this.id;
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.updatable = this._updatable;
    if (Tags && Tags.HasTags(this)) {
      serializationObject.tags = Tags.GetTags(this);
    }
    return serializationObject;
  }
  _toNumberArray(origin) {
    if (Array.isArray(origin)) {
      return origin;
    } else {
      return Array.prototype.slice.call(origin);
    }
  }
  clearCachedData() {
    this._indices = [];
    this._resetPointsArrayCache();
    for (const vbName in this._vertexBuffers) {
      if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {
        continue;
      }
      this._vertexBuffers[vbName]._buffer._data = null;
    }
  }
  serializeVerticeData() {
    const serializationObject = this.serialize();
    if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      serializationObject.positions = this._toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {
        serializationObject.positions._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      serializationObject.normals = this._toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {
        serializationObject.normals._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      serializationObject.tangents = this._toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {
        serializationObject.tangents._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {
      serializationObject.uvs = this._toNumberArray(this.getVerticesData(VertexBuffer.UVKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {
        serializationObject.uvs._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
      serializationObject.uv2s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {
        serializationObject.uv2s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {
      serializationObject.uv3s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {
        serializationObject.uv3s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {
      serializationObject.uv4s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {
        serializationObject.uv4s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {
      serializationObject.uv5s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {
        serializationObject.uv5s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {
      serializationObject.uv6s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {
        serializationObject.uv6s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {
      serializationObject.colors = this._toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {
        serializationObject.colors._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
      serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));
      serializationObject.matricesIndices._isExpanded = true;
      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {
        serializationObject.matricesIndices._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {
        serializationObject.matricesWeights._updatable = true;
      }
    }
    serializationObject.indices = this._toNumberArray(this.getIndices());
    return serializationObject;
  }
  static ExtractFromMesh(mesh, id) {
    const geometry = mesh._geometry;
    if (!geometry) {
      return null;
    }
    return geometry.copy(id);
  }
  static RandomId() {
    return Tools.RandomId();
  }
  static _GetGeometryByLoadedUniqueId(uniqueId, scene) {
    for (let index = 0; index < scene.geometries.length; index++) {
      if (scene.geometries[index]._loadedUniqueId === uniqueId) {
        return scene.geometries[index];
      }
    }
    return null;
  }
  static _ImportGeometry(parsedGeometry, mesh) {
    const scene = mesh.getScene();
    const geometryUniqueId = parsedGeometry.geometryUniqueId;
    const geometryId = parsedGeometry.geometryId;
    if (geometryUniqueId || geometryId) {
      const geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);
      if (geometry) {
        geometry.applyToMesh(mesh);
      }
    } else if (parsedGeometry instanceof ArrayBuffer) {
      const binaryInfo = mesh._binaryInfo;
      if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {
        const positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);
      }
      if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {
        const normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);
      }
      if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {
        const tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);
      }
      if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {
        const uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (let index = 1; index < uvsData.length; index += 2) {
            uvsData[index] = 1 - uvsData[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);
      }
      if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {
        const uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (let index = 1; index < uvs2Data.length; index += 2) {
            uvs2Data[index] = 1 - uvs2Data[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);
      }
      if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {
        const uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (let index = 1; index < uvs3Data.length; index += 2) {
            uvs3Data[index] = 1 - uvs3Data[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);
      }
      if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {
        const uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (let index = 1; index < uvs4Data.length; index += 2) {
            uvs4Data[index] = 1 - uvs4Data[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);
      }
      if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {
        const uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (let index = 1; index < uvs5Data.length; index += 2) {
            uvs5Data[index] = 1 - uvs5Data[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);
      }
      if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {
        const uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (let index = 1; index < uvs6Data.length; index += 2) {
            uvs6Data[index] = 1 - uvs6Data[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);
      }
      if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {
        const colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);
      }
      if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {
        const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);
        const floatIndices = [];
        for (let i = 0; i < matricesIndicesData.length; i++) {
          const index = matricesIndicesData[i];
          floatIndices.push(index & 255);
          floatIndices.push((index & 65280) >> 8);
          floatIndices.push((index & 16711680) >> 16);
          floatIndices.push(index >> 24 & 255);
        }
        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);
      }
      if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {
        const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);
        const floatIndices = [];
        for (let i = 0; i < matricesIndicesData.length; i++) {
          const index = matricesIndicesData[i];
          floatIndices.push(index & 255);
          floatIndices.push((index & 65280) >> 8);
          floatIndices.push((index & 16711680) >> 16);
          floatIndices.push(index >> 24 & 255);
        }
        mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);
      }
      if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {
        const matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);
      }
      if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {
        const indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);
        mesh.setIndices(indicesData, null);
      }
      if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {
        const subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);
        mesh.subMeshes = [];
        for (let i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {
          const materialIndex = subMeshesData[i * 5 + 0];
          const verticesStart = subMeshesData[i * 5 + 1];
          const verticesCount = subMeshesData[i * 5 + 2];
          const indexStart = subMeshesData[i * 5 + 3];
          const indexCount = subMeshesData[i * 5 + 4];
          SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);
        }
      }
    } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {
      mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);
      mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);
      if (parsedGeometry.tangents) {
        mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);
      }
      if (parsedGeometry.uvs) {
        mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);
      }
      if (parsedGeometry.uvs2) {
        mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);
      }
      if (parsedGeometry.uvs3) {
        mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);
      }
      if (parsedGeometry.uvs4) {
        mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);
      }
      if (parsedGeometry.uvs5) {
        mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);
      }
      if (parsedGeometry.uvs6) {
        mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);
      }
      if (parsedGeometry.colors) {
        mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);
      }
      if (parsedGeometry.matricesIndices) {
        if (!parsedGeometry.matricesIndices._isExpanded) {
          const floatIndices = [];
          for (let i = 0; i < parsedGeometry.matricesIndices.length; i++) {
            const matricesIndex = parsedGeometry.matricesIndices[i];
            floatIndices.push(matricesIndex & 255);
            floatIndices.push((matricesIndex & 65280) >> 8);
            floatIndices.push((matricesIndex & 16711680) >> 16);
            floatIndices.push(matricesIndex >> 24 & 255);
          }
          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);
        } else {
          delete parsedGeometry.matricesIndices._isExpanded;
          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);
        }
      }
      if (parsedGeometry.matricesIndicesExtra) {
        if (!parsedGeometry.matricesIndicesExtra._isExpanded) {
          const floatIndices = [];
          for (let i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {
            const matricesIndex = parsedGeometry.matricesIndicesExtra[i];
            floatIndices.push(matricesIndex & 255);
            floatIndices.push((matricesIndex & 65280) >> 8);
            floatIndices.push((matricesIndex & 16711680) >> 16);
            floatIndices.push(matricesIndex >> 24 & 255);
          }
          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);
        } else {
          delete parsedGeometry.matricesIndices._isExpanded;
          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);
        }
      }
      if (parsedGeometry.matricesWeights) {
        Geometry._CleanMatricesWeights(parsedGeometry, mesh);
        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);
      }
      if (parsedGeometry.matricesWeightsExtra) {
        mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);
      }
      mesh.setIndices(parsedGeometry.indices, null);
    }
    if (parsedGeometry.subMeshes) {
      mesh.subMeshes = [];
      for (let subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {
        const parsedSubMesh = parsedGeometry.subMeshes[subIndex];
        SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);
      }
    }
    if (mesh._shouldGenerateFlatShading) {
      mesh.convertToFlatShadedMesh();
      mesh._shouldGenerateFlatShading = false;
    }
    mesh.computeWorldMatrix(true);
    scene.onMeshImportedObservable.notifyObservers(mesh);
  }
  static _CleanMatricesWeights(parsedGeometry, mesh) {
    const epsilon = 1e-3;
    if (!SceneLoaderFlags.CleanBoneMatrixWeights) {
      return;
    }
    let noInfluenceBoneIndex = 0;
    if (parsedGeometry.skeletonId > -1) {
      const skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);
      if (!skeleton) {
        return;
      }
      noInfluenceBoneIndex = skeleton.bones.length;
    } else {
      return;
    }
    const matricesIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);
    const matricesIndicesExtra = mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);
    const matricesWeights = parsedGeometry.matricesWeights;
    const matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;
    const influencers = parsedGeometry.numBoneInfluencer;
    const size = matricesWeights.length;
    for (let i = 0; i < size; i += 4) {
      let weight = 0;
      let firstZeroWeight = -1;
      for (let j = 0; j < 4; j++) {
        const w = matricesWeights[i + j];
        weight += w;
        if (w < epsilon && firstZeroWeight < 0) {
          firstZeroWeight = j;
        }
      }
      if (matricesWeightsExtra) {
        for (let j = 0; j < 4; j++) {
          const w = matricesWeightsExtra[i + j];
          weight += w;
          if (w < epsilon && firstZeroWeight < 0) {
            firstZeroWeight = j + 4;
          }
        }
      }
      if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {
        firstZeroWeight = influencers - 1;
      }
      if (weight > epsilon) {
        const mweight = 1 / weight;
        for (let j = 0; j < 4; j++) {
          matricesWeights[i + j] *= mweight;
        }
        if (matricesWeightsExtra) {
          for (let j = 0; j < 4; j++) {
            matricesWeightsExtra[i + j] *= mweight;
          }
        }
      } else {
        if (firstZeroWeight >= 4) {
          matricesWeightsExtra[i + firstZeroWeight - 4] = 1 - weight;
          matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;
        } else {
          matricesWeights[i + firstZeroWeight] = 1 - weight;
          matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;
        }
      }
    }
    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);
    if (parsedGeometry.matricesWeightsExtra) {
      mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);
    }
  }
  static Parse(parsedVertexData, scene, rootUrl) {
    const geometry = new Geometry(parsedVertexData.id, scene, void 0, parsedVertexData.updatable);
    geometry._loadedUniqueId = parsedVertexData.uniqueId;
    if (Tags) {
      Tags.AddTagsTo(geometry, parsedVertexData.tags);
    }
    if (parsedVertexData.delayLoadingFile) {
      geometry.delayLoadState = 4;
      geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;
      geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));
      geometry._delayInfo = [];
      if (parsedVertexData.hasUVs) {
        geometry._delayInfo.push(VertexBuffer.UVKind);
      }
      if (parsedVertexData.hasUVs2) {
        geometry._delayInfo.push(VertexBuffer.UV2Kind);
      }
      if (parsedVertexData.hasUVs3) {
        geometry._delayInfo.push(VertexBuffer.UV3Kind);
      }
      if (parsedVertexData.hasUVs4) {
        geometry._delayInfo.push(VertexBuffer.UV4Kind);
      }
      if (parsedVertexData.hasUVs5) {
        geometry._delayInfo.push(VertexBuffer.UV5Kind);
      }
      if (parsedVertexData.hasUVs6) {
        geometry._delayInfo.push(VertexBuffer.UV6Kind);
      }
      if (parsedVertexData.hasColors) {
        geometry._delayInfo.push(VertexBuffer.ColorKind);
      }
      if (parsedVertexData.hasMatricesIndices) {
        geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);
      }
      if (parsedVertexData.hasMatricesWeights) {
        geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);
      }
      geometry._delayLoadingFunction = VertexData.ImportVertexData;
    } else {
      VertexData.ImportVertexData(parsedVertexData, geometry);
    }
    scene.pushGeometry(geometry, true);
    return geometry;
  }
};

// node_modules/@babylonjs/core/Misc/performanceMonitor.js
var PerformanceMonitor = class {
  constructor(frameSampleSize = 30) {
    this._enabled = true;
    this._rollingFrameTime = new RollingAverage(frameSampleSize);
  }
  sampleFrame(timeMs = PrecisionDate.Now) {
    if (!this._enabled) {
      return;
    }
    if (this._lastFrameTimeMs != null) {
      const dt = timeMs - this._lastFrameTimeMs;
      this._rollingFrameTime.add(dt);
    }
    this._lastFrameTimeMs = timeMs;
  }
  get averageFrameTime() {
    return this._rollingFrameTime.average;
  }
  get averageFrameTimeVariance() {
    return this._rollingFrameTime.variance;
  }
  get instantaneousFrameTime() {
    return this._rollingFrameTime.history(0);
  }
  get averageFPS() {
    return 1e3 / this._rollingFrameTime.average;
  }
  get instantaneousFPS() {
    const history = this._rollingFrameTime.history(0);
    if (history === 0) {
      return 0;
    }
    return 1e3 / history;
  }
  get isSaturated() {
    return this._rollingFrameTime.isSaturated();
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false;
    this._lastFrameTimeMs = null;
  }
  get isEnabled() {
    return this._enabled;
  }
  reset() {
    this._lastFrameTimeMs = null;
    this._rollingFrameTime.reset();
  }
};
var RollingAverage = class {
  constructor(length) {
    this._samples = new Array(length);
    this.reset();
  }
  add(v) {
    let delta;
    if (this.isSaturated()) {
      const bottomValue = this._samples[this._pos];
      delta = bottomValue - this.average;
      this.average -= delta / (this._sampleCount - 1);
      this._m2 -= delta * (bottomValue - this.average);
    } else {
      this._sampleCount++;
    }
    delta = v - this.average;
    this.average += delta / this._sampleCount;
    this._m2 += delta * (v - this.average);
    this.variance = this._m2 / (this._sampleCount - 1);
    this._samples[this._pos] = v;
    this._pos++;
    this._pos %= this._samples.length;
  }
  history(i) {
    if (i >= this._sampleCount || i >= this._samples.length) {
      return 0;
    }
    const i0 = this._wrapPosition(this._pos - 1);
    return this._samples[this._wrapPosition(i0 - i)];
  }
  isSaturated() {
    return this._sampleCount >= this._samples.length;
  }
  reset() {
    this.average = 0;
    this.variance = 0;
    this._sampleCount = 0;
    this._pos = 0;
    this._m2 = 0;
  }
  _wrapPosition(i) {
    const max = this._samples.length;
    return (i % max + max) % max;
  }
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.readTexture.js
function allocateAndCopyTypedBuffer(type, sizeOrDstBuffer, sizeInBytes = false, copyBuffer) {
  switch (type) {
    case 3: {
      const buffer2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int8Array(sizeOrDstBuffer) : new Int8Array(sizeOrDstBuffer);
      if (copyBuffer) {
        buffer2.set(new Int8Array(copyBuffer));
      }
      return buffer2;
    }
    case 0: {
      const buffer2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);
      if (copyBuffer) {
        buffer2.set(new Uint8Array(copyBuffer));
      }
      return buffer2;
    }
    case 4: {
      const buffer2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int16Array(sizeOrDstBuffer) : new Int16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer2.set(new Int16Array(copyBuffer));
      }
      return buffer2;
    }
    case 5:
    case 8:
    case 9:
    case 10:
    case 2: {
      const buffer2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint16Array(sizeOrDstBuffer) : new Uint16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer2.set(new Uint16Array(copyBuffer));
      }
      return buffer2;
    }
    case 6: {
      const buffer2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int32Array(sizeOrDstBuffer) : new Int32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer2.set(new Int32Array(copyBuffer));
      }
      return buffer2;
    }
    case 7:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15: {
      const buffer2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint32Array(sizeOrDstBuffer) : new Uint32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer2.set(new Uint32Array(copyBuffer));
      }
      return buffer2;
    }
    case 1: {
      const buffer2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Float32Array(sizeOrDstBuffer) : new Float32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer2.set(new Float32Array(copyBuffer));
      }
      return buffer2;
    }
  }
  const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);
  if (copyBuffer) {
    buffer.set(new Uint8Array(copyBuffer));
  }
  return buffer;
}
ThinEngine.prototype._readTexturePixelsSync = function(texture, width, height, faceIndex = -1, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0) {
  var _a, _b;
  const gl = this._gl;
  if (!gl) {
    throw new Error("Engine does not have gl rendering context.");
  }
  if (!this._dummyFramebuffer) {
    const dummy = gl.createFramebuffer();
    if (!dummy) {
      throw new Error("Unable to create dummy framebuffer");
    }
    this._dummyFramebuffer = dummy;
  }
  gl.bindFramebuffer(gl.FRAMEBUFFER, this._dummyFramebuffer);
  if (faceIndex > -1) {
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource, level);
  } else {
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, (_b = texture._hardwareTexture) === null || _b === void 0 ? void 0 : _b.underlyingResource, level);
  }
  let readType = texture.type !== void 0 ? this._getWebGLTextureType(texture.type) : gl.UNSIGNED_BYTE;
  if (!noDataConversion) {
    switch (readType) {
      case gl.UNSIGNED_BYTE:
        if (!buffer) {
          buffer = new Uint8Array(4 * width * height);
        }
        readType = gl.UNSIGNED_BYTE;
        break;
      default:
        if (!buffer) {
          buffer = new Float32Array(4 * width * height);
        }
        readType = gl.FLOAT;
        break;
    }
  } else if (!buffer) {
    buffer = allocateAndCopyTypedBuffer(texture.type, 4 * width * height);
  }
  if (flushRenderer) {
    this.flushFramebuffer();
  }
  gl.readPixels(x, y, width, height, gl.RGBA, readType, buffer);
  gl.bindFramebuffer(gl.FRAMEBUFFER, this._currentFramebuffer);
  return buffer;
};
ThinEngine.prototype._readTexturePixels = function(texture, width, height, faceIndex = -1, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0) {
  return Promise.resolve(this._readTexturePixelsSync(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y));
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.alpha.js
ThinEngine.prototype.setAlphaConstants = function(r, g, b, a) {
  this._alphaState.setAlphaBlendConstants(r, g, b, a);
};
ThinEngine.prototype.setAlphaMode = function(mode, noDepthWriteChange = false) {
  if (this._alphaMode === mode) {
    return;
  }
  switch (mode) {
    case 0:
      this._alphaState.alphaBlend = false;
      break;
    case 7:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 8:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 2:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 6:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 1:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 3:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 4:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 5:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 9:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 10:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 11:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 12:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ZERO);
      this._alphaState.alphaBlend = true;
      break;
    case 13:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE_MINUS_DST_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 14:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 15:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ZERO);
      this._alphaState.alphaBlend = true;
      break;
    case 16:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ZERO, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 17:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
  }
  if (!noDepthWriteChange) {
    this.depthCullingState.depthMask = mode === 0;
  }
  this._alphaMode = mode;
};
ThinEngine.prototype.getAlphaMode = function() {
  return this._alphaMode;
};
ThinEngine.prototype.setAlphaEquation = function(equation) {
  if (this._alphaEquation === equation) {
    return;
  }
  switch (equation) {
    case 0:
      this._alphaState.setAlphaEquationParameters(32774, 32774);
      break;
    case 1:
      this._alphaState.setAlphaEquationParameters(32778, 32778);
      break;
    case 2:
      this._alphaState.setAlphaEquationParameters(32779, 32779);
      break;
    case 3:
      this._alphaState.setAlphaEquationParameters(32776, 32776);
      break;
    case 4:
      this._alphaState.setAlphaEquationParameters(32775, 32775);
      break;
    case 5:
      this._alphaState.setAlphaEquationParameters(32775, 32774);
      break;
  }
  this._alphaEquation = equation;
};
ThinEngine.prototype.getAlphaEquation = function() {
  return this._alphaEquation;
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicBuffer.js
ThinEngine.prototype.updateDynamicIndexBuffer = function(indexBuffer, indices, offset = 0) {
  this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null;
  this.bindIndexBuffer(indexBuffer);
  let view;
  if (indexBuffer.is32Bits) {
    view = indices instanceof Uint32Array ? indices : new Uint32Array(indices);
  } else {
    view = indices instanceof Uint16Array ? indices : new Uint16Array(indices);
  }
  this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, view, this._gl.DYNAMIC_DRAW);
  this._resetIndexBufferBinding();
};
ThinEngine.prototype.updateDynamicVertexBuffer = function(vertexBuffer, data, byteOffset, byteLength) {
  this.bindArrayBuffer(vertexBuffer);
  if (byteOffset === void 0) {
    byteOffset = 0;
  }
  const dataLength = data.byteLength || data.length;
  if (byteLength === void 0 || byteLength >= dataLength && byteOffset === 0) {
    if (data instanceof Array) {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, new Float32Array(data));
    } else {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, data);
    }
  } else {
    if (data instanceof Array) {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(data).subarray(byteOffset, byteOffset + byteLength));
    } else {
      if (data instanceof ArrayBuffer) {
        data = new Uint8Array(data, byteOffset, byteLength);
      } else {
        data = new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);
      }
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
    }
  }
  this._resetVertexBufferBinding();
};

// node_modules/@babylonjs/core/Engines/engine.js
var Engine = class extends ThinEngine {
  constructor(canvasOrContext, antialias, options, adaptToDeviceRatio = false) {
    super(canvasOrContext, antialias, options, adaptToDeviceRatio);
    this.enableOfflineSupport = false;
    this.disableManifestCheck = false;
    this.disableContextMenu = true;
    this.scenes = new Array();
    this._virtualScenes = new Array();
    this.onNewSceneAddedObservable = new Observable();
    this.postProcesses = new Array();
    this.isPointerLock = false;
    this.onResizeObservable = new Observable();
    this.onCanvasBlurObservable = new Observable();
    this.onCanvasFocusObservable = new Observable();
    this.onCanvasPointerOutObservable = new Observable();
    this.onBeginFrameObservable = new Observable();
    this.customAnimationFrameRequester = null;
    this.onEndFrameObservable = new Observable();
    this.onBeforeShaderCompilationObservable = new Observable();
    this.onAfterShaderCompilationObservable = new Observable();
    this._deterministicLockstep = false;
    this._lockstepMaxSteps = 4;
    this._timeStep = 1 / 60;
    this._fps = 60;
    this._deltaTime = 0;
    this._drawCalls = new PerfCounter();
    this.canvasTabIndex = 1;
    this.disablePerformanceMonitorInBackground = false;
    this._performanceMonitor = new PerformanceMonitor();
    this._compatibilityMode = true;
    this.currentRenderPassId = 0;
    this._renderPassNames = ["main"];
    Engine.Instances.push(this);
    if (!canvasOrContext) {
      return;
    }
    this._features.supportRenderPasses = true;
    options = this._creationOptions;
    if (canvasOrContext.getContext) {
      const canvas = canvasOrContext;
      this._sharedInit(canvas, !!options.doNotHandleTouchAction, options.audioEngine);
      if (IsDocumentAvailable()) {
        this._onFullscreenChange = () => {
          this.isFullscreen = !!document.fullscreenElement;
          if (this.isFullscreen && this._pointerLockRequested && canvas) {
            Engine._RequestPointerlock(canvas);
          }
        };
        document.addEventListener("fullscreenchange", this._onFullscreenChange, false);
        document.addEventListener("webkitfullscreenchange", this._onFullscreenChange, false);
        this._onPointerLockChange = () => {
          this.isPointerLock = document.pointerLockElement === canvas;
        };
        document.addEventListener("pointerlockchange", this._onPointerLockChange, false);
        document.addEventListener("webkitpointerlockchange", this._onPointerLockChange, false);
        if (!Engine.audioEngine && options.audioEngine && Engine.AudioEngineFactory) {
          Engine.audioEngine = Engine.AudioEngineFactory(this.getRenderingCanvas(), this.getAudioContext(), this.getAudioDestination());
        }
      }
      this._connectVREvents();
      this.enableOfflineSupport = Engine.OfflineProviderFactory !== void 0;
      this._deterministicLockstep = !!options.deterministicLockstep;
      this._lockstepMaxSteps = options.lockstepMaxSteps || 0;
      this._timeStep = options.timeStep || 1 / 60;
    }
    this._prepareVRComponent();
    if (options.autoEnableWebVR) {
      this.initWebVR();
    }
  }
  static get NpmPackage() {
    return ThinEngine.NpmPackage;
  }
  static get Version() {
    return ThinEngine.Version;
  }
  static get Instances() {
    return EngineStore.Instances;
  }
  static get LastCreatedEngine() {
    return EngineStore.LastCreatedEngine;
  }
  static get LastCreatedScene() {
    return EngineStore.LastCreatedScene;
  }
  _createImageBitmapFromSource(imageSource, options) {
    const promise = new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = () => {
        image.decode().then(() => {
          this.createImageBitmap(image, options).then((imageBitmap) => {
            resolve(imageBitmap);
          });
        });
      };
      image.onerror = () => {
        reject(`Error loading image ${image.src}`);
      };
      image.src = imageSource;
    });
    return promise;
  }
  createImageBitmap(image, options) {
    return createImageBitmap(image, options);
  }
  resizeImageBitmap(image, bufferWidth, bufferHeight) {
    const canvas = this.createCanvas(bufferWidth, bufferHeight);
    const context = canvas.getContext("2d");
    if (!context) {
      throw new Error("Unable to get 2d context for resizeImageBitmap");
    }
    context.drawImage(image, 0, 0);
    const buffer = context.getImageData(0, 0, bufferWidth, bufferHeight).data;
    return buffer;
  }
  static MarkAllMaterialsAsDirty(flag, predicate) {
    for (let engineIndex = 0; engineIndex < Engine.Instances.length; engineIndex++) {
      const engine = Engine.Instances[engineIndex];
      for (let sceneIndex = 0; sceneIndex < engine.scenes.length; sceneIndex++) {
        engine.scenes[sceneIndex].markAllMaterialsAsDirty(flag, predicate);
      }
    }
  }
  static DefaultLoadingScreenFactory(canvas) {
    throw _WarnImport("LoadingScreen");
  }
  get _supportsHardwareTextureRescaling() {
    return !!Engine._RescalePostProcessFactory;
  }
  get performanceMonitor() {
    return this._performanceMonitor;
  }
  get compatibilityMode() {
    return this._compatibilityMode;
  }
  set compatibilityMode(mode) {
    this._compatibilityMode = true;
  }
  getInputElement() {
    return this._renderingCanvas;
  }
  _initGLContext() {
    super._initGLContext();
    this._rescalePostProcess = null;
  }
  _sharedInit(canvas, doNotHandleTouchAction, audioEngine) {
    super._sharedInit(canvas, doNotHandleTouchAction, audioEngine);
    this._onCanvasFocus = () => {
      this.onCanvasFocusObservable.notifyObservers(this);
    };
    this._onCanvasBlur = () => {
      this.onCanvasBlurObservable.notifyObservers(this);
    };
    this._onCanvasContextMenu = (evt) => {
      if (this.disableContextMenu) {
        evt.preventDefault();
      }
    };
    canvas.addEventListener("focus", this._onCanvasFocus);
    canvas.addEventListener("blur", this._onCanvasBlur);
    canvas.addEventListener("contextmenu", this._onCanvasContextMenu);
    this._onBlur = () => {
      if (this.disablePerformanceMonitorInBackground) {
        this._performanceMonitor.disable();
      }
      this._windowIsBackground = true;
    };
    this._onFocus = () => {
      if (this.disablePerformanceMonitorInBackground) {
        this._performanceMonitor.enable();
      }
      this._windowIsBackground = false;
    };
    this._onCanvasPointerOut = (ev) => {
      if (document.elementFromPoint(ev.clientX, ev.clientY) !== canvas) {
        this.onCanvasPointerOutObservable.notifyObservers(ev);
      }
    };
    const hostWindow = this.getHostWindow();
    if (hostWindow && typeof hostWindow.addEventListener === "function") {
      hostWindow.addEventListener("blur", this._onBlur);
      hostWindow.addEventListener("focus", this._onFocus);
    }
    canvas.addEventListener("pointerout", this._onCanvasPointerOut);
    if (!doNotHandleTouchAction) {
      this._disableTouchAction();
    }
    if (!Engine.audioEngine && audioEngine && Engine.AudioEngineFactory) {
      Engine.audioEngine = Engine.AudioEngineFactory(this.getRenderingCanvas(), this.getAudioContext(), this.getAudioDestination());
    }
  }
  getAspectRatio(viewportOwner, useScreen = false) {
    const viewport = viewportOwner.viewport;
    return this.getRenderWidth(useScreen) * viewport.width / (this.getRenderHeight(useScreen) * viewport.height);
  }
  getScreenAspectRatio() {
    return this.getRenderWidth(true) / this.getRenderHeight(true);
  }
  getRenderingCanvasClientRect() {
    if (!this._renderingCanvas) {
      return null;
    }
    return this._renderingCanvas.getBoundingClientRect();
  }
  getInputElementClientRect() {
    if (!this._renderingCanvas) {
      return null;
    }
    return this.getInputElement().getBoundingClientRect();
  }
  isDeterministicLockStep() {
    return this._deterministicLockstep;
  }
  getLockstepMaxSteps() {
    return this._lockstepMaxSteps;
  }
  getTimeStep() {
    return this._timeStep * 1e3;
  }
  generateMipMapsForCubemap(texture, unbind = true) {
    if (texture.generateMipMaps) {
      const gl = this._gl;
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
      if (unbind) {
        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
      }
    }
  }
  getDepthWrite() {
    return this._depthCullingState.depthMask;
  }
  setDepthWrite(enable) {
    this._depthCullingState.depthMask = enable;
  }
  getStencilBuffer() {
    return this._stencilState.stencilTest;
  }
  setStencilBuffer(enable) {
    this._stencilState.stencilTest = enable;
  }
  getStencilMask() {
    return this._stencilState.stencilMask;
  }
  setStencilMask(mask) {
    this._stencilState.stencilMask = mask;
  }
  getStencilFunction() {
    return this._stencilState.stencilFunc;
  }
  getStencilFunctionReference() {
    return this._stencilState.stencilFuncRef;
  }
  getStencilFunctionMask() {
    return this._stencilState.stencilFuncMask;
  }
  setStencilFunction(stencilFunc) {
    this._stencilState.stencilFunc = stencilFunc;
  }
  setStencilFunctionReference(reference) {
    this._stencilState.stencilFuncRef = reference;
  }
  setStencilFunctionMask(mask) {
    this._stencilState.stencilFuncMask = mask;
  }
  getStencilOperationFail() {
    return this._stencilState.stencilOpStencilFail;
  }
  getStencilOperationDepthFail() {
    return this._stencilState.stencilOpDepthFail;
  }
  getStencilOperationPass() {
    return this._stencilState.stencilOpStencilDepthPass;
  }
  setStencilOperationFail(operation) {
    this._stencilState.stencilOpStencilFail = operation;
  }
  setStencilOperationDepthFail(operation) {
    this._stencilState.stencilOpDepthFail = operation;
  }
  setStencilOperationPass(operation) {
    this._stencilState.stencilOpStencilDepthPass = operation;
  }
  setDitheringState(value) {
    if (value) {
      this._gl.enable(this._gl.DITHER);
    } else {
      this._gl.disable(this._gl.DITHER);
    }
  }
  setRasterizerState(value) {
    if (value) {
      this._gl.disable(this._gl.RASTERIZER_DISCARD);
    } else {
      this._gl.enable(this._gl.RASTERIZER_DISCARD);
    }
  }
  getDepthFunction() {
    return this._depthCullingState.depthFunc;
  }
  setDepthFunction(depthFunc) {
    this._depthCullingState.depthFunc = depthFunc;
  }
  setDepthFunctionToGreater() {
    this.setDepthFunction(516);
  }
  setDepthFunctionToGreaterOrEqual() {
    this.setDepthFunction(518);
  }
  setDepthFunctionToLess() {
    this.setDepthFunction(513);
  }
  setDepthFunctionToLessOrEqual() {
    this.setDepthFunction(515);
  }
  cacheStencilState() {
    this._cachedStencilBuffer = this.getStencilBuffer();
    this._cachedStencilFunction = this.getStencilFunction();
    this._cachedStencilMask = this.getStencilMask();
    this._cachedStencilOperationPass = this.getStencilOperationPass();
    this._cachedStencilOperationFail = this.getStencilOperationFail();
    this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail();
    this._cachedStencilReference = this.getStencilFunctionReference();
  }
  restoreStencilState() {
    this.setStencilFunction(this._cachedStencilFunction);
    this.setStencilMask(this._cachedStencilMask);
    this.setStencilBuffer(this._cachedStencilBuffer);
    this.setStencilOperationPass(this._cachedStencilOperationPass);
    this.setStencilOperationFail(this._cachedStencilOperationFail);
    this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail);
    this.setStencilFunctionReference(this._cachedStencilReference);
  }
  setDirectViewport(x, y, width, height) {
    const currentViewport = this._cachedViewport;
    this._cachedViewport = null;
    this._viewport(x, y, width, height);
    return currentViewport;
  }
  scissorClear(x, y, width, height, clearColor) {
    this.enableScissor(x, y, width, height);
    this.clear(clearColor, true, true, true);
    this.disableScissor();
  }
  enableScissor(x, y, width, height) {
    const gl = this._gl;
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(x, y, width, height);
  }
  disableScissor() {
    const gl = this._gl;
    gl.disable(gl.SCISSOR_TEST);
  }
  _reportDrawCall(numDrawCalls = 1) {
    this._drawCalls.addCount(numDrawCalls, false);
  }
  initWebVR() {
    throw _WarnImport("WebVRCamera");
  }
  _prepareVRComponent() {
  }
  _connectVREvents(canvas, document2) {
  }
  _submitVRFrame() {
  }
  disableVR() {
  }
  isVRPresenting() {
    return false;
  }
  _requestVRFrame() {
  }
  _loadFileAsync(url, offlineProvider, useArrayBuffer) {
    return new Promise((resolve, reject) => {
      this._loadFile(url, (data) => {
        resolve(data);
      }, void 0, offlineProvider, useArrayBuffer, (request, exception) => {
        reject(exception);
      });
    });
  }
  getVertexShaderSource(program) {
    const shaders = this._gl.getAttachedShaders(program);
    if (!shaders) {
      return null;
    }
    return this._gl.getShaderSource(shaders[0]);
  }
  getFragmentShaderSource(program) {
    const shaders = this._gl.getAttachedShaders(program);
    if (!shaders) {
      return null;
    }
    return this._gl.getShaderSource(shaders[1]);
  }
  setDepthStencilTexture(channel, uniform, texture, name63) {
    if (channel === void 0) {
      return;
    }
    if (uniform) {
      this._boundUniforms[channel] = uniform;
    }
    if (!texture || !texture.depthStencilTexture) {
      this._setTexture(channel, null, void 0, void 0, name63);
    } else {
      this._setTexture(channel, texture, false, true, name63);
    }
  }
  setTextureFromPostProcess(channel, postProcess, name63) {
    var _a;
    let postProcessInput = null;
    if (postProcess) {
      if (postProcess._textures.data[postProcess._currentRenderTextureInd]) {
        postProcessInput = postProcess._textures.data[postProcess._currentRenderTextureInd];
      } else if (postProcess._forcedOutputTexture) {
        postProcessInput = postProcess._forcedOutputTexture;
      }
    }
    this._bindTexture(channel, (_a = postProcessInput === null || postProcessInput === void 0 ? void 0 : postProcessInput.texture) !== null && _a !== void 0 ? _a : null, name63);
  }
  setTextureFromPostProcessOutput(channel, postProcess, name63) {
    var _a, _b;
    this._bindTexture(channel, (_b = (_a = postProcess === null || postProcess === void 0 ? void 0 : postProcess._outputTexture) === null || _a === void 0 ? void 0 : _a.texture) !== null && _b !== void 0 ? _b : null, name63);
  }
  _rebuildBuffers() {
    for (const scene of this.scenes) {
      scene.resetCachedMaterial();
      scene._rebuildGeometries();
      scene._rebuildTextures();
    }
    for (const scene of this._virtualScenes) {
      scene.resetCachedMaterial();
      scene._rebuildGeometries();
      scene._rebuildTextures();
    }
    super._rebuildBuffers();
  }
  _renderFrame() {
    for (let index = 0; index < this._activeRenderLoops.length; index++) {
      const renderFunction = this._activeRenderLoops[index];
      renderFunction();
    }
  }
  _renderLoop() {
    if (!this._contextWasLost) {
      let shouldRender = true;
      if (!this.renderEvenInBackground && this._windowIsBackground) {
        shouldRender = false;
      }
      if (shouldRender) {
        this.beginFrame();
        if (!this._renderViews()) {
          this._renderFrame();
        }
        this.endFrame();
      }
    }
    if (this._activeRenderLoops.length > 0) {
      if (this.customAnimationFrameRequester) {
        this.customAnimationFrameRequester.requestID = this._queueNewFrame(this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction, this.customAnimationFrameRequester);
        this._frameHandler = this.customAnimationFrameRequester.requestID;
      } else if (this.isVRPresenting()) {
        this._requestVRFrame();
      } else {
        this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
      }
    } else {
      this._renderingQueueLaunched = false;
    }
  }
  _renderViews() {
    return false;
  }
  switchFullscreen(requestPointerLock) {
    if (this.isFullscreen) {
      this.exitFullscreen();
    } else {
      this.enterFullscreen(requestPointerLock);
    }
  }
  enterFullscreen(requestPointerLock) {
    if (!this.isFullscreen) {
      this._pointerLockRequested = requestPointerLock;
      if (this._renderingCanvas) {
        Engine._RequestFullscreen(this._renderingCanvas);
      }
    }
  }
  exitFullscreen() {
    if (this.isFullscreen) {
      Engine._ExitFullscreen();
    }
  }
  enterPointerlock() {
    if (this._renderingCanvas) {
      Engine._RequestPointerlock(this._renderingCanvas);
    }
  }
  exitPointerlock() {
    Engine._ExitPointerlock();
  }
  beginFrame() {
    this._measureFps();
    this.onBeginFrameObservable.notifyObservers(this);
    super.beginFrame();
  }
  endFrame() {
    super.endFrame();
    this._submitVRFrame();
    this.onEndFrameObservable.notifyObservers(this);
  }
  resize(forceSetSize = false) {
    if (this.isVRPresenting()) {
      return;
    }
    super.resize(forceSetSize);
  }
  setSize(width, height, forceSetSize = false) {
    if (!this._renderingCanvas) {
      return false;
    }
    if (!super.setSize(width, height, forceSetSize)) {
      return false;
    }
    if (this.scenes) {
      for (let index = 0; index < this.scenes.length; index++) {
        const scene = this.scenes[index];
        for (let camIndex = 0; camIndex < scene.cameras.length; camIndex++) {
          const cam = scene.cameras[camIndex];
          cam._currentRenderId = 0;
        }
      }
      if (this.onResizeObservable.hasObservers()) {
        this.onResizeObservable.notifyObservers(this);
      }
    }
    return true;
  }
  _deletePipelineContext(pipelineContext) {
    const webGLPipelineContext = pipelineContext;
    if (webGLPipelineContext && webGLPipelineContext.program) {
      if (webGLPipelineContext.transformFeedback) {
        this.deleteTransformFeedback(webGLPipelineContext.transformFeedback);
        webGLPipelineContext.transformFeedback = null;
      }
    }
    super._deletePipelineContext(pipelineContext);
  }
  createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings = null) {
    context = context || this._gl;
    this.onBeforeShaderCompilationObservable.notifyObservers(this);
    const program = super.createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings);
    this.onAfterShaderCompilationObservable.notifyObservers(this);
    return program;
  }
  _createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings = null) {
    const shaderProgram = context.createProgram();
    pipelineContext.program = shaderProgram;
    if (!shaderProgram) {
      throw new Error("Unable to create program");
    }
    context.attachShader(shaderProgram, vertexShader);
    context.attachShader(shaderProgram, fragmentShader);
    if (this.webGLVersion > 1 && transformFeedbackVaryings) {
      const transformFeedback = this.createTransformFeedback();
      this.bindTransformFeedback(transformFeedback);
      this.setTranformFeedbackVaryings(shaderProgram, transformFeedbackVaryings);
      pipelineContext.transformFeedback = transformFeedback;
    }
    context.linkProgram(shaderProgram);
    if (this.webGLVersion > 1 && transformFeedbackVaryings) {
      this.bindTransformFeedback(null);
    }
    pipelineContext.context = context;
    pipelineContext.vertexShader = vertexShader;
    pipelineContext.fragmentShader = fragmentShader;
    if (!pipelineContext.isParallelCompiled) {
      this._finalizePipelineContext(pipelineContext);
    }
    return shaderProgram;
  }
  _releaseTexture(texture) {
    super._releaseTexture(texture);
  }
  _releaseRenderTargetWrapper(rtWrapper) {
    super._releaseRenderTargetWrapper(rtWrapper);
    this.scenes.forEach((scene) => {
      scene.postProcesses.forEach((postProcess) => {
        if (postProcess._outputTexture === rtWrapper) {
          postProcess._outputTexture = null;
        }
      });
      scene.cameras.forEach((camera) => {
        camera._postProcesses.forEach((postProcess) => {
          if (postProcess) {
            if (postProcess._outputTexture === rtWrapper) {
              postProcess._outputTexture = null;
            }
          }
        });
      });
    });
  }
  getRenderPassNames() {
    return this._renderPassNames;
  }
  getCurrentRenderPassName() {
    return this._renderPassNames[this.currentRenderPassId];
  }
  createRenderPassId(name63) {
    const id = ++Engine._RenderPassIdCounter;
    this._renderPassNames[id] = name63 !== null && name63 !== void 0 ? name63 : "NONAME";
    return id;
  }
  releaseRenderPassId(id) {
    this._renderPassNames[id] = void 0;
    for (let s = 0; s < this.scenes.length; ++s) {
      const scene = this.scenes[s];
      for (let m = 0; m < scene.meshes.length; ++m) {
        const mesh = scene.meshes[m];
        if (mesh.subMeshes) {
          for (let b = 0; b < mesh.subMeshes.length; ++b) {
            const subMesh = mesh.subMeshes[b];
            subMesh._removeDrawWrapper(id);
          }
        }
      }
    }
  }
  _rescaleTexture(source, destination, scene, internalFormat, onComplete) {
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
    const rtt = this.createRenderTargetTexture({
      width: destination.width,
      height: destination.height
    }, {
      generateMipMaps: false,
      type: 0,
      samplingMode: 2,
      generateDepthBuffer: false,
      generateStencilBuffer: false
    });
    if (!this._rescalePostProcess && Engine._RescalePostProcessFactory) {
      this._rescalePostProcess = Engine._RescalePostProcessFactory(this);
    }
    if (this._rescalePostProcess) {
      this._rescalePostProcess.externalTextureSamplerBinding = true;
      this._rescalePostProcess.getEffect().executeWhenCompiled(() => {
        this._rescalePostProcess.onApply = function(effect) {
          effect._bindTexture("textureSampler", source);
        };
        let hostingScene = scene;
        if (!hostingScene) {
          hostingScene = this.scenes[this.scenes.length - 1];
        }
        hostingScene.postProcessManager.directRender([this._rescalePostProcess], rtt, true);
        this._bindTextureDirectly(this._gl.TEXTURE_2D, destination, true);
        this._gl.copyTexImage2D(this._gl.TEXTURE_2D, 0, internalFormat, 0, 0, destination.width, destination.height, 0);
        this.unBindFramebuffer(rtt);
        rtt.dispose();
        if (onComplete) {
          onComplete();
        }
      });
    }
  }
  getFps() {
    return this._fps;
  }
  getDeltaTime() {
    return this._deltaTime;
  }
  _measureFps() {
    this._performanceMonitor.sampleFrame();
    this._fps = this._performanceMonitor.averageFPS;
    this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;
  }
  wrapWebGLTexture(texture) {
    const hardwareTexture = new WebGLHardwareTexture(texture, this._gl);
    const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);
    internalTexture._hardwareTexture = hardwareTexture;
    internalTexture.isReady = true;
    return internalTexture;
  }
  _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {
    const gl = this._gl;
    const textureType = this._getWebGLTextureType(texture.type);
    const format = this._getInternalFormat(texture.format);
    const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, format);
    const bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
    this._bindTextureDirectly(bindTarget, texture, true);
    this._unpackFlipY(texture.invertY);
    let target = gl.TEXTURE_2D;
    if (texture.isCube) {
      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    gl.texImage2D(target, lod, internalFormat, format, textureType, image);
    this._bindTextureDirectly(bindTarget, null, true);
  }
  updateTextureComparisonFunction(texture, comparisonFunction) {
    if (this.webGLVersion === 1) {
      Logger.Error("WebGL 1 does not support texture comparison.");
      return;
    }
    const gl = this._gl;
    if (texture.isCube) {
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);
      if (comparisonFunction === 0) {
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, 515);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.NONE);
      } else {
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
    } else {
      this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
      if (comparisonFunction === 0) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, 515);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.NONE);
      } else {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
    }
    texture._comparisonFunction = comparisonFunction;
  }
  createInstancesBuffer(capacity) {
    const buffer = this._gl.createBuffer();
    if (!buffer) {
      throw new Error("Unable to create instance buffer");
    }
    const result = new WebGLDataBuffer(buffer);
    result.capacity = capacity;
    this.bindArrayBuffer(result);
    this._gl.bufferData(this._gl.ARRAY_BUFFER, capacity, this._gl.DYNAMIC_DRAW);
    result.references = 1;
    return result;
  }
  deleteInstancesBuffer(buffer) {
    this._gl.deleteBuffer(buffer);
  }
  _clientWaitAsync(sync, flags = 0, intervalms = 10) {
    const gl = this._gl;
    return new Promise((resolve, reject) => {
      const check = () => {
        const res = gl.clientWaitSync(sync, flags, 0);
        if (res == gl.WAIT_FAILED) {
          reject();
          return;
        }
        if (res == gl.TIMEOUT_EXPIRED) {
          setTimeout(check, intervalms);
          return;
        }
        resolve();
      };
      check();
    });
  }
  _readPixelsAsync(x, y, w, h, format, type, outputBuffer) {
    if (this._webGLVersion < 2) {
      throw new Error("_readPixelsAsync only work on WebGL2+");
    }
    const gl = this._gl;
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
    gl.bufferData(gl.PIXEL_PACK_BUFFER, outputBuffer.byteLength, gl.STREAM_READ);
    gl.readPixels(x, y, w, h, format, type, 0);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
    if (!sync) {
      return null;
    }
    gl.flush();
    return this._clientWaitAsync(sync, 0, 10).then(() => {
      gl.deleteSync(sync);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
      gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, outputBuffer);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
      gl.deleteBuffer(buf);
      return outputBuffer;
    });
  }
  dispose() {
    this.hideLoadingUI();
    this.onNewSceneAddedObservable.clear();
    while (this.postProcesses.length) {
      this.postProcesses[0].dispose();
    }
    if (this._rescalePostProcess) {
      this._rescalePostProcess.dispose();
    }
    while (this.scenes.length) {
      this.scenes[0].dispose();
    }
    while (this._virtualScenes.length) {
      this._virtualScenes[0].dispose();
    }
    if (Engine.Instances.length === 1 && Engine.audioEngine) {
      Engine.audioEngine.dispose();
      Engine.audioEngine = null;
    }
    this.disableVR();
    const hostWindow = this.getHostWindow();
    if (hostWindow && typeof hostWindow.removeEventListener === "function") {
      hostWindow.removeEventListener("blur", this._onBlur);
      hostWindow.removeEventListener("focus", this._onFocus);
    }
    if (this._renderingCanvas) {
      this._renderingCanvas.removeEventListener("focus", this._onCanvasFocus);
      this._renderingCanvas.removeEventListener("blur", this._onCanvasBlur);
      this._renderingCanvas.removeEventListener("pointerout", this._onCanvasPointerOut);
      this._renderingCanvas.removeEventListener("contextmenu", this._onCanvasContextMenu);
    }
    if (IsDocumentAvailable()) {
      document.removeEventListener("fullscreenchange", this._onFullscreenChange);
      document.removeEventListener("mozfullscreenchange", this._onFullscreenChange);
      document.removeEventListener("webkitfullscreenchange", this._onFullscreenChange);
      document.removeEventListener("msfullscreenchange", this._onFullscreenChange);
      document.removeEventListener("pointerlockchange", this._onPointerLockChange);
      document.removeEventListener("mspointerlockchange", this._onPointerLockChange);
      document.removeEventListener("mozpointerlockchange", this._onPointerLockChange);
      document.removeEventListener("webkitpointerlockchange", this._onPointerLockChange);
    }
    super.dispose();
    const index = Engine.Instances.indexOf(this);
    if (index >= 0) {
      Engine.Instances.splice(index, 1);
    }
    this.onResizeObservable.clear();
    this.onCanvasBlurObservable.clear();
    this.onCanvasFocusObservable.clear();
    this.onCanvasPointerOutObservable.clear();
    this.onBeginFrameObservable.clear();
    this.onEndFrameObservable.clear();
  }
  _disableTouchAction() {
    if (!this._renderingCanvas || !this._renderingCanvas.setAttribute) {
      return;
    }
    this._renderingCanvas.setAttribute("touch-action", "none");
    this._renderingCanvas.style.touchAction = "none";
    this._renderingCanvas.style.webkitTapHighlightColor = "transparent";
  }
  displayLoadingUI() {
    if (!IsWindowObjectExist()) {
      return;
    }
    const loadingScreen = this.loadingScreen;
    if (loadingScreen) {
      loadingScreen.displayLoadingUI();
    }
  }
  hideLoadingUI() {
    if (!IsWindowObjectExist()) {
      return;
    }
    const loadingScreen = this._loadingScreen;
    if (loadingScreen) {
      loadingScreen.hideLoadingUI();
    }
  }
  get loadingScreen() {
    if (!this._loadingScreen && this._renderingCanvas) {
      this._loadingScreen = Engine.DefaultLoadingScreenFactory(this._renderingCanvas);
    }
    return this._loadingScreen;
  }
  set loadingScreen(loadingScreen) {
    this._loadingScreen = loadingScreen;
  }
  set loadingUIText(text) {
    this.loadingScreen.loadingUIText = text;
  }
  set loadingUIBackgroundColor(color) {
    this.loadingScreen.loadingUIBackgroundColor = color;
  }
  createVideoElement(constraints) {
    return document.createElement("video");
  }
  static _RequestPointerlock(element) {
    if (element.requestPointerLock) {
      element.requestPointerLock();
      element.focus();
    }
  }
  static _ExitPointerlock() {
    if (document.exitPointerLock) {
      document.exitPointerLock();
    }
  }
  static _RequestFullscreen(element) {
    const requestFunction = element.requestFullscreen || element.webkitRequestFullscreen;
    if (!requestFunction) {
      return;
    }
    requestFunction.call(element);
  }
  static _ExitFullscreen() {
    const anyDoc = document;
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (anyDoc.webkitCancelFullScreen) {
      anyDoc.webkitCancelFullScreen();
    }
  }
  getFontOffset(font) {
    const text = document.createElement("span");
    text.innerHTML = "Hg";
    text.setAttribute("style", `font: ${font} !important`);
    const block = document.createElement("div");
    block.style.display = "inline-block";
    block.style.width = "1px";
    block.style.height = "0px";
    block.style.verticalAlign = "bottom";
    const div = document.createElement("div");
    div.style.whiteSpace = "nowrap";
    div.appendChild(text);
    div.appendChild(block);
    document.body.appendChild(div);
    let fontAscent = 0;
    let fontHeight = 0;
    try {
      fontHeight = block.getBoundingClientRect().top - text.getBoundingClientRect().top;
      block.style.verticalAlign = "baseline";
      fontAscent = block.getBoundingClientRect().top - text.getBoundingClientRect().top;
    } finally {
      document.body.removeChild(div);
    }
    return { ascent: fontAscent, height: fontHeight, descent: fontHeight - fontAscent };
  }
};
Engine.ALPHA_DISABLE = 0;
Engine.ALPHA_ADD = 1;
Engine.ALPHA_COMBINE = 2;
Engine.ALPHA_SUBTRACT = 3;
Engine.ALPHA_MULTIPLY = 4;
Engine.ALPHA_MAXIMIZED = 5;
Engine.ALPHA_ONEONE = 6;
Engine.ALPHA_PREMULTIPLIED = 7;
Engine.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;
Engine.ALPHA_INTERPOLATE = 9;
Engine.ALPHA_SCREENMODE = 10;
Engine.DELAYLOADSTATE_NONE = 0;
Engine.DELAYLOADSTATE_LOADED = 1;
Engine.DELAYLOADSTATE_LOADING = 2;
Engine.DELAYLOADSTATE_NOTLOADED = 4;
Engine.NEVER = 512;
Engine.ALWAYS = 519;
Engine.LESS = 513;
Engine.EQUAL = 514;
Engine.LEQUAL = 515;
Engine.GREATER = 516;
Engine.GEQUAL = 518;
Engine.NOTEQUAL = 517;
Engine.KEEP = 7680;
Engine.REPLACE = 7681;
Engine.INCR = 7682;
Engine.DECR = 7683;
Engine.INVERT = 5386;
Engine.INCR_WRAP = 34055;
Engine.DECR_WRAP = 34056;
Engine.TEXTURE_CLAMP_ADDRESSMODE = 0;
Engine.TEXTURE_WRAP_ADDRESSMODE = 1;
Engine.TEXTURE_MIRROR_ADDRESSMODE = 2;
Engine.TEXTUREFORMAT_ALPHA = 0;
Engine.TEXTUREFORMAT_LUMINANCE = 1;
Engine.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;
Engine.TEXTUREFORMAT_RGB = 4;
Engine.TEXTUREFORMAT_RGBA = 5;
Engine.TEXTUREFORMAT_RED = 6;
Engine.TEXTUREFORMAT_R = 6;
Engine.TEXTUREFORMAT_RG = 7;
Engine.TEXTUREFORMAT_RED_INTEGER = 8;
Engine.TEXTUREFORMAT_R_INTEGER = 8;
Engine.TEXTUREFORMAT_RG_INTEGER = 9;
Engine.TEXTUREFORMAT_RGB_INTEGER = 10;
Engine.TEXTUREFORMAT_RGBA_INTEGER = 11;
Engine.TEXTURETYPE_UNSIGNED_BYTE = 0;
Engine.TEXTURETYPE_UNSIGNED_INT = 0;
Engine.TEXTURETYPE_FLOAT = 1;
Engine.TEXTURETYPE_HALF_FLOAT = 2;
Engine.TEXTURETYPE_BYTE = 3;
Engine.TEXTURETYPE_SHORT = 4;
Engine.TEXTURETYPE_UNSIGNED_SHORT = 5;
Engine.TEXTURETYPE_INT = 6;
Engine.TEXTURETYPE_UNSIGNED_INTEGER = 7;
Engine.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;
Engine.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;
Engine.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;
Engine.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;
Engine.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;
Engine.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;
Engine.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;
Engine.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;
Engine.TEXTURE_NEAREST_SAMPLINGMODE = 1;
Engine.TEXTURE_BILINEAR_SAMPLINGMODE = 2;
Engine.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;
Engine.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;
Engine.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;
Engine.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;
Engine.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;
Engine.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;
Engine.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;
Engine.TEXTURE_NEAREST_LINEAR = 7;
Engine.TEXTURE_NEAREST_NEAREST = 1;
Engine.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;
Engine.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;
Engine.TEXTURE_LINEAR_LINEAR = 2;
Engine.TEXTURE_LINEAR_NEAREST = 12;
Engine.TEXTURE_EXPLICIT_MODE = 0;
Engine.TEXTURE_SPHERICAL_MODE = 1;
Engine.TEXTURE_PLANAR_MODE = 2;
Engine.TEXTURE_CUBIC_MODE = 3;
Engine.TEXTURE_PROJECTION_MODE = 4;
Engine.TEXTURE_SKYBOX_MODE = 5;
Engine.TEXTURE_INVCUBIC_MODE = 6;
Engine.TEXTURE_EQUIRECTANGULAR_MODE = 7;
Engine.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;
Engine.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
Engine.SCALEMODE_FLOOR = 1;
Engine.SCALEMODE_NEAREST = 2;
Engine.SCALEMODE_CEILING = 3;
Engine._RescalePostProcessFactory = null;
Engine._RenderPassIdCounter = 0;

// node_modules/@babylonjs/core/Meshes/transformNode.js
var TransformNode = class extends Node {
  constructor(name63, scene = null, isPure = true) {
    super(name63, scene);
    this._forward = new Vector3(0, 0, 1);
    this._up = new Vector3(0, 1, 0);
    this._right = new Vector3(1, 0, 0);
    this._position = Vector3.Zero();
    this._rotation = Vector3.Zero();
    this._rotationQuaternion = null;
    this._scaling = Vector3.One();
    this._transformToBoneReferal = null;
    this._isAbsoluteSynced = false;
    this._billboardMode = TransformNode.BILLBOARDMODE_NONE;
    this._preserveParentRotationForBillboard = false;
    this.scalingDeterminant = 1;
    this._infiniteDistance = false;
    this.ignoreNonUniformScaling = false;
    this.reIntegrateRotationIntoRotationQuaternion = false;
    this._poseMatrix = null;
    this._localMatrix = Matrix.Zero();
    this._usePivotMatrix = false;
    this._absolutePosition = Vector3.Zero();
    this._absoluteScaling = Vector3.Zero();
    this._absoluteRotationQuaternion = Quaternion.Identity();
    this._pivotMatrix = Matrix.Identity();
    this._postMultiplyPivotMatrix = false;
    this._isWorldMatrixFrozen = false;
    this._indexInSceneTransformNodesArray = -1;
    this.onAfterWorldMatrixUpdateObservable = new Observable();
    this._nonUniformScaling = false;
    if (isPure) {
      this.getScene().addTransformNode(this);
    }
  }
  get billboardMode() {
    return this._billboardMode;
  }
  set billboardMode(value) {
    if (this._billboardMode === value) {
      return;
    }
    this._billboardMode = value;
  }
  get preserveParentRotationForBillboard() {
    return this._preserveParentRotationForBillboard;
  }
  set preserveParentRotationForBillboard(value) {
    if (value === this._preserveParentRotationForBillboard) {
      return;
    }
    this._preserveParentRotationForBillboard = value;
  }
  get infiniteDistance() {
    return this._infiniteDistance;
  }
  set infiniteDistance(value) {
    if (this._infiniteDistance === value) {
      return;
    }
    this._infiniteDistance = value;
  }
  getClassName() {
    return "TransformNode";
  }
  get position() {
    return this._position;
  }
  set position(newPosition) {
    this._position = newPosition;
    this._isDirty = true;
  }
  isUsingPivotMatrix() {
    return this._usePivotMatrix;
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(newRotation) {
    this._rotation = newRotation;
    this._rotationQuaternion = null;
    this._isDirty = true;
  }
  get scaling() {
    return this._scaling;
  }
  set scaling(newScaling) {
    this._scaling = newScaling;
    this._isDirty = true;
  }
  get rotationQuaternion() {
    return this._rotationQuaternion;
  }
  set rotationQuaternion(quaternion) {
    this._rotationQuaternion = quaternion;
    if (quaternion) {
      this._rotation.setAll(0);
    }
    this._isDirty = true;
  }
  get forward() {
    Vector3.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1 : 1, this.getWorldMatrix(), this._forward);
    return this._forward.normalize();
  }
  get up() {
    Vector3.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up);
    return this._up.normalize();
  }
  get right() {
    Vector3.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1 : 1, 0, 0, this.getWorldMatrix(), this._right);
    return this._right.normalize();
  }
  updatePoseMatrix(matrix) {
    if (!this._poseMatrix) {
      this._poseMatrix = matrix.clone();
      return this;
    }
    this._poseMatrix.copyFrom(matrix);
    return this;
  }
  getPoseMatrix() {
    if (!this._poseMatrix) {
      this._poseMatrix = Matrix.Identity();
    }
    return this._poseMatrix;
  }
  _isSynchronized() {
    const cache = this._cache;
    if (this._billboardMode !== cache.billboardMode || this._billboardMode !== TransformNode.BILLBOARDMODE_NONE) {
      return false;
    }
    if (cache.pivotMatrixUpdated) {
      return false;
    }
    if (this._infiniteDistance) {
      return false;
    }
    if (this._position._isDirty) {
      return false;
    }
    if (this._scaling._isDirty) {
      return false;
    }
    if (this._rotationQuaternion && this._rotationQuaternion._isDirty || this._rotation._isDirty) {
      return false;
    }
    return true;
  }
  _initCache() {
    super._initCache();
    const cache = this._cache;
    cache.localMatrixUpdated = false;
    cache.billboardMode = -1;
    cache.infiniteDistance = false;
  }
  get absolutePosition() {
    return this.getAbsolutePosition();
  }
  get absoluteScaling() {
    this._syncAbsoluteScalingAndRotation();
    return this._absoluteScaling;
  }
  get absoluteRotationQuaternion() {
    this._syncAbsoluteScalingAndRotation();
    return this._absoluteRotationQuaternion;
  }
  setPreTransformMatrix(matrix) {
    return this.setPivotMatrix(matrix, false);
  }
  setPivotMatrix(matrix, postMultiplyPivotMatrix = true) {
    this._pivotMatrix.copyFrom(matrix);
    this._usePivotMatrix = !this._pivotMatrix.isIdentity();
    this._cache.pivotMatrixUpdated = true;
    this._postMultiplyPivotMatrix = postMultiplyPivotMatrix;
    if (this._postMultiplyPivotMatrix) {
      if (!this._pivotMatrixInverse) {
        this._pivotMatrixInverse = Matrix.Invert(this._pivotMatrix);
      } else {
        this._pivotMatrix.invertToRef(this._pivotMatrixInverse);
      }
    }
    return this;
  }
  getPivotMatrix() {
    return this._pivotMatrix;
  }
  instantiateHierarchy(newParent = null, options, onNewNodeCreated) {
    const clone = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true);
    if (clone) {
      if (onNewNodeCreated) {
        onNewNodeCreated(this, clone);
      }
    }
    for (const child of this.getChildTransformNodes(true)) {
      child.instantiateHierarchy(clone, options, onNewNodeCreated);
    }
    return clone;
  }
  freezeWorldMatrix(newWorldMatrix = null, decompose = false) {
    if (newWorldMatrix) {
      if (decompose) {
        this._rotation.setAll(0);
        this._rotationQuaternion = this._rotationQuaternion || Quaternion.Identity();
        newWorldMatrix.decompose(this._scaling, this._rotationQuaternion, this._position);
        this.computeWorldMatrix(true);
      } else {
        this._worldMatrix = newWorldMatrix;
        this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
        this._afterComputeWorldMatrix();
      }
    } else {
      this._isWorldMatrixFrozen = false;
      this.computeWorldMatrix(true);
    }
    this._isDirty = false;
    this._isWorldMatrixFrozen = true;
    return this;
  }
  unfreezeWorldMatrix() {
    this._isWorldMatrixFrozen = false;
    this.computeWorldMatrix(true);
    return this;
  }
  get isWorldMatrixFrozen() {
    return this._isWorldMatrixFrozen;
  }
  getAbsolutePosition() {
    this.computeWorldMatrix();
    return this._absolutePosition;
  }
  setAbsolutePosition(absolutePosition) {
    if (!absolutePosition) {
      return this;
    }
    let absolutePositionX;
    let absolutePositionY;
    let absolutePositionZ;
    if (absolutePosition.x === void 0) {
      if (arguments.length < 3) {
        return this;
      }
      absolutePositionX = arguments[0];
      absolutePositionY = arguments[1];
      absolutePositionZ = arguments[2];
    } else {
      absolutePositionX = absolutePosition.x;
      absolutePositionY = absolutePosition.y;
      absolutePositionZ = absolutePosition.z;
    }
    if (this.parent) {
      const invertParentWorldMatrix = TmpVectors.Matrix[0];
      this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);
      Vector3.TransformCoordinatesFromFloatsToRef(absolutePositionX, absolutePositionY, absolutePositionZ, invertParentWorldMatrix, this.position);
    } else {
      this.position.x = absolutePositionX;
      this.position.y = absolutePositionY;
      this.position.z = absolutePositionZ;
    }
    this._absolutePosition.copyFrom(absolutePosition);
    return this;
  }
  setPositionWithLocalVector(vector3) {
    this.computeWorldMatrix();
    this.position = Vector3.TransformNormal(vector3, this._localMatrix);
    return this;
  }
  getPositionExpressedInLocalSpace() {
    this.computeWorldMatrix();
    const invLocalWorldMatrix = TmpVectors.Matrix[0];
    this._localMatrix.invertToRef(invLocalWorldMatrix);
    return Vector3.TransformNormal(this.position, invLocalWorldMatrix);
  }
  locallyTranslate(vector3) {
    this.computeWorldMatrix(true);
    this.position = Vector3.TransformCoordinates(vector3, this._localMatrix);
    return this;
  }
  lookAt(targetPoint, yawCor = 0, pitchCor = 0, rollCor = 0, space = Space.LOCAL) {
    const dv = TransformNode._LookAtVectorCache;
    const pos = space === Space.LOCAL ? this.position : this.getAbsolutePosition();
    targetPoint.subtractToRef(pos, dv);
    this.setDirection(dv, yawCor, pitchCor, rollCor);
    if (space === Space.WORLD && this.parent) {
      if (this.rotationQuaternion) {
        const rotationMatrix = TmpVectors.Matrix[0];
        this.rotationQuaternion.toRotationMatrix(rotationMatrix);
        const parentRotationMatrix = TmpVectors.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
        parentRotationMatrix.invert();
        rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
        this.rotationQuaternion.fromRotationMatrix(rotationMatrix);
      } else {
        const quaternionRotation = TmpVectors.Quaternion[0];
        Quaternion.FromEulerVectorToRef(this.rotation, quaternionRotation);
        const rotationMatrix = TmpVectors.Matrix[0];
        quaternionRotation.toRotationMatrix(rotationMatrix);
        const parentRotationMatrix = TmpVectors.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
        parentRotationMatrix.invert();
        rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
        quaternionRotation.fromRotationMatrix(rotationMatrix);
        quaternionRotation.toEulerAnglesToRef(this.rotation);
      }
    }
    return this;
  }
  getDirection(localAxis) {
    const result = Vector3.Zero();
    this.getDirectionToRef(localAxis, result);
    return result;
  }
  getDirectionToRef(localAxis, result) {
    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
    return this;
  }
  setDirection(localAxis, yawCor = 0, pitchCor = 0, rollCor = 0) {
    const yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;
    const len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);
    const pitch = -Math.atan2(localAxis.y, len);
    if (this.rotationQuaternion) {
      Quaternion.RotationYawPitchRollToRef(yaw + yawCor, pitch + pitchCor, rollCor, this.rotationQuaternion);
    } else {
      this.rotation.x = pitch + pitchCor;
      this.rotation.y = yaw + yawCor;
      this.rotation.z = rollCor;
    }
    return this;
  }
  setPivotPoint(point, space = Space.LOCAL) {
    if (this.getScene().getRenderId() == 0) {
      this.computeWorldMatrix(true);
    }
    const wm = this.getWorldMatrix();
    if (space == Space.WORLD) {
      const tmat = TmpVectors.Matrix[0];
      wm.invertToRef(tmat);
      point = Vector3.TransformCoordinates(point, tmat);
    }
    return this.setPivotMatrix(Matrix.Translation(-point.x, -point.y, -point.z), true);
  }
  getPivotPoint() {
    const point = Vector3.Zero();
    this.getPivotPointToRef(point);
    return point;
  }
  getPivotPointToRef(result) {
    result.x = -this._pivotMatrix.m[12];
    result.y = -this._pivotMatrix.m[13];
    result.z = -this._pivotMatrix.m[14];
    return this;
  }
  getAbsolutePivotPoint() {
    const point = Vector3.Zero();
    this.getAbsolutePivotPointToRef(point);
    return point;
  }
  getAbsolutePivotPointToRef(result) {
    this.getPivotPointToRef(result);
    Vector3.TransformCoordinatesToRef(result, this.getWorldMatrix(), result);
    return this;
  }
  markAsDirty(property) {
    if (this._isDirty) {
      return this;
    }
    if (this._children) {
      for (const child of this._children) {
        child.markAsDirty(property);
      }
    }
    return super.markAsDirty(property);
  }
  setParent(node, preserveScalingSign = false, updatePivot = false) {
    if (!node && !this.parent) {
      return this;
    }
    const quatRotation = TmpVectors.Quaternion[0];
    const position = TmpVectors.Vector3[0];
    const scale = TmpVectors.Vector3[1];
    const invParentMatrix = TmpVectors.Matrix[1];
    Matrix.IdentityToRef(invParentMatrix);
    const composedMatrix = TmpVectors.Matrix[0];
    this.computeWorldMatrix(true);
    let currentRotation = this.rotationQuaternion;
    if (!currentRotation) {
      currentRotation = TransformNode._TmpRotation;
      Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, currentRotation);
    }
    Matrix.ComposeToRef(this.scaling, currentRotation, this.position, composedMatrix);
    if (this.parent) {
      composedMatrix.multiplyToRef(this.parent.computeWorldMatrix(true), composedMatrix);
    }
    if (node) {
      node.computeWorldMatrix(true).invertToRef(invParentMatrix);
      composedMatrix.multiplyToRef(invParentMatrix, composedMatrix);
    }
    composedMatrix.decompose(scale, quatRotation, position, preserveScalingSign ? this : void 0);
    if (this.rotationQuaternion) {
      this.rotationQuaternion.copyFrom(quatRotation);
    } else {
      quatRotation.toEulerAnglesToRef(this.rotation);
    }
    this.scaling.copyFrom(scale);
    this.position.copyFrom(position);
    this.parent = node;
    if (updatePivot) {
      this.setPivotMatrix(Matrix.Identity());
    }
    return this;
  }
  get nonUniformScaling() {
    return this._nonUniformScaling;
  }
  _updateNonUniformScalingState(value) {
    if (this._nonUniformScaling === value) {
      return false;
    }
    this._nonUniformScaling = value;
    return true;
  }
  attachToBone(bone, affectedTransformNode) {
    this._currentParentWhenAttachingToBone = this.parent;
    this._transformToBoneReferal = affectedTransformNode;
    this.parent = bone;
    bone.getSkeleton().prepare();
    if (bone.getWorldMatrix().determinant() < 0) {
      this.scalingDeterminant *= -1;
    }
    return this;
  }
  detachFromBone(resetToPreviousParent = false) {
    if (!this.parent) {
      if (resetToPreviousParent) {
        this.parent = this._currentParentWhenAttachingToBone;
      }
      return this;
    }
    if (this.parent.getWorldMatrix().determinant() < 0) {
      this.scalingDeterminant *= -1;
    }
    this._transformToBoneReferal = null;
    if (resetToPreviousParent) {
      this.parent = this._currentParentWhenAttachingToBone;
    } else {
      this.parent = null;
    }
    return this;
  }
  rotate(axis, amount, space) {
    axis.normalize();
    if (!this.rotationQuaternion) {
      this.rotationQuaternion = this.rotation.toQuaternion();
      this.rotation.setAll(0);
    }
    let rotationQuaternion;
    if (!space || space === Space.LOCAL) {
      rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);
      this.rotationQuaternion.multiplyToRef(rotationQuaternion, this.rotationQuaternion);
    } else {
      if (this.parent) {
        const invertParentWorldMatrix = TmpVectors.Matrix[0];
        this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);
        axis = Vector3.TransformNormal(axis, invertParentWorldMatrix);
      }
      rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);
      rotationQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    }
    return this;
  }
  rotateAround(point, axis, amount) {
    axis.normalize();
    if (!this.rotationQuaternion) {
      this.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
      this.rotation.setAll(0);
    }
    const tmpVector = TmpVectors.Vector3[0];
    const finalScale = TmpVectors.Vector3[1];
    const finalTranslation = TmpVectors.Vector3[2];
    const finalRotation = TmpVectors.Quaternion[0];
    const translationMatrix = TmpVectors.Matrix[0];
    const translationMatrixInv = TmpVectors.Matrix[1];
    const rotationMatrix = TmpVectors.Matrix[2];
    const finalMatrix = TmpVectors.Matrix[3];
    point.subtractToRef(this.position, tmpVector);
    Matrix.TranslationToRef(tmpVector.x, tmpVector.y, tmpVector.z, translationMatrix);
    Matrix.TranslationToRef(-tmpVector.x, -tmpVector.y, -tmpVector.z, translationMatrixInv);
    Matrix.RotationAxisToRef(axis, amount, rotationMatrix);
    translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix);
    finalMatrix.multiplyToRef(translationMatrix, finalMatrix);
    finalMatrix.decompose(finalScale, finalRotation, finalTranslation);
    this.position.addInPlace(finalTranslation);
    finalRotation.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    return this;
  }
  translate(axis, distance, space) {
    const displacementVector = axis.scale(distance);
    if (!space || space === Space.LOCAL) {
      const tempV3 = this.getPositionExpressedInLocalSpace().add(displacementVector);
      this.setPositionWithLocalVector(tempV3);
    } else {
      this.setAbsolutePosition(this.getAbsolutePosition().add(displacementVector));
    }
    return this;
  }
  addRotation(x, y, z) {
    let rotationQuaternion;
    if (this.rotationQuaternion) {
      rotationQuaternion = this.rotationQuaternion;
    } else {
      rotationQuaternion = TmpVectors.Quaternion[1];
      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, rotationQuaternion);
    }
    const accumulation = TmpVectors.Quaternion[0];
    Quaternion.RotationYawPitchRollToRef(y, x, z, accumulation);
    rotationQuaternion.multiplyInPlace(accumulation);
    if (!this.rotationQuaternion) {
      rotationQuaternion.toEulerAnglesToRef(this.rotation);
    }
    return this;
  }
  _getEffectiveParent() {
    return this.parent;
  }
  computeWorldMatrix(force) {
    if (this._isWorldMatrixFrozen && !this._isDirty) {
      return this._worldMatrix;
    }
    const currentRenderId = this.getScene().getRenderId();
    if (!this._isDirty && !force && (this._currentRenderId === currentRenderId || this.isSynchronized())) {
      this._currentRenderId = currentRenderId;
      return this._worldMatrix;
    }
    const camera = this.getScene().activeCamera;
    const useBillboardPosition = (this._billboardMode & TransformNode.BILLBOARDMODE_USE_POSITION) !== 0;
    const useBillboardPath = this._billboardMode !== TransformNode.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;
    this._updateCache();
    const cache = this._cache;
    cache.pivotMatrixUpdated = false;
    cache.billboardMode = this.billboardMode;
    cache.infiniteDistance = this.infiniteDistance;
    cache.parent = this._parentNode;
    this._currentRenderId = currentRenderId;
    this._childUpdateId += 1;
    this._isDirty = false;
    this._position._isDirty = false;
    this._rotation._isDirty = false;
    this._scaling._isDirty = false;
    const parent = this._getEffectiveParent();
    const scaling = TransformNode._TmpScaling;
    let translation = this._position;
    if (this._infiniteDistance) {
      if (!this.parent && camera) {
        const cameraWorldMatrix = camera.getWorldMatrix();
        const cameraGlobalPosition = new Vector3(cameraWorldMatrix.m[12], cameraWorldMatrix.m[13], cameraWorldMatrix.m[14]);
        translation = TransformNode._TmpTranslation;
        translation.copyFromFloats(this._position.x + cameraGlobalPosition.x, this._position.y + cameraGlobalPosition.y, this._position.z + cameraGlobalPosition.z);
      }
    }
    scaling.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);
    let rotation;
    if (this._rotationQuaternion) {
      this._rotationQuaternion._isDirty = false;
      rotation = this._rotationQuaternion;
      if (this.reIntegrateRotationIntoRotationQuaternion) {
        const len = this.rotation.lengthSquared();
        if (len) {
          this._rotationQuaternion.multiplyInPlace(Quaternion.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z));
          this._rotation.copyFromFloats(0, 0, 0);
        }
      }
    } else {
      rotation = TransformNode._TmpRotation;
      Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, rotation);
    }
    if (this._usePivotMatrix) {
      const scaleMatrix = TmpVectors.Matrix[1];
      Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, scaleMatrix);
      const rotationMatrix = TmpVectors.Matrix[0];
      rotation.toRotationMatrix(rotationMatrix);
      this._pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);
      TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, this._localMatrix);
      if (this._postMultiplyPivotMatrix) {
        this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix);
      }
      this._localMatrix.addTranslationFromFloats(translation.x, translation.y, translation.z);
    } else {
      Matrix.ComposeToRef(scaling, rotation, translation, this._localMatrix);
    }
    if (parent && parent.getWorldMatrix) {
      if (force) {
        parent.computeWorldMatrix(force);
      }
      if (useBillboardPath) {
        if (this._transformToBoneReferal) {
          parent.getWorldMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), TmpVectors.Matrix[7]);
        } else {
          TmpVectors.Matrix[7].copyFrom(parent.getWorldMatrix());
        }
        const translation2 = TmpVectors.Vector3[5];
        const scale = TmpVectors.Vector3[6];
        const orientation = TmpVectors.Quaternion[0];
        TmpVectors.Matrix[7].decompose(scale, orientation, translation2);
        Matrix.ScalingToRef(scale.x, scale.y, scale.z, TmpVectors.Matrix[7]);
        TmpVectors.Matrix[7].setTranslation(translation2);
        if (TransformNode.BillboardUseParentOrientation) {
          this._position.applyRotationQuaternionToRef(orientation, translation2);
          this._localMatrix.setTranslation(translation2);
        }
        this._localMatrix.multiplyToRef(TmpVectors.Matrix[7], this._worldMatrix);
      } else {
        if (this._transformToBoneReferal) {
          this._localMatrix.multiplyToRef(parent.getWorldMatrix(), TmpVectors.Matrix[6]);
          TmpVectors.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix);
        } else {
          this._localMatrix.multiplyToRef(parent.getWorldMatrix(), this._worldMatrix);
        }
      }
      this._markSyncedWithParent();
    } else {
      this._worldMatrix.copyFrom(this._localMatrix);
    }
    if (useBillboardPath && camera && this.billboardMode && !useBillboardPosition) {
      const storedTranslation = TmpVectors.Vector3[0];
      this._worldMatrix.getTranslationToRef(storedTranslation);
      TmpVectors.Matrix[1].copyFrom(camera.getViewMatrix());
      TmpVectors.Matrix[1].setTranslationFromFloats(0, 0, 0);
      TmpVectors.Matrix[1].invertToRef(TmpVectors.Matrix[0]);
      if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {
        TmpVectors.Matrix[0].decompose(void 0, TmpVectors.Quaternion[0], void 0);
        const eulerAngles = TmpVectors.Vector3[1];
        TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);
        if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {
          eulerAngles.x = 0;
        }
        if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {
          eulerAngles.y = 0;
        }
        if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {
          eulerAngles.z = 0;
        }
        Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);
      }
      this._worldMatrix.setTranslationFromFloats(0, 0, 0);
      this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);
      this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);
    } else if (useBillboardPath && camera && this.billboardMode && useBillboardPosition) {
      const storedTranslation = TmpVectors.Vector3[0];
      this._worldMatrix.getTranslationToRef(storedTranslation);
      const cameraPosition = camera.globalPosition;
      this._worldMatrix.invertToRef(TmpVectors.Matrix[1]);
      const camInObjSpace = TmpVectors.Vector3[1];
      Vector3.TransformCoordinatesToRef(cameraPosition, TmpVectors.Matrix[1], camInObjSpace);
      camInObjSpace.normalize();
      const yaw = -Math.atan2(camInObjSpace.z, camInObjSpace.x) + Math.PI / 2;
      const len = Math.sqrt(camInObjSpace.x * camInObjSpace.x + camInObjSpace.z * camInObjSpace.z);
      const pitch = -Math.atan2(camInObjSpace.y, len);
      Quaternion.RotationYawPitchRollToRef(yaw, pitch, 0, TmpVectors.Quaternion[0]);
      if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {
        const eulerAngles = TmpVectors.Vector3[1];
        TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);
        if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {
          eulerAngles.x = 0;
        }
        if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {
          eulerAngles.y = 0;
        }
        if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {
          eulerAngles.z = 0;
        }
        Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);
      } else {
        Matrix.FromQuaternionToRef(TmpVectors.Quaternion[0], TmpVectors.Matrix[0]);
      }
      this._worldMatrix.setTranslationFromFloats(0, 0, 0);
      this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);
      this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);
    }
    if (!this.ignoreNonUniformScaling) {
      if (this._scaling.isNonUniformWithinEpsilon(1e-6)) {
        this._updateNonUniformScalingState(true);
      } else if (parent && parent._nonUniformScaling) {
        this._updateNonUniformScalingState(parent._nonUniformScaling);
      } else {
        this._updateNonUniformScalingState(false);
      }
    } else {
      this._updateNonUniformScalingState(false);
    }
    this._afterComputeWorldMatrix();
    this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
    this._isAbsoluteSynced = false;
    this.onAfterWorldMatrixUpdateObservable.notifyObservers(this);
    if (!this._poseMatrix) {
      this._poseMatrix = Matrix.Invert(this._worldMatrix);
    }
    this._worldMatrixDeterminantIsDirty = true;
    return this._worldMatrix;
  }
  resetLocalMatrix(independentOfChildren = true) {
    this.computeWorldMatrix();
    if (independentOfChildren) {
      const children = this.getChildren();
      for (let i = 0; i < children.length; ++i) {
        const child = children[i];
        if (child) {
          child.computeWorldMatrix();
          const bakedMatrix = TmpVectors.Matrix[0];
          child._localMatrix.multiplyToRef(this._localMatrix, bakedMatrix);
          const tmpRotationQuaternion = TmpVectors.Quaternion[0];
          bakedMatrix.decompose(child.scaling, tmpRotationQuaternion, child.position);
          if (child.rotationQuaternion) {
            child.rotationQuaternion.copyFrom(tmpRotationQuaternion);
          } else {
            tmpRotationQuaternion.toEulerAnglesToRef(child.rotation);
          }
        }
      }
    }
    this.scaling.copyFromFloats(1, 1, 1);
    this.position.copyFromFloats(0, 0, 0);
    this.rotation.copyFromFloats(0, 0, 0);
    if (this.rotationQuaternion) {
      this.rotationQuaternion = Quaternion.Identity();
    }
    this._worldMatrix = Matrix.Identity();
  }
  _afterComputeWorldMatrix() {
  }
  registerAfterWorldMatrixUpdate(func) {
    this.onAfterWorldMatrixUpdateObservable.add(func);
    return this;
  }
  unregisterAfterWorldMatrixUpdate(func) {
    this.onAfterWorldMatrixUpdateObservable.removeCallback(func);
    return this;
  }
  getPositionInCameraSpace(camera = null) {
    if (!camera) {
      camera = this.getScene().activeCamera;
    }
    return Vector3.TransformCoordinates(this.getAbsolutePosition(), camera.getViewMatrix());
  }
  getDistanceToCamera(camera = null) {
    if (!camera) {
      camera = this.getScene().activeCamera;
    }
    return this.getAbsolutePosition().subtract(camera.globalPosition).length();
  }
  clone(name63, newParent, doNotCloneChildren) {
    const result = SerializationHelper.Clone(() => new TransformNode(name63, this.getScene()), this);
    result.name = name63;
    result.id = name63;
    if (newParent) {
      result.parent = newParent;
    }
    if (!doNotCloneChildren) {
      const directDescendants = this.getDescendants(true);
      for (let index = 0; index < directDescendants.length; index++) {
        const child = directDescendants[index];
        if (child.clone) {
          child.clone(name63 + "." + child.name, result);
        }
      }
    }
    return result;
  }
  serialize(currentSerializationObject) {
    const serializationObject = SerializationHelper.Serialize(this, currentSerializationObject);
    serializationObject.type = this.getClassName();
    serializationObject.uniqueId = this.uniqueId;
    if (this.parent) {
      this.parent._serializeAsParent(serializationObject);
    }
    serializationObject.localMatrix = this.getPivotMatrix().asArray();
    serializationObject.isEnabled = this.isEnabled();
    return serializationObject;
  }
  static Parse(parsedTransformNode, scene, rootUrl) {
    const transformNode = SerializationHelper.Parse(() => new TransformNode(parsedTransformNode.name, scene), parsedTransformNode, scene, rootUrl);
    if (parsedTransformNode.localMatrix) {
      transformNode.setPreTransformMatrix(Matrix.FromArray(parsedTransformNode.localMatrix));
    } else if (parsedTransformNode.pivotMatrix) {
      transformNode.setPivotMatrix(Matrix.FromArray(parsedTransformNode.pivotMatrix));
    }
    transformNode.setEnabled(parsedTransformNode.isEnabled);
    transformNode._waitingParsedUniqueId = parsedTransformNode.uniqueId;
    if (parsedTransformNode.parentId !== void 0) {
      transformNode._waitingParentId = parsedTransformNode.parentId;
    }
    if (parsedTransformNode.parentInstanceIndex !== void 0) {
      transformNode._waitingParentInstanceIndex = parsedTransformNode.parentInstanceIndex;
    }
    return transformNode;
  }
  getChildTransformNodes(directDescendantsOnly, predicate) {
    const results = [];
    this._getDescendants(results, directDescendantsOnly, (node) => {
      return (!predicate || predicate(node)) && node instanceof TransformNode;
    });
    return results;
  }
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this.getScene().stopAnimation(this);
    this.getScene().removeTransformNode(this);
    if (this._parentContainer) {
      const index = this._parentContainer.transformNodes.indexOf(this);
      if (index > -1) {
        this._parentContainer.transformNodes.splice(index, 1);
      }
      this._parentContainer = null;
    }
    this.onAfterWorldMatrixUpdateObservable.clear();
    if (doNotRecurse) {
      const transformNodes = this.getChildTransformNodes(true);
      for (const transformNode of transformNodes) {
        transformNode.parent = null;
        transformNode.computeWorldMatrix(true);
      }
    }
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate) {
    let storedRotation = null;
    let storedRotationQuaternion = null;
    if (ignoreRotation) {
      if (this.rotationQuaternion) {
        storedRotationQuaternion = this.rotationQuaternion.clone();
        this.rotationQuaternion.copyFromFloats(0, 0, 0, 1);
      } else if (this.rotation) {
        storedRotation = this.rotation.clone();
        this.rotation.copyFromFloats(0, 0, 0);
      }
    }
    const boundingVectors = this.getHierarchyBoundingVectors(includeDescendants, predicate);
    const sizeVec = boundingVectors.max.subtract(boundingVectors.min);
    const maxDimension = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
    if (maxDimension === 0) {
      return this;
    }
    const scale = 1 / maxDimension;
    this.scaling.scaleInPlace(scale);
    if (ignoreRotation) {
      if (this.rotationQuaternion && storedRotationQuaternion) {
        this.rotationQuaternion.copyFrom(storedRotationQuaternion);
      } else if (this.rotation && storedRotation) {
        this.rotation.copyFrom(storedRotation);
      }
    }
    return this;
  }
  _syncAbsoluteScalingAndRotation() {
    if (!this._isAbsoluteSynced) {
      this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion);
      this._isAbsoluteSynced = true;
    }
  }
};
TransformNode.BILLBOARDMODE_NONE = 0;
TransformNode.BILLBOARDMODE_X = 1;
TransformNode.BILLBOARDMODE_Y = 2;
TransformNode.BILLBOARDMODE_Z = 4;
TransformNode.BILLBOARDMODE_ALL = 7;
TransformNode.BILLBOARDMODE_USE_POSITION = 128;
TransformNode.BillboardUseParentOrientation = false;
TransformNode._TmpRotation = Quaternion.Zero();
TransformNode._TmpScaling = Vector3.Zero();
TransformNode._TmpTranslation = Vector3.Zero();
TransformNode._LookAtVectorCache = new Vector3(0, 0, 0);
TransformNode._RotationAxisCache = new Quaternion();
__decorate([
  serializeAsVector3("position")
], TransformNode.prototype, "_position", void 0);
__decorate([
  serializeAsVector3("rotation")
], TransformNode.prototype, "_rotation", void 0);
__decorate([
  serializeAsQuaternion("rotationQuaternion")
], TransformNode.prototype, "_rotationQuaternion", void 0);
__decorate([
  serializeAsVector3("scaling")
], TransformNode.prototype, "_scaling", void 0);
__decorate([
  serialize("billboardMode")
], TransformNode.prototype, "_billboardMode", void 0);
__decorate([
  serialize()
], TransformNode.prototype, "scalingDeterminant", void 0);
__decorate([
  serialize("infiniteDistance")
], TransformNode.prototype, "_infiniteDistance", void 0);
__decorate([
  serialize()
], TransformNode.prototype, "ignoreNonUniformScaling", void 0);
__decorate([
  serialize()
], TransformNode.prototype, "reIntegrateRotationIntoRotationQuaternion", void 0);

// node_modules/@babylonjs/core/Collisions/meshCollisionData.js
var _MeshCollisionData = class {
  constructor() {
    this._checkCollisions = false;
    this._collisionMask = -1;
    this._collisionGroup = -1;
    this._surroundingMeshes = null;
    this._collider = null;
    this._oldPositionForCollisions = new Vector3(0, 0, 0);
    this._diffPositionForCollisions = new Vector3(0, 0, 0);
    this._collisionResponse = true;
  }
};

// node_modules/@babylonjs/core/Meshes/abstractMesh.js
var _FacetDataStorage = class {
  constructor() {
    this.facetNb = 0;
    this.partitioningSubdivisions = 10;
    this.partitioningBBoxRatio = 1.01;
    this.facetDataEnabled = false;
    this.facetParameters = {};
    this.bbSize = Vector3.Zero();
    this.subDiv = {
      max: 1,
      X: 1,
      Y: 1,
      Z: 1
    };
    this.facetDepthSort = false;
    this.facetDepthSortEnabled = false;
  }
};
var _InternalAbstractMeshDataInfo = class {
  constructor() {
    this._hasVertexAlpha = false;
    this._useVertexColors = true;
    this._numBoneInfluencers = 4;
    this._applyFog = true;
    this._receiveShadows = false;
    this._facetData = new _FacetDataStorage();
    this._visibility = 1;
    this._skeleton = null;
    this._layerMask = 268435455;
    this._computeBonesUsingShaders = true;
    this._isActive = false;
    this._onlyForInstances = false;
    this._isActiveIntermediate = false;
    this._onlyForInstancesIntermediate = false;
    this._actAsRegularMesh = false;
    this._currentLOD = null;
    this._currentLODIsUpToDate = false;
    this._collisionRetryCount = 3;
    this._morphTargetManager = null;
    this._renderingGroupId = 0;
    this._bakedVertexAnimationManager = null;
    this._material = null;
    this._positions = null;
    this._pointerOverDisableMeshTesting = false;
    this._meshCollisionData = new _MeshCollisionData();
    this._enableDistantPicking = false;
  }
};
var AbstractMesh = class extends TransformNode {
  constructor(name63, scene = null) {
    super(name63, scene, false);
    this._internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();
    this._waitingMaterialId = null;
    this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
    this.onCollideObservable = new Observable();
    this.onCollisionPositionChangeObservable = new Observable();
    this.onMaterialChangedObservable = new Observable();
    this.definedFacingForward = true;
    this._occlusionQuery = null;
    this._renderingGroup = null;
    this.alphaIndex = Number.MAX_VALUE;
    this.isVisible = true;
    this.isPickable = true;
    this.isNearPickable = false;
    this.isNearGrabbable = false;
    this.showSubMeshesBoundingBox = false;
    this.isBlocker = false;
    this.enablePointerMoveEvents = false;
    this.outlineColor = Color3.Red();
    this.outlineWidth = 0.02;
    this.overlayColor = Color3.Red();
    this.overlayAlpha = 0.5;
    this.useOctreeForRenderingSelection = true;
    this.useOctreeForPicking = true;
    this.useOctreeForCollisions = true;
    this.alwaysSelectAsActiveMesh = false;
    this.doNotSyncBoundingInfo = false;
    this.actionManager = null;
    this.ellipsoid = new Vector3(0.5, 1, 0.5);
    this.ellipsoidOffset = new Vector3(0, 0, 0);
    this.edgesWidth = 1;
    this.edgesColor = new Color4(1, 0, 0, 1);
    this._edgesRenderer = null;
    this._masterMesh = null;
    this._boundingInfo = null;
    this._boundingInfoIsDirty = true;
    this._renderId = 0;
    this._intersectionsInProgress = new Array();
    this._unIndexed = false;
    this._lightSources = new Array();
    this._waitingData = {
      lods: null,
      actions: null,
      freezeWorldMatrix: null
    };
    this._bonesTransformMatrices = null;
    this._transformMatrixTexture = null;
    this.onRebuildObservable = new Observable();
    this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {
      newPosition.subtractToRef(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);
      if (this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > Engine.CollisionsEpsilon) {
        this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);
      }
      if (collidedMesh) {
        this.onCollideObservable.notifyObservers(collidedMesh);
      }
      this.onCollisionPositionChangeObservable.notifyObservers(this.position);
    };
    scene = this.getScene();
    scene.addMesh(this);
    this._resyncLightSources();
    this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), void 0, void 0, name63, !this.getScene().getEngine().isWebGPU);
    this._buildUniformLayout();
    switch (scene.performancePriority) {
      case ScenePerformancePriority.Aggressive:
        this.doNotSyncBoundingInfo = true;
      case ScenePerformancePriority.Intermediate:
        this.alwaysSelectAsActiveMesh = true;
        this.isPickable = false;
        break;
    }
  }
  static get BILLBOARDMODE_NONE() {
    return TransformNode.BILLBOARDMODE_NONE;
  }
  static get BILLBOARDMODE_X() {
    return TransformNode.BILLBOARDMODE_X;
  }
  static get BILLBOARDMODE_Y() {
    return TransformNode.BILLBOARDMODE_Y;
  }
  static get BILLBOARDMODE_Z() {
    return TransformNode.BILLBOARDMODE_Z;
  }
  static get BILLBOARDMODE_ALL() {
    return TransformNode.BILLBOARDMODE_ALL;
  }
  static get BILLBOARDMODE_USE_POSITION() {
    return TransformNode.BILLBOARDMODE_USE_POSITION;
  }
  get facetNb() {
    return this._internalAbstractMeshDataInfo._facetData.facetNb;
  }
  get partitioningSubdivisions() {
    return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;
  }
  set partitioningSubdivisions(nb) {
    this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;
  }
  get partitioningBBoxRatio() {
    return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;
  }
  set partitioningBBoxRatio(ratio) {
    this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;
  }
  get mustDepthSortFacets() {
    return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;
  }
  set mustDepthSortFacets(sort) {
    this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;
  }
  get facetDepthSortFrom() {
    return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;
  }
  set facetDepthSortFrom(location2) {
    this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location2;
  }
  get collisionRetryCount() {
    return this._internalAbstractMeshDataInfo._collisionRetryCount;
  }
  set collisionRetryCount(retryCount) {
    this._internalAbstractMeshDataInfo._collisionRetryCount = retryCount;
  }
  get isFacetDataEnabled() {
    return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;
  }
  get morphTargetManager() {
    return this._internalAbstractMeshDataInfo._morphTargetManager;
  }
  set morphTargetManager(value) {
    if (this._internalAbstractMeshDataInfo._morphTargetManager === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._morphTargetManager = value;
    this._syncGeometryWithMorphTargetManager();
  }
  get bakedVertexAnimationManager() {
    return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;
  }
  set bakedVertexAnimationManager(value) {
    if (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = value;
    this._markSubMeshesAsAttributesDirty();
  }
  _syncGeometryWithMorphTargetManager() {
  }
  _updateNonUniformScalingState(value) {
    if (!super._updateNonUniformScalingState(value)) {
      return false;
    }
    this._markSubMeshesAsMiscDirty();
    return true;
  }
  set onCollide(callback) {
    if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver) {
      this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver);
    }
    this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);
  }
  set onCollisionPositionChange(callback) {
    if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver) {
      this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver);
    }
    this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);
  }
  get visibility() {
    return this._internalAbstractMeshDataInfo._visibility;
  }
  set visibility(value) {
    if (this._internalAbstractMeshDataInfo._visibility === value) {
      return;
    }
    const oldValue = this._internalAbstractMeshDataInfo._visibility;
    this._internalAbstractMeshDataInfo._visibility = value;
    if (oldValue === 1 && value !== 1 || oldValue !== 1 && value === 1) {
      this._markSubMeshesAsMiscDirty();
    }
  }
  get pointerOverDisableMeshTesting() {
    return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting;
  }
  set pointerOverDisableMeshTesting(disable) {
    this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting = disable;
  }
  get renderingGroupId() {
    return this._internalAbstractMeshDataInfo._renderingGroupId;
  }
  set renderingGroupId(value) {
    this._internalAbstractMeshDataInfo._renderingGroupId = value;
  }
  get material() {
    return this._internalAbstractMeshDataInfo._material;
  }
  set material(value) {
    if (this._internalAbstractMeshDataInfo._material === value) {
      return;
    }
    if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {
      this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0;
    }
    this._internalAbstractMeshDataInfo._material = value;
    if (value && value.meshMap) {
      value.meshMap[this.uniqueId] = this;
    }
    if (this.onMaterialChangedObservable.hasObservers()) {
      this.onMaterialChangedObservable.notifyObservers(this);
    }
    if (!this.subMeshes) {
      return;
    }
    this.resetDrawCache();
    this._unBindEffect();
  }
  getMaterialForRenderPass(renderPassId) {
    var _a;
    return (_a = this._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[renderPassId];
  }
  setMaterialForRenderPass(renderPassId, material) {
    this.resetDrawCache(renderPassId);
    if (!this._internalAbstractMeshDataInfo._materialForRenderPass) {
      this._internalAbstractMeshDataInfo._materialForRenderPass = [];
    }
    this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId] = material;
  }
  get receiveShadows() {
    return this._internalAbstractMeshDataInfo._receiveShadows;
  }
  set receiveShadows(value) {
    if (this._internalAbstractMeshDataInfo._receiveShadows === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._receiveShadows = value;
    this._markSubMeshesAsLightDirty();
  }
  get hasVertexAlpha() {
    return this._internalAbstractMeshDataInfo._hasVertexAlpha;
  }
  set hasVertexAlpha(value) {
    if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._hasVertexAlpha = value;
    this._markSubMeshesAsAttributesDirty();
    this._markSubMeshesAsMiscDirty();
  }
  get useVertexColors() {
    return this._internalAbstractMeshDataInfo._useVertexColors;
  }
  set useVertexColors(value) {
    if (this._internalAbstractMeshDataInfo._useVertexColors === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._useVertexColors = value;
    this._markSubMeshesAsAttributesDirty();
  }
  get computeBonesUsingShaders() {
    return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
  }
  set computeBonesUsingShaders(value) {
    if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;
    this._markSubMeshesAsAttributesDirty();
  }
  get numBoneInfluencers() {
    return this._internalAbstractMeshDataInfo._numBoneInfluencers;
  }
  set numBoneInfluencers(value) {
    if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._numBoneInfluencers = value;
    this._markSubMeshesAsAttributesDirty();
  }
  get applyFog() {
    return this._internalAbstractMeshDataInfo._applyFog;
  }
  set applyFog(value) {
    if (this._internalAbstractMeshDataInfo._applyFog === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._applyFog = value;
    this._markSubMeshesAsMiscDirty();
  }
  get enableDistantPicking() {
    return this._internalAbstractMeshDataInfo._enableDistantPicking;
  }
  set enableDistantPicking(value) {
    this._internalAbstractMeshDataInfo._enableDistantPicking = value;
  }
  get layerMask() {
    return this._internalAbstractMeshDataInfo._layerMask;
  }
  set layerMask(value) {
    if (value === this._internalAbstractMeshDataInfo._layerMask) {
      return;
    }
    this._internalAbstractMeshDataInfo._layerMask = value;
    this._resyncLightSources();
  }
  get collisionMask() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;
  }
  set collisionMask(mask) {
    this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;
  }
  get collisionResponse() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;
  }
  set collisionResponse(response) {
    this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = response;
  }
  get collisionGroup() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;
  }
  set collisionGroup(mask) {
    this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;
  }
  get surroundingMeshes() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;
  }
  set surroundingMeshes(meshes) {
    this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = meshes;
  }
  get lightSources() {
    return this._lightSources;
  }
  get _positions() {
    return null;
  }
  set skeleton(value) {
    const skeleton = this._internalAbstractMeshDataInfo._skeleton;
    if (skeleton && skeleton.needInitialSkinMatrix) {
      skeleton._unregisterMeshWithPoseMatrix(this);
    }
    if (value && value.needInitialSkinMatrix) {
      value._registerMeshWithPoseMatrix(this);
    }
    this._internalAbstractMeshDataInfo._skeleton = value;
    if (!this._internalAbstractMeshDataInfo._skeleton) {
      this._bonesTransformMatrices = null;
    }
    this._markSubMeshesAsAttributesDirty();
  }
  get skeleton() {
    return this._internalAbstractMeshDataInfo._skeleton;
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("world", 16);
    this._uniformBuffer.addUniform("visibility", 1);
    this._uniformBuffer.create();
  }
  transferToEffect(world) {
    const ubo = this._uniformBuffer;
    ubo.updateMatrix("world", world);
    ubo.updateFloat("visibility", this._internalAbstractMeshDataInfo._visibility);
    ubo.update();
  }
  getMeshUniformBuffer() {
    return this._uniformBuffer;
  }
  getClassName() {
    return "AbstractMesh";
  }
  toString(fullDetails) {
    let ret = "Name: " + this.name + ", isInstance: " + (this.getClassName() !== "InstancedMesh" ? "YES" : "NO");
    ret += ", # of submeshes: " + (this.subMeshes ? this.subMeshes.length : 0);
    const skeleton = this._internalAbstractMeshDataInfo._skeleton;
    if (skeleton) {
      ret += ", skeleton: " + skeleton.name;
    }
    if (fullDetails) {
      ret += ", billboard mode: " + ["NONE", "X", "Y", null, "Z", null, null, "ALL"][this.billboardMode];
      ret += ", freeze wrld mat: " + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? "YES" : "NO");
    }
    return ret;
  }
  _getEffectiveParent() {
    if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {
      return this._masterMesh;
    }
    return super._getEffectiveParent();
  }
  _getActionManagerForTrigger(trigger, initialCall = true) {
    if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {
      if (trigger) {
        if (this.actionManager.hasSpecificTrigger(trigger)) {
          return this.actionManager;
        }
      } else {
        return this.actionManager;
      }
    }
    if (!this.parent) {
      return null;
    }
    return this.parent._getActionManagerForTrigger(trigger, false);
  }
  _rebuild(dispose = false) {
    this.onRebuildObservable.notifyObservers(this);
    if (this._occlusionQuery !== null) {
      this._occlusionQuery = null;
    }
    if (!this.subMeshes) {
      return;
    }
    for (const subMesh of this.subMeshes) {
      subMesh._rebuild();
    }
  }
  _resyncLightSources() {
    this._lightSources.length = 0;
    for (const light of this.getScene().lights) {
      if (!light.isEnabled()) {
        continue;
      }
      if (light.canAffectMesh(this)) {
        this._lightSources.push(light);
      }
    }
    this._markSubMeshesAsLightDirty();
  }
  _resyncLightSource(light) {
    const isIn = light.isEnabled() && light.canAffectMesh(this);
    const index = this._lightSources.indexOf(light);
    let removed = false;
    if (index === -1) {
      if (!isIn) {
        return;
      }
      this._lightSources.push(light);
    } else {
      if (isIn) {
        return;
      }
      removed = true;
      this._lightSources.splice(index, 1);
    }
    this._markSubMeshesAsLightDirty(removed);
  }
  _unBindEffect() {
    for (const subMesh of this.subMeshes) {
      subMesh.setEffect(null);
    }
  }
  _removeLightSource(light, dispose) {
    const index = this._lightSources.indexOf(light);
    if (index === -1) {
      return;
    }
    this._lightSources.splice(index, 1);
    this._markSubMeshesAsLightDirty(dispose);
  }
  _markSubMeshesAsDirty(func) {
    if (!this.subMeshes) {
      return;
    }
    for (const subMesh of this.subMeshes) {
      for (let i = 0; i < subMesh._drawWrappers.length; ++i) {
        const drawWrapper = subMesh._drawWrappers[i];
        if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {
          continue;
        }
        func(drawWrapper.defines);
      }
    }
  }
  _markSubMeshesAsLightDirty(dispose = false) {
    this._markSubMeshesAsDirty((defines) => defines.markAsLightDirty(dispose));
  }
  _markSubMeshesAsAttributesDirty() {
    this._markSubMeshesAsDirty((defines) => defines.markAsAttributesDirty());
  }
  _markSubMeshesAsMiscDirty() {
    this._markSubMeshesAsDirty((defines) => defines.markAsMiscDirty());
  }
  markAsDirty(property) {
    this._currentRenderId = Number.MAX_VALUE;
    this._isDirty = true;
    return this;
  }
  resetDrawCache(passId) {
    if (!this.subMeshes) {
      return;
    }
    for (const subMesh of this.subMeshes) {
      subMesh.resetDrawCache(passId);
    }
  }
  get isBlocked() {
    return false;
  }
  getLOD(camera) {
    return this;
  }
  getTotalVertices() {
    return 0;
  }
  getTotalIndices() {
    return 0;
  }
  getIndices() {
    return null;
  }
  getVerticesData(kind) {
    return null;
  }
  setVerticesData(kind, data, updatable, stride) {
    return this;
  }
  updateVerticesData(kind, data, updateExtends, makeItUnique) {
    return this;
  }
  setIndices(indices, totalVertices) {
    return this;
  }
  isVerticesDataPresent(kind) {
    return false;
  }
  getBoundingInfo() {
    if (this._masterMesh) {
      return this._masterMesh.getBoundingInfo();
    }
    if (this._boundingInfoIsDirty) {
      this._boundingInfoIsDirty = false;
      this._updateBoundingInfo();
    }
    return this._boundingInfo;
  }
  setBoundingInfo(boundingInfo) {
    this._boundingInfo = boundingInfo;
    return this;
  }
  get hasBoundingInfo() {
    return this._boundingInfo !== null;
  }
  buildBoundingInfo(minimum, maximum, worldMatrix) {
    this._boundingInfo = new BoundingInfo(minimum, maximum, worldMatrix);
    return this._boundingInfo;
  }
  normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate) {
    return super.normalizeToUnitCube(includeDescendants, ignoreRotation, predicate);
  }
  get useBones() {
    return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) && this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind);
  }
  _preActivate() {
  }
  _preActivateForIntermediateRendering(renderId) {
  }
  _activate(renderId, intermediateRendering) {
    this._renderId = renderId;
    return true;
  }
  _postActivate() {
  }
  _freeze() {
  }
  _unFreeze() {
  }
  getWorldMatrix() {
    if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {
      return this._masterMesh.getWorldMatrix();
    }
    return super.getWorldMatrix();
  }
  _getWorldMatrixDeterminant() {
    if (this._masterMesh) {
      return this._masterMesh._getWorldMatrixDeterminant();
    }
    return super._getWorldMatrixDeterminant();
  }
  get isAnInstance() {
    return false;
  }
  get hasInstances() {
    return false;
  }
  get hasThinInstances() {
    return false;
  }
  movePOV(amountRight, amountUp, amountForward) {
    this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));
    return this;
  }
  calcMovePOV(amountRight, amountUp, amountForward) {
    const rotMatrix = new Matrix();
    const rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
    rotQuaternion.toRotationMatrix(rotMatrix);
    const translationDelta = Vector3.Zero();
    const defForwardMult = this.definedFacingForward ? -1 : 1;
    Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);
    return translationDelta;
  }
  rotatePOV(flipBack, twirlClockwise, tiltRight) {
    this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));
    return this;
  }
  calcRotatePOV(flipBack, twirlClockwise, tiltRight) {
    const defForwardMult = this.definedFacingForward ? 1 : -1;
    return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);
  }
  refreshBoundingInfo(applySkeleton = false, applyMorph = false) {
    if (this._boundingInfo && this._boundingInfo.isLocked) {
      return this;
    }
    this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), null);
    return this;
  }
  _refreshBoundingInfo(data, bias) {
    if (data) {
      const extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);
      if (this._boundingInfo) {
        this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
      } else {
        this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
      }
    }
    if (this.subMeshes) {
      for (let index = 0; index < this.subMeshes.length; index++) {
        this.subMeshes[index].refreshBoundingInfo(data);
      }
    }
    this._updateBoundingInfo();
  }
  _getData(applySkeleton = false, applyMorph = false, data, kind = VertexBuffer.PositionKind) {
    data = data !== null && data !== void 0 ? data : this.getVerticesData(kind).slice();
    if (data && applyMorph && this.morphTargetManager) {
      let faceIndexCount = 0;
      let positionIndex = 0;
      for (let vertexCount = 0; vertexCount < data.length; vertexCount++) {
        for (let targetCount = 0; targetCount < this.morphTargetManager.numTargets; targetCount++) {
          const targetMorph = this.morphTargetManager.getTarget(targetCount);
          const influence = targetMorph.influence;
          if (influence > 0) {
            const morphTargetPositions = targetMorph.getPositions();
            if (morphTargetPositions) {
              data[vertexCount] += (morphTargetPositions[vertexCount] - data[vertexCount]) * influence;
            }
          }
        }
        faceIndexCount++;
        if (kind === VertexBuffer.PositionKind) {
          if (this._positions && faceIndexCount === 3) {
            faceIndexCount = 0;
            const index = positionIndex * 3;
            this._positions[positionIndex++].copyFromFloats(data[index], data[index + 1], data[index + 2]);
          }
        }
      }
    }
    if (data && applySkeleton && this.skeleton) {
      const matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
      const matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
      if (matricesWeightsData && matricesIndicesData) {
        const needExtras = this.numBoneInfluencers > 4;
        const matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
        const matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
        const skeletonMatrices = this.skeleton.getTransformMatrices(this);
        const tempVector = TmpVectors.Vector3[0];
        const finalMatrix = TmpVectors.Matrix[0];
        const tempMatrix = TmpVectors.Matrix[1];
        let matWeightIdx = 0;
        for (let index = 0; index < data.length; index += 3, matWeightIdx += 4) {
          finalMatrix.reset();
          let inf;
          let weight;
          for (inf = 0; inf < 4; inf++) {
            weight = matricesWeightsData[matWeightIdx + inf];
            if (weight > 0) {
              Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);
              finalMatrix.addToSelf(tempMatrix);
            }
          }
          if (needExtras) {
            for (inf = 0; inf < 4; inf++) {
              weight = matricesWeightsExtraData[matWeightIdx + inf];
              if (weight > 0) {
                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);
                finalMatrix.addToSelf(tempMatrix);
              }
            }
          }
          if (kind === VertexBuffer.NormalKind) {
            Vector3.TransformNormalFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);
          } else {
            Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);
          }
          tempVector.toArray(data, index);
          if (kind === VertexBuffer.PositionKind && this._positions) {
            this._positions[index / 3].copyFrom(tempVector);
          }
        }
      }
    }
    return data;
  }
  getNormalsData(applySkeleton = false, applyMorph = false) {
    return this._getData(applySkeleton, applyMorph, null, VertexBuffer.NormalKind);
  }
  getPositionData(applySkeleton = false, applyMorph = false, data) {
    return this._getData(applySkeleton, applyMorph, data, VertexBuffer.PositionKind);
  }
  _getPositionData(applySkeleton, applyMorph) {
    var _a;
    let data = this.getVerticesData(VertexBuffer.PositionKind);
    if (this._internalAbstractMeshDataInfo._positions) {
      this._internalAbstractMeshDataInfo._positions = null;
    }
    if (data && (applySkeleton && this.skeleton || applyMorph && this.morphTargetManager)) {
      data = data.slice();
      this._generatePointsArray();
      if (this._positions) {
        const pos = this._positions;
        this._internalAbstractMeshDataInfo._positions = new Array(pos.length);
        for (let i = 0; i < pos.length; i++) {
          this._internalAbstractMeshDataInfo._positions[i] = ((_a = pos[i]) === null || _a === void 0 ? void 0 : _a.clone()) || new Vector3();
        }
      }
      return this.getPositionData(applySkeleton, applyMorph, data);
    }
    return data;
  }
  _updateBoundingInfo() {
    if (this._boundingInfo) {
      this._boundingInfo.update(this.worldMatrixFromCache);
    } else {
      this._boundingInfo = new BoundingInfo(Vector3.Zero(), Vector3.Zero(), this.worldMatrixFromCache);
    }
    this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
    return this;
  }
  _updateSubMeshesBoundingInfo(matrix) {
    if (!this.subMeshes) {
      return this;
    }
    const count = this.subMeshes.length;
    for (let subIndex = 0; subIndex < count; subIndex++) {
      const subMesh = this.subMeshes[subIndex];
      if (count > 1 || !subMesh.IsGlobal) {
        subMesh.updateBoundingInfo(matrix);
      }
    }
    return this;
  }
  _afterComputeWorldMatrix() {
    if (this.doNotSyncBoundingInfo) {
      return;
    }
    this._boundingInfoIsDirty = true;
  }
  isInFrustum(frustumPlanes) {
    return this.getBoundingInfo().isInFrustum(frustumPlanes, this.cullingStrategy);
  }
  isCompletelyInFrustum(frustumPlanes) {
    return this.getBoundingInfo().isCompletelyInFrustum(frustumPlanes);
  }
  intersectsMesh(mesh, precise = false, includeDescendants) {
    const boundingInfo = this.getBoundingInfo();
    const otherBoundingInfo = mesh.getBoundingInfo();
    if (boundingInfo.intersects(otherBoundingInfo, precise)) {
      return true;
    }
    if (includeDescendants) {
      for (const child of this.getChildMeshes()) {
        if (child.intersectsMesh(mesh, precise, true)) {
          return true;
        }
      }
    }
    return false;
  }
  intersectsPoint(point) {
    return this.getBoundingInfo().intersectsPoint(point);
  }
  get checkCollisions() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;
  }
  set checkCollisions(collisionEnabled) {
    this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = collisionEnabled;
  }
  get collider() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collider;
  }
  moveWithCollisions(displacement) {
    const globalPosition = this.getAbsolutePosition();
    globalPosition.addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);
    const coordinator = this.getScene().collisionCoordinator;
    if (!this._internalAbstractMeshDataInfo._meshCollisionData._collider) {
      this._internalAbstractMeshDataInfo._meshCollisionData._collider = coordinator.createCollider();
    }
    this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid;
    coordinator.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, displacement, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.uniqueId);
    return this;
  }
  _collideForSubMesh(subMesh, transformMatrix, collider) {
    var _a;
    this._generatePointsArray();
    if (!this._positions) {
      return this;
    }
    if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix.equals(transformMatrix)) {
      subMesh._lastColliderTransformMatrix = transformMatrix.clone();
      subMesh._lastColliderWorldVertices = [];
      subMesh._trianglePlanes = [];
      const start = subMesh.verticesStart;
      const end = subMesh.verticesStart + subMesh.verticesCount;
      for (let i = start; i < end; i++) {
        subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));
      }
    }
    collider._collide(subMesh._trianglePlanes, subMesh._lastColliderWorldVertices, this.getIndices(), subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, !!subMesh.getMaterial(), this, this._shouldConvertRHS(), ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.fillMode) === 7);
    return this;
  }
  _processCollisionsForSubMeshes(collider, transformMatrix) {
    const subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);
    const len = subMeshes.length;
    for (let index = 0; index < len; index++) {
      const subMesh = subMeshes.data[index];
      if (len > 1 && !subMesh._checkCollision(collider)) {
        continue;
      }
      this._collideForSubMesh(subMesh, transformMatrix, collider);
    }
    return this;
  }
  _shouldConvertRHS() {
    return false;
  }
  _checkCollision(collider) {
    if (!this.getBoundingInfo()._checkCollision(collider)) {
      return this;
    }
    const collisionsScalingMatrix = TmpVectors.Matrix[0];
    const collisionsTransformMatrix = TmpVectors.Matrix[1];
    Matrix.ScalingToRef(1 / collider._radius.x, 1 / collider._radius.y, 1 / collider._radius.z, collisionsScalingMatrix);
    this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);
    this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);
    return this;
  }
  _generatePointsArray() {
    return false;
  }
  intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {
    const pickingInfo = new PickingInfo();
    const intersectionThreshold = this.getClassName() === "InstancedLinesMesh" || this.getClassName() === "LinesMesh" ? this.intersectionThreshold : 0;
    const boundingInfo = this.getBoundingInfo();
    if (!this.subMeshes) {
      return pickingInfo;
    }
    if (!skipBoundingInfo && (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))) {
      return pickingInfo;
    }
    if (onlyBoundingInfo) {
      pickingInfo.hit = skipBoundingInfo ? false : true;
      pickingInfo.pickedMesh = skipBoundingInfo ? null : this;
      pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
      pickingInfo.subMeshId = 0;
      return pickingInfo;
    }
    if (!this._generatePointsArray()) {
      return pickingInfo;
    }
    let intersectInfo = null;
    const subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);
    const len = subMeshes.length;
    let anySubmeshSupportIntersect = false;
    for (let index = 0; index < len; index++) {
      const subMesh = subMeshes.data[index];
      const material = subMesh.getMaterial();
      if (!material) {
        continue;
      }
      if (material.fillMode == 7 || material.fillMode == 0 || material.fillMode == 1 || material.fillMode == 2 || material.fillMode == 4) {
        anySubmeshSupportIntersect = true;
        break;
      }
    }
    if (!anySubmeshSupportIntersect) {
      pickingInfo.hit = true;
      pickingInfo.pickedMesh = this;
      pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
      pickingInfo.subMeshId = -1;
      return pickingInfo;
    }
    for (let index = 0; index < len; index++) {
      const subMesh = subMeshes.data[index];
      if (len > 1 && !subMesh.canIntersects(ray)) {
        continue;
      }
      const currentIntersectInfo = subMesh.intersects(ray, this._positions, this.getIndices(), fastCheck, trianglePredicate);
      if (currentIntersectInfo) {
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.subMeshId = index;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    if (intersectInfo) {
      const world = worldToUse !== null && worldToUse !== void 0 ? worldToUse : this.getWorldMatrix();
      const worldOrigin = TmpVectors.Vector3[0];
      const direction = TmpVectors.Vector3[1];
      Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);
      ray.direction.scaleToRef(intersectInfo.distance, direction);
      const worldDirection = Vector3.TransformNormal(direction, world);
      const pickedPoint = worldDirection.addInPlace(worldOrigin);
      pickingInfo.hit = true;
      pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);
      pickingInfo.pickedPoint = pickedPoint;
      pickingInfo.pickedMesh = this;
      pickingInfo.bu = intersectInfo.bu || 0;
      pickingInfo.bv = intersectInfo.bv || 0;
      pickingInfo.subMeshFaceId = intersectInfo.faceId;
      pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf("LinesMesh") !== -1 ? 2 : 3);
      pickingInfo.subMeshId = intersectInfo.subMeshId;
      return pickingInfo;
    }
    return pickingInfo;
  }
  clone(name63, newParent, doNotCloneChildren) {
    return null;
  }
  releaseSubMeshes() {
    if (this.subMeshes) {
      while (this.subMeshes.length) {
        this.subMeshes[0].dispose();
      }
    } else {
      this.subMeshes = new Array();
    }
    return this;
  }
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    let index;
    if (this._scene.useMaterialMeshMap) {
      if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {
        this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0;
      }
    }
    this.getScene().freeActiveMeshes();
    this.getScene().freeRenderingGroups();
    if (this.actionManager !== void 0 && this.actionManager !== null) {
      this.actionManager.dispose();
      this.actionManager = null;
    }
    this._internalAbstractMeshDataInfo._skeleton = null;
    if (this._transformMatrixTexture) {
      this._transformMatrixTexture.dispose();
      this._transformMatrixTexture = null;
    }
    for (index = 0; index < this._intersectionsInProgress.length; index++) {
      const other = this._intersectionsInProgress[index];
      const pos = other._intersectionsInProgress.indexOf(this);
      other._intersectionsInProgress.splice(pos, 1);
    }
    this._intersectionsInProgress.length = 0;
    const lights = this.getScene().lights;
    lights.forEach((light) => {
      let meshIndex = light.includedOnlyMeshes.indexOf(this);
      if (meshIndex !== -1) {
        light.includedOnlyMeshes.splice(meshIndex, 1);
      }
      meshIndex = light.excludedMeshes.indexOf(this);
      if (meshIndex !== -1) {
        light.excludedMeshes.splice(meshIndex, 1);
      }
      const generators = light.getShadowGenerators();
      if (generators) {
        const iterator = generators.values();
        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
          const generator = key.value;
          const shadowMap = generator.getShadowMap();
          if (shadowMap && shadowMap.renderList) {
            meshIndex = shadowMap.renderList.indexOf(this);
            if (meshIndex !== -1) {
              shadowMap.renderList.splice(meshIndex, 1);
            }
          }
        }
      }
    });
    if (this.getClassName() !== "InstancedMesh" || this.getClassName() !== "InstancedLinesMesh") {
      this.releaseSubMeshes();
    }
    const engine = this.getScene().getEngine();
    if (this._occlusionQuery !== null) {
      this.isOcclusionQueryInProgress = false;
      engine.deleteQuery(this._occlusionQuery);
      this._occlusionQuery = null;
    }
    engine.wipeCaches();
    this.getScene().removeMesh(this);
    if (this._parentContainer) {
      const index2 = this._parentContainer.meshes.indexOf(this);
      if (index2 > -1) {
        this._parentContainer.meshes.splice(index2, 1);
      }
      this._parentContainer = null;
    }
    if (disposeMaterialAndTextures) {
      if (this.material) {
        if (this.material.getClassName() === "MultiMaterial") {
          this.material.dispose(false, true, true);
        } else {
          this.material.dispose(false, true);
        }
      }
    }
    if (!doNotRecurse) {
      for (index = 0; index < this.getScene().particleSystems.length; index++) {
        if (this.getScene().particleSystems[index].emitter === this) {
          this.getScene().particleSystems[index].dispose();
          index--;
        }
      }
    }
    if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {
      this.disableFacetData();
    }
    this._uniformBuffer.dispose();
    this.onAfterWorldMatrixUpdateObservable.clear();
    this.onCollideObservable.clear();
    this.onCollisionPositionChangeObservable.clear();
    this.onRebuildObservable.clear();
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  addChild(mesh, preserveScalingSign = false) {
    mesh.setParent(this, preserveScalingSign);
    return this;
  }
  removeChild(mesh, preserveScalingSign = false) {
    mesh.setParent(null, preserveScalingSign);
    return this;
  }
  _initFacetData() {
    const data = this._internalAbstractMeshDataInfo._facetData;
    if (!data.facetNormals) {
      data.facetNormals = new Array();
    }
    if (!data.facetPositions) {
      data.facetPositions = new Array();
    }
    if (!data.facetPartitioning) {
      data.facetPartitioning = new Array();
    }
    data.facetNb = this.getIndices().length / 3 | 0;
    data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10;
    data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01;
    for (let f = 0; f < data.facetNb; f++) {
      data.facetNormals[f] = Vector3.Zero();
      data.facetPositions[f] = Vector3.Zero();
    }
    data.facetDataEnabled = true;
    return this;
  }
  updateFacetData() {
    const data = this._internalAbstractMeshDataInfo._facetData;
    if (!data.facetDataEnabled) {
      this._initFacetData();
    }
    const positions = this.getVerticesData(VertexBuffer.PositionKind);
    const indices = this.getIndices();
    const normals = this.getVerticesData(VertexBuffer.NormalKind);
    const bInfo = this.getBoundingInfo();
    if (data.facetDepthSort && !data.facetDepthSortEnabled) {
      data.facetDepthSortEnabled = true;
      if (indices instanceof Uint16Array) {
        data.depthSortedIndices = new Uint16Array(indices);
      } else if (indices instanceof Uint32Array) {
        data.depthSortedIndices = new Uint32Array(indices);
      } else {
        let needs32bits = false;
        for (let i = 0; i < indices.length; i++) {
          if (indices[i] > 65535) {
            needs32bits = true;
            break;
          }
        }
        if (needs32bits) {
          data.depthSortedIndices = new Uint32Array(indices);
        } else {
          data.depthSortedIndices = new Uint16Array(indices);
        }
      }
      data.facetDepthSortFunction = function(f1, f2) {
        return f2.sqDistance - f1.sqDistance;
      };
      if (!data.facetDepthSortFrom) {
        const camera = this.getScene().activeCamera;
        data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();
      }
      data.depthSortedFacets = [];
      for (let f = 0; f < data.facetNb; f++) {
        const depthSortedFacet = { ind: f * 3, sqDistance: 0 };
        data.depthSortedFacets.push(depthSortedFacet);
      }
      data.invertedMatrix = Matrix.Identity();
      data.facetDepthSortOrigin = Vector3.Zero();
    }
    data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;
    data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;
    data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;
    let bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;
    bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;
    data.subDiv.max = data.partitioningSubdivisions;
    data.subDiv.X = Math.floor(data.subDiv.max * data.bbSize.x / bbSizeMax);
    data.subDiv.Y = Math.floor(data.subDiv.max * data.bbSize.y / bbSizeMax);
    data.subDiv.Z = Math.floor(data.subDiv.max * data.bbSize.z / bbSizeMax);
    data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X;
    data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;
    data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z;
    data.facetParameters.facetNormals = this.getFacetLocalNormals();
    data.facetParameters.facetPositions = this.getFacetLocalPositions();
    data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();
    data.facetParameters.bInfo = bInfo;
    data.facetParameters.bbSize = data.bbSize;
    data.facetParameters.subDiv = data.subDiv;
    data.facetParameters.ratio = this.partitioningBBoxRatio;
    data.facetParameters.depthSort = data.facetDepthSort;
    if (data.facetDepthSort && data.facetDepthSortEnabled) {
      this.computeWorldMatrix(true);
      this._worldMatrix.invertToRef(data.invertedMatrix);
      Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);
      data.facetParameters.distanceTo = data.facetDepthSortOrigin;
    }
    data.facetParameters.depthSortedFacets = data.depthSortedFacets;
    if (normals) {
      VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);
    }
    if (data.facetDepthSort && data.facetDepthSortEnabled) {
      data.depthSortedFacets.sort(data.facetDepthSortFunction);
      const l = data.depthSortedIndices.length / 3 | 0;
      for (let f = 0; f < l; f++) {
        const sind = data.depthSortedFacets[f].ind;
        data.depthSortedIndices[f * 3] = indices[sind];
        data.depthSortedIndices[f * 3 + 1] = indices[sind + 1];
        data.depthSortedIndices[f * 3 + 2] = indices[sind + 2];
      }
      this.updateIndices(data.depthSortedIndices, void 0, true);
    }
    return this;
  }
  getFacetLocalNormals() {
    const facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetNormals) {
      this.updateFacetData();
    }
    return facetData.facetNormals;
  }
  getFacetLocalPositions() {
    const facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetPositions) {
      this.updateFacetData();
    }
    return facetData.facetPositions;
  }
  getFacetLocalPartitioning() {
    const facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetPartitioning) {
      this.updateFacetData();
    }
    return facetData.facetPartitioning;
  }
  getFacetPosition(i) {
    const pos = Vector3.Zero();
    this.getFacetPositionToRef(i, pos);
    return pos;
  }
  getFacetPositionToRef(i, ref) {
    const localPos = this.getFacetLocalPositions()[i];
    const world = this.getWorldMatrix();
    Vector3.TransformCoordinatesToRef(localPos, world, ref);
    return this;
  }
  getFacetNormal(i) {
    const norm = Vector3.Zero();
    this.getFacetNormalToRef(i, norm);
    return norm;
  }
  getFacetNormalToRef(i, ref) {
    const localNorm = this.getFacetLocalNormals()[i];
    Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);
    return this;
  }
  getFacetsAtLocalCoordinates(x, y, z) {
    const bInfo = this.getBoundingInfo();
    const data = this._internalAbstractMeshDataInfo._facetData;
    const ox = Math.floor((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio / data.bbSize.x);
    const oy = Math.floor((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio / data.bbSize.y);
    const oz = Math.floor((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio / data.bbSize.z);
    if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {
      return null;
    }
    return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];
  }
  getClosestFacetAtCoordinates(x, y, z, projected, checkFace = false, facing = true) {
    const world = this.getWorldMatrix();
    const invMat = TmpVectors.Matrix[5];
    world.invertToRef(invMat);
    const invVect = TmpVectors.Vector3[8];
    Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect);
    const closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);
    if (projected) {
      Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);
    }
    return closest;
  }
  getClosestFacetAtLocalCoordinates(x, y, z, projected, checkFace = false, facing = true) {
    let closest = null;
    let tmpx = 0;
    let tmpy = 0;
    let tmpz = 0;
    let d = 0;
    let t0 = 0;
    let projx = 0;
    let projy = 0;
    let projz = 0;
    const facetPositions = this.getFacetLocalPositions();
    const facetNormals = this.getFacetLocalNormals();
    const facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);
    if (!facetsInBlock) {
      return null;
    }
    let shortest = Number.MAX_VALUE;
    let tmpDistance = shortest;
    let fib;
    let norm;
    let p0;
    for (let idx = 0; idx < facetsInBlock.length; idx++) {
      fib = facetsInBlock[idx];
      norm = facetNormals[fib];
      p0 = facetPositions[fib];
      d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;
      if (!checkFace || checkFace && facing && d >= 0 || checkFace && !facing && d <= 0) {
        d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;
        t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);
        projx = x + norm.x * t0;
        projy = y + norm.y * t0;
        projz = z + norm.z * t0;
        tmpx = projx - x;
        tmpy = projy - y;
        tmpz = projz - z;
        tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz;
        if (tmpDistance < shortest) {
          shortest = tmpDistance;
          closest = fib;
          if (projected) {
            projected.x = projx;
            projected.y = projy;
            projected.z = projz;
          }
        }
      }
    }
    return closest;
  }
  getFacetDataParameters() {
    return this._internalAbstractMeshDataInfo._facetData.facetParameters;
  }
  disableFacetData() {
    const facetData = this._internalAbstractMeshDataInfo._facetData;
    if (facetData.facetDataEnabled) {
      facetData.facetDataEnabled = false;
      facetData.facetPositions = new Array();
      facetData.facetNormals = new Array();
      facetData.facetPartitioning = new Array();
      facetData.facetParameters = null;
      facetData.depthSortedIndices = new Uint32Array(0);
    }
    return this;
  }
  updateIndices(indices, offset, gpuMemoryOnly = false) {
    return this;
  }
  createNormals(updatable) {
    const positions = this.getVerticesData(VertexBuffer.PositionKind);
    const indices = this.getIndices();
    let normals;
    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      normals = this.getVerticesData(VertexBuffer.NormalKind);
    } else {
      normals = [];
    }
    VertexData.ComputeNormals(positions, indices, normals, { useRightHandedSystem: this.getScene().useRightHandedSystem });
    this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);
    return this;
  }
  alignWithNormal(normal, upDirection) {
    if (!upDirection) {
      upDirection = Axis.Y;
    }
    const axisX = TmpVectors.Vector3[0];
    const axisZ = TmpVectors.Vector3[1];
    Vector3.CrossToRef(upDirection, normal, axisZ);
    Vector3.CrossToRef(normal, axisZ, axisX);
    if (this.rotationQuaternion) {
      Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);
    } else {
      Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);
    }
    return this;
  }
  _checkOcclusionQuery() {
    return false;
  }
  disableEdgesRendering() {
    throw _WarnImport("EdgesRenderer");
  }
  enableEdgesRendering(epsilon, checkVerticesInsteadOfIndices, options) {
    throw _WarnImport("EdgesRenderer");
  }
  getConnectedParticleSystems() {
    return this._scene.particleSystems.filter((particleSystem) => particleSystem.emitter === this);
  }
};
AbstractMesh.OCCLUSION_TYPE_NONE = 0;
AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC = 1;
AbstractMesh.OCCLUSION_TYPE_STRICT = 2;
AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;
AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;
AbstractMesh.CULLINGSTRATEGY_STANDARD = 0;
AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
RegisterClass("BABYLON.AbstractMesh", AbstractMesh);

// node_modules/@babylonjs/core/Materials/clipPlaneMaterialHelper.js
function addClipPlaneUniforms(uniforms) {
  if (uniforms.indexOf("vClipPlane") === -1) {
    uniforms.push("vClipPlane");
  }
  if (uniforms.indexOf("vClipPlane2") === -1) {
    uniforms.push("vClipPlane2");
  }
  if (uniforms.indexOf("vClipPlane3") === -1) {
    uniforms.push("vClipPlane3");
  }
  if (uniforms.indexOf("vClipPlane4") === -1) {
    uniforms.push("vClipPlane4");
  }
  if (uniforms.indexOf("vClipPlane5") === -1) {
    uniforms.push("vClipPlane5");
  }
  if (uniforms.indexOf("vClipPlane6") === -1) {
    uniforms.push("vClipPlane6");
  }
}
function prepareDefinesForClipPlanes(primaryHolder, secondaryHolder, defines) {
  var _a, _b, _c, _d, _e, _f;
  let changed = false;
  let clipPlane = (_a = primaryHolder.clipPlane) !== null && _a !== void 0 ? _a : secondaryHolder.clipPlane;
  changed = addDefine(clipPlane, defines, "CLIPPLANE") || changed;
  clipPlane = (_b = primaryHolder.clipPlane2) !== null && _b !== void 0 ? _b : secondaryHolder.clipPlane2;
  changed = addDefine(clipPlane, defines, "CLIPPLANE2") || changed;
  clipPlane = (_c = primaryHolder.clipPlane3) !== null && _c !== void 0 ? _c : secondaryHolder.clipPlane3;
  changed = addDefine(clipPlane, defines, "CLIPPLANE3") || changed;
  clipPlane = (_d = primaryHolder.clipPlane4) !== null && _d !== void 0 ? _d : secondaryHolder.clipPlane4;
  changed = addDefine(clipPlane, defines, "CLIPPLANE4") || changed;
  clipPlane = (_e = primaryHolder.clipPlane5) !== null && _e !== void 0 ? _e : secondaryHolder.clipPlane5;
  changed = addDefine(clipPlane, defines, "CLIPPLANE5") || changed;
  clipPlane = (_f = primaryHolder.clipPlane6) !== null && _f !== void 0 ? _f : secondaryHolder.clipPlane6;
  changed = addDefine(clipPlane, defines, "CLIPPLANE6") || changed;
  return changed;
}
function bindClipPlane(effect, primaryHolder, secondaryHolder) {
  var _a, _b, _c, _d, _e, _f;
  let clipPlane = (_a = primaryHolder.clipPlane) !== null && _a !== void 0 ? _a : secondaryHolder.clipPlane;
  setClipPlane(effect, "vClipPlane", clipPlane);
  clipPlane = (_b = primaryHolder.clipPlane2) !== null && _b !== void 0 ? _b : secondaryHolder.clipPlane2;
  setClipPlane(effect, "vClipPlane2", clipPlane);
  clipPlane = (_c = primaryHolder.clipPlane3) !== null && _c !== void 0 ? _c : secondaryHolder.clipPlane3;
  setClipPlane(effect, "vClipPlane3", clipPlane);
  clipPlane = (_d = primaryHolder.clipPlane4) !== null && _d !== void 0 ? _d : secondaryHolder.clipPlane4;
  setClipPlane(effect, "vClipPlane4", clipPlane);
  clipPlane = (_e = primaryHolder.clipPlane5) !== null && _e !== void 0 ? _e : secondaryHolder.clipPlane5;
  setClipPlane(effect, "vClipPlane5", clipPlane);
  clipPlane = (_f = primaryHolder.clipPlane6) !== null && _f !== void 0 ? _f : secondaryHolder.clipPlane6;
  setClipPlane(effect, "vClipPlane6", clipPlane);
}
function setClipPlane(effect, uniformName, clipPlane) {
  if (clipPlane) {
    effect.setFloat4(uniformName, clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
  }
}
function addDefine(clipPlane, defines, defineName) {
  let isSet = true;
  if (clipPlane) {
    if (Array.isArray(defines)) {
      const defineString = "#define " + defineName;
      isSet = defines.indexOf(defineString) !== -1;
      if (!isSet) {
        defines.push(defineString);
      }
    } else {
      isSet = defines[defineName];
      defines[defineName] = true;
    }
  }
  return !isSet;
}

// node_modules/@babylonjs/core/Materials/materialHelper.js
var MaterialHelper = class {
  static BindSceneUniformBuffer(effect, sceneUbo) {
    sceneUbo.bindToEffect(effect, "Scene");
  }
  static PrepareDefinesForMergedUV(texture, defines, key) {
    defines._needUVs = true;
    defines[key] = true;
    if (texture.optimizeUVAllocation && texture.getTextureMatrix().isIdentityAs3x2()) {
      defines[key + "DIRECTUV"] = texture.coordinatesIndex + 1;
      defines["MAINUV" + (texture.coordinatesIndex + 1)] = true;
    } else {
      defines[key + "DIRECTUV"] = 0;
    }
  }
  static BindTextureMatrix(texture, uniformBuffer, key) {
    const matrix = texture.getTextureMatrix();
    uniformBuffer.updateMatrix(key + "Matrix", matrix);
  }
  static GetFogState(mesh, scene) {
    return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE;
  }
  static PrepareDefinesForMisc(mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines) {
    if (defines._areMiscDirty) {
      defines["LOGARITHMICDEPTH"] = useLogarithmicDepth;
      defines["POINTSIZE"] = pointsCloud;
      defines["FOG"] = fogEnabled && this.GetFogState(mesh, scene);
      defines["NONUNIFORMSCALING"] = mesh.nonUniformScaling;
      defines["ALPHATEST"] = alphaTest;
    }
  }
  static PrepareDefinesForCamera(scene, defines) {
    let changed = false;
    if (scene.activeCamera) {
      const wasOrtho = defines["CAMERA_ORTHOGRAPHIC"] ? 1 : 0;
      const wasPersp = defines["CAMERA_PERSPECTIVE"] ? 1 : 0;
      const isOrtho = scene.activeCamera.mode === Camera.ORTHOGRAPHIC_CAMERA ? 1 : 0;
      const isPersp = scene.activeCamera.mode === Camera.PERSPECTIVE_CAMERA ? 1 : 0;
      if (wasOrtho ^ isOrtho || wasPersp ^ isPersp) {
        defines["CAMERA_ORTHOGRAPHIC"] = isOrtho === 1;
        defines["CAMERA_PERSPECTIVE"] = isPersp === 1;
        changed = true;
      }
    }
    return changed;
  }
  static PrepareDefinesForFrameBoundValues(scene, engine, material, defines, useInstances, useClipPlane = null, useThinInstances = false) {
    let changed = MaterialHelper.PrepareDefinesForCamera(scene, defines);
    if (useClipPlane !== false) {
      changed = prepareDefinesForClipPlanes(material, scene, defines);
    }
    if (defines["DEPTHPREPASS"] !== !engine.getColorWrite()) {
      defines["DEPTHPREPASS"] = !defines["DEPTHPREPASS"];
      changed = true;
    }
    if (defines["INSTANCES"] !== useInstances) {
      defines["INSTANCES"] = useInstances;
      changed = true;
    }
    if (defines["THIN_INSTANCES"] !== useThinInstances) {
      defines["THIN_INSTANCES"] = useThinInstances;
      changed = true;
    }
    if (changed) {
      defines.markAsUnprocessed();
    }
  }
  static PrepareDefinesForBones(mesh, defines) {
    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      defines["NUM_BONE_INFLUENCERS"] = mesh.numBoneInfluencers;
      const materialSupportsBoneTexture = defines["BONETEXTURE"] !== void 0;
      if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {
        defines["BONETEXTURE"] = true;
      } else {
        defines["BonesPerMesh"] = mesh.skeleton.bones.length + 1;
        defines["BONETEXTURE"] = materialSupportsBoneTexture ? false : void 0;
        const prePassRenderer = mesh.getScene().prePassRenderer;
        if (prePassRenderer && prePassRenderer.enabled) {
          const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;
          defines["BONES_VELOCITY_ENABLED"] = nonExcluded;
        }
      }
    } else {
      defines["NUM_BONE_INFLUENCERS"] = 0;
      defines["BonesPerMesh"] = 0;
      if (defines["BONETEXTURE"] !== void 0) {
        defines["BONETEXTURE"] = false;
      }
    }
  }
  static PrepareDefinesForMorphTargets(mesh, defines) {
    const manager = mesh.morphTargetManager;
    if (manager) {
      defines["MORPHTARGETS_UV"] = manager.supportsUVs && defines["UV1"];
      defines["MORPHTARGETS_TANGENT"] = manager.supportsTangents && defines["TANGENT"];
      defines["MORPHTARGETS_NORMAL"] = manager.supportsNormals && defines["NORMAL"];
      defines["MORPHTARGETS"] = manager.numInfluencers > 0;
      defines["NUM_MORPH_INFLUENCERS"] = manager.numInfluencers;
      defines["MORPHTARGETS_TEXTURE"] = manager.isUsingTextureForTargets;
    } else {
      defines["MORPHTARGETS_UV"] = false;
      defines["MORPHTARGETS_TANGENT"] = false;
      defines["MORPHTARGETS_NORMAL"] = false;
      defines["MORPHTARGETS"] = false;
      defines["NUM_MORPH_INFLUENCERS"] = 0;
    }
  }
  static PrepareDefinesForBakedVertexAnimation(mesh, defines) {
    const manager = mesh.bakedVertexAnimationManager;
    defines["BAKED_VERTEX_ANIMATION_TEXTURE"] = manager && manager.isEnabled ? true : false;
  }
  static PrepareDefinesForAttributes(mesh, defines, useVertexColor, useBones, useMorphTargets = false, useVertexAlpha = true, useBakedVertexAnimation = true) {
    if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {
      return false;
    }
    defines._normals = defines._needNormals;
    defines._uvs = defines._needUVs;
    defines["NORMAL"] = defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
    if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      defines["TANGENT"] = true;
    }
    for (let i = 1; i <= 6; ++i) {
      defines["UV" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? "" : i}`) : false;
    }
    if (useVertexColor) {
      const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);
      defines["VERTEXCOLOR"] = hasVertexColors;
      defines["VERTEXALPHA"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;
    }
    if (mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind) && (mesh.hasInstances || mesh.hasThinInstances)) {
      defines["INSTANCESCOLOR"] = true;
    }
    if (useBones) {
      this.PrepareDefinesForBones(mesh, defines);
    }
    if (useMorphTargets) {
      this.PrepareDefinesForMorphTargets(mesh, defines);
    }
    if (useBakedVertexAnimation) {
      this.PrepareDefinesForBakedVertexAnimation(mesh, defines);
    }
    return true;
  }
  static PrepareDefinesForMultiview(scene, defines) {
    if (scene.activeCamera) {
      const previousMultiview = defines.MULTIVIEW;
      defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;
      if (defines.MULTIVIEW != previousMultiview) {
        defines.markAsUnprocessed();
      }
    }
  }
  static PrepareDefinesForOIT(scene, defines, needAlphaBlending) {
    const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;
    const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;
    defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;
    defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;
    if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {
      defines.markAsUnprocessed();
    }
  }
  static PrepareDefinesForPrePass(scene, defines, canRenderToMRT) {
    const previousPrePass = defines.PREPASS;
    if (!defines._arePrePassDirty) {
      return;
    }
    const texturesList = [
      {
        type: 1,
        define: "PREPASS_POSITION",
        index: "PREPASS_POSITION_INDEX"
      },
      {
        type: 2,
        define: "PREPASS_VELOCITY",
        index: "PREPASS_VELOCITY_INDEX"
      },
      {
        type: 3,
        define: "PREPASS_REFLECTIVITY",
        index: "PREPASS_REFLECTIVITY_INDEX"
      },
      {
        type: 0,
        define: "PREPASS_IRRADIANCE",
        index: "PREPASS_IRRADIANCE_INDEX"
      },
      {
        type: 7,
        define: "PREPASS_ALBEDO_SQRT",
        index: "PREPASS_ALBEDO_SQRT_INDEX"
      },
      {
        type: 5,
        define: "PREPASS_DEPTH",
        index: "PREPASS_DEPTH_INDEX"
      },
      {
        type: 6,
        define: "PREPASS_NORMAL",
        index: "PREPASS_NORMAL_INDEX"
      }
    ];
    if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {
      defines.PREPASS = true;
      defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;
      for (let i = 0; i < texturesList.length; i++) {
        const index = scene.prePassRenderer.getIndex(texturesList[i].type);
        if (index !== -1) {
          defines[texturesList[i].define] = true;
          defines[texturesList[i].index] = index;
        } else {
          defines[texturesList[i].define] = false;
        }
      }
    } else {
      defines.PREPASS = false;
      for (let i = 0; i < texturesList.length; i++) {
        defines[texturesList[i].define] = false;
      }
    }
    if (defines.PREPASS != previousPrePass) {
      defines.markAsUnprocessed();
      defines.markAsImageProcessingDirty();
    }
  }
  static PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state) {
    var _a;
    state.needNormals = true;
    if (defines["LIGHT" + lightIndex] === void 0) {
      state.needRebuild = true;
    }
    defines["LIGHT" + lightIndex] = true;
    defines["SPOTLIGHT" + lightIndex] = false;
    defines["HEMILIGHT" + lightIndex] = false;
    defines["POINTLIGHT" + lightIndex] = false;
    defines["DIRLIGHT" + lightIndex] = false;
    light.prepareLightSpecificDefines(defines, lightIndex);
    defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = false;
    defines["LIGHT_FALLOFF_GLTF" + lightIndex] = false;
    defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = false;
    switch (light.falloffType) {
      case LightConstants.FALLOFF_GLTF:
        defines["LIGHT_FALLOFF_GLTF" + lightIndex] = true;
        break;
      case LightConstants.FALLOFF_PHYSICAL:
        defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = true;
        break;
      case LightConstants.FALLOFF_STANDARD:
        defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = true;
        break;
    }
    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {
      state.specularEnabled = true;
    }
    defines["SHADOW" + lightIndex] = false;
    defines["SHADOWCSM" + lightIndex] = false;
    defines["SHADOWCSMDEBUG" + lightIndex] = false;
    defines["SHADOWCSMNUM_CASCADES" + lightIndex] = false;
    defines["SHADOWCSMUSESHADOWMAXZ" + lightIndex] = false;
    defines["SHADOWCSMNOBLEND" + lightIndex] = false;
    defines["SHADOWCSM_RIGHTHANDED" + lightIndex] = false;
    defines["SHADOWPCF" + lightIndex] = false;
    defines["SHADOWPCSS" + lightIndex] = false;
    defines["SHADOWPOISSON" + lightIndex] = false;
    defines["SHADOWESM" + lightIndex] = false;
    defines["SHADOWCLOSEESM" + lightIndex] = false;
    defines["SHADOWCUBE" + lightIndex] = false;
    defines["SHADOWLOWQUALITY" + lightIndex] = false;
    defines["SHADOWMEDIUMQUALITY" + lightIndex] = false;
    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {
      const shadowGenerator = (_a = light.getShadowGenerator(scene.activeCamera)) !== null && _a !== void 0 ? _a : light.getShadowGenerator();
      if (shadowGenerator) {
        const shadowMap = shadowGenerator.getShadowMap();
        if (shadowMap) {
          if (shadowMap.renderList && shadowMap.renderList.length > 0) {
            state.shadowEnabled = true;
            shadowGenerator.prepareDefines(defines, lightIndex);
          }
        }
      }
    }
    if (light.lightmapMode != LightConstants.LIGHTMAP_DEFAULT) {
      state.lightmapMode = true;
      defines["LIGHTMAPEXCLUDED" + lightIndex] = true;
      defines["LIGHTMAPNOSPECULAR" + lightIndex] = light.lightmapMode == LightConstants.LIGHTMAP_SHADOWSONLY;
    } else {
      defines["LIGHTMAPEXCLUDED" + lightIndex] = false;
      defines["LIGHTMAPNOSPECULAR" + lightIndex] = false;
    }
  }
  static PrepareDefinesForLights(scene, mesh, defines, specularSupported, maxSimultaneousLights = 4, disableLighting = false) {
    if (!defines._areLightsDirty) {
      return defines._needNormals;
    }
    let lightIndex = 0;
    const state = {
      needNormals: defines._needNormals,
      needRebuild: false,
      lightmapMode: false,
      shadowEnabled: false,
      specularEnabled: false
    };
    if (scene.lightsEnabled && !disableLighting) {
      for (const light of mesh.lightSources) {
        this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);
        lightIndex++;
        if (lightIndex === maxSimultaneousLights) {
          break;
        }
      }
    }
    defines["SPECULARTERM"] = state.specularEnabled;
    defines["SHADOWS"] = state.shadowEnabled;
    for (let index = lightIndex; index < maxSimultaneousLights; index++) {
      if (defines["LIGHT" + index] !== void 0) {
        defines["LIGHT" + index] = false;
        defines["HEMILIGHT" + index] = false;
        defines["POINTLIGHT" + index] = false;
        defines["DIRLIGHT" + index] = false;
        defines["SPOTLIGHT" + index] = false;
        defines["SHADOW" + index] = false;
        defines["SHADOWCSM" + index] = false;
        defines["SHADOWCSMDEBUG" + index] = false;
        defines["SHADOWCSMNUM_CASCADES" + index] = false;
        defines["SHADOWCSMUSESHADOWMAXZ" + index] = false;
        defines["SHADOWCSMNOBLEND" + index] = false;
        defines["SHADOWCSM_RIGHTHANDED" + index] = false;
        defines["SHADOWPCF" + index] = false;
        defines["SHADOWPCSS" + index] = false;
        defines["SHADOWPOISSON" + index] = false;
        defines["SHADOWESM" + index] = false;
        defines["SHADOWCLOSEESM" + index] = false;
        defines["SHADOWCUBE" + index] = false;
        defines["SHADOWLOWQUALITY" + index] = false;
        defines["SHADOWMEDIUMQUALITY" + index] = false;
      }
    }
    const caps = scene.getEngine().getCaps();
    if (defines["SHADOWFLOAT"] === void 0) {
      state.needRebuild = true;
    }
    defines["SHADOWFLOAT"] = state.shadowEnabled && (caps.textureFloatRender && caps.textureFloatLinearFiltering || caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering);
    defines["LIGHTMAPEXCLUDED"] = state.lightmapMode;
    if (state.needRebuild) {
      defines.rebuild();
    }
    return state.needNormals;
  }
  static PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList = null, updateOnlyBuffersList = false) {
    if (uniformBuffersList) {
      uniformBuffersList.push("Light" + lightIndex);
    }
    if (updateOnlyBuffersList) {
      return;
    }
    uniformsList.push("vLightData" + lightIndex, "vLightDiffuse" + lightIndex, "vLightSpecular" + lightIndex, "vLightDirection" + lightIndex, "vLightFalloff" + lightIndex, "vLightGround" + lightIndex, "lightMatrix" + lightIndex, "shadowsInfo" + lightIndex, "depthValues" + lightIndex);
    samplersList.push("shadowSampler" + lightIndex);
    samplersList.push("depthSampler" + lightIndex);
    uniformsList.push("viewFrustumZ" + lightIndex, "cascadeBlendFactor" + lightIndex, "lightSizeUVCorrection" + lightIndex, "depthCorrection" + lightIndex, "penumbraDarkness" + lightIndex, "frustumLengths" + lightIndex);
    if (projectedLightTexture) {
      samplersList.push("projectionLightSampler" + lightIndex);
      uniformsList.push("textureProjectionMatrix" + lightIndex);
    }
  }
  static PrepareUniformsAndSamplersList(uniformsListOrOptions, samplersList, defines, maxSimultaneousLights = 4) {
    let uniformsList;
    let uniformBuffersList = null;
    if (uniformsListOrOptions.uniformsNames) {
      const options = uniformsListOrOptions;
      uniformsList = options.uniformsNames;
      uniformBuffersList = options.uniformBuffersNames;
      samplersList = options.samplers;
      defines = options.defines;
      maxSimultaneousLights = options.maxSimultaneousLights || 0;
    } else {
      uniformsList = uniformsListOrOptions;
      if (!samplersList) {
        samplersList = [];
      }
    }
    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
      if (!defines["LIGHT" + lightIndex]) {
        break;
      }
      this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines["PROJECTEDLIGHTTEXTURE" + lightIndex], uniformBuffersList);
    }
    if (defines["NUM_MORPH_INFLUENCERS"]) {
      uniformsList.push("morphTargetInfluences");
    }
    if (defines["BAKED_VERTEX_ANIMATION_TEXTURE"]) {
      uniformsList.push("bakedVertexAnimationSettings");
      uniformsList.push("bakedVertexAnimationTextureSizeInverted");
      uniformsList.push("bakedVertexAnimationTime");
      samplersList.push("bakedVertexAnimationTexture");
    }
  }
  static HandleFallbacksForShadows(defines, fallbacks, maxSimultaneousLights = 4, rank = 0) {
    let lightFallbackRank = 0;
    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
      if (!defines["LIGHT" + lightIndex]) {
        break;
      }
      if (lightIndex > 0) {
        lightFallbackRank = rank + lightIndex;
        fallbacks.addFallback(lightFallbackRank, "LIGHT" + lightIndex);
      }
      if (!defines["SHADOWS"]) {
        if (defines["SHADOW" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOW" + lightIndex);
        }
        if (defines["SHADOWPCF" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWPCF" + lightIndex);
        }
        if (defines["SHADOWPCSS" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWPCSS" + lightIndex);
        }
        if (defines["SHADOWPOISSON" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWPOISSON" + lightIndex);
        }
        if (defines["SHADOWESM" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWESM" + lightIndex);
        }
        if (defines["SHADOWCLOSEESM" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWCLOSEESM" + lightIndex);
        }
      }
    }
    return lightFallbackRank++;
  }
  static PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, influencers) {
    this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;
    this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);
  }
  static PrepareAttributesForMorphTargets(attribs, mesh, defines) {
    const influencers = defines["NUM_MORPH_INFLUENCERS"];
    if (influencers > 0 && EngineStore.LastCreatedEngine) {
      const maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;
      const manager = mesh.morphTargetManager;
      if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {
        return;
      }
      const normal = manager && manager.supportsNormals && defines["NORMAL"];
      const tangent = manager && manager.supportsTangents && defines["TANGENT"];
      const uv = manager && manager.supportsUVs && defines["UV1"];
      for (let index = 0; index < influencers; index++) {
        attribs.push(VertexBuffer.PositionKind + index);
        if (normal) {
          attribs.push(VertexBuffer.NormalKind + index);
        }
        if (tangent) {
          attribs.push(VertexBuffer.TangentKind + index);
        }
        if (uv) {
          attribs.push(VertexBuffer.UVKind + "_" + index);
        }
        if (attribs.length > maxAttributesCount) {
          Logger.Error("Cannot add more vertex attributes for mesh " + mesh.name);
        }
      }
    }
  }
  static PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines) {
    const enabled = defines["BAKED_VERTEX_ANIMATION_TEXTURE"] && defines["INSTANCES"];
    if (enabled) {
      attribs.push("bakedVertexAnimationSettingsInstanced");
    }
  }
  static PrepareAttributesForBones(attribs, mesh, defines, fallbacks) {
    if (defines["NUM_BONE_INFLUENCERS"] > 0) {
      fallbacks.addCPUSkinningFallback(0, mesh);
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (defines["NUM_BONE_INFLUENCERS"] > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
    }
  }
  static PrepareAttributesForInstances(attribs, defines) {
    if (defines["INSTANCES"] || defines["THIN_INSTANCES"]) {
      this.PushAttributesForInstances(attribs, !!defines["PREPASS_VELOCITY"]);
    }
    if (defines.INSTANCESCOLOR) {
      attribs.push(VertexBuffer.ColorInstanceKind);
    }
  }
  static PushAttributesForInstances(attribs, needsPreviousMatrices = false) {
    attribs.push("world0");
    attribs.push("world1");
    attribs.push("world2");
    attribs.push("world3");
    if (needsPreviousMatrices) {
      attribs.push("previousWorld0");
      attribs.push("previousWorld1");
      attribs.push("previousWorld2");
      attribs.push("previousWorld3");
    }
  }
  static BindLightProperties(light, effect, lightIndex) {
    light.transferToEffect(effect, lightIndex + "");
  }
  static BindLight(light, lightIndex, scene, effect, useSpecular, receiveShadows = true) {
    light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);
  }
  static BindLights(scene, mesh, effect, defines, maxSimultaneousLights = 4) {
    const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);
    for (let i = 0; i < len; i++) {
      const light = mesh.lightSources[i];
      this.BindLight(light, i, scene, effect, typeof defines === "boolean" ? defines : defines["SPECULARTERM"], mesh.receiveShadows);
    }
  }
  static BindFogParameters(scene, mesh, effect, linearSpace = false) {
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
      if (linearSpace) {
        scene.fogColor.toLinearSpaceToRef(this._TempFogColor);
        effect.setColor3("vFogColor", this._TempFogColor);
      } else {
        effect.setColor3("vFogColor", scene.fogColor);
      }
    }
  }
  static BindBonesParameters(mesh, effect, prePassConfiguration) {
    if (!effect || !mesh) {
      return;
    }
    if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {
      mesh.computeBonesUsingShaders = false;
    }
    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      const skeleton = mesh.skeleton;
      if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex("boneTextureWidth") > -1) {
        const boneTexture = skeleton.getTransformMatrixTexture(mesh);
        effect.setTexture("boneSampler", boneTexture);
        effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
      } else {
        const matrices = skeleton.getTransformMatrices(mesh);
        if (matrices) {
          effect.setMatrices("mBones", matrices);
          if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {
            if (!prePassConfiguration.previousBones[mesh.uniqueId]) {
              prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();
            }
            effect.setMatrices("mPreviousBones", prePassConfiguration.previousBones[mesh.uniqueId]);
            MaterialHelper._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);
          }
        }
      }
    }
  }
  static _CopyBonesTransformationMatrices(source, target) {
    target.set(source);
    return target;
  }
  static BindMorphTargetParameters(abstractMesh, effect) {
    const manager = abstractMesh.morphTargetManager;
    if (!abstractMesh || !manager) {
      return;
    }
    effect.setFloatArray("morphTargetInfluences", manager.influences);
  }
  static BindLogDepth(defines, effect, scene) {
    if (!defines || defines["LOGARITHMICDEPTH"] || defines.indexOf && defines.indexOf("LOGARITHMICDEPTH") >= 0) {
      const camera = scene.activeCamera;
      if (camera.mode === Camera.ORTHOGRAPHIC_CAMERA) {
        Logger.Error("Logarithmic depth is not compatible with orthographic cameras!", 20);
      }
      effect.setFloat("logarithmicDepthConstant", 2 / (Math.log(camera.maxZ + 1) / Math.LN2));
    }
  }
};
MaterialHelper._TmpMorphInfluencers = { NUM_MORPH_INFLUENCERS: 0 };
MaterialHelper._TempFogColor = Color3.Black();

// node_modules/@babylonjs/core/Materials/materialPluginEvent.js
var MaterialPluginEvent;
(function(MaterialPluginEvent2) {
  MaterialPluginEvent2[MaterialPluginEvent2["Created"] = 1] = "Created";
  MaterialPluginEvent2[MaterialPluginEvent2["Disposed"] = 2] = "Disposed";
  MaterialPluginEvent2[MaterialPluginEvent2["GetDefineNames"] = 4] = "GetDefineNames";
  MaterialPluginEvent2[MaterialPluginEvent2["PrepareUniformBuffer"] = 8] = "PrepareUniformBuffer";
  MaterialPluginEvent2[MaterialPluginEvent2["IsReadyForSubMesh"] = 16] = "IsReadyForSubMesh";
  MaterialPluginEvent2[MaterialPluginEvent2["PrepareDefines"] = 32] = "PrepareDefines";
  MaterialPluginEvent2[MaterialPluginEvent2["BindForSubMesh"] = 64] = "BindForSubMesh";
  MaterialPluginEvent2[MaterialPluginEvent2["PrepareEffect"] = 128] = "PrepareEffect";
  MaterialPluginEvent2[MaterialPluginEvent2["GetAnimatables"] = 256] = "GetAnimatables";
  MaterialPluginEvent2[MaterialPluginEvent2["GetActiveTextures"] = 512] = "GetActiveTextures";
  MaterialPluginEvent2[MaterialPluginEvent2["HasTexture"] = 1024] = "HasTexture";
  MaterialPluginEvent2[MaterialPluginEvent2["FillRenderTargetTextures"] = 2048] = "FillRenderTargetTextures";
  MaterialPluginEvent2[MaterialPluginEvent2["HasRenderTargetTextures"] = 4096] = "HasRenderTargetTextures";
  MaterialPluginEvent2[MaterialPluginEvent2["HardBindForSubMesh"] = 8192] = "HardBindForSubMesh";
})(MaterialPluginEvent || (MaterialPluginEvent = {}));

// node_modules/@babylonjs/core/Materials/materialStencilState.js
var MaterialStencilState = class {
  constructor() {
    this.reset();
  }
  reset() {
    this.enabled = false;
    this.mask = 255;
    this.func = 519;
    this.funcRef = 1;
    this.funcMask = 255;
    this.opStencilFail = 7680;
    this.opDepthFail = 7680;
    this.opStencilDepthPass = 7681;
  }
  get func() {
    return this._func;
  }
  set func(value) {
    this._func = value;
  }
  get funcRef() {
    return this._funcRef;
  }
  set funcRef(value) {
    this._funcRef = value;
  }
  get funcMask() {
    return this._funcMask;
  }
  set funcMask(value) {
    this._funcMask = value;
  }
  get opStencilFail() {
    return this._opStencilFail;
  }
  set opStencilFail(value) {
    this._opStencilFail = value;
  }
  get opDepthFail() {
    return this._opDepthFail;
  }
  set opDepthFail(value) {
    this._opDepthFail = value;
  }
  get opStencilDepthPass() {
    return this._opStencilDepthPass;
  }
  set opStencilDepthPass(value) {
    this._opStencilDepthPass = value;
  }
  get mask() {
    return this._mask;
  }
  set mask(value) {
    this._mask = value;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  getClassName() {
    return "MaterialStencilState";
  }
  copyTo(stencilState) {
    SerializationHelper.Clone(() => stencilState, this);
  }
  serialize() {
    return SerializationHelper.Serialize(this);
  }
  parse(source, scene, rootUrl) {
    SerializationHelper.Parse(() => this, source, scene, rootUrl);
  }
};
__decorate([
  serialize()
], MaterialStencilState.prototype, "func", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "funcRef", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "funcMask", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "opStencilFail", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "opDepthFail", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "opStencilDepthPass", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "mask", null);
__decorate([
  serialize()
], MaterialStencilState.prototype, "enabled", null);

// node_modules/@babylonjs/core/Materials/material.js
var Material = class {
  constructor(name63, scene, doNotAdd) {
    this.shadowDepthWrapper = null;
    this.allowShaderHotSwapping = true;
    this.metadata = null;
    this.reservedDataStore = null;
    this.checkReadyOnEveryCall = false;
    this.checkReadyOnlyOnce = false;
    this.state = "";
    this._alpha = 1;
    this._backFaceCulling = true;
    this._cullBackFaces = true;
    this._blockDirtyMechanism = false;
    this.onCompiled = null;
    this.onError = null;
    this.getRenderTargetTextures = null;
    this.doNotSerialize = false;
    this._storeEffectOnSubMeshes = false;
    this.animations = null;
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this._onUnBindObservable = null;
    this._onBindObserver = null;
    this._alphaMode = 2;
    this._needDepthPrePass = false;
    this.disableDepthWrite = false;
    this.disableColorWrite = false;
    this.forceDepthWrite = false;
    this.depthFunction = 0;
    this.separateCullingPass = false;
    this._fogEnabled = true;
    this.pointSize = 1;
    this.zOffset = 0;
    this.zOffsetUnits = 0;
    this.stencil = new MaterialStencilState();
    this._useUBO = false;
    this._fillMode = Material.TriangleFillMode;
    this._cachedDepthWriteState = false;
    this._cachedColorWriteState = false;
    this._cachedDepthFunctionState = 0;
    this._indexInSceneMaterialArray = -1;
    this.meshMap = null;
    this._parentContainer = null;
    this._uniformBufferLayoutBuilt = false;
    this._eventInfo = {};
    this._callbackPluginEventGeneric = () => void 0;
    this._callbackPluginEventIsReadyForSubMesh = () => void 0;
    this._callbackPluginEventPrepareDefines = () => void 0;
    this._callbackPluginEventPrepareDefinesBeforeAttributes = () => void 0;
    this._callbackPluginEventHardBindForSubMesh = () => void 0;
    this._callbackPluginEventBindForSubMesh = () => void 0;
    this._callbackPluginEventHasRenderTargetTextures = () => void 0;
    this._callbackPluginEventFillRenderTargetTextures = () => void 0;
    this._forceAlphaTest = false;
    this._transparencyMode = null;
    this.name = name63;
    const setScene = scene || EngineStore.LastCreatedScene;
    if (!setScene) {
      return;
    }
    this._scene = setScene;
    this._dirtyCallbacks = {};
    this._dirtyCallbacks[1] = this._markAllSubMeshesAsTexturesDirty.bind(this);
    this._dirtyCallbacks[2] = this._markAllSubMeshesAsLightsDirty.bind(this);
    this._dirtyCallbacks[4] = this._markAllSubMeshesAsFresnelDirty.bind(this);
    this._dirtyCallbacks[8] = this._markAllSubMeshesAsAttributesDirty.bind(this);
    this._dirtyCallbacks[16] = this._markAllSubMeshesAsMiscDirty.bind(this);
    this._dirtyCallbacks[32] = this._markAllSubMeshesAsPrePassDirty.bind(this);
    this._dirtyCallbacks[63] = this._markAllSubMeshesAsAllDirty.bind(this);
    this.id = name63 || Tools.RandomId();
    this.uniqueId = this._scene.getUniqueId();
    this._materialContext = this._scene.getEngine().createMaterialContext();
    this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);
    this._drawWrapper.materialContext = this._materialContext;
    if (this._scene.useRightHandedSystem) {
      this.sideOrientation = Material.ClockWiseSideOrientation;
    } else {
      this.sideOrientation = Material.CounterClockWiseSideOrientation;
    }
    this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), void 0, void 0, name63);
    this._useUBO = this.getScene().getEngine().supportsUniformBuffers;
    if (!doNotAdd) {
      this._scene.addMaterial(this);
    }
    if (this._scene.useMaterialMeshMap) {
      this.meshMap = {};
    }
    Material.OnEventObservable.notifyObservers(this, MaterialPluginEvent.Created);
  }
  get canRenderToMRT() {
    return false;
  }
  set alpha(value) {
    if (this._alpha === value) {
      return;
    }
    const oldValue = this._alpha;
    this._alpha = value;
    if (oldValue === 1 || value === 1) {
      this.markAsDirty(Material.MiscDirtyFlag);
    }
  }
  get alpha() {
    return this._alpha;
  }
  set backFaceCulling(value) {
    if (this._backFaceCulling === value) {
      return;
    }
    this._backFaceCulling = value;
    this.markAsDirty(Material.TextureDirtyFlag);
  }
  get backFaceCulling() {
    return this._backFaceCulling;
  }
  set cullBackFaces(value) {
    if (this._cullBackFaces === value) {
      return;
    }
    this._cullBackFaces = value;
    this.markAsDirty(Material.TextureDirtyFlag);
  }
  get cullBackFaces() {
    return this._cullBackFaces;
  }
  get blockDirtyMechanism() {
    return this._blockDirtyMechanism;
  }
  set blockDirtyMechanism(value) {
    if (this._blockDirtyMechanism === value) {
      return;
    }
    this._blockDirtyMechanism = value;
    if (!value) {
      this.markDirty();
    }
  }
  atomicMaterialsUpdate(callback) {
    this.blockDirtyMechanism = true;
    try {
      callback(this);
    } finally {
      this.blockDirtyMechanism = false;
    }
  }
  get hasRenderTargetTextures() {
    this._eventInfo.hasRenderTargetTextures = false;
    this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
    return this._eventInfo.hasRenderTargetTextures;
  }
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  get onBindObservable() {
    if (!this._onBindObservable) {
      this._onBindObservable = new Observable();
    }
    return this._onBindObservable;
  }
  set onBind(callback) {
    if (this._onBindObserver) {
      this.onBindObservable.remove(this._onBindObserver);
    }
    this._onBindObserver = this.onBindObservable.add(callback);
  }
  get onUnBindObservable() {
    if (!this._onUnBindObservable) {
      this._onUnBindObservable = new Observable();
    }
    return this._onUnBindObservable;
  }
  get onEffectCreatedObservable() {
    if (!this._onEffectCreatedObservable) {
      this._onEffectCreatedObservable = new Observable();
    }
    return this._onEffectCreatedObservable;
  }
  set alphaMode(value) {
    if (this._alphaMode === value) {
      return;
    }
    this._alphaMode = value;
    this.markAsDirty(Material.TextureDirtyFlag);
  }
  get alphaMode() {
    return this._alphaMode;
  }
  set needDepthPrePass(value) {
    if (this._needDepthPrePass === value) {
      return;
    }
    this._needDepthPrePass = value;
    if (this._needDepthPrePass) {
      this.checkReadyOnEveryCall = true;
    }
  }
  get needDepthPrePass() {
    return this._needDepthPrePass;
  }
  get isPrePassCapable() {
    return false;
  }
  set fogEnabled(value) {
    if (this._fogEnabled === value) {
      return;
    }
    this._fogEnabled = value;
    this.markAsDirty(Material.MiscDirtyFlag);
  }
  get fogEnabled() {
    return this._fogEnabled;
  }
  get wireframe() {
    switch (this._fillMode) {
      case Material.WireFrameFillMode:
      case Material.LineListDrawMode:
      case Material.LineLoopDrawMode:
      case Material.LineStripDrawMode:
        return true;
    }
    return this._scene.forceWireframe;
  }
  set wireframe(value) {
    this.fillMode = value ? Material.WireFrameFillMode : Material.TriangleFillMode;
  }
  get pointsCloud() {
    switch (this._fillMode) {
      case Material.PointFillMode:
      case Material.PointListDrawMode:
        return true;
    }
    return this._scene.forcePointsCloud;
  }
  set pointsCloud(value) {
    this.fillMode = value ? Material.PointFillMode : Material.TriangleFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  set fillMode(value) {
    if (this._fillMode === value) {
      return;
    }
    this._fillMode = value;
    this.markAsDirty(Material.MiscDirtyFlag);
  }
  _getDrawWrapper() {
    return this._drawWrapper;
  }
  _setDrawWrapper(drawWrapper) {
    this._drawWrapper = drawWrapper;
  }
  toString(fullDetails) {
    const ret = "Name: " + this.name;
    return ret;
  }
  getClassName() {
    return "Material";
  }
  get _isMaterial() {
    return true;
  }
  get isFrozen() {
    return this.checkReadyOnlyOnce;
  }
  freeze() {
    this.markDirty();
    this.checkReadyOnlyOnce = true;
  }
  unfreeze() {
    this.markDirty();
    this.checkReadyOnlyOnce = false;
  }
  isReady(mesh, useInstances) {
    return true;
  }
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    const defines = subMesh.materialDefines;
    if (!defines) {
      return false;
    }
    this._eventInfo.isReadyForSubMesh = true;
    this._eventInfo.defines = defines;
    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
    return this._eventInfo.isReadyForSubMesh;
  }
  getEffect() {
    return this._drawWrapper.effect;
  }
  getScene() {
    return this._scene;
  }
  get transparencyMode() {
    return this._transparencyMode;
  }
  set transparencyMode(value) {
    if (this._transparencyMode === value) {
      return;
    }
    this._transparencyMode = value;
    this._forceAlphaTest = value === Material.MATERIAL_ALPHATESTANDBLEND;
    this._markAllSubMeshesAsTexturesAndMiscDirty();
  }
  get _disableAlphaBlending() {
    return this._transparencyMode === Material.MATERIAL_OPAQUE || this._transparencyMode === Material.MATERIAL_ALPHATEST;
  }
  needAlphaBlending() {
    if (this._disableAlphaBlending) {
      return false;
    }
    return this.alpha < 1;
  }
  needAlphaBlendingForMesh(mesh) {
    if (mesh.visibility < 1) {
      return true;
    }
    if (this._disableAlphaBlending) {
      return false;
    }
    return mesh.hasVertexAlpha || this.needAlphaBlending();
  }
  needAlphaTesting() {
    if (this._forceAlphaTest) {
      return true;
    }
    return false;
  }
  _shouldTurnAlphaTestOn(mesh) {
    return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();
  }
  getAlphaTestTexture() {
    return null;
  }
  markDirty() {
    const meshes = this.getScene().meshes;
    for (const mesh of meshes) {
      if (!mesh.subMeshes) {
        continue;
      }
      for (const subMesh of mesh.subMeshes) {
        if (subMesh.getMaterial() !== this) {
          continue;
        }
        if (!subMesh.effect) {
          continue;
        }
        subMesh.effect._wasPreviouslyReady = false;
        subMesh.effect._wasPreviouslyUsingInstances = null;
      }
    }
  }
  _preBind(effect, overrideOrientation = null) {
    const engine = this._scene.getEngine();
    const orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;
    const reverse = orientation === Material.ClockWiseSideOrientation;
    engine.enableEffect(effect ? effect : this._getDrawWrapper());
    engine.setState(this.backFaceCulling, this.zOffset, false, reverse, this._scene._mirroredCameraPosition ? !this.cullBackFaces : this.cullBackFaces, this.stencil, this.zOffsetUnits);
    return reverse;
  }
  bind(world, mesh) {
  }
  buildUniformLayout() {
    const ubo = this._uniformBuffer;
    this._eventInfo.ubo = ubo;
    this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareUniformBuffer, this._eventInfo);
    ubo.create();
    this._uniformBufferLayoutBuilt = true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventBindForSubMesh(this._eventInfo);
  }
  bindOnlyWorldMatrix(world) {
  }
  bindView(effect) {
    if (!this._useUBO) {
      effect.setMatrix("view", this.getScene().getViewMatrix());
    } else {
      this._needToBindSceneUbo = true;
    }
  }
  bindViewProjection(effect) {
    if (!this._useUBO) {
      effect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
      effect.setMatrix("projection", this.getScene().getProjectionMatrix());
    } else {
      this._needToBindSceneUbo = true;
    }
  }
  bindEyePosition(effect, variableName) {
    if (!this._useUBO) {
      this._scene.bindEyePosition(effect, variableName);
    } else {
      this._needToBindSceneUbo = true;
    }
  }
  _afterBind(mesh, effect = null) {
    this._scene._cachedMaterial = this;
    if (this._needToBindSceneUbo) {
      if (effect) {
        this._needToBindSceneUbo = false;
        MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());
        this._scene.finalizeSceneUbo();
      }
    }
    if (mesh) {
      this._scene._cachedVisibility = mesh.visibility;
    } else {
      this._scene._cachedVisibility = 1;
    }
    if (this._onBindObservable && mesh) {
      this._onBindObservable.notifyObservers(mesh);
    }
    if (this.disableDepthWrite) {
      const engine = this._scene.getEngine();
      this._cachedDepthWriteState = engine.getDepthWrite();
      engine.setDepthWrite(false);
    }
    if (this.disableColorWrite) {
      const engine = this._scene.getEngine();
      this._cachedColorWriteState = engine.getColorWrite();
      engine.setColorWrite(false);
    }
    if (this.depthFunction !== 0) {
      const engine = this._scene.getEngine();
      this._cachedDepthFunctionState = engine.getDepthFunction() || 0;
      engine.setDepthFunction(this.depthFunction);
    }
  }
  unbind() {
    if (this._onUnBindObservable) {
      this._onUnBindObservable.notifyObservers(this);
    }
    if (this.depthFunction !== 0) {
      const engine = this._scene.getEngine();
      engine.setDepthFunction(this._cachedDepthFunctionState);
    }
    if (this.disableDepthWrite) {
      const engine = this._scene.getEngine();
      engine.setDepthWrite(this._cachedDepthWriteState);
    }
    if (this.disableColorWrite) {
      const engine = this._scene.getEngine();
      engine.setColorWrite(this._cachedColorWriteState);
    }
  }
  getAnimatables() {
    this._eventInfo.animatables = [];
    this._callbackPluginEventGeneric(MaterialPluginEvent.GetAnimatables, this._eventInfo);
    return this._eventInfo.animatables;
  }
  getActiveTextures() {
    this._eventInfo.activeTextures = [];
    this._callbackPluginEventGeneric(MaterialPluginEvent.GetActiveTextures, this._eventInfo);
    return this._eventInfo.activeTextures;
  }
  hasTexture(texture) {
    this._eventInfo.hasTexture = false;
    this._eventInfo.texture = texture;
    this._callbackPluginEventGeneric(MaterialPluginEvent.HasTexture, this._eventInfo);
    return this._eventInfo.hasTexture;
  }
  clone(name63) {
    return null;
  }
  getBindedMeshes() {
    if (this.meshMap) {
      const result = new Array();
      for (const meshId in this.meshMap) {
        const mesh = this.meshMap[meshId];
        if (mesh) {
          result.push(mesh);
        }
      }
      return result;
    } else {
      const meshes = this._scene.meshes;
      return meshes.filter((mesh) => mesh.material === this);
    }
  }
  forceCompilation(mesh, onCompiled, options, onError) {
    const localOptions = {
      clipPlane: false,
      useInstances: false,
      ...options
    };
    const scene = this.getScene();
    const currentHotSwapingState = this.allowShaderHotSwapping;
    this.allowShaderHotSwapping = false;
    const checkReady = () => {
      if (!this._scene || !this._scene.getEngine()) {
        return;
      }
      const clipPlaneState = scene.clipPlane;
      if (localOptions.clipPlane) {
        scene.clipPlane = new Plane(0, 0, 0, 1);
      }
      if (this._storeEffectOnSubMeshes) {
        let allDone = true, lastError = null;
        if (mesh.subMeshes) {
          const tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, void 0, false, false);
          if (tempSubMesh.materialDefines) {
            tempSubMesh.materialDefines._renderId = -1;
          }
          if (!this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {
            if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {
              lastError = tempSubMesh.effect.getCompilationError();
            } else {
              allDone = false;
              setTimeout(checkReady, 16);
            }
          }
        }
        if (allDone) {
          this.allowShaderHotSwapping = currentHotSwapingState;
          if (lastError) {
            if (onError) {
              onError(lastError);
            }
          }
          if (onCompiled) {
            onCompiled(this);
          }
        }
      } else {
        if (this.isReady()) {
          this.allowShaderHotSwapping = currentHotSwapingState;
          if (onCompiled) {
            onCompiled(this);
          }
        } else {
          setTimeout(checkReady, 16);
        }
      }
      if (localOptions.clipPlane) {
        scene.clipPlane = clipPlaneState;
      }
    };
    checkReady();
  }
  forceCompilationAsync(mesh, options) {
    return new Promise((resolve, reject) => {
      this.forceCompilation(mesh, () => {
        resolve();
      }, options, (reason) => {
        reject(reason);
      });
    });
  }
  markAsDirty(flag) {
    if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {
      return;
    }
    Material._DirtyCallbackArray.length = 0;
    if (flag & Material.TextureDirtyFlag) {
      Material._DirtyCallbackArray.push(Material._TextureDirtyCallBack);
    }
    if (flag & Material.LightDirtyFlag) {
      Material._DirtyCallbackArray.push(Material._LightsDirtyCallBack);
    }
    if (flag & Material.FresnelDirtyFlag) {
      Material._DirtyCallbackArray.push(Material._FresnelDirtyCallBack);
    }
    if (flag & Material.AttributesDirtyFlag) {
      Material._DirtyCallbackArray.push(Material._AttributeDirtyCallBack);
    }
    if (flag & Material.MiscDirtyFlag) {
      Material._DirtyCallbackArray.push(Material._MiscDirtyCallBack);
    }
    if (flag & Material.PrePassDirtyFlag) {
      Material._DirtyCallbackArray.push(Material._PrePassDirtyCallBack);
    }
    if (Material._DirtyCallbackArray.length) {
      this._markAllSubMeshesAsDirty(Material._RunDirtyCallBacks);
    }
    this.getScene().resetCachedMaterial();
  }
  resetDrawCache() {
    const meshes = this.getScene().meshes;
    for (const mesh of meshes) {
      if (!mesh.subMeshes) {
        continue;
      }
      for (const subMesh of mesh.subMeshes) {
        if (subMesh.getMaterial() !== this) {
          continue;
        }
        subMesh.resetDrawCache();
      }
    }
  }
  _markAllSubMeshesAsDirty(func) {
    if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {
      return;
    }
    const meshes = this.getScene().meshes;
    for (const mesh of meshes) {
      if (!mesh.subMeshes) {
        continue;
      }
      for (const subMesh of mesh.subMeshes) {
        if (subMesh.getMaterial(false) !== this) {
          continue;
        }
        for (const drawWrapper of subMesh._drawWrappers) {
          if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {
            continue;
          }
          if (this._materialContext === drawWrapper.materialContext) {
            func(drawWrapper.defines);
          }
        }
      }
    }
  }
  _markScenePrePassDirty() {
    if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {
      return;
    }
    const prePassRenderer = this.getScene().enablePrePassRenderer();
    if (prePassRenderer) {
      prePassRenderer.markAsDirty();
    }
  }
  _markAllSubMeshesAsAllDirty() {
    this._markAllSubMeshesAsDirty(Material._AllDirtyCallBack);
  }
  _markAllSubMeshesAsImageProcessingDirty() {
    this._markAllSubMeshesAsDirty(Material._ImageProcessingDirtyCallBack);
  }
  _markAllSubMeshesAsTexturesDirty() {
    this._markAllSubMeshesAsDirty(Material._TextureDirtyCallBack);
  }
  _markAllSubMeshesAsFresnelDirty() {
    this._markAllSubMeshesAsDirty(Material._FresnelDirtyCallBack);
  }
  _markAllSubMeshesAsFresnelAndMiscDirty() {
    this._markAllSubMeshesAsDirty(Material._FresnelAndMiscDirtyCallBack);
  }
  _markAllSubMeshesAsLightsDirty() {
    this._markAllSubMeshesAsDirty(Material._LightsDirtyCallBack);
  }
  _markAllSubMeshesAsAttributesDirty() {
    this._markAllSubMeshesAsDirty(Material._AttributeDirtyCallBack);
  }
  _markAllSubMeshesAsMiscDirty() {
    this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);
  }
  _markAllSubMeshesAsPrePassDirty() {
    this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);
  }
  _markAllSubMeshesAsTexturesAndMiscDirty() {
    this._markAllSubMeshesAsDirty(Material._TextureAndMiscDirtyCallBack);
  }
  setPrePassRenderer(prePassRenderer) {
    return false;
  }
  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    const scene = this.getScene();
    scene.stopAnimation(this);
    scene.freeProcessedMaterials();
    scene.removeMaterial(this);
    this._eventInfo.forceDisposeTextures = forceDisposeTextures;
    this._callbackPluginEventGeneric(MaterialPluginEvent.Disposed, this._eventInfo);
    if (this._parentContainer) {
      const index = this._parentContainer.materials.indexOf(this);
      if (index > -1) {
        this._parentContainer.materials.splice(index, 1);
      }
      this._parentContainer = null;
    }
    if (notBoundToMesh !== true) {
      if (this.meshMap) {
        for (const meshId in this.meshMap) {
          const mesh = this.meshMap[meshId];
          if (mesh) {
            mesh.material = null;
            this.releaseVertexArrayObject(mesh, forceDisposeEffect);
          }
        }
      } else {
        const meshes = scene.meshes;
        for (const mesh of meshes) {
          if (mesh.material === this && !mesh.sourceMesh) {
            mesh.material = null;
            this.releaseVertexArrayObject(mesh, forceDisposeEffect);
          }
        }
      }
    }
    this._uniformBuffer.dispose();
    if (forceDisposeEffect && this._drawWrapper.effect) {
      if (!this._storeEffectOnSubMeshes) {
        this._drawWrapper.effect.dispose();
      }
      this._drawWrapper.effect = null;
    }
    this.metadata = null;
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    if (this._onBindObservable) {
      this._onBindObservable.clear();
    }
    if (this._onUnBindObservable) {
      this._onUnBindObservable.clear();
    }
    if (this._onEffectCreatedObservable) {
      this._onEffectCreatedObservable.clear();
    }
  }
  releaseVertexArrayObject(mesh, forceDisposeEffect) {
    if (mesh.geometry) {
      const geometry = mesh.geometry;
      if (this._storeEffectOnSubMeshes) {
        for (const subMesh of mesh.subMeshes) {
          geometry._releaseVertexArrayObject(subMesh.effect);
          if (forceDisposeEffect && subMesh.effect) {
            subMesh.effect.dispose();
          }
        }
      } else {
        geometry._releaseVertexArrayObject(this._drawWrapper.effect);
      }
    }
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.stencil = this.stencil.serialize();
    serializationObject.uniqueId = this.uniqueId;
    return serializationObject;
  }
  static Parse(parsedMaterial, scene, rootUrl) {
    if (!parsedMaterial.customType) {
      parsedMaterial.customType = "BABYLON.StandardMaterial";
    } else if (parsedMaterial.customType === "BABYLON.PBRMaterial" && parsedMaterial.overloadedAlbedo) {
      parsedMaterial.customType = "BABYLON.LegacyPBRMaterial";
      if (!BABYLON.LegacyPBRMaterial) {
        Logger.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.");
        return null;
      }
    }
    const materialType = Tools.Instantiate(parsedMaterial.customType);
    const material = materialType.Parse(parsedMaterial, scene, rootUrl);
    material._loadedUniqueId = parsedMaterial.uniqueId;
    return material;
  }
};
Material.TriangleFillMode = 0;
Material.WireFrameFillMode = 1;
Material.PointFillMode = 2;
Material.PointListDrawMode = 3;
Material.LineListDrawMode = 4;
Material.LineLoopDrawMode = 5;
Material.LineStripDrawMode = 6;
Material.TriangleStripDrawMode = 7;
Material.TriangleFanDrawMode = 8;
Material.ClockWiseSideOrientation = 0;
Material.CounterClockWiseSideOrientation = 1;
Material.TextureDirtyFlag = 1;
Material.LightDirtyFlag = 2;
Material.FresnelDirtyFlag = 4;
Material.AttributesDirtyFlag = 8;
Material.MiscDirtyFlag = 16;
Material.PrePassDirtyFlag = 32;
Material.AllDirtyFlag = 63;
Material.MATERIAL_OPAQUE = 0;
Material.MATERIAL_ALPHATEST = 1;
Material.MATERIAL_ALPHABLEND = 2;
Material.MATERIAL_ALPHATESTANDBLEND = 3;
Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;
Material.MATERIAL_NORMALBLENDMETHOD_RNM = 1;
Material.OnEventObservable = new Observable();
Material._AllDirtyCallBack = (defines) => defines.markAllAsDirty();
Material._ImageProcessingDirtyCallBack = (defines) => defines.markAsImageProcessingDirty();
Material._TextureDirtyCallBack = (defines) => defines.markAsTexturesDirty();
Material._FresnelDirtyCallBack = (defines) => defines.markAsFresnelDirty();
Material._MiscDirtyCallBack = (defines) => defines.markAsMiscDirty();
Material._PrePassDirtyCallBack = (defines) => defines.markAsPrePassDirty();
Material._LightsDirtyCallBack = (defines) => defines.markAsLightDirty();
Material._AttributeDirtyCallBack = (defines) => defines.markAsAttributesDirty();
Material._FresnelAndMiscDirtyCallBack = (defines) => {
  Material._FresnelDirtyCallBack(defines);
  Material._MiscDirtyCallBack(defines);
};
Material._TextureAndMiscDirtyCallBack = (defines) => {
  Material._TextureDirtyCallBack(defines);
  Material._MiscDirtyCallBack(defines);
};
Material._DirtyCallbackArray = [];
Material._RunDirtyCallBacks = (defines) => {
  for (const cb of Material._DirtyCallbackArray) {
    cb(defines);
  }
};
__decorate([
  serialize()
], Material.prototype, "id", void 0);
__decorate([
  serialize()
], Material.prototype, "uniqueId", void 0);
__decorate([
  serialize()
], Material.prototype, "name", void 0);
__decorate([
  serialize()
], Material.prototype, "metadata", void 0);
__decorate([
  serialize()
], Material.prototype, "checkReadyOnEveryCall", void 0);
__decorate([
  serialize()
], Material.prototype, "checkReadyOnlyOnce", void 0);
__decorate([
  serialize()
], Material.prototype, "state", void 0);
__decorate([
  serialize("alpha")
], Material.prototype, "_alpha", void 0);
__decorate([
  serialize("backFaceCulling")
], Material.prototype, "_backFaceCulling", void 0);
__decorate([
  serialize("cullBackFaces")
], Material.prototype, "_cullBackFaces", void 0);
__decorate([
  serialize()
], Material.prototype, "sideOrientation", void 0);
__decorate([
  serialize("alphaMode")
], Material.prototype, "_alphaMode", void 0);
__decorate([
  serialize()
], Material.prototype, "_needDepthPrePass", void 0);
__decorate([
  serialize()
], Material.prototype, "disableDepthWrite", void 0);
__decorate([
  serialize()
], Material.prototype, "disableColorWrite", void 0);
__decorate([
  serialize()
], Material.prototype, "forceDepthWrite", void 0);
__decorate([
  serialize()
], Material.prototype, "depthFunction", void 0);
__decorate([
  serialize()
], Material.prototype, "separateCullingPass", void 0);
__decorate([
  serialize("fogEnabled")
], Material.prototype, "_fogEnabled", void 0);
__decorate([
  serialize()
], Material.prototype, "pointSize", void 0);
__decorate([
  serialize()
], Material.prototype, "zOffset", void 0);
__decorate([
  serialize()
], Material.prototype, "zOffsetUnits", void 0);
__decorate([
  serialize()
], Material.prototype, "pointsCloud", null);
__decorate([
  serialize()
], Material.prototype, "fillMode", null);
__decorate([
  serialize()
], Material.prototype, "transparencyMode", null);

// node_modules/@babylonjs/core/Materials/multiMaterial.js
var MultiMaterial = class extends Material {
  constructor(name63, scene) {
    super(name63, scene, true);
    this._waitingSubMaterialsUniqueIds = [];
    this.getScene().multiMaterials.push(this);
    this.subMaterials = new Array();
    this._storeEffectOnSubMeshes = true;
  }
  get subMaterials() {
    return this._subMaterials;
  }
  set subMaterials(value) {
    this._subMaterials = value;
    this._hookArray(value);
  }
  getChildren() {
    return this.subMaterials;
  }
  _hookArray(array) {
    const oldPush = array.push;
    array.push = (...items) => {
      const result = oldPush.apply(array, items);
      this._markAllSubMeshesAsTexturesDirty();
      return result;
    };
    const oldSplice = array.splice;
    array.splice = (index, deleteCount) => {
      const deleted = oldSplice.apply(array, [index, deleteCount]);
      this._markAllSubMeshesAsTexturesDirty();
      return deleted;
    };
  }
  getSubMaterial(index) {
    if (index < 0 || index >= this.subMaterials.length) {
      return this.getScene().defaultMaterial;
    }
    return this.subMaterials[index];
  }
  getActiveTextures() {
    return super.getActiveTextures().concat(...this.subMaterials.map((subMaterial) => {
      if (subMaterial) {
        return subMaterial.getActiveTextures();
      } else {
        return [];
      }
    }));
  }
  hasTexture(texture) {
    var _a;
    if (super.hasTexture(texture)) {
      return true;
    }
    for (let i = 0; i < this.subMaterials.length; i++) {
      if ((_a = this.subMaterials[i]) === null || _a === void 0 ? void 0 : _a.hasTexture(texture)) {
        return true;
      }
    }
    return false;
  }
  getClassName() {
    return "MultiMaterial";
  }
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    for (let index = 0; index < this.subMaterials.length; index++) {
      const subMaterial = this.subMaterials[index];
      if (subMaterial) {
        if (subMaterial._storeEffectOnSubMeshes) {
          if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {
            return false;
          }
          continue;
        }
        if (!subMaterial.isReady(mesh)) {
          return false;
        }
      }
    }
    return true;
  }
  clone(name63, cloneChildren) {
    const newMultiMaterial = new MultiMaterial(name63, this.getScene());
    for (let index = 0; index < this.subMaterials.length; index++) {
      let subMaterial = null;
      const current = this.subMaterials[index];
      if (cloneChildren && current) {
        subMaterial = current.clone(name63 + "-" + current.name);
      } else {
        subMaterial = this.subMaterials[index];
      }
      newMultiMaterial.subMaterials.push(subMaterial);
    }
    return newMultiMaterial;
  }
  serialize() {
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.id = this.id;
    serializationObject.uniqueId = this.uniqueId;
    if (Tags) {
      serializationObject.tags = Tags.GetTags(this);
    }
    serializationObject.materialsUniqueIds = [];
    serializationObject.materials = [];
    for (let matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {
      const subMat = this.subMaterials[matIndex];
      if (subMat) {
        serializationObject.materialsUniqueIds.push(subMat.uniqueId);
        serializationObject.materials.push(subMat.id);
      } else {
        serializationObject.materialsUniqueIds.push(null);
        serializationObject.materials.push(null);
      }
    }
    return serializationObject;
  }
  dispose(forceDisposeEffect, forceDisposeTextures, forceDisposeChildren) {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    if (forceDisposeChildren) {
      for (let index2 = 0; index2 < this.subMaterials.length; index2++) {
        const subMaterial = this.subMaterials[index2];
        if (subMaterial) {
          subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);
        }
      }
    }
    const index = scene.multiMaterials.indexOf(this);
    if (index >= 0) {
      scene.multiMaterials.splice(index, 1);
    }
    super.dispose(forceDisposeEffect, forceDisposeTextures);
  }
  static ParseMultiMaterial(parsedMultiMaterial, scene) {
    const multiMaterial = new MultiMaterial(parsedMultiMaterial.name, scene);
    multiMaterial.id = parsedMultiMaterial.id;
    multiMaterial._loadedUniqueId = parsedMultiMaterial.uniqueId;
    if (Tags) {
      Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);
    }
    if (parsedMultiMaterial.materialsUniqueIds) {
      multiMaterial._waitingSubMaterialsUniqueIds = parsedMultiMaterial.materialsUniqueIds;
    } else {
      parsedMultiMaterial.materials.forEach((subMatId) => multiMaterial.subMaterials.push(scene.getLastMaterialById(subMatId)));
    }
    return multiMaterial;
  }
};
RegisterClass("BABYLON.MultiMaterial", MultiMaterial);

// node_modules/@babylonjs/core/Meshes/meshLODLevel.js
var MeshLODLevel = class {
  constructor(distanceOrScreenCoverage, mesh) {
    this.distanceOrScreenCoverage = distanceOrScreenCoverage;
    this.mesh = mesh;
  }
};

// node_modules/@babylonjs/core/Meshes/mesh.js
var _CreationDataStorage = class {
};
var _InstanceDataStorage = class {
  constructor() {
    this.visibleInstances = {};
    this.batchCache = new _InstancesBatch();
    this.batchCacheReplacementModeInFrozenMode = new _InstancesBatch();
    this.instancesBufferSize = 32 * 16 * 4;
  }
};
var _InstancesBatch = class {
  constructor() {
    this.mustReturn = false;
    this.visibleInstances = new Array();
    this.renderSelf = new Array();
    this.hardwareInstancedRendering = new Array();
  }
};
var _ThinInstanceDataStorage = class {
  constructor() {
    this.instancesCount = 0;
    this.matrixBuffer = null;
    this.previousMatrixBuffer = null;
    this.matrixBufferSize = 32 * 16;
    this.matrixData = null;
    this.boundingVectors = [];
    this.worldMatrices = null;
  }
};
var _InternalMeshDataInfo = class {
  constructor() {
    this._areNormalsFrozen = false;
    this._source = null;
    this.meshMap = null;
    this._preActivateId = -1;
    this._LODLevels = new Array();
    this._useLODScreenCoverage = false;
    this._effectiveMaterial = null;
    this._forcedInstanceCount = 0;
  }
};
var Mesh = class extends AbstractMesh {
  constructor(name63, scene = null, parent = null, source = null, doNotCloneChildren, clonePhysicsImpostor = true) {
    super(name63, scene);
    this._internalMeshDataInfo = new _InternalMeshDataInfo();
    this.delayLoadState = 0;
    this.instances = new Array();
    this._creationDataStorage = null;
    this._geometry = null;
    this._instanceDataStorage = new _InstanceDataStorage();
    this._thinInstanceDataStorage = new _ThinInstanceDataStorage();
    this._shouldGenerateFlatShading = false;
    this._originalBuilderSideOrientation = Mesh.DEFAULTSIDE;
    this.overrideMaterialSideOrientation = null;
    this.ignoreCameraMaxZ = false;
    scene = this.getScene();
    this._onBeforeDraw = (isInstance, world, effectiveMaterial) => {
      if (isInstance && effectiveMaterial) {
        if (this._uniformBuffer) {
          this.transferToEffect(world);
        } else {
          effectiveMaterial.bindOnlyWorldMatrix(world);
        }
      }
    };
    if (source) {
      if (source._geometry) {
        source._geometry.applyToMesh(this);
      }
      DeepCopier.DeepCopy(source, this, [
        "name",
        "material",
        "skeleton",
        "instances",
        "parent",
        "uniqueId",
        "source",
        "metadata",
        "morphTargetManager",
        "hasInstances",
        "worldMatrixInstancedBuffer",
        "previousWorldMatrixInstancedBuffer",
        "hasLODLevels",
        "geometry",
        "isBlocked",
        "areNormalsFrozen",
        "facetNb",
        "isFacetDataEnabled",
        "lightSources",
        "useBones",
        "isAnInstance",
        "collider",
        "edgesRenderer",
        "forward",
        "up",
        "right",
        "absolutePosition",
        "absoluteScaling",
        "absoluteRotationQuaternion",
        "isWorldMatrixFrozen",
        "nonUniformScaling",
        "behaviors",
        "worldMatrixFromCache",
        "hasThinInstances",
        "cloneMeshMap",
        "hasBoundingInfo"
      ], ["_poseMatrix"]);
      this._internalMeshDataInfo._source = source;
      if (scene.useClonedMeshMap) {
        if (!source._internalMeshDataInfo.meshMap) {
          source._internalMeshDataInfo.meshMap = {};
        }
        source._internalMeshDataInfo.meshMap[this.uniqueId] = this;
      }
      this._originalBuilderSideOrientation = source._originalBuilderSideOrientation;
      this._creationDataStorage = source._creationDataStorage;
      if (source._ranges) {
        const ranges = source._ranges;
        for (const name64 in ranges) {
          if (!Object.prototype.hasOwnProperty.call(ranges, name64)) {
            continue;
          }
          if (!ranges[name64]) {
            continue;
          }
          this.createAnimationRange(name64, ranges[name64].from, ranges[name64].to);
        }
      }
      if (source.metadata && source.metadata.clone) {
        this.metadata = source.metadata.clone();
      } else {
        this.metadata = source.metadata;
      }
      if (Tags && Tags.HasTags(source)) {
        Tags.AddTagsTo(this, Tags.GetTags(source, true));
      }
      this.setEnabled(source.isEnabled(false));
      this.parent = source.parent;
      this.setPivotMatrix(source.getPivotMatrix());
      this.id = name63 + "." + source.id;
      this.material = source.material;
      if (!doNotCloneChildren) {
        const directDescendants = source.getDescendants(true);
        for (let index = 0; index < directDescendants.length; index++) {
          const child = directDescendants[index];
          if (child.clone) {
            child.clone(name63 + "." + child.name, this);
          }
        }
      }
      if (source.morphTargetManager) {
        this.morphTargetManager = source.morphTargetManager;
      }
      if (scene.getPhysicsEngine) {
        const physicsEngine = scene.getPhysicsEngine();
        if (clonePhysicsImpostor && physicsEngine && physicsEngine.getPluginVersion() === 1) {
          const impostor = physicsEngine.getImpostorForPhysicsObject(source);
          if (impostor) {
            this.physicsImpostor = impostor.clone(this);
          }
        }
      }
      for (let index = 0; index < scene.particleSystems.length; index++) {
        const system = scene.particleSystems[index];
        if (system.emitter === source) {
          system.clone(system.name, this);
        }
      }
      this.skeleton = source.skeleton;
      this.refreshBoundingInfo(true, true);
      this.computeWorldMatrix(true);
    }
    if (parent !== null) {
      this.parent = parent;
    }
    this._instanceDataStorage.hardwareInstancedRendering = this.getEngine().getCaps().instancedArrays;
    this._internalMeshDataInfo._onMeshReadyObserverAdded = (observer) => {
      observer.unregisterOnNextCall = true;
      if (this.isReady(true)) {
        this.onMeshReadyObservable.notifyObservers(this);
      } else {
        if (!this._internalMeshDataInfo._checkReadinessObserver) {
          this._internalMeshDataInfo._checkReadinessObserver = this._scene.onBeforeRenderObservable.add(() => {
            if (this.isReady(true)) {
              this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);
              this._internalMeshDataInfo._checkReadinessObserver = null;
              this.onMeshReadyObservable.notifyObservers(this);
            }
          });
        }
      }
    };
    this.onMeshReadyObservable = new Observable(this._internalMeshDataInfo._onMeshReadyObserverAdded);
    if (source) {
      source.onClonedObservable.notifyObservers(this);
    }
  }
  static _GetDefaultSideOrientation(orientation) {
    return orientation || Mesh.FRONTSIDE;
  }
  get useLODScreenCoverage() {
    return this._internalMeshDataInfo._useLODScreenCoverage;
  }
  set useLODScreenCoverage(value) {
    this._internalMeshDataInfo._useLODScreenCoverage = value;
    this._sortLODLevels();
  }
  get computeBonesUsingShaders() {
    return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
  }
  set computeBonesUsingShaders(value) {
    if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {
      return;
    }
    if (value && this._internalMeshDataInfo._sourcePositions) {
      this.setVerticesData(VertexBuffer.PositionKind, this._internalMeshDataInfo._sourcePositions, true);
      if (this._internalMeshDataInfo._sourceNormals) {
        this.setVerticesData(VertexBuffer.NormalKind, this._internalMeshDataInfo._sourceNormals, true);
      }
      this._internalMeshDataInfo._sourcePositions = null;
      this._internalMeshDataInfo._sourceNormals = null;
    }
    this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;
    this._markSubMeshesAsAttributesDirty();
  }
  get onBeforeRenderObservable() {
    if (!this._internalMeshDataInfo._onBeforeRenderObservable) {
      this._internalMeshDataInfo._onBeforeRenderObservable = new Observable();
    }
    return this._internalMeshDataInfo._onBeforeRenderObservable;
  }
  get onBeforeBindObservable() {
    if (!this._internalMeshDataInfo._onBeforeBindObservable) {
      this._internalMeshDataInfo._onBeforeBindObservable = new Observable();
    }
    return this._internalMeshDataInfo._onBeforeBindObservable;
  }
  get onAfterRenderObservable() {
    if (!this._internalMeshDataInfo._onAfterRenderObservable) {
      this._internalMeshDataInfo._onAfterRenderObservable = new Observable();
    }
    return this._internalMeshDataInfo._onAfterRenderObservable;
  }
  get onBetweenPassObservable() {
    if (!this._internalMeshDataInfo._onBetweenPassObservable) {
      this._internalMeshDataInfo._onBetweenPassObservable = new Observable();
    }
    return this._internalMeshDataInfo._onBetweenPassObservable;
  }
  get onBeforeDrawObservable() {
    if (!this._internalMeshDataInfo._onBeforeDrawObservable) {
      this._internalMeshDataInfo._onBeforeDrawObservable = new Observable();
    }
    return this._internalMeshDataInfo._onBeforeDrawObservable;
  }
  set onBeforeDraw(callback) {
    if (this._onBeforeDrawObserver) {
      this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);
    }
    this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);
  }
  get hasInstances() {
    return this.instances.length > 0;
  }
  get hasThinInstances() {
    var _a;
    return ((_a = this._thinInstanceDataStorage.instancesCount) !== null && _a !== void 0 ? _a : 0) > 0;
  }
  get forcedInstanceCount() {
    return this._internalMeshDataInfo._forcedInstanceCount;
  }
  set forcedInstanceCount(count) {
    this._internalMeshDataInfo._forcedInstanceCount = count;
  }
  get source() {
    return this._internalMeshDataInfo._source;
  }
  get cloneMeshMap() {
    return this._internalMeshDataInfo.meshMap;
  }
  get isUnIndexed() {
    return this._unIndexed;
  }
  set isUnIndexed(value) {
    if (this._unIndexed !== value) {
      this._unIndexed = value;
      this._markSubMeshesAsAttributesDirty();
    }
  }
  get worldMatrixInstancedBuffer() {
    return this._instanceDataStorage.instancesData;
  }
  get previousWorldMatrixInstancedBuffer() {
    return this._instanceDataStorage.instancesPreviousData;
  }
  get manualUpdateOfWorldMatrixInstancedBuffer() {
    return this._instanceDataStorage.manualUpdate;
  }
  set manualUpdateOfWorldMatrixInstancedBuffer(value) {
    this._instanceDataStorage.manualUpdate = value;
  }
  get manualUpdateOfPreviousWorldMatrixInstancedBuffer() {
    return this._instanceDataStorage.previousManualUpdate;
  }
  set manualUpdateOfPreviousWorldMatrixInstancedBuffer(value) {
    this._instanceDataStorage.previousManualUpdate = value;
  }
  get forceWorldMatrixInstancedBufferUpdate() {
    return this._instanceDataStorage.forceMatrixUpdates;
  }
  set forceWorldMatrixInstancedBufferUpdate(value) {
    this._instanceDataStorage.forceMatrixUpdates = value;
  }
  instantiateHierarchy(newParent = null, options, onNewNodeCreated) {
    const instance = this.getTotalVertices() === 0 || options && options.doNotInstantiate && (options.doNotInstantiate === true || options.doNotInstantiate(this)) ? this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true) : this.createInstance("instance of " + (this.name || this.id));
    instance.parent = newParent || this.parent;
    instance.position = this.position.clone();
    instance.scaling = this.scaling.clone();
    if (this.rotationQuaternion) {
      instance.rotationQuaternion = this.rotationQuaternion.clone();
    } else {
      instance.rotation = this.rotation.clone();
    }
    if (onNewNodeCreated) {
      onNewNodeCreated(this, instance);
    }
    for (const child of this.getChildTransformNodes(true)) {
      if (child.getClassName() === "InstancedMesh" && instance.getClassName() === "Mesh") {
        child.instantiateHierarchy(instance, {
          doNotInstantiate: options && options.doNotInstantiate || false,
          newSourcedMesh: instance
        }, onNewNodeCreated);
      } else {
        child.instantiateHierarchy(instance, options, onNewNodeCreated);
      }
    }
    return instance;
  }
  getClassName() {
    return "Mesh";
  }
  get _isMesh() {
    return true;
  }
  toString(fullDetails) {
    let ret = super.toString(fullDetails);
    ret += ", n vertices: " + this.getTotalVertices();
    ret += ", parent: " + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : "NONE");
    if (this.animations) {
      for (let i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    if (fullDetails) {
      if (this._geometry) {
        const ib = this.getIndices();
        const vb = this.getVerticesData(VertexBuffer.PositionKind);
        if (vb && ib) {
          ret += ", flat shading: " + (vb.length / 3 === ib.length ? "YES" : "NO");
        }
      } else {
        ret += ", flat shading: UNKNOWN";
      }
    }
    return ret;
  }
  _unBindEffect() {
    super._unBindEffect();
    for (const instance of this.instances) {
      instance._unBindEffect();
    }
  }
  get hasLODLevels() {
    return this._internalMeshDataInfo._LODLevels.length > 0;
  }
  getLODLevels() {
    return this._internalMeshDataInfo._LODLevels;
  }
  _sortLODLevels() {
    const sortingOrderFactor = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;
    this._internalMeshDataInfo._LODLevels.sort((a, b) => {
      if (a.distanceOrScreenCoverage < b.distanceOrScreenCoverage) {
        return sortingOrderFactor;
      }
      if (a.distanceOrScreenCoverage > b.distanceOrScreenCoverage) {
        return -sortingOrderFactor;
      }
      return 0;
    });
  }
  addLODLevel(distanceOrScreenCoverage, mesh) {
    if (mesh && mesh._masterMesh) {
      Logger.Warn("You cannot use a mesh as LOD level twice");
      return this;
    }
    const level = new MeshLODLevel(distanceOrScreenCoverage, mesh);
    this._internalMeshDataInfo._LODLevels.push(level);
    if (mesh) {
      mesh._masterMesh = this;
    }
    this._sortLODLevels();
    return this;
  }
  getLODLevelAtDistance(distance) {
    const internalDataInfo = this._internalMeshDataInfo;
    for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {
      const level = internalDataInfo._LODLevels[index];
      if (level.distanceOrScreenCoverage === distance) {
        return level.mesh;
      }
    }
    return null;
  }
  removeLODLevel(mesh) {
    const internalDataInfo = this._internalMeshDataInfo;
    for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {
      if (internalDataInfo._LODLevels[index].mesh === mesh) {
        internalDataInfo._LODLevels.splice(index, 1);
        if (mesh) {
          mesh._masterMesh = null;
        }
      }
    }
    this._sortLODLevels();
    return this;
  }
  getLOD(camera, boundingSphere) {
    const internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._LODLevels || internalDataInfo._LODLevels.length === 0) {
      return this;
    }
    const bSphere = boundingSphere || this.getBoundingInfo().boundingSphere;
    const distanceToCamera = camera.mode === Camera.ORTHOGRAPHIC_CAMERA ? camera.minZ : bSphere.centerWorld.subtract(camera.globalPosition).length();
    let compareValue = distanceToCamera;
    let compareSign = 1;
    if (internalDataInfo._useLODScreenCoverage) {
      const screenArea = camera.screenArea;
      let meshArea = bSphere.radiusWorld * camera.minZ / distanceToCamera;
      meshArea = meshArea * meshArea * Math.PI;
      compareValue = meshArea / screenArea;
      compareSign = -1;
    }
    if (compareSign * internalDataInfo._LODLevels[internalDataInfo._LODLevels.length - 1].distanceOrScreenCoverage > compareSign * compareValue) {
      if (this.onLODLevelSelection) {
        this.onLODLevelSelection(compareValue, this, this);
      }
      return this;
    }
    for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {
      const level = internalDataInfo._LODLevels[index];
      if (compareSign * level.distanceOrScreenCoverage < compareSign * compareValue) {
        if (level.mesh) {
          if (level.mesh.delayLoadState === 4) {
            level.mesh._checkDelayState();
            return this;
          }
          if (level.mesh.delayLoadState === 2) {
            return this;
          }
          level.mesh._preActivate();
          level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
        }
        if (this.onLODLevelSelection) {
          this.onLODLevelSelection(compareValue, this, level.mesh);
        }
        return level.mesh;
      }
    }
    if (this.onLODLevelSelection) {
      this.onLODLevelSelection(compareValue, this, this);
    }
    return this;
  }
  get geometry() {
    return this._geometry;
  }
  getTotalVertices() {
    if (this._geometry === null || this._geometry === void 0) {
      return 0;
    }
    return this._geometry.getTotalVertices();
  }
  getVerticesData(kind, copyWhenShared, forceCopy) {
    var _a, _b;
    if (!this._geometry) {
      return null;
    }
    let data = (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.getFloatData(this._geometry.getTotalVertices(), forceCopy || copyWhenShared && this._geometry.meshes.length !== 1);
    if (!data) {
      data = this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);
    }
    return data;
  }
  getVertexBuffer(kind) {
    var _a, _b;
    if (!this._geometry) {
      return null;
    }
    return (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== null && _b !== void 0 ? _b : this._geometry.getVertexBuffer(kind);
  }
  isVerticesDataPresent(kind) {
    var _a;
    if (!this._geometry) {
      if (this._delayInfo) {
        return this._delayInfo.indexOf(kind) !== -1;
      }
      return false;
    }
    return ((_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== void 0 || this._geometry.isVerticesDataPresent(kind);
  }
  isVertexBufferUpdatable(kind) {
    var _a, _b;
    if (!this._geometry) {
      if (this._delayInfo) {
        return this._delayInfo.indexOf(kind) !== -1;
      }
      return false;
    }
    return ((_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.isUpdatable()) || this._geometry.isVertexBufferUpdatable(kind);
  }
  getVerticesDataKinds() {
    if (!this._geometry) {
      const result = new Array();
      if (this._delayInfo) {
        this._delayInfo.forEach(function(kind) {
          result.push(kind);
        });
      }
      return result;
    }
    const kinds = this._geometry.getVerticesDataKinds();
    if (this._userInstancedBuffersStorage) {
      for (const kind in this._userInstancedBuffersStorage.vertexBuffers) {
        kinds.push(kind);
      }
    }
    return kinds;
  }
  getTotalIndices() {
    if (!this._geometry) {
      return 0;
    }
    return this._geometry.getTotalIndices();
  }
  getIndices(copyWhenShared, forceCopy) {
    if (!this._geometry) {
      return [];
    }
    return this._geometry.getIndices(copyWhenShared, forceCopy);
  }
  get isBlocked() {
    return this._masterMesh !== null && this._masterMesh !== void 0;
  }
  isReady(completeCheck = false, forceInstanceSupport = false) {
    var _a, _b, _c, _d, _e, _f;
    if (this.delayLoadState === 2) {
      return false;
    }
    if (!super.isReady(completeCheck)) {
      return false;
    }
    if (!this.subMeshes || this.subMeshes.length === 0) {
      return true;
    }
    if (!completeCheck) {
      return true;
    }
    const engine = this.getEngine();
    const scene = this.getScene();
    const hardwareInstancedRendering = forceInstanceSupport || engine.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);
    this.computeWorldMatrix();
    const mat = this.material || scene.defaultMaterial;
    if (mat) {
      if (mat._storeEffectOnSubMeshes) {
        for (const subMesh of this.subMeshes) {
          const effectiveMaterial = subMesh.getMaterial();
          if (effectiveMaterial) {
            if (effectiveMaterial._storeEffectOnSubMeshes) {
              if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {
                return false;
              }
            } else {
              if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {
                return false;
              }
            }
          }
        }
      } else {
        if (!mat.isReady(this, hardwareInstancedRendering)) {
          return false;
        }
      }
    }
    const currentRenderPassId = engine.currentRenderPassId;
    for (const light of this.lightSources) {
      const generators = light.getShadowGenerators();
      if (!generators) {
        continue;
      }
      const iterator = generators.values();
      for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
        const generator = key.value;
        if (generator && (!((_a = generator.getShadowMap()) === null || _a === void 0 ? void 0 : _a.renderList) || ((_b = generator.getShadowMap()) === null || _b === void 0 ? void 0 : _b.renderList) && ((_d = (_c = generator.getShadowMap()) === null || _c === void 0 ? void 0 : _c.renderList) === null || _d === void 0 ? void 0 : _d.indexOf(this)) !== -1)) {
          if (generator.getShadowMap()) {
            engine.currentRenderPassId = generator.getShadowMap().renderPassId;
          }
          for (const subMesh of this.subMeshes) {
            if (!generator.isReady(subMesh, hardwareInstancedRendering, (_f = (_e = subMesh.getMaterial()) === null || _e === void 0 ? void 0 : _e.needAlphaBlendingForMesh(this)) !== null && _f !== void 0 ? _f : false)) {
              engine.currentRenderPassId = currentRenderPassId;
              return false;
            }
          }
          engine.currentRenderPassId = currentRenderPassId;
        }
      }
    }
    for (const lod of this._internalMeshDataInfo._LODLevels) {
      if (lod.mesh && !lod.mesh.isReady(hardwareInstancedRendering)) {
        return false;
      }
    }
    return true;
  }
  get areNormalsFrozen() {
    return this._internalMeshDataInfo._areNormalsFrozen;
  }
  freezeNormals() {
    this._internalMeshDataInfo._areNormalsFrozen = true;
    return this;
  }
  unfreezeNormals() {
    this._internalMeshDataInfo._areNormalsFrozen = false;
    return this;
  }
  set overridenInstanceCount(count) {
    this._instanceDataStorage.overridenInstanceCount = count;
  }
  _preActivate() {
    const internalDataInfo = this._internalMeshDataInfo;
    const sceneRenderId = this.getScene().getRenderId();
    if (internalDataInfo._preActivateId === sceneRenderId) {
      return this;
    }
    internalDataInfo._preActivateId = sceneRenderId;
    this._instanceDataStorage.visibleInstances = null;
    return this;
  }
  _preActivateForIntermediateRendering(renderId) {
    if (this._instanceDataStorage.visibleInstances) {
      this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = renderId;
    }
    return this;
  }
  _registerInstanceForRenderId(instance, renderId) {
    if (!this._instanceDataStorage.visibleInstances) {
      this._instanceDataStorage.visibleInstances = {
        defaultRenderId: renderId,
        selfDefaultRenderId: this._renderId
      };
    }
    if (!this._instanceDataStorage.visibleInstances[renderId]) {
      if (this._instanceDataStorage.previousRenderId !== void 0 && this._instanceDataStorage.isFrozen) {
        this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null;
      }
      this._instanceDataStorage.previousRenderId = renderId;
      this._instanceDataStorage.visibleInstances[renderId] = new Array();
    }
    this._instanceDataStorage.visibleInstances[renderId].push(instance);
    return this;
  }
  _afterComputeWorldMatrix() {
    super._afterComputeWorldMatrix();
    if (!this.hasThinInstances) {
      return;
    }
    if (!this.doNotSyncBoundingInfo) {
      this.thinInstanceRefreshBoundingInfo(false);
    }
  }
  _postActivate() {
    if (this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup) {
      this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer);
      this.edgesRenderer.customInstances.push(this.getWorldMatrix());
    }
  }
  refreshBoundingInfo(applySkeleton = false, applyMorph = false) {
    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {
      return this;
    }
    const bias = this.geometry ? this.geometry.boundingBias : null;
    this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), bias);
    return this;
  }
  _createGlobalSubMesh(force) {
    const totalVertices = this.getTotalVertices();
    if (!totalVertices || !this.getIndices()) {
      return null;
    }
    if (this.subMeshes && this.subMeshes.length > 0) {
      const ib = this.getIndices();
      if (!ib) {
        return null;
      }
      const totalIndices = ib.length;
      let needToRecreate = false;
      if (force) {
        needToRecreate = true;
      } else {
        for (const submesh of this.subMeshes) {
          if (submesh.indexStart + submesh.indexCount > totalIndices) {
            needToRecreate = true;
            break;
          }
          if (submesh.verticesStart + submesh.verticesCount > totalVertices) {
            needToRecreate = true;
            break;
          }
        }
      }
      if (!needToRecreate) {
        return this.subMeshes[0];
      }
    }
    this.releaseSubMeshes();
    return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);
  }
  subdivide(count) {
    if (count < 1) {
      return;
    }
    const totalIndices = this.getTotalIndices();
    let subdivisionSize = totalIndices / count | 0;
    let offset = 0;
    while (subdivisionSize % 3 !== 0) {
      subdivisionSize++;
    }
    this.releaseSubMeshes();
    for (let index = 0; index < count; index++) {
      if (offset >= totalIndices) {
        break;
      }
      SubMesh.CreateFromIndices(0, offset, index === count - 1 ? totalIndices - offset : subdivisionSize, this);
      offset += subdivisionSize;
    }
    this.synchronizeInstances();
  }
  setVerticesData(kind, data, updatable = false, stride) {
    if (!this._geometry) {
      const vertexData = new VertexData();
      vertexData.set(data, kind);
      const scene = this.getScene();
      new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);
    } else {
      this._geometry.setVerticesData(kind, data, updatable, stride);
    }
    return this;
  }
  removeVerticesData(kind) {
    if (!this._geometry) {
      return;
    }
    this._geometry.removeVerticesData(kind);
  }
  markVerticesDataAsUpdatable(kind, updatable = true) {
    const vb = this.getVertexBuffer(kind);
    if (!vb || vb.isUpdatable() === updatable) {
      return;
    }
    this.setVerticesData(kind, this.getVerticesData(kind), updatable);
  }
  setVerticesBuffer(buffer, disposeExistingBuffer = true) {
    if (!this._geometry) {
      this._geometry = Geometry.CreateGeometryForMesh(this);
    }
    this._geometry.setVerticesBuffer(buffer, null, disposeExistingBuffer);
    return this;
  }
  updateVerticesData(kind, data, updateExtends, makeItUnique) {
    if (!this._geometry) {
      return this;
    }
    if (!makeItUnique) {
      this._geometry.updateVerticesData(kind, data, updateExtends);
    } else {
      this.makeGeometryUnique();
      this.updateVerticesData(kind, data, updateExtends, false);
    }
    return this;
  }
  updateMeshPositions(positionFunction, computeNormals = true) {
    const positions = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positions) {
      return this;
    }
    positionFunction(positions);
    this.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
    if (computeNormals) {
      const indices = this.getIndices();
      const normals = this.getVerticesData(VertexBuffer.NormalKind);
      if (!normals) {
        return this;
      }
      VertexData.ComputeNormals(positions, indices, normals);
      this.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);
    }
    return this;
  }
  makeGeometryUnique() {
    if (!this._geometry) {
      return this;
    }
    if (this._geometry.meshes.length === 1) {
      return this;
    }
    const oldGeometry = this._geometry;
    const geometry = this._geometry.copy(Geometry.RandomId());
    oldGeometry.releaseForMesh(this, true);
    geometry.applyToMesh(this);
    return this;
  }
  setIndices(indices, totalVertices = null, updatable = false) {
    if (!this._geometry) {
      const vertexData = new VertexData();
      vertexData.indices = indices;
      const scene = this.getScene();
      new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);
    } else {
      this._geometry.setIndices(indices, totalVertices, updatable);
    }
    return this;
  }
  updateIndices(indices, offset, gpuMemoryOnly = false) {
    if (!this._geometry) {
      return this;
    }
    this._geometry.updateIndices(indices, offset, gpuMemoryOnly);
    return this;
  }
  toLeftHanded() {
    if (!this._geometry) {
      return this;
    }
    this._geometry.toLeftHanded();
    return this;
  }
  _bind(subMesh, effect, fillMode) {
    if (!this._geometry) {
      return this;
    }
    const engine = this.getScene().getEngine();
    if (this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets) {
      this.morphTargetManager._bind(effect);
    }
    let indexToBind;
    if (this._unIndexed) {
      indexToBind = null;
    } else {
      switch (fillMode) {
        case Material.PointFillMode:
          indexToBind = null;
          break;
        case Material.WireFrameFillMode:
          indexToBind = subMesh._getLinesIndexBuffer(this.getIndices(), engine);
          break;
        default:
        case Material.TriangleFillMode:
          indexToBind = this._geometry.getIndexBuffer();
          break;
      }
    }
    if (!this._userInstancedBuffersStorage || this.hasThinInstances) {
      this._geometry._bind(effect, indexToBind);
    } else {
      this._geometry._bind(effect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);
    }
    return this;
  }
  _draw(subMesh, fillMode, instancesCount) {
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
      return this;
    }
    if (this._internalMeshDataInfo._onBeforeDrawObservable) {
      this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);
    }
    const scene = this.getScene();
    const engine = scene.getEngine();
    if (this._unIndexed || fillMode == Material.PointFillMode) {
      engine.drawArraysType(fillMode, subMesh.verticesStart, subMesh.verticesCount, this.forcedInstanceCount || instancesCount);
    } else if (fillMode == Material.WireFrameFillMode) {
      engine.drawElementsType(fillMode, 0, subMesh._linesIndexCount, this.forcedInstanceCount || instancesCount);
    } else {
      engine.drawElementsType(fillMode, subMesh.indexStart, subMesh.indexCount, this.forcedInstanceCount || instancesCount);
    }
    return this;
  }
  registerBeforeRender(func) {
    this.onBeforeRenderObservable.add(func);
    return this;
  }
  unregisterBeforeRender(func) {
    this.onBeforeRenderObservable.removeCallback(func);
    return this;
  }
  registerAfterRender(func) {
    this.onAfterRenderObservable.add(func);
    return this;
  }
  unregisterAfterRender(func) {
    this.onAfterRenderObservable.removeCallback(func);
    return this;
  }
  _getInstancesRenderList(subMeshId, isReplacementMode = false) {
    if (this._instanceDataStorage.isFrozen) {
      if (isReplacementMode) {
        this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[subMeshId] = false;
        this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[subMeshId] = true;
        return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;
      }
      if (this._instanceDataStorage.previousBatch) {
        return this._instanceDataStorage.previousBatch;
      }
    }
    const scene = this.getScene();
    const isInIntermediateRendering = scene._isInIntermediateRendering();
    const onlyForInstances = isInIntermediateRendering ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances;
    const batchCache = this._instanceDataStorage.batchCache;
    batchCache.mustReturn = false;
    batchCache.renderSelf[subMeshId] = isReplacementMode || !onlyForInstances && this.isEnabled() && this.isVisible;
    batchCache.visibleInstances[subMeshId] = null;
    if (this._instanceDataStorage.visibleInstances && !isReplacementMode) {
      const visibleInstances = this._instanceDataStorage.visibleInstances;
      const currentRenderId = scene.getRenderId();
      const defaultRenderId = isInIntermediateRendering ? visibleInstances.intermediateDefaultRenderId : visibleInstances.defaultRenderId;
      batchCache.visibleInstances[subMeshId] = visibleInstances[currentRenderId];
      if (!batchCache.visibleInstances[subMeshId] && defaultRenderId) {
        batchCache.visibleInstances[subMeshId] = visibleInstances[defaultRenderId];
      }
    }
    batchCache.hardwareInstancedRendering[subMeshId] = !isReplacementMode && this._instanceDataStorage.hardwareInstancedRendering && batchCache.visibleInstances[subMeshId] !== null && batchCache.visibleInstances[subMeshId] !== void 0;
    this._instanceDataStorage.previousBatch = batchCache;
    return batchCache;
  }
  _renderWithInstances(subMesh, fillMode, batch, effect, engine) {
    var _a;
    const visibleInstances = batch.visibleInstances[subMesh._id];
    const visibleInstanceCount = visibleInstances ? visibleInstances.length : 0;
    const instanceStorage = this._instanceDataStorage;
    const currentInstancesBufferSize = instanceStorage.instancesBufferSize;
    let instancesBuffer = instanceStorage.instancesBuffer;
    let instancesPreviousBuffer = instanceStorage.instancesPreviousBuffer;
    const matricesCount = visibleInstanceCount + 1;
    const bufferSize = matricesCount * 16 * 4;
    while (instanceStorage.instancesBufferSize < bufferSize) {
      instanceStorage.instancesBufferSize *= 2;
    }
    if (!instanceStorage.instancesData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {
      instanceStorage.instancesData = new Float32Array(instanceStorage.instancesBufferSize / 4);
    }
    if (this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {
      instanceStorage.instancesPreviousData = new Float32Array(instanceStorage.instancesBufferSize / 4);
    }
    let offset = 0;
    let instancesCount = 0;
    const renderSelf = batch.renderSelf[subMesh._id];
    const needUpdateBuffer = !instancesBuffer || currentInstancesBufferSize !== instanceStorage.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousBuffer;
    if (!this._instanceDataStorage.manualUpdate && (!instanceStorage.isFrozen || needUpdateBuffer)) {
      const world = this.getWorldMatrix();
      if (renderSelf) {
        if (this._scene.needsPreviousWorldMatrices) {
          if (!instanceStorage.masterMeshPreviousWorldMatrix) {
            instanceStorage.masterMeshPreviousWorldMatrix = world.clone();
            instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
          } else {
            instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
            instanceStorage.masterMeshPreviousWorldMatrix.copyFrom(world);
          }
        }
        world.copyToArray(instanceStorage.instancesData, offset);
        offset += 16;
        instancesCount++;
      }
      if (visibleInstances) {
        if (Mesh.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.needAlphaBlendingForMesh(subMesh.getRenderingMesh()))) {
          const cameraPosition = this._scene.activeCamera.globalPosition;
          for (let instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {
            const instanceMesh = visibleInstances[instanceIndex];
            instanceMesh._distanceToCamera = Vector3.Distance(instanceMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);
          }
          visibleInstances.sort((m1, m2) => {
            return m1._distanceToCamera > m2._distanceToCamera ? -1 : m1._distanceToCamera < m2._distanceToCamera ? 1 : 0;
          });
        }
        for (let instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {
          const instance = visibleInstances[instanceIndex];
          const matrix = instance.getWorldMatrix();
          matrix.copyToArray(instanceStorage.instancesData, offset);
          if (this._scene.needsPreviousWorldMatrices) {
            if (!instance._previousWorldMatrix) {
              instance._previousWorldMatrix = matrix.clone();
              instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
            } else {
              instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
              instance._previousWorldMatrix.copyFrom(matrix);
            }
          }
          offset += 16;
          instancesCount++;
        }
      }
    } else {
      instancesCount = (renderSelf ? 1 : 0) + visibleInstanceCount;
    }
    if (needUpdateBuffer) {
      if (instancesBuffer) {
        instancesBuffer.dispose();
      }
      if (instancesPreviousBuffer) {
        instancesPreviousBuffer.dispose();
      }
      instancesBuffer = new Buffer(engine, instanceStorage.instancesData, true, 16, false, true);
      instanceStorage.instancesBuffer = instancesBuffer;
      if (!this._userInstancedBuffersStorage) {
        this._userInstancedBuffersStorage = {
          data: {},
          vertexBuffers: {},
          strides: {},
          sizes: {},
          vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
        };
      }
      this._userInstancedBuffersStorage.vertexBuffers["world0"] = instancesBuffer.createVertexBuffer("world0", 0, 4);
      this._userInstancedBuffersStorage.vertexBuffers["world1"] = instancesBuffer.createVertexBuffer("world1", 4, 4);
      this._userInstancedBuffersStorage.vertexBuffers["world2"] = instancesBuffer.createVertexBuffer("world2", 8, 4);
      this._userInstancedBuffersStorage.vertexBuffers["world3"] = instancesBuffer.createVertexBuffer("world3", 12, 4);
      if (this._scene.needsPreviousWorldMatrices) {
        instancesPreviousBuffer = new Buffer(engine, instanceStorage.instancesPreviousData, true, 16, false, true);
        instanceStorage.instancesPreviousBuffer = instancesPreviousBuffer;
        this._userInstancedBuffersStorage.vertexBuffers["previousWorld0"] = instancesPreviousBuffer.createVertexBuffer("previousWorld0", 0, 4);
        this._userInstancedBuffersStorage.vertexBuffers["previousWorld1"] = instancesPreviousBuffer.createVertexBuffer("previousWorld1", 4, 4);
        this._userInstancedBuffersStorage.vertexBuffers["previousWorld2"] = instancesPreviousBuffer.createVertexBuffer("previousWorld2", 8, 4);
        this._userInstancedBuffersStorage.vertexBuffers["previousWorld3"] = instancesPreviousBuffer.createVertexBuffer("previousWorld3", 12, 4);
      }
      this._invalidateInstanceVertexArrayObject();
    } else {
      if (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) {
        instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);
        if (this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate)) {
          instancesPreviousBuffer.updateDirectly(instanceStorage.instancesPreviousData, 0, instancesCount);
        }
      }
    }
    this._processInstancedBuffers(visibleInstances, renderSelf);
    this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);
    if (engine._currentDrawContext) {
      engine._currentDrawContext.useInstancing = true;
    }
    this._bind(subMesh, effect, fillMode);
    this._draw(subMesh, fillMode, instancesCount);
    if (this._scene.needsPreviousWorldMatrices && !needUpdateBuffer && this._instanceDataStorage.manualUpdate && (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) && !this._instanceDataStorage.previousManualUpdate) {
      instancesPreviousBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);
    }
    engine.unbindInstanceAttributes();
    return this;
  }
  _renderWithThinInstances(subMesh, fillMode, effect, engine) {
    var _a, _b;
    const instancesCount = (_b = (_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.instancesCount) !== null && _b !== void 0 ? _b : 0;
    this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);
    if (engine._currentDrawContext) {
      engine._currentDrawContext.useInstancing = true;
    }
    this._bind(subMesh, effect, fillMode);
    this._draw(subMesh, fillMode, instancesCount);
    if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData) {
      if (!this._thinInstanceDataStorage.previousMatrixBuffer) {
        this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.matrixData, false);
      } else {
        this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, instancesCount);
      }
    }
    engine.unbindInstanceAttributes();
  }
  _processInstancedBuffers(visibleInstances, renderSelf) {
  }
  _processRendering(renderingMesh, subMesh, effect, fillMode, batch, hardwareInstancedRendering, onBeforeDraw, effectiveMaterial) {
    const scene = this.getScene();
    const engine = scene.getEngine();
    if (hardwareInstancedRendering && subMesh.getRenderingMesh().hasThinInstances) {
      this._renderWithThinInstances(subMesh, fillMode, effect, engine);
      return this;
    }
    if (hardwareInstancedRendering) {
      this._renderWithInstances(subMesh, fillMode, batch, effect, engine);
    } else {
      if (engine._currentDrawContext) {
        engine._currentDrawContext.useInstancing = false;
      }
      let instanceCount = 0;
      if (batch.renderSelf[subMesh._id]) {
        if (onBeforeDraw) {
          onBeforeDraw(false, renderingMesh.getWorldMatrix(), effectiveMaterial);
        }
        instanceCount++;
        this._draw(subMesh, fillMode, this._instanceDataStorage.overridenInstanceCount);
      }
      const visibleInstancesForSubMesh = batch.visibleInstances[subMesh._id];
      if (visibleInstancesForSubMesh) {
        const visibleInstanceCount = visibleInstancesForSubMesh.length;
        instanceCount += visibleInstanceCount;
        for (let instanceIndex = 0; instanceIndex < visibleInstanceCount; instanceIndex++) {
          const instance = visibleInstancesForSubMesh[instanceIndex];
          const world = instance.getWorldMatrix();
          if (onBeforeDraw) {
            onBeforeDraw(true, world, effectiveMaterial);
          }
          this._draw(subMesh, fillMode);
        }
      }
      scene._activeIndices.addCount(subMesh.indexCount * instanceCount, false);
    }
    return this;
  }
  _rebuild(dispose = false) {
    if (this._instanceDataStorage.instancesBuffer) {
      if (dispose) {
        this._instanceDataStorage.instancesBuffer.dispose();
      }
      this._instanceDataStorage.instancesBuffer = null;
    }
    if (this._userInstancedBuffersStorage) {
      for (const kind in this._userInstancedBuffersStorage.vertexBuffers) {
        const buffer = this._userInstancedBuffersStorage.vertexBuffers[kind];
        if (buffer) {
          if (dispose) {
            buffer.dispose();
          }
          this._userInstancedBuffersStorage.vertexBuffers[kind] = null;
        }
      }
      if (this._userInstancedBuffersStorage.vertexArrayObjects) {
        this._userInstancedBuffersStorage.vertexArrayObjects = {};
      }
    }
    this._internalMeshDataInfo._effectiveMaterial = null;
    super._rebuild(dispose);
  }
  _freeze() {
    if (!this.subMeshes) {
      return;
    }
    for (let index = 0; index < this.subMeshes.length; index++) {
      this._getInstancesRenderList(index);
    }
    this._internalMeshDataInfo._effectiveMaterial = null;
    this._instanceDataStorage.isFrozen = true;
  }
  _unFreeze() {
    this._instanceDataStorage.isFrozen = false;
    this._instanceDataStorage.previousBatch = null;
  }
  render(subMesh, enableAlphaMode, effectiveMeshReplacement) {
    var _a, _b, _c;
    const scene = this.getScene();
    if (this._internalAbstractMeshDataInfo._isActiveIntermediate) {
      this._internalAbstractMeshDataInfo._isActiveIntermediate = false;
    } else {
      this._internalAbstractMeshDataInfo._isActive = false;
    }
    if (this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded) {
      return this;
    }
    const batch = this._getInstancesRenderList(subMesh._id, !!effectiveMeshReplacement);
    if (batch.mustReturn) {
      return this;
    }
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
      return this;
    }
    const engine = scene.getEngine();
    let oldCameraMaxZ = 0;
    let oldCamera = null;
    if (this.ignoreCameraMaxZ && scene.activeCamera && !scene._isInIntermediateRendering()) {
      oldCameraMaxZ = scene.activeCamera.maxZ;
      oldCamera = scene.activeCamera;
      scene.activeCamera.maxZ = 0;
      scene.updateTransformMatrix(true);
    }
    if (this._internalMeshDataInfo._onBeforeRenderObservable) {
      this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);
    }
    const renderingMesh = subMesh.getRenderingMesh();
    const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances || !!this._userInstancedBuffersStorage && !subMesh.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh;
    const instanceDataStorage = this._instanceDataStorage;
    const material = subMesh.getMaterial();
    if (!material) {
      if (oldCamera) {
        oldCamera.maxZ = oldCameraMaxZ;
        scene.updateTransformMatrix(true);
      }
      return this;
    }
    if (!instanceDataStorage.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== material) {
      if (material._storeEffectOnSubMeshes) {
        if (!material.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {
          if (oldCamera) {
            oldCamera.maxZ = oldCameraMaxZ;
            scene.updateTransformMatrix(true);
          }
          return this;
        }
      } else if (!material.isReady(this, hardwareInstancedRendering)) {
        if (oldCamera) {
          oldCamera.maxZ = oldCameraMaxZ;
          scene.updateTransformMatrix(true);
        }
        return this;
      }
      this._internalMeshDataInfo._effectiveMaterial = material;
    } else if (material._storeEffectOnSubMeshes && !((_a = subMesh.effect) === null || _a === void 0 ? void 0 : _a._wasPreviouslyReady) || !material._storeEffectOnSubMeshes && !((_b = material.getEffect()) === null || _b === void 0 ? void 0 : _b._wasPreviouslyReady)) {
      if (oldCamera) {
        oldCamera.maxZ = oldCameraMaxZ;
        scene.updateTransformMatrix(true);
      }
      return this;
    }
    if (enableAlphaMode) {
      engine.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);
    }
    let drawWrapper;
    if (this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes) {
      drawWrapper = subMesh._drawWrapper;
    } else {
      drawWrapper = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();
    }
    const effect = (_c = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.effect) !== null && _c !== void 0 ? _c : null;
    for (const step of scene._beforeRenderingMeshStage) {
      step.action(this, subMesh, batch, effect);
    }
    if (!drawWrapper || !effect) {
      if (oldCamera) {
        oldCamera.maxZ = oldCameraMaxZ;
        scene.updateTransformMatrix(true);
      }
      return this;
    }
    const effectiveMesh = effectiveMeshReplacement || this;
    let sideOrientation;
    if (!instanceDataStorage.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {
      const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();
      sideOrientation = this.overrideMaterialSideOrientation;
      if (sideOrientation == null) {
        sideOrientation = this._internalMeshDataInfo._effectiveMaterial.sideOrientation;
      }
      if (mainDeterminant < 0) {
        sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
      }
      instanceDataStorage.sideOrientation = sideOrientation;
    } else {
      sideOrientation = instanceDataStorage.sideOrientation;
    }
    const reverse = this._internalMeshDataInfo._effectiveMaterial._preBind(drawWrapper, sideOrientation);
    if (this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite) {
      engine.setDepthWrite(true);
    }
    const fillMode = scene.forcePointsCloud ? Material.PointFillMode : scene.forceWireframe ? Material.WireFrameFillMode : this._internalMeshDataInfo._effectiveMaterial.fillMode;
    if (this._internalMeshDataInfo._onBeforeBindObservable) {
      this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this);
    }
    if (!hardwareInstancedRendering) {
      this._bind(subMesh, effect, fillMode);
    }
    const effectiveMaterial = this._internalMeshDataInfo._effectiveMaterial;
    const world = effectiveMesh.getWorldMatrix();
    if (effectiveMaterial._storeEffectOnSubMeshes) {
      effectiveMaterial.bindForSubMesh(world, this, subMesh);
    } else {
      effectiveMaterial.bind(world, this);
    }
    if (!effectiveMaterial.backFaceCulling && effectiveMaterial.separateCullingPass) {
      engine.setState(true, effectiveMaterial.zOffset, false, !reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);
      this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);
      engine.setState(true, effectiveMaterial.zOffset, false, reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);
      if (this._internalMeshDataInfo._onBetweenPassObservable) {
        this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(subMesh);
      }
    }
    this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);
    this._internalMeshDataInfo._effectiveMaterial.unbind();
    for (const step of scene._afterRenderingMeshStage) {
      step.action(this, subMesh, batch, effect);
    }
    if (this._internalMeshDataInfo._onAfterRenderObservable) {
      this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this);
    }
    if (oldCamera) {
      oldCamera.maxZ = oldCameraMaxZ;
      scene.updateTransformMatrix(true);
    }
    if (scene.performancePriority === ScenePerformancePriority.Aggressive && !instanceDataStorage.isFrozen) {
      this._freeze();
    }
    return this;
  }
  cleanMatrixWeights() {
    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {
        this._normalizeSkinWeightsAndExtra();
      } else {
        this._normalizeSkinFourWeights();
      }
    }
  }
  _normalizeSkinFourWeights() {
    const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    const numWeights = matricesWeights.length;
    for (let a = 0; a < numWeights; a += 4) {
      const t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];
      if (t === 0) {
        matricesWeights[a] = 1;
      } else {
        const recip = 1 / t;
        matricesWeights[a] *= recip;
        matricesWeights[a + 1] *= recip;
        matricesWeights[a + 2] *= recip;
        matricesWeights[a + 3] *= recip;
      }
    }
    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);
  }
  _normalizeSkinWeightsAndExtra() {
    const matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);
    const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    const numWeights = matricesWeights.length;
    for (let a = 0; a < numWeights; a += 4) {
      let t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];
      t += matricesWeightsExtra[a] + matricesWeightsExtra[a + 1] + matricesWeightsExtra[a + 2] + matricesWeightsExtra[a + 3];
      if (t === 0) {
        matricesWeights[a] = 1;
      } else {
        const recip = 1 / t;
        matricesWeights[a] *= recip;
        matricesWeights[a + 1] *= recip;
        matricesWeights[a + 2] *= recip;
        matricesWeights[a + 3] *= recip;
        matricesWeightsExtra[a] *= recip;
        matricesWeightsExtra[a + 1] *= recip;
        matricesWeightsExtra[a + 2] *= recip;
        matricesWeightsExtra[a + 3] *= recip;
      }
    }
    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);
    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsExtra);
  }
  validateSkinning() {
    const matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);
    const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    if (matricesWeights === null || this.skeleton == null) {
      return { skinned: false, valid: true, report: "not skinned" };
    }
    const numWeights = matricesWeights.length;
    let numberNotSorted = 0;
    let missingWeights = 0;
    let maxUsedWeights = 0;
    let numberNotNormalized = 0;
    const numInfluences = matricesWeightsExtra === null ? 4 : 8;
    const usedWeightCounts = new Array();
    for (let a = 0; a <= numInfluences; a++) {
      usedWeightCounts[a] = 0;
    }
    const toleranceEpsilon = 1e-3;
    for (let a = 0; a < numWeights; a += 4) {
      let lastWeight = matricesWeights[a];
      let t = lastWeight;
      let usedWeights = t === 0 ? 0 : 1;
      for (let b = 1; b < numInfluences; b++) {
        const d = b < 4 ? matricesWeights[a + b] : matricesWeightsExtra[a + b - 4];
        if (d > lastWeight) {
          numberNotSorted++;
        }
        if (d !== 0) {
          usedWeights++;
        }
        t += d;
        lastWeight = d;
      }
      usedWeightCounts[usedWeights]++;
      if (usedWeights > maxUsedWeights) {
        maxUsedWeights = usedWeights;
      }
      if (t === 0) {
        missingWeights++;
      } else {
        const recip = 1 / t;
        let tolerance = 0;
        for (let b = 0; b < numInfluences; b++) {
          if (b < 4) {
            tolerance += Math.abs(matricesWeights[a + b] - matricesWeights[a + b] * recip);
          } else {
            tolerance += Math.abs(matricesWeightsExtra[a + b - 4] - matricesWeightsExtra[a + b - 4] * recip);
          }
        }
        if (tolerance > toleranceEpsilon) {
          numberNotNormalized++;
        }
      }
    }
    const numBones = this.skeleton.bones.length;
    const matricesIndices = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
    const matricesIndicesExtra = this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);
    let numBadBoneIndices = 0;
    for (let a = 0; a < numWeights; a += 4) {
      for (let b = 0; b < numInfluences; b++) {
        const index = b < 4 ? matricesIndices[a + b] : matricesIndicesExtra[a + b - 4];
        if (index >= numBones || index < 0) {
          numBadBoneIndices++;
        }
      }
    }
    const output = "Number of Weights = " + numWeights / 4 + "\nMaximum influences = " + maxUsedWeights + "\nMissing Weights = " + missingWeights + "\nNot Sorted = " + numberNotSorted + "\nNot Normalized = " + numberNotNormalized + "\nWeightCounts = [" + usedWeightCounts + "]\nNumber of bones = " + numBones + "\nBad Bone Indices = " + numBadBoneIndices;
    return { skinned: true, valid: missingWeights === 0 && numberNotNormalized === 0 && numBadBoneIndices === 0, report: output };
  }
  _checkDelayState() {
    const scene = this.getScene();
    if (this._geometry) {
      this._geometry.load(scene);
    } else if (this.delayLoadState === 4) {
      this.delayLoadState = 2;
      this._queueLoad(scene);
    }
    return this;
  }
  _queueLoad(scene) {
    scene.addPendingData(this);
    const getBinaryData = this.delayLoadingFile.indexOf(".babylonbinarymeshdata") !== -1;
    Tools.LoadFile(this.delayLoadingFile, (data) => {
      if (data instanceof ArrayBuffer) {
        this._delayLoadingFunction(data, this);
      } else {
        this._delayLoadingFunction(JSON.parse(data), this);
      }
      this.instances.forEach((instance) => {
        instance.refreshBoundingInfo();
        instance._syncSubMeshes();
      });
      this.delayLoadState = 1;
      scene.removePendingData(this);
    }, () => {
    }, scene.offlineProvider, getBinaryData);
    return this;
  }
  isInFrustum(frustumPlanes) {
    if (this.delayLoadState === 2) {
      return false;
    }
    if (!super.isInFrustum(frustumPlanes)) {
      return false;
    }
    this._checkDelayState();
    return true;
  }
  setMaterialById(id) {
    const materials = this.getScene().materials;
    let index;
    for (index = materials.length - 1; index > -1; index--) {
      if (materials[index].id === id) {
        this.material = materials[index];
        return this;
      }
    }
    const multiMaterials = this.getScene().multiMaterials;
    for (index = multiMaterials.length - 1; index > -1; index--) {
      if (multiMaterials[index].id === id) {
        this.material = multiMaterials[index];
        return this;
      }
    }
    return this;
  }
  getAnimatables() {
    const results = new Array();
    if (this.material) {
      results.push(this.material);
    }
    if (this.skeleton) {
      results.push(this.skeleton);
    }
    return results;
  }
  bakeTransformIntoVertices(transform) {
    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      return this;
    }
    const submeshes = this.subMeshes.splice(0);
    this._resetPointsArrayCache();
    let data = this.getVerticesData(VertexBuffer.PositionKind);
    const temp = Vector3.Zero();
    let index;
    for (index = 0; index < data.length; index += 3) {
      Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], transform, temp).toArray(data, index);
    }
    this.setVerticesData(VertexBuffer.PositionKind, data, this.getVertexBuffer(VertexBuffer.PositionKind).isUpdatable());
    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      data = this.getVerticesData(VertexBuffer.NormalKind);
      for (index = 0; index < data.length; index += 3) {
        Vector3.TransformNormalFromFloatsToRef(data[index], data[index + 1], data[index + 2], transform, temp).normalize().toArray(data, index);
      }
      this.setVerticesData(VertexBuffer.NormalKind, data, this.getVertexBuffer(VertexBuffer.NormalKind).isUpdatable());
    }
    if (transform.determinant() < 0) {
      this.flipFaces();
    }
    this.releaseSubMeshes();
    this.subMeshes = submeshes;
    return this;
  }
  bakeCurrentTransformIntoVertices(bakeIndependentlyOfChildren = true) {
    this.bakeTransformIntoVertices(this.computeWorldMatrix(true));
    this.resetLocalMatrix(bakeIndependentlyOfChildren);
    return this;
  }
  get _positions() {
    if (this._internalAbstractMeshDataInfo._positions) {
      return this._internalAbstractMeshDataInfo._positions;
    }
    if (this._geometry) {
      return this._geometry._positions;
    }
    return null;
  }
  _resetPointsArrayCache() {
    if (this._geometry) {
      this._geometry._resetPointsArrayCache();
    }
    return this;
  }
  _generatePointsArray() {
    if (this._geometry) {
      return this._geometry._generatePointsArray();
    }
    return false;
  }
  clone(name63 = "", newParent = null, doNotCloneChildren, clonePhysicsImpostor = true) {
    return new Mesh(name63, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);
  }
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this.morphTargetManager = null;
    if (this._geometry) {
      this._geometry.releaseForMesh(this, true);
    }
    const internalDataInfo = this._internalMeshDataInfo;
    if (internalDataInfo._onBeforeDrawObservable) {
      internalDataInfo._onBeforeDrawObservable.clear();
    }
    if (internalDataInfo._onBeforeBindObservable) {
      internalDataInfo._onBeforeBindObservable.clear();
    }
    if (internalDataInfo._onBeforeRenderObservable) {
      internalDataInfo._onBeforeRenderObservable.clear();
    }
    if (internalDataInfo._onAfterRenderObservable) {
      internalDataInfo._onAfterRenderObservable.clear();
    }
    if (internalDataInfo._onBetweenPassObservable) {
      internalDataInfo._onBetweenPassObservable.clear();
    }
    if (this._scene.useClonedMeshMap) {
      if (internalDataInfo.meshMap) {
        for (const uniqueId in internalDataInfo.meshMap) {
          const mesh = internalDataInfo.meshMap[uniqueId];
          if (mesh) {
            mesh._internalMeshDataInfo._source = null;
            internalDataInfo.meshMap[uniqueId] = void 0;
          }
        }
      }
      if (internalDataInfo._source && internalDataInfo._source._internalMeshDataInfo.meshMap) {
        internalDataInfo._source._internalMeshDataInfo.meshMap[this.uniqueId] = void 0;
      }
    } else {
      const meshes = this.getScene().meshes;
      for (const abstractMesh of meshes) {
        const mesh = abstractMesh;
        if (mesh._internalMeshDataInfo && mesh._internalMeshDataInfo._source && mesh._internalMeshDataInfo._source === this) {
          mesh._internalMeshDataInfo._source = null;
        }
      }
    }
    internalDataInfo._source = null;
    this._disposeInstanceSpecificData();
    this._disposeThinInstanceSpecificData();
    if (this._internalMeshDataInfo._checkReadinessObserver) {
      this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);
    }
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  _disposeInstanceSpecificData() {
  }
  _disposeThinInstanceSpecificData() {
  }
  _invalidateInstanceVertexArrayObject() {
  }
  applyDisplacementMap(url, minHeight, maxHeight, onSuccess, uvOffset, uvScale, forceUpdate = false) {
    const scene = this.getScene();
    const onload = (img) => {
      const heightMapWidth = img.width;
      const heightMapHeight = img.height;
      const canvas = this.getEngine().createCanvas(heightMapWidth, heightMapHeight);
      const context = canvas.getContext("2d");
      context.drawImage(img, 0, 0);
      const buffer = context.getImageData(0, 0, heightMapWidth, heightMapHeight).data;
      this.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate);
      if (onSuccess) {
        onSuccess(this);
      }
    };
    Tools.LoadImage(url, onload, () => {
    }, scene.offlineProvider);
    return this;
  }
  applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate = false) {
    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind) || !this.isVerticesDataPresent(VertexBuffer.NormalKind) || !this.isVerticesDataPresent(VertexBuffer.UVKind)) {
      Logger.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing");
      return this;
    }
    const positions = this.getVerticesData(VertexBuffer.PositionKind, true, true);
    const normals = this.getVerticesData(VertexBuffer.NormalKind);
    const uvs = this.getVerticesData(VertexBuffer.UVKind);
    let position = Vector3.Zero();
    const normal = Vector3.Zero();
    const uv = Vector2.Zero();
    uvOffset = uvOffset || Vector2.Zero();
    uvScale = uvScale || new Vector2(1, 1);
    for (let index = 0; index < positions.length; index += 3) {
      Vector3.FromArrayToRef(positions, index, position);
      Vector3.FromArrayToRef(normals, index, normal);
      Vector2.FromArrayToRef(uvs, index / 3 * 2, uv);
      const u = Math.abs(uv.x * uvScale.x + uvOffset.x % 1) * (heightMapWidth - 1) % heightMapWidth | 0;
      const v = Math.abs(uv.y * uvScale.y + uvOffset.y % 1) * (heightMapHeight - 1) % heightMapHeight | 0;
      const pos = (u + v * heightMapWidth) * 4;
      const r = buffer[pos] / 255;
      const g = buffer[pos + 1] / 255;
      const b = buffer[pos + 2] / 255;
      const gradient = r * 0.3 + g * 0.59 + b * 0.11;
      normal.normalize();
      normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);
      position = position.add(normal);
      position.toArray(positions, index);
    }
    VertexData.ComputeNormals(positions, this.getIndices(), normals);
    if (forceUpdate) {
      this.setVerticesData(VertexBuffer.PositionKind, positions);
      this.setVerticesData(VertexBuffer.NormalKind, normals);
      this.setVerticesData(VertexBuffer.UVKind, uvs);
    } else {
      this.updateVerticesData(VertexBuffer.PositionKind, positions);
      this.updateVerticesData(VertexBuffer.NormalKind, normals);
    }
    return this;
  }
  convertToFlatShadedMesh() {
    const kinds = this.getVerticesDataKinds();
    const vbs = {};
    const data = {};
    const newdata = {};
    let updatableNormals = false;
    let kindIndex;
    let kind;
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      const vertexBuffer = this.getVertexBuffer(kind);
      const vertexData = vertexBuffer.getData();
      if (vertexData instanceof Array || vertexData instanceof Float32Array) {
        if (vertexData.length === 0) {
          continue;
        }
      }
      if (kind === VertexBuffer.NormalKind) {
        updatableNormals = vertexBuffer.isUpdatable();
        kinds.splice(kindIndex, 1);
        kindIndex--;
        continue;
      }
      vbs[kind] = vertexBuffer;
      data[kind] = this.getVerticesData(kind);
      newdata[kind] = [];
    }
    const previousSubmeshes = this.subMeshes.slice(0);
    const indices = this.getIndices();
    const totalIndices = this.getTotalIndices();
    let index;
    for (index = 0; index < totalIndices; index++) {
      const vertexIndex = indices[index];
      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
        kind = kinds[kindIndex];
        if (!vbs[kind]) {
          continue;
        }
        const stride = vbs[kind].getStrideSize();
        for (let offset = 0; offset < stride; offset++) {
          newdata[kind].push(data[kind][vertexIndex * stride + offset]);
        }
      }
    }
    const normals = [];
    const positions = newdata[VertexBuffer.PositionKind];
    const useRightHandedSystem = this.getScene().useRightHandedSystem;
    let flipNormalGeneration;
    if (useRightHandedSystem) {
      flipNormalGeneration = this.overrideMaterialSideOrientation === 1;
    } else {
      flipNormalGeneration = this.overrideMaterialSideOrientation === 0;
    }
    for (index = 0; index < totalIndices; index += 3) {
      indices[index] = index;
      indices[index + 1] = index + 1;
      indices[index + 2] = index + 2;
      const p1 = Vector3.FromArray(positions, index * 3);
      const p2 = Vector3.FromArray(positions, (index + 1) * 3);
      const p3 = Vector3.FromArray(positions, (index + 2) * 3);
      const p1p2 = p1.subtract(p2);
      const p3p2 = p3.subtract(p2);
      const normal = Vector3.Normalize(Vector3.Cross(p1p2, p3p2));
      if (flipNormalGeneration) {
        normal.scaleInPlace(-1);
      }
      for (let localIndex = 0; localIndex < 3; localIndex++) {
        normals.push(normal.x);
        normals.push(normal.y);
        normals.push(normal.z);
      }
    }
    this.setIndices(indices);
    this.setVerticesData(VertexBuffer.NormalKind, normals, updatableNormals);
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      if (!newdata[kind]) {
        continue;
      }
      this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());
    }
    this.releaseSubMeshes();
    for (let submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {
      const previousOne = previousSubmeshes[submeshIndex];
      SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);
    }
    this.synchronizeInstances();
    return this;
  }
  convertToUnIndexedMesh() {
    const kinds = this.getVerticesDataKinds();
    const vbs = {};
    const data = {};
    const newdata = {};
    let kindIndex;
    let kind;
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      const vertexBuffer = this.getVertexBuffer(kind);
      vbs[kind] = vertexBuffer;
      data[kind] = vbs[kind].getData();
      newdata[kind] = [];
    }
    const previousSubmeshes = this.subMeshes.slice(0);
    const indices = this.getIndices();
    const totalIndices = this.getTotalIndices();
    let index;
    for (index = 0; index < totalIndices; index++) {
      const vertexIndex = indices[index];
      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
        kind = kinds[kindIndex];
        const stride = vbs[kind].getStrideSize();
        for (let offset = 0; offset < stride; offset++) {
          newdata[kind].push(data[kind][vertexIndex * stride + offset]);
        }
      }
    }
    for (index = 0; index < totalIndices; index += 3) {
      indices[index] = index;
      indices[index + 1] = index + 1;
      indices[index + 2] = index + 2;
    }
    this.setIndices(indices);
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable(), vbs[kind].getStrideSize());
    }
    this.releaseSubMeshes();
    for (let submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {
      const previousOne = previousSubmeshes[submeshIndex];
      SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);
    }
    this._unIndexed = true;
    this.synchronizeInstances();
    return this;
  }
  flipFaces(flipNormals = false) {
    const vertex_data = VertexData.ExtractFromMesh(this);
    let i;
    if (flipNormals && this.isVerticesDataPresent(VertexBuffer.NormalKind) && vertex_data.normals) {
      for (i = 0; i < vertex_data.normals.length; i++) {
        vertex_data.normals[i] *= -1;
      }
    }
    if (vertex_data.indices) {
      let temp;
      for (i = 0; i < vertex_data.indices.length; i += 3) {
        temp = vertex_data.indices[i + 1];
        vertex_data.indices[i + 1] = vertex_data.indices[i + 2];
        vertex_data.indices[i + 2] = temp;
      }
    }
    vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
    return this;
  }
  increaseVertices(numberPerEdge = 1) {
    const vertex_data = VertexData.ExtractFromMesh(this);
    const currentIndices = vertex_data.indices && !Array.isArray(vertex_data.indices) && Array.from ? Array.from(vertex_data.indices) : vertex_data.indices;
    const positions = vertex_data.positions && !Array.isArray(vertex_data.positions) && Array.from ? Array.from(vertex_data.positions) : vertex_data.positions;
    const uvs = vertex_data.uvs && !Array.isArray(vertex_data.uvs) && Array.from ? Array.from(vertex_data.uvs) : vertex_data.uvs;
    const normals = vertex_data.normals && !Array.isArray(vertex_data.normals) && Array.from ? Array.from(vertex_data.normals) : vertex_data.normals;
    if (!currentIndices || !positions) {
      Logger.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions");
    } else {
      vertex_data.indices = currentIndices;
      vertex_data.positions = positions;
      if (uvs) {
        vertex_data.uvs = uvs;
      }
      if (normals) {
        vertex_data.normals = normals;
      }
      const segments = numberPerEdge + 1;
      const tempIndices = new Array();
      for (let i = 0; i < segments + 1; i++) {
        tempIndices[i] = new Array();
      }
      let a;
      let b;
      const deltaPosition = new Vector3(0, 0, 0);
      const deltaNormal = new Vector3(0, 0, 0);
      const deltaUV = new Vector2(0, 0);
      const indices = new Array();
      const vertexIndex = new Array();
      const side = new Array();
      let len;
      let positionPtr = positions.length;
      let uvPtr;
      if (uvs) {
        uvPtr = uvs.length;
      }
      let normalsPtr;
      if (normals) {
        normalsPtr = normals.length;
      }
      for (let i = 0; i < currentIndices.length; i += 3) {
        vertexIndex[0] = currentIndices[i];
        vertexIndex[1] = currentIndices[i + 1];
        vertexIndex[2] = currentIndices[i + 2];
        for (let j = 0; j < 3; j++) {
          a = vertexIndex[j];
          b = vertexIndex[(j + 1) % 3];
          if (side[a] === void 0 && side[b] === void 0) {
            side[a] = new Array();
            side[b] = new Array();
          } else {
            if (side[a] === void 0) {
              side[a] = new Array();
            }
            if (side[b] === void 0) {
              side[b] = new Array();
            }
          }
          if (side[a][b] === void 0 && side[b][a] === void 0) {
            side[a][b] = [];
            deltaPosition.x = (positions[3 * b] - positions[3 * a]) / segments;
            deltaPosition.y = (positions[3 * b + 1] - positions[3 * a + 1]) / segments;
            deltaPosition.z = (positions[3 * b + 2] - positions[3 * a + 2]) / segments;
            if (normals) {
              deltaNormal.x = (normals[3 * b] - normals[3 * a]) / segments;
              deltaNormal.y = (normals[3 * b + 1] - normals[3 * a + 1]) / segments;
              deltaNormal.z = (normals[3 * b + 2] - normals[3 * a + 2]) / segments;
            }
            if (uvs) {
              deltaUV.x = (uvs[2 * b] - uvs[2 * a]) / segments;
              deltaUV.y = (uvs[2 * b + 1] - uvs[2 * a + 1]) / segments;
            }
            side[a][b].push(a);
            for (let k = 1; k < segments; k++) {
              side[a][b].push(positions.length / 3);
              positions[positionPtr++] = positions[3 * a] + k * deltaPosition.x;
              positions[positionPtr++] = positions[3 * a + 1] + k * deltaPosition.y;
              positions[positionPtr++] = positions[3 * a + 2] + k * deltaPosition.z;
              if (normals) {
                normals[normalsPtr++] = normals[3 * a] + k * deltaNormal.x;
                normals[normalsPtr++] = normals[3 * a + 1] + k * deltaNormal.y;
                normals[normalsPtr++] = normals[3 * a + 2] + k * deltaNormal.z;
              }
              if (uvs) {
                uvs[uvPtr++] = uvs[2 * a] + k * deltaUV.x;
                uvs[uvPtr++] = uvs[2 * a + 1] + k * deltaUV.y;
              }
            }
            side[a][b].push(b);
            side[b][a] = new Array();
            len = side[a][b].length;
            for (let idx = 0; idx < len; idx++) {
              side[b][a][idx] = side[a][b][len - 1 - idx];
            }
          }
        }
        tempIndices[0][0] = currentIndices[i];
        tempIndices[1][0] = side[currentIndices[i]][currentIndices[i + 1]][1];
        tempIndices[1][1] = side[currentIndices[i]][currentIndices[i + 2]][1];
        for (let k = 2; k < segments; k++) {
          tempIndices[k][0] = side[currentIndices[i]][currentIndices[i + 1]][k];
          tempIndices[k][k] = side[currentIndices[i]][currentIndices[i + 2]][k];
          deltaPosition.x = (positions[3 * tempIndices[k][k]] - positions[3 * tempIndices[k][0]]) / k;
          deltaPosition.y = (positions[3 * tempIndices[k][k] + 1] - positions[3 * tempIndices[k][0] + 1]) / k;
          deltaPosition.z = (positions[3 * tempIndices[k][k] + 2] - positions[3 * tempIndices[k][0] + 2]) / k;
          if (normals) {
            deltaNormal.x = (normals[3 * tempIndices[k][k]] - normals[3 * tempIndices[k][0]]) / k;
            deltaNormal.y = (normals[3 * tempIndices[k][k] + 1] - normals[3 * tempIndices[k][0] + 1]) / k;
            deltaNormal.z = (normals[3 * tempIndices[k][k] + 2] - normals[3 * tempIndices[k][0] + 2]) / k;
          }
          if (uvs) {
            deltaUV.x = (uvs[2 * tempIndices[k][k]] - uvs[2 * tempIndices[k][0]]) / k;
            deltaUV.y = (uvs[2 * tempIndices[k][k] + 1] - uvs[2 * tempIndices[k][0] + 1]) / k;
          }
          for (let j = 1; j < k; j++) {
            tempIndices[k][j] = positions.length / 3;
            positions[positionPtr++] = positions[3 * tempIndices[k][0]] + j * deltaPosition.x;
            positions[positionPtr++] = positions[3 * tempIndices[k][0] + 1] + j * deltaPosition.y;
            positions[positionPtr++] = positions[3 * tempIndices[k][0] + 2] + j * deltaPosition.z;
            if (normals) {
              normals[normalsPtr++] = normals[3 * tempIndices[k][0]] + j * deltaNormal.x;
              normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 1] + j * deltaNormal.y;
              normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 2] + j * deltaNormal.z;
            }
            if (uvs) {
              uvs[uvPtr++] = uvs[2 * tempIndices[k][0]] + j * deltaUV.x;
              uvs[uvPtr++] = uvs[2 * tempIndices[k][0] + 1] + j * deltaUV.y;
            }
          }
        }
        tempIndices[segments] = side[currentIndices[i + 1]][currentIndices[i + 2]];
        indices.push(tempIndices[0][0], tempIndices[1][0], tempIndices[1][1]);
        for (let k = 1; k < segments; k++) {
          let j;
          for (j = 0; j < k; j++) {
            indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);
            indices.push(tempIndices[k][j], tempIndices[k + 1][j + 1], tempIndices[k][j + 1]);
          }
          indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);
        }
      }
      vertex_data.indices = indices;
      vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
    }
  }
  forceSharedVertices() {
    const vertex_data = VertexData.ExtractFromMesh(this);
    const currentUVs = vertex_data.uvs;
    const currentIndices = vertex_data.indices;
    const currentPositions = vertex_data.positions;
    const currentColors = vertex_data.colors;
    const currentMatrixIndices = vertex_data.matricesIndices;
    const currentMatrixWeights = vertex_data.matricesWeights;
    const currentMatrixIndicesExtra = vertex_data.matricesIndicesExtra;
    const currentMatrixWeightsExtra = vertex_data.matricesWeightsExtra;
    if (currentIndices === void 0 || currentPositions === void 0 || currentIndices === null || currentPositions === null) {
      Logger.Warn("VertexData contains empty entries");
    } else {
      const positions = new Array();
      const indices = new Array();
      const uvs = new Array();
      const colors = new Array();
      const matrixIndices = new Array();
      const matrixWeights = new Array();
      const matrixIndicesExtra = new Array();
      const matrixWeightsExtra = new Array();
      let pstring = new Array();
      let indexPtr = 0;
      const uniquePositions = {};
      let ptr;
      let facet;
      for (let i = 0; i < currentIndices.length; i += 3) {
        facet = [currentIndices[i], currentIndices[i + 1], currentIndices[i + 2]];
        pstring = new Array();
        for (let j = 0; j < 3; j++) {
          pstring[j] = "";
          for (let k = 0; k < 3; k++) {
            if (Math.abs(currentPositions[3 * facet[j] + k]) < 1e-8) {
              currentPositions[3 * facet[j] + k] = 0;
            }
            pstring[j] += currentPositions[3 * facet[j] + k] + "|";
          }
        }
        if (!(pstring[0] == pstring[1] || pstring[0] == pstring[2] || pstring[1] == pstring[2])) {
          for (let j = 0; j < 3; j++) {
            ptr = uniquePositions[pstring[j]];
            if (ptr === void 0) {
              uniquePositions[pstring[j]] = indexPtr;
              ptr = indexPtr++;
              for (let k = 0; k < 3; k++) {
                positions.push(currentPositions[3 * facet[j] + k]);
              }
              if (currentColors !== null && currentColors !== void 0) {
                for (let k = 0; k < 4; k++) {
                  colors.push(currentColors[4 * facet[j] + k]);
                }
              }
              if (currentUVs !== null && currentUVs !== void 0) {
                for (let k = 0; k < 2; k++) {
                  uvs.push(currentUVs[2 * facet[j] + k]);
                }
              }
              if (currentMatrixIndices !== null && currentMatrixIndices !== void 0) {
                for (let k = 0; k < 4; k++) {
                  matrixIndices.push(currentMatrixIndices[4 * facet[j] + k]);
                }
              }
              if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {
                for (let k = 0; k < 4; k++) {
                  matrixWeights.push(currentMatrixWeights[4 * facet[j] + k]);
                }
              }
              if (currentMatrixIndicesExtra !== null && currentMatrixIndicesExtra !== void 0) {
                for (let k = 0; k < 4; k++) {
                  matrixIndicesExtra.push(currentMatrixIndicesExtra[4 * facet[j] + k]);
                }
              }
              if (currentMatrixWeightsExtra !== null && currentMatrixWeightsExtra !== void 0) {
                for (let k = 0; k < 4; k++) {
                  matrixWeightsExtra.push(currentMatrixWeightsExtra[4 * facet[j] + k]);
                }
              }
            }
            indices.push(ptr);
          }
        }
      }
      const normals = new Array();
      VertexData.ComputeNormals(positions, indices, normals);
      vertex_data.positions = positions;
      vertex_data.indices = indices;
      vertex_data.normals = normals;
      if (currentUVs !== null && currentUVs !== void 0) {
        vertex_data.uvs = uvs;
      }
      if (currentColors !== null && currentColors !== void 0) {
        vertex_data.colors = colors;
      }
      if (currentMatrixIndices !== null && currentMatrixIndices !== void 0) {
        vertex_data.matricesIndices = matrixIndices;
      }
      if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {
        vertex_data.matricesWeights = matrixWeights;
      }
      if (currentMatrixIndicesExtra !== null && currentMatrixIndicesExtra !== void 0) {
        vertex_data.matricesIndicesExtra = matrixIndicesExtra;
      }
      if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {
        vertex_data.matricesWeightsExtra = matrixWeightsExtra;
      }
      vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
    }
  }
  static _instancedMeshFactory(name63, mesh) {
    throw _WarnImport("InstancedMesh");
  }
  static _PhysicsImpostorParser(scene, physicObject, jsonObject) {
    throw _WarnImport("PhysicsImpostor");
  }
  createInstance(name63) {
    return Mesh._instancedMeshFactory(name63, this);
  }
  synchronizeInstances() {
    for (let instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {
      const instance = this.instances[instanceIndex];
      instance._syncSubMeshes();
    }
    return this;
  }
  optimizeIndices(successCallback) {
    const indices = this.getIndices();
    const positions = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positions || !indices) {
      return this;
    }
    const vectorPositions = new Array();
    for (let pos = 0; pos < positions.length; pos = pos + 3) {
      vectorPositions.push(Vector3.FromArray(positions, pos));
    }
    const dupes = new Array();
    AsyncLoop.SyncAsyncForLoop(vectorPositions.length, 40, (iteration) => {
      const realPos = vectorPositions.length - 1 - iteration;
      const testedPosition = vectorPositions[realPos];
      for (let j = 0; j < realPos; ++j) {
        const againstPosition = vectorPositions[j];
        if (testedPosition.equals(againstPosition)) {
          dupes[realPos] = j;
          break;
        }
      }
    }, () => {
      for (let i = 0; i < indices.length; ++i) {
        indices[i] = dupes[indices[i]] || indices[i];
      }
      const originalSubMeshes = this.subMeshes.slice(0);
      this.setIndices(indices);
      this.subMeshes = originalSubMeshes;
      if (successCallback) {
        successCallback(this);
      }
    });
    return this;
  }
  serialize(serializationObject = {}) {
    serializationObject.name = this.name;
    serializationObject.id = this.id;
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getClassName();
    if (Tags && Tags.HasTags(this)) {
      serializationObject.tags = Tags.GetTags(this);
    }
    serializationObject.position = this.position.asArray();
    if (this.rotationQuaternion) {
      serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();
    } else if (this.rotation) {
      serializationObject.rotation = this.rotation.asArray();
    }
    serializationObject.scaling = this.scaling.asArray();
    if (this._postMultiplyPivotMatrix) {
      serializationObject.pivotMatrix = this.getPivotMatrix().asArray();
    } else {
      serializationObject.localMatrix = this.getPivotMatrix().asArray();
    }
    serializationObject.isEnabled = this.isEnabled(false);
    serializationObject.isVisible = this.isVisible;
    serializationObject.infiniteDistance = this.infiniteDistance;
    serializationObject.pickable = this.isPickable;
    serializationObject.receiveShadows = this.receiveShadows;
    serializationObject.billboardMode = this.billboardMode;
    serializationObject.visibility = this.visibility;
    serializationObject.checkCollisions = this.checkCollisions;
    serializationObject.isBlocker = this.isBlocker;
    serializationObject.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation;
    if (this.parent) {
      this.parent._serializeAsParent(serializationObject);
    }
    serializationObject.isUnIndexed = this.isUnIndexed;
    const geometry = this._geometry;
    if (geometry && this.subMeshes) {
      serializationObject.geometryUniqueId = geometry.uniqueId;
      serializationObject.geometryId = geometry.id;
      serializationObject.subMeshes = [];
      for (let subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {
        const subMesh = this.subMeshes[subIndex];
        serializationObject.subMeshes.push({
          materialIndex: subMesh.materialIndex,
          verticesStart: subMesh.verticesStart,
          verticesCount: subMesh.verticesCount,
          indexStart: subMesh.indexStart,
          indexCount: subMesh.indexCount
        });
      }
    }
    if (this.material) {
      if (!this.material.doNotSerialize) {
        serializationObject.materialUniqueId = this.material.uniqueId;
        serializationObject.materialId = this.material.id;
      }
    } else {
      this.material = null;
      serializationObject.materialUniqueId = this._scene.defaultMaterial.uniqueId;
      serializationObject.materialId = this._scene.defaultMaterial.id;
    }
    if (this.morphTargetManager) {
      serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;
    }
    if (this.skeleton) {
      serializationObject.skeletonId = this.skeleton.id;
      serializationObject.numBoneInfluencers = this.numBoneInfluencers;
    }
    if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {
      const impostor = this.getPhysicsImpostor();
      if (impostor) {
        serializationObject.physicsMass = impostor.getParam("mass");
        serializationObject.physicsFriction = impostor.getParam("friction");
        serializationObject.physicsRestitution = impostor.getParam("mass");
        serializationObject.physicsImpostor = impostor.type;
      }
    }
    if (this.metadata) {
      serializationObject.metadata = this.metadata;
    }
    serializationObject.instances = [];
    for (let index = 0; index < this.instances.length; index++) {
      const instance = this.instances[index];
      if (instance.doNotSerialize) {
        continue;
      }
      const serializationInstance = {
        name: instance.name,
        id: instance.id,
        isEnabled: instance.isEnabled(false),
        isVisible: instance.isVisible,
        isPickable: instance.isPickable,
        checkCollisions: instance.checkCollisions,
        position: instance.position.asArray(),
        scaling: instance.scaling.asArray()
      };
      if (instance.parent) {
        instance.parent._serializeAsParent(serializationInstance);
      }
      if (instance.rotationQuaternion) {
        serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();
      } else if (instance.rotation) {
        serializationInstance.rotation = instance.rotation.asArray();
      }
      if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {
        const impostor = instance.getPhysicsImpostor();
        if (impostor) {
          serializationInstance.physicsMass = impostor.getParam("mass");
          serializationInstance.physicsFriction = impostor.getParam("friction");
          serializationInstance.physicsRestitution = impostor.getParam("mass");
          serializationInstance.physicsImpostor = impostor.type;
        }
      }
      if (instance.metadata) {
        serializationInstance.metadata = instance.metadata;
      }
      serializationObject.instances.push(serializationInstance);
      SerializationHelper.AppendSerializedAnimations(instance, serializationInstance);
      serializationInstance.ranges = instance.serializeAnimationRanges();
    }
    if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData) {
      serializationObject.thinInstances = {
        instancesCount: this._thinInstanceDataStorage.instancesCount,
        matrixData: Array.from(this._thinInstanceDataStorage.matrixData),
        matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,
        enablePicking: this.thinInstanceEnablePicking
      };
      if (this._userThinInstanceBuffersStorage) {
        const userThinInstance = {
          data: {},
          sizes: {},
          strides: {}
        };
        for (const kind in this._userThinInstanceBuffersStorage.data) {
          userThinInstance.data[kind] = Array.from(this._userThinInstanceBuffersStorage.data[kind]);
          userThinInstance.sizes[kind] = this._userThinInstanceBuffersStorage.sizes[kind];
          userThinInstance.strides[kind] = this._userThinInstanceBuffersStorage.strides[kind];
        }
        serializationObject.thinInstances.userThinInstance = userThinInstance;
      }
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.layerMask = this.layerMask;
    serializationObject.alphaIndex = this.alphaIndex;
    serializationObject.hasVertexAlpha = this.hasVertexAlpha;
    serializationObject.overlayAlpha = this.overlayAlpha;
    serializationObject.overlayColor = this.overlayColor.asArray();
    serializationObject.renderOverlay = this.renderOverlay;
    serializationObject.applyFog = this.applyFog;
    if (this.actionManager) {
      serializationObject.actions = this.actionManager.serialize(this.name);
    }
    return serializationObject;
  }
  _syncGeometryWithMorphTargetManager() {
    if (!this.geometry) {
      return;
    }
    this._markSubMeshesAsAttributesDirty();
    const morphTargetManager = this._internalAbstractMeshDataInfo._morphTargetManager;
    if (morphTargetManager && morphTargetManager.vertexCount) {
      if (morphTargetManager.vertexCount !== this.getTotalVertices()) {
        Logger.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.");
        this.morphTargetManager = null;
        return;
      }
      if (morphTargetManager.isUsingTextureForTargets) {
        return;
      }
      for (let index = 0; index < morphTargetManager.numInfluencers; index++) {
        const morphTarget = morphTargetManager.getActiveTarget(index);
        const positions = morphTarget.getPositions();
        if (!positions) {
          Logger.Error("Invalid morph target. Target must have positions.");
          return;
        }
        this.geometry.setVerticesData(VertexBuffer.PositionKind + index, positions, false, 3);
        const normals = morphTarget.getNormals();
        if (normals) {
          this.geometry.setVerticesData(VertexBuffer.NormalKind + index, normals, false, 3);
        }
        const tangents = morphTarget.getTangents();
        if (tangents) {
          this.geometry.setVerticesData(VertexBuffer.TangentKind + index, tangents, false, 3);
        }
        const uvs = morphTarget.getUVs();
        if (uvs) {
          this.geometry.setVerticesData(VertexBuffer.UVKind + "_" + index, uvs, false, 2);
        }
      }
    } else {
      let index = 0;
      while (this.geometry.isVerticesDataPresent(VertexBuffer.PositionKind + index)) {
        this.geometry.removeVerticesData(VertexBuffer.PositionKind + index);
        if (this.geometry.isVerticesDataPresent(VertexBuffer.NormalKind + index)) {
          this.geometry.removeVerticesData(VertexBuffer.NormalKind + index);
        }
        if (this.geometry.isVerticesDataPresent(VertexBuffer.TangentKind + index)) {
          this.geometry.removeVerticesData(VertexBuffer.TangentKind + index);
        }
        if (this.geometry.isVerticesDataPresent(VertexBuffer.UVKind + index)) {
          this.geometry.removeVerticesData(VertexBuffer.UVKind + "_" + index);
        }
        index++;
      }
    }
  }
  static Parse(parsedMesh, scene, rootUrl) {
    let mesh;
    if (parsedMesh.type && parsedMesh.type === "LinesMesh") {
      mesh = Mesh._LinesMeshParser(parsedMesh, scene);
    } else if (parsedMesh.type && parsedMesh.type === "GroundMesh") {
      mesh = Mesh._GroundMeshParser(parsedMesh, scene);
    } else if (parsedMesh.type && parsedMesh.type === "GoldbergMesh") {
      mesh = Mesh._GoldbergMeshParser(parsedMesh, scene);
    } else {
      mesh = new Mesh(parsedMesh.name, scene);
    }
    mesh.id = parsedMesh.id;
    mesh._waitingParsedUniqueId = parsedMesh.uniqueId;
    if (Tags) {
      Tags.AddTagsTo(mesh, parsedMesh.tags);
    }
    mesh.position = Vector3.FromArray(parsedMesh.position);
    if (parsedMesh.metadata !== void 0) {
      mesh.metadata = parsedMesh.metadata;
    }
    if (parsedMesh.rotationQuaternion) {
      mesh.rotationQuaternion = Quaternion.FromArray(parsedMesh.rotationQuaternion);
    } else if (parsedMesh.rotation) {
      mesh.rotation = Vector3.FromArray(parsedMesh.rotation);
    }
    mesh.scaling = Vector3.FromArray(parsedMesh.scaling);
    if (parsedMesh.localMatrix) {
      mesh.setPreTransformMatrix(Matrix.FromArray(parsedMesh.localMatrix));
    } else if (parsedMesh.pivotMatrix) {
      mesh.setPivotMatrix(Matrix.FromArray(parsedMesh.pivotMatrix));
    }
    mesh.setEnabled(parsedMesh.isEnabled);
    mesh.isVisible = parsedMesh.isVisible;
    mesh.infiniteDistance = parsedMesh.infiniteDistance;
    mesh.showBoundingBox = parsedMesh.showBoundingBox;
    mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;
    if (parsedMesh.applyFog !== void 0) {
      mesh.applyFog = parsedMesh.applyFog;
    }
    if (parsedMesh.pickable !== void 0) {
      mesh.isPickable = parsedMesh.pickable;
    }
    if (parsedMesh.alphaIndex !== void 0) {
      mesh.alphaIndex = parsedMesh.alphaIndex;
    }
    mesh.receiveShadows = parsedMesh.receiveShadows;
    if (parsedMesh.billboardMode !== void 0) {
      mesh.billboardMode = parsedMesh.billboardMode;
    }
    if (parsedMesh.visibility !== void 0) {
      mesh.visibility = parsedMesh.visibility;
    }
    mesh.checkCollisions = parsedMesh.checkCollisions;
    mesh.overrideMaterialSideOrientation = parsedMesh.overrideMaterialSideOrientation;
    if (parsedMesh.isBlocker !== void 0) {
      mesh.isBlocker = parsedMesh.isBlocker;
    }
    mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading;
    if (parsedMesh.freezeWorldMatrix) {
      mesh._waitingData.freezeWorldMatrix = parsedMesh.freezeWorldMatrix;
    }
    if (parsedMesh.parentId !== void 0) {
      mesh._waitingParentId = parsedMesh.parentId;
    }
    if (parsedMesh.parentInstanceIndex !== void 0) {
      mesh._waitingParentInstanceIndex = parsedMesh.parentInstanceIndex;
    }
    if (parsedMesh.actions !== void 0) {
      mesh._waitingData.actions = parsedMesh.actions;
    }
    if (parsedMesh.overlayAlpha !== void 0) {
      mesh.overlayAlpha = parsedMesh.overlayAlpha;
    }
    if (parsedMesh.overlayColor !== void 0) {
      mesh.overlayColor = Color3.FromArray(parsedMesh.overlayColor);
    }
    if (parsedMesh.renderOverlay !== void 0) {
      mesh.renderOverlay = parsedMesh.renderOverlay;
    }
    mesh.isUnIndexed = !!parsedMesh.isUnIndexed;
    mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;
    if (parsedMesh.delayLoadingFile) {
      mesh.delayLoadState = 4;
      mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;
      mesh.buildBoundingInfo(Vector3.FromArray(parsedMesh.boundingBoxMinimum), Vector3.FromArray(parsedMesh.boundingBoxMaximum));
      if (parsedMesh._binaryInfo) {
        mesh._binaryInfo = parsedMesh._binaryInfo;
      }
      mesh._delayInfo = [];
      if (parsedMesh.hasUVs) {
        mesh._delayInfo.push(VertexBuffer.UVKind);
      }
      if (parsedMesh.hasUVs2) {
        mesh._delayInfo.push(VertexBuffer.UV2Kind);
      }
      if (parsedMesh.hasUVs3) {
        mesh._delayInfo.push(VertexBuffer.UV3Kind);
      }
      if (parsedMesh.hasUVs4) {
        mesh._delayInfo.push(VertexBuffer.UV4Kind);
      }
      if (parsedMesh.hasUVs5) {
        mesh._delayInfo.push(VertexBuffer.UV5Kind);
      }
      if (parsedMesh.hasUVs6) {
        mesh._delayInfo.push(VertexBuffer.UV6Kind);
      }
      if (parsedMesh.hasColors) {
        mesh._delayInfo.push(VertexBuffer.ColorKind);
      }
      if (parsedMesh.hasMatricesIndices) {
        mesh._delayInfo.push(VertexBuffer.MatricesIndicesKind);
      }
      if (parsedMesh.hasMatricesWeights) {
        mesh._delayInfo.push(VertexBuffer.MatricesWeightsKind);
      }
      mesh._delayLoadingFunction = Geometry._ImportGeometry;
      if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {
        mesh._checkDelayState();
      }
    } else {
      Geometry._ImportGeometry(parsedMesh, mesh);
    }
    if (parsedMesh.materialUniqueId) {
      mesh._waitingMaterialId = parsedMesh.materialUniqueId;
    } else if (parsedMesh.materialId) {
      mesh._waitingMaterialId = parsedMesh.materialId;
    }
    if (parsedMesh.morphTargetManagerId > -1) {
      mesh.morphTargetManager = scene.getMorphTargetManagerById(parsedMesh.morphTargetManagerId);
    }
    if (parsedMesh.skeletonId !== void 0 && parsedMesh.skeletonId !== null) {
      mesh.skeleton = scene.getLastSkeletonById(parsedMesh.skeletonId);
      if (parsedMesh.numBoneInfluencers) {
        mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;
      }
    }
    if (parsedMesh.animations) {
      for (let animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {
        const parsedAnimation = parsedMesh.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          mesh.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(mesh, parsedMesh, scene);
    }
    if (parsedMesh.autoAnimate) {
      scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1);
    }
    if (parsedMesh.layerMask && !isNaN(parsedMesh.layerMask)) {
      mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));
    } else {
      mesh.layerMask = 268435455;
    }
    if (parsedMesh.physicsImpostor) {
      Mesh._PhysicsImpostorParser(scene, mesh, parsedMesh);
    }
    if (parsedMesh.lodMeshIds) {
      mesh._waitingData.lods = {
        ids: parsedMesh.lodMeshIds,
        distances: parsedMesh.lodDistances ? parsedMesh.lodDistances : null,
        coverages: parsedMesh.lodCoverages ? parsedMesh.lodCoverages : null
      };
    }
    if (parsedMesh.instances) {
      for (let index = 0; index < parsedMesh.instances.length; index++) {
        const parsedInstance = parsedMesh.instances[index];
        const instance = mesh.createInstance(parsedInstance.name);
        if (parsedInstance.id) {
          instance.id = parsedInstance.id;
        }
        if (Tags) {
          if (parsedInstance.tags) {
            Tags.AddTagsTo(instance, parsedInstance.tags);
          } else {
            Tags.AddTagsTo(instance, parsedMesh.tags);
          }
        }
        instance.position = Vector3.FromArray(parsedInstance.position);
        if (parsedInstance.metadata !== void 0) {
          instance.metadata = parsedInstance.metadata;
        }
        if (parsedInstance.parentId !== void 0) {
          instance._waitingParentId = parsedInstance.parentId;
        }
        if (parsedInstance.parentInstanceIndex !== void 0) {
          instance._waitingParentInstanceIndex = parsedInstance.parentInstanceIndex;
        }
        if (parsedInstance.isEnabled !== void 0 && parsedInstance.isEnabled !== null) {
          instance.setEnabled(parsedInstance.isEnabled);
        }
        if (parsedInstance.isVisible !== void 0 && parsedInstance.isVisible !== null) {
          instance.isVisible = parsedInstance.isVisible;
        }
        if (parsedInstance.isPickable !== void 0 && parsedInstance.isPickable !== null) {
          instance.isPickable = parsedInstance.isPickable;
        }
        if (parsedInstance.rotationQuaternion) {
          instance.rotationQuaternion = Quaternion.FromArray(parsedInstance.rotationQuaternion);
        } else if (parsedInstance.rotation) {
          instance.rotation = Vector3.FromArray(parsedInstance.rotation);
        }
        instance.scaling = Vector3.FromArray(parsedInstance.scaling);
        if (parsedInstance.checkCollisions != void 0 && parsedInstance.checkCollisions != null) {
          instance.checkCollisions = parsedInstance.checkCollisions;
        }
        if (parsedInstance.pickable != void 0 && parsedInstance.pickable != null) {
          instance.isPickable = parsedInstance.pickable;
        }
        if (parsedInstance.showBoundingBox != void 0 && parsedInstance.showBoundingBox != null) {
          instance.showBoundingBox = parsedInstance.showBoundingBox;
        }
        if (parsedInstance.showSubMeshesBoundingBox != void 0 && parsedInstance.showSubMeshesBoundingBox != null) {
          instance.showSubMeshesBoundingBox = parsedInstance.showSubMeshesBoundingBox;
        }
        if (parsedInstance.alphaIndex != void 0 && parsedInstance.showSubMeshesBoundingBox != null) {
          instance.alphaIndex = parsedInstance.alphaIndex;
        }
        if (parsedInstance.physicsImpostor) {
          Mesh._PhysicsImpostorParser(scene, instance, parsedInstance);
        }
        if (parsedInstance.animations) {
          for (let animationIndex = 0; animationIndex < parsedInstance.animations.length; animationIndex++) {
            const parsedAnimation = parsedInstance.animations[animationIndex];
            const internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              instance.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          Node.ParseAnimationRanges(instance, parsedInstance, scene);
          if (parsedInstance.autoAnimate) {
            scene.beginAnimation(instance, parsedInstance.autoAnimateFrom, parsedInstance.autoAnimateTo, parsedInstance.autoAnimateLoop, parsedInstance.autoAnimateSpeed || 1);
          }
        }
      }
    }
    if (parsedMesh.thinInstances) {
      const thinInstances = parsedMesh.thinInstances;
      mesh.thinInstanceEnablePicking = !!thinInstances.enablePicking;
      if (thinInstances.matrixData) {
        mesh.thinInstanceSetBuffer("matrix", new Float32Array(thinInstances.matrixData), 16, false);
        mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;
        mesh._thinInstanceDataStorage.instancesCount = thinInstances.instancesCount;
      } else {
        mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;
      }
      if (parsedMesh.thinInstances.userThinInstance) {
        const userThinInstance = parsedMesh.thinInstances.userThinInstance;
        for (const kind in userThinInstance.data) {
          mesh.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], false);
          mesh._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];
        }
      }
    }
    return mesh;
  }
  setPositionsForCPUSkinning() {
    const internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._sourcePositions) {
      const source = this.getVerticesData(VertexBuffer.PositionKind);
      if (!source) {
        return internalDataInfo._sourcePositions;
      }
      internalDataInfo._sourcePositions = new Float32Array(source);
      if (!this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {
        this.setVerticesData(VertexBuffer.PositionKind, source, true);
      }
    }
    return internalDataInfo._sourcePositions;
  }
  setNormalsForCPUSkinning() {
    const internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._sourceNormals) {
      const source = this.getVerticesData(VertexBuffer.NormalKind);
      if (!source) {
        return internalDataInfo._sourceNormals;
      }
      internalDataInfo._sourceNormals = new Float32Array(source);
      if (!this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {
        this.setVerticesData(VertexBuffer.NormalKind, source, true);
      }
    }
    return internalDataInfo._sourceNormals;
  }
  applySkeleton(skeleton) {
    if (!this.geometry) {
      return this;
    }
    if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) {
      return this;
    }
    this.geometry._softwareSkinningFrameId = this.getScene().getFrameId();
    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      return this;
    }
    if (!this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
      return this;
    }
    if (!this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      return this;
    }
    const hasNormals = this.isVerticesDataPresent(VertexBuffer.NormalKind);
    const internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._sourcePositions) {
      const submeshes = this.subMeshes.slice();
      this.setPositionsForCPUSkinning();
      this.subMeshes = submeshes;
    }
    if (hasNormals && !internalDataInfo._sourceNormals) {
      this.setNormalsForCPUSkinning();
    }
    let positionsData = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positionsData) {
      return this;
    }
    if (!(positionsData instanceof Float32Array)) {
      positionsData = new Float32Array(positionsData);
    }
    let normalsData = this.getVerticesData(VertexBuffer.NormalKind);
    if (hasNormals) {
      if (!normalsData) {
        return this;
      }
      if (!(normalsData instanceof Float32Array)) {
        normalsData = new Float32Array(normalsData);
      }
    }
    const matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
    const matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    if (!matricesWeightsData || !matricesIndicesData) {
      return this;
    }
    const needExtras = this.numBoneInfluencers > 4;
    const matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
    const matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
    const skeletonMatrices = skeleton.getTransformMatrices(this);
    const tempVector3 = Vector3.Zero();
    const finalMatrix = new Matrix();
    const tempMatrix = new Matrix();
    let matWeightIdx = 0;
    let inf;
    for (let index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {
      let weight;
      for (inf = 0; inf < 4; inf++) {
        weight = matricesWeightsData[matWeightIdx + inf];
        if (weight > 0) {
          Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);
          finalMatrix.addToSelf(tempMatrix);
        }
      }
      if (needExtras) {
        for (inf = 0; inf < 4; inf++) {
          weight = matricesWeightsExtraData[matWeightIdx + inf];
          if (weight > 0) {
            Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);
            finalMatrix.addToSelf(tempMatrix);
          }
        }
      }
      Vector3.TransformCoordinatesFromFloatsToRef(internalDataInfo._sourcePositions[index], internalDataInfo._sourcePositions[index + 1], internalDataInfo._sourcePositions[index + 2], finalMatrix, tempVector3);
      tempVector3.toArray(positionsData, index);
      if (hasNormals) {
        Vector3.TransformNormalFromFloatsToRef(internalDataInfo._sourceNormals[index], internalDataInfo._sourceNormals[index + 1], internalDataInfo._sourceNormals[index + 2], finalMatrix, tempVector3);
        tempVector3.toArray(normalsData, index);
      }
      finalMatrix.reset();
    }
    this.updateVerticesData(VertexBuffer.PositionKind, positionsData);
    if (hasNormals) {
      this.updateVerticesData(VertexBuffer.NormalKind, normalsData);
    }
    return this;
  }
  static MinMax(meshes) {
    let minVector = null;
    let maxVector = null;
    meshes.forEach(function(mesh) {
      const boundingInfo = mesh.getBoundingInfo();
      const boundingBox = boundingInfo.boundingBox;
      if (!minVector || !maxVector) {
        minVector = boundingBox.minimumWorld;
        maxVector = boundingBox.maximumWorld;
      } else {
        minVector.minimizeInPlace(boundingBox.minimumWorld);
        maxVector.maximizeInPlace(boundingBox.maximumWorld);
      }
    });
    if (!minVector || !maxVector) {
      return {
        min: Vector3.Zero(),
        max: Vector3.Zero()
      };
    }
    return {
      min: minVector,
      max: maxVector
    };
  }
  static Center(meshesOrMinMaxVector) {
    const minMaxVector = meshesOrMinMaxVector instanceof Array ? Mesh.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;
    return Vector3.Center(minMaxVector.min, minMaxVector.max);
  }
  static MergeMeshes(meshes, disposeSource = true, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {
    return runCoroutineSync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, false));
  }
  static MergeMeshesAsync(meshes, disposeSource = true, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {
    return runCoroutineAsync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, true), createYieldingScheduler());
  }
  static *_MergeMeshesCoroutine(meshes, disposeSource = true, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, isAsync) {
    meshes = meshes.filter(Boolean);
    if (meshes.length === 0) {
      return null;
    }
    let index;
    if (!allow32BitsIndices) {
      let totalVertices = 0;
      for (index = 0; index < meshes.length; index++) {
        totalVertices += meshes[index].getTotalVertices();
        if (totalVertices >= 65536) {
          Logger.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices");
          return null;
        }
      }
    }
    if (multiMultiMaterials) {
      subdivideWithSubMeshes = false;
    }
    const materialArray = new Array();
    const materialIndexArray = new Array();
    const indiceArray = new Array();
    const currentOverrideMaterialSideOrientation = meshes[0].overrideMaterialSideOrientation;
    for (index = 0; index < meshes.length; index++) {
      const mesh = meshes[index];
      if (mesh.isAnInstance) {
        Logger.Warn("Cannot merge instance meshes.");
        return null;
      }
      if (currentOverrideMaterialSideOrientation !== mesh.overrideMaterialSideOrientation) {
        Logger.Warn("Cannot merge meshes with different overrideMaterialSideOrientation values.");
        return null;
      }
      if (subdivideWithSubMeshes) {
        indiceArray.push(mesh.getTotalIndices());
      }
      if (multiMultiMaterials) {
        if (mesh.material) {
          const material = mesh.material;
          if (material instanceof MultiMaterial) {
            for (let matIndex = 0; matIndex < material.subMaterials.length; matIndex++) {
              if (materialArray.indexOf(material.subMaterials[matIndex]) < 0) {
                materialArray.push(material.subMaterials[matIndex]);
              }
            }
            for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
              materialIndexArray.push(materialArray.indexOf(material.subMaterials[mesh.subMeshes[subIndex].materialIndex]));
              indiceArray.push(mesh.subMeshes[subIndex].indexCount);
            }
          } else {
            if (materialArray.indexOf(material) < 0) {
              materialArray.push(material);
            }
            for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
              materialIndexArray.push(materialArray.indexOf(material));
              indiceArray.push(mesh.subMeshes[subIndex].indexCount);
            }
          }
        } else {
          for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
            materialIndexArray.push(0);
            indiceArray.push(mesh.subMeshes[subIndex].indexCount);
          }
        }
      }
    }
    const source = meshes[0];
    const getVertexDataFromMesh = (mesh) => {
      const wm = mesh.computeWorldMatrix(true);
      const vertexData2 = VertexData.ExtractFromMesh(mesh, false, false);
      return [vertexData2, wm];
    };
    const [sourceVertexData, sourceTransform] = getVertexDataFromMesh(source);
    if (isAsync) {
      yield;
    }
    const meshVertexDatas = new Array(meshes.length - 1);
    for (let i = 1; i < meshes.length; i++) {
      meshVertexDatas[i - 1] = getVertexDataFromMesh(meshes[i]);
      if (isAsync) {
        yield;
      }
    }
    const mergeCoroutine = sourceVertexData._mergeCoroutine(sourceTransform, meshVertexDatas, allow32BitsIndices, isAsync, !disposeSource);
    let mergeCoroutineStep = mergeCoroutine.next();
    while (!mergeCoroutineStep.done) {
      if (isAsync) {
        yield;
      }
      mergeCoroutineStep = mergeCoroutine.next();
    }
    const vertexData = mergeCoroutineStep.value;
    if (!meshSubclass) {
      meshSubclass = new Mesh(source.name + "_merged", source.getScene());
    }
    const applyToCoroutine = vertexData._applyToCoroutine(meshSubclass, void 0, isAsync);
    let applyToCoroutineStep = applyToCoroutine.next();
    while (!applyToCoroutineStep.done) {
      if (isAsync) {
        yield;
      }
      applyToCoroutineStep = applyToCoroutine.next();
    }
    meshSubclass.checkCollisions = source.checkCollisions;
    meshSubclass.overrideMaterialSideOrientation = source.overrideMaterialSideOrientation;
    if (disposeSource) {
      for (index = 0; index < meshes.length; index++) {
        meshes[index].dispose();
      }
    }
    if (subdivideWithSubMeshes || multiMultiMaterials) {
      meshSubclass.releaseSubMeshes();
      index = 0;
      let offset = 0;
      while (index < indiceArray.length) {
        SubMesh.CreateFromIndices(0, offset, indiceArray[index], meshSubclass, void 0, false);
        offset += indiceArray[index];
        index++;
      }
      for (const subMesh of meshSubclass.subMeshes) {
        subMesh.refreshBoundingInfo();
      }
      meshSubclass.computeWorldMatrix(true);
    }
    if (multiMultiMaterials) {
      const newMultiMaterial = new MultiMaterial(source.name + "_merged", source.getScene());
      newMultiMaterial.subMaterials = materialArray;
      for (let subIndex = 0; subIndex < meshSubclass.subMeshes.length; subIndex++) {
        meshSubclass.subMeshes[subIndex].materialIndex = materialIndexArray[subIndex];
      }
      meshSubclass.material = newMultiMaterial;
    } else {
      meshSubclass.material = source.material;
    }
    return meshSubclass;
  }
  addInstance(instance) {
    instance._indexInSourceMeshInstanceArray = this.instances.length;
    this.instances.push(instance);
  }
  removeInstance(instance) {
    const index = instance._indexInSourceMeshInstanceArray;
    if (index != -1) {
      if (index !== this.instances.length - 1) {
        const last = this.instances[this.instances.length - 1];
        this.instances[index] = last;
        last._indexInSourceMeshInstanceArray = index;
      }
      instance._indexInSourceMeshInstanceArray = -1;
      this.instances.pop();
    }
  }
  _shouldConvertRHS() {
    return this.overrideMaterialSideOrientation === Material.CounterClockWiseSideOrientation;
  }
};
Mesh.FRONTSIDE = VertexData.FRONTSIDE;
Mesh.BACKSIDE = VertexData.BACKSIDE;
Mesh.DOUBLESIDE = VertexData.DOUBLESIDE;
Mesh.DEFAULTSIDE = VertexData.DEFAULTSIDE;
Mesh.NO_CAP = 0;
Mesh.CAP_START = 1;
Mesh.CAP_END = 2;
Mesh.CAP_ALL = 3;
Mesh.NO_FLIP = 0;
Mesh.FLIP_TILE = 1;
Mesh.ROTATE_TILE = 2;
Mesh.FLIP_ROW = 3;
Mesh.ROTATE_ROW = 4;
Mesh.FLIP_N_ROTATE_TILE = 5;
Mesh.FLIP_N_ROTATE_ROW = 6;
Mesh.CENTER = 0;
Mesh.LEFT = 1;
Mesh.RIGHT = 2;
Mesh.TOP = 3;
Mesh.BOTTOM = 4;
Mesh.INSTANCEDMESH_SORT_TRANSPARENT = false;
Mesh._GroundMeshParser = (parsedMesh, scene) => {
  throw _WarnImport("GroundMesh");
};
Mesh._GoldbergMeshParser = (parsedMesh, scene) => {
  throw _WarnImport("GoldbergMesh");
};
Mesh._LinesMeshParser = (parsedMesh, scene) => {
  throw _WarnImport("LinesMesh");
};
RegisterClass("BABYLON.Mesh", Mesh);
Mesh.prototype.setMaterialByID = function(id) {
  return this.setMaterialById(id);
};
Mesh.CreateDisc = Mesh.CreateDisc || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
Mesh.CreateBox = Mesh.CreateBox || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
Mesh.CreateSphere = Mesh.CreateSphere || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
Mesh.CreateCylinder = Mesh.CreateCylinder || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
Mesh.CreateTorusKnot = Mesh.CreateTorusKnot || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
Mesh.CreateTorus = Mesh.CreateTorus || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
Mesh.CreatePlane = Mesh.CreatePlane || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
Mesh.CreateGround = Mesh.CreateGround || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
Mesh.CreateTiledGround = Mesh.CreateTiledGround || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
Mesh.CreateGroundFromHeightMap = Mesh.CreateGroundFromHeightMap || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
Mesh.CreateTube = Mesh.CreateTube || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
Mesh.CreatePolyhedron = Mesh.CreatePolyhedron || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
Mesh.CreateIcoSphere = Mesh.CreateIcoSphere || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
Mesh.CreateDecal = Mesh.CreateDecal || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
Mesh.CreateCapsule = Mesh.CreateCapsule || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
Mesh.ExtendToGoldberg = Mesh.ExtendToGoldberg || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});

// node_modules/@babylonjs/core/Materials/Textures/thinTexture.js
var ThinTexture = class {
  constructor(internalTexture) {
    this._wrapU = 1;
    this._wrapV = 1;
    this.wrapR = 1;
    this.anisotropicFilteringLevel = 4;
    this.delayLoadState = 0;
    this._texture = null;
    this._engine = null;
    this._cachedSize = Size.Zero();
    this._cachedBaseSize = Size.Zero();
    this._initialSamplingMode = 2;
    this._texture = internalTexture;
    if (this._texture) {
      this._engine = this._texture.getEngine();
    }
  }
  get wrapU() {
    return this._wrapU;
  }
  set wrapU(value) {
    this._wrapU = value;
  }
  get wrapV() {
    return this._wrapV;
  }
  set wrapV(value) {
    this._wrapV = value;
  }
  get coordinatesMode() {
    return 0;
  }
  get isCube() {
    if (!this._texture) {
      return false;
    }
    return this._texture.isCube;
  }
  set isCube(value) {
    if (!this._texture) {
      return;
    }
    this._texture.isCube = value;
  }
  get is3D() {
    if (!this._texture) {
      return false;
    }
    return this._texture.is3D;
  }
  set is3D(value) {
    if (!this._texture) {
      return;
    }
    this._texture.is3D = value;
  }
  get is2DArray() {
    if (!this._texture) {
      return false;
    }
    return this._texture.is2DArray;
  }
  set is2DArray(value) {
    if (!this._texture) {
      return;
    }
    this._texture.is2DArray = value;
  }
  getClassName() {
    return "ThinTexture";
  }
  isReady() {
    if (this.delayLoadState === 4) {
      this.delayLoad();
      return false;
    }
    if (this._texture) {
      return this._texture.isReady;
    }
    return false;
  }
  delayLoad() {
  }
  getInternalTexture() {
    return this._texture;
  }
  getSize() {
    if (this._texture) {
      if (this._texture.width) {
        this._cachedSize.width = this._texture.width;
        this._cachedSize.height = this._texture.height;
        return this._cachedSize;
      }
      if (this._texture._size) {
        this._cachedSize.width = this._texture._size;
        this._cachedSize.height = this._texture._size;
        return this._cachedSize;
      }
    }
    return this._cachedSize;
  }
  getBaseSize() {
    if (!this.isReady() || !this._texture) {
      this._cachedBaseSize.width = 0;
      this._cachedBaseSize.height = 0;
      return this._cachedBaseSize;
    }
    if (this._texture._size) {
      this._cachedBaseSize.width = this._texture._size;
      this._cachedBaseSize.height = this._texture._size;
      return this._cachedBaseSize;
    }
    this._cachedBaseSize.width = this._texture.baseWidth;
    this._cachedBaseSize.height = this._texture.baseHeight;
    return this._cachedBaseSize;
  }
  get samplingMode() {
    if (!this._texture) {
      return this._initialSamplingMode;
    }
    return this._texture.samplingMode;
  }
  updateSamplingMode(samplingMode) {
    if (this._texture && this._engine) {
      this._engine.updateTextureSamplingMode(samplingMode, this._texture);
    }
  }
  releaseInternalTexture() {
    if (this._texture) {
      this._texture.dispose();
      this._texture = null;
    }
  }
  dispose() {
    if (this._texture) {
      this.releaseInternalTexture();
      this._engine = null;
    }
  }
};

// node_modules/@babylonjs/core/Materials/Textures/baseTexture.js
var BaseTexture = class extends ThinTexture {
  constructor(sceneOrEngine, internalTexture = null) {
    super(null);
    this.metadata = null;
    this.reservedDataStore = null;
    this._hasAlpha = false;
    this._getAlphaFromRGB = false;
    this.level = 1;
    this._coordinatesIndex = 0;
    this.optimizeUVAllocation = true;
    this._coordinatesMode = 0;
    this.wrapR = 1;
    this.anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;
    this._isCube = false;
    this._gammaSpace = true;
    this.invertZ = false;
    this.lodLevelInAlpha = false;
    this.isRenderTarget = false;
    this._prefiltered = false;
    this._forceSerialize = false;
    this.animations = new Array();
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this._scene = null;
    this._uid = null;
    this._parentContainer = null;
    this._loadingError = false;
    if (sceneOrEngine) {
      if (BaseTexture._IsScene(sceneOrEngine)) {
        this._scene = sceneOrEngine;
      } else {
        this._engine = sceneOrEngine;
      }
    } else {
      this._scene = EngineStore.LastCreatedScene;
    }
    if (this._scene) {
      this.uniqueId = this._scene.getUniqueId();
      this._scene.addTexture(this);
      this._engine = this._scene.getEngine();
    }
    this._texture = internalTexture;
    this._uid = null;
  }
  set hasAlpha(value) {
    if (this._hasAlpha === value) {
      return;
    }
    this._hasAlpha = value;
    if (this._scene) {
      this._scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this);
      });
    }
  }
  get hasAlpha() {
    return this._hasAlpha;
  }
  set getAlphaFromRGB(value) {
    if (this._getAlphaFromRGB === value) {
      return;
    }
    this._getAlphaFromRGB = value;
    if (this._scene) {
      this._scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this);
      });
    }
  }
  get getAlphaFromRGB() {
    return this._getAlphaFromRGB;
  }
  set coordinatesIndex(value) {
    if (this._coordinatesIndex === value) {
      return;
    }
    this._coordinatesIndex = value;
    if (this._scene) {
      this._scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this);
      });
    }
  }
  get coordinatesIndex() {
    return this._coordinatesIndex;
  }
  set coordinatesMode(value) {
    if (this._coordinatesMode === value) {
      return;
    }
    this._coordinatesMode = value;
    if (this._scene) {
      this._scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this);
      });
    }
  }
  get coordinatesMode() {
    return this._coordinatesMode;
  }
  get wrapU() {
    return this._wrapU;
  }
  set wrapU(value) {
    this._wrapU = value;
  }
  get wrapV() {
    return this._wrapV;
  }
  set wrapV(value) {
    this._wrapV = value;
  }
  get isCube() {
    if (!this._texture) {
      return this._isCube;
    }
    return this._texture.isCube;
  }
  set isCube(value) {
    if (!this._texture) {
      this._isCube = value;
    } else {
      this._texture.isCube = value;
    }
  }
  get is3D() {
    if (!this._texture) {
      return false;
    }
    return this._texture.is3D;
  }
  set is3D(value) {
    if (!this._texture) {
      return;
    }
    this._texture.is3D = value;
  }
  get is2DArray() {
    if (!this._texture) {
      return false;
    }
    return this._texture.is2DArray;
  }
  set is2DArray(value) {
    if (!this._texture) {
      return;
    }
    this._texture.is2DArray = value;
  }
  get gammaSpace() {
    if (!this._texture) {
      return this._gammaSpace;
    } else {
      if (this._texture._gammaSpace === null) {
        this._texture._gammaSpace = this._gammaSpace;
      }
    }
    return this._texture._gammaSpace && !this._texture._useSRGBBuffer;
  }
  set gammaSpace(gamma) {
    if (!this._texture) {
      if (this._gammaSpace === gamma) {
        return;
      }
      this._gammaSpace = gamma;
    } else {
      if (this._texture._gammaSpace === gamma) {
        return;
      }
      this._texture._gammaSpace = gamma;
    }
    this._markAllSubMeshesAsTexturesDirty();
  }
  get isRGBD() {
    return this._texture != null && this._texture._isRGBD;
  }
  set isRGBD(value) {
    if (this._texture) {
      this._texture._isRGBD = value;
    }
  }
  get noMipmap() {
    return false;
  }
  get lodGenerationOffset() {
    if (this._texture) {
      return this._texture._lodGenerationOffset;
    }
    return 0;
  }
  set lodGenerationOffset(value) {
    if (this._texture) {
      this._texture._lodGenerationOffset = value;
    }
  }
  get lodGenerationScale() {
    if (this._texture) {
      return this._texture._lodGenerationScale;
    }
    return 0;
  }
  set lodGenerationScale(value) {
    if (this._texture) {
      this._texture._lodGenerationScale = value;
    }
  }
  get linearSpecularLOD() {
    if (this._texture) {
      return this._texture._linearSpecularLOD;
    }
    return false;
  }
  set linearSpecularLOD(value) {
    if (this._texture) {
      this._texture._linearSpecularLOD = value;
    }
  }
  get irradianceTexture() {
    if (this._texture) {
      return this._texture._irradianceTexture;
    }
    return null;
  }
  set irradianceTexture(value) {
    if (this._texture) {
      this._texture._irradianceTexture = value;
    }
  }
  get uid() {
    if (!this._uid) {
      this._uid = RandomGUID();
    }
    return this._uid;
  }
  toString() {
    return this.name;
  }
  getClassName() {
    return "BaseTexture";
  }
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  get isBlocking() {
    return true;
  }
  get loadingError() {
    return this._loadingError;
  }
  get errorObject() {
    return this._errorObject;
  }
  getScene() {
    return this._scene;
  }
  _getEngine() {
    return this._engine;
  }
  checkTransformsAreIdentical(texture) {
    return texture !== null;
  }
  getTextureMatrix() {
    return Matrix.IdentityReadOnly;
  }
  getReflectionTextureMatrix() {
    return Matrix.IdentityReadOnly;
  }
  isReadyOrNotBlocking() {
    return !this.isBlocking || this.isReady() || this.loadingError;
  }
  scale(ratio) {
  }
  get canRescale() {
    return false;
  }
  _getFromCache(url, noMipmap, sampling, invertY, useSRGBBuffer, isCube) {
    const engine = this._getEngine();
    if (!engine) {
      return null;
    }
    const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);
    const texturesCache = engine.getLoadedTexturesCache();
    for (let index = 0; index < texturesCache.length; index++) {
      const texturesCacheEntry = texturesCache[index];
      if (useSRGBBuffer === void 0 || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {
        if (invertY === void 0 || invertY === texturesCacheEntry.invertY) {
          if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {
            if (!sampling || sampling === texturesCacheEntry.samplingMode) {
              if (isCube === void 0 || isCube === texturesCacheEntry.isCube) {
                texturesCacheEntry.incrementReferences();
                return texturesCacheEntry;
              }
            }
          }
        }
      }
    }
    return null;
  }
  _rebuild() {
  }
  clone() {
    return null;
  }
  get textureType() {
    if (!this._texture) {
      return 0;
    }
    return this._texture.type !== void 0 ? this._texture.type : 0;
  }
  get textureFormat() {
    if (!this._texture) {
      return 5;
    }
    return this._texture.format !== void 0 ? this._texture.format : 5;
  }
  _markAllSubMeshesAsTexturesDirty() {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    scene.markAllMaterialsAsDirty(1);
  }
  readPixels(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0, width = Number.MAX_VALUE, height = Number.MAX_VALUE) {
    if (!this._texture) {
      return null;
    }
    const engine = this._getEngine();
    if (!engine) {
      return null;
    }
    const size = this.getSize();
    let maxWidth = size.width;
    let maxHeight = size.height;
    if (level !== 0) {
      maxWidth = maxWidth / Math.pow(2, level);
      maxHeight = maxHeight / Math.pow(2, level);
      maxWidth = Math.round(maxWidth);
      maxHeight = Math.round(maxHeight);
    }
    width = Math.min(maxWidth, width);
    height = Math.min(maxHeight, height);
    try {
      if (this._texture.isCube) {
        return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);
      }
      return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);
    } catch (e) {
      return null;
    }
  }
  _readPixelsSync(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false) {
    if (!this._texture) {
      return null;
    }
    const size = this.getSize();
    let width = size.width;
    let height = size.height;
    const engine = this._getEngine();
    if (!engine) {
      return null;
    }
    if (level != 0) {
      width = width / Math.pow(2, level);
      height = height / Math.pow(2, level);
      width = Math.round(width);
      height = Math.round(height);
    }
    try {
      if (this._texture.isCube) {
        return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);
      }
      return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);
    } catch (e) {
      return null;
    }
  }
  get _lodTextureHigh() {
    if (this._texture) {
      return this._texture._lodTextureHigh;
    }
    return null;
  }
  get _lodTextureMid() {
    if (this._texture) {
      return this._texture._lodTextureMid;
    }
    return null;
  }
  get _lodTextureLow() {
    if (this._texture) {
      return this._texture._lodTextureLow;
    }
    return null;
  }
  dispose() {
    if (this._scene) {
      if (this._scene.stopAnimation) {
        this._scene.stopAnimation(this);
      }
      this._scene.removePendingData(this);
      const index = this._scene.textures.indexOf(this);
      if (index >= 0) {
        this._scene.textures.splice(index, 1);
      }
      this._scene.onTextureRemovedObservable.notifyObservers(this);
      this._scene = null;
      if (this._parentContainer) {
        const index2 = this._parentContainer.textures.indexOf(this);
        if (index2 > -1) {
          this._parentContainer.textures.splice(index2, 1);
        }
        this._parentContainer = null;
      }
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.metadata = null;
    super.dispose();
  }
  serialize(allowEmptyName = false) {
    if (!this.name && !allowEmptyName) {
      return null;
    }
    const serializationObject = SerializationHelper.Serialize(this);
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    return serializationObject;
  }
  static WhenAllReady(textures, callback) {
    let numRemaining = textures.length;
    if (numRemaining === 0) {
      callback();
      return;
    }
    for (let i = 0; i < textures.length; i++) {
      const texture = textures[i];
      if (texture.isReady()) {
        if (--numRemaining === 0) {
          callback();
        }
      } else {
        const onLoadObservable = texture.onLoadObservable;
        if (onLoadObservable) {
          onLoadObservable.addOnce(() => {
            if (--numRemaining === 0) {
              callback();
            }
          });
        } else {
          if (--numRemaining === 0) {
            callback();
          }
        }
      }
    }
  }
  static _IsScene(sceneOrEngine) {
    return sceneOrEngine.getClassName() === "Scene";
  }
};
BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;
__decorate([
  serialize()
], BaseTexture.prototype, "uniqueId", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "name", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "metadata", void 0);
__decorate([
  serialize("hasAlpha")
], BaseTexture.prototype, "_hasAlpha", void 0);
__decorate([
  serialize("getAlphaFromRGB")
], BaseTexture.prototype, "_getAlphaFromRGB", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "level", void 0);
__decorate([
  serialize("coordinatesIndex")
], BaseTexture.prototype, "_coordinatesIndex", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "optimizeUVAllocation", void 0);
__decorate([
  serialize("coordinatesMode")
], BaseTexture.prototype, "_coordinatesMode", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "wrapU", null);
__decorate([
  serialize()
], BaseTexture.prototype, "wrapV", null);
__decorate([
  serialize()
], BaseTexture.prototype, "wrapR", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "anisotropicFilteringLevel", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "isCube", null);
__decorate([
  serialize()
], BaseTexture.prototype, "is3D", null);
__decorate([
  serialize()
], BaseTexture.prototype, "is2DArray", null);
__decorate([
  serialize()
], BaseTexture.prototype, "gammaSpace", null);
__decorate([
  serialize()
], BaseTexture.prototype, "invertZ", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "lodLevelInAlpha", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "lodGenerationOffset", null);
__decorate([
  serialize()
], BaseTexture.prototype, "lodGenerationScale", null);
__decorate([
  serialize()
], BaseTexture.prototype, "linearSpecularLOD", null);
__decorate([
  serializeAsTexture()
], BaseTexture.prototype, "irradianceTexture", null);
__decorate([
  serialize()
], BaseTexture.prototype, "isRenderTarget", void 0);

// node_modules/@babylonjs/core/Misc/copyTools.js
function GenerateBase64StringFromPixelData(pixels, size, invertY = false) {
  const width = size.width;
  const height = size.height;
  if (pixels instanceof Float32Array) {
    let len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;
    const npixels = new Uint8Array(len);
    while (--len >= 0) {
      let val = pixels[len];
      if (val < 0) {
        val = 0;
      } else if (val > 1) {
        val = 1;
      }
      npixels[len] = val * 255;
    }
    pixels = npixels;
  }
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    return null;
  }
  const imageData = ctx.createImageData(width, height);
  const castData = imageData.data;
  castData.set(pixels);
  ctx.putImageData(imageData, 0, 0);
  if (invertY) {
    const canvas2 = document.createElement("canvas");
    canvas2.width = width;
    canvas2.height = height;
    const ctx2 = canvas2.getContext("2d");
    if (!ctx2) {
      return null;
    }
    ctx2.translate(0, height);
    ctx2.scale(1, -1);
    ctx2.drawImage(canvas, 0, 0);
    return canvas2.toDataURL("image/png");
  }
  return canvas.toDataURL("image/png");
}
function GenerateBase64StringFromTexture(texture, faceIndex = 0, level = 0) {
  const internalTexture = texture.getInternalTexture();
  if (!internalTexture) {
    return null;
  }
  const pixels = texture._readPixelsSync(faceIndex, level);
  if (!pixels) {
    return null;
  }
  return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);
}
async function GenerateBase64StringFromTextureAsync(texture, faceIndex = 0, level = 0) {
  const internalTexture = texture.getInternalTexture();
  if (!internalTexture) {
    return null;
  }
  const pixels = await texture.readPixels(faceIndex, level);
  if (!pixels) {
    return null;
  }
  return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);
}
var CopyTools = {
  GenerateBase64StringFromPixelData,
  GenerateBase64StringFromTexture,
  GenerateBase64StringFromTextureAsync
};

// node_modules/@babylonjs/core/Materials/Textures/texture.js
var Texture = class extends BaseTexture {
  constructor(url, sceneOrEngine, noMipmapOrOptions, invertY, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, onLoad = null, onError = null, buffer = null, deleteBuffer = false, format, mimeType, loaderOptions, creationFlags, forcedExtension) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    super(sceneOrEngine);
    this.url = null;
    this.uOffset = 0;
    this.vOffset = 0;
    this.uScale = 1;
    this.vScale = 1;
    this.uAng = 0;
    this.vAng = 0;
    this.wAng = 0;
    this.uRotationCenter = 0.5;
    this.vRotationCenter = 0.5;
    this.wRotationCenter = 0.5;
    this.homogeneousRotationInUVTransform = false;
    this.inspectableCustomProperties = null;
    this._noMipmap = false;
    this._invertY = false;
    this._rowGenerationMatrix = null;
    this._cachedTextureMatrix = null;
    this._projectionModeMatrix = null;
    this._t0 = null;
    this._t1 = null;
    this._t2 = null;
    this._cachedUOffset = -1;
    this._cachedVOffset = -1;
    this._cachedUScale = 0;
    this._cachedVScale = 0;
    this._cachedUAng = -1;
    this._cachedVAng = -1;
    this._cachedWAng = -1;
    this._cachedReflectionProjectionMatrixId = -1;
    this._cachedURotationCenter = -1;
    this._cachedVRotationCenter = -1;
    this._cachedWRotationCenter = -1;
    this._cachedHomogeneousRotationInUVTransform = false;
    this._cachedReflectionTextureMatrix = null;
    this._cachedReflectionUOffset = -1;
    this._cachedReflectionVOffset = -1;
    this._cachedReflectionUScale = 0;
    this._cachedReflectionVScale = 0;
    this._cachedReflectionCoordinatesMode = -1;
    this._buffer = null;
    this._deleteBuffer = false;
    this._format = null;
    this._delayedOnLoad = null;
    this._delayedOnError = null;
    this.onLoadObservable = new Observable();
    this._isBlocking = true;
    this.name = url || "";
    this.url = url;
    let noMipmap;
    let useSRGBBuffer = false;
    let internalTexture = null;
    if (typeof noMipmapOrOptions === "object" && noMipmapOrOptions !== null) {
      noMipmap = (_a = noMipmapOrOptions.noMipmap) !== null && _a !== void 0 ? _a : false;
      invertY = (_b = noMipmapOrOptions.invertY) !== null && _b !== void 0 ? _b : CompatibilityOptions.UseOpenGLOrientationForUV ? false : true;
      samplingMode = (_c = noMipmapOrOptions.samplingMode) !== null && _c !== void 0 ? _c : Texture.TRILINEAR_SAMPLINGMODE;
      onLoad = (_d = noMipmapOrOptions.onLoad) !== null && _d !== void 0 ? _d : null;
      onError = (_e = noMipmapOrOptions.onError) !== null && _e !== void 0 ? _e : null;
      buffer = (_f = noMipmapOrOptions.buffer) !== null && _f !== void 0 ? _f : null;
      deleteBuffer = (_g = noMipmapOrOptions.deleteBuffer) !== null && _g !== void 0 ? _g : false;
      format = noMipmapOrOptions.format;
      mimeType = noMipmapOrOptions.mimeType;
      loaderOptions = noMipmapOrOptions.loaderOptions;
      creationFlags = noMipmapOrOptions.creationFlags;
      useSRGBBuffer = (_h = noMipmapOrOptions.useSRGBBuffer) !== null && _h !== void 0 ? _h : false;
      internalTexture = (_j = noMipmapOrOptions.internalTexture) !== null && _j !== void 0 ? _j : null;
    } else {
      noMipmap = !!noMipmapOrOptions;
    }
    this._noMipmap = noMipmap;
    this._invertY = invertY === void 0 ? CompatibilityOptions.UseOpenGLOrientationForUV ? false : true : invertY;
    this._initialSamplingMode = samplingMode;
    this._buffer = buffer;
    this._deleteBuffer = deleteBuffer;
    this._mimeType = mimeType;
    this._loaderOptions = loaderOptions;
    this._creationFlags = creationFlags;
    this._useSRGBBuffer = useSRGBBuffer;
    this._forcedExtension = forcedExtension;
    if (format) {
      this._format = format;
    }
    const scene = this.getScene();
    const engine = this._getEngine();
    if (!engine) {
      return;
    }
    engine.onBeforeTextureInitObservable.notifyObservers(this);
    const load = () => {
      if (this._texture) {
        if (this._texture._invertVScale) {
          this.vScale *= -1;
          this.vOffset += 1;
        }
        if (this._texture._cachedWrapU !== null) {
          this.wrapU = this._texture._cachedWrapU;
          this._texture._cachedWrapU = null;
        }
        if (this._texture._cachedWrapV !== null) {
          this.wrapV = this._texture._cachedWrapV;
          this._texture._cachedWrapV = null;
        }
        if (this._texture._cachedWrapR !== null) {
          this.wrapR = this._texture._cachedWrapR;
          this._texture._cachedWrapR = null;
        }
      }
      if (this.onLoadObservable.hasObservers()) {
        this.onLoadObservable.notifyObservers(this);
      }
      if (onLoad) {
        onLoad();
      }
      if (!this.isBlocking && scene) {
        scene.resetCachedMaterial();
      }
    };
    const errorHandler = (message, exception) => {
      this._loadingError = true;
      this._errorObject = { message, exception };
      if (onError) {
        onError(message, exception);
      }
      Texture.OnTextureLoadErrorObservable.notifyObservers(this);
    };
    if (!this.url && !internalTexture) {
      this._delayedOnLoad = load;
      this._delayedOnError = errorHandler;
      return;
    }
    this._texture = internalTexture !== null && internalTexture !== void 0 ? internalTexture : this._getFromCache(this.url, noMipmap, samplingMode, this._invertY, useSRGBBuffer);
    if (!this._texture) {
      if (!scene || !scene.useDelayedTextureLoading) {
        try {
          this._texture = engine.createTexture(this.url, noMipmap, this._invertY, scene, samplingMode, load, errorHandler, this._buffer, void 0, this._format, this._forcedExtension, mimeType, loaderOptions, creationFlags, useSRGBBuffer);
        } catch (e) {
          errorHandler("error loading", e);
          throw e;
        }
        if (deleteBuffer) {
          this._buffer = null;
        }
      } else {
        this.delayLoadState = 4;
        this._delayedOnLoad = load;
        this._delayedOnError = errorHandler;
      }
    } else {
      if (this._texture.isReady) {
        TimingTools.SetImmediate(() => load());
      } else {
        const loadObserver = this._texture.onLoadedObservable.add(load);
        this._texture.onErrorObservable.add((e) => {
          var _a2;
          errorHandler(e.message, e.exception);
          (_a2 = this._texture) === null || _a2 === void 0 ? void 0 : _a2.onLoadedObservable.remove(loadObserver);
        });
      }
    }
  }
  get noMipmap() {
    return this._noMipmap;
  }
  get mimeType() {
    return this._mimeType;
  }
  set isBlocking(value) {
    this._isBlocking = value;
  }
  get isBlocking() {
    return this._isBlocking;
  }
  get invertY() {
    return this._invertY;
  }
  updateURL(url, buffer = null, onLoad, forcedExtension) {
    if (this.url) {
      this.releaseInternalTexture();
      this.getScene().markAllMaterialsAsDirty(1);
    }
    if (!this.name || this.name.startsWith("data:")) {
      this.name = url;
    }
    this.url = url;
    this._buffer = buffer;
    this._forcedExtension = forcedExtension;
    this.delayLoadState = 4;
    if (onLoad) {
      this._delayedOnLoad = onLoad;
    }
    this.delayLoad();
  }
  delayLoad() {
    if (this.delayLoadState !== 4) {
      return;
    }
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    this.delayLoadState = 1;
    this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer);
    if (!this._texture) {
      this._texture = scene.getEngine().createTexture(this.url, this._noMipmap, this._invertY, scene, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, this._forcedExtension, this._mimeType, this._loaderOptions, this._creationFlags, this._useSRGBBuffer);
      if (this._deleteBuffer) {
        this._buffer = null;
      }
    } else {
      if (this._delayedOnLoad) {
        if (this._texture.isReady) {
          TimingTools.SetImmediate(this._delayedOnLoad);
        } else {
          this._texture.onLoadedObservable.add(this._delayedOnLoad);
        }
      }
    }
    this._delayedOnLoad = null;
    this._delayedOnError = null;
  }
  _prepareRowForTextureGeneration(x, y, z, t) {
    x *= this._cachedUScale;
    y *= this._cachedVScale;
    x -= this.uRotationCenter * this._cachedUScale;
    y -= this.vRotationCenter * this._cachedVScale;
    z -= this.wRotationCenter;
    Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix, t);
    t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;
    t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;
    t.z += this.wRotationCenter;
  }
  checkTransformsAreIdentical(texture) {
    return texture !== null && this.uOffset === texture.uOffset && this.vOffset === texture.vOffset && this.uScale === texture.uScale && this.vScale === texture.vScale && this.uAng === texture.uAng && this.vAng === texture.vAng && this.wAng === texture.wAng;
  }
  getTextureMatrix(uBase = 1) {
    if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale * uBase === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng && this.uRotationCenter === this._cachedURotationCenter && this.vRotationCenter === this._cachedVRotationCenter && this.wRotationCenter === this._cachedWRotationCenter && this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform) {
      return this._cachedTextureMatrix;
    }
    this._cachedUOffset = this.uOffset;
    this._cachedVOffset = this.vOffset;
    this._cachedUScale = this.uScale * uBase;
    this._cachedVScale = this.vScale;
    this._cachedUAng = this.uAng;
    this._cachedVAng = this.vAng;
    this._cachedWAng = this.wAng;
    this._cachedURotationCenter = this.uRotationCenter;
    this._cachedVRotationCenter = this.vRotationCenter;
    this._cachedWRotationCenter = this.wRotationCenter;
    this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;
    if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {
      this._cachedTextureMatrix = Matrix.Zero();
      this._rowGenerationMatrix = new Matrix();
      this._t0 = Vector3.Zero();
      this._t1 = Vector3.Zero();
      this._t2 = Vector3.Zero();
    }
    Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix);
    if (this.homogeneousRotationInUVTransform) {
      Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);
      Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);
      Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);
      Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);
      TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix);
      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);
      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);
      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix);
      this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);
    } else {
      this._prepareRowForTextureGeneration(0, 0, 0, this._t0);
      this._prepareRowForTextureGeneration(1, 0, 0, this._t1);
      this._prepareRowForTextureGeneration(0, 1, 0, this._t2);
      this._t1.subtractInPlace(this._t0);
      this._t2.subtractInPlace(this._t0);
      Matrix.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0, this._t2.x, this._t2.y, this._t2.z, 0, this._t0.x, this._t0.y, this._t0.z, 0, 0, 0, 0, 1, this._cachedTextureMatrix);
    }
    const scene = this.getScene();
    if (!scene) {
      return this._cachedTextureMatrix;
    }
    if (this.optimizeUVAllocation) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this);
      });
    }
    return this._cachedTextureMatrix;
  }
  getReflectionTextureMatrix() {
    const scene = this.getScene();
    if (!scene) {
      return this._cachedReflectionTextureMatrix;
    }
    if (this.uOffset === this._cachedReflectionUOffset && this.vOffset === this._cachedReflectionVOffset && this.uScale === this._cachedReflectionUScale && this.vScale === this._cachedReflectionVScale && this.coordinatesMode === this._cachedReflectionCoordinatesMode) {
      if (this.coordinatesMode === Texture.PROJECTION_MODE) {
        if (this._cachedReflectionProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {
          return this._cachedReflectionTextureMatrix;
        }
      } else {
        return this._cachedReflectionTextureMatrix;
      }
    }
    if (!this._cachedReflectionTextureMatrix) {
      this._cachedReflectionTextureMatrix = Matrix.Zero();
    }
    if (!this._projectionModeMatrix) {
      this._projectionModeMatrix = Matrix.Zero();
    }
    const flagMaterialsAsTextureDirty = this._cachedReflectionCoordinatesMode !== this.coordinatesMode;
    this._cachedReflectionUOffset = this.uOffset;
    this._cachedReflectionVOffset = this.vOffset;
    this._cachedReflectionUScale = this.uScale;
    this._cachedReflectionVScale = this.vScale;
    this._cachedReflectionCoordinatesMode = this.coordinatesMode;
    switch (this.coordinatesMode) {
      case Texture.PLANAR_MODE: {
        Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);
        this._cachedReflectionTextureMatrix[0] = this.uScale;
        this._cachedReflectionTextureMatrix[5] = this.vScale;
        this._cachedReflectionTextureMatrix[12] = this.uOffset;
        this._cachedReflectionTextureMatrix[13] = this.vOffset;
        break;
      }
      case Texture.PROJECTION_MODE: {
        Matrix.FromValuesToRef(0.5, 0, 0, 0, 0, -0.5, 0, 0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, this._projectionModeMatrix);
        const projectionMatrix = scene.getProjectionMatrix();
        this._cachedReflectionProjectionMatrixId = projectionMatrix.updateFlag;
        projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedReflectionTextureMatrix);
        break;
      }
      default:
        Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);
        break;
    }
    if (flagMaterialsAsTextureDirty) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.getActiveTextures().indexOf(this) !== -1;
      });
    }
    return this._cachedReflectionTextureMatrix;
  }
  clone() {
    const options = {
      noMipmap: this._noMipmap,
      invertY: this._invertY,
      samplingMode: this.samplingMode,
      onLoad: void 0,
      onError: void 0,
      buffer: this._texture ? this._texture._buffer : void 0,
      deleteBuffer: this._deleteBuffer,
      format: this.textureFormat,
      mimeType: this.mimeType,
      loaderOptions: this._loaderOptions,
      creationFlags: this._creationFlags,
      useSRGBBuffer: this._useSRGBBuffer
    };
    return SerializationHelper.Clone(() => {
      return new Texture(this._texture ? this._texture.url : null, this.getScene(), options);
    }, this);
  }
  serialize() {
    var _a, _b;
    const savedName = this.name;
    if (!Texture.SerializeBuffers) {
      if (this.name.startsWith("data:")) {
        this.name = "";
      }
    }
    if (this.name.startsWith("data:") && this.url === this.name) {
      this.url = "";
    }
    const serializationObject = super.serialize(Texture._SerializeInternalTextureUniqueId);
    if (!serializationObject) {
      return null;
    }
    if (Texture.SerializeBuffers || Texture.ForceSerializeBuffers) {
      if (typeof this._buffer === "string" && this._buffer.substr(0, 5) === "data:") {
        serializationObject.base64String = this._buffer;
        serializationObject.name = serializationObject.name.replace("data:", "");
      } else if (this.url && this.url.startsWith("data:") && this._buffer instanceof Uint8Array) {
        serializationObject.base64String = "data:image/png;base64," + EncodeArrayBufferToBase64(this._buffer);
      } else if (Texture.ForceSerializeBuffers || this.url && this.url.startsWith("blob:") || this._forceSerialize) {
        serializationObject.base64String = !this._engine || this._engine._features.supportSyncTextureRead ? GenerateBase64StringFromTexture(this) : GenerateBase64StringFromTextureAsync(this);
      }
    }
    serializationObject.invertY = this._invertY;
    serializationObject.samplingMode = this.samplingMode;
    serializationObject._creationFlags = this._creationFlags;
    serializationObject._useSRGBBuffer = this._useSRGBBuffer;
    if (Texture._SerializeInternalTextureUniqueId) {
      serializationObject.internalTextureUniqueId = (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.uniqueId) !== null && _b !== void 0 ? _b : void 0;
    }
    this.name = savedName;
    return serializationObject;
  }
  getClassName() {
    return "Texture";
  }
  dispose() {
    super.dispose();
    this.onLoadObservable.clear();
    this._delayedOnLoad = null;
    this._delayedOnError = null;
  }
  static Parse(parsedTexture, scene, rootUrl) {
    if (parsedTexture.customType) {
      const customTexture = InstantiationTools.Instantiate(parsedTexture.customType);
      const parsedCustomTexture = customTexture.Parse(parsedTexture, scene, rootUrl);
      if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {
        if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {
          parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);
        }
      }
      return parsedCustomTexture;
    }
    if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {
      return Texture._CubeTextureParser(parsedTexture, scene, rootUrl);
    }
    const hasInternalTextureUniqueId = parsedTexture.internalTextureUniqueId !== void 0;
    if (!parsedTexture.name && !parsedTexture.isRenderTarget && !hasInternalTextureUniqueId) {
      return null;
    }
    let internalTexture;
    if (hasInternalTextureUniqueId) {
      const cache = scene.getEngine().getLoadedTexturesCache();
      for (const texture2 of cache) {
        if (texture2.uniqueId === parsedTexture.internalTextureUniqueId) {
          internalTexture = texture2;
          break;
        }
      }
    }
    const onLoaded = (texture2) => {
      var _a;
      if (texture2 && texture2._texture) {
        texture2._texture._cachedWrapU = null;
        texture2._texture._cachedWrapV = null;
        texture2._texture._cachedWrapR = null;
      }
      if (parsedTexture.samplingMode) {
        const sampling = parsedTexture.samplingMode;
        if (texture2 && texture2.samplingMode !== sampling) {
          texture2.updateSamplingMode(sampling);
        }
      }
      if (texture2 && parsedTexture.animations) {
        for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {
          const parsedAnimation = parsedTexture.animations[animationIndex];
          const internalClass = GetClass("BABYLON.Animation");
          if (internalClass) {
            texture2.animations.push(internalClass.Parse(parsedAnimation));
          }
        }
      }
      if (hasInternalTextureUniqueId && !internalTexture) {
        (_a = texture2 === null || texture2 === void 0 ? void 0 : texture2._texture) === null || _a === void 0 ? void 0 : _a._setUniqueId(parsedTexture.internalTextureUniqueId);
      }
    };
    const texture = SerializationHelper.Parse(() => {
      var _a, _b, _c;
      let generateMipMaps = true;
      if (parsedTexture.noMipmap) {
        generateMipMaps = false;
      }
      if (parsedTexture.mirrorPlane) {
        const mirrorTexture = Texture._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);
        mirrorTexture._waitingRenderList = parsedTexture.renderList;
        mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);
        onLoaded(mirrorTexture);
        return mirrorTexture;
      } else if (parsedTexture.isRenderTarget) {
        let renderTargetTexture = null;
        if (parsedTexture.isCube) {
          if (scene.reflectionProbes) {
            for (let index = 0; index < scene.reflectionProbes.length; index++) {
              const probe = scene.reflectionProbes[index];
              if (probe.name === parsedTexture.name) {
                return probe.cubeTexture;
              }
            }
          }
        } else {
          renderTargetTexture = Texture._CreateRenderTargetTexture(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps, (_a = parsedTexture._creationFlags) !== null && _a !== void 0 ? _a : 0);
          renderTargetTexture._waitingRenderList = parsedTexture.renderList;
        }
        onLoaded(renderTargetTexture);
        return renderTargetTexture;
      } else {
        let texture2;
        if (parsedTexture.base64String && !internalTexture) {
          texture2 = Texture.CreateFromBase64String(parsedTexture.base64String, parsedTexture.base64String, scene, !generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, () => {
            onLoaded(texture2);
          }, (_b = parsedTexture._creationFlags) !== null && _b !== void 0 ? _b : 0, (_c = parsedTexture._useSRGBBuffer) !== null && _c !== void 0 ? _c : false);
          texture2.name = parsedTexture.name;
        } else {
          let url;
          if (parsedTexture.name && parsedTexture.name.indexOf("://") > 0) {
            url = parsedTexture.name;
          } else {
            url = rootUrl + parsedTexture.name;
          }
          if (parsedTexture.url && (parsedTexture.url.startsWith("data:") || Texture.UseSerializedUrlIfAny)) {
            url = parsedTexture.url;
          }
          const options = {
            noMipmap: !generateMipMaps,
            invertY: parsedTexture.invertY,
            samplingMode: parsedTexture.samplingMode,
            onLoad: () => {
              onLoaded(texture2);
            },
            internalTexture
          };
          texture2 = new Texture(url, scene, options);
        }
        return texture2;
      }
    }, parsedTexture, scene);
    return texture;
  }
  static CreateFromBase64String(data, name63, scene, noMipmapOrOptions, invertY, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, onLoad = null, onError = null, format = 5, creationFlags) {
    return new Texture("data:" + name63, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, data, false, format, void 0, void 0, creationFlags);
  }
  static LoadFromDataString(name63, buffer, scene, deleteBuffer = false, noMipmapOrOptions, invertY = true, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, onLoad = null, onError = null, format = 5, creationFlags) {
    if (name63.substr(0, 5) !== "data:") {
      name63 = "data:" + name63;
    }
    return new Texture(name63, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, void 0, void 0, creationFlags);
  }
};
Texture.SerializeBuffers = true;
Texture.ForceSerializeBuffers = false;
Texture.OnTextureLoadErrorObservable = new Observable();
Texture._SerializeInternalTextureUniqueId = false;
Texture._CubeTextureParser = (jsonTexture, scene, rootUrl) => {
  throw _WarnImport("CubeTexture");
};
Texture._CreateMirror = (name63, renderTargetSize, scene, generateMipMaps) => {
  throw _WarnImport("MirrorTexture");
};
Texture._CreateRenderTargetTexture = (name63, renderTargetSize, scene, generateMipMaps, creationFlags) => {
  throw _WarnImport("RenderTargetTexture");
};
Texture.NEAREST_SAMPLINGMODE = 1;
Texture.NEAREST_NEAREST_MIPLINEAR = 8;
Texture.BILINEAR_SAMPLINGMODE = 2;
Texture.LINEAR_LINEAR_MIPNEAREST = 11;
Texture.TRILINEAR_SAMPLINGMODE = 3;
Texture.LINEAR_LINEAR_MIPLINEAR = 3;
Texture.NEAREST_NEAREST_MIPNEAREST = 4;
Texture.NEAREST_LINEAR_MIPNEAREST = 5;
Texture.NEAREST_LINEAR_MIPLINEAR = 6;
Texture.NEAREST_LINEAR = 7;
Texture.NEAREST_NEAREST = 1;
Texture.LINEAR_NEAREST_MIPNEAREST = 9;
Texture.LINEAR_NEAREST_MIPLINEAR = 10;
Texture.LINEAR_LINEAR = 2;
Texture.LINEAR_NEAREST = 12;
Texture.EXPLICIT_MODE = 0;
Texture.SPHERICAL_MODE = 1;
Texture.PLANAR_MODE = 2;
Texture.CUBIC_MODE = 3;
Texture.PROJECTION_MODE = 4;
Texture.SKYBOX_MODE = 5;
Texture.INVCUBIC_MODE = 6;
Texture.EQUIRECTANGULAR_MODE = 7;
Texture.FIXED_EQUIRECTANGULAR_MODE = 8;
Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
Texture.CLAMP_ADDRESSMODE = 0;
Texture.WRAP_ADDRESSMODE = 1;
Texture.MIRROR_ADDRESSMODE = 2;
Texture.UseSerializedUrlIfAny = false;
__decorate([
  serialize()
], Texture.prototype, "url", void 0);
__decorate([
  serialize()
], Texture.prototype, "uOffset", void 0);
__decorate([
  serialize()
], Texture.prototype, "vOffset", void 0);
__decorate([
  serialize()
], Texture.prototype, "uScale", void 0);
__decorate([
  serialize()
], Texture.prototype, "vScale", void 0);
__decorate([
  serialize()
], Texture.prototype, "uAng", void 0);
__decorate([
  serialize()
], Texture.prototype, "vAng", void 0);
__decorate([
  serialize()
], Texture.prototype, "wAng", void 0);
__decorate([
  serialize()
], Texture.prototype, "uRotationCenter", void 0);
__decorate([
  serialize()
], Texture.prototype, "vRotationCenter", void 0);
__decorate([
  serialize()
], Texture.prototype, "wRotationCenter", void 0);
__decorate([
  serialize()
], Texture.prototype, "homogeneousRotationInUVTransform", void 0);
__decorate([
  serialize()
], Texture.prototype, "isBlocking", null);
RegisterClass("BABYLON.Texture", Texture);
SerializationHelper._TextureParser = Texture.Parse;

// node_modules/@babylonjs/core/Loading/sceneLoader.js
var SceneLoaderAnimationGroupLoadingMode;
(function(SceneLoaderAnimationGroupLoadingMode2) {
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Clean"] = 0] = "Clean";
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Stop"] = 1] = "Stop";
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Sync"] = 2] = "Sync";
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["NoSync"] = 3] = "NoSync";
})(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));
var SceneLoader = class {
  static get ForceFullSceneLoadingForIncremental() {
    return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;
  }
  static set ForceFullSceneLoadingForIncremental(value) {
    SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;
  }
  static get ShowLoadingScreen() {
    return SceneLoaderFlags.ShowLoadingScreen;
  }
  static set ShowLoadingScreen(value) {
    SceneLoaderFlags.ShowLoadingScreen = value;
  }
  static get loggingLevel() {
    return SceneLoaderFlags.loggingLevel;
  }
  static set loggingLevel(value) {
    SceneLoaderFlags.loggingLevel = value;
  }
  static get CleanBoneMatrixWeights() {
    return SceneLoaderFlags.CleanBoneMatrixWeights;
  }
  static set CleanBoneMatrixWeights(value) {
    SceneLoaderFlags.CleanBoneMatrixWeights = value;
  }
  static GetDefaultPlugin() {
    return SceneLoader._RegisteredPlugins[".babylon"];
  }
  static _GetPluginForExtension(extension) {
    const registeredPlugin = SceneLoader._RegisteredPlugins[extension];
    if (registeredPlugin) {
      return registeredPlugin;
    }
    Logger.Warn("Unable to find a plugin to load " + extension + " files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes");
    return SceneLoader.GetDefaultPlugin();
  }
  static _GetPluginForDirectLoad(data) {
    for (const extension in SceneLoader._RegisteredPlugins) {
      const plugin = SceneLoader._RegisteredPlugins[extension].plugin;
      if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {
        return SceneLoader._RegisteredPlugins[extension];
      }
    }
    return SceneLoader.GetDefaultPlugin();
  }
  static _GetPluginForFilename(sceneFilename) {
    const queryStringPosition = sceneFilename.indexOf("?");
    if (queryStringPosition !== -1) {
      sceneFilename = sceneFilename.substring(0, queryStringPosition);
    }
    const dotPosition = sceneFilename.lastIndexOf(".");
    const extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();
    return SceneLoader._GetPluginForExtension(extension);
  }
  static _GetDirectLoad(sceneFilename) {
    if (sceneFilename.substr(0, 5) === "data:") {
      return sceneFilename.substr(5);
    }
    return null;
  }
  static _FormatErrorMessage(fileInfo, message, exception) {
    let errorMessage = "Unable to load from " + fileInfo.url;
    if (message) {
      errorMessage += `: ${message}`;
    } else if (exception) {
      errorMessage += `: ${exception}`;
    }
    return errorMessage;
  }
  static _LoadData(fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension) {
    const directLoad = SceneLoader._GetDirectLoad(fileInfo.url);
    const registeredPlugin = pluginExtension ? SceneLoader._GetPluginForExtension(pluginExtension) : directLoad ? SceneLoader._GetPluginForDirectLoad(fileInfo.url) : SceneLoader._GetPluginForFilename(fileInfo.url);
    let plugin;
    if (registeredPlugin.plugin.createPlugin !== void 0) {
      plugin = registeredPlugin.plugin.createPlugin();
    } else {
      plugin = registeredPlugin.plugin;
    }
    if (!plugin) {
      throw "The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.";
    }
    SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);
    if (directLoad && (plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url) || !IsBase64DataUrl(fileInfo.url))) {
      if (plugin.directLoad) {
        const result = plugin.directLoad(scene, directLoad);
        if (result.then) {
          result.then((data) => {
            onSuccess(plugin, data);
          }).catch((error) => {
            onError("Error in directLoad of _loadData: " + error, error);
          });
        } else {
          onSuccess(plugin, result);
        }
      } else {
        onSuccess(plugin, directLoad);
      }
      return plugin;
    }
    const useArrayBuffer = registeredPlugin.isBinary;
    const dataCallback = (data, responseURL) => {
      if (scene.isDisposed) {
        onError("Scene has been disposed");
        return;
      }
      onSuccess(plugin, data, responseURL);
    };
    let request = null;
    let pluginDisposed = false;
    const onDisposeObservable = plugin.onDisposeObservable;
    if (onDisposeObservable) {
      onDisposeObservable.add(() => {
        pluginDisposed = true;
        if (request) {
          request.abort();
          request = null;
        }
        onDispose();
      });
    }
    const manifestChecked = () => {
      if (pluginDisposed) {
        return;
      }
      const errorCallback = (request2, exception) => {
        onError(request2 === null || request2 === void 0 ? void 0 : request2.statusText, exception);
      };
      const fileOrUrl = fileInfo.file || fileInfo.url;
      request = plugin.loadFile ? plugin.loadFile(scene, fileOrUrl, dataCallback, onProgress, useArrayBuffer, errorCallback) : scene._loadFile(fileOrUrl, dataCallback, onProgress, true, useArrayBuffer, errorCallback);
    };
    const engine = scene.getEngine();
    let canUseOfflineSupport = engine.enableOfflineSupport;
    if (canUseOfflineSupport) {
      let exceptionFound = false;
      for (const regex of scene.disableOfflineSupportExceptionRules) {
        if (regex.test(fileInfo.url)) {
          exceptionFound = true;
          break;
        }
      }
      canUseOfflineSupport = !exceptionFound;
    }
    if (canUseOfflineSupport && Engine.OfflineProviderFactory) {
      scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);
    } else {
      manifestChecked();
    }
    return plugin;
  }
  static _GetFileInfo(rootUrl, sceneFilename) {
    let url;
    let name63;
    let file = null;
    if (!sceneFilename) {
      url = rootUrl;
      name63 = Tools.GetFilename(rootUrl);
      rootUrl = Tools.GetFolderPath(rootUrl);
    } else if (sceneFilename.name) {
      const sceneFile = sceneFilename;
      url = `file:${sceneFile.name}`;
      name63 = sceneFile.name;
      file = sceneFile;
    } else if (typeof sceneFilename === "string" && sceneFilename.startsWith("data:")) {
      url = sceneFilename;
      name63 = "";
    } else {
      const filename = sceneFilename;
      if (filename.substr(0, 1) === "/") {
        Tools.Error("Wrong sceneFilename parameter");
        return null;
      }
      url = rootUrl + filename;
      name63 = filename;
    }
    return {
      url,
      rootUrl,
      name: name63,
      file
    };
  }
  static GetPluginForExtension(extension) {
    return SceneLoader._GetPluginForExtension(extension).plugin;
  }
  static IsPluginForExtensionAvailable(extension) {
    return !!SceneLoader._RegisteredPlugins[extension];
  }
  static RegisterPlugin(plugin) {
    if (typeof plugin.extensions === "string") {
      const extension = plugin.extensions;
      SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {
        plugin,
        isBinary: false
      };
    } else {
      const extensions = plugin.extensions;
      Object.keys(extensions).forEach((extension) => {
        SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {
          plugin,
          isBinary: extensions[extension].isBinary
        };
      });
    }
  }
  static ImportMesh(meshNames, rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {
    if (!scene) {
      Logger.Error("No scene available to import mesh to");
      return null;
    }
    const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);
    if (!fileInfo) {
      return null;
    }
    const loadingToken = {};
    scene.addPendingData(loadingToken);
    const disposeHandler = () => {
      scene.removePendingData(loadingToken);
    };
    const errorHandler = (message, exception) => {
      const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);
      if (onError) {
        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
      } else {
        Logger.Error(errorMessage);
      }
      disposeHandler();
    };
    const progressHandler = onProgress ? (event) => {
      try {
        onProgress(event);
      } catch (e) {
        errorHandler("Error in onProgress callback: " + e, e);
      }
    } : void 0;
    const successHandler = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {
      scene.importedMeshesFiles.push(fileInfo.url);
      if (onSuccess) {
        try {
          onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);
        } catch (e) {
          errorHandler("Error in onSuccess callback: " + e, e);
        }
      }
      scene.removePendingData(loadingToken);
    };
    return SceneLoader._LoadData(fileInfo, scene, (plugin, data, responseURL) => {
      if (plugin.rewriteRootURL) {
        fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);
      }
      if (plugin.importMesh) {
        const syncedPlugin = plugin;
        const meshes = new Array();
        const particleSystems = new Array();
        const skeletons = new Array();
        if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {
          return;
        }
        scene.loadingPluginName = plugin.name;
        successHandler(meshes, particleSystems, skeletons, [], [], [], []);
      } else {
        const asyncedPlugin = plugin;
        asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then((result) => {
          scene.loadingPluginName = plugin.name;
          successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights);
        }).catch((error) => {
          errorHandler(error.message, error);
        });
      }
    }, progressHandler, errorHandler, disposeHandler, pluginExtension);
  }
  static ImportMeshAsync(meshNames, rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null) {
    return new Promise((resolve, reject) => {
      SceneLoader.ImportMesh(meshNames, rootUrl, sceneFilename, scene, (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {
        resolve({
          meshes,
          particleSystems,
          skeletons,
          animationGroups,
          transformNodes,
          geometries,
          lights
        });
      }, onProgress, (scene2, message, exception) => {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  }
  static Load(rootUrl, sceneFilename = "", engine = EngineStore.LastCreatedEngine, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {
    if (!engine) {
      Tools.Error("No engine available");
      return null;
    }
    return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension);
  }
  static LoadAsync(rootUrl, sceneFilename = "", engine = EngineStore.LastCreatedEngine, onProgress = null, pluginExtension = null) {
    return new Promise((resolve, reject) => {
      SceneLoader.Load(rootUrl, sceneFilename, engine, (scene) => {
        resolve(scene);
      }, onProgress, (scene, message, exception) => {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  }
  static Append(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {
    if (!scene) {
      Logger.Error("No scene available to append to");
      return null;
    }
    const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);
    if (!fileInfo) {
      return null;
    }
    const loadingToken = {};
    scene.addPendingData(loadingToken);
    const disposeHandler = () => {
      scene.removePendingData(loadingToken);
    };
    if (SceneLoader.ShowLoadingScreen && !this._ShowingLoadingScreen) {
      this._ShowingLoadingScreen = true;
      scene.getEngine().displayLoadingUI();
      scene.executeWhenReady(() => {
        scene.getEngine().hideLoadingUI();
        this._ShowingLoadingScreen = false;
      });
    }
    const errorHandler = (message, exception) => {
      const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);
      if (onError) {
        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
      } else {
        Logger.Error(errorMessage);
      }
      disposeHandler();
    };
    const progressHandler = onProgress ? (event) => {
      try {
        onProgress(event);
      } catch (e) {
        errorHandler("Error in onProgress callback", e);
      }
    } : void 0;
    const successHandler = () => {
      if (onSuccess) {
        try {
          onSuccess(scene);
        } catch (e) {
          errorHandler("Error in onSuccess callback", e);
        }
      }
      scene.removePendingData(loadingToken);
    };
    return SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {
      if (plugin.load) {
        const syncedPlugin = plugin;
        if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {
          return;
        }
        scene.loadingPluginName = plugin.name;
        successHandler();
      } else {
        const asyncedPlugin = plugin;
        asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(() => {
          scene.loadingPluginName = plugin.name;
          successHandler();
        }).catch((error) => {
          errorHandler(error.message, error);
        });
      }
    }, progressHandler, errorHandler, disposeHandler, pluginExtension);
  }
  static AppendAsync(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null) {
    return new Promise((resolve, reject) => {
      SceneLoader.Append(rootUrl, sceneFilename, scene, (scene2) => {
        resolve(scene2);
      }, onProgress, (scene2, message, exception) => {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  }
  static LoadAssetContainer(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {
    if (!scene) {
      Logger.Error("No scene available to load asset container to");
      return null;
    }
    const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);
    if (!fileInfo) {
      return null;
    }
    const loadingToken = {};
    scene.addPendingData(loadingToken);
    const disposeHandler = () => {
      scene.removePendingData(loadingToken);
    };
    const errorHandler = (message, exception) => {
      const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);
      if (onError) {
        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
      } else {
        Logger.Error(errorMessage);
      }
      disposeHandler();
    };
    const progressHandler = onProgress ? (event) => {
      try {
        onProgress(event);
      } catch (e) {
        errorHandler("Error in onProgress callback", e);
      }
    } : void 0;
    const successHandler = (assets) => {
      if (onSuccess) {
        try {
          onSuccess(assets);
        } catch (e) {
          errorHandler("Error in onSuccess callback", e);
        }
      }
      scene.removePendingData(loadingToken);
    };
    return SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {
      if (plugin.loadAssetContainer) {
        const syncedPlugin = plugin;
        const assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);
        if (!assetContainer) {
          return;
        }
        scene.loadingPluginName = plugin.name;
        successHandler(assetContainer);
      } else if (plugin.loadAssetContainerAsync) {
        const asyncedPlugin = plugin;
        asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then((assetContainer) => {
          scene.loadingPluginName = plugin.name;
          successHandler(assetContainer);
        }).catch((error) => {
          errorHandler(error.message, error);
        });
      } else {
        errorHandler("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.");
      }
    }, progressHandler, errorHandler, disposeHandler, pluginExtension);
  }
  static LoadAssetContainerAsync(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null) {
    return new Promise((resolve, reject) => {
      SceneLoader.LoadAssetContainer(rootUrl, sceneFilename, scene, (assetContainer) => {
        resolve(assetContainer);
      }, onProgress, (scene2, message, exception) => {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  }
  static ImportAnimations(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter = null, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {
    if (!scene) {
      Logger.Error("No scene available to load animations to");
      return;
    }
    if (overwriteAnimations) {
      for (const animatable of scene.animatables) {
        animatable.reset();
      }
      scene.stopAllAnimations();
      scene.animationGroups.slice().forEach((animationGroup) => {
        animationGroup.dispose();
      });
      const nodes = scene.getNodes();
      nodes.forEach((node) => {
        if (node.animations) {
          node.animations = [];
        }
      });
    } else {
      switch (animationGroupLoadingMode) {
        case SceneLoaderAnimationGroupLoadingMode.Clean:
          scene.animationGroups.slice().forEach((animationGroup) => {
            animationGroup.dispose();
          });
          break;
        case SceneLoaderAnimationGroupLoadingMode.Stop:
          scene.animationGroups.forEach((animationGroup) => {
            animationGroup.stop();
          });
          break;
        case SceneLoaderAnimationGroupLoadingMode.Sync:
          scene.animationGroups.forEach((animationGroup) => {
            animationGroup.reset();
            animationGroup.restart();
          });
          break;
        case SceneLoaderAnimationGroupLoadingMode.NoSync:
          break;
        default:
          Logger.Error("Unknown animation group loading mode value '" + animationGroupLoadingMode + "'");
          return;
      }
    }
    const startingIndexForNewAnimatables = scene.animatables.length;
    const onAssetContainerLoaded = (container) => {
      container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);
      container.dispose();
      scene.onAnimationFileImportedObservable.notifyObservers(scene);
      if (onSuccess) {
        onSuccess(scene);
      }
    };
    this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);
  }
  static ImportAnimationsAsync(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter = null, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {
    return new Promise((resolve, reject) => {
      SceneLoader.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, (_scene) => {
        resolve(_scene);
      }, onProgress, (_scene, message, exception) => {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  }
};
SceneLoader.NO_LOGGING = 0;
SceneLoader.MINIMAL_LOGGING = 1;
SceneLoader.SUMMARY_LOGGING = 2;
SceneLoader.DETAILED_LOGGING = 3;
SceneLoader.OnPluginActivatedObservable = new Observable();
SceneLoader._RegisteredPlugins = {};
SceneLoader._ShowingLoadingScreen = false;

// node_modules/@babylonjs/core/Materials/pushMaterial.js
var PushMaterial = class extends Material {
  constructor(name63, scene, storeEffectOnSubMeshes = true) {
    super(name63, scene);
    this._normalMatrix = new Matrix();
    this._storeEffectOnSubMeshes = storeEffectOnSubMeshes;
  }
  getEffect() {
    return this._storeEffectOnSubMeshes ? this._activeEffect : super.getEffect();
  }
  isReady(mesh, useInstances) {
    if (!mesh) {
      return false;
    }
    if (!this._storeEffectOnSubMeshes) {
      return true;
    }
    if (!mesh.subMeshes || mesh.subMeshes.length === 0) {
      return true;
    }
    return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);
  }
  _isReadyForSubMesh(subMesh) {
    const defines = subMesh.materialDefines;
    if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {
      if (defines._renderId === this.getScene().getRenderId()) {
        return true;
      }
    }
    return false;
  }
  bindOnlyWorldMatrix(world) {
    this._activeEffect.setMatrix("world", world);
  }
  bindOnlyNormalMatrix(normalMatrix) {
    this._activeEffect.setMatrix("normalMatrix", normalMatrix);
  }
  bind(world, mesh) {
    if (!mesh) {
      return;
    }
    this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);
  }
  _afterBind(mesh, effect = null) {
    super._afterBind(mesh, effect);
    this.getScene()._cachedEffect = effect;
  }
  _mustRebind(scene, effect, visibility = 1) {
    return scene.isCachedMaterialInvalid(this, effect, visibility);
  }
};

// node_modules/@babylonjs/core/Maths/math.vertexFormat.js
var PositionNormalVertex = class {
  constructor(position = Vector3.Zero(), normal = Vector3.Up()) {
    this.position = position;
    this.normal = normal;
  }
  clone() {
    return new PositionNormalVertex(this.position.clone(), this.normal.clone());
  }
};
var PositionNormalTextureVertex = class {
  constructor(position = Vector3.Zero(), normal = Vector3.Up(), uv = Vector2.Zero()) {
    this.position = position;
    this.normal = normal;
    this.uv = uv;
  }
  clone() {
    return new PositionNormalTextureVertex(this.position.clone(), this.normal.clone(), this.uv.clone());
  }
};

// node_modules/@babylonjs/core/Materials/effectFallbacks.js
var EffectFallbacks = class {
  constructor() {
    this._defines = {};
    this._currentRank = 32;
    this._maxRank = -1;
    this._mesh = null;
  }
  unBindMesh() {
    this._mesh = null;
  }
  addFallback(rank, define) {
    if (!this._defines[rank]) {
      if (rank < this._currentRank) {
        this._currentRank = rank;
      }
      if (rank > this._maxRank) {
        this._maxRank = rank;
      }
      this._defines[rank] = new Array();
    }
    this._defines[rank].push(define);
  }
  addCPUSkinningFallback(rank, mesh) {
    this._mesh = mesh;
    if (rank < this._currentRank) {
      this._currentRank = rank;
    }
    if (rank > this._maxRank) {
      this._maxRank = rank;
    }
  }
  get hasMoreFallbacks() {
    return this._currentRank <= this._maxRank;
  }
  reduce(currentDefines, effect) {
    if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {
      this._mesh.computeBonesUsingShaders = false;
      currentDefines = currentDefines.replace("#define NUM_BONE_INFLUENCERS " + this._mesh.numBoneInfluencers, "#define NUM_BONE_INFLUENCERS 0");
      effect._bonesComputationForcedToCPU = true;
      const scene = this._mesh.getScene();
      for (let index = 0; index < scene.meshes.length; index++) {
        const otherMesh = scene.meshes[index];
        if (!otherMesh.material) {
          if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {
            otherMesh.computeBonesUsingShaders = false;
          }
          continue;
        }
        if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {
          continue;
        }
        if (otherMesh.material.getEffect() === effect) {
          otherMesh.computeBonesUsingShaders = false;
        } else if (otherMesh.subMeshes) {
          for (const subMesh of otherMesh.subMeshes) {
            const subMeshEffect = subMesh.effect;
            if (subMeshEffect === effect) {
              otherMesh.computeBonesUsingShaders = false;
              break;
            }
          }
        }
      }
    } else {
      const currentFallbacks = this._defines[this._currentRank];
      if (currentFallbacks) {
        for (let index = 0; index < currentFallbacks.length; index++) {
          currentDefines = currentDefines.replace("#define " + currentFallbacks[index], "");
        }
      }
      this._currentRank++;
    }
    return currentDefines;
  }
};

// node_modules/@babylonjs/core/Engines/renderTargetWrapper.js
var RenderTargetWrapper = class {
  constructor(isMulti, isCube, size, engine) {
    this._textures = null;
    this._samples = 1;
    this._attachments = null;
    this._generateStencilBuffer = false;
    this._generateDepthBuffer = false;
    this._depthStencilTextureWithStencil = false;
    this._isMulti = isMulti;
    this._isCube = isCube;
    this._size = size;
    this._engine = engine;
    this._depthStencilTexture = null;
  }
  get depthStencilTexture() {
    return this._depthStencilTexture;
  }
  get depthStencilTextureWithStencil() {
    return this._depthStencilTextureWithStencil;
  }
  get isCube() {
    return this._isCube;
  }
  get isMulti() {
    return this._isMulti;
  }
  get is2DArray() {
    return this.layers > 0;
  }
  get size() {
    return this.width;
  }
  get width() {
    return this._size.width || this._size;
  }
  get height() {
    return this._size.height || this._size;
  }
  get layers() {
    return this._size.layers || 0;
  }
  get texture() {
    var _a, _b;
    return (_b = (_a = this._textures) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;
  }
  get textures() {
    return this._textures;
  }
  get samples() {
    return this._samples;
  }
  setSamples(value, initializeBuffers = true, force = false) {
    if (this.samples === value && !force) {
      return value;
    }
    const result = this._isMulti ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, value, initializeBuffers) : this._engine.updateRenderTargetTextureSampleCount(this, value);
    this._samples = value;
    return result;
  }
  setTextures(textures) {
    if (Array.isArray(textures)) {
      this._textures = textures;
    } else if (textures) {
      this._textures = [textures];
    } else {
      this._textures = null;
    }
  }
  setTexture(texture, index = 0, disposePrevious = true) {
    if (!this._textures) {
      this._textures = [];
    }
    if (this._textures[index] && disposePrevious) {
      this._textures[index].dispose();
    }
    this._textures[index] = texture;
  }
  createDepthStencilTexture(comparisonFunction = 0, bilinearFiltering = true, generateStencil = false, samples = 1, format = 14) {
    var _a;
    (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();
    this._depthStencilTextureWithStencil = generateStencil;
    this._depthStencilTexture = this._engine.createDepthStencilTexture(this._size, {
      bilinearFiltering,
      comparisonFunction,
      generateStencil,
      isCube: this._isCube,
      samples,
      depthTextureFormat: format
    }, this);
    return this._depthStencilTexture;
  }
  _shareDepth(renderTarget) {
    if (this._depthStencilTexture) {
      if (renderTarget._depthStencilTexture) {
        renderTarget._depthStencilTexture.dispose();
      }
      renderTarget._depthStencilTexture = this._depthStencilTexture;
      this._depthStencilTexture.incrementReferences();
    }
  }
  _swapAndDie(target) {
    if (this.texture) {
      this.texture._swapAndDie(target);
    }
    this._textures = null;
    this.dispose(true);
  }
  _cloneRenderTargetWrapper() {
    var _a, _b, _c, _d, _e, _f;
    let rtw = null;
    if (this._isMulti) {
      const textureArray = this.textures;
      if (textureArray && textureArray.length > 0) {
        let generateDepthTexture = false;
        let textureCount = textureArray.length;
        const lastTextureSource = textureArray[textureArray.length - 1]._source;
        if (lastTextureSource === InternalTextureSource.Depth || lastTextureSource === InternalTextureSource.DepthStencil) {
          generateDepthTexture = true;
          textureCount--;
        }
        const samplingModes = [];
        const types = [];
        for (let i = 0; i < textureCount; ++i) {
          const texture = textureArray[i];
          samplingModes.push(texture.samplingMode);
          types.push(texture.type);
        }
        const optionsMRT = {
          samplingModes,
          generateMipMaps: textureArray[0].generateMipMaps,
          generateDepthBuffer: this._generateDepthBuffer,
          generateStencilBuffer: this._generateStencilBuffer,
          generateDepthTexture,
          types,
          textureCount
        };
        const size = {
          width: this.width,
          height: this.height
        };
        rtw = this._engine.createMultipleRenderTarget(size, optionsMRT);
      }
    } else {
      const options = {};
      options.generateDepthBuffer = this._generateDepthBuffer;
      options.generateMipMaps = (_b = (_a = this.texture) === null || _a === void 0 ? void 0 : _a.generateMipMaps) !== null && _b !== void 0 ? _b : false;
      options.generateStencilBuffer = this._generateStencilBuffer;
      options.samplingMode = (_c = this.texture) === null || _c === void 0 ? void 0 : _c.samplingMode;
      options.type = (_d = this.texture) === null || _d === void 0 ? void 0 : _d.type;
      options.format = (_e = this.texture) === null || _e === void 0 ? void 0 : _e.format;
      if (this.isCube) {
        rtw = this._engine.createRenderTargetCubeTexture(this.width, options);
      } else {
        const size = {
          width: this.width,
          height: this.height,
          layers: this.is2DArray ? (_f = this.texture) === null || _f === void 0 ? void 0 : _f.depth : void 0
        };
        rtw = this._engine.createRenderTargetTexture(size, options);
      }
      rtw.texture.isReady = true;
    }
    return rtw;
  }
  _swapRenderTargetWrapper(target) {
    if (this._textures && target._textures) {
      for (let i = 0; i < this._textures.length; ++i) {
        this._textures[i]._swapAndDie(target._textures[i], false);
        target._textures[i].isReady = true;
      }
    }
    if (this._depthStencilTexture && target._depthStencilTexture) {
      this._depthStencilTexture._swapAndDie(target._depthStencilTexture);
      target._depthStencilTexture.isReady = true;
    }
    this._textures = null;
    this._depthStencilTexture = null;
  }
  _rebuild() {
    const rtw = this._cloneRenderTargetWrapper();
    if (!rtw) {
      return;
    }
    if (this._depthStencilTexture) {
      const samplingMode = this._depthStencilTexture.samplingMode;
      const bilinear = samplingMode === 2 || samplingMode === 3 || samplingMode === 11;
      rtw.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, bilinear, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples);
    }
    if (this.samples > 1) {
      rtw.setSamples(this.samples);
    }
    rtw._swapRenderTargetWrapper(this);
    rtw.dispose();
  }
  releaseTextures() {
    var _a, _b;
    if (this._textures) {
      for (let i = 0; (_b = i < ((_a = this._textures) === null || _a === void 0 ? void 0 : _a.length)) !== null && _b !== void 0 ? _b : 0; ++i) {
        this._textures[i].dispose();
      }
    }
    this._textures = null;
  }
  dispose(disposeOnlyFramebuffers = false) {
    var _a;
    if (!disposeOnlyFramebuffers) {
      (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();
      this._depthStencilTexture = null;
      this.releaseTextures();
    }
    this._engine._releaseRenderTargetWrapper(this);
  }
};

// node_modules/@babylonjs/core/Shaders/postprocess.vertex.js
var name = "postprocessVertexShader";
var shader = `attribute vec2 position;
uniform vec2 scale;
varying vec2 vUV;
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=(position*madd+madd)*scale;
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name] = shader;

// node_modules/@babylonjs/core/Engines/WebGL/webGLRenderTargetWrapper.js
var WebGLRenderTargetWrapper = class extends RenderTargetWrapper {
  constructor(isMulti, isCube, size, engine, context) {
    super(isMulti, isCube, size, engine);
    this._framebuffer = null;
    this._depthStencilBuffer = null;
    this._MSAAFramebuffer = null;
    this._colorTextureArray = null;
    this._depthStencilTextureArray = null;
    this._context = context;
  }
  _cloneRenderTargetWrapper() {
    let rtw = null;
    if (this._colorTextureArray && this._depthStencilTextureArray) {
      rtw = this._engine.createMultiviewRenderTargetTexture(this.width, this.height);
      rtw.texture.isReady = true;
    } else {
      rtw = super._cloneRenderTargetWrapper();
    }
    return rtw;
  }
  _swapRenderTargetWrapper(target) {
    super._swapRenderTargetWrapper(target);
    target._framebuffer = this._framebuffer;
    target._depthStencilBuffer = this._depthStencilBuffer;
    target._MSAAFramebuffer = this._MSAAFramebuffer;
    target._colorTextureArray = this._colorTextureArray;
    target._depthStencilTextureArray = this._depthStencilTextureArray;
    this._framebuffer = this._depthStencilBuffer = this._MSAAFramebuffer = this._colorTextureArray = this._depthStencilTextureArray = null;
  }
  _shareDepth(renderTarget) {
    super._shareDepth(renderTarget);
    const gl = this._context;
    const depthbuffer = this._depthStencilBuffer;
    const framebuffer = renderTarget._MSAAFramebuffer || renderTarget._framebuffer;
    if (renderTarget._depthStencilBuffer) {
      gl.deleteRenderbuffer(renderTarget._depthStencilBuffer);
    }
    renderTarget._depthStencilBuffer = this._depthStencilBuffer;
    this._engine._bindUnboundFramebuffer(framebuffer);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthbuffer);
    this._engine._bindUnboundFramebuffer(null);
  }
  _bindTextureRenderTarget(texture, attachmentIndex = 0, faceIndex = -1, lodLevel = 0) {
    if (!texture._hardwareTexture) {
      return;
    }
    const gl = this._context;
    const framebuffer = this._framebuffer;
    const currentFB = this._engine._currentFramebuffer;
    this._engine._bindUnboundFramebuffer(framebuffer);
    const attachment = gl[this._engine.webGLVersion > 1 ? "COLOR_ATTACHMENT" + attachmentIndex : "COLOR_ATTACHMENT" + attachmentIndex + "_WEBGL"];
    const target = faceIndex !== -1 ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, target, texture._hardwareTexture.underlyingResource, lodLevel);
    this._engine._bindUnboundFramebuffer(currentFB);
  }
  setTexture(texture, index = 0, disposePrevious = true) {
    super.setTexture(texture, index, disposePrevious);
    this._bindTextureRenderTarget(texture, index);
  }
  dispose(disposeOnlyFramebuffers = false) {
    const gl = this._context;
    if (!disposeOnlyFramebuffers) {
      if (this._colorTextureArray) {
        this._context.deleteTexture(this._colorTextureArray);
        this._colorTextureArray = null;
      }
      if (this._depthStencilTextureArray) {
        this._context.deleteTexture(this._depthStencilTextureArray);
        this._depthStencilTextureArray = null;
      }
    }
    if (this._framebuffer) {
      gl.deleteFramebuffer(this._framebuffer);
      this._framebuffer = null;
    }
    if (this._depthStencilBuffer) {
      gl.deleteRenderbuffer(this._depthStencilBuffer);
      this._depthStencilBuffer = null;
    }
    if (this._MSAAFramebuffer) {
      gl.deleteFramebuffer(this._MSAAFramebuffer);
      this._MSAAFramebuffer = null;
    }
    super.dispose(disposeOnlyFramebuffers);
  }
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.renderTarget.js
ThinEngine.prototype._createHardwareRenderTargetWrapper = function(isMulti, isCube, size) {
  const rtWrapper = new WebGLRenderTargetWrapper(isMulti, isCube, size, this, this._gl);
  this._renderTargetWrapperCache.push(rtWrapper);
  return rtWrapper;
};
ThinEngine.prototype.createRenderTargetTexture = function(size, options) {
  var _a, _b;
  const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);
  let generateDepthBuffer = true;
  let generateStencilBuffer = false;
  let noColorAttachment = false;
  let colorAttachment = void 0;
  let samples = 1;
  if (options !== void 0 && typeof options === "object") {
    generateDepthBuffer = (_a = options.generateDepthBuffer) !== null && _a !== void 0 ? _a : true;
    generateStencilBuffer = !!options.generateStencilBuffer;
    noColorAttachment = !!options.noColorAttachment;
    colorAttachment = options.colorAttachment;
    samples = (_b = options.samples) !== null && _b !== void 0 ? _b : 1;
  }
  const texture = colorAttachment || (noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget));
  const width = size.width || size;
  const height = size.height || size;
  const currentFrameBuffer = this._currentFramebuffer;
  const gl = this._gl;
  const framebuffer = gl.createFramebuffer();
  this._bindUnboundFramebuffer(framebuffer);
  rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height);
  if (texture && !texture.is2DArray) {
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource, 0);
  }
  this._bindUnboundFramebuffer(currentFrameBuffer);
  rtWrapper._framebuffer = framebuffer;
  rtWrapper._generateDepthBuffer = generateDepthBuffer;
  rtWrapper._generateStencilBuffer = generateStencilBuffer;
  rtWrapper.setTextures(texture);
  this.updateRenderTargetTextureSampleCount(rtWrapper, samples);
  return rtWrapper;
};
ThinEngine.prototype.createDepthStencilTexture = function(size, options, rtWrapper) {
  if (options.isCube) {
    const width = size.width || size;
    return this._createDepthStencilCubeTexture(width, options, rtWrapper);
  } else {
    return this._createDepthStencilTexture(size, options, rtWrapper);
  }
};
ThinEngine.prototype._createDepthStencilTexture = function(size, options, rtWrapper) {
  const gl = this._gl;
  const layers = size.layers || 0;
  const target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
  const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);
  if (!this._caps.depthTextureExtension) {
    Logger.Error("Depth texture is not supported by your browser or hardware.");
    return internalTexture;
  }
  const internalOptions = {
    bilinearFiltering: false,
    comparisonFunction: 0,
    generateStencil: false,
    ...options
  };
  this._bindTextureDirectly(target, internalTexture, true);
  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.comparisonFunction === 0 ? false : internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);
  if (internalOptions.depthTextureFormat !== void 0) {
    if (internalOptions.depthTextureFormat !== 15 && internalOptions.depthTextureFormat !== 16 && internalOptions.depthTextureFormat !== 17 && internalOptions.depthTextureFormat !== 13 && internalOptions.depthTextureFormat !== 14 && internalOptions.depthTextureFormat !== 18) {
      Logger.Error("Depth texture format is not supported.");
      return internalTexture;
    }
    internalTexture.format = internalOptions.depthTextureFormat;
  } else {
    internalTexture.format = internalOptions.generateStencil ? 13 : 16;
  }
  const hasStencil = internalTexture.format === 17 || internalTexture.format === 13 || internalTexture.format === 18;
  rtWrapper._depthStencilTexture = internalTexture;
  rtWrapper._depthStencilTextureWithStencil = hasStencil;
  let type = gl.UNSIGNED_INT;
  if (internalTexture.format === 15) {
    type = gl.UNSIGNED_SHORT;
  } else if (internalTexture.format === 17 || internalTexture.format === 13) {
    type = gl.UNSIGNED_INT_24_8;
  } else if (internalTexture.format === 14) {
    type = gl.FLOAT;
  } else if (internalTexture.format === 18) {
    type = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
  }
  const format = hasStencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT;
  let internalFormat = format;
  if (this.webGLVersion > 1) {
    if (internalTexture.format === 15) {
      internalFormat = gl.DEPTH_COMPONENT16;
    } else if (internalTexture.format === 16) {
      internalFormat = gl.DEPTH_COMPONENT24;
    } else if (internalTexture.format === 17 || internalTexture.format === 13) {
      internalFormat = gl.DEPTH24_STENCIL8;
    } else if (internalTexture.format === 14) {
      internalFormat = gl.DEPTH_COMPONENT32F;
    } else if (internalTexture.format === 18) {
      internalFormat = gl.DEPTH32F_STENCIL8;
    }
  }
  if (internalTexture.is2DArray) {
    gl.texImage3D(target, 0, internalFormat, internalTexture.width, internalTexture.height, layers, 0, format, type, null);
  } else {
    gl.texImage2D(target, 0, internalFormat, internalTexture.width, internalTexture.height, 0, format, type, null);
  }
  this._bindTextureDirectly(target, null);
  this._internalTexturesCache.push(internalTexture);
  const glRtWrapper = rtWrapper;
  if (glRtWrapper._depthStencilBuffer) {
    const currentFrameBuffer = this._currentFramebuffer;
    this._bindUnboundFramebuffer(glRtWrapper._framebuffer);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, null);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, null);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, null);
    this._bindUnboundFramebuffer(currentFrameBuffer);
    gl.deleteRenderbuffer(glRtWrapper._depthStencilBuffer);
    glRtWrapper._depthStencilBuffer = null;
  }
  return internalTexture;
};
ThinEngine.prototype.updateRenderTargetTextureSampleCount = function(rtWrapper, samples) {
  if (this.webGLVersion < 2 || !rtWrapper || !rtWrapper.texture) {
    return 1;
  }
  if (rtWrapper.samples === samples) {
    return samples;
  }
  const gl = this._gl;
  samples = Math.min(samples, this.getCaps().maxMSAASamples);
  if (rtWrapper._depthStencilBuffer) {
    gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);
    rtWrapper._depthStencilBuffer = null;
  }
  if (rtWrapper._MSAAFramebuffer) {
    gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);
    rtWrapper._MSAAFramebuffer = null;
  }
  const hardwareTexture = rtWrapper.texture._hardwareTexture;
  if (hardwareTexture._MSAARenderBuffer) {
    gl.deleteRenderbuffer(hardwareTexture._MSAARenderBuffer);
    hardwareTexture._MSAARenderBuffer = null;
  }
  if (samples > 1 && gl.renderbufferStorageMultisample) {
    const framebuffer = gl.createFramebuffer();
    if (!framebuffer) {
      throw new Error("Unable to create multi sampled framebuffer");
    }
    rtWrapper._MSAAFramebuffer = framebuffer;
    this._bindUnboundFramebuffer(rtWrapper._MSAAFramebuffer);
    const colorRenderbuffer = this._createRenderBuffer(rtWrapper.texture.width, rtWrapper.texture.height, samples, -1, this._getRGBAMultiSampleBufferFormat(rtWrapper.texture.type), gl.COLOR_ATTACHMENT0, false);
    if (!colorRenderbuffer) {
      throw new Error("Unable to create multi sampled framebuffer");
    }
    hardwareTexture._MSAARenderBuffer = colorRenderbuffer;
  } else {
    this._bindUnboundFramebuffer(rtWrapper._framebuffer);
  }
  rtWrapper.texture.samples = samples;
  rtWrapper._samples = samples;
  rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, rtWrapper.texture.width, rtWrapper.texture.height, samples);
  this._bindUnboundFramebuffer(null);
  return samples;
};

// node_modules/@babylonjs/core/PostProcesses/postProcess.js
var PostProcess = class {
  constructor(name63, fragmentUrl, parameters, samplers, options, camera, samplingMode = 1, engine, reusable, defines = null, textureType = 0, vertexUrl = "postprocess", indexParameters, blockCompilation = false, textureFormat = 5, shaderLanguage = ShaderLanguage.GLSL) {
    this._parentContainer = null;
    this.width = -1;
    this.height = -1;
    this.nodeMaterialSource = null;
    this._outputTexture = null;
    this.autoClear = true;
    this.alphaMode = 0;
    this.animations = new Array();
    this.enablePixelPerfectMode = false;
    this.forceFullscreenViewport = true;
    this.scaleMode = 1;
    this.alwaysForcePOT = false;
    this._samples = 1;
    this.adaptScaleToCurrentViewport = false;
    this._reusable = false;
    this._renderId = 0;
    this.externalTextureSamplerBinding = false;
    this._textures = new SmartArray(2);
    this._textureCache = [];
    this._currentRenderTextureInd = 0;
    this._scaleRatio = new Vector2(1, 1);
    this._texelSize = Vector2.Zero();
    this.onActivateObservable = new Observable();
    this.onSizeChangedObservable = new Observable();
    this.onApplyObservable = new Observable();
    this.onBeforeRenderObservable = new Observable();
    this.onAfterRenderObservable = new Observable();
    this.name = name63;
    if (camera != null) {
      this._camera = camera;
      this._scene = camera.getScene();
      camera.attachPostProcess(this);
      this._engine = this._scene.getEngine();
      this._scene.postProcesses.push(this);
      this.uniqueId = this._scene.getUniqueId();
    } else if (engine) {
      this._engine = engine;
      this._engine.postProcesses.push(this);
    }
    this._options = options;
    this.renderTargetSamplingMode = samplingMode ? samplingMode : 1;
    this._reusable = reusable || false;
    this._textureType = textureType;
    this._textureFormat = textureFormat;
    this._shaderLanguage = shaderLanguage;
    this._samplers = samplers || [];
    this._samplers.push("textureSampler");
    this._fragmentUrl = fragmentUrl;
    this._vertexUrl = vertexUrl;
    this._parameters = parameters || [];
    this._parameters.push("scale");
    this._indexParameters = indexParameters;
    this._drawWrapper = new DrawWrapper(this._engine);
    if (!blockCompilation) {
      this.updateEffect(defines);
    }
  }
  static RegisterShaderCodeProcessing(postProcessName, customShaderCodeProcessing) {
    if (!customShaderCodeProcessing) {
      delete PostProcess._CustomShaderCodeProcessing[postProcessName !== null && postProcessName !== void 0 ? postProcessName : ""];
      return;
    }
    PostProcess._CustomShaderCodeProcessing[postProcessName !== null && postProcessName !== void 0 ? postProcessName : ""] = customShaderCodeProcessing;
  }
  static _GetShaderCodeProcessing(postProcessName) {
    var _a;
    return (_a = PostProcess._CustomShaderCodeProcessing[postProcessName]) !== null && _a !== void 0 ? _a : PostProcess._CustomShaderCodeProcessing[""];
  }
  get samples() {
    return this._samples;
  }
  set samples(n) {
    this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);
    this._textures.forEach((texture) => {
      texture.setSamples(this._samples);
    });
  }
  getEffectName() {
    return this._fragmentUrl;
  }
  set onActivate(callback) {
    if (this._onActivateObserver) {
      this.onActivateObservable.remove(this._onActivateObserver);
    }
    if (callback) {
      this._onActivateObserver = this.onActivateObservable.add(callback);
    }
  }
  set onSizeChanged(callback) {
    if (this._onSizeChangedObserver) {
      this.onSizeChangedObservable.remove(this._onSizeChangedObserver);
    }
    this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);
  }
  set onApply(callback) {
    if (this._onApplyObserver) {
      this.onApplyObservable.remove(this._onApplyObserver);
    }
    this._onApplyObserver = this.onApplyObservable.add(callback);
  }
  set onBeforeRender(callback) {
    if (this._onBeforeRenderObserver) {
      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
    }
    this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
  }
  set onAfterRender(callback) {
    if (this._onAfterRenderObserver) {
      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
    }
    this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
  }
  get inputTexture() {
    return this._textures.data[this._currentRenderTextureInd];
  }
  set inputTexture(value) {
    this._forcedOutputTexture = value;
  }
  restoreDefaultInputTexture() {
    if (this._forcedOutputTexture) {
      this._forcedOutputTexture = null;
      this.markTextureDirty();
    }
  }
  getCamera() {
    return this._camera;
  }
  get texelSize() {
    if (this._shareOutputWithPostProcess) {
      return this._shareOutputWithPostProcess.texelSize;
    }
    if (this._forcedOutputTexture) {
      this._texelSize.copyFromFloats(1 / this._forcedOutputTexture.width, 1 / this._forcedOutputTexture.height);
    }
    return this._texelSize;
  }
  getClassName() {
    return "PostProcess";
  }
  getEngine() {
    return this._engine;
  }
  getEffect() {
    return this._drawWrapper.effect;
  }
  shareOutputWith(postProcess) {
    this._disposeTextures();
    this._shareOutputWithPostProcess = postProcess;
    return this;
  }
  useOwnOutput() {
    if (this._textures.length == 0) {
      this._textures = new SmartArray(2);
    }
    this._shareOutputWithPostProcess = null;
  }
  updateEffect(defines = null, uniforms = null, samplers = null, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl) {
    var _a, _b;
    const customShaderCodeProcessing = PostProcess._GetShaderCodeProcessing(this.name);
    if (customShaderCodeProcessing === null || customShaderCodeProcessing === void 0 ? void 0 : customShaderCodeProcessing.defineCustomBindings) {
      const newUniforms = (_a = uniforms === null || uniforms === void 0 ? void 0 : uniforms.slice()) !== null && _a !== void 0 ? _a : [];
      newUniforms.push(...this._parameters);
      const newSamplers = (_b = samplers === null || samplers === void 0 ? void 0 : samplers.slice()) !== null && _b !== void 0 ? _b : [];
      newSamplers.push(...this._samplers);
      defines = customShaderCodeProcessing.defineCustomBindings(this.name, defines, newUniforms, newSamplers);
      uniforms = newUniforms;
      samplers = newSamplers;
    }
    this._postProcessDefines = defines;
    this._drawWrapper.effect = this._engine.createEffect({ vertex: vertexUrl !== null && vertexUrl !== void 0 ? vertexUrl : this._vertexUrl, fragment: fragmentUrl !== null && fragmentUrl !== void 0 ? fragmentUrl : this._fragmentUrl }, {
      attributes: ["position"],
      uniformsNames: uniforms || this._parameters,
      uniformBuffersNames: [],
      samplers: samplers || this._samplers,
      defines: defines !== null ? defines : "",
      fallbacks: null,
      onCompiled: onCompiled !== null && onCompiled !== void 0 ? onCompiled : null,
      onError: onError !== null && onError !== void 0 ? onError : null,
      indexParameters: indexParameters || this._indexParameters,
      processCodeAfterIncludes: (customShaderCodeProcessing === null || customShaderCodeProcessing === void 0 ? void 0 : customShaderCodeProcessing.processCodeAfterIncludes) ? (shaderType, code) => customShaderCodeProcessing.processCodeAfterIncludes(this.name, shaderType, code) : null,
      processFinalCode: (customShaderCodeProcessing === null || customShaderCodeProcessing === void 0 ? void 0 : customShaderCodeProcessing.processFinalCode) ? (shaderType, code) => customShaderCodeProcessing.processFinalCode(this.name, shaderType, code) : null,
      shaderLanguage: this._shaderLanguage
    }, this._engine);
  }
  isReusable() {
    return this._reusable;
  }
  markTextureDirty() {
    this.width = -1;
  }
  _createRenderTargetTexture(textureSize, textureOptions, channel = 0) {
    for (let i = 0; i < this._textureCache.length; i++) {
      if (this._textureCache[i].texture.width === textureSize.width && this._textureCache[i].texture.height === textureSize.height && this._textureCache[i].postProcessChannel === channel && this._textureCache[i].texture._generateDepthBuffer === textureOptions.generateDepthBuffer && this._textureCache[i].texture.samples === textureOptions.samples) {
        return this._textureCache[i].texture;
      }
    }
    const tex = this._engine.createRenderTargetTexture(textureSize, textureOptions);
    this._textureCache.push({ texture: tex, postProcessChannel: channel, lastUsedRenderId: -1 });
    return tex;
  }
  _flushTextureCache() {
    const currentRenderId = this._renderId;
    for (let i = this._textureCache.length - 1; i >= 0; i--) {
      if (currentRenderId - this._textureCache[i].lastUsedRenderId > 100) {
        let currentlyUsed = false;
        for (let j = 0; j < this._textures.length; j++) {
          if (this._textures.data[j] === this._textureCache[i].texture) {
            currentlyUsed = true;
            break;
          }
        }
        if (!currentlyUsed) {
          this._textureCache[i].texture.dispose();
          this._textureCache.splice(i, 1);
        }
      }
    }
  }
  _resize(width, height, camera, needMipMaps, forceDepthStencil) {
    if (this._textures.length > 0) {
      this._textures.reset();
    }
    this.width = width;
    this.height = height;
    let firstPP = null;
    for (let i = 0; i < camera._postProcesses.length; i++) {
      if (camera._postProcesses[i] !== null) {
        firstPP = camera._postProcesses[i];
        break;
      }
    }
    const textureSize = { width: this.width, height: this.height };
    const textureOptions = {
      generateMipMaps: needMipMaps,
      generateDepthBuffer: forceDepthStencil || firstPP === this,
      generateStencilBuffer: (forceDepthStencil || firstPP === this) && this._engine.isStencilEnable,
      samplingMode: this.renderTargetSamplingMode,
      type: this._textureType,
      format: this._textureFormat,
      samples: this._samples
    };
    this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 0));
    if (this._reusable) {
      this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 1));
    }
    this._texelSize.copyFromFloats(1 / this.width, 1 / this.height);
    this.onSizeChangedObservable.notifyObservers(this);
  }
  activate(camera, sourceTexture = null, forceDepthStencil) {
    var _a, _b;
    camera = camera || this._camera;
    const scene = camera.getScene();
    const engine = scene.getEngine();
    const maxSize = engine.getCaps().maxTextureSize;
    let requiredWidth = (sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * this._options | 0;
    const requiredHeight = (sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * this._options | 0;
    const webVRCamera = camera.parent;
    if (webVRCamera && (webVRCamera.leftCamera == camera || webVRCamera.rightCamera == camera)) {
      requiredWidth /= 2;
    }
    let desiredWidth = this._options.width || requiredWidth;
    let desiredHeight = this._options.height || requiredHeight;
    const needMipMaps = this.renderTargetSamplingMode !== 7 && this.renderTargetSamplingMode !== 1 && this.renderTargetSamplingMode !== 2;
    if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {
      if (this.adaptScaleToCurrentViewport) {
        const currentViewport = engine.currentViewport;
        if (currentViewport) {
          desiredWidth *= currentViewport.width;
          desiredHeight *= currentViewport.height;
        }
      }
      if (needMipMaps || this.alwaysForcePOT) {
        if (!this._options.width) {
          desiredWidth = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;
        }
        if (!this._options.height) {
          desiredHeight = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;
        }
      }
      if (this.width !== desiredWidth || this.height !== desiredHeight) {
        this._resize(desiredWidth, desiredHeight, camera, needMipMaps, forceDepthStencil);
      }
      this._textures.forEach((texture) => {
        if (texture.samples !== this.samples) {
          this._engine.updateRenderTargetTextureSampleCount(texture, this.samples);
        }
      });
      this._flushTextureCache();
      this._renderId++;
    }
    let target;
    if (this._shareOutputWithPostProcess) {
      target = this._shareOutputWithPostProcess.inputTexture;
    } else if (this._forcedOutputTexture) {
      target = this._forcedOutputTexture;
      this.width = this._forcedOutputTexture.width;
      this.height = this._forcedOutputTexture.height;
    } else {
      target = this.inputTexture;
      let cache;
      for (let i = 0; i < this._textureCache.length; i++) {
        if (this._textureCache[i].texture === target) {
          cache = this._textureCache[i];
          break;
        }
      }
      if (cache) {
        cache.lastUsedRenderId = this._renderId;
      }
    }
    if (this.enablePixelPerfectMode) {
      this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);
      this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);
    } else {
      this._scaleRatio.copyFromFloats(1, 1);
      this._engine.bindFramebuffer(target, 0, void 0, void 0, this.forceFullscreenViewport);
    }
    (_b = (_a = this._engine)._debugInsertMarker) === null || _b === void 0 ? void 0 : _b.call(_a, `post process ${this.name} input`);
    this.onActivateObservable.notifyObservers(camera);
    if (this.autoClear && this.alphaMode === 0) {
      this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);
    }
    if (this._reusable) {
      this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;
    }
    return target;
  }
  get isSupported() {
    return this._drawWrapper.effect.isSupported;
  }
  get aspectRatio() {
    if (this._shareOutputWithPostProcess) {
      return this._shareOutputWithPostProcess.aspectRatio;
    }
    if (this._forcedOutputTexture) {
      return this._forcedOutputTexture.width / this._forcedOutputTexture.height;
    }
    return this.width / this.height;
  }
  isReady() {
    var _a, _b;
    return (_b = (_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.isReady()) !== null && _b !== void 0 ? _b : false;
  }
  apply() {
    var _a, _b, _c;
    if (!((_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.isReady())) {
      return null;
    }
    this._engine.enableEffect(this._drawWrapper);
    this._engine.setState(false);
    this._engine.setDepthBuffer(false);
    this._engine.setDepthWrite(false);
    this._engine.setAlphaMode(this.alphaMode);
    if (this.alphaConstants) {
      this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);
    }
    let source;
    if (this._shareOutputWithPostProcess) {
      source = this._shareOutputWithPostProcess.inputTexture;
    } else if (this._forcedOutputTexture) {
      source = this._forcedOutputTexture;
    } else {
      source = this.inputTexture;
    }
    if (!this.externalTextureSamplerBinding) {
      this._drawWrapper.effect._bindTexture("textureSampler", source === null || source === void 0 ? void 0 : source.texture);
    }
    this._drawWrapper.effect.setVector2("scale", this._scaleRatio);
    this.onApplyObservable.notifyObservers(this._drawWrapper.effect);
    (_c = (_b = PostProcess._GetShaderCodeProcessing(this.name)) === null || _b === void 0 ? void 0 : _b.bindCustomBindings) === null || _c === void 0 ? void 0 : _c.call(_b, this.name, this._drawWrapper.effect);
    return this._drawWrapper.effect;
  }
  _disposeTextures() {
    if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {
      this._disposeTextureCache();
      return;
    }
    this._disposeTextureCache();
    this._textures.dispose();
  }
  _disposeTextureCache() {
    for (let i = this._textureCache.length - 1; i >= 0; i--) {
      this._textureCache[i].texture.dispose();
    }
    this._textureCache.length = 0;
  }
  setPrePassRenderer(prePassRenderer) {
    if (this._prePassEffectConfiguration) {
      this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);
      this._prePassEffectConfiguration.enabled = true;
      return true;
    }
    return false;
  }
  dispose(camera) {
    camera = camera || this._camera;
    this._disposeTextures();
    let index;
    if (this._scene) {
      index = this._scene.postProcesses.indexOf(this);
      if (index !== -1) {
        this._scene.postProcesses.splice(index, 1);
      }
    }
    if (this._parentContainer) {
      const index2 = this._parentContainer.postProcesses.indexOf(this);
      if (index2 > -1) {
        this._parentContainer.postProcesses.splice(index2, 1);
      }
      this._parentContainer = null;
    }
    index = this._engine.postProcesses.indexOf(this);
    if (index !== -1) {
      this._engine.postProcesses.splice(index, 1);
    }
    if (!camera) {
      return;
    }
    camera.detachPostProcess(this);
    index = camera._postProcesses.indexOf(this);
    if (index === 0 && camera._postProcesses.length > 0) {
      const firstPostProcess = this._camera._getFirstPostProcess();
      if (firstPostProcess) {
        firstPostProcess.markTextureDirty();
      }
    }
    this.onActivateObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onApplyObservable.clear();
    this.onBeforeRenderObservable.clear();
    this.onSizeChangedObservable.clear();
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    const camera = this.getCamera() || this._scene && this._scene.activeCamera;
    serializationObject.customType = "BABYLON." + this.getClassName();
    serializationObject.cameraId = camera ? camera.id : null;
    serializationObject.reusable = this._reusable;
    serializationObject.textureType = this._textureType;
    serializationObject.fragmentUrl = this._fragmentUrl;
    serializationObject.parameters = this._parameters;
    serializationObject.samplers = this._samplers;
    serializationObject.options = this._options;
    serializationObject.defines = this._postProcessDefines;
    serializationObject.textureFormat = this._textureFormat;
    serializationObject.vertexUrl = this._vertexUrl;
    serializationObject.indexParameters = this._indexParameters;
    return serializationObject;
  }
  clone() {
    const serializationObject = this.serialize();
    serializationObject._engine = this._engine;
    serializationObject.cameraId = null;
    const result = PostProcess.Parse(serializationObject, this._scene, "");
    if (!result) {
      return null;
    }
    result.onActivateObservable = this.onActivateObservable.clone();
    result.onSizeChangedObservable = this.onSizeChangedObservable.clone();
    result.onApplyObservable = this.onApplyObservable.clone();
    result.onBeforeRenderObservable = this.onBeforeRenderObservable.clone();
    result.onAfterRenderObservable = this.onAfterRenderObservable.clone();
    result._prePassEffectConfiguration = this._prePassEffectConfiguration;
    return result;
  }
  static Parse(parsedPostProcess, scene, rootUrl) {
    const postProcessType = GetClass(parsedPostProcess.customType);
    if (!postProcessType || !postProcessType._Parse) {
      return null;
    }
    const camera = scene ? scene.getCameraById(parsedPostProcess.cameraId) : null;
    return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);
  }
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new PostProcess(parsedPostProcess.name, parsedPostProcess.fragmentUrl, parsedPostProcess.parameters, parsedPostProcess.samplers, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable, parsedPostProcess.defines, parsedPostProcess.textureType, parsedPostProcess.vertexUrl, parsedPostProcess.indexParameters, false, parsedPostProcess.textureFormat);
    }, parsedPostProcess, scene, rootUrl);
  }
};
PostProcess._CustomShaderCodeProcessing = {};
__decorate([
  serialize()
], PostProcess.prototype, "uniqueId", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "name", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "width", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "height", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "renderTargetSamplingMode", void 0);
__decorate([
  serializeAsColor4()
], PostProcess.prototype, "clearColor", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "autoClear", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "alphaMode", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "alphaConstants", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "enablePixelPerfectMode", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "forceFullscreenViewport", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "scaleMode", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "alwaysForcePOT", void 0);
__decorate([
  serialize("samples")
], PostProcess.prototype, "_samples", void 0);
__decorate([
  serialize()
], PostProcess.prototype, "adaptScaleToCurrentViewport", void 0);
RegisterClass("BABYLON.PostProcess", PostProcess);

// node_modules/@babylonjs/core/Materials/effectRenderer.js
var defaultOptions = {
  positions: [1, 1, -1, 1, -1, -1, 1, -1],
  indices: [0, 1, 2, 0, 2, 3]
};
var EffectRenderer = class {
  constructor(engine, options = defaultOptions) {
    var _a, _b;
    this._fullscreenViewport = new Viewport(0, 0, 1, 1);
    const positions = (_a = options.positions) !== null && _a !== void 0 ? _a : defaultOptions.positions;
    const indices = (_b = options.indices) !== null && _b !== void 0 ? _b : defaultOptions.indices;
    this.engine = engine;
    this._vertexBuffers = {
      [VertexBuffer.PositionKind]: new VertexBuffer(engine, positions, VertexBuffer.PositionKind, false, false, 2)
    };
    this._indexBuffer = engine.createIndexBuffer(indices);
    this._onContextRestoredObserver = engine.onContextRestoredObservable.add(() => {
      this._indexBuffer = engine.createIndexBuffer(indices);
      for (const key in this._vertexBuffers) {
        const vertexBuffer = this._vertexBuffers[key];
        vertexBuffer._rebuild();
      }
    });
  }
  setViewport(viewport = this._fullscreenViewport) {
    this.engine.setViewport(viewport);
  }
  bindBuffers(effect) {
    this.engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
  }
  applyEffectWrapper(effectWrapper) {
    this.engine.setState(true);
    this.engine.depthCullingState.depthTest = false;
    this.engine.stencilState.stencilTest = false;
    this.engine.enableEffect(effectWrapper._drawWrapper);
    this.bindBuffers(effectWrapper.effect);
    effectWrapper.onApplyObservable.notifyObservers({});
  }
  restoreStates() {
    this.engine.depthCullingState.depthTest = true;
    this.engine.stencilState.stencilTest = true;
  }
  draw() {
    this.engine.drawElementsType(0, 0, 6);
  }
  _isRenderTargetTexture(texture) {
    return texture.renderTarget !== void 0;
  }
  render(effectWrapper, outputTexture = null) {
    if (!effectWrapper.effect.isReady()) {
      return;
    }
    this.setViewport();
    const out = outputTexture === null ? null : this._isRenderTargetTexture(outputTexture) ? outputTexture.renderTarget : outputTexture;
    if (out) {
      this.engine.bindFramebuffer(out);
    }
    this.applyEffectWrapper(effectWrapper);
    this.draw();
    if (out) {
      this.engine.unBindFramebuffer(out);
    }
    this.restoreStates();
  }
  dispose() {
    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      delete this._vertexBuffers[VertexBuffer.PositionKind];
    }
    if (this._indexBuffer) {
      this.engine._releaseBuffer(this._indexBuffer);
    }
    if (this._onContextRestoredObserver) {
      this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver);
      this._onContextRestoredObserver = null;
    }
  }
};
var EffectWrapper = class {
  constructor(creationOptions) {
    this.onApplyObservable = new Observable();
    let effectCreationOptions;
    const uniformNames = creationOptions.uniformNames || [];
    if (creationOptions.vertexShader) {
      effectCreationOptions = {
        fragmentSource: creationOptions.fragmentShader,
        vertexSource: creationOptions.vertexShader,
        spectorName: creationOptions.name || "effectWrapper"
      };
    } else {
      uniformNames.push("scale");
      effectCreationOptions = {
        fragmentSource: creationOptions.fragmentShader,
        vertex: "postprocess",
        spectorName: creationOptions.name || "effectWrapper"
      };
      this.onApplyObservable.add(() => {
        this.effect.setFloat2("scale", 1, 1);
      });
    }
    const defines = creationOptions.defines ? creationOptions.defines.join("\n") : "";
    this._drawWrapper = new DrawWrapper(creationOptions.engine);
    if (creationOptions.useShaderStore) {
      effectCreationOptions.fragment = effectCreationOptions.fragmentSource;
      if (!effectCreationOptions.vertex) {
        effectCreationOptions.vertex = effectCreationOptions.vertexSource;
      }
      delete effectCreationOptions.fragmentSource;
      delete effectCreationOptions.vertexSource;
      this.effect = creationOptions.engine.createEffect(effectCreationOptions, creationOptions.attributeNames || ["position"], uniformNames, creationOptions.samplerNames, defines, void 0, creationOptions.onCompiled, void 0, void 0, creationOptions.shaderLanguage);
    } else {
      this.effect = new Effect(effectCreationOptions, creationOptions.attributeNames || ["position"], uniformNames, creationOptions.samplerNames, creationOptions.engine, defines, void 0, creationOptions.onCompiled, void 0, void 0, void 0, creationOptions.shaderLanguage);
      this._onContextRestoredObserver = creationOptions.engine.onContextRestoredObservable.add(() => {
        this.effect._pipelineContext = null;
        this.effect._wasPreviouslyReady = false;
        this.effect._prepareEffect();
      });
    }
  }
  get effect() {
    return this._drawWrapper.effect;
  }
  set effect(effect) {
    this._drawWrapper.effect = effect;
  }
  dispose() {
    if (this._onContextRestoredObserver) {
      this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
      this._onContextRestoredObserver = null;
    }
    this.effect.dispose();
  }
};

// node_modules/@babylonjs/core/Shaders/pass.fragment.js
var name2 = "passPixelShader";
var shader2 = `varying vec2 vUV;
uniform sampler2D textureSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{
gl_FragColor=texture2D(textureSampler,vUV);
}`;
ShaderStore.ShadersStore[name2] = shader2;
var passPixelShader = { name: name2, shader: shader2 };

// node_modules/@babylonjs/core/Misc/dumpTools.js
var DumpTools = class {
  static _CreateDumpRenderer() {
    if (!DumpTools._DumpToolsEngine) {
      const canvas = document.createElement("canvas");
      const engine = new ThinEngine(canvas, false, {
        preserveDrawingBuffer: true,
        depth: false,
        stencil: false,
        alpha: true,
        premultipliedAlpha: false,
        antialias: false,
        failIfMajorPerformanceCaveat: false
      });
      engine.getCaps().parallelShaderCompile = void 0;
      const renderer = new EffectRenderer(engine);
      const wrapper = new EffectWrapper({
        engine,
        name: passPixelShader.name,
        fragmentShader: passPixelShader.shader,
        samplerNames: ["textureSampler"]
      });
      DumpTools._DumpToolsEngine = {
        canvas,
        engine,
        renderer,
        wrapper
      };
    }
    return DumpTools._DumpToolsEngine;
  }
  static async DumpFramebuffer(width, height, engine, successCallback, mimeType = "image/png", fileName) {
    const bufferView = await engine.readPixels(0, 0, width, height);
    const data = new Uint8Array(bufferView.buffer);
    DumpTools.DumpData(width, height, data, successCallback, mimeType, fileName, true);
  }
  static DumpDataAsync(width, height, data, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
    return new Promise((resolve) => {
      DumpTools.DumpData(width, height, data, (result) => resolve(result), mimeType, fileName, invertY, toArrayBuffer, quality);
    });
  }
  static DumpData(width, height, data, successCallback, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
    const renderer = DumpTools._CreateDumpRenderer();
    renderer.engine.setSize(width, height, true);
    if (data instanceof Float32Array) {
      const data2 = new Uint8Array(data.length);
      let n = data.length;
      while (n--) {
        const v = data[n];
        data2[n] = v < 0 ? 0 : v > 1 ? 1 : Math.round(v * 255);
      }
      data = data2;
    }
    const texture = renderer.engine.createRawTexture(data, width, height, 5, false, !invertY, 1);
    renderer.renderer.setViewport();
    renderer.renderer.applyEffectWrapper(renderer.wrapper);
    renderer.wrapper.effect._bindTexture("textureSampler", texture);
    renderer.renderer.draw();
    if (toArrayBuffer) {
      Tools.ToBlob(renderer.canvas, (blob) => {
        const fileReader = new FileReader();
        fileReader.onload = (event) => {
          const arrayBuffer = event.target.result;
          if (successCallback) {
            successCallback(arrayBuffer);
          }
        };
        fileReader.readAsArrayBuffer(blob);
      }, mimeType, quality);
    } else {
      Tools.EncodeScreenshotCanvasData(renderer.canvas, successCallback, mimeType, fileName, quality);
    }
    texture.dispose();
  }
  static Dispose() {
    if (DumpTools._DumpToolsEngine) {
      DumpTools._DumpToolsEngine.wrapper.dispose();
      DumpTools._DumpToolsEngine.renderer.dispose();
      DumpTools._DumpToolsEngine.engine.dispose();
    }
    DumpTools._DumpToolsEngine = null;
  }
};
var initSideEffects2 = () => {
  Tools.DumpData = DumpTools.DumpData;
  Tools.DumpDataAsync = DumpTools.DumpDataAsync;
  Tools.DumpFramebuffer = DumpTools.DumpFramebuffer;
};
initSideEffects2();

// node_modules/@babylonjs/core/Engines/Extensions/engine.renderTargetCube.js
ThinEngine.prototype.createRenderTargetCubeTexture = function(size, options) {
  const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);
  const fullOptions = {
    generateMipMaps: true,
    generateDepthBuffer: true,
    generateStencilBuffer: false,
    type: 0,
    samplingMode: 3,
    format: 5,
    ...options
  };
  fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;
  if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
    fullOptions.samplingMode = 1;
  } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
    fullOptions.samplingMode = 1;
  }
  const gl = this._gl;
  const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
  const filters = this._getSamplingParameters(fullOptions.samplingMode, fullOptions.generateMipMaps);
  if (fullOptions.type === 1 && !this._caps.textureFloat) {
    fullOptions.type = 0;
    Logger.Warn("Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type");
  }
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  for (let face = 0; face < 6; face++) {
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, this._getRGBABufferInternalSizedFormat(fullOptions.type, fullOptions.format), size, size, 0, this._getInternalFormat(fullOptions.format), this._getWebGLTextureType(fullOptions.type), null);
  }
  const framebuffer = gl.createFramebuffer();
  this._bindUnboundFramebuffer(framebuffer);
  rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(fullOptions.generateStencilBuffer, fullOptions.generateDepthBuffer, size, size);
  if (fullOptions.generateMipMaps) {
    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
  }
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
  this._bindUnboundFramebuffer(null);
  rtWrapper._framebuffer = framebuffer;
  rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
  rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer;
  texture.width = size;
  texture.height = size;
  texture.isReady = true;
  texture.isCube = true;
  texture.samples = 1;
  texture.generateMipMaps = fullOptions.generateMipMaps;
  texture.samplingMode = fullOptions.samplingMode;
  texture.type = fullOptions.type;
  texture.format = fullOptions.format;
  this._internalTexturesCache.push(texture);
  rtWrapper.setTextures(texture);
  return rtWrapper;
};

// node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js
var RenderTargetTexture = class extends Texture {
  constructor(name63, size, scene, generateMipMaps = false, doNotChangeAspectRatio = true, type = 0, isCube = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, generateDepthBuffer = true, generateStencilBuffer = false, isMulti = false, format = 5, delayAllocation = false, samples, creationFlags, noColorAttachment = false, useSRGBBuffer = false) {
    var _a, _b, _c, _d, _e, _f;
    let colorAttachment = void 0;
    if (typeof generateMipMaps === "object") {
      const options = generateMipMaps;
      generateMipMaps = !!options.generateMipMaps;
      doNotChangeAspectRatio = (_a = options.doNotChangeAspectRatio) !== null && _a !== void 0 ? _a : true;
      type = (_b = options.type) !== null && _b !== void 0 ? _b : 0;
      isCube = !!options.isCube;
      samplingMode = (_c = options.samplingMode) !== null && _c !== void 0 ? _c : Texture.TRILINEAR_SAMPLINGMODE;
      generateDepthBuffer = (_d = options.generateDepthBuffer) !== null && _d !== void 0 ? _d : true;
      generateStencilBuffer = !!options.generateStencilBuffer;
      isMulti = !!options.isMulti;
      format = (_e = options.format) !== null && _e !== void 0 ? _e : 5;
      delayAllocation = !!options.delayAllocation;
      samples = options.samples;
      creationFlags = options.creationFlags;
      noColorAttachment = !!options.noColorAttachment;
      useSRGBBuffer = !!options.useSRGBBuffer;
      colorAttachment = options.colorAttachment;
    }
    super(null, scene, !generateMipMaps, void 0, samplingMode, void 0, void 0, void 0, void 0, format);
    this._unObserveRenderList = null;
    this._renderListHasChanged = (_functionName, previousLength) => {
      var _a2;
      const newLength = this._renderList ? this._renderList.length : 0;
      if (previousLength === 0 && newLength > 0 || newLength === 0) {
        (_a2 = this.getScene()) === null || _a2 === void 0 ? void 0 : _a2.meshes.forEach((mesh) => {
          mesh._markSubMeshesAsLightDirty();
        });
      }
    };
    this.renderParticles = true;
    this.renderSprites = false;
    this.forceLayerMaskCheck = false;
    this.ignoreCameraViewport = false;
    this.onBeforeBindObservable = new Observable();
    this.onAfterUnbindObservable = new Observable();
    this.onBeforeRenderObservable = new Observable();
    this.onAfterRenderObservable = new Observable();
    this.onClearObservable = new Observable();
    this.onResizeObservable = new Observable();
    this._cleared = false;
    this.skipInitialClear = false;
    this._currentRefreshId = -1;
    this._refreshRate = 1;
    this._samples = 1;
    this._canRescale = true;
    this._renderTarget = null;
    this.boundingBoxPosition = Vector3.Zero();
    scene = this.getScene();
    if (!scene) {
      return;
    }
    const engine = this.getScene().getEngine();
    this._coordinatesMode = Texture.PROJECTION_MODE;
    this.renderList = new Array();
    this.name = name63;
    this.isRenderTarget = true;
    this._initialSizeParameter = size;
    this._renderPassIds = [];
    this._isCubeData = isCube;
    this._processSizeParameter(size);
    this.renderPassId = this._renderPassIds[0];
    this._resizeObserver = engine.onResizeObservable.add(() => {
    });
    this._generateMipMaps = generateMipMaps ? true : false;
    this._doNotChangeAspectRatio = doNotChangeAspectRatio;
    this._renderingManager = new RenderingManager(scene);
    this._renderingManager._useSceneAutoClearSetup = true;
    if (isMulti) {
      return;
    }
    this._renderTargetOptions = {
      generateMipMaps,
      type,
      format: (_f = this._format) !== null && _f !== void 0 ? _f : void 0,
      samplingMode: this.samplingMode,
      generateDepthBuffer,
      generateStencilBuffer,
      samples,
      creationFlags,
      noColorAttachment,
      useSRGBBuffer,
      colorAttachment
    };
    if (this.samplingMode === Texture.NEAREST_SAMPLINGMODE) {
      this.wrapU = Texture.CLAMP_ADDRESSMODE;
      this.wrapV = Texture.CLAMP_ADDRESSMODE;
    }
    if (!delayAllocation) {
      if (isCube) {
        this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);
        this.coordinatesMode = Texture.INVCUBIC_MODE;
        this._textureMatrix = Matrix.Identity();
      } else {
        this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);
      }
      this._texture = this._renderTarget.texture;
      if (samples !== void 0) {
        this.samples = samples;
      }
    }
  }
  get renderList() {
    return this._renderList;
  }
  set renderList(value) {
    if (this._unObserveRenderList) {
      this._unObserveRenderList();
      this._unObserveRenderList = null;
    }
    if (value) {
      this._unObserveRenderList = _ObserveArray(value, this._renderListHasChanged);
    }
    this._renderList = value;
  }
  get postProcesses() {
    return this._postProcesses;
  }
  get _prePassEnabled() {
    return !!this._prePassRenderTarget && this._prePassRenderTarget.enabled;
  }
  set onAfterUnbind(callback) {
    if (this._onAfterUnbindObserver) {
      this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);
    }
    this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);
  }
  set onBeforeRender(callback) {
    if (this._onBeforeRenderObserver) {
      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
    }
    this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
  }
  set onAfterRender(callback) {
    if (this._onAfterRenderObserver) {
      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
    }
    this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
  }
  set onClear(callback) {
    if (this._onClearObserver) {
      this.onClearObservable.remove(this._onClearObserver);
    }
    this._onClearObserver = this.onClearObservable.add(callback);
  }
  get renderPassIds() {
    return this._renderPassIds;
  }
  get currentRefreshId() {
    return this._currentRefreshId;
  }
  setMaterialForRendering(mesh, material) {
    let meshes;
    if (!Array.isArray(mesh)) {
      meshes = [mesh];
    } else {
      meshes = mesh;
    }
    for (let j = 0; j < meshes.length; ++j) {
      for (let i = 0; i < this._renderPassIds.length; ++i) {
        meshes[j].setMaterialForRenderPass(this._renderPassIds[i], material !== void 0 ? Array.isArray(material) ? material[i] : material : void 0);
      }
    }
  }
  get renderTargetOptions() {
    return this._renderTargetOptions;
  }
  get renderTarget() {
    return this._renderTarget;
  }
  _onRatioRescale() {
    if (this._sizeRatio) {
      this.resize(this._initialSizeParameter);
    }
  }
  set boundingBoxSize(value) {
    if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
      return;
    }
    this._boundingBoxSize = value;
    const scene = this.getScene();
    if (scene) {
      scene.markAllMaterialsAsDirty(1);
    }
  }
  get boundingBoxSize() {
    return this._boundingBoxSize;
  }
  get depthStencilTexture() {
    var _a, _b;
    return (_b = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a._depthStencilTexture) !== null && _b !== void 0 ? _b : null;
  }
  createDepthStencilTexture(comparisonFunction = 0, bilinearFiltering = true, generateStencil = false, samples = 1, format = 14) {
    var _a;
    (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.createDepthStencilTexture(comparisonFunction, bilinearFiltering, generateStencil, samples, format);
  }
  _releaseRenderPassId() {
    if (this._scene) {
      const engine = this._scene.getEngine();
      for (let i = 0; i < this._renderPassIds.length; ++i) {
        engine.releaseRenderPassId(this._renderPassIds[i]);
      }
    }
    this._renderPassIds = [];
  }
  _createRenderPassId() {
    this._releaseRenderPassId();
    const engine = this._scene.getEngine();
    const numPasses = this._isCubeData ? 6 : this.getRenderLayers() || 1;
    for (let i = 0; i < numPasses; ++i) {
      this._renderPassIds[i] = engine.createRenderPassId(`RenderTargetTexture - ${this.name}#${i}`);
    }
  }
  _processSizeParameter(size) {
    if (size.ratio) {
      this._sizeRatio = size.ratio;
      const engine = this._getEngine();
      this._size = {
        width: this._bestReflectionRenderTargetDimension(engine.getRenderWidth(), this._sizeRatio),
        height: this._bestReflectionRenderTargetDimension(engine.getRenderHeight(), this._sizeRatio)
      };
    } else {
      this._size = size;
    }
    this._createRenderPassId();
  }
  get samples() {
    var _a, _b;
    return (_b = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.samples) !== null && _b !== void 0 ? _b : this._samples;
  }
  set samples(value) {
    if (this._renderTarget) {
      this._samples = this._renderTarget.setSamples(value);
    }
  }
  resetRefreshCounter() {
    this._currentRefreshId = -1;
  }
  get refreshRate() {
    return this._refreshRate;
  }
  set refreshRate(value) {
    this._refreshRate = value;
    this.resetRefreshCounter();
  }
  addPostProcess(postProcess) {
    if (!this._postProcessManager) {
      const scene = this.getScene();
      if (!scene) {
        return;
      }
      this._postProcessManager = new PostProcessManager(scene);
      this._postProcesses = new Array();
    }
    this._postProcesses.push(postProcess);
    this._postProcesses[0].autoClear = false;
  }
  clearPostProcesses(dispose = false) {
    if (!this._postProcesses) {
      return;
    }
    if (dispose) {
      for (const postProcess of this._postProcesses) {
        postProcess.dispose();
      }
    }
    this._postProcesses = [];
  }
  removePostProcess(postProcess) {
    if (!this._postProcesses) {
      return;
    }
    const index = this._postProcesses.indexOf(postProcess);
    if (index === -1) {
      return;
    }
    this._postProcesses.splice(index, 1);
    if (this._postProcesses.length > 0) {
      this._postProcesses[0].autoClear = false;
    }
  }
  _shouldRender() {
    if (this._currentRefreshId === -1) {
      this._currentRefreshId = 1;
      return true;
    }
    if (this.refreshRate === this._currentRefreshId) {
      this._currentRefreshId = 1;
      return true;
    }
    this._currentRefreshId++;
    return false;
  }
  getRenderSize() {
    return this.getRenderWidth();
  }
  getRenderWidth() {
    if (this._size.width) {
      return this._size.width;
    }
    return this._size;
  }
  getRenderHeight() {
    if (this._size.width) {
      return this._size.height;
    }
    return this._size;
  }
  getRenderLayers() {
    const layers = this._size.layers;
    if (layers) {
      return layers;
    }
    return 0;
  }
  disableRescaling() {
    this._canRescale = false;
  }
  get canRescale() {
    return this._canRescale;
  }
  scale(ratio) {
    const newSize = Math.max(1, this.getRenderSize() * ratio);
    this.resize(newSize);
  }
  getReflectionTextureMatrix() {
    if (this.isCube) {
      return this._textureMatrix;
    }
    return super.getReflectionTextureMatrix();
  }
  resize(size) {
    var _a;
    const wasCube = this.isCube;
    (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose();
    this._renderTarget = null;
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    this._processSizeParameter(size);
    if (wasCube) {
      this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);
    } else {
      this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);
    }
    this._texture = this._renderTarget.texture;
    if (this._renderTargetOptions.samples !== void 0) {
      this.samples = this._renderTargetOptions.samples;
    }
    if (this.onResizeObservable.hasObservers()) {
      this.onResizeObservable.notifyObservers(this);
    }
  }
  render(useCameraPostProcess = false, dumpForDebug = false) {
    this._render(useCameraPostProcess, dumpForDebug);
  }
  isReadyForRendering() {
    return this._render(false, false, true);
  }
  _render(useCameraPostProcess = false, dumpForDebug = false, checkReadiness = false) {
    var _a;
    const scene = this.getScene();
    if (!scene) {
      return checkReadiness;
    }
    const engine = scene.getEngine();
    if (this.useCameraPostProcesses !== void 0) {
      useCameraPostProcess = this.useCameraPostProcesses;
    }
    if (this._waitingRenderList) {
      this.renderList = [];
      for (let index = 0; index < this._waitingRenderList.length; index++) {
        const id = this._waitingRenderList[index];
        const mesh = scene.getMeshById(id);
        if (mesh) {
          this.renderList.push(mesh);
        }
      }
      this._waitingRenderList = void 0;
    }
    if (this.renderListPredicate) {
      if (this.renderList) {
        this.renderList.length = 0;
      } else {
        this.renderList = [];
      }
      const scene2 = this.getScene();
      if (!scene2) {
        return checkReadiness;
      }
      const sceneMeshes = scene2.meshes;
      for (let index = 0; index < sceneMeshes.length; index++) {
        const mesh = sceneMeshes[index];
        if (this.renderListPredicate(mesh)) {
          this.renderList.push(mesh);
        }
      }
    }
    const currentRenderPassId = engine.currentRenderPassId;
    this.onBeforeBindObservable.notifyObservers(this);
    const camera = (_a = this.activeCamera) !== null && _a !== void 0 ? _a : scene.activeCamera;
    const sceneCamera = scene.activeCamera;
    if (camera) {
      if (camera !== scene.activeCamera) {
        scene.setTransformMatrix(camera.getViewMatrix(), camera.getProjectionMatrix(true));
        scene.activeCamera = camera;
      }
      engine.setViewport(camera.viewport, this.getRenderWidth(), this.getRenderHeight());
    }
    this._defaultRenderListPrepared = false;
    let returnValue = checkReadiness;
    if (!checkReadiness) {
      if (this.is2DArray) {
        for (let layer = 0; layer < this.getRenderLayers(); layer++) {
          this._renderToTarget(0, useCameraPostProcess, dumpForDebug, layer, camera);
          scene.incrementRenderId();
          scene.resetCachedMaterial();
        }
      } else if (this.isCube) {
        for (let face = 0; face < 6; face++) {
          this._renderToTarget(face, useCameraPostProcess, dumpForDebug, void 0, camera);
          scene.incrementRenderId();
          scene.resetCachedMaterial();
        }
      } else {
        this._renderToTarget(0, useCameraPostProcess, dumpForDebug, void 0, camera);
      }
    } else {
      if (!scene.getViewMatrix()) {
        scene.updateTransformMatrix();
      }
      const numLayers = this.is2DArray ? this.getRenderLayers() : this.isCube ? 6 : 1;
      for (let layer = 0; layer < numLayers && returnValue; layer++) {
        let currentRenderList = null;
        const defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;
        const defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;
        engine.currentRenderPassId = this._renderPassIds[layer];
        this.onBeforeRenderObservable.notifyObservers(layer);
        if (this.getCustomRenderList) {
          currentRenderList = this.getCustomRenderList(layer, defaultRenderList, defaultRenderListLength);
        }
        if (!currentRenderList) {
          currentRenderList = defaultRenderList;
        }
        if (!this._doNotChangeAspectRatio) {
          scene.updateTransformMatrix(true);
        }
        for (let i = 0; i < currentRenderList.length && returnValue; ++i) {
          const mesh = currentRenderList[i];
          if (!mesh.isEnabled() || mesh.isBlocked || !mesh.isVisible || !mesh.subMeshes) {
            continue;
          }
          if (this.customIsReadyFunction) {
            if (!this.customIsReadyFunction(mesh, this.refreshRate, checkReadiness)) {
              returnValue = false;
              continue;
            }
          } else if (!mesh.isReady(true)) {
            returnValue = false;
            continue;
          }
        }
        this.onAfterRenderObservable.notifyObservers(layer);
        if (this.is2DArray || this.isCube) {
          scene.incrementRenderId();
          scene.resetCachedMaterial();
        }
      }
    }
    this.onAfterUnbindObservable.notifyObservers(this);
    engine.currentRenderPassId = currentRenderPassId;
    if (sceneCamera) {
      scene.activeCamera = sceneCamera;
      if (scene.getEngine().scenes.length > 1 || this.activeCamera && this.activeCamera !== scene.activeCamera) {
        scene.setTransformMatrix(scene.activeCamera.getViewMatrix(), scene.activeCamera.getProjectionMatrix(true));
      }
      engine.setViewport(scene.activeCamera.viewport);
    }
    scene.resetCachedMaterial();
    return returnValue;
  }
  _bestReflectionRenderTargetDimension(renderDimension, scale) {
    const minimum = 128;
    const x = renderDimension * scale;
    const curved = Engine.NearestPOT(x + minimum * minimum / (minimum + x));
    return Math.min(Engine.FloorPOT(renderDimension), curved);
  }
  _prepareRenderingManager(currentRenderList, currentRenderListLength, camera, checkLayerMask) {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    this._renderingManager.reset();
    const sceneRenderId = scene.getRenderId();
    for (let meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {
      const mesh = currentRenderList[meshIndex];
      if (mesh && !mesh.isBlocked) {
        if (this.customIsReadyFunction) {
          if (!this.customIsReadyFunction(mesh, this.refreshRate, false)) {
            this.resetRefreshCounter();
            continue;
          }
        } else if (!mesh.isReady(this.refreshRate === 0)) {
          this.resetRefreshCounter();
          continue;
        }
        if (!mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate && scene.activeCamera) {
          mesh._internalAbstractMeshDataInfo._currentLOD = scene.customLODSelector ? scene.customLODSelector(mesh, this.activeCamera || scene.activeCamera) : mesh.getLOD(this.activeCamera || scene.activeCamera);
          mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;
        }
        if (!mesh._internalAbstractMeshDataInfo._currentLOD) {
          continue;
        }
        let meshToRender = mesh._internalAbstractMeshDataInfo._currentLOD;
        meshToRender._preActivateForIntermediateRendering(sceneRenderId);
        let isMasked;
        if (checkLayerMask && camera) {
          isMasked = (mesh.layerMask & camera.layerMask) === 0;
        } else {
          isMasked = false;
        }
        if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {
          if (meshToRender !== mesh) {
            meshToRender._activate(sceneRenderId, true);
          }
          if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {
            if (!mesh.isAnInstance) {
              meshToRender._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;
            } else {
              if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {
                meshToRender = mesh;
              }
            }
            meshToRender._internalAbstractMeshDataInfo._isActiveIntermediate = true;
            for (let subIndex = 0; subIndex < meshToRender.subMeshes.length; subIndex++) {
              const subMesh = meshToRender.subMeshes[subIndex];
              this._renderingManager.dispatch(subMesh, meshToRender);
            }
          }
        }
      }
    }
    for (let particleIndex = 0; particleIndex < scene.particleSystems.length; particleIndex++) {
      const particleSystem = scene.particleSystems[particleIndex];
      const emitter = particleSystem.emitter;
      if (!particleSystem.isStarted() || !emitter || !emitter.position || !emitter.isEnabled()) {
        continue;
      }
      if (currentRenderList.indexOf(emitter) >= 0) {
        this._renderingManager.dispatchParticles(particleSystem);
      }
    }
  }
  _bindFrameBuffer(faceIndex = 0, layer = 0) {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    const engine = scene.getEngine();
    if (this._renderTarget) {
      engine.bindFramebuffer(this._renderTarget, this.isCube ? faceIndex : void 0, void 0, void 0, this.ignoreCameraViewport, 0, layer);
    }
  }
  _unbindFrameBuffer(engine, faceIndex) {
    if (!this._renderTarget) {
      return;
    }
    engine.unBindFramebuffer(this._renderTarget, this.isCube, () => {
      this.onAfterRenderObservable.notifyObservers(faceIndex);
    });
  }
  _prepareFrame(scene, faceIndex, layer, useCameraPostProcess) {
    if (this._postProcessManager) {
      if (!this._prePassEnabled) {
        this._postProcessManager._prepareFrame(this._texture, this._postProcesses);
      }
    } else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {
      this._bindFrameBuffer(faceIndex, layer);
    }
  }
  _renderToTarget(faceIndex, useCameraPostProcess, dumpForDebug, layer = 0, camera = null) {
    var _a, _b, _c, _d, _e, _f;
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    const engine = scene.getEngine();
    (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `render to face #${faceIndex} layer #${layer}`, 1);
    this._prepareFrame(scene, faceIndex, layer, useCameraPostProcess);
    if (this.is2DArray) {
      engine.currentRenderPassId = this._renderPassIds[layer];
      this.onBeforeRenderObservable.notifyObservers(layer);
    } else {
      engine.currentRenderPassId = this._renderPassIds[faceIndex];
      this.onBeforeRenderObservable.notifyObservers(faceIndex);
    }
    const fastPath = engine.snapshotRendering && engine.snapshotRenderingMode === 1;
    if (!fastPath) {
      let currentRenderList = null;
      const defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;
      const defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;
      if (this.getCustomRenderList) {
        currentRenderList = this.getCustomRenderList(this.is2DArray ? layer : faceIndex, defaultRenderList, defaultRenderListLength);
      }
      if (!currentRenderList) {
        if (!this._defaultRenderListPrepared) {
          this._prepareRenderingManager(defaultRenderList, defaultRenderListLength, camera, !this.renderList || this.forceLayerMaskCheck);
          this._defaultRenderListPrepared = true;
        }
        currentRenderList = defaultRenderList;
      } else {
        this._prepareRenderingManager(currentRenderList, currentRenderList.length, camera, this.forceLayerMaskCheck);
      }
      for (const step of scene._beforeRenderTargetClearStage) {
        step.action(this, faceIndex, layer);
      }
      if (this.onClearObservable.hasObservers()) {
        this.onClearObservable.notifyObservers(engine);
      } else {
        if (!this.skipInitialClear) {
          engine.clear(this.clearColor || scene.clearColor, true, true, true);
        }
      }
      if (!this._doNotChangeAspectRatio) {
        scene.updateTransformMatrix(true);
      }
      for (const step of scene._beforeRenderTargetDrawStage) {
        step.action(this, faceIndex, layer);
      }
      this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites);
      for (const step of scene._afterRenderTargetDrawStage) {
        step.action(this, faceIndex, layer);
      }
      const saveGenerateMipMaps = (_c = (_b = this._texture) === null || _b === void 0 ? void 0 : _b.generateMipMaps) !== null && _c !== void 0 ? _c : false;
      if (this._texture) {
        this._texture.generateMipMaps = false;
      }
      if (this._postProcessManager) {
        this._postProcessManager._finalizeFrame(false, (_d = this._renderTarget) !== null && _d !== void 0 ? _d : void 0, faceIndex, this._postProcesses, this.ignoreCameraViewport);
      } else if (useCameraPostProcess) {
        scene.postProcessManager._finalizeFrame(false, (_e = this._renderTarget) !== null && _e !== void 0 ? _e : void 0, faceIndex);
      }
      for (const step of scene._afterRenderTargetPostProcessStage) {
        step.action(this, faceIndex, layer);
      }
      if (this._texture) {
        this._texture.generateMipMaps = saveGenerateMipMaps;
      }
      if (!this._doNotChangeAspectRatio) {
        scene.updateTransformMatrix(true);
      }
      if (dumpForDebug) {
        DumpTools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);
      }
    } else {
      if (this.onClearObservable.hasObservers()) {
        this.onClearObservable.notifyObservers(engine);
      } else {
        if (!this.skipInitialClear) {
          engine.clear(this.clearColor || scene.clearColor, true, true, true);
        }
      }
    }
    this._unbindFrameBuffer(engine, faceIndex);
    if (this._texture && this.isCube && faceIndex === 5) {
      engine.generateMipMapsForCubemap(this._texture);
    }
    (_f = engine._debugPopGroup) === null || _f === void 0 ? void 0 : _f.call(engine, 1);
  }
  setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
  }
  setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil) {
    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);
    this._renderingManager._useSceneAutoClearSetup = false;
  }
  clone() {
    const textureSize = this.getSize();
    const newTexture = new RenderTargetTexture(this.name, textureSize, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer, void 0, this._renderTargetOptions.format, void 0, this._renderTargetOptions.samples);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.coordinatesMode = this.coordinatesMode;
    if (this.renderList) {
      newTexture.renderList = this.renderList.slice(0);
    }
    return newTexture;
  }
  serialize() {
    if (!this.name) {
      return null;
    }
    const serializationObject = super.serialize();
    serializationObject.renderTargetSize = this.getRenderSize();
    serializationObject.renderList = [];
    if (this.renderList) {
      for (let index = 0; index < this.renderList.length; index++) {
        serializationObject.renderList.push(this.renderList[index].id);
      }
    }
    return serializationObject;
  }
  disposeFramebufferObjects() {
    var _a;
    (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose(true);
  }
  releaseInternalTexture() {
    var _a;
    (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.releaseTextures();
    this._texture = null;
  }
  dispose() {
    var _a;
    this.onResizeObservable.clear();
    this.onClearObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onAfterUnbindObservable.clear();
    this.onBeforeBindObservable.clear();
    this.onBeforeRenderObservable.clear();
    if (this._postProcessManager) {
      this._postProcessManager.dispose();
      this._postProcessManager = null;
    }
    if (this._prePassRenderTarget) {
      this._prePassRenderTarget.dispose();
    }
    this._releaseRenderPassId();
    this.clearPostProcesses(true);
    if (this._resizeObserver) {
      this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver);
      this._resizeObserver = null;
    }
    this.renderList = null;
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    let index = scene.customRenderTargets.indexOf(this);
    if (index >= 0) {
      scene.customRenderTargets.splice(index, 1);
    }
    for (const camera of scene.cameras) {
      index = camera.customRenderTargets.indexOf(this);
      if (index >= 0) {
        camera.customRenderTargets.splice(index, 1);
      }
    }
    (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose();
    this._renderTarget = null;
    this._texture = null;
    super.dispose();
  }
  _rebuild() {
    if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {
      this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
    }
    if (this._postProcessManager) {
      this._postProcessManager._rebuild();
    }
  }
  freeRenderingGroups() {
    if (this._renderingManager) {
      this._renderingManager.freeRenderingGroups();
    }
  }
  getViewCount() {
    return 1;
  }
};
RenderTargetTexture.REFRESHRATE_RENDER_ONCE = 0;
RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME = 1;
RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2;
Texture._CreateRenderTargetTexture = (name63, renderTargetSize, scene, generateMipMaps, creationFlags) => {
  return new RenderTargetTexture(name63, renderTargetSize, scene, generateMipMaps);
};

// node_modules/@babylonjs/core/Lights/light.js
var Light = class extends Node {
  constructor(name63, scene) {
    super(name63, scene);
    this.diffuse = new Color3(1, 1, 1);
    this.specular = new Color3(1, 1, 1);
    this.falloffType = Light.FALLOFF_DEFAULT;
    this.intensity = 1;
    this._range = Number.MAX_VALUE;
    this._inverseSquaredRange = 0;
    this._photometricScale = 1;
    this._intensityMode = Light.INTENSITYMODE_AUTOMATIC;
    this._radius = 1e-5;
    this.renderPriority = 0;
    this._shadowEnabled = true;
    this._excludeWithLayerMask = 0;
    this._includeOnlyWithLayerMask = 0;
    this._lightmapMode = 0;
    this._shadowGenerators = null;
    this._excludedMeshesIds = new Array();
    this._includedOnlyMeshesIds = new Array();
    this._isLight = true;
    this.getScene().addLight(this);
    this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), void 0, void 0, name63);
    this._buildUniformLayout();
    this.includedOnlyMeshes = new Array();
    this.excludedMeshes = new Array();
    this._resyncMeshes();
  }
  get range() {
    return this._range;
  }
  set range(value) {
    this._range = value;
    this._inverseSquaredRange = 1 / (this.range * this.range);
  }
  get intensityMode() {
    return this._intensityMode;
  }
  set intensityMode(value) {
    this._intensityMode = value;
    this._computePhotometricScale();
  }
  get radius() {
    return this._radius;
  }
  set radius(value) {
    this._radius = value;
    this._computePhotometricScale();
  }
  get shadowEnabled() {
    return this._shadowEnabled;
  }
  set shadowEnabled(value) {
    if (this._shadowEnabled === value) {
      return;
    }
    this._shadowEnabled = value;
    this._markMeshesAsLightDirty();
  }
  get includedOnlyMeshes() {
    return this._includedOnlyMeshes;
  }
  set includedOnlyMeshes(value) {
    this._includedOnlyMeshes = value;
    this._hookArrayForIncludedOnly(value);
  }
  get excludedMeshes() {
    return this._excludedMeshes;
  }
  set excludedMeshes(value) {
    this._excludedMeshes = value;
    this._hookArrayForExcluded(value);
  }
  get excludeWithLayerMask() {
    return this._excludeWithLayerMask;
  }
  set excludeWithLayerMask(value) {
    this._excludeWithLayerMask = value;
    this._resyncMeshes();
  }
  get includeOnlyWithLayerMask() {
    return this._includeOnlyWithLayerMask;
  }
  set includeOnlyWithLayerMask(value) {
    this._includeOnlyWithLayerMask = value;
    this._resyncMeshes();
  }
  get lightmapMode() {
    return this._lightmapMode;
  }
  set lightmapMode(value) {
    if (this._lightmapMode === value) {
      return;
    }
    this._lightmapMode = value;
    this._markMeshesAsLightDirty();
  }
  transferTexturesToEffect(effect, lightIndex) {
    return this;
  }
  _bindLight(lightIndex, scene, effect, useSpecular, receiveShadows = true) {
    var _a;
    const iAsString = lightIndex.toString();
    let needUpdate = false;
    this._uniformBuffer.bindToEffect(effect, "Light" + iAsString);
    if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {
      this._renderId = scene.getRenderId();
      this._lastUseSpecular = useSpecular;
      const scaledIntensity = this.getScaledIntensity();
      this.transferToEffect(effect, iAsString);
      this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);
      this._uniformBuffer.updateColor4("vLightDiffuse", TmpColors.Color3[0], this.range, iAsString);
      if (useSpecular) {
        this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);
        this._uniformBuffer.updateColor4("vLightSpecular", TmpColors.Color3[1], this.radius, iAsString);
      }
      needUpdate = true;
    }
    this.transferTexturesToEffect(effect, iAsString);
    if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {
      const shadowGenerator = (_a = this.getShadowGenerator(scene.activeCamera)) !== null && _a !== void 0 ? _a : this.getShadowGenerator();
      if (shadowGenerator) {
        shadowGenerator.bindShadowLight(iAsString, effect);
        needUpdate = true;
      }
    }
    if (needUpdate) {
      this._uniformBuffer.update();
    } else {
      this._uniformBuffer.bindUniformBuffer();
    }
  }
  getClassName() {
    return "Light";
  }
  toString(fullDetails) {
    let ret = "Name: " + this.name;
    ret += ", type: " + ["Point", "Directional", "Spot", "Hemispheric"][this.getTypeID()];
    if (this.animations) {
      for (let i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    return ret;
  }
  _syncParentEnabledState() {
    super._syncParentEnabledState();
    if (!this.isDisposed()) {
      this._resyncMeshes();
    }
  }
  setEnabled(value) {
    super.setEnabled(value);
    this._resyncMeshes();
  }
  getShadowGenerator(camera = null) {
    var _a;
    if (this._shadowGenerators === null) {
      return null;
    }
    return (_a = this._shadowGenerators.get(camera)) !== null && _a !== void 0 ? _a : null;
  }
  getShadowGenerators() {
    return this._shadowGenerators;
  }
  getAbsolutePosition() {
    return Vector3.Zero();
  }
  canAffectMesh(mesh) {
    if (!mesh) {
      return true;
    }
    if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {
      return false;
    }
    if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {
      return false;
    }
    if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {
      return false;
    }
    if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {
      return false;
    }
    return true;
  }
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    if (this._shadowGenerators) {
      const iterator = this._shadowGenerators.values();
      for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
        const shadowGenerator = key.value;
        shadowGenerator.dispose();
      }
      this._shadowGenerators = null;
    }
    this.getScene().stopAnimation(this);
    if (this._parentContainer) {
      const index = this._parentContainer.lights.indexOf(this);
      if (index > -1) {
        this._parentContainer.lights.splice(index, 1);
      }
      this._parentContainer = null;
    }
    for (const mesh of this.getScene().meshes) {
      mesh._removeLightSource(this, true);
    }
    this._uniformBuffer.dispose();
    this.getScene().removeLight(this);
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  getTypeID() {
    return 0;
  }
  getScaledIntensity() {
    return this._photometricScale * this.intensity;
  }
  clone(name63, newParent = null) {
    const constructor = Light.GetConstructorFromName(this.getTypeID(), name63, this.getScene());
    if (!constructor) {
      return null;
    }
    const clonedLight = SerializationHelper.Clone(constructor, this);
    if (name63) {
      clonedLight.name = name63;
    }
    if (newParent) {
      clonedLight.parent = newParent;
    }
    clonedLight.setEnabled(this.isEnabled());
    this.onClonedObservable.notifyObservers(clonedLight);
    return clonedLight;
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getTypeID();
    if (this.parent) {
      this.parent._serializeAsParent(serializationObject);
    }
    if (this.excludedMeshes.length > 0) {
      serializationObject.excludedMeshesIds = [];
      this.excludedMeshes.forEach((mesh) => {
        serializationObject.excludedMeshesIds.push(mesh.id);
      });
    }
    if (this.includedOnlyMeshes.length > 0) {
      serializationObject.includedOnlyMeshesIds = [];
      this.includedOnlyMeshes.forEach((mesh) => {
        serializationObject.includedOnlyMeshesIds.push(mesh.id);
      });
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.isEnabled = this.isEnabled();
    return serializationObject;
  }
  static GetConstructorFromName(type, name63, scene) {
    const constructorFunc = Node.Construct("Light_Type_" + type, name63, scene);
    if (constructorFunc) {
      return constructorFunc;
    }
    return null;
  }
  static Parse(parsedLight, scene) {
    const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);
    if (!constructor) {
      return null;
    }
    const light = SerializationHelper.Parse(constructor, parsedLight, scene);
    if (parsedLight.excludedMeshesIds) {
      light._excludedMeshesIds = parsedLight.excludedMeshesIds;
    }
    if (parsedLight.includedOnlyMeshesIds) {
      light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;
    }
    if (parsedLight.parentId !== void 0) {
      light._waitingParentId = parsedLight.parentId;
    }
    if (parsedLight.parentInstanceIndex !== void 0) {
      light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;
    }
    if (parsedLight.falloffType !== void 0) {
      light.falloffType = parsedLight.falloffType;
    }
    if (parsedLight.lightmapMode !== void 0) {
      light.lightmapMode = parsedLight.lightmapMode;
    }
    if (parsedLight.animations) {
      for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {
        const parsedAnimation = parsedLight.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          light.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(light, parsedLight, scene);
    }
    if (parsedLight.autoAnimate) {
      scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1);
    }
    if (parsedLight.isEnabled !== void 0) {
      light.setEnabled(parsedLight.isEnabled);
    }
    return light;
  }
  _hookArrayForExcluded(array) {
    const oldPush = array.push;
    array.push = (...items) => {
      const result = oldPush.apply(array, items);
      for (const item of items) {
        item._resyncLightSource(this);
      }
      return result;
    };
    const oldSplice = array.splice;
    array.splice = (index, deleteCount) => {
      const deleted = oldSplice.apply(array, [index, deleteCount]);
      for (const item of deleted) {
        item._resyncLightSource(this);
      }
      return deleted;
    };
    for (const item of array) {
      item._resyncLightSource(this);
    }
  }
  _hookArrayForIncludedOnly(array) {
    const oldPush = array.push;
    array.push = (...items) => {
      const result = oldPush.apply(array, items);
      this._resyncMeshes();
      return result;
    };
    const oldSplice = array.splice;
    array.splice = (index, deleteCount) => {
      const deleted = oldSplice.apply(array, [index, deleteCount]);
      this._resyncMeshes();
      return deleted;
    };
    this._resyncMeshes();
  }
  _resyncMeshes() {
    for (const mesh of this.getScene().meshes) {
      mesh._resyncLightSource(this);
    }
  }
  _markMeshesAsLightDirty() {
    for (const mesh of this.getScene().meshes) {
      if (mesh.lightSources.indexOf(this) !== -1) {
        mesh._markSubMeshesAsLightDirty();
      }
    }
  }
  _computePhotometricScale() {
    this._photometricScale = this._getPhotometricScale();
    this.getScene().resetCachedMaterial();
  }
  _getPhotometricScale() {
    let photometricScale = 0;
    const lightTypeID = this.getTypeID();
    let photometricMode = this.intensityMode;
    if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {
      if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
        photometricMode = Light.INTENSITYMODE_ILLUMINANCE;
      } else {
        photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;
      }
    }
    switch (lightTypeID) {
      case Light.LIGHTTYPEID_POINTLIGHT:
      case Light.LIGHTTYPEID_SPOTLIGHT:
        switch (photometricMode) {
          case Light.INTENSITYMODE_LUMINOUSPOWER:
            photometricScale = 1 / (4 * Math.PI);
            break;
          case Light.INTENSITYMODE_LUMINOUSINTENSITY:
            photometricScale = 1;
            break;
          case Light.INTENSITYMODE_LUMINANCE:
            photometricScale = this.radius * this.radius;
            break;
        }
        break;
      case Light.LIGHTTYPEID_DIRECTIONALLIGHT:
        switch (photometricMode) {
          case Light.INTENSITYMODE_ILLUMINANCE:
            photometricScale = 1;
            break;
          case Light.INTENSITYMODE_LUMINANCE: {
            let apexAngleRadians = this.radius;
            apexAngleRadians = Math.max(apexAngleRadians, 1e-3);
            const solidAngle = 2 * Math.PI * (1 - Math.cos(apexAngleRadians));
            photometricScale = solidAngle;
            break;
          }
        }
        break;
      case Light.LIGHTTYPEID_HEMISPHERICLIGHT:
        photometricScale = 1;
        break;
    }
    return photometricScale;
  }
  _reorderLightsInScene() {
    const scene = this.getScene();
    if (this._renderPriority != 0) {
      scene.requireLightSorting = true;
    }
    this.getScene().sortLightsByPriority();
  }
};
Light.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;
Light.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;
Light.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;
Light.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;
Light.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;
Light.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;
Light.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;
Light.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;
Light.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;
Light.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;
Light.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;
Light.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;
Light.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;
Light.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;
Light.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;
Light.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;
__decorate([
  serializeAsColor3()
], Light.prototype, "diffuse", void 0);
__decorate([
  serializeAsColor3()
], Light.prototype, "specular", void 0);
__decorate([
  serialize()
], Light.prototype, "falloffType", void 0);
__decorate([
  serialize()
], Light.prototype, "intensity", void 0);
__decorate([
  serialize()
], Light.prototype, "range", null);
__decorate([
  serialize()
], Light.prototype, "intensityMode", null);
__decorate([
  serialize()
], Light.prototype, "radius", null);
__decorate([
  serialize()
], Light.prototype, "_renderPriority", void 0);
__decorate([
  expandToProperty("_reorderLightsInScene")
], Light.prototype, "renderPriority", void 0);
__decorate([
  serialize("shadowEnabled")
], Light.prototype, "_shadowEnabled", void 0);
__decorate([
  serialize("excludeWithLayerMask")
], Light.prototype, "_excludeWithLayerMask", void 0);
__decorate([
  serialize("includeOnlyWithLayerMask")
], Light.prototype, "_includeOnlyWithLayerMask", void 0);
__decorate([
  serialize("lightmapMode")
], Light.prototype, "_lightmapMode", void 0);

// node_modules/@babylonjs/core/Lights/hemisphericLight.js
Node.AddNodeConstructor("Light_Type_3", (name63, scene) => {
  return () => new HemisphericLight(name63, Vector3.Zero(), scene);
});
var HemisphericLight = class extends Light {
  constructor(name63, direction, scene) {
    super(name63, scene);
    this.groundColor = new Color3(0, 0, 0);
    this.direction = direction || Vector3.Up();
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("vLightData", 4);
    this._uniformBuffer.addUniform("vLightDiffuse", 4);
    this._uniformBuffer.addUniform("vLightSpecular", 4);
    this._uniformBuffer.addUniform("vLightGround", 3);
    this._uniformBuffer.addUniform("shadowsInfo", 3);
    this._uniformBuffer.addUniform("depthValues", 2);
    this._uniformBuffer.create();
  }
  getClassName() {
    return "HemisphericLight";
  }
  setDirectionToTarget(target) {
    this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));
    return this.direction;
  }
  getShadowGenerator() {
    return null;
  }
  transferToEffect(_effect, lightIndex) {
    const normalizeDirection = Vector3.Normalize(this.direction);
    this._uniformBuffer.updateFloat4("vLightData", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0, lightIndex);
    this._uniformBuffer.updateColor3("vLightGround", this.groundColor.scale(this.intensity), lightIndex);
    return this;
  }
  transferToNodeMaterialEffect(effect, lightDataUniformName) {
    const normalizeDirection = Vector3.Normalize(this.direction);
    effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);
    return this;
  }
  computeWorldMatrix() {
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    return this._worldMatrix;
  }
  getTypeID() {
    return Light.LIGHTTYPEID_HEMISPHERICLIGHT;
  }
  prepareLightSpecificDefines(defines, lightIndex) {
    defines["HEMILIGHT" + lightIndex] = true;
  }
};
__decorate([
  serializeAsColor3()
], HemisphericLight.prototype, "groundColor", void 0);
__decorate([
  serializeAsVector3()
], HemisphericLight.prototype, "direction", void 0);

// node_modules/@babylonjs/core/Materials/materialFlags.js
var MaterialFlags = class {
  static get DiffuseTextureEnabled() {
    return this._DiffuseTextureEnabled;
  }
  static set DiffuseTextureEnabled(value) {
    if (this._DiffuseTextureEnabled === value) {
      return;
    }
    this._DiffuseTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get DetailTextureEnabled() {
    return this._DetailTextureEnabled;
  }
  static set DetailTextureEnabled(value) {
    if (this._DetailTextureEnabled === value) {
      return;
    }
    this._DetailTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get AmbientTextureEnabled() {
    return this._AmbientTextureEnabled;
  }
  static set AmbientTextureEnabled(value) {
    if (this._AmbientTextureEnabled === value) {
      return;
    }
    this._AmbientTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get OpacityTextureEnabled() {
    return this._OpacityTextureEnabled;
  }
  static set OpacityTextureEnabled(value) {
    if (this._OpacityTextureEnabled === value) {
      return;
    }
    this._OpacityTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get ReflectionTextureEnabled() {
    return this._ReflectionTextureEnabled;
  }
  static set ReflectionTextureEnabled(value) {
    if (this._ReflectionTextureEnabled === value) {
      return;
    }
    this._ReflectionTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get EmissiveTextureEnabled() {
    return this._EmissiveTextureEnabled;
  }
  static set EmissiveTextureEnabled(value) {
    if (this._EmissiveTextureEnabled === value) {
      return;
    }
    this._EmissiveTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get SpecularTextureEnabled() {
    return this._SpecularTextureEnabled;
  }
  static set SpecularTextureEnabled(value) {
    if (this._SpecularTextureEnabled === value) {
      return;
    }
    this._SpecularTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get BumpTextureEnabled() {
    return this._BumpTextureEnabled;
  }
  static set BumpTextureEnabled(value) {
    if (this._BumpTextureEnabled === value) {
      return;
    }
    this._BumpTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get LightmapTextureEnabled() {
    return this._LightmapTextureEnabled;
  }
  static set LightmapTextureEnabled(value) {
    if (this._LightmapTextureEnabled === value) {
      return;
    }
    this._LightmapTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get RefractionTextureEnabled() {
    return this._RefractionTextureEnabled;
  }
  static set RefractionTextureEnabled(value) {
    if (this._RefractionTextureEnabled === value) {
      return;
    }
    this._RefractionTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get ColorGradingTextureEnabled() {
    return this._ColorGradingTextureEnabled;
  }
  static set ColorGradingTextureEnabled(value) {
    if (this._ColorGradingTextureEnabled === value) {
      return;
    }
    this._ColorGradingTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get FresnelEnabled() {
    return this._FresnelEnabled;
  }
  static set FresnelEnabled(value) {
    if (this._FresnelEnabled === value) {
      return;
    }
    this._FresnelEnabled = value;
    Engine.MarkAllMaterialsAsDirty(4);
  }
  static get ClearCoatTextureEnabled() {
    return this._ClearCoatTextureEnabled;
  }
  static set ClearCoatTextureEnabled(value) {
    if (this._ClearCoatTextureEnabled === value) {
      return;
    }
    this._ClearCoatTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get ClearCoatBumpTextureEnabled() {
    return this._ClearCoatBumpTextureEnabled;
  }
  static set ClearCoatBumpTextureEnabled(value) {
    if (this._ClearCoatBumpTextureEnabled === value) {
      return;
    }
    this._ClearCoatBumpTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get ClearCoatTintTextureEnabled() {
    return this._ClearCoatTintTextureEnabled;
  }
  static set ClearCoatTintTextureEnabled(value) {
    if (this._ClearCoatTintTextureEnabled === value) {
      return;
    }
    this._ClearCoatTintTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get SheenTextureEnabled() {
    return this._SheenTextureEnabled;
  }
  static set SheenTextureEnabled(value) {
    if (this._SheenTextureEnabled === value) {
      return;
    }
    this._SheenTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get AnisotropicTextureEnabled() {
    return this._AnisotropicTextureEnabled;
  }
  static set AnisotropicTextureEnabled(value) {
    if (this._AnisotropicTextureEnabled === value) {
      return;
    }
    this._AnisotropicTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get ThicknessTextureEnabled() {
    return this._ThicknessTextureEnabled;
  }
  static set ThicknessTextureEnabled(value) {
    if (this._ThicknessTextureEnabled === value) {
      return;
    }
    this._ThicknessTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get RefractionIntensityTextureEnabled() {
    return this._ThicknessTextureEnabled;
  }
  static set RefractionIntensityTextureEnabled(value) {
    if (this._RefractionIntensityTextureEnabled === value) {
      return;
    }
    this._RefractionIntensityTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get TranslucencyIntensityTextureEnabled() {
    return this._ThicknessTextureEnabled;
  }
  static set TranslucencyIntensityTextureEnabled(value) {
    if (this._TranslucencyIntensityTextureEnabled === value) {
      return;
    }
    this._TranslucencyIntensityTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  static get IridescenceTextureEnabled() {
    return this._IridescenceTextureEnabled;
  }
  static set IridescenceTextureEnabled(value) {
    if (this._IridescenceTextureEnabled === value) {
      return;
    }
    this._IridescenceTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
};
MaterialFlags._DiffuseTextureEnabled = true;
MaterialFlags._DetailTextureEnabled = true;
MaterialFlags._AmbientTextureEnabled = true;
MaterialFlags._OpacityTextureEnabled = true;
MaterialFlags._ReflectionTextureEnabled = true;
MaterialFlags._EmissiveTextureEnabled = true;
MaterialFlags._SpecularTextureEnabled = true;
MaterialFlags._BumpTextureEnabled = true;
MaterialFlags._LightmapTextureEnabled = true;
MaterialFlags._RefractionTextureEnabled = true;
MaterialFlags._ColorGradingTextureEnabled = true;
MaterialFlags._FresnelEnabled = true;
MaterialFlags._ClearCoatTextureEnabled = true;
MaterialFlags._ClearCoatBumpTextureEnabled = true;
MaterialFlags._ClearCoatTintTextureEnabled = true;
MaterialFlags._SheenTextureEnabled = true;
MaterialFlags._AnisotropicTextureEnabled = true;
MaterialFlags._ThicknessTextureEnabled = true;
MaterialFlags._RefractionIntensityTextureEnabled = true;
MaterialFlags._TranslucencyIntensityTextureEnabled = true;
MaterialFlags._IridescenceTextureEnabled = true;

// node_modules/@babylonjs/core/Materials/materialPluginManager.js
var rxOption = new RegExp("^([gimus]+)!");
var MaterialPluginManager = class {
  constructor(material) {
    this._plugins = [];
    this._activePlugins = [];
    this._activePluginsForExtraEvents = [];
    this._material = material;
    this._scene = material.getScene();
    this._engine = this._scene.getEngine();
  }
  _addPlugin(plugin) {
    for (let i = 0; i < this._plugins.length; ++i) {
      if (this._plugins[i].name === plugin.name) {
        throw `Plugin "${plugin.name}" already added to the material "${this._material.name}"!`;
      }
    }
    if (this._material._uniformBufferLayoutBuilt) {
      throw `The plugin "${plugin.name}" can't be added to the material "${this._material.name}" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;
    }
    const pluginClassName = plugin.getClassName();
    if (!MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]) {
      MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName] = "MATERIALPLUGIN_" + ++MaterialPluginManager._MaterialPluginCounter;
    }
    this._material._callbackPluginEventGeneric = this._handlePluginEvent.bind(this);
    this._plugins.push(plugin);
    this._plugins.sort((a, b) => a.priority - b.priority);
    this._codeInjectionPoints = {};
    const defineNamesFromPlugins = {};
    defineNamesFromPlugins[MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]] = {
      type: "boolean",
      default: true
    };
    for (const plugin2 of this._plugins) {
      plugin2.collectDefines(defineNamesFromPlugins);
      this._collectPointNames("vertex", plugin2.getCustomCode("vertex"));
      this._collectPointNames("fragment", plugin2.getCustomCode("fragment"));
    }
    this._defineNamesFromPlugins = defineNamesFromPlugins;
  }
  _activatePlugin(plugin) {
    if (this._activePlugins.indexOf(plugin) === -1) {
      this._activePlugins.push(plugin);
      this._activePlugins.sort((a, b) => a.priority - b.priority);
      this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this);
      this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this);
      this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this);
      this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this);
      if (plugin.registerForExtraEvents) {
        this._activePluginsForExtraEvents.push(plugin);
        this._activePluginsForExtraEvents.sort((a, b) => a.priority - b.priority);
        this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this);
        this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this);
        this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this);
      }
    }
  }
  getPlugin(name63) {
    for (let i = 0; i < this._plugins.length; ++i) {
      if (this._plugins[i].name === name63) {
        return this._plugins[i];
      }
    }
    return null;
  }
  _handlePluginEventIsReadyForSubMesh(eventData) {
    let isReady = true;
    for (const plugin of this._activePlugins) {
      isReady = isReady && plugin.isReadyForSubMesh(eventData.defines, this._scene, this._engine, eventData.subMesh);
    }
    eventData.isReadyForSubMesh = isReady;
  }
  _handlePluginEventPrepareDefinesBeforeAttributes(eventData) {
    for (const plugin of this._activePlugins) {
      plugin.prepareDefinesBeforeAttributes(eventData.defines, this._scene, eventData.mesh);
    }
  }
  _handlePluginEventPrepareDefines(eventData) {
    for (const plugin of this._activePlugins) {
      plugin.prepareDefines(eventData.defines, this._scene, eventData.mesh);
    }
  }
  _handlePluginEventHardBindForSubMesh(eventData) {
    for (const plugin of this._activePluginsForExtraEvents) {
      plugin.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);
    }
  }
  _handlePluginEventBindForSubMesh(eventData) {
    for (const plugin of this._activePlugins) {
      plugin.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);
    }
  }
  _handlePluginEventHasRenderTargetTextures(eventData) {
    let hasRenderTargetTextures = false;
    for (const plugin of this._activePluginsForExtraEvents) {
      hasRenderTargetTextures = plugin.hasRenderTargetTextures();
      if (hasRenderTargetTextures) {
        break;
      }
    }
    eventData.hasRenderTargetTextures = hasRenderTargetTextures;
  }
  _handlePluginEventFillRenderTargetTextures(eventData) {
    for (const plugin of this._activePluginsForExtraEvents) {
      plugin.fillRenderTargetTextures(eventData.renderTargets);
    }
  }
  _handlePluginEvent(id, info) {
    switch (id) {
      case MaterialPluginEvent.GetActiveTextures: {
        const eventData = info;
        for (const plugin of this._activePlugins) {
          plugin.getActiveTextures(eventData.activeTextures);
        }
        break;
      }
      case MaterialPluginEvent.GetAnimatables: {
        const eventData = info;
        for (const plugin of this._activePlugins) {
          plugin.getAnimatables(eventData.animatables);
        }
        break;
      }
      case MaterialPluginEvent.HasTexture: {
        const eventData = info;
        let hasTexture = false;
        for (const plugin of this._activePlugins) {
          hasTexture = plugin.hasTexture(eventData.texture);
          if (hasTexture) {
            break;
          }
        }
        eventData.hasTexture = hasTexture;
        break;
      }
      case MaterialPluginEvent.Disposed: {
        const eventData = info;
        for (const plugin of this._plugins) {
          plugin.dispose(eventData.forceDisposeTextures);
        }
        break;
      }
      case MaterialPluginEvent.GetDefineNames: {
        const eventData = info;
        eventData.defineNames = this._defineNamesFromPlugins;
        break;
      }
      case MaterialPluginEvent.PrepareEffect: {
        const eventData = info;
        for (const plugin of this._activePlugins) {
          eventData.fallbackRank = plugin.addFallbacks(eventData.defines, eventData.fallbacks, eventData.fallbackRank);
          plugin.getAttributes(eventData.attributes, this._scene, eventData.mesh);
        }
        if (this._uniformList.length > 0) {
          eventData.uniforms.push(...this._uniformList);
        }
        if (this._samplerList.length > 0) {
          eventData.samplers.push(...this._samplerList);
        }
        if (this._uboList.length > 0) {
          eventData.uniformBuffersNames.push(...this._uboList);
        }
        eventData.customCode = this._injectCustomCode(eventData.customCode);
        break;
      }
      case MaterialPluginEvent.PrepareUniformBuffer: {
        const eventData = info;
        this._uboDeclaration = "";
        this._vertexDeclaration = "";
        this._fragmentDeclaration = "";
        this._uniformList = [];
        this._samplerList = [];
        this._uboList = [];
        for (const plugin of this._plugins) {
          const uniforms = plugin.getUniforms();
          if (uniforms) {
            if (uniforms.ubo) {
              for (const uniform of uniforms.ubo) {
                eventData.ubo.addUniform(uniform.name, uniform.size);
                this._uboDeclaration += `${uniform.type} ${uniform.name};\r
`;
                this._uniformList.push(uniform.name);
              }
            }
            if (uniforms.vertex) {
              this._vertexDeclaration += uniforms.vertex + "\r\n";
            }
            if (uniforms.fragment) {
              this._fragmentDeclaration += uniforms.fragment + "\r\n";
            }
          }
          plugin.getSamplers(this._samplerList);
          plugin.getUniformBuffersNames(this._uboList);
        }
        break;
      }
    }
  }
  _collectPointNames(shaderType, customCode) {
    if (!customCode) {
      return;
    }
    for (const pointName in customCode) {
      if (!this._codeInjectionPoints[shaderType]) {
        this._codeInjectionPoints[shaderType] = {};
      }
      this._codeInjectionPoints[shaderType][pointName] = true;
    }
  }
  _injectCustomCode(existingCallback) {
    return (shaderType, code) => {
      var _a;
      if (existingCallback) {
        code = existingCallback(shaderType, code);
      }
      if (this._uboDeclaration) {
        code = code.replace("#define ADDITIONAL_UBO_DECLARATION", this._uboDeclaration);
      }
      if (this._vertexDeclaration) {
        code = code.replace("#define ADDITIONAL_VERTEX_DECLARATION", this._vertexDeclaration);
      }
      if (this._fragmentDeclaration) {
        code = code.replace("#define ADDITIONAL_FRAGMENT_DECLARATION", this._fragmentDeclaration);
      }
      const points = (_a = this._codeInjectionPoints) === null || _a === void 0 ? void 0 : _a[shaderType];
      if (!points) {
        return code;
      }
      for (let pointName in points) {
        let injectedCode = "";
        for (const plugin of this._activePlugins) {
          const customCode = plugin.getCustomCode(shaderType);
          if (customCode === null || customCode === void 0 ? void 0 : customCode[pointName]) {
            injectedCode += customCode[pointName] + "\r\n";
          }
        }
        if (injectedCode.length > 0) {
          if (pointName.charAt(0) === "!") {
            pointName = pointName.substring(1);
            let regexFlags = "g";
            if (pointName.charAt(0) === "!") {
              regexFlags = "";
              pointName = pointName.substring(1);
            } else {
              const matchOption = rxOption.exec(pointName);
              if (matchOption && matchOption.length >= 2) {
                regexFlags = matchOption[1];
                pointName = pointName.substring(regexFlags.length + 1);
              }
            }
            if (regexFlags.indexOf("g") < 0) {
              regexFlags += "g";
            }
            const sourceCode = code;
            const rx = new RegExp(pointName, regexFlags);
            let match = rx.exec(sourceCode);
            while (match !== null) {
              let newCode = injectedCode;
              for (let i = 0; i < match.length; ++i) {
                newCode = newCode.replace("$" + i, match[i]);
              }
              code = code.replace(match[0], newCode);
              match = rx.exec(sourceCode);
            }
          } else {
            const fullPointName = "#define " + pointName;
            code = code.replace(fullPointName, "\r\n" + injectedCode + "\r\n" + fullPointName);
          }
        }
      }
      return code;
    };
  }
};
MaterialPluginManager._MaterialPluginClassToMainDefine = {};
MaterialPluginManager._MaterialPluginCounter = 0;
var plugins = [];
var inited = false;
function RegisterMaterialPlugin(pluginName, factory) {
  if (!inited) {
    Material.OnEventObservable.add((material) => {
      for (const [, factory2] of plugins) {
        factory2(material);
      }
    }, MaterialPluginEvent.Created);
    inited = true;
  }
  const existing = plugins.filter(([name63, _factory]) => name63 === pluginName);
  if (existing.length > 0) {
    existing[0][1] = factory;
  } else {
    plugins.push([pluginName, factory]);
  }
}
function UnregisterMaterialPlugin(pluginName) {
  for (let i = 0; i < plugins.length; ++i) {
    if (plugins[i][0] === pluginName) {
      plugins.splice(i, 1);
      return true;
    }
  }
  return false;
}
function UnregisterAllMaterialPlugins() {
  plugins.length = 0;
}

// node_modules/@babylonjs/core/Materials/materialPluginBase.js
var MaterialPluginBase = class {
  constructor(material, name63, priority, defines, addToPluginList = true, enable = false) {
    this.priority = 500;
    this.registerForExtraEvents = false;
    this._material = material;
    this.name = name63;
    this.priority = priority;
    if (!material.pluginManager) {
      material.pluginManager = new MaterialPluginManager(material);
    }
    this._pluginDefineNames = defines;
    this._pluginManager = material.pluginManager;
    if (addToPluginList) {
      this._pluginManager._addPlugin(this);
    }
    if (enable) {
      this._enable(true);
    }
    this.markAllDefinesAsDirty = material._dirtyCallbacks[63];
  }
  _enable(enable) {
    if (enable) {
      this._pluginManager._activatePlugin(this);
    }
  }
  getClassName() {
    return "MaterialPluginBase";
  }
  isReadyForSubMesh(defines, scene, engine, subMesh) {
    return true;
  }
  hardBindForSubMesh(uniformBuffer, scene, engine, subMesh) {
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
  }
  dispose(forceDisposeTextures) {
  }
  getCustomCode(shaderType) {
    return null;
  }
  collectDefines(defines) {
    if (!this._pluginDefineNames) {
      return;
    }
    for (const key of Object.keys(this._pluginDefineNames)) {
      if (key[0] === "_") {
        continue;
      }
      const type = typeof this._pluginDefineNames[key];
      defines[key] = {
        type: type === "number" ? "number" : type === "string" ? "string" : type === "boolean" ? "boolean" : "object",
        default: this._pluginDefineNames[key]
      };
    }
  }
  prepareDefinesBeforeAttributes(defines, scene, mesh) {
  }
  prepareDefines(defines, scene, mesh) {
  }
  hasTexture(texture) {
    return false;
  }
  hasRenderTargetTextures() {
    return false;
  }
  fillRenderTargetTextures(renderTargets) {
  }
  getActiveTextures(activeTextures) {
  }
  getAnimatables(animatables) {
  }
  addFallbacks(defines, fallbacks, currentRank) {
    return currentRank;
  }
  getSamplers(samplers) {
  }
  getAttributes(attributes, scene, mesh) {
  }
  getUniformBuffersNames(ubos) {
  }
  getUniforms() {
    return {};
  }
  copyTo(plugin) {
    SerializationHelper.Clone(() => plugin, this);
  }
  serialize() {
    return SerializationHelper.Serialize(this);
  }
  parse(source, scene, rootUrl) {
    SerializationHelper.Parse(() => this, source, scene, rootUrl);
  }
};
__decorate([
  serialize()
], MaterialPluginBase.prototype, "name", void 0);
__decorate([
  serialize()
], MaterialPluginBase.prototype, "priority", void 0);
__decorate([
  serialize()
], MaterialPluginBase.prototype, "registerForExtraEvents", void 0);

// node_modules/@babylonjs/core/Materials/material.detailMapConfiguration.js
var MaterialDetailMapDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.DETAIL = false;
    this.DETAILDIRECTUV = 0;
    this.DETAIL_NORMALBLENDMETHOD = 0;
  }
};
var DetailMapConfiguration = class extends MaterialPluginBase {
  constructor(material, addToPluginList = true) {
    super(material, "DetailMap", 140, new MaterialDetailMapDefines(), addToPluginList);
    this._texture = null;
    this.diffuseBlendLevel = 1;
    this.roughnessBlendLevel = 1;
    this.bumpLevel = 1;
    this._normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;
    this._isEnabled = false;
    this.isEnabled = false;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
  }
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  isReadyForSubMesh(defines, scene, engine) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty && scene.texturesEnabled) {
      if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {
        if (!this._texture.isReady()) {
          return false;
        }
      }
    }
    return true;
  }
  prepareDefines(defines, scene) {
    if (this._isEnabled) {
      defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
      const engine = scene.getEngine();
      if (defines._areTexturesDirty) {
        if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {
          MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "DETAIL");
          defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
        } else {
          defines.DETAIL = false;
        }
      }
    } else {
      defines.DETAIL = false;
    }
  }
  bindForSubMesh(uniformBuffer, scene) {
    if (!this._isEnabled) {
      return;
    }
    const isFrozen = this._material.isFrozen;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (this._texture && MaterialFlags.DetailTextureEnabled) {
        uniformBuffer.updateFloat4("vDetailInfos", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);
        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "detail");
      }
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.DetailTextureEnabled) {
        uniformBuffer.setTexture("detailSampler", this._texture);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
  }
  dispose(forceDisposeTextures) {
    var _a;
    if (forceDisposeTextures) {
      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
    }
  }
  getClassName() {
    return "DetailMapConfiguration";
  }
  getSamplers(samplers) {
    samplers.push("detailSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vDetailInfos", size: 4, type: "vec4" },
        { name: "detailMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
__decorate([
  serializeAsTexture("detailTexture"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], DetailMapConfiguration.prototype, "texture", void 0);
__decorate([
  serialize()
], DetailMapConfiguration.prototype, "diffuseBlendLevel", void 0);
__decorate([
  serialize()
], DetailMapConfiguration.prototype, "roughnessBlendLevel", void 0);
__decorate([
  serialize()
], DetailMapConfiguration.prototype, "bumpLevel", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], DetailMapConfiguration.prototype, "normalBlendMethod", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], DetailMapConfiguration.prototype, "isEnabled", void 0);

// node_modules/@babylonjs/core/Materials/prePassConfiguration.js
var PrePassConfiguration = class {
  constructor() {
    this.previousWorldMatrices = {};
    this.previousBones = {};
  }
  static AddUniforms(uniforms) {
    uniforms.push("previousWorld", "previousViewProjection", "mPreviousBones");
  }
  static AddSamplers(samplers) {
  }
  bindForSubMesh(effect, scene, mesh, world, isFrozen) {
    if (scene.prePassRenderer && scene.prePassRenderer.enabled && scene.prePassRenderer.currentRTisSceneRT) {
      if (scene.prePassRenderer.getIndex(2) !== -1) {
        if (!this.previousWorldMatrices[mesh.uniqueId]) {
          this.previousWorldMatrices[mesh.uniqueId] = world.clone();
        }
        if (!this.previousViewProjection) {
          this.previousViewProjection = scene.getTransformMatrix().clone();
          this.currentViewProjection = scene.getTransformMatrix().clone();
        }
        const engine = scene.getEngine();
        if (this.currentViewProjection.updateFlag !== scene.getTransformMatrix().updateFlag) {
          this._lastUpdateFrameId = engine.frameId;
          this.previousViewProjection.copyFrom(this.currentViewProjection);
          this.currentViewProjection.copyFrom(scene.getTransformMatrix());
        } else if (this._lastUpdateFrameId !== engine.frameId) {
          this._lastUpdateFrameId = engine.frameId;
          this.previousViewProjection.copyFrom(this.currentViewProjection);
        }
        effect.setMatrix("previousWorld", this.previousWorldMatrices[mesh.uniqueId]);
        effect.setMatrix("previousViewProjection", this.previousViewProjection);
        this.previousWorldMatrices[mesh.uniqueId] = world.clone();
      }
    }
  }
};

// node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultFragmentDeclaration.js
var name3 = "defaultFragmentDeclaration";
var shader3 = `uniform vec4 vEyePosition;
uniform vec4 vDiffuseColor;
#ifdef SPECULARTERM
uniform vec4 vSpecularColor;
#endif
uniform vec3 vEmissiveColor;
uniform vec3 vAmbientColor;
uniform float visibility;
#ifdef DIFFUSE
uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY 
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;
uniform vec2 vTangentSpaceParams;
#endif
#ifdef ALPHATEST
uniform float alphaCutOff;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)
uniform mat4 view;
#endif
#ifdef REFRACTION
uniform vec4 vRefractionInfos;
#ifndef REFRACTIONMAP_3D
uniform mat4 refractionMatrix;
#endif
#ifdef REFRACTIONFRESNEL
uniform vec4 refractionLeftColor;
uniform vec4 refractionRightColor;
#endif
#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)
uniform vec3 vRefractionPosition;
uniform vec3 vRefractionSize; 
#endif
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;
#endif
#ifdef DIFFUSEFRESNEL
uniform vec4 diffuseLeftColor;
uniform vec4 diffuseRightColor;
#endif
#ifdef OPACITYFRESNEL
uniform vec4 opacityParts;
#endif
#ifdef EMISSIVEFRESNEL
uniform vec4 emissiveLeftColor;
uniform vec4 emissiveRightColor;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;
#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)
uniform mat4 reflectionMatrix;
#endif
#ifndef REFLECTIONMAP_SKYBOX
#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)
uniform vec3 vReflectionPosition;
uniform vec3 vReflectionSize; 
#endif
#endif
#ifdef REFLECTIONFRESNEL
uniform vec4 reflectionLeftColor;
uniform vec4 reflectionRightColor;
#endif
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
#endif
#define ADDITIONAL_FRAGMENT_DECLARATION
`;
ShaderStore.IncludesShadersStore[name3] = shader3;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/sceneUboDeclaration.js
var name4 = "sceneUboDeclaration";
var shader4 = `layout(std140,column_major) uniform;
uniform Scene {
mat4 viewProjection;
#ifdef MULTIVIEW
mat4 viewProjectionR;
#endif 
mat4 view;
mat4 projection;
vec4 vEyePosition;
};
`;
ShaderStore.IncludesShadersStore[name4] = shader4;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/meshUboDeclaration.js
var name5 = "meshUboDeclaration";
var shader5 = `#ifdef WEBGL2
uniform mat4 world;
uniform float visibility;
#else
layout(std140,column_major) uniform;
uniform Mesh
{
mat4 world;
float visibility;
};
#endif
#define WORLD_UBO
`;
ShaderStore.IncludesShadersStore[name5] = shader5;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultUboDeclaration.js
var name6 = "defaultUboDeclaration";
var shader6 = `layout(std140,column_major) uniform;
uniform Material
{
vec4 diffuseLeftColor;
vec4 diffuseRightColor;
vec4 opacityParts;
vec4 reflectionLeftColor;
vec4 reflectionRightColor;
vec4 refractionLeftColor;
vec4 refractionRightColor;
vec4 emissiveLeftColor;
vec4 emissiveRightColor;
vec2 vDiffuseInfos;
vec2 vAmbientInfos;
vec2 vOpacityInfos;
vec2 vReflectionInfos;
vec3 vReflectionPosition;
vec3 vReflectionSize;
vec2 vEmissiveInfos;
vec2 vLightmapInfos;
vec2 vSpecularInfos;
vec3 vBumpInfos;
mat4 diffuseMatrix;
mat4 ambientMatrix;
mat4 opacityMatrix;
mat4 reflectionMatrix;
mat4 emissiveMatrix;
mat4 lightmapMatrix;
mat4 specularMatrix;
mat4 bumpMatrix;
vec2 vTangentSpaceParams;
float pointSize;
float alphaCutOff;
mat4 refractionMatrix;
vec4 vRefractionInfos;
vec3 vRefractionPosition;
vec3 vRefractionSize;
vec4 vSpecularColor;
vec3 vEmissiveColor;
vec4 vDiffuseColor;
vec3 vAmbientColor;
#define ADDITIONAL_UBO_DECLARATION
};
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
ShaderStore.IncludesShadersStore[name6] = shader6;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassDeclaration.js
var name7 = "prePassDeclaration";
var shader7 = `#ifdef PREPASS
#extension GL_EXT_draw_buffers : require
layout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;
#ifdef PREPASS_DEPTH
varying highp vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
varying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name7] = shader7;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/oitDeclaration.js
var name8 = "oitDeclaration";
var shader8 = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
#extension GL_EXT_draw_buffers : require
layout(location=0) out vec2 depth; 
layout(location=1) out vec4 frontColor;
layout(location=2) out vec4 backColor;
#define MAX_DEPTH 99999.0
highp vec4 gl_FragColor;
uniform sampler2D oitDepthSampler;
uniform sampler2D oitFrontColorSampler;
#endif
`;
ShaderStore.IncludesShadersStore[name8] = shader8;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/mainUVVaryingDeclaration.js
var name9 = "mainUVVaryingDeclaration";
var shader9 = `#ifdef MAINUV{X}
varying vec2 vMainUV{X};
#endif
`;
ShaderStore.IncludesShadersStore[name9] = shader9;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js
var name10 = "helperFunctions";
var shader10 = `const float PI=3.1415926535897932384626433832795;
const float HALF_MIN=5.96046448e-08; 
const float LinearEncodePowerApprox=2.2;
const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;
const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);
const float Epsilon=0.0000001;
#define saturate(x) clamp(x,0.0,1.0)
#define absEps(x) abs(x)+Epsilon
#define maxEps(x) max(x,Epsilon)
#define saturateEps(x) clamp(x,Epsilon,1.0)
mat3 transposeMat3(mat3 inMatrix) {
vec3 i0=inMatrix[0];
vec3 i1=inMatrix[1];
vec3 i2=inMatrix[2];
mat3 outMatrix=mat3(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);
return outMatrix;
}
mat3 inverseMat3(mat3 inMatrix) {
float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];
float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];
float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];
float b01=a22*a11-a12*a21;
float b11=-a22*a10+a12*a20;
float b21=a21*a10-a11*a20;
float det=a00*b01+a01*b11+a02*b21;
return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),
b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),
b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;
}
#if USE_EXACT_SRGB_CONVERSIONS
vec3 toLinearSpaceExact(vec3 color)
{
vec3 nearZeroSection=0.0773993808*color;
vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));
#else
return
vec3(
color.r<=0.04045 ? nearZeroSection.r : remainingSection.r,
color.g<=0.04045 ? nearZeroSection.g : remainingSection.g,
color.b<=0.04045 ? nearZeroSection.b : remainingSection.b);
#endif
}
vec3 toGammaSpaceExact(vec3 color)
{
vec3 nearZeroSection=12.92*color;
vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));
#else
return
vec3(
color.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,
color.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,
color.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);
#endif
}
#endif
float toLinearSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=0.0773993808*color;
float remainingSection=pow(0.947867299*(color+0.055),2.4);
return color<=0.04045 ? nearZeroSection : remainingSection;
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
vec3 toLinearSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3(LinearEncodePowerApprox));
#endif
}
vec4 toLinearSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);
#endif
}
float toGammaSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=12.92*color;
float remainingSection=1.055*pow(color,0.41666)-0.055;
return color<=0.0031308 ? nearZeroSection : remainingSection;
#else
return pow(color,GammaEncodePowerApprox);
#endif
}
vec3 toGammaSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3(GammaEncodePowerApprox));
#endif
}
vec4 toGammaSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);
#endif
}
float square(float value)
{
return value*value;
}
vec3 square(vec3 value)
{
return value*value;
}
float pow5(float value) {
float sq=value*value;
return sq*sq*value;
}
float getLuminance(vec3 color)
{
return clamp(dot(color,LuminanceEncodeApprox),0.,1.);
}
float getRand(vec2 seed) {
return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);
}
float dither(vec2 seed,float varianceAmount) {
float rand=getRand(seed);
float normVariance=varianceAmount/255.0;
float dither=mix(-normVariance,normVariance,rand);
return dither;
}
const float rgbdMaxRange=255.0;
vec4 toRGBD(vec3 color) {
float maxRGB=maxEps(max(color.r,max(color.g,color.b)));
float D =max(rgbdMaxRange/maxRGB,1.);
D =clamp(floor(D)/255.0,0.,1.);
vec3 rgb=color.rgb*D;
rgb=toGammaSpace(rgb);
return vec4(clamp(rgb,0.,1.),D); 
}
vec3 fromRGBD(vec4 rgbd) {
rgbd.rgb=toLinearSpace(rgbd.rgb);
return rgbd.rgb/rgbd.a;
}
vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {
vec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;
vec3 halfSize=cubeSize*0.5;
vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;
vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;
vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);
float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);
vec3 intersectPositionWS=vertexPos+origVec*distance;
return intersectPositionWS-cubePos;
}
`;
ShaderStore.IncludesShadersStore[name10] = shader10;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js
var name11 = "lightFragmentDeclaration";
var shader11 = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};
uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float cascadeBlendFactor{X};
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
uniform highp sampler2DArray depthSampler{X};
uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);
vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X};
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};
uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};
uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};
uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};
uniform sampler2D projectionLightSampler{X};
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name11] = shader11;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js
var name12 = "lightUboDeclaration";
var shader12 = `#ifdef LIGHT{X}
uniform Light{X}
{
vec4 vLightData;
vec4 vLightDiffuse;
vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;
vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;
vec2 depthValues;
} light{X};
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};
uniform sampler2D projectionLightSampler{X};
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float cascadeBlendFactor{X};
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
uniform highp sampler2DArray depthSampler{X};
uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);
vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X}; 
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};
uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name12] = shader12;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions.js
var name13 = "lightsFragmentFunctions";
var shader13 = `struct lightingInfo
{
vec3 diffuse;
#ifdef SPECULARTERM
vec3 specular;
#endif
#ifdef NDOTL
float ndl;
#endif
};
lightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {
lightingInfo result;
vec3 lightVectorW;
float attenuation=1.0;
if (lightData.w==0.)
{
vec3 direction=lightData.xyz-vPositionW;
attenuation=max(0.,1.0-length(direction)/range);
lightVectorW=normalize(direction);
}
else
{
lightVectorW=normalize(-lightData.xyz);
}
float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);
float specComp=max(0.,dot(vNormal,angleW));
specComp=pow(specComp,max(1.,glossiness));
result.specular=specComp*specularColor*attenuation;
#endif
return result;
}
lightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {
lightingInfo result;
vec3 direction=lightData.xyz-vPositionW;
vec3 lightVectorW=normalize(direction);
float attenuation=max(0.,1.0-length(direction)/range);
float cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));
if (cosAngle>=lightDirection.w)
{
cosAngle=max(0.,pow(cosAngle,lightData.w));
attenuation*=cosAngle;
float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);
float specComp=max(0.,dot(vNormal,angleW));
specComp=pow(specComp,max(1.,glossiness));
result.specular=specComp*specularColor*attenuation;
#endif
return result;
}
result.diffuse=vec3(0.);
#ifdef SPECULARTERM
result.specular=vec3(0.);
#endif
#ifdef NDOTL
result.ndl=0.;
#endif
return result;
}
lightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {
lightingInfo result;
float ndl=dot(vNormal,lightData.xyz)*0.5+0.5;
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=mix(groundColor,diffuseColor,ndl);
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightData.xyz);
float specComp=max(0.,dot(vNormal,angleW));
specComp=pow(specComp,max(1.,glossiness));
result.specular=specComp*specularColor;
#endif
return result;
}
#define inline
vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){
vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);
strq/=strq.w;
vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;
return textureColor;
}`;
ShaderStore.IncludesShadersStore[name13] = shader13;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js
var name14 = "shadowsFragmentFunctions";
var shader14 = `#ifdef SHADOWS
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)
#else
#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)
#endif
#ifndef SHADOWFLOAT
float unpack(vec4 color)
{
const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);
return dot(color,bit_shift);
}
#endif
float computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)
{
float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));
return mix(value,1.0,mask);
}
#define inline
float computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
depth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadow=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadow=textureCube(shadowSampler,directionToLight).x;
#endif
return depth>shadow ? darkness : 1.0;
}
#define inline
float computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
depth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
float visibility=1.;
vec3 poissonDisk[4];
poissonDisk[0]=vec3(-1.0,1.0,-1.0);
poissonDisk[1]=vec3(1.0,-1.0,-1.0);
poissonDisk[2]=vec3(-1.0,-1.0,-1.0);
poissonDisk[3]=vec3(1.0,-1.0,1.0);
#ifndef SHADOWFLOAT
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;
#else
if (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;
if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;
if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;
if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;
#endif
return min(1.0,visibility+darkness);
}
#define inline
float computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
float shadowPixelDepth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness); 
return esm;
}
#define inline
float computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
float shadowPixelDepth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);
return esm;
}
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define inline
float computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
vec3 uvLayer=vec3(uv.x,uv.y,layer);
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(texture2D(shadowSampler,uvLayer));
#else
float shadow=texture2D(shadowSampler,uvLayer).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;
}
#endif
#define inline
float computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;
}
}
#define inline
float computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
float visibility=1.;
vec2 poissonDisk[4];
poissonDisk[0]=vec2(-0.94201624,-0.39906216);
poissonDisk[1]=vec2(0.94558609,-0.76890725);
poissonDisk[2]=vec2(-0.094184101,-0.92938870);
poissonDisk[3]=vec2(0.34495938,0.29387760);
#ifndef SHADOWFLOAT
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
#else
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
#endif
return computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);
return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0); 
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);
return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);
}
}
#ifdef IS_NDC_HALF_ZRANGE
#define ZINCLIP clipSpace.z
#else
#define ZINCLIP uvDepth.z
#endif
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define GREATEST_LESS_THAN_ONE 0.99999994
#define inline
float computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);
float shadow=texture2D(shadowSampler,uvDepthLayer);
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
#define inline
float computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;
vec2 uvw1=1.+2.*st;
vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;
vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));
shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));
shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));
shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));
shadow=shadow/16.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
#define inline
float computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;
vec2 uvw1=vec2(7.);
vec2 uvw2=1.+3.*st;
vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;
vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));
shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));
shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));
shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));
shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));
shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));
shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));
shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));
shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));
shadow=shadow/144.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
#define inline
float computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
float shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;
vec2 uvw1=1.+2.*st;
vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;
vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);
shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);
shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);
shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);
shadow=shadow/16.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;
vec2 uvw1=vec2(7.);
vec2 uvw2=1.+3.*st;
vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;
vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);
shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);
shadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);
shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);
shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);
shadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);
shadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);
shadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);
shadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);
shadow=shadow/144.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
const vec3 PoissonSamplers32[64]=vec3[64](
vec3(0.06407013,0.05409927,0.),
vec3(0.7366577,0.5789394,0.),
vec3(-0.6270542,-0.5320278,0.),
vec3(-0.4096107,0.8411095,0.),
vec3(0.6849564,-0.4990818,0.),
vec3(-0.874181,-0.04579735,0.),
vec3(0.9989998,0.0009880066,0.),
vec3(-0.004920578,-0.9151649,0.),
vec3(0.1805763,0.9747483,0.),
vec3(-0.2138451,0.2635818,0.),
vec3(0.109845,0.3884785,0.),
vec3(0.06876755,-0.3581074,0.),
vec3(0.374073,-0.7661266,0.),
vec3(0.3079132,-0.1216763,0.),
vec3(-0.3794335,-0.8271583,0.),
vec3(-0.203878,-0.07715034,0.),
vec3(0.5912697,0.1469799,0.),
vec3(-0.88069,0.3031784,0.),
vec3(0.5040108,0.8283722,0.),
vec3(-0.5844124,0.5494877,0.),
vec3(0.6017799,-0.1726654,0.),
vec3(-0.5554981,0.1559997,0.),
vec3(-0.3016369,-0.3900928,0.),
vec3(-0.5550632,-0.1723762,0.),
vec3(0.925029,0.2995041,0.),
vec3(-0.2473137,0.5538505,0.),
vec3(0.9183037,-0.2862392,0.),
vec3(0.2469421,0.6718712,0.),
vec3(0.3916397,-0.4328209,0.),
vec3(-0.03576927,-0.6220032,0.),
vec3(-0.04661255,0.7995201,0.),
vec3(0.4402924,0.3640312,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.)
);
const vec3 PoissonSamplers64[64]=vec3[64](
vec3(-0.613392,0.617481,0.),
vec3(0.170019,-0.040254,0.),
vec3(-0.299417,0.791925,0.),
vec3(0.645680,0.493210,0.),
vec3(-0.651784,0.717887,0.),
vec3(0.421003,0.027070,0.),
vec3(-0.817194,-0.271096,0.),
vec3(-0.705374,-0.668203,0.),
vec3(0.977050,-0.108615,0.),
vec3(0.063326,0.142369,0.),
vec3(0.203528,0.214331,0.),
vec3(-0.667531,0.326090,0.),
vec3(-0.098422,-0.295755,0.),
vec3(-0.885922,0.215369,0.),
vec3(0.566637,0.605213,0.),
vec3(0.039766,-0.396100,0.),
vec3(0.751946,0.453352,0.),
vec3(0.078707,-0.715323,0.),
vec3(-0.075838,-0.529344,0.),
vec3(0.724479,-0.580798,0.),
vec3(0.222999,-0.215125,0.),
vec3(-0.467574,-0.405438,0.),
vec3(-0.248268,-0.814753,0.),
vec3(0.354411,-0.887570,0.),
vec3(0.175817,0.382366,0.),
vec3(0.487472,-0.063082,0.),
vec3(-0.084078,0.898312,0.),
vec3(0.488876,-0.783441,0.),
vec3(0.470016,0.217933,0.),
vec3(-0.696890,-0.549791,0.),
vec3(-0.149693,0.605762,0.),
vec3(0.034211,0.979980,0.),
vec3(0.503098,-0.308878,0.),
vec3(-0.016205,-0.872921,0.),
vec3(0.385784,-0.393902,0.),
vec3(-0.146886,-0.859249,0.),
vec3(0.643361,0.164098,0.),
vec3(0.634388,-0.049471,0.),
vec3(-0.688894,0.007843,0.),
vec3(0.464034,-0.188818,0.),
vec3(-0.440840,0.137486,0.),
vec3(0.364483,0.511704,0.),
vec3(0.034028,0.325968,0.),
vec3(0.099094,-0.308023,0.),
vec3(0.693960,-0.366253,0.),
vec3(0.678884,-0.204688,0.),
vec3(0.001801,0.780328,0.),
vec3(0.145177,-0.898984,0.),
vec3(0.062655,-0.611866,0.),
vec3(0.315226,-0.604297,0.),
vec3(-0.780145,0.486251,0.),
vec3(-0.371868,0.882138,0.),
vec3(0.200476,0.494430,0.),
vec3(-0.494552,-0.711051,0.),
vec3(0.612476,0.705252,0.),
vec3(-0.578845,-0.768792,0.),
vec3(-0.772454,-0.090976,0.),
vec3(0.504440,0.372295,0.),
vec3(0.155736,0.065157,0.),
vec3(0.391522,0.849605,0.),
vec3(-0.620106,-0.328104,0.),
vec3(0.789239,-0.419965,0.),
vec3(-0.545396,0.538133,0.),
vec3(-0.178564,-0.596057,0.)
);
#define inline
float computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);
float blockerDepth=0.0;
float sumBlockerDepth=0.0;
float numBlocker=0.0;
for (int i=0; i<searchTapCount; i ++) {
blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;
if (blockerDepth<depthMetric) {
sumBlockerDepth+=blockerDepth;
numBlocker++;
}
}
float avgBlockerDepth=sumBlockerDepth/numBlocker;
float AAOffset=shadowMapSizeInverse*10.;
float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);
vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);
float random=getRand(vPositionFromLight.xy);
float rotationAngle=random*3.1415926;
vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));
float shadow=0.;
for (int i=0; i<pcfTapCount; i++) {
vec4 offset=vec4(poissonSamplers[i],0.);
offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);
shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);
}
shadow/=float(pcfTapCount);
shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));
shadow=mix(darkness,1.,shadow);
if (numBlocker<1.0) {
return 1.0;
}
else
{
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
float blockerDepth=0.0;
float sumBlockerDepth=0.0;
float numBlocker=0.0;
for (int i=0; i<searchTapCount; i ++) {
blockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;
if (blockerDepth<depthMetric) {
sumBlockerDepth+=blockerDepth;
numBlocker++;
}
}
if (numBlocker<1.0) {
return 1.0;
}
else
{
float avgBlockerDepth=sumBlockerDepth/numBlocker;
float AAOffset=shadowMapSizeInverse*10.;
float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);
float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;
float random=getRand(vPositionFromLight.xy);
float rotationAngle=random*3.1415926;
vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));
float shadow=0.;
for (int i=0; i<pcfTapCount; i++) {
vec3 offset=poissonSamplers[i];
offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);
shadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);
}
shadow/=float(pcfTapCount);
shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
}
#define inline
float computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{
return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);
}
#define inline
float computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{
return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);
}
#define inline
float computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{
return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);
}
#define inline
float computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);
}
#define inline
float computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);
}
#define inline
float computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);
}
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name14] = shader14;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentDeclaration.js
var name15 = "samplerFragmentDeclaration";
var shader15 = `#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
uniform sampler2D _SAMPLERNAME_Sampler;
#endif
`;
ShaderStore.IncludesShadersStore[name15] = shader15;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fresnelFunction.js
var name16 = "fresnelFunction";
var shader16 = `#ifdef FRESNEL
float computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)
{
float fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);
return clamp(fresnelTerm,0.,1.);
}
#endif
`;
ShaderStore.IncludesShadersStore[name16] = shader16;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/reflectionFunction.js
var name17 = "reflectionFunction";
var shader17 = `vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{
float lon=atan(direction.z,direction.x);
float lat=acos(direction.y);
vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;
float s=sphereCoords.x*0.5+0.5;
float t=sphereCoords.y;
return vec3(s,t,0); 
}
vec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{
float lon=atan(direction.z,direction.x);
float lat=acos(direction.y);
vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;
float s=sphereCoords.x*0.5+0.5;
float t=sphereCoords.y;
return vec3(1.0-s,t,0); 
}
vec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{
vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);
vec3 r=normalize(reflect(cameraToVertex,worldNormal));
r=vec3(reflectionMatrix*vec4(r,0));
float lon=atan(r.z,r.x);
float lat=acos(r.y);
vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;
float s=sphereCoords.x*0.5+0.5;
float t=sphereCoords.y;
return vec3(s,t,0);
}
vec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)
{
vec3 viewDir=normalize(vec3(view*worldPos));
vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));
vec3 r=reflect(viewDir,viewNormal);
r=vec3(reflectionMatrix*vec4(r,0));
r.z=r.z-1.0;
float m=2.0*length(r);
return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);
}
vec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{
vec3 viewDir=worldPos.xyz-eyePosition;
vec3 coords=normalize(reflect(viewDir,worldNormal));
return vec3(reflectionMatrix*vec4(coords,1));
}
vec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{
vec3 viewDir=normalize(worldPos.xyz-eyePosition);
vec3 coords=reflect(viewDir,worldNormal);
coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;
}
vec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)
{
vec3 viewDir=normalize(worldPos.xyz-eyePosition);
vec3 coords=reflect(viewDir,worldNormal);
coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);
coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;
}
vec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)
{
return vec3(reflectionMatrix*(view*worldPos));
}
vec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)
{
return vec3(reflectionMatrix*vec4(positionW,1.));
}
#ifdef REFLECTION
vec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)
{
#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);
return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);
return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR
return computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SPHERICAL
return computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_PLANAR
return computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_CUBIC
#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC
return computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);
#else
return computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_PROJECTION
return computeProjectionCoords(worldPos,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SKYBOX
return computeSkyBoxCoords(vPositionUVW,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_EXPLICIT
return vec3(0,0,0);
#endif
}
#endif
`;
ShaderStore.IncludesShadersStore[name17] = shader17;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js
var name18 = "imageProcessingDeclaration";
var shader18 = `#ifdef EXPOSURE
uniform float exposureLinear;
#endif
#ifdef CONTRAST
uniform float contrast;
#endif
#if defined(VIGNETTE) || defined(DITHER)
uniform vec2 vInverseScreenSize;
#endif
#ifdef VIGNETTE
uniform vec4 vignetteSettings1;
uniform vec4 vignetteSettings2;
#endif
#ifdef COLORCURVES
uniform vec4 vCameraColorCurveNegative;
uniform vec4 vCameraColorCurveNeutral;
uniform vec4 vCameraColorCurvePositive;
#endif
#ifdef COLORGRADING
#ifdef COLORGRADING3D
uniform highp sampler3D txColorTransform;
#else
uniform sampler2D txColorTransform;
#endif
uniform vec4 colorTransformSettings;
#endif
#ifdef DITHER
uniform float ditherIntensity;
#endif
`;
ShaderStore.IncludesShadersStore[name18] = shader18;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js
var name19 = "imageProcessingFunctions";
var shader19 = `#if defined(COLORGRADING) && !defined(COLORGRADING3D)
/** 
* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.
* sampler3dSetting.x=textureOffset (0.5/textureSize).
* sampler3dSetting.y=textureSize.
*/
#define inline
vec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)
{
float sliceSize=2.0*sampler3dSetting.x; 
#ifdef SAMPLER3DGREENDEPTH
float sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;
#else
float sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;
#endif
float sliceInteger=floor(sliceContinuous);
float sliceFraction=sliceContinuous-sliceInteger;
#ifdef SAMPLER3DGREENDEPTH
vec2 sliceUV=color.rb;
#else
vec2 sliceUV=color.rg;
#endif
sliceUV.x*=sliceSize;
sliceUV.x+=sliceInteger*sliceSize;
sliceUV=saturate(sliceUV);
vec4 slice0Color=texture2D(colorTransform,sliceUV);
sliceUV.x+=sliceSize;
sliceUV=saturate(sliceUV);
vec4 slice1Color=texture2D(colorTransform,sliceUV);
vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);
#ifdef SAMPLER3DBGRMAP
color.rgb=result.rgb;
#else
color.rgb=result.bgr;
#endif
return color;
}
#endif
#ifdef TONEMAPPING_ACES
const mat3 ACESInputMat=mat3(
vec3(0.59719,0.07600,0.02840),
vec3(0.35458,0.90834,0.13383),
vec3(0.04823,0.01566,0.83777)
);
const mat3 ACESOutputMat=mat3(
vec3( 1.60475,-0.10208,-0.00327),
vec3(-0.53108, 1.10813,-0.07276),
vec3(-0.07367,-0.00605, 1.07602)
);
vec3 RRTAndODTFit(vec3 v)
{
vec3 a=v*(v+0.0245786)-0.000090537;
vec3 b=v*(0.983729*v+0.4329510)+0.238081;
return a/b;
}
vec3 ACESFitted(vec3 color)
{
color=ACESInputMat*color;
color=RRTAndODTFit(color);
color=ACESOutputMat*color;
color=saturate(color);
return color;
}
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS
vec4 applyImageProcessing(vec4 result) {
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART
#ifdef EXPOSURE
result.rgb*=exposureLinear;
#endif
#ifdef VIGNETTE
vec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;
viewportXY=viewportXY*2.0-1.0;
vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);
float vignetteTerm=dot(vignetteXY1,vignetteXY1);
float vignette=pow(vignetteTerm,vignetteSettings2.w);
vec3 vignetteColor=vignetteSettings2.rgb;
#ifdef VIGNETTEBLENDMODEMULTIPLY
vec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);
result.rgb*=vignetteColorMultiplier;
#endif
#ifdef VIGNETTEBLENDMODEOPAQUE
result.rgb=mix(vignetteColor,result.rgb,vignette);
#endif
#endif
#ifdef TONEMAPPING
#ifdef TONEMAPPING_ACES
result.rgb=ACESFitted(result.rgb);
#else
const float tonemappingCalibration=1.590579;
result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);
#endif
#endif
result.rgb=toGammaSpace(result.rgb);
result.rgb=saturate(result.rgb);
#ifdef CONTRAST
vec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);
if (contrast<1.0) {
result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);
} else {
result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);
}
#endif
#ifdef COLORGRADING
vec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;
#ifdef COLORGRADING3D
vec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;
#else
vec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;
#endif
result.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);
#endif
#ifdef COLORCURVES
float luma=getLuminance(result.rgb);
vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));
vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;
result.rgb*=colorCurve.rgb;
result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);
#endif
#ifdef DITHER
float rand=getRand(gl_FragCoord.xy*vInverseScreenSize);
float dither=mix(-ditherIntensity,ditherIntensity,rand);
result.rgb=saturate(result.rgb+vec3(dither));
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND
return result;
}`;
ShaderStore.IncludesShadersStore[name19] = shader19;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentMainFunctions.js
var name20 = "bumpFragmentMainFunctions";
var shader20 = `#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform mat4 normalMatrix;
#endif
vec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)
{
#ifdef NORMALXYSCALE
normal=normalize(normal*vec3(scale,scale,1.0));
#endif
return normalize(cotangentFrame*normal);
}
vec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)
{
return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);
}
mat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)
{
vec3 dp1=dFdx(p);
vec3 dp2=dFdy(p);
vec2 duv1=dFdx(uv);
vec2 duv2=dFdy(uv);
vec3 dp2perp=cross(dp2,normal);
vec3 dp1perp=cross(normal,dp1);
vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;
vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;
tangent*=tangentSpaceParams.x;
bitangent*=tangentSpaceParams.y;
float det=max(dot(tangent,tangent),dot(bitangent,bitangent));
float invmax=det==0.0 ? 0.0 : inversesqrt(det);
return mat3(tangent*invmax,bitangent*invmax,normal);
}
#endif
`;
ShaderStore.IncludesShadersStore[name20] = shader20;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentFunctions.js
var name21 = "bumpFragmentFunctions";
var shader21 = `#if defined(BUMP)
#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)
#endif
#if defined(DETAIL)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)
#endif
#if defined(BUMP) && defined(PARALLAX)
const float minSamples=4.;
const float maxSamples=15.;
const int iMaxSamples=15;
vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {
float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;
parallaxLimit*=parallaxScale;
vec2 vOffsetDir=normalize(vViewDirCoT.xy);
vec2 vMaxOffset=vOffsetDir*parallaxLimit;
float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));
float stepSize=1.0/numSamples;
float currRayHeight=1.0;
vec2 vCurrOffset=vec2(0,0);
vec2 vLastOffset=vec2(0,0);
float lastSampledHeight=1.0;
float currSampledHeight=1.0;
bool keepWorking=true;
for (int i=0; i<iMaxSamples; i++)
{
currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;
if (!keepWorking)
{
}
else if (currSampledHeight>currRayHeight)
{
float delta1=currSampledHeight-currRayHeight;
float delta2=(currRayHeight+stepSize)-lastSampledHeight;
float ratio=delta1/(delta1+delta2);
vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;
keepWorking=false;
}
else
{
currRayHeight-=stepSize;
vLastOffset=vCurrOffset;
vCurrOffset+=stepSize*vMaxOffset;
lastSampledHeight=currSampledHeight;
}
}
return vCurrOffset;
}
vec2 parallaxOffset(vec3 viewDir,float heightScale)
{
float height=texture2D(bumpSampler,vBumpUV).w;
vec2 texCoordOffset=heightScale*viewDir.xy*height;
return -texCoordOffset;
}
#endif
`;
ShaderStore.IncludesShadersStore[name21] = shader21;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js
var name22 = "clipPlaneFragmentDeclaration";
var shader22 = `#ifdef CLIPPLANE
varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
varying float fClipDistance6;
#endif
`;
ShaderStore.IncludesShadersStore[name22] = shader22;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration.js
var name23 = "logDepthDeclaration";
var shader23 = `#ifdef LOGARITHMICDEPTH
uniform float logarithmicDepthConstant;
varying float vFragmentDepth;
#endif
`;
ShaderStore.IncludesShadersStore[name23] = shader23;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js
var name24 = "fogFragmentDeclaration";
var shader24 = `#ifdef FOG
#define FOGMODE_NONE 0.
#define FOGMODE_EXP 1.
#define FOGMODE_EXP2 2.
#define FOGMODE_LINEAR 3.
#define E 2.71828
uniform vec4 vFogInfos;
uniform vec3 vFogColor;
varying vec3 vFogDistance;
float CalcFogFactor()
{
float fogCoeff=1.0;
float fogStart=vFogInfos.y;
float fogEnd=vFogInfos.z;
float fogDensity=vFogInfos.w;
float fogDistance=length(vFogDistance);
if (FOGMODE_LINEAR==vFogInfos.x)
{
fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);
}
else if (FOGMODE_EXP==vFogInfos.x)
{
fogCoeff=1.0/pow(E,fogDistance*fogDensity);
}
else if (FOGMODE_EXP2==vFogInfos.x)
{
fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);
}
return clamp(fogCoeff,0.0,1.0);
}
#endif
`;
ShaderStore.IncludesShadersStore[name24] = shader24;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js
var name25 = "clipPlaneFragment";
var shader25 = `#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
if (false) {}
#endif
#ifdef CLIPPLANE
else if (fClipDistance>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE2
else if (fClipDistance2>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE3
else if (fClipDistance3>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE4
else if (fClipDistance4>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE5
else if (fClipDistance5>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE6
else if (fClipDistance6>0.0)
{
discard;
}
#endif
`;
ShaderStore.IncludesShadersStore[name25] = shader25;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragment.js
var name26 = "bumpFragment";
var shader26 = `vec2 uvOffset=vec2(0.0,0.0);
#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)
#ifdef NORMALXYSCALE
float normalScale=1.0;
#elif defined(BUMP)
float normalScale=vBumpInfos.y;
#else
float normalScale=1.0;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#elif defined(BUMP)
vec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;
mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);
#else
vec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;
mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));
#endif
#elif defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#else
vec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;
mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));
#endif
#endif
#ifdef PARALLAX
mat3 invTBN=transposeMat3(TBN);
#ifdef PARALLAXOCCLUSION
uvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);
#else
uvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);
#endif
#endif
#ifdef DETAIL
vec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);
vec2 detailNormalRG=detailColor.wy*2.0-1.0;
float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));
vec3 detailNormal=vec3(detailNormalRG,detailNormalB);
#endif
#ifdef BUMP
#ifdef OBJECTSPACE_NORMALMAP
normalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);
normalW=normalize(mat3(normalMatrix)*normalW);
#elif !defined(DETAIL)
normalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);
#else
vec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;
#if DETAIL_NORMALBLENDMETHOD==0 
detailNormal.xy*=vDetailInfos.z;
vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));
#elif DETAIL_NORMALBLENDMETHOD==1 
detailNormal.xy*=vDetailInfos.z;
bumpNormal+=vec3(0.0,0.0,1.0);
detailNormal*=vec3(-1.0,-1.0,1.0);
vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;
#endif
normalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);
#endif
#elif defined(DETAIL)
detailNormal.xy*=vDetailInfos.z;
normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);
#endif
`;
ShaderStore.IncludesShadersStore[name26] = shader26;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/depthPrePass.js
var name27 = "depthPrePass";
var shader27 = `#ifdef DEPTHPREPASS
gl_FragColor=vec4(0.,0.,0.,1.0);
return;
#endif
`;
ShaderStore.IncludesShadersStore[name27] = shader27;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragment.js
var name28 = "lightFragment";
var shader28 = `#ifdef LIGHT{X}
#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})
#else
#ifdef PBR
#ifdef SPOTLIGHT{X}
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(POINTLIGHT{X})
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(HEMILIGHT{X})
preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(DIRLIGHT{X})
preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#endif
preInfo.NdotV=NdotV;
#ifdef SPOTLIGHT{X}
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#elif defined(POINTLIGHT{X})
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#endif
#else
preInfo.attenuation=1.0;
#endif
#ifdef HEMILIGHT{X}
preInfo.roughness=roughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#ifdef IRIDESCENCE
preInfo.iridescenceIntensity=iridescenceIntensity;
#endif
#ifdef HEMILIGHT{X}
info.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);
#elif defined(SS_TRANSLUCENCY)
info.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);
#else
info.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);
#endif
#ifdef SPECULARTERM
#ifdef ANISOTROPIC
info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#else
info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#endif
#ifdef SHEEN
#ifdef SHEEN_LINKWITHALBEDO
preInfo.roughness=sheenOut.sheenIntensity;
#else
#ifdef HEMILIGHT{X}
preInfo.roughness=sheenOut.sheenRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#endif
info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#ifdef CLEARCOAT
#ifdef HEMILIGHT{X}
preInfo.roughness=clearcoatOut.clearCoatRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);
#ifdef CLEARCOAT_TINT
absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);
info.diffuse*=absorption;
#ifdef SPECULARTERM
info.specular*=absorption;
#endif
#endif
info.diffuse*=info.clearCoat.w;
#ifdef SPECULARTERM
info.specular*=info.clearCoat.w;
#endif
#ifdef SHEEN
info.sheen*=info.clearCoat.w;
#endif
#endif
#else
#ifdef SPOTLIGHT{X}
info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#elif defined(HEMILIGHT{X})
info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);
#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})
info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#endif
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});
#endif
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) 
{
#ifdef SHADOWCSM_RIGHTHANDED{X}
diff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;
#else
diff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;
#endif
if (diff{X}>=0.) {
index{X}=i;
break;
}
}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
if (index{X}>=0)
#endif
{
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
shadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
shadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];
#endif
#ifndef SHADOWCSMNOBLEND{X}
float frustumLength=frustumLengths{X}[index{X}];
float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};
if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)
{
index{X}+=1;
float nextShadow=0.;
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
nextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
nextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
nextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
shadow=mix(nextShadow,shadow,diffRatio);
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);
#endif
}
#endif
}
#elif defined(SHADOWCLOSEESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPOISSON{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#else
#if defined(SHADOWCUBE{X})
shadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#endif
#ifdef SHADOWONLY
#ifndef SHADOWINUSE
#define SHADOWINUSE
#endif
globalShadow+=shadow;
shadowLightCount+=1.0;
#endif
#else
shadow=1.;
#endif
#ifndef SHADOWONLY
#ifdef CUSTOMUSERLIGHTING
diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);
#ifdef SPECULARTERM
specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);
#endif
#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})
diffuseBase+=lightmapColor.rgb*shadow;
#ifdef SPECULARTERM
#ifndef LIGHTMAPNOSPECULAR{X}
specularBase+=info.specular*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef CLEARCOAT
#ifndef LIGHTMAPNOSPECULAR{X}
clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef SHEEN
#ifndef LIGHTMAPNOSPECULAR{X}
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#else
#ifdef SHADOWCSMDEBUG{X}
diffuseBase+=info.diffuse*shadowDebug{X};
#else 
diffuseBase+=info.diffuse*shadow;
#endif
#ifdef SPECULARTERM
specularBase+=info.specular*shadow;
#endif
#ifdef CLEARCOAT
clearCoatBase+=info.clearCoat.rgb*shadow;
#endif
#ifdef SHEEN
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name28] = shader28;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthFragment.js
var name29 = "logDepthFragment";
var shader29 = `#ifdef LOGARITHMICDEPTH
gl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;
#endif
`;
ShaderStore.IncludesShadersStore[name29] = shader29;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragment.js
var name30 = "fogFragment";
var shader30 = `#ifdef FOG
float fog=CalcFogFactor();
#ifdef PBR
fog=toLinearSpace(fog);
#endif
color.rgb=mix(vFogColor,color.rgb,fog);
#endif
`;
ShaderStore.IncludesShadersStore[name30] = shader30;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/oitFragment.js
var name31 = "oitFragment";
var shader31 = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
float fragDepth=gl_FragCoord.z; 
#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS
uint halfFloat=packHalf2x16(vec2(fragDepth));
vec2 full=unpackHalf2x16(halfFloat);
fragDepth=full.x;
#endif
ivec2 fragCoord=ivec2(gl_FragCoord.xy);
vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;
vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);
depth.rg=vec2(-MAX_DEPTH);
frontColor=lastFrontColor;
backColor=vec4(0.0);
#ifdef USE_REVERSE_DEPTHBUFFER
float furthestDepth=-lastDepth.x;
float nearestDepth=lastDepth.y;
#else
float nearestDepth=-lastDepth.x;
float furthestDepth=lastDepth.y;
#endif
float alphaMultiplier=1.0-lastFrontColor.a;
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth>nearestDepth || fragDepth<furthestDepth) {
#else
if (fragDepth<nearestDepth || fragDepth>furthestDepth) {
#endif
return;
}
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth<nearestDepth && fragDepth>furthestDepth) {
#else
if (fragDepth>nearestDepth && fragDepth<furthestDepth) {
#endif
depth.rg=vec2(-fragDepth,fragDepth);
return;
}
#endif
`;
ShaderStore.IncludesShadersStore[name31] = shader31;

// node_modules/@babylonjs/core/Shaders/default.fragment.js
var name32 = "defaultPixelShader";
var shader32 = `#include<__decl__defaultFragment>
#if defined(BUMP) || !defined(NORMAL)
#extension GL_OES_standard_derivatives : enable
#endif
#include<prePassDeclaration>[SCENE_MRT_COUNT]
#include<oitDeclaration>
#define CUSTOM_FRAGMENT_BEGIN
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#define RECIPROCAL_PI2 0.15915494
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<mainUVVaryingDeclaration>[1..7]
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)
#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)
#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)
#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)
#ifdef REFRACTION
#ifdef REFRACTIONMAP_3D
uniform samplerCube refractionCubeSampler;
#else
uniform sampler2D refraction2DSampler;
#endif
#endif
#if defined(SPECULARTERM)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)
#endif
#include<fresnelFunction>
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
uniform samplerCube reflectionCubeSampler;
#else
uniform sampler2D reflection2DSampler;
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#include<reflectionFunction>
#endif
#include<imageProcessingDeclaration>
#include<imageProcessingFunctions>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
vec4 baseColor=vec4(1.,1.,1.,1.);
vec3 diffuseColor=vDiffuseColor.rgb;
float alpha=vDiffuseColor.a;
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));
#endif
#include<bumpFragment>
#ifdef TWOSIDEDLIGHTING
normalW=gl_FrontFacing ? normalW : -normalW;
#endif
#ifdef DIFFUSE
baseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);
#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)
if (baseColor.a<alphaCutOff)
discard;
#endif
#ifdef ALPHAFROMDIFFUSE
alpha*=baseColor.a;
#endif
#define CUSTOM_FRAGMENT_UPDATE_ALPHA
baseColor.rgb*=vDiffuseInfos.y;
#endif
#include<depthPrePass>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
baseColor.rgb*=vColor.rgb;
#endif
#ifdef DETAIL
baseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);
#endif
#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE
vec3 baseAmbientColor=vec3(1.,1.,1.);
#ifdef AMBIENT
baseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;
#endif
#define CUSTOM_FRAGMENT_BEFORE_LIGHTS
#ifdef SPECULARTERM
float glossiness=vSpecularColor.a;
vec3 specularColor=vSpecularColor.rgb;
#ifdef SPECULAR
vec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);
specularColor=specularMapColor.rgb;
#ifdef GLOSSINESS
glossiness=glossiness*specularMapColor.a;
#endif
#endif
#else
float glossiness=0.;
#endif
vec3 diffuseBase=vec3(0.,0.,0.);
lightingInfo info;
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
float shadow=1.;
#ifdef LIGHTMAP
vec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);
#ifdef RGBDLIGHTMAP
lightmapColor.rgb=fromRGBD(lightmapColor);
#endif
lightmapColor.rgb*=vLightmapInfos.y;
#endif
#include<lightFragment>[0..maxSimultaneousLights]
vec4 refractionColor=vec4(0.,0.,0.,1.);
#ifdef REFRACTION
vec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));
#ifdef REFRACTIONMAP_3D
#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC
refractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);
#endif
refractionVector.y=refractionVector.y*vRefractionInfos.w;
if (dot(refractionVector,viewDirectionW)<1.0) {
refractionColor=textureCube(refractionCubeSampler,refractionVector);
}
#else
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));
vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;
refractionCoords.y=1.0-refractionCoords.y;
refractionColor=texture2D(refraction2DSampler,refractionCoords);
#endif
#ifdef RGBDREFRACTION
refractionColor.rgb=fromRGBD(refractionColor);
#endif
#ifdef IS_REFRACTION_LINEAR
refractionColor.rgb=toGammaSpace(refractionColor.rgb);
#endif
refractionColor.rgb*=vRefractionInfos.x;
#endif
vec4 reflectionColor=vec4(0.,0.,0.,1.);
#ifdef REFLECTION
vec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
vReflectionUVW.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
#ifdef ROUGHNESS
float bias=vReflectionInfos.y;
#ifdef SPECULARTERM
#ifdef SPECULAR
#ifdef GLOSSINESS
bias*=(1.0-specularMapColor.a);
#endif
#endif
#endif
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);
#else
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);
#endif
#else
vec2 coords=vReflectionUVW.xy;
#ifdef REFLECTIONMAP_PROJECTION
coords/=vReflectionUVW.z;
#endif
coords.y=1.0-coords.y;
reflectionColor=texture2D(reflection2DSampler,coords);
#endif
#ifdef RGBDREFLECTION
reflectionColor.rgb=fromRGBD(reflectionColor);
#endif
#ifdef IS_REFLECTION_LINEAR
reflectionColor.rgb=toGammaSpace(reflectionColor.rgb);
#endif
reflectionColor.rgb*=vReflectionInfos.x;
#ifdef REFLECTIONFRESNEL
float reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);
#ifdef REFLECTIONFRESNELFROMSPECULAR
#ifdef SPECULARTERM
reflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#endif
#endif
#ifdef REFRACTIONFRESNEL
float refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);
refractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);
#ifdef OPACITYRGB
opacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);
alpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;
#else
alpha*=opacityMap.a*vOpacityInfos.y;
#endif
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#ifdef OPACITYFRESNEL
float opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);
alpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;
#endif
#ifdef ALPHATEST
#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS
if (alpha<alphaCutOff)
discard;
#endif
#ifndef ALPHABLEND
alpha=1.0;
#endif
#endif
vec3 emissiveColor=vEmissiveColor;
#ifdef EMISSIVE
emissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;
#endif
#ifdef EMISSIVEFRESNEL
float emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);
emissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;
#endif
#ifdef DIFFUSEFRESNEL
float diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);
diffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;
#endif
#ifdef EMISSIVEASILLUMINATION
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
#ifdef LINKEMISSIVEWITHDIFFUSE
vec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#endif
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase*specularColor;
#ifdef SPECULAROVERALPHA
alpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#else
vec3 finalSpecular=vec3(0.0);
#endif
#ifdef REFLECTIONOVERALPHA
alpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#ifdef EMISSIVEASILLUMINATION
vec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);
#else
vec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);
#endif
#ifdef LIGHTMAP
#ifndef LIGHTMAPEXCLUDED
#ifdef USELIGHTMAPASSHADOWMAP
color.rgb*=lightmapColor.rgb;
#else
color.rgb+=lightmapColor.rgb;
#endif
#endif
#endif
#define CUSTOM_FRAGMENT_BEFORE_FOG
color.rgb=max(color.rgb,0.);
#include<logDepthFragment>
#include<fogFragment>
#ifdef IMAGEPROCESSINGPOSTPROCESS
color.rgb=toLinearSpace(color.rgb);
#else
#ifdef IMAGEPROCESSING
color.rgb=toLinearSpace(color.rgb);
color=applyImageProcessing(color);
#endif
#endif
color.a*=visibility;
#ifdef PREMULTIPLYALPHA
color.rgb*=color.a;
#endif
#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR
#ifdef PREPASS
float writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;
gl_FragData[0]=color; 
#ifdef PREPASS_POSITION
gl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);
#endif
#ifdef PREPASS_VELOCITY
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;
vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;
vec2 velocity=abs(a-b);
velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;
gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_IRRADIANCE
gl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_DEPTH
gl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_NORMAL
gl_FragData[PREPASS_NORMAL_INDEX]=vec4((view*vec4(normalW,0.0)).rgb,writeGeometryInfo); 
#endif
#ifdef PREPASS_ALBEDO_SQRT
gl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_REFLECTIVITY
#if defined(SPECULARTERM)
#if defined(SPECULAR)
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularMapColor)*writeGeometryInfo; 
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularColor,1.0)*writeGeometryInfo;
#endif
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0)*writeGeometryInfo;
#endif
#endif
#endif
#if !defined(PREPASS) || defined(WEBGL2)
gl_FragColor=color;
#endif
#include<oitFragment>
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {
frontColor.rgb+=color.rgb*color.a*alphaMultiplier;
frontColor.a=1.0-alphaMultiplier*(1.0-color.a);
} else {
backColor+=color;
}
#endif
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
ShaderStore.ShadersStore[name32] = shader32;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultVertexDeclaration.js
var name33 = "defaultVertexDeclaration";
var shader33 = `uniform mat4 viewProjection;
uniform mat4 view;
#ifdef DIFFUSE
uniform mat4 diffuseMatrix;
uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform mat4 ambientMatrix;
uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY
uniform mat4 opacityMatrix;
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
uniform mat4 emissiveMatrix;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
uniform mat4 lightmapMatrix;
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;
uniform mat4 specularMatrix;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;
uniform mat4 bumpMatrix;
#endif
#ifdef REFLECTION
uniform mat4 reflectionMatrix;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
uniform mat4 detailMatrix;
#endif
#define ADDITIONAL_VERTEX_DECLARATION
`;
ShaderStore.IncludesShadersStore[name33] = shader33;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/uvAttributeDeclaration.js
var name34 = "uvAttributeDeclaration";
var shader34 = `#ifdef UV{X}
attribute vec2 uv{X};
#endif
`;
ShaderStore.IncludesShadersStore[name34] = shader34;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js
var name35 = "bonesDeclaration";
var shader35 = `#if NUM_BONE_INFLUENCERS>0
attribute vec4 matricesIndices;
attribute vec4 matricesWeights;
#if NUM_BONE_INFLUENCERS>4
attribute vec4 matricesIndicesExtra;
attribute vec4 matricesWeightsExtra;
#endif
#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#ifdef BONETEXTURE
uniform sampler2D boneSampler;
uniform float boneTextureWidth;
#else
uniform mat4 mBones[BonesPerMesh];
#ifdef BONES_VELOCITY_ENABLED
uniform mat4 mPreviousBones[BonesPerMesh];
#endif
#endif
#ifdef BONETEXTURE
#define inline
mat4 readMatrixFromRawSampler(sampler2D smp,float index)
{
float offset=index *4.0;
float dx=1.0/boneTextureWidth;
vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));
vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));
vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));
vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));
return mat4(m0,m1,m2,m3);
}
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name35] = shader35;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.js
var name36 = "bakedVertexAnimationDeclaration";
var shader36 = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
uniform float bakedVertexAnimationTime;
uniform vec2 bakedVertexAnimationTextureSizeInverted;
uniform vec4 bakedVertexAnimationSettings;
uniform sampler2D bakedVertexAnimationTexture;
#ifdef INSTANCES
attribute vec4 bakedVertexAnimationSettingsInstanced;
#endif
#define inline
mat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)
{
float offset=index*4.0;
float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;
float dx=bakedVertexAnimationTextureSizeInverted.x;
vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));
vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));
vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));
vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));
return mat4(m0,m1,m2,m3);
}
#endif
`;
ShaderStore.IncludesShadersStore[name36] = shader36;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js
var name37 = "instancesDeclaration";
var shader37 = `#ifdef INSTANCES
attribute vec4 world0;
attribute vec4 world1;
attribute vec4 world2;
attribute vec4 world3;
#ifdef INSTANCESCOLOR
attribute vec4 instanceColor;
#endif
#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
attribute vec4 previousWorld0;
attribute vec4 previousWorld1;
attribute vec4 previousWorld2;
attribute vec4 previousWorld3;
#ifdef THIN_INSTANCES
uniform mat4 previousWorld;
#endif
#endif
#else
#if !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
uniform mat4 previousWorld;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name37] = shader37;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertexDeclaration.js
var name38 = "prePassVertexDeclaration";
var shader38 = `#ifdef PREPASS
#ifdef PREPASS_DEPTH
varying vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
uniform mat4 previousViewProjection;
varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name38] = shader38;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexDeclaration.js
var name39 = "samplerVertexDeclaration";
var shader39 = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
varying vec2 v_VARYINGNAME_UV;
#endif
`;
ShaderStore.IncludesShadersStore[name39] = shader39;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertexDeclaration.js
var name40 = "bumpVertexDeclaration";
var shader40 = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name40] = shader40;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js
var name41 = "clipPlaneVertexDeclaration";
var shader41 = `#ifdef CLIPPLANE
uniform vec4 vClipPlane;
varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
uniform vec4 vClipPlane2;
varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
uniform vec4 vClipPlane3;
varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
uniform vec4 vClipPlane4;
varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
uniform vec4 vClipPlane5;
varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
uniform vec4 vClipPlane6;
varying float fClipDistance6;
#endif
`;
ShaderStore.IncludesShadersStore[name41] = shader41;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js
var name42 = "fogVertexDeclaration";
var shader42 = `#ifdef FOG
varying vec3 vFogDistance;
#endif
`;
ShaderStore.IncludesShadersStore[name42] = shader42;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxFragmentDeclaration.js
var name43 = "lightVxFragmentDeclaration";
var shader43 = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};
uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};
uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};
uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name43] = shader43;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxUboDeclaration.js
var name44 = "lightVxUboDeclaration";
var shader44 = `#ifdef LIGHT{X}
uniform Light{X}
{
vec4 vLightData;
vec4 vLightDiffuse;
vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;
vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;
vec2 depthValues;
} light{X};
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name44] = shader44;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js
var name45 = "morphTargetsVertexGlobalDeclaration";
var shader45 = `#ifdef MORPHTARGETS
uniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];
#ifdef MORPHTARGETS_TEXTURE 
precision mediump sampler2DArray; 
uniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];
uniform vec3 morphTargetTextureInfo;
uniform sampler2DArray morphTargets;
vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)
{ 
float y=floor(vertexIndex/morphTargetTextureInfo.y);
float x=vertexIndex-y*morphTargetTextureInfo.y;
vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);
return texture(morphTargets,textureUV).xyz;
}
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name45] = shader45;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.js
var name46 = "morphTargetsVertexDeclaration";
var shader46 = `#ifdef MORPHTARGETS
#ifndef MORPHTARGETS_TEXTURE
attribute vec3 position{X};
#ifdef MORPHTARGETS_NORMAL
attribute vec3 normal{X};
#endif
#ifdef MORPHTARGETS_TANGENT
attribute vec3 tangent{X};
#endif
#ifdef MORPHTARGETS_UV
attribute vec2 uv_{X};
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name46] = shader46;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobal.js
var name47 = "morphTargetsVertexGlobal";
var shader47 = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
float vertexID;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name47] = shader47;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js
var name48 = "morphTargetsVertex";
var shader48 = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE 
vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;
positionUpdated+=(readVector3FromRawSampler({X},vertexID)-position)*morphTargetInfluences[{X}];
vertexID+=1.0;
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(readVector3FromRawSampler({X},vertexID) -normal)*morphTargetInfluences[{X}];
vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(readVector3FromRawSampler({X},vertexID).xy-uv)*morphTargetInfluences[{X}];
vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(readVector3FromRawSampler({X},vertexID) -tangent.xyz)*morphTargetInfluences[{X}];
#endif
#else
positionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name48] = shader48;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js
var name49 = "instancesVertex";
var shader49 = `#ifdef INSTANCES
mat4 finalWorld=mat4(world0,world1,world2,world3);
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);
#endif
#ifdef THIN_INSTANCES
finalWorld=world*finalWorld;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
finalPreviousWorld=previousWorld*finalPreviousWorld;
#endif
#endif
#else
mat4 finalWorld=world;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=previousWorld;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name49] = shader49;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js
var name50 = "bonesVertex";
var shader50 = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#if NUM_BONE_INFLUENCERS>0
mat4 influence;
#ifdef BONETEXTURE
influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];
#endif
#else
influence=mBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=mBones[int(matricesIndices[1])]*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=mBones[int(matricesIndices[2])]*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=mBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
#endif
finalWorld=finalWorld*influence;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name50] = shader50;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimation.js
var name51 = "bakedVertexAnimation";
var shader51 = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
{
#ifdef INSTANCES
#define BVASNAME bakedVertexAnimationSettingsInstanced
#else
#define BVASNAME bakedVertexAnimationSettings
#endif
float VATStartFrame=BVASNAME.x;
float VATEndFrame=BVASNAME.y;
float VATOffsetFrame=BVASNAME.z;
float VATSpeed=BVASNAME.w;
float totalFrames=VATEndFrame-VATStartFrame+1.0;
float time=bakedVertexAnimationTime*VATSpeed/totalFrames;
float frameCorrection=time<1.0 ? 0.0 : 1.0;
float numOfFrames=totalFrames-frameCorrection;
float VATFrameNum=fract(time)*numOfFrames;
VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);
VATFrameNum=floor(VATFrameNum);
VATFrameNum+=VATStartFrame+frameCorrection;
mat4 VATInfluence;
VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];
#endif
finalWorld=finalWorld*VATInfluence;
}
#endif
`;
ShaderStore.IncludesShadersStore[name51] = shader51;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertex.js
var name52 = "prePassVertex";
var shader52 = `#ifdef PREPASS_DEPTH
vViewPos=(view*worldPos).rgb;
#endif
#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*worldPos;
#if NUM_BONE_INFLUENCERS>0
mat4 previousInfluence;
previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);
#else
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name52] = shader52;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/uvVariableDeclaration.js
var name53 = "uvVariableDeclaration";
var shader53 = `#if !defined(UV{X}) && defined(MAINUV{X})
vec2 uv{X}=vec2(0.,0.);
#endif
#ifdef MAINUV{X}
vMainUV{X}=uv{X};
#endif
`;
ShaderStore.IncludesShadersStore[name53] = shader53;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexImplementation.js
var name54 = "samplerVertexImplementation";
var shader54 = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
if (v_INFONAME_==0.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));
}
#ifdef UV2
else if (v_INFONAME_==1.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));
}
#endif
#ifdef UV3
else if (v_INFONAME_==2.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));
}
#endif
#ifdef UV4
else if (v_INFONAME_==3.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));
}
#endif
#ifdef UV5
else if (v_INFONAME_==4.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));
}
#endif
#ifdef UV6
else if (v_INFONAME_==5.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));
}
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name54] = shader54;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertex.js
var name55 = "bumpVertex";
var shader55 = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
vec3 tbnNormal=normalize(normalUpdated);
vec3 tbnTangent=normalize(tangentUpdated.xyz);
vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;
vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name55] = shader55;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex.js
var name56 = "clipPlaneVertex";
var shader56 = `#ifdef CLIPPLANE
fClipDistance=dot(worldPos,vClipPlane);
#endif
#ifdef CLIPPLANE2
fClipDistance2=dot(worldPos,vClipPlane2);
#endif
#ifdef CLIPPLANE3
fClipDistance3=dot(worldPos,vClipPlane3);
#endif
#ifdef CLIPPLANE4
fClipDistance4=dot(worldPos,vClipPlane4);
#endif
#ifdef CLIPPLANE5
fClipDistance5=dot(worldPos,vClipPlane5);
#endif
#ifdef CLIPPLANE6
fClipDistance6=dot(worldPos,vClipPlane6);
#endif
`;
ShaderStore.IncludesShadersStore[name56] = shader56;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertex.js
var name57 = "fogVertex";
var shader57 = `#ifdef FOG
vFogDistance=(view*worldPos).xyz;
#endif
`;
ShaderStore.IncludesShadersStore[name57] = shader57;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js
var name58 = "shadowsVertex";
var shader58 = `#ifdef SHADOWS
#if defined(SHADOWCSM{X})
vPositionFromCamera{X}=view*worldPos;
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {
vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
}
#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})
vPositionFromLight{X}=lightMatrix{X}*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name58] = shader58;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/vertexColorMixing.js
var name59 = "vertexColorMixing";
var shader59 = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
vColor=vec4(1.0);
#ifdef VERTEXCOLOR
#ifdef VERTEXALPHA
vColor*=color;
#else
vColor.rgb*=color.rgb;
#endif
#endif
#ifdef INSTANCESCOLOR
vColor*=instanceColor;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name59] = shader59;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pointCloudVertex.js
var name60 = "pointCloudVertex";
var shader60 = `#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
`;
ShaderStore.IncludesShadersStore[name60] = shader60;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthVertex.js
var name61 = "logDepthVertex";
var shader61 = `#ifdef LOGARITHMICDEPTH
vFragmentDepth=1.0+gl_Position.w;
gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;
#endif
`;
ShaderStore.IncludesShadersStore[name61] = shader61;

// node_modules/@babylonjs/core/Shaders/default.vertex.js
var name62 = "defaultVertexShader";
var shader62 = `#include<__decl__defaultVertex>
#define CUSTOM_VERTEX_BEGIN
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef TANGENT
attribute vec4 tangent;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#include<uvAttributeDeclaration>[2..7]
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
#include<prePassVertexDeclaration>
#include<mainUVVaryingDeclaration>[1..7]
#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)
#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)
#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)
#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)
#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)
#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)
#if defined(SPECULARTERM)
#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)
#endif
#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<bumpVertexDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 positionUpdated=position;
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#ifdef TANGENT
vec4 tangentUpdated=tangent;
#endif
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=positionUpdated;
#endif
#define CUSTOM_VERTEX_UPDATE_POSITION
#define CUSTOM_VERTEX_UPDATE_NORMAL
#include<instancesVertex>
#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));
vNormalW=normalize(normalWorld*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normalUpdated);
#endif
#endif
#define CUSTOM_VERTEX_UPDATE_WORLDPOS
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {
gl_Position=viewProjection*worldPos;
} else {
gl_Position=viewProjectionR*worldPos;
}
#else
gl_Position=viewProjection*worldPos;
#endif
vPositionW=vec3(worldPos);
#include<prePassVertex>
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));
#endif
#ifndef UV1
vec2 uvUpdated=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uvUpdated;
#endif
#include<uvVariableDeclaration>[2..7]
#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)
#if defined(SPECULARTERM)
#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)
#endif
#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)
#include<bumpVertex>
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#include<pointCloudVertex>
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name62] = shader62;

// node_modules/@babylonjs/core/Materials/standardMaterial.js
var onCreatedEffectParameters = { effect: null, subMesh: null };
var StandardMaterialDefines = class extends MaterialDefines {
  constructor(externalProperties) {
    super(externalProperties);
    this.MAINUV1 = false;
    this.MAINUV2 = false;
    this.MAINUV3 = false;
    this.MAINUV4 = false;
    this.MAINUV5 = false;
    this.MAINUV6 = false;
    this.DIFFUSE = false;
    this.DIFFUSEDIRECTUV = 0;
    this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
    this.AMBIENT = false;
    this.AMBIENTDIRECTUV = 0;
    this.OPACITY = false;
    this.OPACITYDIRECTUV = 0;
    this.OPACITYRGB = false;
    this.REFLECTION = false;
    this.EMISSIVE = false;
    this.EMISSIVEDIRECTUV = 0;
    this.SPECULAR = false;
    this.SPECULARDIRECTUV = 0;
    this.BUMP = false;
    this.BUMPDIRECTUV = 0;
    this.PARALLAX = false;
    this.PARALLAXOCCLUSION = false;
    this.SPECULAROVERALPHA = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.ALPHAFROMDIFFUSE = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.SPECULARTERM = false;
    this.DIFFUSEFRESNEL = false;
    this.OPACITYFRESNEL = false;
    this.REFLECTIONFRESNEL = false;
    this.REFRACTIONFRESNEL = false;
    this.EMISSIVEFRESNEL = false;
    this.FRESNEL = false;
    this.NORMAL = false;
    this.TANGENT = false;
    this.UV1 = false;
    this.UV2 = false;
    this.UV3 = false;
    this.UV4 = false;
    this.UV5 = false;
    this.UV6 = false;
    this.VERTEXCOLOR = false;
    this.VERTEXALPHA = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.BONETEXTURE = false;
    this.BONES_VELOCITY_ENABLED = false;
    this.INSTANCES = false;
    this.THIN_INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.GLOSSINESS = false;
    this.ROUGHNESS = false;
    this.EMISSIVEASILLUMINATION = false;
    this.LINKEMISSIVEWITHDIFFUSE = false;
    this.REFLECTIONFRESNELFROMSPECULAR = false;
    this.LIGHTMAP = false;
    this.LIGHTMAPDIRECTUV = 0;
    this.OBJECTSPACE_NORMALMAP = false;
    this.USELIGHTMAPASSHADOWMAP = false;
    this.REFLECTIONMAP_3D = false;
    this.REFLECTIONMAP_SPHERICAL = false;
    this.REFLECTIONMAP_PLANAR = false;
    this.REFLECTIONMAP_CUBIC = false;
    this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
    this.USE_LOCAL_REFRACTIONMAP_CUBIC = false;
    this.REFLECTIONMAP_PROJECTION = false;
    this.REFLECTIONMAP_SKYBOX = false;
    this.REFLECTIONMAP_EXPLICIT = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
    this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
    this.REFLECTIONMAP_OPPOSITEZ = false;
    this.INVERTCUBICMAP = false;
    this.LOGARITHMICDEPTH = false;
    this.REFRACTION = false;
    this.REFRACTIONMAP_3D = false;
    this.REFLECTIONOVERALPHA = false;
    this.TWOSIDEDLIGHTING = false;
    this.SHADOWFLOAT = false;
    this.MORPHTARGETS = false;
    this.MORPHTARGETS_NORMAL = false;
    this.MORPHTARGETS_TANGENT = false;
    this.MORPHTARGETS_UV = false;
    this.NUM_MORPH_INFLUENCERS = 0;
    this.MORPHTARGETS_TEXTURE = false;
    this.NONUNIFORMSCALING = false;
    this.PREMULTIPLYALPHA = false;
    this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = false;
    this.ALPHABLEND = true;
    this.PREPASS = false;
    this.PREPASS_IRRADIANCE = false;
    this.PREPASS_IRRADIANCE_INDEX = -1;
    this.PREPASS_ALBEDO_SQRT = false;
    this.PREPASS_ALBEDO_SQRT_INDEX = -1;
    this.PREPASS_DEPTH = false;
    this.PREPASS_DEPTH_INDEX = -1;
    this.PREPASS_NORMAL = false;
    this.PREPASS_NORMAL_INDEX = -1;
    this.PREPASS_POSITION = false;
    this.PREPASS_POSITION_INDEX = -1;
    this.PREPASS_VELOCITY = false;
    this.PREPASS_VELOCITY_INDEX = -1;
    this.PREPASS_REFLECTIVITY = false;
    this.PREPASS_REFLECTIVITY_INDEX = -1;
    this.SCENE_MRT_COUNT = 0;
    this.RGBDLIGHTMAP = false;
    this.RGBDREFLECTION = false;
    this.RGBDREFRACTION = false;
    this.IMAGEPROCESSING = false;
    this.VIGNETTE = false;
    this.VIGNETTEBLENDMODEMULTIPLY = false;
    this.VIGNETTEBLENDMODEOPAQUE = false;
    this.TONEMAPPING = false;
    this.TONEMAPPING_ACES = false;
    this.CONTRAST = false;
    this.COLORCURVES = false;
    this.COLORGRADING = false;
    this.COLORGRADING3D = false;
    this.SAMPLER3DGREENDEPTH = false;
    this.SAMPLER3DBGRMAP = false;
    this.DITHER = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.MULTIVIEW = false;
    this.ORDER_INDEPENDENT_TRANSPARENCY = false;
    this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;
    this.CAMERA_ORTHOGRAPHIC = false;
    this.CAMERA_PERSPECTIVE = false;
    this.IS_REFLECTION_LINEAR = false;
    this.IS_REFRACTION_LINEAR = false;
    this.EXPOSURE = false;
    this.rebuild();
  }
  setReflectionMode(modeToEnable) {
    const modes = [
      "REFLECTIONMAP_CUBIC",
      "REFLECTIONMAP_EXPLICIT",
      "REFLECTIONMAP_PLANAR",
      "REFLECTIONMAP_PROJECTION",
      "REFLECTIONMAP_PROJECTION",
      "REFLECTIONMAP_SKYBOX",
      "REFLECTIONMAP_SPHERICAL",
      "REFLECTIONMAP_EQUIRECTANGULAR",
      "REFLECTIONMAP_EQUIRECTANGULAR_FIXED",
      "REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"
    ];
    for (const mode of modes) {
      this[mode] = mode === modeToEnable;
    }
  }
};
var StandardMaterial = class extends PushMaterial {
  constructor(name63, scene) {
    super(name63, scene);
    this._diffuseTexture = null;
    this._ambientTexture = null;
    this._opacityTexture = null;
    this._reflectionTexture = null;
    this._emissiveTexture = null;
    this._specularTexture = null;
    this._bumpTexture = null;
    this._lightmapTexture = null;
    this._refractionTexture = null;
    this.ambientColor = new Color3(0, 0, 0);
    this.diffuseColor = new Color3(1, 1, 1);
    this.specularColor = new Color3(1, 1, 1);
    this.emissiveColor = new Color3(0, 0, 0);
    this.specularPower = 64;
    this._useAlphaFromDiffuseTexture = false;
    this._useEmissiveAsIllumination = false;
    this._linkEmissiveWithDiffuse = false;
    this._useSpecularOverAlpha = false;
    this._useReflectionOverAlpha = false;
    this._disableLighting = false;
    this._useObjectSpaceNormalMap = false;
    this._useParallax = false;
    this._useParallaxOcclusion = false;
    this.parallaxScaleBias = 0.05;
    this._roughness = 0;
    this.indexOfRefraction = 0.98;
    this.invertRefractionY = true;
    this.alphaCutOff = 0.4;
    this._useLightmapAsShadowmap = false;
    this._useReflectionFresnelFromSpecular = false;
    this._useGlossinessFromSpecularMapAlpha = false;
    this._maxSimultaneousLights = 4;
    this._invertNormalMapX = false;
    this._invertNormalMapY = false;
    this._twoSidedLighting = false;
    this._renderTargets = new SmartArray(16);
    this._worldViewProjectionMatrix = Matrix.Zero();
    this._globalAmbientColor = new Color3(0, 0, 0);
    this._cacheHasRenderTargetTextures = false;
    this.detailMap = new DetailMapConfiguration(this);
    this._attachImageProcessingConfiguration(null);
    this.prePassConfiguration = new PrePassConfiguration();
    this.getRenderTargetTextures = () => {
      this._renderTargets.reset();
      if (StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
        this._renderTargets.push(this._reflectionTexture);
      }
      if (StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
        this._renderTargets.push(this._refractionTexture);
      }
      this._eventInfo.renderTargets = this._renderTargets;
      this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);
      return this._renderTargets;
    };
  }
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  set imageProcessingConfiguration(value) {
    this._attachImageProcessingConfiguration(value);
    this._markAllSubMeshesAsTexturesDirty();
  }
  _attachImageProcessingConfiguration(configuration) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (!configuration) {
      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
        this._markAllSubMeshesAsImageProcessingDirty();
      });
    }
  }
  get isPrePassCapable() {
    return !this.disableDepthWrite;
  }
  get cameraColorCurvesEnabled() {
    return this.imageProcessingConfiguration.colorCurvesEnabled;
  }
  set cameraColorCurvesEnabled(value) {
    this.imageProcessingConfiguration.colorCurvesEnabled = value;
  }
  get cameraColorGradingEnabled() {
    return this.imageProcessingConfiguration.colorGradingEnabled;
  }
  set cameraColorGradingEnabled(value) {
    this.imageProcessingConfiguration.colorGradingEnabled = value;
  }
  get cameraToneMappingEnabled() {
    return this._imageProcessingConfiguration.toneMappingEnabled;
  }
  set cameraToneMappingEnabled(value) {
    this._imageProcessingConfiguration.toneMappingEnabled = value;
  }
  get cameraExposure() {
    return this._imageProcessingConfiguration.exposure;
  }
  set cameraExposure(value) {
    this._imageProcessingConfiguration.exposure = value;
  }
  get cameraContrast() {
    return this._imageProcessingConfiguration.contrast;
  }
  set cameraContrast(value) {
    this._imageProcessingConfiguration.contrast = value;
  }
  get cameraColorGradingTexture() {
    return this._imageProcessingConfiguration.colorGradingTexture;
  }
  set cameraColorGradingTexture(value) {
    this._imageProcessingConfiguration.colorGradingTexture = value;
  }
  get cameraColorCurves() {
    return this._imageProcessingConfiguration.colorCurves;
  }
  set cameraColorCurves(value) {
    this._imageProcessingConfiguration.colorCurves = value;
  }
  get canRenderToMRT() {
    return true;
  }
  get hasRenderTargetTextures() {
    if (StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
      return true;
    }
    if (StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
      return true;
    }
    return this._cacheHasRenderTargetTextures;
  }
  getClassName() {
    return "StandardMaterial";
  }
  get useLogarithmicDepth() {
    return this._useLogarithmicDepth;
  }
  set useLogarithmicDepth(value) {
    this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;
    this._markAllSubMeshesAsMiscDirty();
  }
  needAlphaBlending() {
    if (this._disableAlphaBlending) {
      return false;
    }
    return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
  }
  needAlphaTesting() {
    if (this._forceAlphaTest) {
      return true;
    }
    return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === Material.MATERIAL_ALPHATEST);
  }
  _shouldUseAlphaFromDiffuseTexture() {
    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Material.MATERIAL_OPAQUE;
  }
  _hasAlphaChannel() {
    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._opacityTexture != null;
  }
  getAlphaTestTexture() {
    return this._diffuseTexture;
  }
  isReadyForSubMesh(mesh, subMesh, useInstances = false) {
    if (!this._uniformBufferLayoutBuilt) {
      this.buildUniformLayout();
    }
    if (subMesh.effect && this.isFrozen) {
      if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);
      subMesh.materialDefines = new StandardMaterialDefines(this._eventInfo.defineNames);
    }
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
    MaterialHelper.PrepareDefinesForMultiview(scene, defines);
    const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
    MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
    MaterialHelper.PrepareDefinesForOIT(scene, defines, oit);
    if (defines._areTexturesDirty) {
      this._eventInfo.hasRenderTargetTextures = false;
      this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
      this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
      defines._needUVs = false;
      for (let i = 1; i <= 6; ++i) {
        defines["MAINUV" + i] = false;
      }
      if (scene.texturesEnabled) {
        defines.DIFFUSEDIRECTUV = 0;
        defines.BUMPDIRECTUV = 0;
        defines.AMBIENTDIRECTUV = 0;
        defines.OPACITYDIRECTUV = 0;
        defines.EMISSIVEDIRECTUV = 0;
        defines.SPECULARDIRECTUV = 0;
        defines.LIGHTMAPDIRECTUV = 0;
        if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {
          if (!this._diffuseTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, "DIFFUSE");
          }
        } else {
          defines.DIFFUSE = false;
        }
        if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {
          if (!this._ambientTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
          }
        } else {
          defines.AMBIENT = false;
        }
        if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {
          if (!this._opacityTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
            defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
          }
        } else {
          defines.OPACITY = false;
        }
        if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {
          if (!this._reflectionTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            defines._needNormals = true;
            defines.REFLECTION = true;
            defines.ROUGHNESS = this._roughness > 0;
            defines.REFLECTIONOVERALPHA = this._useReflectionOverAlpha;
            defines.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;
            defines.REFLECTIONMAP_3D = this._reflectionTexture.isCube;
            defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !this._reflectionTexture.invertZ : this._reflectionTexture.invertZ;
            defines.RGBDREFLECTION = this._reflectionTexture.isRGBD;
            switch (this._reflectionTexture.coordinatesMode) {
              case Texture.EXPLICIT_MODE:
                defines.setReflectionMode("REFLECTIONMAP_EXPLICIT");
                break;
              case Texture.PLANAR_MODE:
                defines.setReflectionMode("REFLECTIONMAP_PLANAR");
                break;
              case Texture.PROJECTION_MODE:
                defines.setReflectionMode("REFLECTIONMAP_PROJECTION");
                break;
              case Texture.SKYBOX_MODE:
                defines.setReflectionMode("REFLECTIONMAP_SKYBOX");
                break;
              case Texture.SPHERICAL_MODE:
                defines.setReflectionMode("REFLECTIONMAP_SPHERICAL");
                break;
              case Texture.EQUIRECTANGULAR_MODE:
                defines.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR");
                break;
              case Texture.FIXED_EQUIRECTANGULAR_MODE:
                defines.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");
                break;
              case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
                defines.setReflectionMode("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");
                break;
              case Texture.CUBIC_MODE:
              case Texture.INVCUBIC_MODE:
              default:
                defines.setReflectionMode("REFLECTIONMAP_CUBIC");
                break;
            }
            defines.USE_LOCAL_REFLECTIONMAP_CUBIC = this._reflectionTexture.boundingBoxSize ? true : false;
          }
        } else {
          defines.REFLECTION = false;
          defines.REFLECTIONMAP_OPPOSITEZ = false;
        }
        if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {
          if (!this._emissiveTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
          }
        } else {
          defines.EMISSIVE = false;
        }
        if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {
          if (!this._lightmapTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
            defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
            defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
          }
        } else {
          defines.LIGHTMAP = false;
        }
        if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {
          if (!this._specularTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._specularTexture, defines, "SPECULAR");
            defines.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;
          }
        } else {
          defines.SPECULAR = false;
        }
        if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && StandardMaterial.BumpTextureEnabled) {
          if (!this._bumpTexture.isReady()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
            defines.PARALLAX = this._useParallax;
            defines.PARALLAXOCCLUSION = this._useParallaxOcclusion;
          }
          defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
        } else {
          defines.BUMP = false;
          defines.PARALLAX = false;
          defines.PARALLAXOCCLUSION = false;
        }
        if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {
          if (!this._refractionTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            defines._needUVs = true;
            defines.REFRACTION = true;
            defines.REFRACTIONMAP_3D = this._refractionTexture.isCube;
            defines.RGBDREFRACTION = this._refractionTexture.isRGBD;
            defines.USE_LOCAL_REFRACTIONMAP_CUBIC = this._refractionTexture.boundingBoxSize ? true : false;
          }
        } else {
          defines.REFRACTION = false;
        }
        defines.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;
      } else {
        defines.DIFFUSE = false;
        defines.AMBIENT = false;
        defines.OPACITY = false;
        defines.REFLECTION = false;
        defines.EMISSIVE = false;
        defines.LIGHTMAP = false;
        defines.BUMP = false;
        defines.REFRACTION = false;
      }
      defines.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture();
      defines.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination;
      defines.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse;
      defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
      defines.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null;
      defines.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(mesh);
    }
    this._eventInfo.isReadyForSubMesh = true;
    this._eventInfo.defines = defines;
    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
    if (!this._eventInfo.isReadyForSubMesh) {
      return false;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady()) {
        return false;
      }
      this._imageProcessingConfiguration.prepareDefines(defines);
      defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;
      defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;
    }
    if (defines._areFresnelDirty) {
      if (StandardMaterial.FresnelEnabled) {
        if (this._diffuseFresnelParameters || this._opacityFresnelParameters || this._emissiveFresnelParameters || this._refractionFresnelParameters || this._reflectionFresnelParameters) {
          defines.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled;
          defines.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
          defines.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled;
          defines.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular;
          defines.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled;
          defines.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled;
          defines._needNormals = true;
          defines.FRESNEL = true;
        }
      } else {
        defines.FRESNEL = false;
      }
    }
    MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines);
    MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
    this._eventInfo.defines = defines;
    this._eventInfo.mesh = mesh;
    this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);
    MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true);
    this._callbackPluginEventPrepareDefines(this._eventInfo);
    if (defines.isDirty) {
      const lightDisposed = defines._areLightsDisposed;
      defines.markAsProcessed();
      const fallbacks = new EffectFallbacks();
      if (defines.REFLECTION) {
        fallbacks.addFallback(0, "REFLECTION");
      }
      if (defines.SPECULAR) {
        fallbacks.addFallback(0, "SPECULAR");
      }
      if (defines.BUMP) {
        fallbacks.addFallback(0, "BUMP");
      }
      if (defines.PARALLAX) {
        fallbacks.addFallback(1, "PARALLAX");
      }
      if (defines.PARALLAXOCCLUSION) {
        fallbacks.addFallback(0, "PARALLAXOCCLUSION");
      }
      if (defines.SPECULAROVERALPHA) {
        fallbacks.addFallback(0, "SPECULAROVERALPHA");
      }
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      if (defines.POINTSIZE) {
        fallbacks.addFallback(0, "POINTSIZE");
      }
      if (defines.LOGARITHMICDEPTH) {
        fallbacks.addFallback(0, "LOGARITHMICDEPTH");
      }
      MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);
      if (defines.SPECULARTERM) {
        fallbacks.addFallback(0, "SPECULARTERM");
      }
      if (defines.DIFFUSEFRESNEL) {
        fallbacks.addFallback(1, "DIFFUSEFRESNEL");
      }
      if (defines.OPACITYFRESNEL) {
        fallbacks.addFallback(2, "OPACITYFRESNEL");
      }
      if (defines.REFLECTIONFRESNEL) {
        fallbacks.addFallback(3, "REFLECTIONFRESNEL");
      }
      if (defines.EMISSIVEFRESNEL) {
        fallbacks.addFallback(4, "EMISSIVEFRESNEL");
      }
      if (defines.FRESNEL) {
        fallbacks.addFallback(4, "FRESNEL");
      }
      if (defines.MULTIVIEW) {
        fallbacks.addFallback(0, "MULTIVIEW");
      }
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      for (let i = 1; i <= 6; ++i) {
        if (defines["UV" + i]) {
          attribs.push(`uv${i === 1 ? "" : i}`);
        }
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      MaterialHelper.PrepareAttributesForInstances(attribs, defines);
      MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);
      MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
      let shaderName = "default";
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vAmbientColor",
        "vDiffuseColor",
        "vSpecularColor",
        "vEmissiveColor",
        "visibility",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vDiffuseInfos",
        "vAmbientInfos",
        "vOpacityInfos",
        "vReflectionInfos",
        "vEmissiveInfos",
        "vSpecularInfos",
        "vBumpInfos",
        "vLightmapInfos",
        "vRefractionInfos",
        "mBones",
        "diffuseMatrix",
        "ambientMatrix",
        "opacityMatrix",
        "reflectionMatrix",
        "emissiveMatrix",
        "specularMatrix",
        "bumpMatrix",
        "normalMatrix",
        "lightmapMatrix",
        "refractionMatrix",
        "diffuseLeftColor",
        "diffuseRightColor",
        "opacityParts",
        "reflectionLeftColor",
        "reflectionRightColor",
        "emissiveLeftColor",
        "emissiveRightColor",
        "refractionLeftColor",
        "refractionRightColor",
        "vReflectionPosition",
        "vReflectionSize",
        "vRefractionPosition",
        "vRefractionSize",
        "logarithmicDepthConstant",
        "vTangentSpaceParams",
        "alphaCutOff",
        "boneTextureWidth",
        "morphTargetTextureInfo",
        "morphTargetTextureIndices"
      ];
      const samplers = [
        "diffuseSampler",
        "ambientSampler",
        "opacitySampler",
        "reflectionCubeSampler",
        "reflection2DSampler",
        "emissiveSampler",
        "specularSampler",
        "bumpSampler",
        "lightmapSampler",
        "refractionCubeSampler",
        "refraction2DSampler",
        "boneSampler",
        "morphTargets",
        "oitDepthSampler",
        "oitFrontColorSampler"
      ];
      const uniformBuffers = ["Material", "Scene", "Mesh"];
      this._eventInfo.fallbacks = fallbacks;
      this._eventInfo.fallbackRank = 0;
      this._eventInfo.defines = defines;
      this._eventInfo.uniforms = uniforms;
      this._eventInfo.attributes = attribs;
      this._eventInfo.samplers = samplers;
      this._eventInfo.uniformBuffersNames = uniformBuffers;
      this._eventInfo.customCode = void 0;
      this._eventInfo.mesh = mesh;
      this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);
      PrePassConfiguration.AddUniforms(uniforms);
      PrePassConfiguration.AddSamplers(samplers);
      if (ImageProcessingConfiguration) {
        ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
        ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
      }
      MaterialHelper.PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: this._maxSimultaneousLights
      });
      addClipPlaneUniforms(uniforms);
      const csnrOptions = {};
      if (this.customShaderNameResolve) {
        shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
      }
      const join = defines.toString();
      const previousEffect = subMesh.effect;
      let effect = scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },
        processFinalCode: csnrOptions.processFinalCode,
        processCodeAfterIncludes: this._eventInfo.customCode,
        multiTarget: defines.PREPASS
      }, engine);
      if (effect) {
        if (this._onEffectCreatedObservable) {
          onCreatedEffectParameters.effect = effect;
          onCreatedEffectParameters.subMesh = subMesh;
          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
        }
        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
          effect = previousEffect;
          defines.markAsUnprocessed();
          if (lightDisposed) {
            defines._areLightsDisposed = true;
            return false;
          }
        } else {
          scene.resetCachedMaterial();
          subMesh.setEffect(effect, defines, this._materialContext);
        }
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    subMesh.effect._wasPreviouslyReady = true;
    subMesh.effect._wasPreviouslyUsingInstances = useInstances;
    if (scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {
      this.checkReadyOnlyOnce = true;
    }
    return true;
  }
  buildUniformLayout() {
    const ubo = this._uniformBuffer;
    ubo.addUniform("diffuseLeftColor", 4);
    ubo.addUniform("diffuseRightColor", 4);
    ubo.addUniform("opacityParts", 4);
    ubo.addUniform("reflectionLeftColor", 4);
    ubo.addUniform("reflectionRightColor", 4);
    ubo.addUniform("refractionLeftColor", 4);
    ubo.addUniform("refractionRightColor", 4);
    ubo.addUniform("emissiveLeftColor", 4);
    ubo.addUniform("emissiveRightColor", 4);
    ubo.addUniform("vDiffuseInfos", 2);
    ubo.addUniform("vAmbientInfos", 2);
    ubo.addUniform("vOpacityInfos", 2);
    ubo.addUniform("vReflectionInfos", 2);
    ubo.addUniform("vReflectionPosition", 3);
    ubo.addUniform("vReflectionSize", 3);
    ubo.addUniform("vEmissiveInfos", 2);
    ubo.addUniform("vLightmapInfos", 2);
    ubo.addUniform("vSpecularInfos", 2);
    ubo.addUniform("vBumpInfos", 3);
    ubo.addUniform("diffuseMatrix", 16);
    ubo.addUniform("ambientMatrix", 16);
    ubo.addUniform("opacityMatrix", 16);
    ubo.addUniform("reflectionMatrix", 16);
    ubo.addUniform("emissiveMatrix", 16);
    ubo.addUniform("lightmapMatrix", 16);
    ubo.addUniform("specularMatrix", 16);
    ubo.addUniform("bumpMatrix", 16);
    ubo.addUniform("vTangentSpaceParams", 2);
    ubo.addUniform("pointSize", 1);
    ubo.addUniform("alphaCutOff", 1);
    ubo.addUniform("refractionMatrix", 16);
    ubo.addUniform("vRefractionInfos", 4);
    ubo.addUniform("vRefractionPosition", 3);
    ubo.addUniform("vRefractionSize", 3);
    ubo.addUniform("vSpecularColor", 4);
    ubo.addUniform("vEmissiveColor", 3);
    ubo.addUniform("vDiffuseColor", 4);
    ubo.addUniform("vAmbientColor", 3);
    super.buildUniformLayout();
  }
  bindForSubMesh(world, mesh, subMesh) {
    var _a;
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
    mesh.transferToEffect(world);
    this._uniformBuffer.bindToEffect(effect, "Material");
    this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
    if (defines.OBJECTSPACE_NORMALMAP) {
      world.toNormalMatrix(this._normalMatrix);
      this.bindOnlyNormalMatrix(this._normalMatrix);
    }
    const mustRebind = this._mustRebind(scene, effect, mesh.visibility);
    MaterialHelper.BindBonesParameters(mesh, effect);
    const ubo = this._uniformBuffer;
    if (mustRebind) {
      this.bindViewProjection(effect);
      if (!ubo.useUbo || !this.isFrozen || !ubo.isSync) {
        if (StandardMaterial.FresnelEnabled && defines.FRESNEL) {
          if (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled) {
            ubo.updateColor4("diffuseLeftColor", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power);
            ubo.updateColor4("diffuseRightColor", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias);
          }
          if (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled) {
            ubo.updateColor4("opacityParts", new Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power);
          }
          if (this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) {
            ubo.updateColor4("reflectionLeftColor", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power);
            ubo.updateColor4("reflectionRightColor", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias);
          }
          if (this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled) {
            ubo.updateColor4("refractionLeftColor", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power);
            ubo.updateColor4("refractionRightColor", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias);
          }
          if (this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) {
            ubo.updateColor4("emissiveLeftColor", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power);
            ubo.updateColor4("emissiveRightColor", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias);
          }
        }
        if (scene.texturesEnabled) {
          if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {
            ubo.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);
            MaterialHelper.BindTextureMatrix(this._diffuseTexture, ubo, "diffuse");
          }
          if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {
            ubo.updateFloat2("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level);
            MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, "ambient");
          }
          if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {
            ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
            MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, "opacity");
          }
          if (this._hasAlphaChannel()) {
            ubo.updateFloat("alphaCutOff", this.alphaCutOff);
          }
          if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {
            ubo.updateFloat2("vReflectionInfos", this._reflectionTexture.level, this.roughness);
            ubo.updateMatrix("reflectionMatrix", this._reflectionTexture.getReflectionTextureMatrix());
            if (this._reflectionTexture.boundingBoxSize) {
              const cubeTexture = this._reflectionTexture;
              ubo.updateVector3("vReflectionPosition", cubeTexture.boundingBoxPosition);
              ubo.updateVector3("vReflectionSize", cubeTexture.boundingBoxSize);
            }
          }
          if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {
            ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
            MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
          }
          if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {
            ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
            MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
          }
          if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {
            ubo.updateFloat2("vSpecularInfos", this._specularTexture.coordinatesIndex, this._specularTexture.level);
            MaterialHelper.BindTextureMatrix(this._specularTexture, ubo, "specular");
          }
          if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {
            ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, 1 / this._bumpTexture.level, this.parallaxScaleBias);
            MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, "bump");
            if (scene._mirroredCameraPosition) {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
            } else {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
            }
          }
          if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {
            let depth = 1;
            if (!this._refractionTexture.isCube) {
              ubo.updateMatrix("refractionMatrix", this._refractionTexture.getReflectionTextureMatrix());
              if (this._refractionTexture.depth) {
                depth = this._refractionTexture.depth;
              }
            }
            ubo.updateFloat4("vRefractionInfos", this._refractionTexture.level, this.indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);
            if (this._refractionTexture.boundingBoxSize) {
              const cubeTexture = this._refractionTexture;
              ubo.updateVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
              ubo.updateVector3("vRefractionSize", cubeTexture.boundingBoxSize);
            }
          }
        }
        if (this.pointsCloud) {
          ubo.updateFloat("pointSize", this.pointSize);
        }
        if (defines.SPECULARTERM) {
          ubo.updateColor4("vSpecularColor", this.specularColor, this.specularPower);
        }
        ubo.updateColor3("vEmissiveColor", StandardMaterial.EmissiveTextureEnabled ? this.emissiveColor : Color3.BlackReadOnly);
        ubo.updateColor4("vDiffuseColor", this.diffuseColor, this.alpha);
        scene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor);
        ubo.updateColor3("vAmbientColor", this._globalAmbientColor);
      }
      if (scene.texturesEnabled) {
        if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {
          effect.setTexture("diffuseSampler", this._diffuseTexture);
        }
        if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {
          effect.setTexture("ambientSampler", this._ambientTexture);
        }
        if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {
          effect.setTexture("opacitySampler", this._opacityTexture);
        }
        if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {
          if (this._reflectionTexture.isCube) {
            effect.setTexture("reflectionCubeSampler", this._reflectionTexture);
          } else {
            effect.setTexture("reflection2DSampler", this._reflectionTexture);
          }
        }
        if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {
          effect.setTexture("emissiveSampler", this._emissiveTexture);
        }
        if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {
          effect.setTexture("lightmapSampler", this._lightmapTexture);
        }
        if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {
          effect.setTexture("specularSampler", this._specularTexture);
        }
        if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {
          effect.setTexture("bumpSampler", this._bumpTexture);
        }
        if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {
          if (this._refractionTexture.isCube) {
            effect.setTexture("refractionCubeSampler", this._refractionTexture);
          } else {
            effect.setTexture("refraction2DSampler", this._refractionTexture);
          }
        }
      }
      if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
        this.getScene().depthPeelingRenderer.bind(effect);
      }
      this._eventInfo.subMesh = subMesh;
      this._callbackPluginEventBindForSubMesh(this._eventInfo);
      bindClipPlane(effect, this, scene);
      this.bindEyePosition(effect);
    } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
      this._needToBindSceneUbo = true;
    }
    if (mustRebind || !this.isFrozen) {
      if (scene.lightsEnabled && !this._disableLighting) {
        MaterialHelper.BindLights(scene, mesh, effect, defines, this._maxSimultaneousLights);
      }
      if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture || mesh.receiveShadows || defines.PREPASS) {
        this.bindView(effect);
      }
      MaterialHelper.BindFogParameters(scene, mesh, effect);
      if (defines.NUM_MORPH_INFLUENCERS) {
        MaterialHelper.BindMorphTargetParameters(mesh, effect);
      }
      if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
        (_a = mesh.bakedVertexAnimationManager) === null || _a === void 0 ? void 0 : _a.bind(effect, defines.INSTANCES);
      }
      if (this.useLogarithmicDepth) {
        MaterialHelper.BindLogDepth(defines, effect, scene);
      }
      if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
        this._imageProcessingConfiguration.bind(this._activeEffect);
      }
    }
    this._afterBind(mesh, this._activeEffect);
    ubo.update();
  }
  getAnimatables() {
    const results = super.getAnimatables();
    if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {
      results.push(this._diffuseTexture);
    }
    if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
      results.push(this._ambientTexture);
    }
    if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
      results.push(this._opacityTexture);
    }
    if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
      results.push(this._reflectionTexture);
    }
    if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
      results.push(this._emissiveTexture);
    }
    if (this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0) {
      results.push(this._specularTexture);
    }
    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
      results.push(this._bumpTexture);
    }
    if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
      results.push(this._lightmapTexture);
    }
    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
      results.push(this._refractionTexture);
    }
    return results;
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._diffuseTexture) {
      activeTextures.push(this._diffuseTexture);
    }
    if (this._ambientTexture) {
      activeTextures.push(this._ambientTexture);
    }
    if (this._opacityTexture) {
      activeTextures.push(this._opacityTexture);
    }
    if (this._reflectionTexture) {
      activeTextures.push(this._reflectionTexture);
    }
    if (this._emissiveTexture) {
      activeTextures.push(this._emissiveTexture);
    }
    if (this._specularTexture) {
      activeTextures.push(this._specularTexture);
    }
    if (this._bumpTexture) {
      activeTextures.push(this._bumpTexture);
    }
    if (this._lightmapTexture) {
      activeTextures.push(this._lightmapTexture);
    }
    if (this._refractionTexture) {
      activeTextures.push(this._refractionTexture);
    }
    return activeTextures;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this._diffuseTexture === texture) {
      return true;
    }
    if (this._ambientTexture === texture) {
      return true;
    }
    if (this._opacityTexture === texture) {
      return true;
    }
    if (this._reflectionTexture === texture) {
      return true;
    }
    if (this._emissiveTexture === texture) {
      return true;
    }
    if (this._specularTexture === texture) {
      return true;
    }
    if (this._bumpTexture === texture) {
      return true;
    }
    if (this._lightmapTexture === texture) {
      return true;
    }
    if (this._refractionTexture === texture) {
      return true;
    }
    return false;
  }
  dispose(forceDisposeEffect, forceDisposeTextures) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (forceDisposeTextures) {
      (_a = this._diffuseTexture) === null || _a === void 0 ? void 0 : _a.dispose();
      (_b = this._ambientTexture) === null || _b === void 0 ? void 0 : _b.dispose();
      (_c = this._opacityTexture) === null || _c === void 0 ? void 0 : _c.dispose();
      (_d = this._reflectionTexture) === null || _d === void 0 ? void 0 : _d.dispose();
      (_e = this._emissiveTexture) === null || _e === void 0 ? void 0 : _e.dispose();
      (_f = this._specularTexture) === null || _f === void 0 ? void 0 : _f.dispose();
      (_g = this._bumpTexture) === null || _g === void 0 ? void 0 : _g.dispose();
      (_h = this._lightmapTexture) === null || _h === void 0 ? void 0 : _h.dispose();
      (_j = this._refractionTexture) === null || _j === void 0 ? void 0 : _j.dispose();
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    super.dispose(forceDisposeEffect, forceDisposeTextures);
  }
  clone(name63) {
    const result = SerializationHelper.Clone(() => new StandardMaterial(name63, this.getScene()), this);
    result.name = name63;
    result.id = name63;
    this.stencil.copyTo(result.stencil);
    return result;
  }
  static Parse(source, scene, rootUrl) {
    const material = SerializationHelper.Parse(() => new StandardMaterial(source.name, scene), source, scene, rootUrl);
    if (source.stencil) {
      material.stencil.parse(source.stencil, scene, rootUrl);
    }
    return material;
  }
  static get DiffuseTextureEnabled() {
    return MaterialFlags.DiffuseTextureEnabled;
  }
  static set DiffuseTextureEnabled(value) {
    MaterialFlags.DiffuseTextureEnabled = value;
  }
  static get DetailTextureEnabled() {
    return MaterialFlags.DetailTextureEnabled;
  }
  static set DetailTextureEnabled(value) {
    MaterialFlags.DetailTextureEnabled = value;
  }
  static get AmbientTextureEnabled() {
    return MaterialFlags.AmbientTextureEnabled;
  }
  static set AmbientTextureEnabled(value) {
    MaterialFlags.AmbientTextureEnabled = value;
  }
  static get OpacityTextureEnabled() {
    return MaterialFlags.OpacityTextureEnabled;
  }
  static set OpacityTextureEnabled(value) {
    MaterialFlags.OpacityTextureEnabled = value;
  }
  static get ReflectionTextureEnabled() {
    return MaterialFlags.ReflectionTextureEnabled;
  }
  static set ReflectionTextureEnabled(value) {
    MaterialFlags.ReflectionTextureEnabled = value;
  }
  static get EmissiveTextureEnabled() {
    return MaterialFlags.EmissiveTextureEnabled;
  }
  static set EmissiveTextureEnabled(value) {
    MaterialFlags.EmissiveTextureEnabled = value;
  }
  static get SpecularTextureEnabled() {
    return MaterialFlags.SpecularTextureEnabled;
  }
  static set SpecularTextureEnabled(value) {
    MaterialFlags.SpecularTextureEnabled = value;
  }
  static get BumpTextureEnabled() {
    return MaterialFlags.BumpTextureEnabled;
  }
  static set BumpTextureEnabled(value) {
    MaterialFlags.BumpTextureEnabled = value;
  }
  static get LightmapTextureEnabled() {
    return MaterialFlags.LightmapTextureEnabled;
  }
  static set LightmapTextureEnabled(value) {
    MaterialFlags.LightmapTextureEnabled = value;
  }
  static get RefractionTextureEnabled() {
    return MaterialFlags.RefractionTextureEnabled;
  }
  static set RefractionTextureEnabled(value) {
    MaterialFlags.RefractionTextureEnabled = value;
  }
  static get ColorGradingTextureEnabled() {
    return MaterialFlags.ColorGradingTextureEnabled;
  }
  static set ColorGradingTextureEnabled(value) {
    MaterialFlags.ColorGradingTextureEnabled = value;
  }
  static get FresnelEnabled() {
    return MaterialFlags.FresnelEnabled;
  }
  static set FresnelEnabled(value) {
    MaterialFlags.FresnelEnabled = value;
  }
};
__decorate([
  serializeAsTexture("diffuseTexture")
], StandardMaterial.prototype, "_diffuseTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], StandardMaterial.prototype, "diffuseTexture", void 0);
__decorate([
  serializeAsTexture("ambientTexture")
], StandardMaterial.prototype, "_ambientTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "ambientTexture", void 0);
__decorate([
  serializeAsTexture("opacityTexture")
], StandardMaterial.prototype, "_opacityTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], StandardMaterial.prototype, "opacityTexture", void 0);
__decorate([
  serializeAsTexture("reflectionTexture")
], StandardMaterial.prototype, "_reflectionTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "reflectionTexture", void 0);
__decorate([
  serializeAsTexture("emissiveTexture")
], StandardMaterial.prototype, "_emissiveTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "emissiveTexture", void 0);
__decorate([
  serializeAsTexture("specularTexture")
], StandardMaterial.prototype, "_specularTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "specularTexture", void 0);
__decorate([
  serializeAsTexture("bumpTexture")
], StandardMaterial.prototype, "_bumpTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "bumpTexture", void 0);
__decorate([
  serializeAsTexture("lightmapTexture")
], StandardMaterial.prototype, "_lightmapTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "lightmapTexture", void 0);
__decorate([
  serializeAsTexture("refractionTexture")
], StandardMaterial.prototype, "_refractionTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "refractionTexture", void 0);
__decorate([
  serializeAsColor3("ambient")
], StandardMaterial.prototype, "ambientColor", void 0);
__decorate([
  serializeAsColor3("diffuse")
], StandardMaterial.prototype, "diffuseColor", void 0);
__decorate([
  serializeAsColor3("specular")
], StandardMaterial.prototype, "specularColor", void 0);
__decorate([
  serializeAsColor3("emissive")
], StandardMaterial.prototype, "emissiveColor", void 0);
__decorate([
  serialize()
], StandardMaterial.prototype, "specularPower", void 0);
__decorate([
  serialize("useAlphaFromDiffuseTexture")
], StandardMaterial.prototype, "_useAlphaFromDiffuseTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], StandardMaterial.prototype, "useAlphaFromDiffuseTexture", void 0);
__decorate([
  serialize("useEmissiveAsIllumination")
], StandardMaterial.prototype, "_useEmissiveAsIllumination", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useEmissiveAsIllumination", void 0);
__decorate([
  serialize("linkEmissiveWithDiffuse")
], StandardMaterial.prototype, "_linkEmissiveWithDiffuse", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "linkEmissiveWithDiffuse", void 0);
__decorate([
  serialize("useSpecularOverAlpha")
], StandardMaterial.prototype, "_useSpecularOverAlpha", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useSpecularOverAlpha", void 0);
__decorate([
  serialize("useReflectionOverAlpha")
], StandardMaterial.prototype, "_useReflectionOverAlpha", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useReflectionOverAlpha", void 0);
__decorate([
  serialize("disableLighting")
], StandardMaterial.prototype, "_disableLighting", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], StandardMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize("useObjectSpaceNormalMap")
], StandardMaterial.prototype, "_useObjectSpaceNormalMap", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useObjectSpaceNormalMap", void 0);
__decorate([
  serialize("useParallax")
], StandardMaterial.prototype, "_useParallax", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useParallax", void 0);
__decorate([
  serialize("useParallaxOcclusion")
], StandardMaterial.prototype, "_useParallaxOcclusion", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useParallaxOcclusion", void 0);
__decorate([
  serialize()
], StandardMaterial.prototype, "parallaxScaleBias", void 0);
__decorate([
  serialize("roughness")
], StandardMaterial.prototype, "_roughness", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "roughness", void 0);
__decorate([
  serialize()
], StandardMaterial.prototype, "indexOfRefraction", void 0);
__decorate([
  serialize()
], StandardMaterial.prototype, "invertRefractionY", void 0);
__decorate([
  serialize()
], StandardMaterial.prototype, "alphaCutOff", void 0);
__decorate([
  serialize("useLightmapAsShadowmap")
], StandardMaterial.prototype, "_useLightmapAsShadowmap", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useLightmapAsShadowmap", void 0);
__decorate([
  serializeAsFresnelParameters("diffuseFresnelParameters")
], StandardMaterial.prototype, "_diffuseFresnelParameters", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsFresnelDirty")
], StandardMaterial.prototype, "diffuseFresnelParameters", void 0);
__decorate([
  serializeAsFresnelParameters("opacityFresnelParameters")
], StandardMaterial.prototype, "_opacityFresnelParameters", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsFresnelAndMiscDirty")
], StandardMaterial.prototype, "opacityFresnelParameters", void 0);
__decorate([
  serializeAsFresnelParameters("reflectionFresnelParameters")
], StandardMaterial.prototype, "_reflectionFresnelParameters", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsFresnelDirty")
], StandardMaterial.prototype, "reflectionFresnelParameters", void 0);
__decorate([
  serializeAsFresnelParameters("refractionFresnelParameters")
], StandardMaterial.prototype, "_refractionFresnelParameters", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsFresnelDirty")
], StandardMaterial.prototype, "refractionFresnelParameters", void 0);
__decorate([
  serializeAsFresnelParameters("emissiveFresnelParameters")
], StandardMaterial.prototype, "_emissiveFresnelParameters", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsFresnelDirty")
], StandardMaterial.prototype, "emissiveFresnelParameters", void 0);
__decorate([
  serialize("useReflectionFresnelFromSpecular")
], StandardMaterial.prototype, "_useReflectionFresnelFromSpecular", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsFresnelDirty")
], StandardMaterial.prototype, "useReflectionFresnelFromSpecular", void 0);
__decorate([
  serialize("useGlossinessFromSpecularMapAlpha")
], StandardMaterial.prototype, "_useGlossinessFromSpecularMapAlpha", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useGlossinessFromSpecularMapAlpha", void 0);
__decorate([
  serialize("maxSimultaneousLights")
], StandardMaterial.prototype, "_maxSimultaneousLights", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], StandardMaterial.prototype, "maxSimultaneousLights", void 0);
__decorate([
  serialize("invertNormalMapX")
], StandardMaterial.prototype, "_invertNormalMapX", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "invertNormalMapX", void 0);
__decorate([
  serialize("invertNormalMapY")
], StandardMaterial.prototype, "_invertNormalMapY", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "invertNormalMapY", void 0);
__decorate([
  serialize("twoSidedLighting")
], StandardMaterial.prototype, "_twoSidedLighting", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "twoSidedLighting", void 0);
__decorate([
  serialize()
], StandardMaterial.prototype, "useLogarithmicDepth", null);
RegisterClass("BABYLON.StandardMaterial", StandardMaterial);
Scene.DefaultMaterialFactory = (scene) => {
  return new StandardMaterial("default material", scene);
};

// node_modules/@babylonjs/core/Materials/shaderMaterial.js
var onCreatedEffectParameters2 = { effect: null, subMesh: null };
var ShaderMaterial = class extends PushMaterial {
  constructor(name63, scene, shaderPath, options = {}, storeEffectOnSubMeshes = true) {
    super(name63, scene, storeEffectOnSubMeshes);
    this._textures = {};
    this._textureArrays = {};
    this._externalTextures = {};
    this._floats = {};
    this._ints = {};
    this._floatsArrays = {};
    this._colors3 = {};
    this._colors3Arrays = {};
    this._colors4 = {};
    this._colors4Arrays = {};
    this._vectors2 = {};
    this._vectors3 = {};
    this._vectors4 = {};
    this._quaternions = {};
    this._quaternionsArrays = {};
    this._matrices = {};
    this._matrixArrays = {};
    this._matrices3x3 = {};
    this._matrices2x2 = {};
    this._vectors2Arrays = {};
    this._vectors3Arrays = {};
    this._vectors4Arrays = {};
    this._uniformBuffers = {};
    this._textureSamplers = {};
    this._storageBuffers = {};
    this._cachedWorldViewMatrix = new Matrix();
    this._cachedWorldViewProjectionMatrix = new Matrix();
    this._multiview = false;
    this._shaderPath = shaderPath;
    this._options = {
      needAlphaBlending: false,
      needAlphaTesting: false,
      attributes: ["position", "normal", "uv"],
      uniforms: ["worldViewProjection"],
      uniformBuffers: [],
      samplers: [],
      externalTextures: [],
      samplerObjects: [],
      storageBuffers: [],
      defines: [],
      useClipPlane: false,
      ...options
    };
  }
  get shaderPath() {
    return this._shaderPath;
  }
  set shaderPath(shaderPath) {
    this._shaderPath = shaderPath;
  }
  get options() {
    return this._options;
  }
  getClassName() {
    return "ShaderMaterial";
  }
  needAlphaBlending() {
    return this.alpha < 1 || this._options.needAlphaBlending;
  }
  needAlphaTesting() {
    return this._options.needAlphaTesting;
  }
  _checkUniform(uniformName) {
    if (this._options.uniforms.indexOf(uniformName) === -1) {
      this._options.uniforms.push(uniformName);
    }
  }
  setTexture(name63, texture) {
    if (this._options.samplers.indexOf(name63) === -1) {
      this._options.samplers.push(name63);
    }
    this._textures[name63] = texture;
    return this;
  }
  setTextureArray(name63, textures) {
    if (this._options.samplers.indexOf(name63) === -1) {
      this._options.samplers.push(name63);
    }
    this._checkUniform(name63);
    this._textureArrays[name63] = textures;
    return this;
  }
  setExternalTexture(name63, texture) {
    if (this._options.externalTextures.indexOf(name63) === -1) {
      this._options.externalTextures.push(name63);
    }
    this._externalTextures[name63] = texture;
    return this;
  }
  setFloat(name63, value) {
    this._checkUniform(name63);
    this._floats[name63] = value;
    return this;
  }
  setInt(name63, value) {
    this._checkUniform(name63);
    this._ints[name63] = value;
    return this;
  }
  setFloats(name63, value) {
    this._checkUniform(name63);
    this._floatsArrays[name63] = value;
    return this;
  }
  setColor3(name63, value) {
    this._checkUniform(name63);
    this._colors3[name63] = value;
    return this;
  }
  setColor3Array(name63, value) {
    this._checkUniform(name63);
    this._colors3Arrays[name63] = value.reduce((arr, color) => {
      color.toArray(arr, arr.length);
      return arr;
    }, []);
    return this;
  }
  setColor4(name63, value) {
    this._checkUniform(name63);
    this._colors4[name63] = value;
    return this;
  }
  setColor4Array(name63, value) {
    this._checkUniform(name63);
    this._colors4Arrays[name63] = value.reduce((arr, color) => {
      color.toArray(arr, arr.length);
      return arr;
    }, []);
    return this;
  }
  setVector2(name63, value) {
    this._checkUniform(name63);
    this._vectors2[name63] = value;
    return this;
  }
  setVector3(name63, value) {
    this._checkUniform(name63);
    this._vectors3[name63] = value;
    return this;
  }
  setVector4(name63, value) {
    this._checkUniform(name63);
    this._vectors4[name63] = value;
    return this;
  }
  setQuaternion(name63, value) {
    this._checkUniform(name63);
    this._quaternions[name63] = value;
    return this;
  }
  setQuaternionArray(name63, value) {
    this._checkUniform(name63);
    this._quaternionsArrays[name63] = value.reduce((arr, quaternion) => {
      quaternion.toArray(arr, arr.length);
      return arr;
    }, []);
    return this;
  }
  setMatrix(name63, value) {
    this._checkUniform(name63);
    this._matrices[name63] = value;
    return this;
  }
  setMatrices(name63, value) {
    this._checkUniform(name63);
    const float32Array = new Float32Array(value.length * 16);
    for (let index = 0; index < value.length; index++) {
      const matrix = value[index];
      matrix.copyToArray(float32Array, index * 16);
    }
    this._matrixArrays[name63] = float32Array;
    return this;
  }
  setMatrix3x3(name63, value) {
    this._checkUniform(name63);
    this._matrices3x3[name63] = value;
    return this;
  }
  setMatrix2x2(name63, value) {
    this._checkUniform(name63);
    this._matrices2x2[name63] = value;
    return this;
  }
  setArray2(name63, value) {
    this._checkUniform(name63);
    this._vectors2Arrays[name63] = value;
    return this;
  }
  setArray3(name63, value) {
    this._checkUniform(name63);
    this._vectors3Arrays[name63] = value;
    return this;
  }
  setArray4(name63, value) {
    this._checkUniform(name63);
    this._vectors4Arrays[name63] = value;
    return this;
  }
  setUniformBuffer(name63, buffer) {
    if (this._options.uniformBuffers.indexOf(name63) === -1) {
      this._options.uniformBuffers.push(name63);
    }
    this._uniformBuffers[name63] = buffer;
    return this;
  }
  setTextureSampler(name63, sampler) {
    if (this._options.samplerObjects.indexOf(name63) === -1) {
      this._options.samplerObjects.push(name63);
    }
    this._textureSamplers[name63] = sampler;
    return this;
  }
  setStorageBuffer(name63, buffer) {
    if (this._options.storageBuffers.indexOf(name63) === -1) {
      this._options.storageBuffers.push(name63);
    }
    this._storageBuffers[name63] = buffer;
    return this;
  }
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    return this.isReady(mesh, useInstances, subMesh);
  }
  isReady(mesh, useInstances, subMesh) {
    var _a, _b, _c, _d;
    const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;
    if (this.isFrozen) {
      if (storeEffectOnSubMeshes) {
        if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {
          return true;
        }
      } else {
        const effect2 = this._drawWrapper.effect;
        if (effect2 && effect2._wasPreviouslyReady && effect2._wasPreviouslyUsingInstances === useInstances) {
          return true;
        }
      }
    }
    const scene = this.getScene();
    const engine = scene.getEngine();
    const defines = [];
    const attribs = [];
    const fallbacks = new EffectFallbacks();
    let shaderName = this._shaderPath, uniforms = this._options.uniforms, uniformBuffers = this._options.uniformBuffers, samplers = this._options.samplers;
    if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {
      this._multiview = true;
      defines.push("#define MULTIVIEW");
      if (this._options.uniforms.indexOf("viewProjection") !== -1 && this._options.uniforms.indexOf("viewProjectionR") === -1) {
        this._options.uniforms.push("viewProjectionR");
      }
    }
    for (let index = 0; index < this._options.defines.length; index++) {
      const defineToAdd = this._options.defines[index].indexOf("#define") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;
      defines.push(defineToAdd);
    }
    for (let index = 0; index < this._options.attributes.length; index++) {
      attribs.push(this._options.attributes[index]);
    }
    if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {
      attribs.push(VertexBuffer.ColorKind);
      defines.push("#define VERTEXCOLOR");
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      MaterialHelper.PushAttributesForInstances(attribs);
      if (mesh === null || mesh === void 0 ? void 0 : mesh.hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {
          attribs.push(VertexBuffer.ColorInstanceKind);
          defines.push("#define INSTANCESCOLOR");
        }
      }
    }
    if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      const skeleton = mesh.skeleton;
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      fallbacks.addCPUSkinningFallback(0, mesh);
      if (skeleton.isUsingTextureForMatrices) {
        defines.push("#define BONETEXTURE");
        if (this._options.uniforms.indexOf("boneTextureWidth") === -1) {
          this._options.uniforms.push("boneTextureWidth");
        }
        if (this._options.samplers.indexOf("boneSampler") === -1) {
          this._options.samplers.push("boneSampler");
        }
      } else {
        defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
        if (this._options.uniforms.indexOf("mBones") === -1) {
          this._options.uniforms.push("mBones");
        }
      }
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    let numInfluencers = 0;
    const manager = mesh ? mesh.morphTargetManager : null;
    if (manager) {
      const uv = manager.supportsUVs && defines.indexOf("#define UV1") !== -1;
      const tangent = manager.supportsTangents && defines.indexOf("#define TANGENT") !== -1;
      const normal = manager.supportsNormals && defines.indexOf("#define NORMAL") !== -1;
      numInfluencers = manager.numInfluencers;
      if (uv) {
        defines.push("#define MORPHTARGETS_UV");
      }
      if (tangent) {
        defines.push("#define MORPHTARGETS_TANGENT");
      }
      if (normal) {
        defines.push("#define MORPHTARGETS_NORMAL");
      }
      if (numInfluencers > 0) {
        defines.push("#define MORPHTARGETS");
      }
      if (manager.isUsingTextureForTargets) {
        defines.push("#define MORPHTARGETS_TEXTURE");
        if (this._options.uniforms.indexOf("morphTargetTextureIndices") === -1) {
          this._options.uniforms.push("morphTargetTextureIndices");
        }
        if (this._options.samplers.indexOf("morphTargets") === -1) {
          this._options.samplers.push("morphTargets");
        }
      }
      defines.push("#define NUM_MORPH_INFLUENCERS " + numInfluencers);
      for (let index = 0; index < numInfluencers; index++) {
        attribs.push(VertexBuffer.PositionKind + index);
        if (normal) {
          attribs.push(VertexBuffer.NormalKind + index);
        }
        if (tangent) {
          attribs.push(VertexBuffer.TangentKind + index);
        }
        if (uv) {
          attribs.push(VertexBuffer.UVKind + "_" + index);
        }
      }
      if (numInfluencers > 0) {
        uniforms = uniforms.slice();
        uniforms.push("morphTargetInfluences");
        uniforms.push("morphTargetTextureInfo");
        uniforms.push("morphTargetTextureIndices");
      }
    } else {
      defines.push("#define NUM_MORPH_INFLUENCERS 0");
    }
    if (mesh) {
      const bvaManager = mesh.bakedVertexAnimationManager;
      if (bvaManager && bvaManager.isEnabled) {
        defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
        if (this._options.uniforms.indexOf("bakedVertexAnimationSettings") === -1) {
          this._options.uniforms.push("bakedVertexAnimationSettings");
        }
        if (this._options.uniforms.indexOf("bakedVertexAnimationTextureSizeInverted") === -1) {
          this._options.uniforms.push("bakedVertexAnimationTextureSizeInverted");
        }
        if (this._options.uniforms.indexOf("bakedVertexAnimationTime") === -1) {
          this._options.uniforms.push("bakedVertexAnimationTime");
        }
        if (this._options.samplers.indexOf("bakedVertexAnimationTexture") === -1) {
          this._options.samplers.push("bakedVertexAnimationTexture");
        }
      }
      MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
    }
    for (const name63 in this._textures) {
      if (!this._textures[name63].isReady()) {
        return false;
      }
    }
    if (mesh && this._shouldTurnAlphaTestOn(mesh)) {
      defines.push("#define ALPHATEST");
    }
    if (this._options.useClipPlane !== false) {
      addClipPlaneUniforms(uniforms);
      prepareDefinesForClipPlanes(this, scene, defines);
    }
    if (this.customShaderNameResolve) {
      uniforms = uniforms.slice();
      uniformBuffers = uniformBuffers.slice();
      samplers = samplers.slice();
      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);
    }
    const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper() : this._drawWrapper;
    const previousEffect = (_a = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.effect) !== null && _a !== void 0 ? _a : null;
    const previousDefines = (_b = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.defines) !== null && _b !== void 0 ? _b : null;
    const join = defines.join("\n");
    let effect = previousEffect;
    if (previousDefines !== join) {
      effect = engine.createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousMorphTargets: numInfluencers },
        shaderLanguage: this._options.shaderLanguage
      }, engine);
      if (storeEffectOnSubMeshes) {
        subMesh.setEffect(effect, join, this._materialContext);
      } else if (drawWrapper) {
        drawWrapper.setEffect(effect, join);
      }
      if (this._onEffectCreatedObservable) {
        onCreatedEffectParameters2.effect = effect;
        onCreatedEffectParameters2.subMesh = (_c = subMesh !== null && subMesh !== void 0 ? subMesh : mesh === null || mesh === void 0 ? void 0 : mesh.subMeshes[0]) !== null && _c !== void 0 ? _c : null;
        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters2);
      }
    }
    effect._wasPreviouslyUsingInstances = !!useInstances;
    if ((_d = !(effect === null || effect === void 0 ? void 0 : effect.isReady())) !== null && _d !== void 0 ? _d : true) {
      return false;
    }
    if (previousEffect !== effect) {
      scene.resetCachedMaterial();
    }
    effect._wasPreviouslyReady = true;
    return true;
  }
  bindOnlyWorldMatrix(world, effectOverride) {
    const scene = this.getScene();
    const effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : this.getEffect();
    if (!effect) {
      return;
    }
    if (this._options.uniforms.indexOf("world") !== -1) {
      effect.setMatrix("world", world);
    }
    if (this._options.uniforms.indexOf("worldView") !== -1) {
      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);
      effect.setMatrix("worldView", this._cachedWorldViewMatrix);
    }
    if (this._options.uniforms.indexOf("worldViewProjection") !== -1) {
      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);
      effect.setMatrix("worldViewProjection", this._cachedWorldViewProjectionMatrix);
    }
  }
  bindForSubMesh(world, mesh, subMesh) {
    var _a;
    this.bind(world, mesh, (_a = subMesh._drawWrapperOverride) === null || _a === void 0 ? void 0 : _a.effect, subMesh);
  }
  bind(world, mesh, effectOverride, subMesh) {
    var _a;
    const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;
    const effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : storeEffectOnSubMeshes ? subMesh.effect : this.getEffect();
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world, effectOverride);
    const uniformBuffers = this._options.uniformBuffers;
    let useSceneUBO = false;
    if (effect && uniformBuffers && uniformBuffers.length > 0 && this.getScene().getEngine().supportsUniformBuffers) {
      for (let i = 0; i < uniformBuffers.length; ++i) {
        const bufferName = uniformBuffers[i];
        switch (bufferName) {
          case "Mesh":
            if (mesh) {
              mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
              mesh.transferToEffect(world);
            }
            break;
          case "Scene":
            MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());
            this.getScene().finalizeSceneUbo();
            useSceneUBO = true;
            break;
        }
      }
    }
    const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(this.getScene(), effect, mesh.visibility) : this.getScene().getCachedMaterial() !== this;
    if (effect && mustRebind) {
      if (!useSceneUBO && this._options.uniforms.indexOf("view") !== -1) {
        effect.setMatrix("view", this.getScene().getViewMatrix());
      }
      if (!useSceneUBO && this._options.uniforms.indexOf("projection") !== -1) {
        effect.setMatrix("projection", this.getScene().getProjectionMatrix());
      }
      if (!useSceneUBO && this._options.uniforms.indexOf("viewProjection") !== -1) {
        effect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
        if (this._multiview) {
          effect.setMatrix("viewProjectionR", this.getScene()._transformMatrixR);
        }
      }
      if (this.getScene().activeCamera && this._options.uniforms.indexOf("cameraPosition") !== -1) {
        effect.setVector3("cameraPosition", this.getScene().activeCamera.globalPosition);
      }
      MaterialHelper.BindBonesParameters(mesh, effect);
      bindClipPlane(effect, this, this.getScene());
      let name63;
      for (name63 in this._textures) {
        effect.setTexture(name63, this._textures[name63]);
      }
      for (name63 in this._textureArrays) {
        effect.setTextureArray(name63, this._textureArrays[name63]);
      }
      for (name63 in this._externalTextures) {
        effect.setExternalTexture(name63, this._externalTextures[name63]);
      }
      for (name63 in this._ints) {
        effect.setInt(name63, this._ints[name63]);
      }
      for (name63 in this._floats) {
        effect.setFloat(name63, this._floats[name63]);
      }
      for (name63 in this._floatsArrays) {
        effect.setArray(name63, this._floatsArrays[name63]);
      }
      for (name63 in this._colors3) {
        effect.setColor3(name63, this._colors3[name63]);
      }
      for (name63 in this._colors3Arrays) {
        effect.setArray3(name63, this._colors3Arrays[name63]);
      }
      for (name63 in this._colors4) {
        const color = this._colors4[name63];
        effect.setFloat4(name63, color.r, color.g, color.b, color.a);
      }
      for (name63 in this._colors4Arrays) {
        effect.setArray4(name63, this._colors4Arrays[name63]);
      }
      for (name63 in this._vectors2) {
        effect.setVector2(name63, this._vectors2[name63]);
      }
      for (name63 in this._vectors3) {
        effect.setVector3(name63, this._vectors3[name63]);
      }
      for (name63 in this._vectors4) {
        effect.setVector4(name63, this._vectors4[name63]);
      }
      for (name63 in this._quaternions) {
        effect.setQuaternion(name63, this._quaternions[name63]);
      }
      for (name63 in this._matrices) {
        effect.setMatrix(name63, this._matrices[name63]);
      }
      for (name63 in this._matrixArrays) {
        effect.setMatrices(name63, this._matrixArrays[name63]);
      }
      for (name63 in this._matrices3x3) {
        effect.setMatrix3x3(name63, this._matrices3x3[name63]);
      }
      for (name63 in this._matrices2x2) {
        effect.setMatrix2x2(name63, this._matrices2x2[name63]);
      }
      for (name63 in this._vectors2Arrays) {
        effect.setArray2(name63, this._vectors2Arrays[name63]);
      }
      for (name63 in this._vectors3Arrays) {
        effect.setArray3(name63, this._vectors3Arrays[name63]);
      }
      for (name63 in this._vectors4Arrays) {
        effect.setArray4(name63, this._vectors4Arrays[name63]);
      }
      for (name63 in this._quaternionsArrays) {
        effect.setArray4(name63, this._quaternionsArrays[name63]);
      }
      for (name63 in this._uniformBuffers) {
        const buffer = this._uniformBuffers[name63].getBuffer();
        if (buffer) {
          effect.bindUniformBuffer(buffer, name63);
        }
      }
      for (name63 in this._textureSamplers) {
        effect.setTextureSampler(name63, this._textureSamplers[name63]);
      }
      for (name63 in this._storageBuffers) {
        effect.setStorageBuffer(name63, this._storageBuffers[name63]);
      }
    }
    if (effect && mesh && (mustRebind || !this.isFrozen)) {
      const manager = mesh.morphTargetManager;
      if (manager && manager.numInfluencers > 0) {
        MaterialHelper.BindMorphTargetParameters(mesh, effect);
      }
      const bvaManager = mesh.bakedVertexAnimationManager;
      if (bvaManager && bvaManager.isEnabled) {
        (_a = mesh.bakedVertexAnimationManager) === null || _a === void 0 ? void 0 : _a.bind(effect, !!effect._wasPreviouslyUsingInstances);
      }
    }
    this._afterBind(mesh, effect);
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    for (const name63 in this._textures) {
      activeTextures.push(this._textures[name63]);
    }
    for (const name63 in this._textureArrays) {
      const array = this._textureArrays[name63];
      for (let index = 0; index < array.length; index++) {
        activeTextures.push(array[index]);
      }
    }
    return activeTextures;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    for (const name63 in this._textures) {
      if (this._textures[name63] === texture) {
        return true;
      }
    }
    for (const name63 in this._textureArrays) {
      const array = this._textureArrays[name63];
      for (let index = 0; index < array.length; index++) {
        if (array[index] === texture) {
          return true;
        }
      }
    }
    return false;
  }
  clone(name63) {
    const result = SerializationHelper.Clone(() => new ShaderMaterial(name63, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);
    result.name = name63;
    result.id = name63;
    if (typeof result._shaderPath === "object") {
      result._shaderPath = { ...result._shaderPath };
    }
    this._options = { ...this._options };
    Object.keys(this._options).forEach((propName) => {
      const propValue = this._options[propName];
      if (Array.isArray(propValue)) {
        this._options[propName] = propValue.slice(0);
      }
    });
    this.stencil.copyTo(result.stencil);
    for (const key in this._textures) {
      result.setTexture(key, this._textures[key]);
    }
    for (const key in this._textureArrays) {
      result.setTextureArray(key, this._textureArrays[key]);
    }
    for (const key in this._externalTextures) {
      result.setExternalTexture(key, this._externalTextures[key]);
    }
    for (const key in this._ints) {
      result.setInt(key, this._ints[key]);
    }
    for (const key in this._floats) {
      result.setFloat(key, this._floats[key]);
    }
    for (const key in this._floatsArrays) {
      result.setFloats(key, this._floatsArrays[key]);
    }
    for (const key in this._colors3) {
      result.setColor3(key, this._colors3[key]);
    }
    for (const key in this._colors3Arrays) {
      result._colors3Arrays[key] = this._colors3Arrays[key];
    }
    for (const key in this._colors4) {
      result.setColor4(key, this._colors4[key]);
    }
    for (const key in this._colors4Arrays) {
      result._colors4Arrays[key] = this._colors4Arrays[key];
    }
    for (const key in this._vectors2) {
      result.setVector2(key, this._vectors2[key]);
    }
    for (const key in this._vectors3) {
      result.setVector3(key, this._vectors3[key]);
    }
    for (const key in this._vectors4) {
      result.setVector4(key, this._vectors4[key]);
    }
    for (const key in this._quaternions) {
      result.setQuaternion(key, this._quaternions[key]);
    }
    for (const key in this._quaternionsArrays) {
      result._quaternionsArrays[key] = this._quaternionsArrays[key];
    }
    for (const key in this._matrices) {
      result.setMatrix(key, this._matrices[key]);
    }
    for (const key in this._matrixArrays) {
      result._matrixArrays[key] = this._matrixArrays[key].slice();
    }
    for (const key in this._matrices3x3) {
      result.setMatrix3x3(key, this._matrices3x3[key]);
    }
    for (const key in this._matrices2x2) {
      result.setMatrix2x2(key, this._matrices2x2[key]);
    }
    for (const key in this._vectors2Arrays) {
      result.setArray2(key, this._vectors2Arrays[key]);
    }
    for (const key in this._vectors3Arrays) {
      result.setArray3(key, this._vectors3Arrays[key]);
    }
    for (const key in this._vectors4Arrays) {
      result.setArray4(key, this._vectors4Arrays[key]);
    }
    for (const key in this._uniformBuffers) {
      result.setUniformBuffer(key, this._uniformBuffers[key]);
    }
    for (const key in this._textureSamplers) {
      result.setTextureSampler(key, this._textureSamplers[key]);
    }
    for (const key in this._storageBuffers) {
      result.setStorageBuffer(key, this._storageBuffers[key]);
    }
    return result;
  }
  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    if (forceDisposeTextures) {
      let name63;
      for (name63 in this._textures) {
        this._textures[name63].dispose();
      }
      for (name63 in this._textureArrays) {
        const array = this._textureArrays[name63];
        for (let index = 0; index < array.length; index++) {
          array[index].dispose();
        }
      }
    }
    this._textures = {};
    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.ShaderMaterial";
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.options = this._options;
    serializationObject.shaderPath = this._shaderPath;
    serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;
    let name63;
    serializationObject.stencil = this.stencil.serialize();
    serializationObject.textures = {};
    for (name63 in this._textures) {
      serializationObject.textures[name63] = this._textures[name63].serialize();
    }
    serializationObject.textureArrays = {};
    for (name63 in this._textureArrays) {
      serializationObject.textureArrays[name63] = [];
      const array = this._textureArrays[name63];
      for (let index = 0; index < array.length; index++) {
        serializationObject.textureArrays[name63].push(array[index].serialize());
      }
    }
    serializationObject.ints = {};
    for (name63 in this._ints) {
      serializationObject.ints[name63] = this._ints[name63];
    }
    serializationObject.floats = {};
    for (name63 in this._floats) {
      serializationObject.floats[name63] = this._floats[name63];
    }
    serializationObject.FloatArrays = {};
    for (name63 in this._floatsArrays) {
      serializationObject.FloatArrays[name63] = this._floatsArrays[name63];
    }
    serializationObject.colors3 = {};
    for (name63 in this._colors3) {
      serializationObject.colors3[name63] = this._colors3[name63].asArray();
    }
    serializationObject.colors3Arrays = {};
    for (name63 in this._colors3Arrays) {
      serializationObject.colors3Arrays[name63] = this._colors3Arrays[name63];
    }
    serializationObject.colors4 = {};
    for (name63 in this._colors4) {
      serializationObject.colors4[name63] = this._colors4[name63].asArray();
    }
    serializationObject.colors4Arrays = {};
    for (name63 in this._colors4Arrays) {
      serializationObject.colors4Arrays[name63] = this._colors4Arrays[name63];
    }
    serializationObject.vectors2 = {};
    for (name63 in this._vectors2) {
      serializationObject.vectors2[name63] = this._vectors2[name63].asArray();
    }
    serializationObject.vectors3 = {};
    for (name63 in this._vectors3) {
      serializationObject.vectors3[name63] = this._vectors3[name63].asArray();
    }
    serializationObject.vectors4 = {};
    for (name63 in this._vectors4) {
      serializationObject.vectors4[name63] = this._vectors4[name63].asArray();
    }
    serializationObject.quaternions = {};
    for (name63 in this._quaternions) {
      serializationObject.quaternions[name63] = this._quaternions[name63].asArray();
    }
    serializationObject.matrices = {};
    for (name63 in this._matrices) {
      serializationObject.matrices[name63] = this._matrices[name63].asArray();
    }
    serializationObject.matrixArray = {};
    for (name63 in this._matrixArrays) {
      serializationObject.matrixArray[name63] = this._matrixArrays[name63];
    }
    serializationObject.matrices3x3 = {};
    for (name63 in this._matrices3x3) {
      serializationObject.matrices3x3[name63] = this._matrices3x3[name63];
    }
    serializationObject.matrices2x2 = {};
    for (name63 in this._matrices2x2) {
      serializationObject.matrices2x2[name63] = this._matrices2x2[name63];
    }
    serializationObject.vectors2Arrays = {};
    for (name63 in this._vectors2Arrays) {
      serializationObject.vectors2Arrays[name63] = this._vectors2Arrays[name63];
    }
    serializationObject.vectors3Arrays = {};
    for (name63 in this._vectors3Arrays) {
      serializationObject.vectors3Arrays[name63] = this._vectors3Arrays[name63];
    }
    serializationObject.vectors4Arrays = {};
    for (name63 in this._vectors4Arrays) {
      serializationObject.vectors4Arrays[name63] = this._vectors4Arrays[name63];
    }
    serializationObject.quaternionsArrays = {};
    for (name63 in this._quaternionsArrays) {
      serializationObject.quaternionsArrays[name63] = this._quaternionsArrays[name63];
    }
    return serializationObject;
  }
  static Parse(source, scene, rootUrl) {
    const material = SerializationHelper.Parse(() => new ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes), source, scene, rootUrl);
    let name63;
    if (source.stencil) {
      material.stencil.parse(source.stencil, scene, rootUrl);
    }
    for (name63 in source.textures) {
      material.setTexture(name63, Texture.Parse(source.textures[name63], scene, rootUrl));
    }
    for (name63 in source.textureArrays) {
      const array = source.textureArrays[name63];
      const textureArray = new Array();
      for (let index = 0; index < array.length; index++) {
        textureArray.push(Texture.Parse(array[index], scene, rootUrl));
      }
      material.setTextureArray(name63, textureArray);
    }
    for (name63 in source.ints) {
      material.setInt(name63, source.ints[name63]);
    }
    for (name63 in source.floats) {
      material.setFloat(name63, source.floats[name63]);
    }
    for (name63 in source.floatsArrays) {
      material.setFloats(name63, source.floatsArrays[name63]);
    }
    for (name63 in source.colors3) {
      material.setColor3(name63, Color3.FromArray(source.colors3[name63]));
    }
    for (name63 in source.colors3Arrays) {
      const colors = source.colors3Arrays[name63].reduce((arr, num, i) => {
        if (i % 3 === 0) {
          arr.push([num]);
        } else {
          arr[arr.length - 1].push(num);
        }
        return arr;
      }, []).map((color) => Color3.FromArray(color));
      material.setColor3Array(name63, colors);
    }
    for (name63 in source.colors4) {
      material.setColor4(name63, Color4.FromArray(source.colors4[name63]));
    }
    for (name63 in source.colors4Arrays) {
      const colors = source.colors4Arrays[name63].reduce((arr, num, i) => {
        if (i % 4 === 0) {
          arr.push([num]);
        } else {
          arr[arr.length - 1].push(num);
        }
        return arr;
      }, []).map((color) => Color4.FromArray(color));
      material.setColor4Array(name63, colors);
    }
    for (name63 in source.vectors2) {
      material.setVector2(name63, Vector2.FromArray(source.vectors2[name63]));
    }
    for (name63 in source.vectors3) {
      material.setVector3(name63, Vector3.FromArray(source.vectors3[name63]));
    }
    for (name63 in source.vectors4) {
      material.setVector4(name63, Vector4.FromArray(source.vectors4[name63]));
    }
    for (name63 in source.quaternions) {
      material.setQuaternion(name63, Quaternion.FromArray(source.quaternions[name63]));
    }
    for (name63 in source.matrices) {
      material.setMatrix(name63, Matrix.FromArray(source.matrices[name63]));
    }
    for (name63 in source.matrixArray) {
      material._matrixArrays[name63] = new Float32Array(source.matrixArray[name63]);
    }
    for (name63 in source.matrices3x3) {
      material.setMatrix3x3(name63, source.matrices3x3[name63]);
    }
    for (name63 in source.matrices2x2) {
      material.setMatrix2x2(name63, source.matrices2x2[name63]);
    }
    for (name63 in source.vectors2Arrays) {
      material.setArray2(name63, source.vectors2Arrays[name63]);
    }
    for (name63 in source.vectors3Arrays) {
      material.setArray3(name63, source.vectors3Arrays[name63]);
    }
    for (name63 in source.vectors4Arrays) {
      material.setArray4(name63, source.vectors4Arrays[name63]);
    }
    for (name63 in source.quaternionsArrays) {
      material.setArray4(name63, source.quaternionsArrays[name63]);
    }
    return material;
  }
  static ParseFromFileAsync(name63, url, scene, rootUrl = "") {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const serializationObject = JSON.parse(request.responseText);
            const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
            if (name63) {
              output.name = name63;
            }
            resolve(output);
          } else {
            reject("Unable to load the ShaderMaterial");
          }
        }
      });
      request.open("GET", url);
      request.send();
    });
  }
  static ParseFromSnippetAsync(snippetId, scene, rootUrl = "") {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            const serializationObject = JSON.parse(snippet.shaderMaterial);
            const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
            output.snippetId = snippetId;
            resolve(output);
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  }
};
ShaderMaterial.SnippetUrl = `https://snippet.babylonjs.com`;
ShaderMaterial.CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;
RegisterClass("BABYLON.ShaderMaterial", ShaderMaterial);

// node_modules/@babylonjs/core/Engines/constants.js
var Constants = class {
};
Constants.ALPHA_DISABLE = 0;
Constants.ALPHA_ADD = 1;
Constants.ALPHA_COMBINE = 2;
Constants.ALPHA_SUBTRACT = 3;
Constants.ALPHA_MULTIPLY = 4;
Constants.ALPHA_MAXIMIZED = 5;
Constants.ALPHA_ONEONE = 6;
Constants.ALPHA_PREMULTIPLIED = 7;
Constants.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;
Constants.ALPHA_INTERPOLATE = 9;
Constants.ALPHA_SCREENMODE = 10;
Constants.ALPHA_ONEONE_ONEONE = 11;
Constants.ALPHA_ALPHATOCOLOR = 12;
Constants.ALPHA_REVERSEONEMINUS = 13;
Constants.ALPHA_SRC_DSTONEMINUSSRCALPHA = 14;
Constants.ALPHA_ONEONE_ONEZERO = 15;
Constants.ALPHA_EXCLUSION = 16;
Constants.ALPHA_LAYER_ACCUMULATE = 17;
Constants.ALPHA_EQUATION_ADD = 0;
Constants.ALPHA_EQUATION_SUBSTRACT = 1;
Constants.ALPHA_EQUATION_REVERSE_SUBTRACT = 2;
Constants.ALPHA_EQUATION_MAX = 3;
Constants.ALPHA_EQUATION_MIN = 4;
Constants.ALPHA_EQUATION_DARKEN = 5;
Constants.DELAYLOADSTATE_NONE = 0;
Constants.DELAYLOADSTATE_LOADED = 1;
Constants.DELAYLOADSTATE_LOADING = 2;
Constants.DELAYLOADSTATE_NOTLOADED = 4;
Constants.NEVER = 512;
Constants.ALWAYS = 519;
Constants.LESS = 513;
Constants.EQUAL = 514;
Constants.LEQUAL = 515;
Constants.GREATER = 516;
Constants.GEQUAL = 518;
Constants.NOTEQUAL = 517;
Constants.KEEP = 7680;
Constants.ZERO = 0;
Constants.REPLACE = 7681;
Constants.INCR = 7682;
Constants.DECR = 7683;
Constants.INVERT = 5386;
Constants.INCR_WRAP = 34055;
Constants.DECR_WRAP = 34056;
Constants.TEXTURE_CLAMP_ADDRESSMODE = 0;
Constants.TEXTURE_WRAP_ADDRESSMODE = 1;
Constants.TEXTURE_MIRROR_ADDRESSMODE = 2;
Constants.TEXTURE_CREATIONFLAG_STORAGE = 1;
Constants.TEXTUREFORMAT_ALPHA = 0;
Constants.TEXTUREFORMAT_LUMINANCE = 1;
Constants.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;
Constants.TEXTUREFORMAT_RGB = 4;
Constants.TEXTUREFORMAT_RGBA = 5;
Constants.TEXTUREFORMAT_RED = 6;
Constants.TEXTUREFORMAT_R = 6;
Constants.TEXTUREFORMAT_RG = 7;
Constants.TEXTUREFORMAT_RED_INTEGER = 8;
Constants.TEXTUREFORMAT_R_INTEGER = 8;
Constants.TEXTUREFORMAT_RG_INTEGER = 9;
Constants.TEXTUREFORMAT_RGB_INTEGER = 10;
Constants.TEXTUREFORMAT_RGBA_INTEGER = 11;
Constants.TEXTUREFORMAT_BGRA = 12;
Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 = 13;
Constants.TEXTUREFORMAT_DEPTH32_FLOAT = 14;
Constants.TEXTUREFORMAT_DEPTH16 = 15;
Constants.TEXTUREFORMAT_DEPTH24 = 16;
Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 = 17;
Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8 = 18;
Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM = 36492;
Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM = 36493;
Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = 36495;
Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT = 36494;
Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5 = 33779;
Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919;
Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3 = 33778;
Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918;
Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1 = 33777;
Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1 = 33776;
Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917;
Constants.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916;
Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4 = 37808;
Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840;
Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL = 36196;
Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2 = 37492;
Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2 = 37493;
Constants.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494;
Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495;
Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC = 37496;
Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497;
Constants.TEXTURETYPE_UNSIGNED_BYTE = 0;
Constants.TEXTURETYPE_UNSIGNED_INT = 0;
Constants.TEXTURETYPE_FLOAT = 1;
Constants.TEXTURETYPE_HALF_FLOAT = 2;
Constants.TEXTURETYPE_BYTE = 3;
Constants.TEXTURETYPE_SHORT = 4;
Constants.TEXTURETYPE_UNSIGNED_SHORT = 5;
Constants.TEXTURETYPE_INT = 6;
Constants.TEXTURETYPE_UNSIGNED_INTEGER = 7;
Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;
Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;
Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;
Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;
Constants.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;
Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;
Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;
Constants.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;
Constants.TEXTURETYPE_UNDEFINED = 16;
Constants.TEXTURE_NEAREST_SAMPLINGMODE = 1;
Constants.TEXTURE_NEAREST_NEAREST = 1;
Constants.TEXTURE_BILINEAR_SAMPLINGMODE = 2;
Constants.TEXTURE_LINEAR_LINEAR = 2;
Constants.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;
Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;
Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;
Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;
Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;
Constants.TEXTURE_NEAREST_LINEAR = 7;
Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;
Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;
Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;
Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;
Constants.TEXTURE_LINEAR_NEAREST = 12;
Constants.TEXTURE_EXPLICIT_MODE = 0;
Constants.TEXTURE_SPHERICAL_MODE = 1;
Constants.TEXTURE_PLANAR_MODE = 2;
Constants.TEXTURE_CUBIC_MODE = 3;
Constants.TEXTURE_PROJECTION_MODE = 4;
Constants.TEXTURE_SKYBOX_MODE = 5;
Constants.TEXTURE_INVCUBIC_MODE = 6;
Constants.TEXTURE_EQUIRECTANGULAR_MODE = 7;
Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;
Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
Constants.TEXTURE_FILTERING_QUALITY_OFFLINE = 4096;
Constants.TEXTURE_FILTERING_QUALITY_HIGH = 64;
Constants.TEXTURE_FILTERING_QUALITY_MEDIUM = 16;
Constants.TEXTURE_FILTERING_QUALITY_LOW = 8;
Constants.SCALEMODE_FLOOR = 1;
Constants.SCALEMODE_NEAREST = 2;
Constants.SCALEMODE_CEILING = 3;
Constants.MATERIAL_TextureDirtyFlag = 1;
Constants.MATERIAL_LightDirtyFlag = 2;
Constants.MATERIAL_FresnelDirtyFlag = 4;
Constants.MATERIAL_AttributesDirtyFlag = 8;
Constants.MATERIAL_MiscDirtyFlag = 16;
Constants.MATERIAL_PrePassDirtyFlag = 32;
Constants.MATERIAL_AllDirtyFlag = 63;
Constants.MATERIAL_TriangleFillMode = 0;
Constants.MATERIAL_WireFrameFillMode = 1;
Constants.MATERIAL_PointFillMode = 2;
Constants.MATERIAL_PointListDrawMode = 3;
Constants.MATERIAL_LineListDrawMode = 4;
Constants.MATERIAL_LineLoopDrawMode = 5;
Constants.MATERIAL_LineStripDrawMode = 6;
Constants.MATERIAL_TriangleStripDrawMode = 7;
Constants.MATERIAL_TriangleFanDrawMode = 8;
Constants.MATERIAL_ClockWiseSideOrientation = 0;
Constants.MATERIAL_CounterClockWiseSideOrientation = 1;
Constants.ACTION_NothingTrigger = 0;
Constants.ACTION_OnPickTrigger = 1;
Constants.ACTION_OnLeftPickTrigger = 2;
Constants.ACTION_OnRightPickTrigger = 3;
Constants.ACTION_OnCenterPickTrigger = 4;
Constants.ACTION_OnPickDownTrigger = 5;
Constants.ACTION_OnDoublePickTrigger = 6;
Constants.ACTION_OnPickUpTrigger = 7;
Constants.ACTION_OnPickOutTrigger = 16;
Constants.ACTION_OnLongPressTrigger = 8;
Constants.ACTION_OnPointerOverTrigger = 9;
Constants.ACTION_OnPointerOutTrigger = 10;
Constants.ACTION_OnEveryFrameTrigger = 11;
Constants.ACTION_OnIntersectionEnterTrigger = 12;
Constants.ACTION_OnIntersectionExitTrigger = 13;
Constants.ACTION_OnKeyDownTrigger = 14;
Constants.ACTION_OnKeyUpTrigger = 15;
Constants.PARTICLES_BILLBOARDMODE_Y = 2;
Constants.PARTICLES_BILLBOARDMODE_ALL = 7;
Constants.PARTICLES_BILLBOARDMODE_STRETCHED = 8;
Constants.PARTICLES_BILLBOARDMODE_STRETCHED_LOCAL = 9;
Constants.MESHES_CULLINGSTRATEGY_STANDARD = 0;
Constants.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
Constants.SCENELOADER_NO_LOGGING = 0;
Constants.SCENELOADER_MINIMAL_LOGGING = 1;
Constants.SCENELOADER_SUMMARY_LOGGING = 2;
Constants.SCENELOADER_DETAILED_LOGGING = 3;
Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE = 0;
Constants.PREPASS_POSITION_TEXTURE_TYPE = 1;
Constants.PREPASS_VELOCITY_TEXTURE_TYPE = 2;
Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE = 3;
Constants.PREPASS_COLOR_TEXTURE_TYPE = 4;
Constants.PREPASS_DEPTH_TEXTURE_TYPE = 5;
Constants.PREPASS_NORMAL_TEXTURE_TYPE = 6;
Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE = 7;
Constants.BUFFER_CREATIONFLAG_READ = 1;
Constants.BUFFER_CREATIONFLAG_WRITE = 2;
Constants.BUFFER_CREATIONFLAG_READWRITE = 3;
Constants.BUFFER_CREATIONFLAG_UNIFORM = 4;
Constants.BUFFER_CREATIONFLAG_VERTEX = 8;
Constants.BUFFER_CREATIONFLAG_INDEX = 16;
Constants.BUFFER_CREATIONFLAG_STORAGE = 32;
Constants.RENDERPASS_MAIN = 0;
Constants.INPUT_ALT_KEY = 18;
Constants.INPUT_CTRL_KEY = 17;
Constants.INPUT_META_KEY1 = 91;
Constants.INPUT_META_KEY2 = 92;
Constants.INPUT_META_KEY3 = 93;
Constants.INPUT_SHIFT_KEY = 16;
Constants.SNAPSHOTRENDERING_STANDARD = 0;
Constants.SNAPSHOTRENDERING_FAST = 1;
Constants.PERSPECTIVE_CAMERA = 0;
Constants.ORTHOGRAPHIC_CAMERA = 1;
Constants.FOVMODE_VERTICAL_FIXED = 0;
Constants.FOVMODE_HORIZONTAL_FIXED = 1;
Constants.RIG_MODE_NONE = 0;
Constants.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
Constants.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
Constants.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
Constants.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
Constants.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
Constants.RIG_MODE_VR = 20;
Constants.RIG_MODE_WEBVR = 21;
Constants.RIG_MODE_CUSTOM = 22;
Constants.MAX_SUPPORTED_UV_SETS = 6;
Constants.GL_ALPHA_EQUATION_ADD = 32774;
Constants.GL_ALPHA_EQUATION_MIN = 32775;
Constants.GL_ALPHA_EQUATION_MAX = 32776;
Constants.GL_ALPHA_EQUATION_SUBTRACT = 32778;
Constants.GL_ALPHA_EQUATION_REVERSE_SUBTRACT = 32779;
Constants.GL_ALPHA_FUNCTION_SRC = 768;
Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR = 769;
Constants.GL_ALPHA_FUNCTION_SRC_ALPHA = 770;
Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA = 771;
Constants.GL_ALPHA_FUNCTION_DST_ALPHA = 772;
Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA = 773;
Constants.GL_ALPHA_FUNCTION_DST_COLOR = 774;
Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR = 775;
Constants.GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED = 776;
Constants.GL_ALPHA_FUNCTION_CONSTANT_COLOR = 32769;
Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR = 32770;
Constants.GL_ALPHA_FUNCTION_CONSTANT_ALPHA = 32771;
Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA = 32772;
Constants.SnippetUrl = "https://snippet.babylonjs.com";

export {
  AbstractScene,
  AbstractActionManager,
  EventState,
  Observer,
  Observable,
  Scalar,
  ToGammaSpace,
  ToLinearSpace,
  PHI,
  Epsilon,
  ArrayTools,
  RegisterClass,
  GetClass,
  PerformanceConfigurator,
  EngineStore,
  Vector2,
  Vector3,
  Vector4,
  Quaternion,
  Matrix,
  TmpVectors,
  Color3,
  Color4,
  TmpColors,
  ActionEvent,
  Logger,
  DeepCopier,
  AndOrNotEvaluator,
  Tags,
  _WarnImport,
  expandToProperty,
  serialize,
  serializeAsTexture,
  serializeAsColor3,
  serializeAsFresnelParameters,
  serializeAsVector2,
  serializeAsVector3,
  serializeAsMeshReference,
  serializeAsColorCurves,
  serializeAsColor4,
  serializeAsImageProcessingConfiguration,
  serializeAsQuaternion,
  serializeAsMatrix,
  serializeAsCameraReference,
  SerializationHelper,
  nativeOverride,
  AnimationKeyInterpolation,
  AnimationRange,
  __decorate,
  Node,
  Size,
  WebRequest,
  _IAnimationState,
  Animation,
  IsWindowObjectExist,
  IsNavigatorAvailable,
  IsDocumentAvailable,
  GetDOMTextContent,
  DomManagement,
  PrecisionDate,
  FilesInputStore,
  RetryStrategy,
  BaseError,
  ErrorCodes,
  RuntimeError,
  EndsWith,
  StartsWith,
  Decode,
  EncodeArrayBufferToBase64,
  DecodeBase64ToString,
  DecodeBase64ToBinary,
  PadNumber,
  StringTools,
  ShaderLanguage,
  ShaderProcessor,
  ShaderStore,
  Effect,
  DepthCullingState,
  StencilState,
  AlphaState,
  TextureSampler,
  InternalTextureSource,
  InternalTexture,
  WebGL2ShaderProcessor,
  DataBuffer,
  WebGLDataBuffer,
  WebGLPipelineContext,
  WebGLHardwareTexture,
  DrawWrapper,
  StencilStateComposer,
  ThinEngine,
  TimingTools,
  LoadFileError,
  RequestFileError,
  ReadFileError,
  FileToolsOptions,
  SetCorsBehavior,
  LoadImage,
  ReadFile,
  LoadFile,
  RequestFile,
  IsFileURL,
  IsBase64DataUrl,
  TestBase64DataUrl,
  DecodeBase64UrlToBinary,
  DecodeBase64UrlToString,
  FileTools,
  _injectLTSFileTools,
  RandomGUID,
  GUID,
  Tools,
  className,
  AsyncLoop,
  SmartArray,
  SmartArrayNoDuplicate,
  StringDictionary,
  MaterialDefines,
  ColorCurves,
  ImageProcessingConfigurationDefines,
  ImageProcessingConfiguration,
  UniformBuffer,
  Buffer,
  VertexBuffer,
  PickingInfo,
  PostProcessManager,
  RenderingGroup,
  RenderingGroupInfo,
  RenderingManager,
  SceneComponentConstants,
  Stage,
  PointerEventTypes,
  PointerInfoBase,
  PointerInfoPre,
  PointerInfo,
  KeyboardEventTypes,
  KeyboardInfo,
  KeyboardInfoPre,
  DeviceType,
  PointerInput,
  NativePointerInput,
  DualShockInput,
  DualSenseInput,
  XboxInput,
  SwitchInput,
  DeviceInputEventType,
  EventConstants,
  DeviceSource,
  DeviceSourceManager,
  PerfCounter,
  Plane,
  Frustum,
  UniqueIdGenerator,
  LightConstants,
  ScenePerformancePriority,
  Scene,
  Space,
  Axis,
  Coordinate,
  Orientation,
  BezierCurve,
  Angle,
  Arc2,
  Path2,
  Path3D,
  Curve3,
  TargetedAnimation,
  AnimationGroup,
  inlineScheduler,
  createYieldingScheduler,
  runCoroutine,
  runCoroutineSync,
  runCoroutineAsync,
  makeSyncFunction,
  makeAsyncFunction,
  Viewport,
  Camera,
  VertexData,
  IntersectionInfo,
  BoundingBox,
  BoundingSphere,
  BoundingInfo,
  extractMinAndMaxIndexed,
  extractMinAndMax,
  SubMesh,
  SceneLoaderFlags,
  CompatibilityOptions,
  Geometry,
  PerformanceMonitor,
  RollingAverage,
  allocateAndCopyTypedBuffer,
  Engine,
  TransformNode,
  _MeshCollisionData,
  AbstractMesh,
  addClipPlaneUniforms,
  prepareDefinesForClipPlanes,
  bindClipPlane,
  MaterialHelper,
  MaterialPluginEvent,
  Material,
  MultiMaterial,
  MeshLODLevel,
  _CreationDataStorage,
  _InstancesBatch,
  Mesh,
  ThinTexture,
  BaseTexture,
  GenerateBase64StringFromPixelData,
  GenerateBase64StringFromTexture,
  GenerateBase64StringFromTextureAsync,
  CopyTools,
  Texture,
  SceneLoaderAnimationGroupLoadingMode,
  SceneLoader,
  PushMaterial,
  PositionNormalVertex,
  PositionNormalTextureVertex,
  EffectFallbacks,
  RenderTargetWrapper,
  PostProcess,
  EffectRenderer,
  EffectWrapper,
  DumpTools,
  RenderTargetTexture,
  Light,
  HemisphericLight,
  PrePassConfiguration,
  MaterialFlags,
  MaterialPluginManager,
  RegisterMaterialPlugin,
  UnregisterMaterialPlugin,
  UnregisterAllMaterialPlugins,
  MaterialPluginBase,
  MaterialDetailMapDefines,
  DetailMapConfiguration,
  StandardMaterialDefines,
  StandardMaterial,
  ShaderMaterial,
  Constants
};
//# sourceMappingURL=chunk-PPM2REY6.js.map
